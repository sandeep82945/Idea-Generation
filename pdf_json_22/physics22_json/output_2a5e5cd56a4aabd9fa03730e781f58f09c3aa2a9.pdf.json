{
    "abstractText": "We construct a discrete subset of Narain CFTs from quantum stabilizer codes with qudit (including qubit) systems whose dimension is a prime number. Our construction exploits three important relations. The first relation is between qudit stabilizer codes and classical codes. The second is between classical codes and Lorentzian lattices. The third is between Lorentzian lattices and Narain CFTs. In particular, we study qudit CalderbankShor-Steane (CSS) codes as a special class of qudit stabilizer codes and the ensembles of the Narain code CFTs constructed from CSS codes. We obtain exact results for the averaged partition functions over the ensembles and discuss their implications for holographic duality. Copyright K. Kawabata et al. This work is licensed under the Creative Commons Attribution 4.0 International License. Published by the SciPost Foundation. Received 12-01-2023 Accepted 20-03-2023 Published 26-04-2023 Check for updates doi:10.21468/SciPostPhysCore.6.2.035",
    "authors": [
        {
            "affiliations": [],
            "name": "Kohki Kawabata"
        },
        {
            "affiliations": [],
            "name": "Tatsuma Nishioka"
        },
        {
            "affiliations": [],
            "name": "Takuya Okuda"
        }
    ],
    "id": "SP:507c514bf781499d54a9120e154f2da6feaf3fcf",
    "references": [
        {
            "authors": [
                "I.B. Frenkel",
                "J. Lepowsky",
                "A. Meurman"
            ],
            "title": "A natural representation of the Fischer-Griess monster with the modular function J as character",
            "venue": "Proc. Natl. Acad. Sci. 81, 3256 (1984), doi:10.1073/pnas.81.10.3256. 39 SciPost Phys. Core 6, 035 ",
            "year": 2023
        },
        {
            "authors": [
                "I. Frenkel",
                "J. Lepowsky",
                "A. Meurman"
            ],
            "title": "Vertex operator algebras and the monster",
            "venue": "Academic Press, Cambridge, USA, ISBN 9780080874548 ",
            "year": 1989
        },
        {
            "authors": [
                "L. Dolan",
                "P. Goddard",
                "P. Montague"
            ],
            "title": "Conformal field theories",
            "venue": "representations and lattice constructions, Commun. Math. Phys. 179, 61 ",
            "year": 1996
        },
        {
            "authors": [
                "A. Dymarsky",
                "A. Shapere"
            ],
            "title": "Quantum stabilizer codes",
            "venue": "lattices, and CFTs, J. High Energy Phys. 03, 160 (2021), doi:10.1007/JHEP03",
            "year": 2021
        },
        {
            "authors": [
                "D. Gottesman"
            ],
            "title": "Fault tolerant quantum computation with higher dimensional systems",
            "venue": "Chaos Solit. Fractals 10, 1749 ",
            "year": 1016
        },
        {
            "authors": [
                "D. Gottesman"
            ],
            "title": "Class of quantum error-correcting codes saturating the quantum Hamming bound",
            "venue": "Phys. Rev. A 54, 1862 ",
            "year": 1996
        },
        {
            "authors": [
                "A.R. Calderbank",
                "E.M. Rains",
                "P.W. Shor",
                "N.J.A. Sloane"
            ],
            "title": "Quantum error correction and orthogonal geometry",
            "venue": "Phys. Rev. Lett. 78, 405 ",
            "year": 1997
        },
        {
            "authors": [
                "A.R. Calderbank",
                "E.M. Rains",
                "P.W. Shor",
                "N.J.A. Sloane"
            ],
            "title": "Quantum error correction via codes over GF(4)",
            "venue": "IEEE Trans. Inf. Theory 44, 1369 ",
            "year": 1998
        },
        {
            "authors": [
                "A. Ashikhmin",
                "E. Knill"
            ],
            "title": "Nonbinary quantum stabilizer codes",
            "venue": "IEEE Trans. Inf. Theory 47, 3065 ",
            "year": 2001
        },
        {
            "authors": [
                "S. Yahagi"
            ],
            "title": "Narain CFTs and error-correcting codes on finite fields",
            "venue": "J. High Energy Phys. 08, 058 (2022), doi:10.1007/JHEP08",
            "year": 2022
        },
        {
            "authors": [
                "A.R. Calderbank",
                "P.W. Shor"
            ],
            "title": "Good quantum error-correcting codes exist",
            "venue": "Phys. Rev. A 54, 1098 ",
            "year": 1996
        },
        {
            "authors": [
                "A. Steane"
            ],
            "title": "Multiple-particle interference and quantum error correction",
            "venue": "Proc. R. Soc. Lond., A: Math. Phys. Eng. Sci. 452, 2551 ",
            "year": 1996
        },
        {
            "authors": [
                "I. Siap",
                "D. Ray-Chaudhuri"
            ],
            "title": "On r-fold complete weight enumerators of r linear codes",
            "venue": "Algebra and its applications, American Mathematical Society, Providence, USA, ISBN 9780821819500 ",
            "year": 2000
        },
        {
            "authors": [
                "A. Maloney",
                "E. Witten"
            ],
            "title": "Averaging over Narain moduli space",
            "venue": "J. High Energy Phys. 10, 187 (2020), doi:10.1007/JHEP10",
            "year": 2020
        },
        {
            "authors": [
                "N. Afkhami-Jeddi",
                "H. Cohn",
                "T. Hartman",
                "A. Tajdini"
            ],
            "title": "Free partition functions and an averaged holographic duality",
            "venue": "J. High Energy Phys. 01, 130 (2021), doi:10.1007/JHEP01",
            "year": 2021
        },
        {
            "authors": [
                "A. Dymarsky",
                "A. Shapere"
            ],
            "title": "Comments on the holographic description of Narain theories",
            "venue": "J. High Energy Phys. 10, 197 (2021), doi:10.1007/JHEP10",
            "year": 2021
        },
        {
            "authors": [
                "V. Meruliya",
                "S. Mukhi",
                "P. Singh"
            ],
            "title": "Poincar\u00e9 series",
            "venue": "3d gravity and averages of rational CFT, J. High Energy Phys. 04, 267 (2021), doi:10.1007/JHEP04",
            "year": 2021
        },
        {
            "authors": [
                "S. Datta",
                "S. Duary",
                "P. Kraus",
                "P. Maity",
                "A. Maloney"
            ],
            "title": "Adding flavor to the Narain ensemble",
            "venue": "J. High Energy Phys. 05, 090 (2022), doi:10.1007/JHEP05(2022)090. 40 SciPost Phys. Core 6, 035 ",
            "year": 2023
        },
        {
            "authors": [
                "N. Benjamin",
                "C.A. Keller",
                "H. Ooguri",
                "I.G. Zadeh"
            ],
            "title": "Narain to Narnia",
            "venue": "Commun. Math. Phys. 390, 425 ",
            "year": 2021
        },
        {
            "authors": [
                "V. Meruliya",
                "S. Mukhi"
            ],
            "title": "AdS3 gravity and RCFT ensembles with multiple invariants",
            "venue": "J. High Energy Phys. 08, 098 (2021), doi:10.1007/JHEP08",
            "year": 2021
        },
        {
            "authors": [
                "M. Ashwinkumar",
                "M. Dodelson",
                "A. Kidambi",
                "J.M. Leedom",
                "M. Yamazaki"
            ],
            "title": "Chern- Simons invariants from ensemble averages",
            "venue": "J. High Energy Phys. 08, 044 (2021), doi:10.1007/JHEP08",
            "year": 2021
        },
        {
            "authors": [
                "J. Dong",
                "T. Hartman",
                "Y. Jiang"
            ],
            "title": "Averaging over moduli in deformed WZW models",
            "venue": "J. High Energy Phys. 09, 185 (2021), doi:10.1007/JHEP09",
            "year": 2021
        },
        {
            "authors": [
                "D. Das",
                "S. Datta"
            ],
            "title": "Higher spin wormholes from modular bootstrap",
            "venue": "J. High Energy Phys. 10, 010 (2021), doi:10.1007/JHEP10",
            "year": 2021
        },
        {
            "authors": [
                "S. Collier",
                "A. Maloney"
            ],
            "title": "Wormholes and spectral statistics in the Narain ensemble",
            "venue": "J. High Energy Phys. 03, 004 (2022), doi:10.1007/JHEP03",
            "year": 2022
        },
        {
            "authors": [
                "N. Benjamin",
                "S. Collier",
                "A.L. Fitzpatrick",
                "A. Maloney",
                "E. Perlmutter"
            ],
            "title": "Harmonic analysis of 2d CFT partition functions",
            "venue": "J. High Energy Phys. 09, 174 (2021), doi:10.1007/JHEP09",
            "year": 2021
        },
        {
            "authors": [
                "J. Raeymaekers"
            ],
            "title": "A note on ensemble holography for rational tori",
            "venue": "J. High Energy Phys. 12, 177 (2021), doi:10.1007/JHEP12",
            "year": 2021
        },
        {
            "authors": [
                "N. Angelinos",
                "D. Chakraborty",
                "A. Dymarsky"
            ],
            "title": "Optimal Narain CFTs from codes",
            "venue": "J. High Energy Phys. 11, 118 (2022), doi:10.1007/JHEP11",
            "year": 2022
        },
        {
            "authors": [
                "B. Runge"
            ],
            "title": "Codes and Siegel modular forms",
            "venue": "Discrete Math. 148, 175 ",
            "year": 1016
        },
        {
            "authors": [
                "M. Oura"
            ],
            "title": "Eisenstein polynomials associated to binary codes",
            "venue": "Int. J. Number Theory 5, 635 ",
            "year": 2009
        },
        {
            "authors": [
                "D. Miller"
            ],
            "title": "Small quantum networks in the qudit stabilizer formalism, (arXiv preprint) doi:10.48550/arXiv.1910.09551",
            "year": 1910
        },
        {
            "authors": [
                "M. Hamada"
            ],
            "title": "Notes on the fidelity of symplectic quantum error-correcting codes",
            "venue": "Int. J. Quantum Inf. 1, 443 ",
            "year": 2003
        },
        {
            "authors": [
                "M. Hamada"
            ],
            "title": "Reliability of Calderbank-Shor-Steane codes and security of quantum key distribution",
            "venue": "J. Phys. A: Math. Gen. 37, 8303 ",
            "year": 2004
        },
        {
            "authors": [
                "E. Knill"
            ],
            "title": "Group representations",
            "venue": "error bases and quantum codes, (arXiv preprint) doi:10.48550/arXiv.quant-ph/9608049. 41 SciPost Phys. Core 6, 035 ",
            "year": 2023
        },
        {
            "authors": [
                "E.M. Rains"
            ],
            "title": "Nonbinary quantum codes",
            "venue": "IEEE Trans. Inf. Theory 45, 1827 ",
            "year": 1999
        },
        {
            "authors": [
                "M.A. Nielsen",
                "I.L. Chuang"
            ],
            "title": "Quantum computation and quantum information",
            "venue": "Cambridge University Press, Cambridge, UK, ISBN 9781107002173 ",
            "year": 2010
        },
        {
            "authors": [
                "F.J. MacWilliams",
                "N.J.A. Sloane"
            ],
            "title": "The theory of error correcting codes",
            "venue": "Elsevier, Amsterdam, Netherlands, ISBN 9780444850096 ",
            "year": 1977
        },
        {
            "authors": [
                "D. Welsh"
            ],
            "title": "Codes and cryptography",
            "venue": "Oxford University Press, Oxford, UK, ISBN 9780198532873 ",
            "year": 1988
        },
        {
            "authors": [
                "J.H. Conway",
                "N.J.A. Sloane"
            ],
            "title": "Sphere packings",
            "venue": "lattices and groups, Springer, New York, USA, ISBN 9780387985855 ",
            "year": 1998
        },
        {
            "authors": [
                "J. Justesen",
                "T. H\u00f8holdt"
            ],
            "title": "A course in error-correcting codes",
            "venue": "European Mathematical Society, Helsinki, Finland, ISBN 9783037191798 ",
            "year": 2004
        },
        {
            "authors": [
                "N.D. Elkies"
            ],
            "title": "Lattices",
            "venue": "linear codes, and invariants, part I, Not. AMS 47, 10 ",
            "year": 2000
        },
        {
            "authors": [
                "N.D. Elkies"
            ],
            "title": "Lattices",
            "venue": "linear codes, and invariants, part II, Not. AMS 47, 11 ",
            "year": 2000
        },
        {
            "authors": [
                "A. Almheiri",
                "X. Dong",
                "D. Harlow"
            ],
            "title": "Bulk locality and quantum error correction in AdS/CFT",
            "venue": "J. High Energy Phys. 04, 163 (2015), doi:10.1007/JHEP04",
            "year": 2015
        },
        {
            "authors": [
                "K.S. Narain"
            ],
            "title": "New heterotic string theories in uncompactified dimensions < 10",
            "venue": "Phys. Lett. B 169, 41 ",
            "year": 2693
        },
        {
            "authors": [
                "K.S. Narain",
                "M.H. Sarmadi",
                "E. Witten"
            ],
            "title": "A note on toroidal compactification of heterotic string theory",
            "venue": "Nucl. Phys. B 279, 369 ",
            "year": 1016
        },
        {
            "authors": [
                "J. Polchinski"
            ],
            "title": "String theory",
            "venue": "Vol. 1: An introduction to the bosonic string, Cambridge University Press, Cambridge, UK, ISBN 9780511816079 ",
            "year": 1998
        },
        {
            "authors": [
                "J. Polchinski"
            ],
            "title": "String theory",
            "venue": "Vol. 2: Superstring theory and beyond, Cambridge University Press, Cambridge, UK, ISBN 9780511618123 ",
            "year": 1998
        },
        {
            "authors": [
                "G. Nebe",
                "E.M. Rains",
                "N.J.A. Sloane"
            ],
            "title": "Self-dual codes and invariant theory",
            "venue": "Springer, Berlin, Heidelberg, Germany, ISBN 9783540307297 ",
            "year": 2006
        },
        {
            "authors": [
                "F.J. MacWilliams"
            ],
            "title": "Combinatorial problems of elementary group theory",
            "venue": "PhD thesis, Harvard University, Cambridge, USA ",
            "year": 1962
        },
        {
            "authors": [
                "F.J. MacWilliams"
            ],
            "title": "A theorem on the distribution of weights in a systematic code",
            "venue": "Bell Syst. Tech. J. 42, 79 (1963), doi:10.1002/j.1538-7305.1963.tb04003.x. 42 SciPost Phys. Core 6, 035 ",
            "year": 2023
        },
        {
            "authors": [
                "F.J. MacWilliams",
                "N.J. Sloane",
                "J.G. Thompson"
            ],
            "title": "Good self dual codes exist",
            "venue": "Discrete Math. 3, 153 ",
            "year": 1016
        },
        {
            "authors": [
                "V. Pless"
            ],
            "title": "On the uniqueness of the Golay codes",
            "venue": "J. Comb. Theory 5, 215 ",
            "year": 1016
        },
        {
            "authors": [
                "A. Bassa",
                "N. Tuta\u015f"
            ],
            "title": "Extending self-orthogonal codes",
            "venue": "Turk. J. Math. 43, 2177 ",
            "year": 2019
        },
        {
            "authors": [
                "J. Korevaar"
            ],
            "title": "Tauberian theory: A century of developments",
            "venue": "Springer, Berlin, Heidelberg, Germany, ISBN 9783540210580 ",
            "year": 2004
        },
        {
            "authors": [
                "P. Saad",
                "S.H. Shenker",
                "D. Stanford"
            ],
            "title": "JT gravity as a matrix integral, (arXiv preprint) doi:10.48550/arXiv.1903.11115",
            "year": 1903
        },
        {
            "authors": [
                "G.W. Moore",
                "N. Seiberg"
            ],
            "title": "Classical and quantum conformal field theory",
            "venue": "Commun. Math. Phys. 123, 177 ",
            "year": 1989
        },
        {
            "authors": [
                "M. Buican",
                "A. Dymarsky",
                "R. Radhakrishnan"
            ],
            "title": "Quantum codes",
            "venue": "CFTs, and defects, J. High Energy Phys. 03, 17 (2023), doi:10.1007/JHEP03",
            "year": 2023
        },
        {
            "authors": [
                "Y. Furuta"
            ],
            "title": "Relation between spectra of Narain CFTs and properties of associated boolean functions",
            "venue": "J. High Energy Phys. 09, 146 (2022), doi:10.1007/JHEP09",
            "year": 2022
        },
        {
            "authors": [
                "A. Dymarsky",
                "A. Sharon"
            ],
            "title": "Non-rational Narain CFTs from codes over F4",
            "venue": "J. High Energy Phys. 11, 016 (2021), doi:10.1007/JHEP11",
            "year": 2021
        },
        {
            "authors": [
                "A. Dymarsky",
                "A. Shapere"
            ],
            "title": "Solutions of modular bootstrap constraints from quantum codes",
            "venue": "Phys. Rev. Lett. 126, 161602 ",
            "year": 2021
        },
        {
            "authors": [
                "J. Henriksson",
                "A. Kakkar",
                "B. McPeak"
            ],
            "title": "Classical codes and chiral CFTs at higher genus",
            "venue": "J. High Energy Phys. 05, 159 (2022), doi:10.1007/JHEP05",
            "year": 2022
        },
        {
            "authors": [
                "J. Henriksson",
                "A. Kakkar",
                "B. McPeak"
            ],
            "title": "Narain CFTs and quantum codes at higher genus",
            "venue": "J. High Energy Phys. 03, 17 (2023), doi:10.1007/JHEP03",
            "year": 2023
        }
    ],
    "sections": [
        {
            "text": "We construct a discrete subset of Narain CFTs from quantum stabilizer codes with qudit (including qubit) systems whose dimension is a prime number. Our construction exploits three important relations. The first relation is between qudit stabilizer codes and classical codes. The second is between classical codes and Lorentzian lattices. The third is between Lorentzian lattices and Narain CFTs. In particular, we study qudit CalderbankShor-Steane (CSS) codes as a special class of qudit stabilizer codes and the ensembles of the Narain code CFTs constructed from CSS codes. We obtain exact results for the averaged partition functions over the ensembles and discuss their implications for holographic duality.\nCopyright K. Kawabata et al. This work is licensed under the Creative Commons Attribution 4.0 International License. Published by the SciPost Foundation.\nReceived 12-01-2023 Accepted 20-03-2023 Published 26-04-2023\nCheck for updates\ndoi:10.21468/SciPostPhysCore.6.2.035\nContents"
        },
        {
            "heading": "1 Introduction 2",
            "text": ""
        },
        {
            "heading": "2 Qudit stabilizer codes 4",
            "text": "2.1 Qudit system 5 2.2 Stabilizer codes 6\n2.2.1 Stabilizer formalism 6 2.2.2 Symplectic representation 8 2.2.3 Code equivalence 9\n2.3 CSS codes 10"
        },
        {
            "heading": "3 Construction of Lorentzian even self-dual lattices 12",
            "text": "3.1 Lorentzian lattices via Construction A 12 3.2 Even self-dual lattices 14 3.3 CSS construction 17"
        },
        {
            "heading": "4 Narain code CFTs 18",
            "text": "4.1 Construction of Narain CFTs 19 4.2 Partition function 20\n4.3 Example: CSS construction 24"
        },
        {
            "heading": "5 Averaged partition function 26",
            "text": "5.1 Higher-genus weight enumerator 26 5.2 Average of higher-genus weight enumerator 28\n5.2.1 For p = 2 28 5.2.2 For odd prime p \u0338= 2 32\n5.3 Averaging over CSS codes 34"
        },
        {
            "heading": "6 Discussion 35",
            "text": ""
        },
        {
            "heading": "A List of notations 37",
            "text": ""
        },
        {
            "heading": "B Saddle point computation 39",
            "text": "References 39"
        },
        {
            "heading": "1 Introduction",
            "text": "The main goal of this paper is to construct a class of non-chiral conformal field theories (CFTs) from quantum error-correcting codes. It has been known for many years that a certain class of chiral CFTs can be constructed from classical error-correcting codes [1\u20133]. In recent years, an analogous construction for non-chiral CFTs has been developed in [4] based on a specific type of quantum error-correcting codes called qubit stabilizer codes, which results in a discrete subset of Narain CFTs named Narain code CFTs. We generalize this construction of Narain code CFTs to qudit stabilizer codes. The qudit system is a natural generalization of the qubit system to higher dimensions with d-level quantum states |x\u232a (x = 0, 1, \u00b7 \u00b7 \u00b7 , d \u2212 1). Quantum errorcorrecting codes with qudit systems can be formulated in the same way [5] as in the binary case [6,7]. In this paper, we extend the construction from binary systems to d-ary systems for d = p being a prime number.\nWe establish the relationship between qudit stabilizer codes, Lorentzian lattices, and Narain code CFTs in a similar manner to the binary case [4].1 To this end, we leverage the following results in the literature:\n\u2022 Some qudit stabilizer codes are associated with classical codes [8\u201310].\n\u2022 Some Lorentzian lattices can be constructed from classical p-ary codes [11].\nWe combine these ingredients to construct Lorentzian lattices from qudit stabilizer codes (see figure 1). Then, we define a Narain code CFT by regarding each resulting Lorentzian lattice as the momentum lattice of the CFT. We show that the modular invariance of the Narain code CFT is guaranteed by certain conditions satisfied by the stabilizer code or equivalently by the classical code. The correspondences between qudit codes, Lorentzian lattices, and Narain CFTs are summarized in table 1.\nIn particular, our construction reveals a concrete relation among certain functions associated with codes, lattices, and CFTs. Let C be the classical code that specifies a qudit stabilizer\n1While our construction closely follows the one in [4], there is a major difference between the binary and p-ary cases with odd-prime p. In our construction, equivalent qudit stabilizer codes do not necessarily yield the same Narain code CFT unless p = 2. See the comment in section 2.2.3 for more details.\nQudit stabilizer codes Classical codes C Lorentzian lattices e\u039b(C)\ncode. Then the CFT torus partition function ZC(\u03c4, \u03c4\u0304), the lattice theta function \u0398e\u039b(C)(\u03c4, \u03c4\u0304) for the lattice e\u039b(C), and the complete enumerator polynomial WC({xab}) of C are related as\nZC(\u03c4, \u03c4\u0304) = \u0398 e\u039b(C)(\u03c4, \u03c4\u0304)\n|\u03b7(\u03c4)|2n = 1 |\u03b7(\u03c4)|2n WC({\u03c8ab}) . (1)\nHere \u03c4 is the modulus of the torus, \u03b7 is the Dedekind eta function, and \u03c8ab are functions of \u03c4 and \u03c4\u0304.2 Thus the spectrum of the CFT can be read off from any of the three functions.\nWhile our construction of Narain code CFTs is limited to a part of qudit stabilizer codes, it can be applied to an important class of quantum codes known as qudit Calderbank-ShorSteane (CSS) codes. The CSS codes are quantum error-correcting codes defined by a pair (C (1), C (2)) of classical codes [12, 13]. In this sense, CSS codes form a subset of quantum codes closely related to classical codes. Therefore, we can exploit the fundamental features of classical linear codes to analyze the CSS codes. Let us consider a CSS code defined by the pair (C (1), C (2)) = (C , C\u22a5) for a classical code C , where C\u22a5 is the dual code of C . Then, a Narain code CFT associated with the CSS code can be constructed, whose partition function is uniquely determined by the complete joint weight enumerator WC ({xab}) of C and C\u22a5 introduced in [14]:\nZ (CSS) C ,C\u22a5\n(\u03c4, \u03c4\u0304) = 1\n|\u03b7(\u03c4)|2n WC ({\u03c8ab}) , (2)\nwhere C = C \u00d7 C\u22a5. The complete joint weight enumerator was originally introduced in the study of classical codes. We will also give a few simple examples for Narain code CFTs based on CSS codes and exemplify our construction in more detail in section 4.3.\nTo investigate the universal aspects of the Narain code CFTs we construct, we consider the partition functions averaged over a class of CSS codes. Recently, ensemble averaging of Narain CFTs has attracted much attention with a view to seeking a holographic duality [15, 16] (see [17\u201329] for related works). In this paper, we focus on CSS codes C given by\n2Explicitly, \u03c8ab(\u03c4, \u03c4\u0304) are defined in (90) and can be rewritten as (95).\n(C (1), C (2)) = (C , C) and average over self-dual classical codes C . The partition function of the Narain code CFT based on a single such CSS code C turns out to be the genus-2 complete enumerator polynomial W2,C({xab}) of the self-dual code C:\nZ (CSS)C ,C (\u03c4, \u03c4\u0304) = 1\n|\u03b7(\u03c4)|2n W2,C ({\u03c8ab}) . (3)\nThen, the average over self-dual codes takes the form\nZ (CSS) n,p (\u03c4, \u03c4\u0304) := 1 |Mn,p| \u2211\nC \u2208Mn,p\nZ (CSS)C ,C (\u03c4, \u03c4\u0304) = 1 |\u03b7(\u03c4)|2n 1 |Mn,p| \u2211\nC \u2208Mn,p\nW2,C({\u03c8ab}) , (4)\nwhere Mn,p is the set of all classical p-ary self-dual codes of length n. Hence, our problem amounts to calculating the average of the enumerator polynomials over self-dual codes C .\nWhile we are mainly concerned with the genus-2 case, we address the more general problems of calculating the average of the genus-g complete enumerator polynomial Wg,C over the set Mn,p ,\nE(g)n,p({xv}) = 1 |Mn,p| \u2211\nC \u2208Mn,p\nWg,C({xv}) . (5)\nThe formula for the average of the genus-g complete enumerator polynomial over doublyeven self-dual codes was given in [30, 31]. To our best knowledge, however, the averaged genus-g complete enumerator polynomial for self-dual codes has not been derived yet. The properties of classical self-dual codes allow us to explicitly write down the formula for p = 2 in Theorem 5.2 and for odd prime p in Theorem 5.4. Therefore, focusing on the genus-2 case, we obtain the exact averaged partition functions (3) of the CSS codes. We find that the averaged partition function reproduces an averaged partition function conjectured in [28] for a similar but different ensemble of codes in the large central charge limit. We will discuss the implications of the averaged Narain code CFTs for holographic duality in section 6 along the line of [15,16].\nThe organization of this paper is as follows. In section 2, we review the qudit stabilizer formalism and in particular the symplectic representation that we use. After introducing these elements, we concretely illustrate qudit codes by giving some examples of CSS codes. In section 3, we examine the conditions for a qudit stabilizer code to yield an even self-dual lattice and point out that a class of CSS codes satisfies the conditions automatically. In section 4, the resulting Lorentzian even self-dual lattices are lifted to Narain code CFTs, and the dictionary between codes, lattices, and CFTs is given. In section 5, we consider the averaged theory of Narain code CFTs. We give the general formula for the average of the higher-genus weight enumerators, which reduces to the averaged partition function for g = 2. We point out that our result exactly agrees with the conjectural partition function of the averaged theory associated with error-correcting codes in [28]. Section 6 concludes with discussions and future directions. Appendix A lists our notations used throughout this paper. In appendix B, we give details for a saddle point computation in section 5."
        },
        {
            "heading": "2 Qudit stabilizer codes",
            "text": "In this section, we will review quantum error correction on qudit systems, which is the generalization of a qubit to higher dimensions following [5,32,33]. We illustrate quantum errorcorrecting codes focusing on stabilizer codes in section 2.2. In section 2.3, we introduce CSS codes, a class of stabilizer codes constructed from a pair of classical codes. We will see later that CSS codes are compatible with our construction of Narain CFTs."
        },
        {
            "heading": "2.1 Qudit system",
            "text": "We consider a d-level quantum system called a qudit system (refer to Appendix A.1 in [34] and section 2 in [35]). For simplicity, we set the number of states with the qudit system as a prime d = p. Then, a qudit state takes over a finite field Fp = Z/pZ. An orthonormal basis on a qudit system Hp is given by {|x\u232a} x=p\u22121 x=0 . The elementary actions on the Hilbert space Hp are given by\nXp |x\u232a= |x + 1\u232a , Zp |x\u232a=\u03c9xp |x\u232a , (6)\nwhere \u03c9p = e2\u03c0i/p and x \u2208 Fp: x \u223c x + p. These operators are called the qudit Pauli X and Z operator [5]. The qudit Pauli operators are represented by\nXp = p\u22121 \u2211\nx=0\n|x + 1\u232a \u2329x | , Zp = p\u22121 \u2211\nx=0\n\u03c9xp |x\u232a \u2329x | . (7)\nTherefore, we have the following commutation relation:\nZpXp =\u03c9p XpZp . (8)\nFor example, these operators become Pauli X and Pauli Z when the system is a qubit (p = 2). In the case of a qutrit (p = 3), these operators are 3\u00d7 3 matrices.\nX3 =\n\n \n0 0 1\n1 0 0\n0 1 0\n\n  , Z3 =\n\n \n1 0 0\n0 \u03c93 0 0 0 \u03c923\n\n  , (9)\nwhere \u03c93 = e2\u03c0i/3. We define generalized Pauli operators that act on a qudit system as\ng(\u03b1,\u03b2) =\u03c9\u03ba X\u03b1p Z \u03b2 p =\u03c9 \u03ba\np\u22121 \u2211\nx=0\n\u03c9x\u03b2p |x +\u03b1\u232a \u2329x | , (10)\nwhere \u03b1,\u03b2 \u2208 Fp = {0,1, \u00b7 \u00b7 \u00b7 , p \u2212 1}. We suppress the dependence on \u03ba in g(\u03b1,\u03b2) because it plays no role for our construction of Narain CFTs. The global phase factor is given by\n\u03c9\u03ba =\ni\u03ba , if p = 2 , \u03c9\u03bap , if p odd prime , (11)\nwhere \u03ba \u2208 {0, 1,2, 3} for p = 2 and \u03ba \u2208 Fp for an odd prime. This ensures that there exists a choice of \u03ba in operators g(\u03b1,\u03b2) such that g(\u03b1,\u03b2)p = 1 for any \u03b1,\u03b2 \u2208 Fp [5]. There are p2 operators up to phases, which act on a qudit system in an analogous way to four operators {I , X , Y, Z} in a qubit system. The commutation relations are\ng(\u03b1,\u03b2)g(\u03b1\u2032,\u03b2 \u2032) =\u03c9\u2212\u03b1\u03b2 \u2032+\u03b2\u03b1\u2032 p g(\u03b1 \u2032,\u03b2 \u2032)g(\u03b1,\u03b2) . (12)\nThen two operators commute if and only if \u03b1\u03b2 \u2032 \u2212 \u03b2\u03b1\u2032 = 0 mod p. We can easily generalize this representation to the n-qudit system. An orthonormal basis in the n-qudit system is the n-fold tensor products of {|x\u232a}x=p\u22121x=0 . The p 2n operators that act on the n-qudit system are given by\ng(\u03b1,\u03b2) = g(\u03b11,\u03b21)\u2297 \u00b7 \u00b7 \u00b7 \u2297 g(\u03b1n,\u03b2n) =\u03c9\u03ba X\u03b11p Z \u03b21 p \u2297 \u00b7 \u00b7 \u00b7 \u2297 X \u03b1n p Z \u03b2n p , (13)\nwhere \u03b1= (\u03b11, \u00b7 \u00b7 \u00b7 ,\u03b1n) \u2208 Fnp, \u03b2 = (\u03b21, \u00b7 \u00b7 \u00b7 ,\u03b2n) \u2208 F n p and the global phase is given by (11). We call the group that acts on the n-qudit system the n-qudit Pauli group P(p)n . For odd prime p, the elements of P(p)n have eigenvalues\u03c9ip for i = 0, 1, \u00b7 \u00b7 \u00b7 , p\u22121. For the case of qubits (p = 2), the group P(2)n consists of all n-fold tensor products of the Pauli matrices multiplied by \u00b11 or \u00b1i. These elements have eigenvalues of either \u00b11 or \u00b1i. The commutation relations are given by\ng(\u03b1,\u03b2) g(\u03b1\u2032,\u03b2 \u2032) =\u03c9\u2212\u03b1\u00b7\u03b2 \u2032+\u03b2 \u00b7\u03b1\u2032 p g(\u03b1 \u2032,\u03b2 \u2032) g(\u03b1,\u03b2) , (14)\nwhere we introduce the dot product\n\u03b1 \u00b7 \u03b2 = (\u03b11, \u00b7 \u00b7 \u00b7 ,\u03b1n) \u00b7 (\u03b21, \u00b7 \u00b7 \u00b7 ,\u03b2n) = n \u2211\ni=1\n\u03b1i\u03b2i , (15)\nwhere arithmetic is performed in Fp (modulo p). It may be useful to introduce the following symplectic product [8]:\n\u2329(\u03b1,\u03b2), (\u03b1\u2032,\u03b2 \u2032)\u232a= \u03b1 \u00b7 \u03b2 \u2032 \u2212 \u03b2 \u00b7\u03b1\u2032. (16)\nThen, the commutation relations imply that a pair of operators g(\u03b1,\u03b2), g(\u03b1\u2032,\u03b2 \u2032) commute each other if and only if the symplectic product vanishes: \u2329(\u03b1,\u03b2), (\u03b1\u2032,\u03b2 \u2032)\u232a= 0 mod p."
        },
        {
            "heading": "2.2 Stabilizer codes",
            "text": "Error-correcting codes were invented to communicate with others via a noisy channel. We send an original message encoded as an appropriate signal to be able to correct some noise. In quantum error-correcting codes, we send a quantum state as an encoded signal. For specifying an encoded quantum state, some group theoretic methods are useful. Such a class of quantum codes is called stabilizer codes."
        },
        {
            "heading": "2.2.1 Stabilizer formalism",
            "text": "In order to understand stabilizer codes, we must develop a stabilizer formalism. The stabilizer formalism is convenient for representing the state vector compactly in a clever use of group theory. Stabilizer codes were originally considered for qubits by Gottesman [6]. After that, the notion of stabilizer codes was generalized to qudits in [36\u201338].\nSuppose that S is an abelian subgroup of P(p)n , called the stabilizer group. The set of valid codewords forms a subspace of the full n qudit Hilbert space, the code subspace of the quantum code. For a stabilizer group S, a code subspace VS is composed of states that are fixed by all elements of S: for |\u03c8\u232a \u2208 VS ,\ng |\u03c8\u232a= |\u03c8\u232a , g \u2208 S . (17)\nThe projector on the code subspace VS is given by\nPS = 1 |S| \u2211\ng\u2208S g . (18)\nActually, this operator satisfies P2S = PS due to the group structure of the stabilizer group S. A qubit stabilizer code with a nontrivial code subspace VS must have an abelian stabilizer group S that does not contain \u00b1i I [39]. A similar proposition holds for odd prime p.\nProposition 2.1 Let S be a subgroup of the n-qudit Pauli group P(p)n for odd prime p. The group S is an abelian group which does not contain \u03c9ip I (i = 1,2, \u00b7 \u00b7 \u00b7 , p \u2212 1) if the stabilizer code has a nontrivial code subspace VS .\nProof. In the following, we prove that a code subspace becomes trivial assuming that the stabilizer group is non-abelian or has a nontrivial multiple of the identity.\nFirstly, let us consider the case when a non-abelian subgroup S of P(p)n stabilizes a code subspace VS . Suppose that M , N \u2208 S stabilize a state |\u03c8\u232a \u2208 VS . Then |\u03c8\u232a = MN |\u03c8\u232a = \u03c9ip N M |\u03c8\u232a = \u03c9 i p |\u03c8\u232a for some i \u2208 {1,2, \u00b7 \u00b7 \u00b7 , p \u2212 1}. This implies the encoded state |\u03c8\u232a is trivial: |\u03c8\u232a = 0. Next, assume that an abelian stabilizer group S contains a nontrivial multiple of identity. Then we have \u03c9ip I \u2208 S where i = 1, 2, \u00b7 \u00b7 \u00b7 , p \u2212 1, so VS \u220b |\u03c8\u232a=\u03c9ip I |\u03c8\u232a=\u03c9 i p |\u03c8\u232a. We conclude that |\u03c8\u232a= 0.\nThe stabilizer group can be characterized by n \u2212 k independent generators g1, \u00b7 \u00b7 \u00b7 , gn\u2212k. More concretely, the stabilizer group is generated by g (\u03b1(1),\u03b2 (1)), \u00b7 \u00b7 \u00b7 , g (\u03b1(n\u2212k),\u03b2 (n\u2212k)) on an n qudit system where (\u03b1(i),\u03b2 (i)) \u2208 Fnp\u00d7F n p specifies the generators of the stabilizer group. The stabilizer generator gi \u2208 S divides the entire pn-dimensional Hilbert space into p subspaces of equal dimension by its eigenvalue. Since there are (n \u2212 k) stabilizer generators, VS is a pk-dimensional vector space. In this case, a stabilizer code is called [[n, k]]p code.\nStabilizer groups S stabilize states in the code subspace VS . On the other hand, there are operators that change states from the code subspace into other states in the code subspace. These operators are called logical operators. Logical operators do not map the encoded state |\u03c8\u232a \u2208 VS into a non-code subspace. It follows that stabilizer operators and logical operators commute. Let us illustrate this fact. Suppose that an operator EL does not commute with a stabilizer operator g \u2208 S. Then we have\ng EL |\u03c8\u232a=\u03c9\u03ba EL g |\u03c8\u232a=\u03c9\u03ba EL |\u03c8\u232a , |\u03c8\u232a \u2208 VS , (19)\nwhere the phase factor is nontrivial (\u03ba \u0338= 0). The stabilizer operator g \u2208 S does not stabilize the state EL |\u03c8\u232a and then EL |\u03c8\u232a /\u2208 VS . This implies that if an operator EL does not commute with a stabilizer operator, then the action of EL on a coding state |\u03c8\u232a \u2208 VS put into a noncode subspace: EL |\u03c8\u232a /\u2208 VS . Therefore, to stay in a code subspace under the action of an operator EL , this operator EL has to commute with a stabilizer group S.\nWe can write logical operators as the n-fold tensor products (13). Since the number of all operators that act on k qudits is p2k up to global phase factors, the same number of logical operators act on the encoded subspace. Then, we have 2k generators of such transformations. There are p2n operators that act on the n-qudits system in all. pn\u2212k of them are stabilizer operators, and p2k of them are logical operators. Other pn\u2212k operators that anticommute with the stabilizer group are called error operators.\nThese operators can be recast in a more group theoretically sophisticated manner. Let us pick up an abelian subgroup S of the n-qudit Pauli group P(p)n . For each stabilizer group S, we introduce the normalizer (or centralizer) N(S) of S in P(p)n , i.e., the subgroup of P (p) n containing all elements that commutes with every element of S. Then, logical operators are defined as elements of N(S)\\S. Also, error operators that anticommute with each element of S are given by elements of P(p)n \\N(S). Note that the set of logical operators and the set of error operators cannot have the group structure since the identity is always in the stabilizer group S."
        },
        {
            "heading": "2.2.2 Symplectic representation",
            "text": "In the above, we have described a stabilizer code using an operator formalism. We can encode a stabilizer group S into an (n\u2212 k)\u00d7 2n check matrix [8]:\nH=\n\n    \n\u03b1(1) \u03b2 (1)\n\u03b1(2) \u03b2 (2)\n... ...\n\u03b1(n\u2212k) \u03b2 (n\u2212k)\n\n     , (20)\nwhere (\u03b1(i),\u03b2 (i)) \u2208 Fnp \u00d7 F n p characterizes the generators of the stabilizer group S. In general, a stabilizer generator has a phase factor \u03c9\u03ba that is not considered in the above check matrix:\ng(\u03b1,\u03b2) =\u03c9\u03ba X\u03b11 Z\u03b21 \u2297 \u00b7 \u00b7 \u00b7 \u2297 X\u03b1n Z\u03b2n , (21)\nwhere \u03b1= (\u03b11, \u00b7 \u00b7 \u00b7 ,\u03b1n) and \u03b2 = (\u03b21, \u00b7 \u00b7 \u00b7 ,\u03b2n). By code equivalence we can set \u03c9\u03ba to 1 for odd prime p and to i\u03b1\u00b7\u03b2 for p = 2.3\nA stabilizer group S is mapped to a check matrix H. The commutation relation in the stabilizer group is also encoded into a symplectic product on the vector space spanned by the check matrix. We define a 2n\u00d7 2n matrix W as\nW = 0 In \u2212In 0 , (22)\nwhere the In in the off-diagonals is an n\u00d7 n identity matrix. Elements g(\u03b1,\u03b2) and g(\u03b1\u2032,\u03b2 \u2032) commute if and only if (\u03b1,\u03b2)W (\u03b1\u2032,\u03b2 \u2032)T = \u2329(\u03b1,\u03b2), (\u03b1\u2032,\u03b2 \u2032)\u232a = 0. Then the abelian structure of a stabilizer group reduces to the following condition:\nHWHT = 0 mod p , (23)\nwhere 0 on the right-hand side denotes a (n\u2212 k)\u00d7 (n\u2212 k) matrix. We introduce the generator matrix G over Fp such that\nHWGT = 0 mod p , (24)\nwhere G is a (n+ k)\u00d7 2n matrix with rank (G) = n+ k and its component is given by\nG=\n\n \n\u03b1(1) \u03b2 (1)\n... ...\n\u03b1(n+k) \u03b2 (n+k)\n\n  . (25)\nThis implies that the operators generated by rows of the generator matrix commute with the stabilizer group. The generator matrix G generates the normalizer N(S) of the stabilizer group S in P(p)n , which consists of stabilizer operators and logical operators. We can choose the generator matrix G such that the first (n \u2212 k) rows and the remaining 2k rows generate stabilizer operators and the set of logical operators, respectively.\n3This statement follows from Proposition 2.2."
        },
        {
            "heading": "2.2.3 Code equivalence",
            "text": "There is a subgroup of unitary transformations that do not change the form (13) of the stabilizer generators. The group with this property is called the Clifford group. The Clifford group is characterized by the property that it leaves the n-qudit Pauli group P(p)n invariant under conjugation. Hence, it is a normalizer of the qudits Pauli group: N P(p)n\nin the unitary group U(pn). The Clifford group generates equivalence classes of the stabilizer codes by conjugation. The stabilizer codes in the same equivalence class are called equivalent.\nFor the case with qubits (p = 2), the Clifford group is generated by the Hadamard transformation: X \u2192 Z , Z \u2192 X and the phase gate: X \u2192 PX P\u22121, Z \u2192 Z where P = diag(1, i), and the CNOT gate:\nX \u2297 I \u2192 X \u2297 X , I \u2297 X \u2192 I \u2297 X , Z \u2297 I \u2192 Z \u2297 I , I \u2297 Z \u2192 Z \u2297 Z .\n(26)\nFor qudits where p is an odd prime, there are the following transformations in the Clifford group [5], called the discrete Fourier transformation: Xp\u2192 Zp, Zp\u2192 X\u22121p and the phase gate: Xp\u2192 Xp Zp, Zp\u2192 Zp, and the SUM gate:\nXp \u2297 I \u2192 Xp \u2297 Xp , I \u2297 Xp\u2192 I \u2297 Xp , Zp \u2297 I \u2192 Zp \u2297 I , I \u2297 Zp\u2192 Z\u22121p \u2297 Zp . (27)\nFurthermore, we need the S gate to generate the Clifford group: Xp \u2192 X ap , Zp \u2192 Z b p where\nab = 1 mod p. These four operators generate the Clifford group N P(p)n\n. Then a stabilizer code is equivalent to another code obtained by the conjugation generated by these operators.\nRelated to the code equivalence, we can show the following proposition. This statement ensures the existence of an equivalent stabilizer code with trivial phases.\nProposition 2.2 Suppose that the stabilizer generators be gi where i = 1, 2, \u00b7 \u00b7 \u00b7 , n\u2212 k. For fixed i, there exists g \u2208 P(p)n such that g gi g\u22121 =\u03c9\u03bap gi for \u03ba \u2208 {1, 2, \u00b7 \u00b7 \u00b7 , p\u2212 1} and g g j g \u22121 = g j for j \u0338= i.\nProof. Suppose that a check matrix H of a stabilizer group S is of the form (20) where the rows are linearly independent. Then there exists a 2n-dimensional row vector x = (\u03b1,\u03b2) \u2208 Fnp \u00d7F n p which satisfies\nHW x T = ei , (28)\nwhere ei is the (n+k)-dimensional column vector with 1 at the i-th position and 0s elsewhere. Let \u03c3 \u2208 P(p)n be an operator such that\n\u03c3 = g(\u03b1,\u03b2) . (29)\nLet gi \u2208 S be a generator of the stabilizer group encoded in the i-th row of the check matrix H. Then we have the following relation from (28): gi \u03c3 =\u03c9\u22121p \u03c3 gi , and g j \u03c3 = \u03c3 g j where j \u0338= i. This implies that \u03c3 = g(\u03b1,\u03b2) \u2208 P(p)n acts as \u03c3 gi \u03c3\u22121 = \u03c9p gi and \u03c3 g j\u03c3\u22121 = g j . Hence, we obtain the result g gi g \u22121 =\u03c9\u03bap gi and g g j g \u22121 = g j where g = \u03c3\u03ba.\nSince the Clifford group is the normalizer of the Pauli group P(p)n , it contains the Pauli group P(p)n . Proposition 2.2 states that there exists an equivalent stabilizer code that is the same as the original code except for phase factors. Therefore, it allows us to remove the phase factors in front of the stabilizer generators by an appropriate equivalent transformation.\nAssociated with the equivalence of quantum codes, we make a comment on our construction of Lorentzian lattices from qudit stabilizer codes illustrated in section 3.\nComment: Suppose that a qudit stabilizer code has a check matrix H. When constructing a Lorentzian lattice, we will introduce a Lorentzian metric \u03b7 into a vector space generated by the matrix H by hand. In the binary case (p = 2), the symplectic structure W inherited from quantum codes also undertakes the role of the Lorentzian metric as a result of the modulo-two operation: W = \u03b7 mod 2. However, they do not match and must be defined separately for an odd prime p. Therefore, the Lorentzian metric and symplectic structure impose independent conditions when constructing Narain CFTs for an odd prime p. The Clifford group preserves only the symplectic structure and changes the Lorentzian metric. Thus, even if a quantum code satisfies the conditions for the construction of Narain CFTs, it is not guaranteed that an equivalent quantum code after the action of the Clifford group meets the same conditions when p is an odd prime."
        },
        {
            "heading": "2.3 CSS codes",
            "text": "There is a class of stabilizer codes that can be constructed from a pair of classical codes. These codes are called CSS codes [12,13]. CSS codes give nontrivial examples for our construction of Narain CFTs. To introduce CSS codes, we first illustrate classical linear codes briefly (see [40\u201345] for more details).\nLet us define a p-ary classical linear code that encodes a k-bit message into an n-bit signal. A classical linear code C has the generator matrix GC and the parity check matrix HC that satisfies\nGC H T C = 0 mod p , (30)\nwhere GC and HC are a k\u00d7n matrix of rank k and an (n\u2212k)\u00d7n matrix of rank n\u2212k, respectively. The codewords are generated by the generator matrix GC as follows:\nc = x GC , (31)\nwhere x \u2208 Fkp is a k-dimensional row vector. These codewords determine the code subspace\nC = \u00a6\nc \u2208 Fnp | c = x GC , x \u2208 F k p\n\u00a9\n\u2282 Fnp . (32)\nFor all codewords c \u2208 C , the parity check matrix HC satisfies c HTC = 0 mod p due to the condition (30). Then, the parity check matrix gives an alternative definition of the code subspace C\nC = \u00a6\nc \u2208 Fnp | c H T C = 0 mod p\n\u00a9\n. (33)\nTo characterize the error-correcting property of a linear code, let us introduce the distance in the vector space Fnp. The Hamming distance d (c, c\n\u2032) between vectors c , c\u2032 \u2208 Fnp is given by the number of nonzero components of the vector c \u2212 c\u2032 \u2208 Fnp. For a linear code, the Hamming weight is also useful. The Hamming weight wt(c) of a vector c \u2208 Fnp is defined as the number of nonzero components of the vector c. For example, the Hamming weight of the vector c = (0,0, 4,3) \u2208 F45 is wt(c) = 2. Using the Hamming distance or weight, we define the minimum distance of a linear code. The minimum distance d (C) of a linear code C is given by the minimum nonzero Hamming distance for any pair of codewords:\nd (C) = min c, c\u2032\u2208C , c \u0338=c\u2032 d (c, c\u2032) = min c\u2208C , c \u0338=0 wt(c) , (34)\nwhere we use the fact that for a linear code C , c\u2212c\u2032 \u2208 C if c and c\u2032 are codewords. A linear code with the minimum distance d can correct up to \u230a(d\u22121)/2\u230b bit errors, so the minimum distance\ncaptures the characteristics of the error-correcting property well. We call a p-ary linear code that encodes k bits into n bits with the minimum distance d as an [n, k, d]p code. Often the minimum distance is omitted and simply referred to as an [n, k] code.\nA key ingredient in the CSS codes is the dual construction of classical codes. The dual code C\u22a5 for a code C is defined by\nC\u22a5 = {c\u2032 \u2208 Fnp | c \u00b7 c \u2032 = 0 mod p , c \u2208 C} . (35)\nWe call a code self-orthogonal if C \u2286 C\u22a5, and self-dual if C = C\u22a5. Suppose C is a p-ary classical linear code with a k\u00d7n generator matrix GC and an (n\u2212k)\u00d7n parity check matrix HC . We assume the Euclidean metric c \u00b7 c\u2032 = \u2211n i=1 ci c \u2032 i . Then the dual code C\u22a5 is the code with an (n\u2212k)\u00d7n generator matrix HC and a k\u00d7n parity check matrix GC . The codewords c \u2208 C are generated by the generator G: c = x GC where x \u2208 Fkp is a kdimensional row vector. Also, the codewords c\u2032 \u2208 C\u22a5 are given by c\u2032 = y HC where y \u2208 Fn\u2212kp is an (n\u2212k)-dimensional row vector. The inner product of these vectors is c \u00b7c\u2032 = x GC HTC y\nT = 0 mod p from the relation (30).\nSuppose that CX and CZ are [n, kX ]p and [n, kZ]p linear codes with the generator matrices GX , GZ and the parity check matrices HX , HZ , respectively. Also, we assume the following condition:\nC\u22a5X \u2286 CZ . (36)\nThis condition implies that the dual code of CX is a subspace of the other code CZ , so all codewords generated by HX are contained in the code subspace CZ . Then we reach\nHX H T Z = 0 mod p . (37)\nIn this case, the CSS code can be defined by the following check matrix:\nH(CX , CZ ) =\nHX 0\n0 HZ\n, (38)\nwhere the block HX (HZ) represents the parity check matrix of the classical linear code CX (CZ). To see that this construction defines a stabilizer code, let us examine if the check matrix satisfies the commutativity condition (23): H(CX , CZ )WH T (CX , CZ )\n= 0 (mod p). Now we have the relation (37), then\nH(CX , CZ )WH T (CX , CZ ) =\n0 HX H T Z\n\u2212HZ HTX 0\n= 0 mod p . (39)\nTherefore, the CSS code with the check matrix (38) is a subclass of the stabilizer code. The resulting qudit code is [[n, kX + kZ \u2212 n]]p type.\nFor self-dual codes C , we can choose the generator matrix as GC = HC . From (30), we have HC H T C = 0 and this implies that if we choose CX = CZ = C , the commutativity condition (37) holds automatically. We can always construct the CSS code by setting CX = CZ = C with a self-dual code C . In this case, we obtain a quantum [[n, 0]]p code since the classical self-dual codes satisfy k = n/2.\nAn example of the CSS codes is the three-qutrit code. Consider a classical ternary code C with the generator matrix G3 and the parity check matrix H3:\nG3 =\n1 1 1\n0 1 2\n, H3 = 1 1 1 . (40)\nThis code satisfies C\u22a5 \u2286 C but is not self-dual C \u0338= C\u22a5. We set CX = CZ = C . The commutativity condition (37) is satisfied for HX = HZ = H3. Then the CSS code is given by\nH(C ,C) =\n1 1 1 0 0 0\n0 0 0 1 1 1\n. (41)\nThis check matrix gives us the stabilizer generators g1 = X \u2297 X \u2297 X and g2 = Z \u2297 Z \u2297 Z . The stabilizer group generated by these operators stabilizes the following quantum codewords:4\n|0\u0304\u232a= 1 p\n3 (|000\u232a+ |111\u232a+ |222\u232a) ,\n|1\u0304\u232a= 1 p\n3 (|012\u232a+ |120\u232a+ |201\u232a) ,\n|2\u0304\u232a= 1 p\n3 (|021\u232a+ |102\u232a+ |210\u232a) .\n(42)\nWe give one more example of the CSS codes. There is a self-dual code C over F5 of length n= 2. This classical code is given by the following generator matrix:\nG5 = 1 2 . (43)\nSince the above code is self-dual, we can choose the parity matrix H5 = G5. For the same reason, we can choose HX = HZ = H5 while satisfying the commutativity condition. Then the corresponding CSS code is\nH(C ,C) =\n1 2 0 0\n0 0 1 2\n. (44)\nThe stabilizer generators generated by the above check matrix are g1 = X\u2297X 2 and g2 = Z\u2297Z2. These operators generate the stabilizer group S and stabilize the following encoded state:\n|\u03c8\u232a= 1 p\n5 (|00\u232a+ |12\u232a+ |24\u232a+ |31\u232a+ |43\u232a) . (45)"
        },
        {
            "heading": "3 Construction of Lorentzian even self-dual lattices",
            "text": "Classical binary codes are known to give rise to Euclidean lattices and chiral CFTs [3]. In the previous section, we have described qudit stabilizer codes. In what follows, we will give an explicit construction of Lorentzian lattices from qudit stabilizer codes. In particular, we will illustrate that our construction works for the CSS codes. This is the generalization of the work [4], where the authors focus on the binary quantum stabilizer codes."
        },
        {
            "heading": "3.1 Lorentzian lattices via Construction A",
            "text": "A stabilizer code is defined by an abelian subgroup of the Pauli group P(p)n , and the generators of each code are given by the rows of the check matrix (20). We define a classical code generated by the check matrix of a stabilizer code. We construct the Lorentzian lattice from the classical code and connect the property of a classical code and a lattice. In the following, we focus on an [[n, 0]]p qudit stabilizer code where the check matrix is an n\u00d7 2n matrix.\n4The three-qutrit code can be seen as the simplest model of holography [46]. The relation between CSS codes and holography is also discussed in [47].\nSuppose that a stabilizer code has the n\u00d7 2n check matrix\nH=\n\n    \n\u03b1(1) \u03b2 (1)\n\u03b1(2) \u03b2 (2)\n... ...\n\u03b1(n) \u03b2 (n)\n\n     , (46)\nwhere the rows are linearly independent since each row corresponds to an independent generator of the stabilizer group S. Then the rank of the check matrix is rank (H) = n.\nConsider a classical code generated by the check matrix. To avoid confusion, we define the n\u00d7 2n generator matrix GH of the classical code as\nGH = H=\n\n \n\u03b1(1) \u03b2 (1)\n... ...\n\u03b1(n) \u03b2 (n)\n\n  . (47)\nThe code subspace C \u2282 F2np is\nC = \u00a6\nc \u2208 F2np | c = x GH, x \u2208 F n p\n\u00a9\n, (48)\nwhere x \u2208 Fnp is an n-dimensional row vector. This classical code is a [2n, n]p code since the check matrix H has rank n. We introduce the off-diagonal Lorentzian metric \u03b7 to the classical code C:\n\u03b7= 0 In In 0 , (49)\nwhere In is the n\u00d7 n identity. This metric is different from the symplectic form W introduced earlier for p \u0338= 2 by (22). We denote the inner products with respect to the off-diagonal Lorentzian metric \u03b7 by \u2299. Note that the norm of a codeword c = (\u03b1,\u03b2) \u2208 C with respect to the metric \u03b7 is always even:\nc \u2299 c \u2261 c\u03b7 cT = 2\u03b1 \u00b7 \u03b2 \u2208 2Z , (50)\nwhere the dot denotes the Euclidean inner product. We define the dual code C\u22a5 with respect to the metric \u03b7 by\nC\u22a5 = \u00a6 c\u2032 \u2208 F2np | c \u2032 \u2299 c = 0 mod p, c \u2208 C \u00a9 . (51)\nThe classical code C is called self-orthogonal if C \u2286 C\u22a5, and self-dual if C = C\u22a5. Note that the notion of self-orthogonality and self-duality depends on the metric. In this section, we focus on the off-diagonal Lorentzian metric \u03b7.\nFor a [2n, k\u2032]p code C with the generator matrix GH, one can take as the generator matrix G\u22a5H of the dual code C \u22a5 any matrix such that\nG\u22a5H \u03b7G T H = 0 mod p , (52)\nand rank (G\u22a5H) = 2n\u2212k \u2032. In the case of a self-orthogonal code C, the following relation holds:\nGH\u03b7G T H = 0 mod p . (53)\nIf k\u2032 = n, the self-orthogonality condition (53) ensures self-duality C = C\u22a5 as follows from the proposition below.\nProposition 3.1 Suppose that a [[n, 0]]p qudit stabilizer code has a n\u00d7 2n check matrix H. Then, the classical code with the generator matrix GH = H is self-dual with respect to the metric \u03b7 if and only if the check matrix satisfies the self-orthogonal condition: H\u03b7HT = 0 mod p.\nProof. The generator matrix GH = H has rank n due to the independence of the stabilizer generators. If the self-orthogonality condition (53) holds, the matrix GH is also the generator matrix of the dual code C\u22a5 from (52) since it satisfies rank (GH) = n. Then both the original code C and its dual C\u22a5 are generated by the matrix GH. This implies the classical code C is selfdual with respect to the metric \u03b7: C = C\u22a5. On the other hand, if a classical code is self-dual, then the self-orthogonal condition is automatically satisfied.\nThe constructions of a lattice from a classical code are useful to search dense sphere packings and are well-studied by mathematicians (refer to [42] and the references therein). The simplest construction of them is called Construction A. The Construction A lattice \u039b(C) from a classical code C is defined by\n\u039b(C) = v/ p p | v \u2208 Z2n, v = c (mod p), c \u2208 C . (54)\nThe lattice \u039b(C) is a Lorentzian lattice with respect to the off-diagonal Lorentzian metric \u03b7 in (49). We use \u2299 for the notation of the inner products between lattice vectors with the off-diagonal Lorentzian metric \u03b7 as in the case of a classical code C.\nBy analogy with classical codes, we define the dual lattice with respect to the metric \u03b7 as follows:\n\u039b\u2217 = \u03bb\u2032 \u2208 Rn,n |\u03bb\u2032 \u2299\u03bb \u2208 Z, \u03bb \u2208 \u039b . (55)\nThe lattice \u039b is integral if and only if \u039b \u2286 \u039b\u2217 and self-dual if and only if \u039b = \u039b\u2217. We call the lattice \u039b even if and only if \u03bb\u2299\u03bb \u2208 2Z for \u03bb \u2208 \u039b.\nThe lattice \u039b(C) reduces to the classical code C by identifying \u03bb \u223c \u03bb + ppZ2n, where \u03bb \u2208 \u039b(C). This implies that different codes give different lattices via Construction A. Then \u039b(C) = \u039b(C\u2032) if and only if C = C\u2032."
        },
        {
            "heading": "3.2 Even self-dual lattices",
            "text": "The above prescription defines the map between the classical code C derived from a qudit stabilizer code and the Lorentzian lattice \u039b(C), which associates the properties of the codes with those of the lattices. In this section, we describe the conditions for a classical code to give an even self-dual lattice via Construction A, some of which were obtained in [11]. For completeness we provide proofs in our notations. Then we translate the conditions into those on qudit stabilizer codes.\nStarting with a qudit stabilizer code, we obtain a check matrix. We regard it as the generator matrix of a classical code C over Fp and construct a Lorentzian lattice \u039b(C). This construction connects a self-dual code C with the metric \u03b7 to a self-dual lattice \u039b(C) with the metric \u03b7. It can be summarized by the following proposition.\nProposition 3.2 ( [11, Proposition 3.2]) For a prime p, the Construction A lattice \u039b(C) is self-dual with the off-diagonal Lorentzian metric \u03b7 if and only if a classical code C is self-dual with the Lorentzian metric \u03b7.\nProof. We first prove \u039b(C\u22a5) \u2283 \u039b(C)\u2217. Let us consider a vector \u03bb\u2032 = (\u03bb\u20321,\u03bb \u2032 2) \u2208 \u039b(C) \u2217. A lattice vector in the Construction A lattice is given by \u03bb= (\u03bb1,\u03bb2) \u2208 \u039b(C) where\n\u03bb1 = \u03b1+ p k1p\np , \u03bb2 = \u03b2 + p k2p p , k1, k2 \u2208 Zn , (56)\nwhich is labeled by a codeword c = (\u03b1,\u03b2) \u2208 C. Since the vector \u03bb\u2032 is in the dual lattice \u039b(C)\u2217, the inner product with \u03bb \u2208 \u039b(C) must be an integer. Let \u03bb \u2208 \u039b(C) be \u03bb1 = p p k1 and \u03bb2 = p p k2. Then the inner product becomes\n\u03bb\u2299\u03bb\u2032 =pp\u03bb\u20322 \u00b7 k1 + p p\u03bb\u20321 \u00b7 k2 , k1, k2 \u2208 Z n . (57)\nTo satisfy \u03bb\u2299 \u03bb\u2032 \u2208 Z, the lattice vector in the dual lattice has to be \u03bb\u2032 \u2208 (Z/pp)n. Then the lattice vector \u03bb\u2032 = (\u03bb\u20321,\u03bb \u2032 2) \u2208 \u039b(C) \u2217 can be written as the form\n\u03bb\u20321 = \u03b1\u2032 + p k\u20321p\np , \u03bb\u20322 = \u03b2 \u2032 + p k\u20322p p , k\u20321, k \u2032 2 \u2208 Z n , (58)\nwhere c\u2032 = (\u03b1\u2032,\u03b2 \u2032) \u2208 Fnp \u00d7 F n p. The inner product between \u03bb \u2208 \u039b(C) and \u03bb \u2032 \u2208 \u039b(C)\u2217 is\n\u03bb\u2299\u03bb\u2032 = \u03b1\u2032 \u00b7 \u03b2 +\u03b1 \u00b7 \u03b2 \u2032\np + (\u03b1\u2032 \u00b7 k2 + k\u20321 \u00b7 \u03b2 + p k \u2032 1 \u00b7 k2 +\u03b1 \u00b7 k \u2032 2 + k1 \u00b7 \u03b2 \u2032 + p k1 \u00b7 k\u20322) . (59)\nThe assumption \u03bb\u2299 \u03bb\u2032 \u2208 Z gives us c \u2299 c\u2032 = \u03b1 \u00b7 \u03b2 \u2032 + \u03b1\u2032 \u00b7 \u03b2 = 0 mod p. This implies c\u2032 \u2208 C\u22a5 and \u03bb\u2032 \u2208 \u039b(C\u22a5).\nTo prove \u039b(C\u22a5) \u2282 \u039b(C)\u2217, we assume \u03bb \u2208 \u039b(C) and \u03bb\u2032 \u2208 \u039b(C\u22a5) take the same forms as (56) and (58), respectively, where c = (\u03b1,\u03b2) \u2208 C and c\u2032 = (\u03b1\u2032,\u03b2 \u2032) \u2208 C\u22a5. Then, the inner product \u03bb\u2299 \u03bb\u2032 given in (59) for any \u03bb \u2208 \u039b(C) becomes integer as c \u2299 c\u2032 = \u03b1 \u00b7 \u03b2 \u2032 + \u03b1\u2032 \u00b7 \u03b2 = 0 mod p, which means \u03bb\u2032 \u2208 \u039b(C)\u2217.\nWe have shown the lattice \u039b(C\u22a5) is the dual lattice of \u039b(C): \u039b\u2217(C) = \u039b(C\u22a5). Thus, for C a self-dual code C = C\u22a5, the Construction A lattice is self-dual: \u039b\u2217(C) = \u039b(C). The inverse is also true because \u039b(C) = \u039b(C\u2032) if and only if C = C\u2032. Therefore, \u039b(C) is self-dual with respect to \u03b7 if and only if C is self-dual with respect to \u03b7.\nNext, we construct an even lattice \u039b(C) with the Lorentzian metric from a classical code C with an appropriate property. This property is associated with the norm of a classical code C as in the following proposition. Note that there is a subtle difference between p = 2 and the other cases.\nProposition 3.3 ( [11, Proposition 3.1]) For a prime p \u0338= 2, the Construction A lattice \u039b(C) is even with the Lorentzian metric \u03b7 if and only if a classical code C is self-orthogonal with the off-diagonal Lorentzian metric \u03b7.\nProof. Suppose that a codeword c = (\u03b1,\u03b2) \u2208 C. The Construction A lattice is given by \u03bb= (\u03bb1,\u03bb2) \u2208 \u039b(C) where\n\u03bb1 = \u03b1+ p k1p\np , \u03bb2 = \u03b2 + p k2p p , k1, k2 \u2208 Zn . (60)\nThe norm of the lattice vector is\n\u03bb\u2299\u03bb= 2 p \u03b1 \u00b7 \u03b2 + p\u03b1 \u00b7 k2 + p\u03b2 \u00b7 k1 + p2 k1 \u00b7 k2 . (61)\nLet C be a self-orthogonal code. Then the codeword satisfies c \u2299 c = 2\u03b1 \u00b7 \u03b2 = 0 mod p. This implies \u03b1 \u00b7 \u03b2 \u2208 pZ since \u03b1 \u00b7 \u03b2 \u2208 Z and p and 2 are coprime for an odd prime p \u0338= 2. Thus, we conclude the norm of the lattice vector is even. On the other hand, let \u039b(C) be even with respect to the metric \u03b7. Then we obtain (\u03b1 \u00b7\u03b2)/p \u2208 Z. This implies c \u2299 c = 2\u03b1 \u00b7\u03b2 = 0 mod p. The relation (c + c\u2032)\u2299 (c + c\u2032) = c \u2299 c + c\u2032 \u2299 c\u2032 + 2 c \u2299 c\u2032 for c, c\u2032 \u2208 C ensures self-orthogonality of the classical code C for an odd prime p \u0338= 2: c \u2299 c\u2032 \u2208 pZ for any pair of c, c\u2032 \u2208 C.\nProposition 3.4 For p = 2, the Construction A lattice \u039b(C) is even with respect to the off-diagonal Lorentzian metric \u03b7 if and only if a classical code C is doubly-even with respect to the metric \u03b7: c\u2299 c = 0 mod 4 where c \u2208 C.\nProof. Suppose that a lattice vector \u03bb= (\u03bb1,\u03bb2) in the Construction A lattice \u039b(C) is\n\u03bb1 = \u03b1+ 2 k1p\n2 , \u03bb2 = \u03b2 + 2 k2p 2 , k1, k2 \u2208 Zn , (62)\nwhere c = (\u03b1,\u03b2) \u2208 C is a codeword. The norm of this vector is\n\u03bb\u2299\u03bb= \u03b1 \u00b7 \u03b2 + 2\u03b1 \u00b7 k2 + 2\u03b2 \u00b7 k1 + 4 k1 \u00b7 k2 . (63)\nLet C be doubly-even: c \u2299 c = 2\u03b1 \u00b7 \u03b2 = 0 mod 4. Then we have \u03b1 \u00b7 \u03b2 = 0 mod 2, so the norm of a lattice vector is even. On the other hand, suppose that the Construction A lattice is even. Then, it results in \u03b1 \u00b7\u03b2 = 0 mod 2, which is equivalent to doubly-evenness: c\u2299 c = 2\u03b1 \u00b7\u03b2 = 0 mod 4.\nProposition 3.2 and Proposition 3.3 or 3.4 lead to the following theorem that ensures that a class of qudit stabilizer codes yields Lorentzian even self-dual lattices via Construction A.\nTheorem 3.5 ( [11, Proposition 3.3] for p \u0338= 2) For a prime p \u0338= 2, a self-dual code C with the off-diagonal Lorentzian metric \u03b7 gives an even self-dual lattice \u039b(C) with the metric \u03b7 via Construction A. For p = 2, a doubly-even self-dual code C with the metric \u03b7 endows an even self-dual lattice \u039b(C) with the metric \u03b7.\nWe now combine the above theorem and Proposition 3.1 to obtain the conditions for a qudit stabilizer code to give a Lorentzian even self-dual lattice.\nCorollary 3.6 Suppose that a [[n, 0]]p qudit stabilizer code has an n\u00d72n check matrixH satisfyingH\u03b7HT = 0 mod p. For an odd prime p \u0338= 2, a p-ary classical code C generated by the matrix GH = H prepares an even self-dual lattice \u039b(C) with yields to the off-diagonal Lorentzian metric \u03b7.\nFor p = 2, we must consider the additional condition to ensure doubly-evenness of the classical code C. It also reduces to a simple condition for the generator matrix.\nCorollary 3.7 Suppose that a [[n, 0]]2 binary stabilizer code has an n \u00d7 2n check matrix H that satisfies H\u03b7HT = 0 mod 2 and diag (H\u03b7HT ) = 0 mod 4. Then, a binary classical code C generated by the matrix GH = H gives an even self-dual lattice \u039b(C) with respect to the metric \u03b7.\nProof. We already know that the condition H\u03b7HT = 0 mod 2 guarantees that the classical code generated by GH = H is self-dual from Proposition 3.1. Thus, we only have to verify that the assumptions H\u03b7HT = 0 mod 2 and diag (H\u03b7HT ) = 0 mod 4 ensure the classical code to be doubly-even. Let c(i) (i = 1,2, \u00b7 \u00b7 \u00b7 , n) be the i-th row of the generator matrix GH. These vectors form a basis of the code subspace C. Then, a codeword c is written as c = \u2211\ni si c (i) and\nits norm is given by\nc \u2299 c = \u2211\ni, j\nsis j c (i) \u2299 c( j) =\n\u2211\ni\ns2i c (i) \u2299 c(i) + 2\n\u2211\ni< j\nsis j c (i) \u2299 c( j) . (64)\nThe condition H\u03b7HT = 0 mod 2 reduces to c(i) \u2299 c( j) = 0 mod 2. The other condition diag (H\u03b7HT ) = 0 mod 4 implies c(i) \u2299 c(i) = 0 mod 4. From (64), the norm c \u2299 c becomes a multiple of 4: c \u2299 c \u2208 4Z for any codeword c \u2208 C. That is, the classical code C is doublyeven.\nWhile we have discussed the construction of Lorentzian lattice for qubit cases and qudit cases in parallel, we emphasize the difference between them mentioned in section 2.2.3. The Clifford group preserves the group structure of the Pauli group, so a stabilizer group is kept abelian under the action of the Clifford group. In the language of a check matrix, this property implies that the symplectic form W is invariant with the Clifford group transformation. For example, let us consider the Hadamard transformation: Xp\u2192 Zp, Zp\u2192 X\u22121p . If the Hadamard transformation acts on the i-th qudit, the i-th column and the (i + n)-th column in the check matrix are swapped with \u22121 on one side. It keeps the symplectic form invariant. However, the Hadamard transformation does change the inner products with respect to the off-diagonal metric \u03b7. Therefore, the Clifford group does not preserve the structure of the Lorentzian metric \u03b7 for an odd prime p. On the other hand, for qubits (p = 2), the symplectic form W coincides with the metric \u03b7 introduced later, so the Clifford group also preserves the metric \u03b7 in this case [4]."
        },
        {
            "heading": "3.3 CSS construction",
            "text": "We have described the conditions for a qudit stabilizer code to give a Lorentzian even self-dual lattice. We now explain that the CSS codes reviewed in section 2.3 satisfy the conditions and discuss an explicit example of the construction of lattices from CSS codes, which we will use heavily later in this paper.\nWe start with a classical [n, k]p code C with a generator matrix GC and a parity check matrix HC . Then, the dual code C\n\u22a5 has the generator matrix HC and the parity check matrix GC . Note that we do not require the code C to be self-orthogonal or self-dual. As a special case of CX and CZ satisfying (36), we choose CX = C and CZ = C\u22a5. Then, the code CX = C has the generator matrix GX = GC and the parity check matrix HX = HC . On the other hand, the code CZ = C\u22a5 has the generator matrix GZ = HC and the parity check matrix HZ = GC . For this choice, the condition (37) reduces to GC H T C = 0 mod p, and it is satisfied due to the relation (30) between the generator matrix and the parity check matrix. Then, the n\u00d7 2n check matrix of the CSS code is as follows:\nH(C ,C\u22a5) =\nHC 0\n0 GC\n. (65)\nWe denote a classical code generated by the matrix GH = H(C ,C\u22a5) as C:\nC = \u00a6\n(c1, c2) \u2208 Fnp \u00d7 F n p | c1 \u2208 C \u22a5 , c2 \u2208 C \u00a9 . (66)\nThe following theorem verifies that the CSS code C leads to an even self-dual lattice through Construction A, giving explicit examples of the construction of a Lorentzian even self-dual lattice from a qudit stabilizer code.\nTheorem 3.8 Suppose that a CSS code has a check matrix (65) with a classical [n, k]p code C and the dual code C\u22a5. Let C be the classical code with the generator matrix H(C ,C\u22a5). Then, the Construction A lattice \u039b(C) is even self-dual with respect to the metric \u03b7.\nProof. For a prime p \u0338= 2, all we have to do is to check self-duality of the code C with respect to the Lorentzian metric \u03b7. The dual code with the metric \u03b7 is defined by\nC\u22a5 = \u00a6 (c\u20321, c \u2032 2) \u2208 F n p \u00d7 F n p | (c \u2032 1, c \u2032 2)\u2299 (c1, c2) = 0 mod p, (c1, c2) \u2208 C \u00a9 . (67)\nSince the metric is given by (49), this implies that (c\u20321, c \u2032 2) is in the dual code if and only if c\u20321 \u00b7 c2+ c \u2032 2 \u00b7 c1 = 0 mod p for any c1 \u2208 C \u22a5 and c2 \u2208 C . Thus, the above definition reduces to the\nfollowing condition: c\u20321 \u00b7 c2 = 0 mod p and c \u2032 2 \u00b7 c1 = 0 mod p. Equivalently, c \u2032 1 G T C = c \u2032 2 H T C = 0 mod p. This means c\u20321 \u2208 C \u22a5 and c\u20322 \u2208 C through (33):\nC\u22a5 = \u00a6 (c\u20321, c \u2032 2) \u2208 F n p \u00d7 F n p | c \u2032 1 \u2208 C \u22a5 , c\u20322 \u2208 C \u00a9 \u2261 C . (68)\nTherefore, a classical code obtained through the CSS construction is self-dual with respect to the metric \u03b7. For a prime p \u0338= 2, Theorem 3.5 states the CSS code C generated by a classical p-ary self-dual code gives an even self-dual lattice \u039b(C).\nTo ensure that the Construction A lattice is even for p = 2, an additional condition should be imposed. In this case, we require the CSS code C to be doubly-even with respect to the metric \u03b7 as dictated by Theorem 3.5. Then, for a classical binary [n, k]2 code C , we have\nc \u2299 c = 2 c1 \u00b7 c2 \u2208 4Z , c1 \u2208 C\u22a5 , c2 \u2208 C , (69)\nwhere c = (c1, c2) \u2208 C and the dot denotes the Euclidean inner product on the classical code C . The condition for a doubly-even code is c1 \u00b7 c2 = 0 mod 2 and this is satisfied as an inner product between the code C and the dual code C\u22a5 vanishes modulo 2. There are no additional requirements for doubly-evenness in the case of the CSS construction.\nTherefore, the classical code C starting with a classical [n, k]p code C becomes self-dual for a prime p and doubly-even for p = 2. Hence, the Construction A lattice from the CSS code is even and self-dual with respect to the off-diagonal Lorentzian metric \u03b7.\nWe can choose a classical code C to be self-dual. Following the above prescription, we give the CSS code constructed from a pair of classical codes CX , CZ such that CX = CZ = C . Then, the check matrix of the CSS code is\nH(C ,C) =\nHC 0\n0 HC\n. (70)\nThe classical code with the generator matrix GH = H(C ,C) is given by\nC = \u00a6\n(c1, c2) \u2208 Fnp \u00d7 F n p | c1 , c2 \u2208 C\n\u00a9\n. (71)\nThis is an example of the construction dictated in Theorem 3.8. In this case, of course, the classical code C gives an even self-dual lattice via Construction A. In section 5, we will consider the averaged theory over the CSS codes defined from a classical self-dual code.\nCorollary 3.9 Suppose that a CSS code has a check matrix (70) with a classical [n, n/2]p self-dual code C . Let C be the classical code with the generator matrix H(C ,C). Then, the Construction A lattice \u039b(C) is even self-dual with respect to the off-diagonal Lorentzian metric \u03b7."
        },
        {
            "heading": "4 Narain code CFTs",
            "text": "We have seen that an even self-dual Lorentzian lattice can be constructed from a qudit stabilizer code with appropriate conditions via Construction A. In this section, we assume that \u039b(C) is a Lorentzian even self-dual lattice obtained through Construction A. We associate the lattice with a Narain CFT [48, 49], a free boson theory with a torus target space. We refer to the Narain CFTs constructed from codes as Narain code CFTs."
        },
        {
            "heading": "4.1 Construction of Narain CFTs",
            "text": "From a qudit stabilizer code, we can construct a Narain lattice, i.e., an even self-dual lattice as in Corollary 3.6 and 3.7. Naively, a Narain CFT is given by choosing the Construction A lattice as the momentum lattice. However, there is a subtlety in this naive construction. The Construction A lattices are equipped with an off-diagonal Lorentzian metric \u03b7, so they are given in the coordinates:\n\u03bb= (\u03bb1,\u03bb2) = pL + pRp 2 , pL \u2212 pRp 2 \u2208 \u039b(C) , (72)\nrather than the coordinates of the left- and right-moving momentum (pL , pR). The norm of \u03bb= (\u03bb1,\u03bb2) \u2208 \u039b(C) with respect to the off-diagonal Lorentzian metric \u03b7 is\n(\u03bb1,\u03bb2)\u2299 (\u03bb1,\u03bb2) = p2L \u2212 p 2 R = (pL , pR) \u25e6 (pL , pR) , (73)\nwhere we follow the notation of Polchinski\u2019s textbook [50,51]. This is associated with a natural metric for the left- and right-moving momentum in the Narain lattices:\ne\u03b7=\nIn 0 0 \u2212In , (74)\nwhere In is the n\u00d7n identity matrix. To show it explicitly, we have to move onto the momentum basis by the orthogonal transformation:\n(pL , pR) = (\u03bb1,\u03bb2) P , P = 1 p\n2 In In In \u2212In . (75)\nThe left- and right-moving momentum are given by points (pL , pR) \u2208 e\u039b(C) in the momentum lattice e\u039b(C). The vertex operators in the Narain code CFTs are given by\nVpL ,pR(z, z\u0304) = : e ipL X L(z)+ipRXR(z\u0304) : , (76)\nwhere (pL , pR) \u2208 e\u039b(C). We omit the cocycle factors, which do not matter for our analysis. These operators correspond to the momentum states |pL , pR\u232a via the state-operator isomorphism. We have the oscillators \u03b1ik and \u03b1\u0303 i k (i = 1,2, \u00b7 \u00b7 \u00b7 , n) that satisfy the following algebra:\n[\u03b1ik ,\u03b1 j l ] = [\u03b1\u0303 i k , \u03b1\u0303 j l ] = k\u03b4k+l,0\u03b4 i, j , k, l \u2208 Z . (77)\nThe Hilbert space of the Narain code CFT is given by\nH(C) = \u00a6 \u03b1 i1 \u2212k1 \u00b7 \u00b7 \u00b7\u03b1ir\u2212kr \u03b1\u0303 j1 \u2212l1 \u00b7 \u00b7 \u00b7 \u03b1\u0303 js\u2212ls |pL , pR\u232a | (pL , pR) \u2208 e\u039b(C) \u00a9 , (78)\nwith k1, \u00b7 \u00b7 \u00b7 , kr \u2208 Z>0 and l1, \u00b7 \u00b7 \u00b7 , ls \u2208 Z>0. Therefore, we arrive at the following proposition:\nProposition 4.1 Let \u039b(C) be the Construction A lattice that is even self-dual with respect to the off-diagonal Lorentzian metric \u03b7. Suppose that e\u039b(C) is the lattice obtained by the orthogonal transformation (75) of the Construction A lattice \u039b(C). Then, a Narain CFT is provided by giving the leftand right-moving momenta as (pL , pR) \u2208 e\u039b(C).\nBy combining this proposition with Corollary 3.6 and 3.7, we finally get the following theorems that summarize our construction of the Narain code CFTs:\nTheorem 4.2 Suppose that a [[n, 0]]p qudit stabilizer code has an n\u00d72n check matrixH satisfyingH\u03b7HT = 0 mod p. Let C be a classical code generated by the matrix GH = H. For an odd prime p \u0338= 2, the Construction A lattice e\u039b(C) followed by the orthogonal transformation (75) provides a Narain CFT by giving the left- and right-moving momenta as (pL , pR) \u2208 e\u039b(C).\nTheorem 4.3 Suppose that a [[n, 0]]2 qubit stabilizer code has an n \u00d7 2n check matrix H that satisfies H\u03b7HT = 0 mod 2 and diag (H\u03b7HT ) = 0 mod 4. Let C be a binary classical code generated by the matrix GH = H. Then, the Construction A lattice e\u039b(C) followed by the orthogonal transformation (75) provides a Narain CFT by giving the left- and right-moving momenta as (pL , pR) \u2208 e\u039b(C).\nThe torus partition function of the resulting Narain code CFT is as follows:\nZC(\u03c4, \u03c4\u0304) = TrH(C) q L0\u2212 n 24 q\u0304 L\u03040\u2212 n 24 =\n\u0398 e\u039b(C)(\u03c4, \u03c4\u0304)\n|\u03b7(\u03c4)|2n , (79)\nwhere \u03b7(\u03c4) is the Dedekind eta function. The lattice theta function of the Narain lattice is\n\u0398 e\u039b(C)(\u03c4, \u03c4\u0304) =\n\u2211\np\u2208e\u039b(C)\nq p2L 2 q\u0304 p2R 2 , (80)\nwhere q = e2\u03c0i\u03c4 and \u03c4 = \u03c41 + i\u03c42 is the modulus of the torus. Note that the CFT partition function (79) explicitly depends on the decomposition of the lattice e\u039b(C) into the left-moving momentum pL and the right-moving momentum pR. However, the inner product does not depend on the coordinate (73), so e\u039b(C) is also even and self-dual with respect to the diagonal Lorentzian metric e\u03b7. Therefore, the modular invariance of the partition function constructed from the momentum lattice e\u039b(C) follows directly from that the Construction A lattice \u039b(C) is even self-dual."
        },
        {
            "heading": "4.2 Partition function",
            "text": "We have obtained the direct connection (79) between the partition function and the lattice theta function. Both of these quantities characterize each spectrum. There is also a quantity that measures the spectrum of codes, which is called the enumerator polynomial. The construction above gives a simple relation between the spectrum of Narain CFTs, lattices, and codes. Using this relationship, it is straightforward to calculate the partition function of the Narain CFT in terms of the code enumerator polynomial. In what follows, we will determine the partition function of the Narain CFT constructed from a qudit code and explain how each spectrum is tied together.\nThe Construction A lattice has a concrete representation by a codeword c = (\u03b1,\u03b2) \u2208 C where \u03b1= (\u03b11, \u00b7 \u00b7 \u00b7 ,\u03b1n) \u2208 Fnp and \u03b2 = (\u03b21, \u00b7 \u00b7 \u00b7 ,\u03b2n) \u2208 F n p:\n\u03bb1 = \u03b1+ p k1p\np , \u03bb2 = \u03b2 + p k2p p , k1, k2 \u2208 Zn . (81)\nTherefore, the partition function of the Narain code CFT can be expressed in terms of codewords c = (\u03b1,\u03b2) \u2208 C:\nZC(\u03c4, \u03c4\u0304) = 1 |\u03b7(\u03c4)|2n \u2211\n(\u03b1,\u03b2)\u2208C\n\u2211\nk1,k2\u2208Zn q\np 4 \u03b1+\u03b2 p +k1+k2\n2\nq\u0304 p 4 \u03b1\u2212\u03b2 p +k1\u2212k2\n2\n. (82)\nWe can associate the partition function with the complete enumerator polynomial of the code C. The complete enumerator polynomial of a code C is defined by ( [52,53])\nWC ({xab}) = \u2211\nc\u2208C\n\u220f\n(a,b)\u2208Fp\u00d7Fp\nxwtab(c)ab , (83)\nwhere wtab(c) is the number of components ci = (\u03b1i ,\u03b2i) \u2208 Fp\u00d7Fp that equal to (a, b) \u2208 Fp\u00d7Fp for a codeword c \u2208 C:\nwtab(c) = |{i | ci = (a, b)}| , (84)\nwhich is called the composition of c \u2208 C in [40, 53]. The complete enumerator polynomial of the dual code C\u22a5 is uniquely determined by the one of C. We obtain the complete enumerator polynomial of the dual code C\u22a5 from the MacWilliams identity [54,55] (see also Theorem 10 of Chapter 5 in [40] and Example 2.2.7 in [53]):\nWC\u22a5({xab}) =WC({ x\u0303ab}) , (85)\nwhere for v = (a, b) \u2208 Fp \u00d7 Fp\nx\u0303v = 1 p \u2211\nw\u2208Fp\u00d7Fp\ne 2\u03c0i p w\u03b72 v T xw , (86)\nwith the non-degenerate symmetric bilinear form \u03b72 on Fp \u00d7 Fp:\n\u03b72 =\n0 1\n1 0\n. (87)\nWe can also write the relation as\nxv = 1 p \u2211\nw\u2208Fp\u00d7Fp\ne\u2212 2\u03c0i p w\u03b72 v T x\u0303w . (88)\nThen, for a self-dual code C = C\u22a5, the complete enumerator polynomial is invariant under the change of variables xai bi \u2194 x\u0303ai bi . The invariance of the complete enumerator polynomial is closely related to the modular invariance for the partition functions of Narain code CFTs. We will see it later in this section.\nWe can explicitly relate the complete enumerator polynomial to the partition function.\nProposition 4.4 Let C \u2282 Fnp \u00d7 F n p be a classical code whose complete enumerator polynomial WC is given by (83). Then, the partition function of the Narain CFT constructed from the code C is\nZC(\u03c4, \u03c4\u0304) = \u0398 e\u039b(C)(\u03c4, \u03c4\u0304)\n|\u03b7(\u03c4)|2n = 1 |\u03b7(\u03c4)|2n WC({\u03c8ab}) , (89)\nwhere the variables xab in the complete enumerator polynomial are replaced by\n\u03c8ab(\u03c4, \u03c4\u0304) = \u2211\nk1,k2\u2208Z q\np 4 a+b p +k1+k2\n2\nq\u0304 p 4 a\u2212b p +k1\u2212k2\n2\n. (90)\nProof. We start with the complete enumerator polynomial\nWC({\u03c8ab}) = \u2211\nc\u2208C\n\u220f\n(a,b)\u2208Fp\u00d7Fp\n\u03c8ab(\u03c4, \u03c4\u0304) wtab(c) . (91)\nThe composition of a codeword c \u2208 C is given by the sum of wtab(ci) for each component:\nwtab(c) = n \u2211\ni=1\nwtab(ci) , (92)\nwhere, for each component of a codeword, we define\nwtab(ci) =\n1 , ci = (a, b) , 0 , ci \u0338= (a, b) . (93)\nThen, we have\nWC({\u03c8ab}) = \u2211\nc\u2208C\nn \u220f\ni=1\n\u220f\n(a,b)\u2208Fp\u00d7Fp\n\u03c8ab(\u03c4, \u03c4\u0304) wtab(ci)\n= \u2211\n(\u03b1,\u03b2)\u2208C\nn \u220f\ni=1\n\u03c8\u03b1i\u03b2i (\u03c4, \u03c4\u0304)\n= \u2211\n(\u03b1,\u03b2)\u2208C\n\u2211\nk1,k2 \u2208Zn q\np 4 \u03b1+\u03b2 p +k1+k2\n2\nq\u0304 p 4 \u03b1\u2212\u03b2 p +k1\u2212k2\n2\n= \u0398 e\u039b(C)(\u03c4, \u03c4\u0304) .\n(94)\nThe lattice theta function of the Construction A lattice from a classical code C appears. From (79), we divide the complete enumerator polynomial by |\u03b7(\u03c4)|2n to show the statement.\nIt is useful to write the function \u03c8ab as\n\u03c8ab(\u03c4, \u03c4\u0304) = \u0398a+b, p(\u03c4) \u0398\u0304a\u2212b, p(\u03c4\u0304) +\u0398a+b\u2212p, p(\u03c4) \u0398\u0304a\u2212b\u2212p, p(\u03c4\u0304) , (95)\nwhere (a, b) \u2208 Fp \u00d7 Fp and \u0398m, k(\u03c4) is the theta function\n\u0398m, k(\u03c4) = \u2211 n\u2208Z qk (n+ m 2k ) 2 . (96)\nFor an integer m \u2208 Z, the modular transformations of the theta functions are\n\u0398m, k(\u03c4+ 1) = e 2\u03c0i m 2 4k \u0398m, k(\u03c4) , (97) \u0398m, k(\u22121/\u03c4) = p \u2212i\u03c4 \u2211\nm\u2032\u2208Z2k\nM (k)mm\u2032 \u0398m\u2032,k(\u03c4) , (98)\nwhere M (k)mm\u2032 = 1p 2k\ne\u22122\u03c0i mm\u2032 2k .\nLet us return to the modular invariance for the partition functions of Narain code CFTs. We can derive it directly from the property of the code C. To see it, let us focus on the modular property of the lattice theta function in (89) since the modular transformation of the Dedekind eta function is given by\n\u03b7(\u03c4+ 1) = e2\u03c0i 1 24 \u03b7(\u03c4) , \u03b7(\u22121/\u03c4) = p \u2212i\u03c4\u03b7(\u03c4) . (99)\nIt is straightforward to see that the function \u03c8ab behaves as follows under the modular transformation:\n\u03c8ab(\u03c4, \u03c4\u0304)\u2192 e 2\u03c0i abp \u03c8ab(\u03c4, \u03c4\u0304) , (\u03c4\u2192 \u03c4+ 1) , \u03c8ab(\u03c4, \u03c4\u0304)\u2192 |\u2212 i\u03c4|\np\n\u2211\nw1,w2\u2208Fp\ne\u2212 2\u03c0i p (w1,w2)\u03b72(a,b) T \u03c8w1w2(\u03c4, \u03c4\u0304) , (\u03c4\u2192\u22121/\u03c4) .\n(100)\nUnder the modular transformation \u03c4\u2192 \u03c4+ 1, the lattice theta function behaves as\n\u0398 e\u039b(C)(\u03c4+ 1, \u03c4\u0304+ 1) =WC({e 2\u03c0i abp \u03c8ab}) = \u2211\nc\u2208C e\n2\u03c0i p \u2211 a,b\u2208Fp ab wtab(c) \u220f\n(a,b)\u2208Fp\u00d7Fp\n\u03c8 wtab(c) ab . (101)\nOur Narain code CFTs are based on doubly-even self-dual codes for p = 2 and self-dual codes for odd prime p. Then, the norm c \u2299 c = 2\u03b1 \u00b7\u03b2 = 2 \u2211\na,b\u2208Fp ab wtab(c) becomes a multiple of 4 for p = 2 and a multiple of p for odd prime p. Since 2 and p are coprime for odd prime p, we have\n\u2211\na,b\u2208Fp\nab wtab(c) = 0 mod p . (102)\nTherefore, the lattice theta function is invariant under the modular transformation \u03c4\u2192 \u03c4+ 1 from (101). Note that the invariance of the lattice theta function directly follows from doublyevenness for p = 2 and self-orthogonality for odd prime p. From the modular property (99) of the Dedekind eta function, we obtain the immediate consequence that the partition function is also invariant under \u03c4\u2192 \u03c4+ 1.\nOn the other hand, the lattice theta function transforms as follows under the modular transformation \u03c4\u2192\u22121/\u03c4:\n\u0398 e\u039b(C)(\u22121/\u03c4,\u22121/\u03c4\u0304) = | \u2212 i\u03c4| n WC({\u03a8ab}) , (103)\nwhere\n\u03a8ab(\u03c4, \u03c4\u0304) = 1 p \u2211\nw1,w2\u2208Fp\ne\u2212 2\u03c0i p (w1,w2)\u03b72(a,b) T \u03c8w1w2(\u03c4, \u03c4\u0304) , (104)\nwhere we use the fact that the complete enumerator polynomial is a homogeneous polynomial of degree n. We observe that the relation between \u03a8ab and \u03c8w1w2 is same as one between xv and x\u0303w in (88). Hence, the MacWilliams identity ensures that the complete enumerator polynomial is invariant under the linear transformation \u03a8ab \u2194 \u03c8ab for a self-dual code C: WC({\u03a8ab}) = WC({\u03c8ab}). We conclude that, under the modular transformation \u03c4 \u2192 \u22121/\u03c4, the lattice theta function behaves as WC({\u03c8ab})\u2192 |\u2212 i\u03c4|n WC({\u03c8ab}). The term | \u2212 i\u03c4|n that appears from the complete enumerator polynomial cancels with the one from the modular transformation (99) of the Dedekind eta function in the partition function. Therefore, the partition functions of our Narain code CFTs are invariant under \u03c4\u2192\u22121/\u03c4.\nIn this section, we have connected the properties and quantities of codes, lattices, and CFTs. For example, the complete enumerator polynomial determines the lattice theta function of the Construction A lattice and the partition function of the Narain code CFT. We show a list summarizing the main relations in table 1 while omitting some items for quantum codes because it does not matter in our construction.\n(p = 2) diag (H\u03b7HT ) = 0 mod 4 doubly-even\n[[n, 0]]p code\ns.t. H\u03b7HT = 0 mod p self-dual self-dual modular S invariance"
        },
        {
            "heading": "4.3 Example: CSS construction",
            "text": "Let us turn back to the partition functions of our Narain code CFTs. As in Proposition 4.4, the partition function is uniquely determined by the complete enumerator polynomial of a classical code C. We give some examples for Narain code CFTs focusing on the CSS construction described in Theorem 3.8.\nSuppose that a CSS code has a check matrix H(C ,C\u22a5) with a classical [n, k]p code C and its dual code C\u22a5. Let C be a classical code generated by the matrix GH = H(C ,C\u22a5). The complete enumerator polynomial of the code C is given by\nW (CSS) C ,C\u22a5 ({xab}) :=WC ({xab}) = \u2211\nc\u2208C , c\u2032 \u2208C\u22a5\n\u220f\n(a,b)\u2208Fp\u00d7Fp\nxwtab(c,c \u2032)\nab , (105)\nwhere c = (c1, \u00b7 \u00b7 \u00b7 , cn) \u2208 C and c\u2032 = (c\u20321, \u00b7 \u00b7 \u00b7 , c \u2032 n) \u2208 C \u22a5. Here, for (a, b) \u2208 Fp \u00d7 Fp, we set\nwtab(c, c \u2032) = { j \u2208 {1, \u00b7 \u00b7 \u00b7 , n} | c j = a, c\u2032j = b} . (106)\nThe complete enumerator polynomial of the CSS code is given in terms of a pair of classical codes C and C\u22a5. We point out that the complete enumerator polynomial can be understood as the 2-fold complete joint weight enumerator of classical codes C and C\u22a5.\nLet us consider r classical [n, ki]p codes C (i) (possibly distinct) where i = 1,2, \u00b7 \u00b7 \u00b7 , r, and define their product C = C (1) \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 C (r). The r-fold complete joint weight enumerator for C is given by ( [14])\nWC ({xv}) = \u2211\n(c(1), \u00b7\u00b7\u00b7 , c(r))\u2208C\n\u220f\nv\u2208Frp\nx wtv(c(1), \u00b7\u00b7\u00b7 , c(r)) v , (107)\nwhere v = (v1, \u00b7 \u00b7 \u00b7 , vr) \u2208 Frp, c (i) = (c(i)1 , \u00b7 \u00b7 \u00b7 , c (i) n ) \u2208 C (i), and\nwtv(c (1), \u00b7 \u00b7 \u00b7 , c(r)) = j \u2208 {1, \u00b7 \u00b7 \u00b7 , n} c(i)j = vi , i = 1, 2, \u00b7 \u00b7 \u00b7 , r . (108)\nNote that this is a generalization of (106). If we set r = 2 and (C (1), C (2)) = (C , C\u22a5), we arrive at the complete enumerator polynomial (105) for the CSS code. Then, we obtain\nW (CSS) C ,C\u22a5 ({xab}) =WC ({xab}) , (109)\nwhere C = C \u00d7 C\u22a5. As dictated in Proposition 4.4, the partition functions of the Narain code CFTs are determined by the complete enumerator polynomial of the associated classical code. Therefore, the partition function for the CSS construction turns out to be\nZ (CSS) C ,C\u22a5\n(\u03c4, \u03c4\u0304) = 1\n|\u03b7(\u03c4)|2n W (CSS) C ,C\u22a5 ({\u03c8ab}) . (110)\nOur CSS construction can be applied to a CSS code based on a classical self-dual code C = C\u22a5. Then, the 2-fold complete joint enumerator of C and C\u22a5 = C reduces to the genus-2 weight enumerator of C , which will be introduced in section 5 because it plays a significant role when averaging the partition functions over the CSS codes.\nFinally, we give some examples of the CSS construction. Let us consider a trivial [1,0]2 code C such that the generator matrix is GC = [0] and the check matrix is HC = [1]. Then, the CSS construction gives the check matrix\nH(C ,C\u22a5) = 1 0 , (111)\nwhere we omit the row that comes from the generator matrix GC in (65) because it does not contribute to nontrivial generators. The stabilizer generator of the CSS code is the Pauli X . The corresponding complete enumerator polynomial is given by\nW (CSS) C ,C\u22a5 ({xab}) = x00 + x10 . (112)\nHere, we have\n\u03c800 = \u03d13 \u03d1\u03043 + \u03d14 \u03d1\u03044\n2 , \u03c801 =\u03c810 = \u03d12 \u03d1\u03042 2 , \u03c811 = \u03d13 \u03d1\u03043 \u2212 \u03d14 \u03d1\u03044 2 , (113)\nwhere \u03d1i (i = 2, 3,4) are the Jacobi theta functions, \u03d12(\u03c4) \u2261 \u2211 n\u2208Z q 1 2(n\u2212 12)\n2\n,\n\u03d13(\u03c4) \u2261 \u2211 n\u2208Z q n2 2 , \u03d14(\u03c4) \u2261 \u2211 n\u2208Z (\u22121) n q n2 2 , q = e2\u03c0i\u03c4. Then, the partition function of the Narain code CFT becomes\nZ (CSS) C ,C\u22a5\n(\u03c4, \u03c4\u0304) = \u03d12 \u03d1\u03042 + \u03d13 \u03d1\u03043 + \u03d14 \u03d1\u03044\n2 |\u03b7(\u03c4)|2 . (114)\nAs another example, we consider the [2,1]5 self-dual code C whose generator matrix is given by GC = [12 ]. The parity check matrix is also HC = [1 2 ] because of self-duality. The check matrix of the corresponding CSS code is\nH(C ,C) =\n1 2 0 0\n0 0 1 2\n. (115)\nThe complete enumerator polynomial is\nW (CSS)C ,C ({xab}) = x 2 00 + x01 x02 + x01 x03 + x02 x04 + x03 x04 + x10 x20 + x13 x21 + x11 x22 + x14 x23 + x12 x24 + x10 x30 + x12 x31 + x14 x32 + x11 x33 + x13 x34 + x20 x40 + x30 x40 + x23 x41 + x32 x41 + x21 x42 + x34 x42 + x24 x43 + x31 x43 + x22 x44 + x33 x44 .\n(116)\nWe obtain the partition function of the Narain code CFT\nZ (CSS)C ,C (\u03c4, \u03c4\u0304) = 1 |\u03b7(\u03c4)|4 W (CSS)C ,C ({\u03c8ab}) , (117)\nwhere we substitute (95) to the variables xab."
        },
        {
            "heading": "5 Averaged partition function",
            "text": "Recently, the relation between an averaged theory over the whole Narain moduli and U(1) Chern-Simons theory with topological sum has been pointed out [15, 16]. In this section, we consider the averaged theory of the Narain code CFTs based on a class of CSS codes. Then, the average is a sum over the discrete points in the whole Narain moduli space. For a class of CSS codes defined by a single self-dual code C , we exactly compute the averaged partition functions of the associated Narain code CFTs. We will discuss the holographic implication of the averaged partition functions in section 6."
        },
        {
            "heading": "5.1 Higher-genus weight enumerator",
            "text": "We introduced the CSS construction for a pair (C , C\u22a5) with a classical code C in section 4.3. In this section, we focus on a pair (C , C) with self-dual codes C .\nLet H(C ,C) be a check matrix of a CSS code that is constructed from a single self-dual code C over Fp via (65). Suppose that C is a classical code generated by the matrix GH = H(C ,C). The complete enumerator polynomial of the classical code C is given by\nW (CSS)C ,C ({xab}) = \u2211\n(c, c\u2032)\u2208C2\n\u220f\n(a,b)\u2208Fp\u00d7Fp\nxwtab(c,c \u2032)\nab , (118)\nwhere, for codewords c = (c1, \u00b7 \u00b7 \u00b7 , cn) \u2208 C and c\u2032 = (c\u20321, \u00b7 \u00b7 \u00b7 , c \u2032 n) \u2208 C , we define\nwtab(c, c \u2032) = { j \u2208 {1, \u00b7 \u00b7 \u00b7 , n} | c j = a , c\u2032j = b} . (119)\nWe aim to average the above complete enumerator polynomial over a classical self-dual code C over Fp for fixed length n. Before taking the average, we interpret the complete enumerator polynomial of a quantum CSS code as a genus-2 weight enumerator of a classical self-dual code C . It is helpful for our task since the average of genus-g weight enumerators over doubly-even self-dual codes was considered in [30,31] for a binary case.\nLet us introduce higher-genus weight enumerators of a classical code C of length n. The genus-g weight enumerator of a classical code C over Fp is defined by\nWg, C({xv}) = \u2211\n(c(1), \u00b7\u00b7\u00b7 , c(g))\u2208C g\n\u220f\nv\u2208Fgp\nx wtv(c(1), \u00b7\u00b7\u00b7 , c(g)) v , (120)\nwhere for v = (v1, \u00b7 \u00b7 \u00b7 , vg) \u2208 F g p and c(i) = (c (i) 1 , \u00b7 \u00b7 \u00b7 , c (i) n ) \u2208 C , the term wtv c(1), \u00b7 \u00b7 \u00b7 , c(g)\nis given by the following:\nwtv(c (1), \u00b7 \u00b7 \u00b7 , c(g)) = j \u2208 {1, \u00b7 \u00b7 \u00b7 , n} c(i)j = vi , i = 1, 2, \u00b7 \u00b7 \u00b7 , g . (121)\nNote that wtv\nc(1), \u00b7 \u00b7 \u00b7 , c(g)\nis a generalization of (119) for g \u2265 2 and reduces to (119) for g = 2. For g = 1, the above genus-g weight enumerator becomes the usual complete enumerator polynomial of a classical code C .\nThe higher-genus weight enumerators are a reduced form of the complete joint weight enumeratorWC({xv}) introduced in section 4.3. Let us compare these definitions (107) and (120). The only difference is that the complete joint weight enumerator can deal with a product of different classical codes C = C (1)\u00d7\u00b7 \u00b7 \u00b7\u00d7C (r). If we set C = C r , the r-fold complete joint weight enumerator reduces to the genus-r weight enumerator of a classical code C:\nWC({xv}) =Wr,C({xv}) . (122)\nLet us return to the complete enumerator polynomial (118) of the CSS code. In section 4.3, we pointed out the coincidence (109) between the 2-fold complete joint enumerator of C = C\u00d7C\u22a5 and the complete enumerator polynomial of the classical code generated by the matrix H(C ,C\u22a5): W (CSS) C ,C\u22a5 ({xab}) =WC ({xab}). Focusing on a self-dual code C = C\u22a5, we get\nW (CSS)C ,C ({xab}) =WC ({xab}) , (123)\nwhere C = C \u00d7 C . The relation (122) implies the following result:\nW (CSS)C ,C ({xab}) =W2,C({xab}) . (124)\nTherefore, the complete weight enumerator of the CSS code can be understood as the genus-2 weight enumerator of the classical code C . Average of W (CSS)C ,C ({xab}) over self-dual codes C reduces to the sum of the genus-2 weight enumerator over classical self-dual codes.\nNow we give an alternative expression of the higher-genus weight enumerator (120), which will be useful when we consider the average over the CSS codes in the next subsection.\nLet c be a tuple of g elements c(i) \u2208 Fnp (i = 1, 2, \u00b7 \u00b7 \u00b7 , g), denoted by c= c(1), \u00b7 \u00b7 \u00b7 , c(g) . We\nassociate c to a tuple A(c) = (ev(c) | v \u2208 F g p) by\nev(c) = wtv\nc(1), \u00b7 \u00b7 \u00b7 , c(g) . (125)\nTo catch the meaning of this definition, consider n = 4, g = 2 and p = 3 case. Suppose we take two elements in Fn=4p=3 as\nc(1) = (1,2, 0,1) , c(2) = (0,1, 2,0) . (126)\nThe tuple A(c) can be read off from the four column vectors of the matrix whose rows are c(i):\nc(1)\nc(2)\n=\n1\n0\n2\n1\n0\n2\n1\n0\n. (127)\nIt follows from the definitions (121) and (125) that ev(c) counts the number of column vectors which match v. In this example, we have\ne10(c) = 2 , e21(c) = 1 , e02(c) = 1 , ev \u0338=10,21,02(c) = 0 . (128)\nNote that ev(c) are a partition of n\nn= \u2211\nv\u2208Fgp\nev(c) , (129)\nwhich is verified in the above example. With the tuple A(c), one can rewrite the genus-g weight enumerator (120) as\nWg,C({xv}) = \u2211 c\u2208C g xA(c) , (130)\nwhere xA(c) = \u220f v\u2208Fgp x ev(c) v ."
        },
        {
            "heading": "5.2 Average of higher-genus weight enumerator",
            "text": "We have found that the average of the complete enumerator polynomial over the CSS codes reduces to the sum of the genus-2 weight enumerator of self-dual codes. This section tackles more general problems: averaging the genus-g weight enumerator over self-dual codes.\nLet Mn,p be a set of classical self-dual codes C \u2282 Fnp with n and p fixed:\nMn,p = {self-dual codes over Fp of length n} . (131)\nThe average of the genus-g weight enumerators over a set of self-dual codes Mn,p is given by\nE(g)n,p({xv}) = 1 |Mn,p| \u2211\nC \u2208Mn,p\nWg,C({xv}) . (132)\nFor doubly-even self-dual codes over F2 of length n \u2208 8Z, these polynomials E (g) n,p({xv}) are called Eisenstein polynomials as being the counterpart of the Eisenstein series for lattices [31]. The genus-g Eisenstein polynomials E(g)n,p are given explicitly in [30,31].\nIn the following, we consider the averaged genus-g weight enumerators over self-dual codes C \u2282 Fn2 and C \u2282 F n p for an odd prime p, respectively."
        },
        {
            "heading": "5.2.1 For p = 2",
            "text": "Let us introduce some notions needed to describe our statements.\nType-I-admissible tuples We define a tuple A = ev | v \u2208 F g 2\nwhere ev \u2208 Z\u22650. We define the dimension of a tuple A as the dimension of the vector space spanned by the vectors (1v) satisfying ev > 0:\ndim2(A) = dimF2\u2329 {(1v) \u2208 F g+1 2 | ev > 0} \u232a , (133)\nwhere (1v) \u2208 Fg+12 is the binary vector such that the first component is 1 and the remaining components are v, and \u2329{a, b, c, \u00b7 \u00b7 \u00b7 }\u232a denotes the vector space spanned by the vectors a, b, c, \u00b7 \u00b7 \u00b7\nWe call A a type-I-admissible tuple if a tuple A is a partition of even n:\nn= \u2211\nv\u2208Fg2\nev = 0 mod 2 , (134)\nand it satisfies \u2211\nv\u2208Fg2\nev v Sd v T\n= 0 mod 2 , \u2211\nv\u2208Fg2\nev v Snd v T = 0 mod 4 , (135)\nwhere v = (v1, \u00b7 \u00b7 \u00b7 , vg) \u2208 F g 2 for all integral diagonal g \u00d7 g matrices Sd and all integral symmetric g \u00d7 g matrices Snd with 0s in diagonal elements. Let us illustrate the above definition of the dimension of a tuple by an example. Consider the genus-two (g = 2) and n = 8 case where v is a two-dimensional binary vector, v \u2208 {00,01, 10,11}= F22. Let us take a tuple A= ev | v \u2208 F22 = (e00, e01, e10, e11) such that\ne00 = 2 , e01 = 4 , e10 = 2 , e11 = 0 . (136)\nThen its dimension is given by\ndim2(A) = dimF2\u2329 {(1v) \u2208 F 3 2 | ev > 0} \u232a= dimF2\u2329 {100,101, 110}\u232a= 3 . (137)\nTo see if the tuple A is type-I-admissible, we examine the conditions (135) for 2\u00d7 2 matrices of the forms:\nSd =\na 0\n0 b\n, Snd =\n0 c\nc 0\n, (a, b, c \u2208 Z) . (138)\nThen, the conditions (135) become \u2211\nv1,v2 \u2208F2\nev (a v 2 1 + b v 2 2 ) = a (e10 + e11) + b (e01 + e11) = 0 mod 2 ,\n2 \u2211\nv1,v2 \u2208F2\nev c v1 v2 = 2 c e11 = 0 mod 4 . (139)\nFor the tuple (136), these equations hold for any integer a, b, c. Thus, the tuple A is type-Iadmissible in this example.\nSelf-orthogonal codes and type-I-admissible tuples For a tuple of g elements c= (c(1), \u00b7 \u00b7 \u00b7 , c(g)) \u2208 (Fn2) g , we define C as the [n, s(c)]2 code generated by 1n and c(1), \u00b7 \u00b7 \u00b7 , c(g) where s(c) is the dimension of the code. On the other hand, we associate c to a tuple A(c) = (ev(c) | v \u2208 F g 2) as in (125). There is a simple relation between the tuple A(c) and the dimension s(c):\ndim2(A(c)) = s(c) . (140)\nTo show this equality, note that the dimension of a code generated by 1n and c (1), \u00b7 \u00b7 \u00b7 , c(g) \u2208 Fn2 is given by the following:\ns(c) = rank\n\n    \n1 1 \u00b7 \u00b7 \u00b7 1 c(1)1 c (1) 2 \u00b7 \u00b7 \u00b7 c (1) n\n... ...\n...\nc(g)1 c (g) 2 \u00b7 \u00b7 \u00b7 c (g) n\n\n     . (141)\nElementary column operations reduce the right hand side to the dimension of the vector space spanned by the vectors {(1v) \u2208 Fg+12 | ev > 0}. Therefore, we arrive at the relation s(c) = dim2(A(c)).\nNow we state an important relation between the code C and the tuple A(c) which will play a key role in deriving the averaged weight enumerator:\nProposition 5.1 Let c be a tuple of g elements c= (c(1), \u00b7 \u00b7 \u00b7 , c(g)) \u2208 (Fn2)\ng . Then, the code C generated by 1n and c is self-orthogonal code of length n if and only if the associated tuple A(c) is type-I-admissible.\nProof. Assume that C is self-orthogonal. Let c(i) (i = 1,2, \u00b7 \u00b7 \u00b7 , g) be elements in the tuple c. The code C generated by 1n and c\n(i) (i = 1, 2, \u00b7 \u00b7 \u00b7 , g) is self-orthogonal if and only if 1n \u00b71n = 0 mod 2, 1n \u00b7 c(i) = c(i) \u00b7 c(i) = 0 mod 2, and c(i) \u00b7 c( j) = 0 mod 2 for i \u0338= j. The first condition implies n= \u2211\nv\u2208Fg2 ev(c) = 0 mod 2. Let us denote a binary vector v = (v1, \u00b7 \u00b7 \u00b7 , vg) \u2208 F g 2 where\nvi \u2208 F2 for convenience. Then\nc(i) \u00b7 c(i) = \u2211\nvi=1,v j \u0338=i\u2208F2\nev1\u00b7\u00b7\u00b7vg (c) = \u2211\nvi \u2208F2\nv2i \u2211\nv j \u0338=i\u2208F2\nev1\u00b7\u00b7\u00b7vg (c)\n= \u2211\nv1,\u00b7\u00b7\u00b7 ,vg \u2208F2\nev1\u00b7\u00b7\u00b7vg (c) v 2 i =\n\u2211\nv\u2208Fg2\nev(c) v S(i)d v T\n, (142)\nwhere S(i)d is the diagonal g \u00d7 g matrix with 1 at the (i, i)-th position and 0s elsewhere. The condition c(i) \u00b7 c(i) = 0 mod 2 for i = 1, 2, \u00b7 \u00b7 \u00b7 , g implies\n\u2211\nv\u2208Fg2\nev(c) v Sd v T = 0 mod 2 , (143)\nfor all integral diagonal g \u00d7 g matrices Sd. Also, we have for i \u0338= j\nc(i) \u00b7 c( j) = \u2211\nv1,\u00b7\u00b7\u00b7 ,vg \u2208F2\nev1\u00b7\u00b7\u00b7vg (c) vi v j = 1 2 \u2211\nv\u2208Fg2\nev(c) v S(i, j)nd v T , (144)\nwhere S(i, j)nd is the symmetric g \u00d7 g matrix with 1 at the (i, j)-th and ( j, i)-th positions, and 0s elsewhere. Then the other condition c(i) \u00b7 c( j) = 0 mod 2 becomes\n\u2211\nv\u2208Fg2\nev(c) v Snd v T = 0 mod 4 , (145)\nfor all integral symmetric g \u00d7 g matrices Snd with 0s in diagonal elements. Therefore, selforthogonality for C means that a tuple A(c) is type-I-admissible. If A(c) = (ev(c) | v \u2208 F g 2) is type-I-admissible, we can trace the above discussion backwards.\nMain theorem and its proof The following theorem gives the average of genus-g weight enumerators for self-dual codes over F2. For doubly-even self-dual codes, it was shown in [30, 31]. To our best knowledge, however, the formula for self-dual codes over F2 has not been stated explicitly in literature.\nTheorem 5.2 Let Mn,2 be a set of classical self-dual codes over F2 of length n \u2208 2Z. Then the average of genus-g weight enumerators is given by\nE(g)n,2({xv}) := 1 |Mn,2| \u2211\nC \u2208Mn,2\nWg,C({xv})\n= \u2211\nA\n1\n2 n 2\u22121 + 1 \u00b7 \u00b7 \u00b7 2 n 2\u2212dim2(A)+1 + 1 n A\nxA , (146)\nwhere the sum is extended over all type-I-admissible tuples A = (ev | v \u2208 F g 2). We denote xA = \u220f\nv\u2208Fg2 x evv and\nn A = n! \u220f\nv\u2208Fg2 ev!\n. (147)\nProof. We prove the theorem following [30] where the averaged genus-g weight enumerator over doubly-even self-dual codes over F2 is given.\nFirst, we use the tuple representation (130) of Wg,C ({xv}) to rewrite the averaged weight enumerator:\nE(g)n,2({xv}) = 1 |Mn,2| \u2211\nC \u2208Mn,2\nWg,C({xv})\n= (130) 1 |Mn,2| \u2211\nC \u2208Mn,2\n\u2211\nc\u2208C g xA(c)\n= 1 |Mn,2| \u2211\nc\u2208Fng2\n{C \u2208Mn,2 with c \u2208 C g} xA(c) ,\n(148)\nwhere {C \u2208Mn,2 with c \u2208 C g}\nis the number of binary self-dual codes of length n such that C g contains a tuple c.\nThe number of binary self-dual [n, n/2]2 codes, which contain a self-orthogonal [n, s]2 code including 1n \u2208 Fn2, is [56, Theorem 2.1]\nn 2\u2212s \u220f\ni=1\n(2i + 1) . (149)\nNote that self-dual codes contain only self-orthogonal codes because any subspaces of self-dual codes are self-orthogonal.\nSince all binary self-dual codes contain the all-ones vector 1n, self-dual codes containing c(i) (i = 1,2, \u00b7 \u00b7 \u00b7 , g) always contain the code C. It is obvious that self-dual codes contain the codewords c(i) (i = 1,2, \u00b7 \u00b7 \u00b7 , g) if they contain the code C. Hence, we get\n|{C \u2208Mn,2 with c \u2208 C g}|= |{C \u2208Mn,2 with C \u2282 C}| . (150)\nUsing the enumeration (149), we count the number of self-dual codes C such that c \u2208 C g as follows\n|{C \u2208Mn,2 , with c \u2208 C g}|=\n\n \n \nn 2\u2212s(c) \u220f\ni=1\n(2i + 1) , if C self-orthogonal,\n0 , otherwise.\n(151)\nConsider the case with s = 1 in (149). The formula returns the number of self-dual codes containing a self-orthogonal [n, 1]2 code C that contains 1n \u2208 Fn2. All binary self-dual codes contain the [n, 1]2 code that consists of the all-zeros vector and the all-ones vector. Therefore, (149) gives the number of whole binary self-dual codes enumerated in [57]\n|Mn,2|=\nn 2\u22121 \u220f\ni=1\n(2i + 1) . (152)\nTherefore, the averaged genus-g weight enumerator can be written as\nE(g)n,2({xv}) = 1 |Mn,2| \u2211\nc\u2208Fng2\n{C \u2208Mn,2 with c \u2208 C g} xA(c)\n= (151) (140)\n\u2211\nC\u2282C\u22a5\n1\n2 n 2\u22121 + 1 \u00b7 \u00b7 \u00b7 2 n 2\u2212dim2(A(c))+1 + 1\nxA(c)\n= \u2211\nA\n1\n2 n 2\u22121 + 1 \u00b7 \u00b7 \u00b7 2 n 2\u2212dim2(A)+1 + 1 n A xA .\n(153)\nIn the second line, the sum is extended over tuples c such that C is self-orthogonal. In the last line, we take the sum over type-I-admissible tuples A. The last line follows from Proposition 5.1 and the fact that, for a type-I-admissible tuple A = (ev | v \u2208 F g 2), there are n A\ntuples c which are different only in the order of coordinates.\nFor g = 1, the genus-g weight enumerator reduces to the usual complete enumerator polynomial. Then its average gives a well-known formula for the averaged enumerator polynomial over self-dual codes C \u2282 Fn2 (see for example p.329 in [53]):\nE(1)n,2({x0, x1}) = x n 0 + x n 1 +\n1\n2 n 2\u22121 + 1\nn 2\u22121 \u2211\ni=1\nn 2i x2i0 x n\u22122i 1 . (154)"
        },
        {
            "heading": "5.2.2 For odd prime p \u0338= 2",
            "text": "p-admissible tuples For a tuple A= (ev | v \u2208 F g p), we define the dimension of the tuple\ndimp(A) = dimFp\u2329 {v \u2208 F g p | ev > 0} \u232a . (155)\nWe call a tuple A as p-admissible if\nn= \u2211\nv\u2208Fgp\nev =\n0 mod 2 , (p = 1 mod 4) , 0 mod 4 , (p = 3 mod 4) , (156)\nand \u2211\nv\u2208Fgp\nev\nv S vT = 0 mod p , (157)\nfor all integral symmetric g \u00d7 g matrices S where v = (v1, \u00b7 \u00b7 \u00b7 , vg) \u2208 F g p .\nSelf-orthogonal codes and p-admissible tuples Let us take a tuple of g elements c = (c(1), \u00b7 \u00b7 \u00b7 , c(g)) \u2208 (Fnp)\ng . For each tuple c, we define C as the [n, s(c)]p code generated by c(1), \u00b7 \u00b7 \u00b7 , c(g) where s(c) is the dimension of the code. On the other hand, we associate c to a tuple A(c) = (ev(c) | v \u2208 F g p) as in (125). There is a relation dimp(A(c)) = s(c) because the dimension of the code C generated by c(1), \u00b7 \u00b7 \u00b7 , c(g) is given by\ns(c) = rank\n\n \nc(1)1 c (1) 2 \u00b7 \u00b7 \u00b7 c (1) n\n... ...\n...\nc(g)1 c (g) 2 \u00b7 \u00b7 \u00b7 c (g) n\n\n  , (158)\nwhich reduces to s(c) = dimp(A(c)) through the elementary column operations.\nProposition 5.3 Let c be a tuple of g elements c = c(1), \u00b7 \u00b7 \u00b7 , c(g)\n\u2208 (Fnp) g . Then, the code C generated by c is\nself-orthogonal code of length n if and only if the associated tuple A(c) is p-admissible.\nProof. Let c(i) (i = 1, \u00b7 \u00b7 \u00b7 , g) be elements in a tuple c. Note that C is self-orthogonal if and only if c(i) \u00b7 c(i) = 0 mod p, and c(i) \u00b7 c( j) = 0 mod p for i \u0338= j. Let us denote v = (v1, \u00b7 \u00b7 \u00b7 , vg) \u2208 F g p for convenience. Then we have\nc(i) \u00b7 c(i) = \u2211\nvi=1,v j \u0338=i\u2208Fp\nev1\u00b7\u00b7\u00b7vg = \u2211\nvi \u2208Fp\nv2i \u2211\nv j \u0338=i \u2208Fp\nev1\u00b7\u00b7\u00b7vg (c)\n= \u2211\nv1,\u00b7\u00b7\u00b7 ,vg \u2208Fp\nev1\u00b7\u00b7\u00b7vg (c) v 2 i =\n\u2211\nv\u2208Fgp\nev(c) v Sd v T\n, (159)\nwhere Sd is the diagonal g \u00d7 g matrix with 1 at the (i, i)-th position and 0s elsewhere. Therefore, c(i) \u00b7 c(i) = 0 mod p if and only if \u2211\nv\u2208Fgp ev(c)\nv Sd v T\n= 0 mod p. Also, we have for i \u0338= j\nc(i) \u00b7 c( j) = \u2211\nv1,\u00b7\u00b7\u00b7 ,vg \u2208Fp\nev1\u00b7\u00b7\u00b7vg (c) vi v j = 1 2 \u2211\nv\u2208Fgp\nev(c) v Snd v T\n, (160)\nwhere Snd is the symmetric g\u00d7g matrix with 1 at the (i, j)-th and ( j, i)-th position, and 0s elsewhere. Since we have c(i) \u00b7c( j) \u2208 Z, c(i) \u00b7c( j) = 0 mod p if and only if \u2211\nv\u2208Fgp ev(c)\nv Snd v T = 0\nmod p. Hence, a code C is self-orthogonal if and only if \u2211\nv\u2208Fgp ev(c)\nv S vT\n= 0 mod p for all integral symmetric g \u00d7 g matrices S. Let us consider the other condition (156) for a padmissible tuple. Since we have n= \u2211\nv\u2208Fgp ev(c), (156) holds automatically by the assumption in Theorem 5.4. Therefore, a code C is self-orthogonal if and only if A(c) is p-admissible.\nMain theorem and its proof\nTheorem 5.4 Let Mn,p be a set of classical self-dual codes C \u2282 Fnp for an odd prime p. (Then n \u2208 2Z for p = 1 mod 4 and n \u2208 4Z for p = 3 mod 4.) The average of genus-g weight enumerators is given by\nE(g)n,p({xv}) := 1 |Mn,p| \u2211\nC \u2208Mn,p\nWg,C({xv}) = \u2211\nA\n1\np n 2\u22121 + 1 \u00b7 \u00b7 \u00b7 p n 2\u2212dimp(A) + 1 n A xA , (161)\nwhere we take the sum over all p-admissible tuples. We denote xA = \u220f v\u2208Fgp x ev v and\nn A = n! \u220f\nv\u2208Fgp ev! . (162)\nProof. The proof is similar to the case with p = 2. The number of p-ary self-dual [n, n/2]p codes that contain a self-orthogonal [n, s]p code is [58]\n2\nn 2\u2212s\u22121 \u220f\ni=1\n(pi + 1) . (163)\nThen the number of p-ary self-dual codes that contain the code C is given by\n|{C \u2208Mn,p with c \u2208 C g}|=\n\n \n \n2\nn 2\u2212s(c)\u22121 \u220f\ni=1\n(pi + 1) , if C self-orthogonal,\n0 , otherwise.\n(164)\nFor s = 0, (163) reduces to the number of p-ary self-dual codes of length n enumerated in [57]\n|Mn,p|= 2\nn 2\u22121 \u220f\ni=1\n(pi + 1) . (165)\nThe averaged genus-g weight enumerator is\nE(g)n,p({xv}) = 1 |Mn,p| \u2211\nC \u2208Mn,p\nWg,C({xv})\n= 1 |Mn,p| \u2211\nC \u2208Mn,p\n\u2211\nc\u2208C g xA(c)\n= 1 |Mn,p| \u2211\nc\u2208Fgp\n|{C \u2208Mn,p with c \u2208 C g}| xA(c)\n= \u2211\nC\u2282C\u22a5\n1\np n 2\u22121 + 1 \u00b7 \u00b7 \u00b7 p n 2\u2212dimp(A(c)) + 1\nxA(c)\n= \u2211\nA\n1\np n 2\u22121 + 1 \u00b7 \u00b7 \u00b7 p n 2\u2212dimp(A) + 1 n A xA .\n(166)\nIn the fourth line, the sum is taken over tuples c such that C is self-orthogonal. In the last line, we take the sum over p-admissible tuples A. We obtain the last line because, for a padmissible tuple A= (ev | v \u2208 F g p), there are n A\ntuples c which are different only in the order of coordinates."
        },
        {
            "heading": "5.3 Averaging over CSS codes",
            "text": "Let us go back to the complete enumerator polynomial of a CSS code whose check matrix is given by H(C ,C). As discussed in section 5.1, the complete enumerator polynomial can be written as the genus-2 weight enumerator of the associated classical self-dual code C:\nW (CSS)C ,C ({xab}) =W2,C({xab}) . (167)\nTherefore, the average of the complete enumerator polynomials over a set of self-dual codes Mn,p reduces to the averaged genus-2 weight enumerator over Mn,p:\nW (CSS) n,p ({xab}) = 1 |Mn,p| \u2211\nC \u2208Mn,p\nW (CSS)C ,C ({xab})\n= 1 |Mn,p| \u2211\nC \u2208Mn,p\nW2,C({xab})\n= E(2)n,p({xab})\n=\n\n  \n  \n\u2211\nA\n1\n2 n 2\u22121 + 1 \u00b7 \u00b7 \u00b7 2 n 2\u2212dim2(A)+1 + 1 n A xA , if p = 2 ,\n\u2211\nA\n1\np n 2\u22121 + 1 \u00b7 \u00b7 \u00b7 p n 2\u2212dimp(A) + 1 n A xA , if p odd prime.\n(168)\nLet us evaluate W (CSS) n,p ({xab}) in the large-n limit. To approximate the sums by integrals,\nwe define variables zab :=\neab n . (169)\nSince the tuple A= (eab|a, b \u2208 Fp) is a partition of n, we have zab \u2265 0 and \u2211\na,b zab = 1. In the large-n limit the sums over A become (p2 \u2212 1)-dimensional integrals over\nzab|(a, b) \u0338= (0, 0)\nin the region defined by zab \u2265 0 and \u2211\n(a,b)\u0338=(0,0) zab \u2264 1. When p = 2, for the tuple A to be type-I admissible, eab must satisfy the conditions\ne01 = e10 = e11 = 0 mod 2 , (170)\nwhich follow from (139). When p is an odd prime integer, for A to be p-admissible, eab must obey\n\u2211\na,b\u2208Fp\na2 eab = \u2211\na,b\u2208Fp\nb2 eab = \u2211\na,b\u2208Fp\na b eab = 0 mod p , (171)\nas follow from (156). Given generic values of the variables (zab|a \u0338= 0, b \u0338= 0), the condition (170) or (171) reduces the number of allowed values of (z01, z10, z11) by p3 in either case. We also note that for generic A, the dimension defined by (133) and (155) is dimp(A) = 3 for p = 2 and dimp(A) = 2 for odd prime p. In both cases, in the large-n limit, (168) is approximated by a (p2 \u2212 1)-dimensional integral over the region defined above\nW (CSS) n,p ({xab})\u2243 p\n\u2212n n\n2\u03c0\np2\u22121 2 \u222b\n\u220f\n(a,b)\u0338=(0,0)\ndzab\n\u220f\na,b\nxab zab nzab z \u2212 12 ab , (172)\nwhere we used Stirling\u2019s formula n!= (2\u03c0n)1/2(n/e)n(1+O(n\u22121)). In Appendix B we evaluate the integral (172) by the saddle point method. We find that\nW (CSS) n,p ({xab}) = p \u2212n\n\u2211\na,b\nxab\n!n\n(1+O(n\u22121)) . (173)\nTo explore the density of states, let us simplify the averaged partition function by fixing the torus moduli \u03c4 = i\u03c42 = i\u03b2/2\u03c0 (\u03c41 = 0). Then we have q = q\u0304 = e\u2212\u03b2 and \u03c8ab = \u03c8a\u03c8b where\n\u03c8a(i\u03c42) = \u2211\nk\u2208Z q\np 2 a p+k\n2\n. (174)\nDue to the relation (117) between the partition function and the enumerator polynomial, the averaged partition function reduces, for large n, to\nZ (CSS) n,p (i\u03c42)\u2243 1 pn |\u03b7(i\u03c42)|2n \u2211\na\u2208Fp\n\u03c8a(i\u03c42)\n!2n\n= 1\npn |\u03b7(i\u03c42)|2n\n\u2211 k\u2208Z e\u2212\u03c0\u03c42 k2 p\n2n\n= \u03d13(i\u03c42/p)2n\npn|\u03b7(i\u03c42)|2n .\n(175)\nThe above partition function exactly agrees with the averaged partition function over the Bform codes in the large-n limit, which was conjectured in [28]."
        },
        {
            "heading": "6 Discussion",
            "text": "In this paper, we constructed a class of Narain code CFTs from p-ary qudit stabilizer codes for a prime p. Our construction was based on two fundamental relations: one between qudit codes to classical codes [8\u201310] and the other between classical codes and Lorentzian lattice [11]. The former is actually not limited to the case we considered but holds between pm-ary stabilizer codes and self-orthogonal classical codes over Fp2m for arbitrary integer m \u2265 1 [10]. The latter relation is also likely to hold true for a broader class of classical codes [11]. Thus, we speculate that there is a class of Narain code CFTs associated with pm-ary stabilizer codes for any integer m\u2265 1.\nIn section 5, we considered the CSS codes as a special class of qudit codes and examined the averaged theory over the corresponding Narain code CFTs along the line of [15, 16]. We showed that the averaged partition function over the CSS codes takes the same form as the conjectured form of the partition function averaged over the B-form codes in the large-n limit. Our definition of the averaged partition function is different from theirs as we take the average over all CSS codes associated with self-dual classical codes including equivalent ones while their averaging is over inequivalent qudit stabilizer codes. In the large-n limit, this difference may be ignorable. Also our result implies that the CSS codes sample a typical set of quantum codes in this limit.\nIn section 5.3, we calculated the averaged partition function over the CSS codes (175). By noting that |\u03b7(i\u03c42)|2n in the denominator accounts for the descendant contributions, the density of primary states \u03c1(\u2206) for the averaged code CFT can be read off from Z\n(CSS) n,p (i\u03c42)\nwith \u03c42 = \u03b2 2\u03c0 as\n\u03d13(i\u03b2/2\u03c0p)2n\npn =\n\u222b \u221e\n0\nd\u2206 e\u2212\u03b2\u2206\u03c1(\u2206) . (176)\nNarain code CFTs (p : small)\nNarain code CFTs (p : large)\nThe asymptotic form of \u03c1(\u2206) in \u2206\u2192\u221e is5\n\u03c1(\u2206)\u2243 (2\u03c0)n\u2206n\u22121\n\u0393 (n) . (177)\nNumerical experiments suggest that this asymptotic form is valid for \u2206\u2273 1p log n and is likely to be exact when p is large enough compared to log n.6 The density of states (177) is the same as the one for the averaged CFT of central charge c = n over the whole Narain moduli, which is shown to have a spectral gap\u2206= c2\u03c0e in the large-c limit [16]. We expect that our averaged Narain code CFT over the CSS codes has the same spectral gap in the large-n limit for a large prime integer p and that there exists a Narain CSS code CFT with the spectral gap \u2206= c2\u03c0e .\nIn recent studies, ensemble averaging is seen as a key to understanding holographic duality [60]. The average of Narain CFTs has a large spectral gap and has been proposed to have a holographic interpretation in terms of an abelian Chern-Simons theory [15, 16]. We expect that our averaged theory over the CSS codes also has a large spectral gap, and may have a dual gravity description in the large-n limit. Note that our ensemble average depends on the choice of a prime number p. We conjecture that each ensemble has a different gravity description as in [17, 18, 21, 22, 27\u201329]. In our case, the size of the ensemble increases for larger p as in (165) and we expect the averaged theory tends to the one over the whole Narain moduli space (see figure 2).\nEven without averaging, a Narain code CFT is related to an abelian Chern-Simons theory. Indeed (89) and (95) imply that the partition function is given as a finite sum involving U(1)2p characters\u0398m,p(\u03c4)/\u03b7(\u03c4) and is therefore a rational CFT with an extended chiral algebra corresponding to the U(1)n2p Chern-Simons theory. (See for example [61].) It would be interesting to see if the conjectural holographic description above can be obtained from an ensemble of Chern-Simons theories.\nThere are also other directions of research related to quantum codes and CFTs [62\u201368]. It deserves further investigation to see whether our construction is relevant to these recent developments.\n5This statement follows from the direct calculation or Tauberian theorem (see, for example, Theorem 15.3 of section 1 in [59]).\n6Note that we are focused on the large-n limit of the averaged theory here."
        },
        {
            "heading": "Acknowledgments",
            "text": "We are grateful to S. Yahagi for valuable discussions. The work of T. N. was supported in part by the JSPS Grant-in-Aid for Scientific Research (C) No.19K03863, Grant-in-Aid for Scientific Research (A) No. 21H04469, and Grant-in-Aid for Transformative Research Areas (A) \u201cExtreme Universe\u201d No. 21H05182 and No. 21H05190. The research of T. O. was supported in part by Grant-in-Aid for Transformative Research Areas (A) \u201cExtreme Universe\u201d No. 21H05190. The work of K. K. was supported by Forefront Physics and Mathematics Program to Drive Transformation (FoPM), a World-leading Innovative Graduate Study (WINGS) Program, the University of Tokyo."
        },
        {
            "heading": "A List of notations",
            "text": "Symbol Definition See\np A prime number.\nFq The field of order q. Hp Hilbert space of a qudit system with p states . \u03c9p The primitive p-th root of unity (\u03c9p = e2\u03c0i/p).\ng(\u03b1,\u03b2) The generalized Pauli operator on the single-qudit system. Eq.(10)\ng(\u03b1,\u03b2) The generalized Pauli operator on the n-qudit system. Eq.(13)\nP(p)n The n-qudit Pauli group. \u2329\u00b7, \u00b7\u232a The symplectic bilinear form on F2np .\nS A stabilizer group.\nVS The code subspace stabilized by a stabilizer group S.\nN(G) The normalizer of a subgroup G in an appropriate group.\nH The check matrix of a stabilizer code. Eq.(20)\nG The generator matrix of a stabilizer code. Eq.(25)\nW A matrix that defines the symplectic product \u2329\u00b7, \u00b7\u232a on F2np . Eq.(22) In The n\u00d7 n identity matrix.\nU(n) The unitary group of degree n.\nC A classical code on Fnp. GC The generator matrix of a classical code C .\nHC The parity check matrix of a classical code C .\nc A codeword of a classical code (written as a row vector on Fnp). \u00b7 The Euclidean inner product over Fnp.\nC\u22a5 The dual code of a classical code C with respect to the Euclidean inner product. Eq.(35)\nH(CX ,CZ ) The check matrix of the CSS code constructed from CX and CZ . Eq.(38)\nGH The generator matrix of the classical code with a check matrix H. Eq.(47)\nC The classical code generated by the matrix GH. Eq.(48)\n\u03b7 The off-diagonal Lorentzian metric. Eq.(49)\n\u2299 The inner product with respect to the metric \u03b7. C\u22a5 The dual code of a classical code C with respect to the metric \u03b7. Eq.(51) \u039b(C) The Construction A lattice from a classical code C. Eq.(54) \u039b\u2217 The dual lattice of a lattice \u039b with respect to the metric \u03b7. Eq.(55)\n\u03bb A lattice vector written as a row vector.\ne\u03b7 The diagonal Lorentzian metric. Eq.(74)\n\u25e6 The inner product with respect to the metric e\u03b7. Eq.(73) e\u039b(C) The momentum lattice obtained by a linear transformation from the\nConstruction A lattice \u039b(C). (pL , pR) A momentum vector that is an element of a momentum lattice.\nZC The partition function of a Narain code CFT. Eq.(79)\n\u0398 e\u039b(C) The lattice theta function of the momentum lattice obtained from a classical code C. Eq.(80)\nWC The complete enumerator polynomial of a classical code C. Eq.(83) W (CSS)\nC ,C\u22a5 The complete enumerator polynomial of a classical code based on a CSS code with a check matrix H(C ,C\u22a5). Eq.(105)\nC The product of r classical codes: C = C (1) \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 C (r)\nWC The r-fold complete joint weight enumerator for C = C (1)\u00d7\u00b7 \u00b7 \u00b7\u00d7C (r). Eq.(107) Z (CSS)\nC ,C\u22a5 The partition function of a Narain code CFT based on a CSS code with a check matrix H(C ,C\u22a5). W (CSS)C ,C The complete enumerator polynomial of a classical code based on a CSS code with a check matrix H(C ,C) for a self-dual code C . Eq.(118)\nWg,C The genus-g weight enumerator of a classical code C . Eq.(120) Mn,p The set of classical self-dual codes C \u2282 Fnp. Eq.(131) E(g)n,p The average of genus-g weight enumerators over the set Mn,p. Eq.(132) A A tuple of non-negative integers ev where v \u2208 F g p .\ndim2(A) The dimension of a tuple A for p = 2. Eq.(133)\ndimp(A) The dimension of a tuple A for odd prime p. Eq.(155)\nc A tuple of g codewords: c= (c(1), \u00b7 \u00b7 \u00b7 , c(g)). C The classical code generated by 1n and c for p = 2 and by c for odd\nprime p.\nW (CSS) n,p The averaged complete enumerator polynomial of CSS codes over\nself-dual codes C \u2208Mn,p. Eq.(168)\nZ (CSS) n,p The averaged partition function of Narain code CFTs based on a class\nof CSS codes."
        },
        {
            "heading": "B Saddle point computation",
            "text": "In this appendix we perform a saddle point computation of the integral (172) to derive the result (173). For this purpose, let us introduce the function\nf (z) := \u2211\na,b\nzab log zab xab . (B.1)\nWe treat zab with (a, b) \u0338= (0,0) as independent variables. Using the relation z00 = 1\u2212 \u2211 (a,b)\u0338=(0,0) zab, we find for (a, b) \u0338= (0,0) and (c, d) \u0338= (0, 0)\n\u2202 f \u2202 zab = log zab z00 x00 xab , Hab;cd := \u2202 2 f \u2202 zab\u2202 zcd = \u03b4ac\u03b4bd zab + 1 z00 . (B.2)\nThe saddle point z\u2217 defined as the solution of \u2202 f /\u2202 zab = 0 is\nz\u2217ab = xab \u2211\nc,d\u2208Fp xcd . (B.3)\nAfter several non-trivial cancellations in the saddle point computation of the integral, we are left with\nW (CSS) n,p ({xab}) = p \u2212n\n\u2211\na,b\nxab\nn \u220f\n(a,b)\nz\u2217ab \u22121/2 (det H|z=z\u2217) \u22121/2 1+O(n\u22121) . (B.4)\nThe Hessian matrix H given in (B.2) is of the form\ndiag 1 y1 , . . . , 1 yL + 1 x\n\n  1 ...\n1\n\n  1 . . . 1 = 1 x diag 1 y1 , . . . , 1 yL (x I + B) , (B.5)\nwhere\nB =\n\n  y1 ...\nyL\n\n  1 . . . 1 . (B.6)\nThe determinant of x I + B is the characteristic polynomial of \u2212B, which is given by x L\u22121(x+ y1+. . .+ yL) because the eigenvalues of B are 0 with multiplicity L\u22121 and y1+. . .+ yL . Then we find\ndet H|z=z\u2217 =\n\u220f\n(a,b)\nz\u2217ab\n\u22121 . (B.7)\nThus the third and the fourth factors in (B.4) exactly cancel out, giving the result (173)."
        }
    ],
    "title": "Narain CFTs from qudit stabilizer codes",
    "year": 2023
}