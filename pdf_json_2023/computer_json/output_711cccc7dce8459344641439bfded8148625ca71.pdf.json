{
    "abstractText": "The streaming model was introduced to parameterized complexity independently by Fafianie and Kratsch [MFCS14] and by Chitnis, Cormode, Hajiaghayi and Monemizadeh [SODA15]. Subsequently, it was broadened by Chitnis, Cormode, Esfandiari, Hajiaghayi and Monemizadeh [SPAA15] and by Chitnis, Cormode, Esfandiari, Hajiaghayi, McGregor, Monemizadeh and Vorotnikova [SODA16]. Despite its strong motivation, the applicability of the streaming model to central problems in parameterized complexity has remained, for almost a decade, quite limited. Indeed, due to simple \u03a9(n)-space lower bounds for many of these problems, the kO(1) \u00b7 polylog(n)-space requirement in the model is too strict. Thus, we explore semi-streaming algorithms for parameterized graph problems, and present the first systematic study of this topic. Crucially, we aim to construct succinct representations of the input on which optimal post-processing time complexity can be achieved. \u2022 We devise meta-theorems specifically designed for parameterized streaming and demonstrate their applicability by obtaining the first kO(1) \u00b7n \u00b7 polylog(n)-space streaming algorithms for wellstudied problems such as Feedback Vertex Set on Tournaments, Cluster Vertex Deletion, Proper Interval Vertex Deletion and Block Vertex Deletion. In the process, we demonstrate a fundamental connection between semi-streaming algorithms for recognizing graphs in a graph classH and semi-streaming algorithms for the problem of vertex deletion intoH. \u2022 We present an algorithmic machinery for obtaining streaming algorithms for cut problems and exemplify this by giving the first kO(1) \u00b7 n \u00b7 polylog(n)-space streaming algorithms for Graph Bipartitization, Multiway Cut and Subset Feedback Vertex Set. \u2217University of California, Santa Barbara, USA. daniello@ucsb.edu \u2020Chennai Mathematical Institute. pranabendu@cmi.ac.in \u2021Indian Institute of Technology, Hyderabad. fahad@iith.ac.in \u00a7University of Warwick, UK. r.maadapuzhi-sridharan@warwick.ac.uk \u00b6Department of Informatics, University of Bergen, Norway and Institute of Mathematical Sciences, HBNI, India, saket@imsc.res.in \u2225Ben-Gurion University of the Negev, Israel. meiravze@bgu.ac.il ar X iv :2 30 8. 01 59 8v 1 [ cs .D S] 3 A ug 2 02 3",
    "authors": [
        {
            "affiliations": [],
            "name": "Daniel Lokshtanov"
        },
        {
            "affiliations": [],
            "name": "Pranabendu Misra"
        },
        {
            "affiliations": [],
            "name": "Fahad Panolan"
        },
        {
            "affiliations": [],
            "name": "M. S. Ramanujan"
        },
        {
            "affiliations": [],
            "name": "Saket Saurabh"
        },
        {
            "affiliations": [],
            "name": "Meirav Zehavi"
        }
    ],
    "id": "SP:31fc440c051167a047ce358b87f44ea22cce6b41",
    "references": [
        {
            "authors": [
                "Akanksha Agrawal",
                "Sudeshna Kolay",
                "Daniel Lokshtanov",
                "Saket Saurabh"
            ],
            "title": "A faster FPT algorithm and a smaller kernel for block graph vertex deletion",
            "venue": "LATIN 2016: Theoretical Informatics - 12th Latin American Symposium,",
            "year": 2016
        },
        {
            "authors": [
                "Josh Alman",
                "Matthias Mnich",
                "Virginia Vassilevska Williams"
            ],
            "title": "Dynamic parameterized problems and algorithms",
            "venue": "ACM Trans. Algorithms,",
            "year": 2020
        },
        {
            "authors": [
                "Ann Becker",
                "Reuven Bar-Yehuda",
                "Dan Geiger"
            ],
            "title": "Randomized algorithms for the loop cutset problem",
            "venue": "J. Artif. Intell. Res.,",
            "year": 2000
        },
        {
            "authors": [
                "Ann Becker",
                "Reuven Bar-Yehuda",
                "Dan Geiger"
            ],
            "title": "Randomized algorithms for the loop cutset problem",
            "venue": "Journal of Artificial Intelligence Research,",
            "year": 2000
        },
        {
            "authors": [
                "Davide Bil\u00f2",
                "Katrin Casel",
                "Keerti Choudhary",
                "Sarel Cohen",
                "Tobias Friedrich",
                "J.A. Gregor Lagodzinski",
                "Martin Schirneck",
                "Simon Wietheger"
            ],
            "title": "Fixed-parameter sensitivity oracles",
            "venue": "13th Innovations in Theoretical Computer Science Conference, ITCS 2022,",
            "year": 2022
        },
        {
            "authors": [
                "Andreas Brandst\u00e4dt",
                "Van Bang Le",
                "Jeremy P Spinrad"
            ],
            "title": "Graph classes: a survey",
            "year": 1999
        },
        {
            "authors": [
                "Neta Barkay",
                "Ely Porat",
                "Bar Shalem"
            ],
            "title": "Efficient sampling of non-strict turnstile data streams",
            "venue": "Theor. Comput. Sci.,",
            "year": 2015
        },
        {
            "authors": [
                "Rajesh Chitnis",
                "Graham Cormode"
            ],
            "title": "Towards a theory of parameterized streaming algorithms",
            "venue": "14th International Symposium on Parameterized and Exact Computation, IPEC 2019,",
            "year": 2019
        },
        {
            "authors": [
                "Jiehua Chen",
                "Wojciech Czerwinski",
                "Yann Disser",
                "Andreas Emil Feldmann",
                "Danny Hermelin",
                "Wojciech Nadara",
                "Marcin Pilipczuk",
                "Michal Pilipczuk",
                "Manuel Sorge",
                "Bartlomiej Wr\u00f3blewski",
                "Anna Zych-Pawlewicz"
            ],
            "title": "Efficient fully dynamic elimination forests with applications to detecting long paths and cycles",
            "venue": "Proceedings of the 2021 ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2021
        },
        {
            "authors": [
                "Rajesh Chitnis",
                "Graham Cormode",
                "Hossein Esfandiari",
                "MohammadTaghi Hajiaghayi",
                "Andrew McGregor",
                "Morteza Monemizadeh",
                "Sofya Vorotnikova"
            ],
            "title": "Kernelization via sampling with applications to finding matchings and related problems in dynamic graph streams",
            "venue": "Proceedings of the Twenty-Seventh Annual ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2016
        },
        {
            "authors": [
                "Rajesh Hemant Chitnis",
                "Graham Cormode",
                "Mohammad Taghi Hajiaghayi",
                "Morteza Monemizadeh"
            ],
            "title": "Parameterized streaming: Maximal matching and vertex cover",
            "venue": "Proceedings of the Twenty-Sixth Annual ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2015
        },
        {
            "authors": [
                "Parinya Chalermsook",
                "Marek Cygan",
                "Guy Kortsarz",
                "Bundit Laekhanukit",
                "Pasin Manurangsi",
                "Danupon Nanongkai",
                "Luca Trevisan"
            ],
            "title": "From gap-exponential time hypothesis to fixed parameter tractable inapproximability: Clique, dominating set, and more",
            "venue": "SIAM J. Comput.,",
            "year": 2020
        },
        {
            "authors": [
                "Parinya Chalermsook",
                "Marek Cygan",
                "Guy Kortsarz",
                "Bundit Laekhanukit",
                "Pasin Manurangsi",
                "Danupon Nanongkai",
                "Luca Trevisan"
            ],
            "title": "From gap-exponential time hypothesis to fixed parameter tractable inapproximability: Clique, dominating set, and more",
            "venue": "SIAM J. Comput.,",
            "year": 2020
        },
        {
            "authors": [
                "Amit Chakrabarti",
                "Prantar Ghosh",
                "Andrew McGregor",
                "Sofya Vorotnikova"
            ],
            "title": "Vertex ordering problems in directed graph streams",
            "venue": "Proceedings of the 2020 ACMSIAM Symposium on Discrete Algorithms,",
            "year": 2020
        },
        {
            "authors": [
                "Marek Cygan",
                "Pawel Komosa",
                "Daniel Lokshtanov",
                "Marcin Pilipczuk",
                "Michal Pilipczuk",
                "Saket Saurabh",
                "Magnus Wahlstr\u00f6m"
            ],
            "title": "Randomized contractions meet lean decompositions",
            "venue": "ACM Trans. Algorithms,",
            "year": 2021
        },
        {
            "authors": [
                "Marek Cygan",
                "Daniel Lokshtanov",
                "Marcin Pilipczuk",
                "Michal Pilipczuk",
                "Saket Saurabh"
            ],
            "title": "Minimum bisection is fixed-parameter tractable",
            "venue": "SIAM J. Comput.,",
            "year": 2019
        },
        {
            "authors": [
                "Mark de Berg",
                "Hans L. Bodlaender",
                "S\u00e1ndor Kisfaludi-Bak",
                "D\u00e1niel Marx",
                "Tom C. van der Zanden"
            ],
            "title": "A framework for eth-tight algorithms and lower bounds in geometric intersection graphs",
            "venue": "In Proceedings of the 50th Annual ACM SIGACT Symposium on Theory of Computing,",
            "year": 2018
        },
        {
            "authors": [
                "Erik D. Demaine",
                "Mohammad Taghi Hajiaghayi"
            ],
            "title": "Bidimensionality: new connections between FPT algorithms and ptass",
            "venue": "In Proceedings of the Sixteenth Annual ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2005
        },
        {
            "authors": [
                "Xiaotie Deng",
                "Pavol Hell",
                "Jing Huang"
            ],
            "title": "Linear-time representation algorithms for proper circular-arc graphs and proper interval graphs",
            "venue": "SIAM J. Comput.,",
            "year": 1996
        },
        {
            "authors": [
                "Erik D. Demaine",
                "Mohammad Taghi Hajiaghayi",
                "Ken-ichi Kawarabayashi"
            ],
            "title": "Algorithmic graph minor theory: Decomposition, approximation, and coloring",
            "venue": "In 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS 2005),",
            "year": 2005
        },
        {
            "authors": [
                "Reinhard Diestel"
            ],
            "title": "Graduate texts in mathematics",
            "venue": "Graph theory,",
            "year": 2000
        },
        {
            "authors": [
                "Zdenek Dvor\u00e1k",
                "Martin Kupec",
                "Vojtech Tuma"
            ],
            "title": "A dynamic data structure for MSO properties in graphs with bounded tree-depth",
            "venue": "Algorithms - ESA 2014 - 22th Annual European Symposium,",
            "year": 2014
        },
        {
            "authors": [
                "Rod Downey"
            ],
            "title": "The birth and early years of parameterized complexity. In The Multivariate Algorithmic Revolution and Beyond - Essays",
            "venue": "Dedicated to Michael R. Fellows on the Occasion of His 60th Birthday,",
            "year": 2012
        },
        {
            "authors": [
                "Stefan Fafianie",
                "Stefan Kratsch"
            ],
            "title": "Streaming kernelization",
            "venue": "In International Symposium on Mathematical Foundations of Computer Science,",
            "year": 2014
        },
        {
            "authors": [
                "Andreas Emil Feldmann",
                "Karthik C. S",
                "Euiwoong Lee",
                "Pasin Manurangsi"
            ],
            "title": "A survey on approximation in parameterized complexity",
            "venue": "Hardness and algorithms. Algorithms,",
            "year": 2020
        },
        {
            "authors": [
                "Joan Feigenbaum",
                "Sampath Kannan",
                "Andrew McGregor",
                "Siddharth Suri",
                "Jian Zhang"
            ],
            "title": "On graph problems in a semi-streaming model",
            "venue": "Theor. Comput. Sci.,",
            "year": 2005
        },
        {
            "authors": [
                "Joan Feigenbaum",
                "Sampath Kannan",
                "Martin Strauss",
                "Mahesh Viswanathan"
            ],
            "title": "An approximate l1-difference algorithm for massive data streams",
            "venue": "SIAM J. Comput.,",
            "year": 2002
        },
        {
            "authors": [
                "Fedor V. Fomin",
                "Daniel Lokshtanov",
                "Neeldhara Misra",
                "Saket Saurabh"
            ],
            "title": "Planar F-deletion: Approximation, kernelization and optimal FPT algorithms",
            "venue": "In Proceedings of the 53rd Annual Symposium on Foundations of Computer Science (FOCS),",
            "year": 2012
        },
        {
            "authors": [
                "Fedor V. Fomin",
                "Daniel Lokshtanov",
                "Fahad Panolan",
                "Saket Saurabh",
                "Meirav Zehavi"
            ],
            "title": "Finding, hitting and packing cycles in subexponential time on unit disk graphs",
            "venue": "Discret. Comput. Geom.,",
            "year": 2019
        },
        {
            "authors": [
                "Fedor V. Fomin",
                "Daniel Lokshtanov",
                "Fahad Panolan",
                "Saket Saurabh",
                "Meirav Zehavi"
            ],
            "title": "Ethtight algorithms for long path and cycle on unit disk graphs",
            "venue": "In 36th International Symposium on Computational Geometry,",
            "year": 2020
        },
        {
            "authors": [
                "Toshihiro Fujito"
            ],
            "title": "A unified approximation algorithm for node-deletion problems",
            "venue": "Discret. Appl. Math.,",
            "year": 1998
        },
        {
            "authors": [
                "Panos Giannopoulos",
                "Christian Knauer",
                "Sue Whitesides"
            ],
            "title": "Parameterized complexity of geometric problems",
            "venue": "The Computer Journal,",
            "year": 2008
        },
        {
            "authors": [
                "Fabrizio Grandoni",
                "Stefan Kratsch",
                "Andreas Wiese"
            ],
            "title": "Parameterized approximation schemes for independent set of rectangles and geometric knapsack",
            "venue": "27th Annual European Symposium on Algorithms,",
            "year": 2019
        },
        {
            "authors": [
                "Anupam Gupta",
                "Euiwoong Lee",
                "Jason Li"
            ],
            "title": "Faster exact and approximate algorithms for k-cut",
            "venue": "In Mikkel Thorup, editor, 59th IEEE Annual Symposium on Foundations of Computer Science,",
            "year": 2018
        },
        {
            "authors": [
                "Sudipto Guha",
                "Andrew McGregor",
                "David Tench"
            ],
            "title": "Vertex and hyperedge connectivity in dynamic graph streams",
            "venue": "Proceedings of the 34th ACM Symposium on Principles of Database Systems,",
            "year": 2015
        },
        {
            "authors": [
                "Martin Charles Golumbic"
            ],
            "title": "Algorithmic Graph Theory and Perfect Graphs (Annals of Discrete Mathematics, Vol 57)",
            "venue": "North-Holland Publishing Co., NLD,",
            "year": 2004
        },
        {
            "authors": [
                "Pinar Heggernes",
                "Dieter Kratsch"
            ],
            "title": "Linear-time certifying recognition algorithms and forbidden induced subgraphs",
            "venue": "Nord. J. Comput.,",
            "year": 2007
        },
        {
            "authors": [
                "Karthik C. S",
                "Bundit Laekhanukit",
                "Pasin Manurangsi"
            ],
            "title": "On the parameterized complexity of approximating dominating set",
            "venue": "J. ACM,",
            "year": 2019
        },
        {
            "authors": [
                "Sudeshna Kolay",
                "Pranabendu Misra",
                "M.S. Ramanujan",
                "Saket Saurabh"
            ],
            "title": "Faster graph bipartization",
            "venue": "J. Comput. Syst. Sci.,",
            "year": 2020
        },
        {
            "authors": [
                "Ilan Kremer",
                "Noam Nisan",
                "Dana Ron"
            ],
            "title": "On randomized one-round communication",
            "venue": "complexity. Comput. Complex.,",
            "year": 1999
        },
        {
            "authors": [
                "Ariel Kulik",
                "Hadas Shachnai"
            ],
            "title": "Analysis of two-variable recurrence relations with application to parameterized approximations",
            "venue": "IEEE Annual Symposium on Foundations of Computer Science,",
            "year": 2020
        },
        {
            "authors": [
                "Stefan Kratsch",
                "Magnus Wahlstr\u00f6m"
            ],
            "title": "Compression via matroids: A randomized polynomial kernel for odd cycle transversal",
            "venue": "ACM Trans. Algorithms,",
            "year": 2014
        },
        {
            "authors": [
                "Stefan Kratsch",
                "Magnus Wahlstr\u00f6m"
            ],
            "title": "Representative sets and irrelevant vertices: New tools for kernelization",
            "venue": "J. ACM,",
            "year": 2020
        },
        {
            "authors": [
                "Daniel Lokshtanov",
                "Pranabendu Misra",
                "M.S. Ramanujan",
                "Saket Saurabh",
                "Meirav Zehavi"
            ],
            "title": "FPT approximation for FPT problems",
            "venue": "In Proceedings of the 2021 ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2021
        },
        {
            "authors": [
                "Daniel Lokshtanov",
                "Fahad Panolan",
                "M.S. Ramanujan",
                "Saket Saurabh"
            ],
            "title": "Lossy kernelization",
            "venue": "In Proceedings of the 49th Annual ACM SIGACT Symposium on Theory of Computing,",
            "year": 2017
        },
        {
            "authors": [
                "Daniel Lokshtanov",
                "M.S. Ramanujan",
                "Saket Saurabh"
            ],
            "title": "Linear time parameterized algorithms for subset feedback vertex set",
            "venue": "ACM Trans. Algorithms,",
            "year": 2018
        },
        {
            "authors": [
                "Daniel Lokshtanov",
                "Saket Saurabh",
                "Vaishali Surianarayanan"
            ],
            "title": "A parameterized approximation scheme for min $k$-cut",
            "venue": "IEEE Annual Symposium on Foundations of Computer Science,",
            "year": 2020
        },
        {
            "authors": [
                "Daniel Lokshtanov",
                "Saket Saurabh",
                "Meirav Zehavi"
            ],
            "title": "Efficient graph minors theory and parameterized algorithms for (planar) disjoint paths. In Treewidth, Kernels, and Algorithms Essays Dedicated to Hans L",
            "venue": "Bodlaender on the Occasion of His 60th Birthday,",
            "year": 2020
        },
        {
            "authors": [
                "John M. Lewis",
                "Mihalis Yannakakis"
            ],
            "title": "The node-deletion problem for hereditary properties is NP-complete",
            "venue": "J. Comput. Syst. Sci.,",
            "year": 1980
        },
        {
            "authors": [
                "Carsten Lund",
                "Mihalis Yannakakis"
            ],
            "title": "On the hardness of approximating minimization problems",
            "venue": "J. ACM,",
            "year": 1994
        },
        {
            "authors": [
                "D\u00e1niel Marx"
            ],
            "title": "Parameterized complexity and approximation algorithms",
            "venue": "The Computer Journal,",
            "year": 2008
        },
        {
            "authors": [
                "Andrew McGregor"
            ],
            "title": "Graph stream algorithms: a survey",
            "venue": "ACM SIGMOD Record,",
            "year": 2014
        },
        {
            "authors": [
                "Konrad Majewski",
                "Michal Pilipczuk",
                "Marek Sokolowski"
            ],
            "title": "Maintaining cmso properties on dynamic structures with bounded feedback vertex number",
            "venue": "40th International Symposium on Theoretical Aspects of Computer Science,",
            "year": 2023
        },
        {
            "authors": [
                "Shanmugavelayutham Muthukrishnan"
            ],
            "title": "Data streams: Algorithms and applications",
            "venue": "Now Publishers Inc,",
            "year": 2005
        },
        {
            "authors": [
                "M. Naor",
                "L.J. Schulman",
                "A. Srinivasan"
            ],
            "title": "Splitters and near-optimal derandomization",
            "venue": "In Proceedings of the 36th Annual Symposium on Foundations of Computer Science,",
            "year": 1995
        },
        {
            "authors": [
                "Michal Pilipczuk",
                "Nicole Schirrmacher",
                "Sebastian Siebertz",
                "Szymon Torunczyk",
                "Alexandre Vigny"
            ],
            "title": "Algorithms and data structures for first-order logic with connectivity under vertex failures",
            "venue": "49th International Colloquium on Automata, Languages, and Programming,",
            "year": 2022
        },
        {
            "authors": [
                "Fahad Panolan",
                "Saket Saurabh",
                "Meirav Zehavi"
            ],
            "title": "Contraction decomposition in unit disk graphs and algorithmic applications in parameterized complexity",
            "venue": "In Proceedings of the Thirtieth Annual ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2019
        },
        {
            "authors": [
                "Xiaoming Sun",
                "David P. Woodruff"
            ],
            "title": "Tight bounds for graph problems in insertion streams",
            "venue": "Algorithms and Techniques,",
            "year": 2015
        },
        {
            "authors": [
                "Pim van \u2019t Hof",
                "Yngve Villanger"
            ],
            "title": "Proper interval vertex deletion",
            "year": 2013
        },
        {
            "authors": [
                "Mihalis Yannakakis"
            ],
            "title": "Node- and edge-deletion np-complete problems",
            "venue": "Proceedings of the 10th Annual ACM Symposium onTheory of Computing, May 1-3,",
            "year": 1978
        },
        {
            "authors": [
                "Andrew Chi-Chih Yao"
            ],
            "title": "Some complexity questions related to distributive computing(preliminary report)",
            "venue": "In Proceedings of the Eleventh Annual ACM Symposium on Theory of Computing,",
            "year": 1979
        }
    ],
    "sections": [
        {
            "text": "Thus, we explore semi-streaming algorithms for parameterized graph problems, and present the first systematic study of this topic. Crucially, we aim to construct succinct representations of the input on which optimal post-processing time complexity can be achieved.\n\u2022 We devise meta-theorems specifically designed for parameterized streaming and demonstrate their applicability by obtaining the first kO(1) \u00b7n \u00b7 polylog(n)-space streaming algorithms for wellstudied problems such as Feedback Vertex Set on Tournaments, Cluster Vertex Deletion, Proper Interval Vertex Deletion and Block Vertex Deletion. In the process, we demonstrate a fundamental connection between semi-streaming algorithms for recognizing graphs in a graph classH and semi-streaming algorithms for the problem of vertex deletion intoH.\n\u2022 We present an algorithmic machinery for obtaining streaming algorithms for cut problems and exemplify this by giving the first kO(1) \u00b7 n \u00b7 polylog(n)-space streaming algorithms for Graph Bipartitization, Multiway Cut and Subset Feedback Vertex Set.\n\u2217University of California, Santa Barbara, USA. daniello@ucsb.edu \u2020Chennai Mathematical Institute. pranabendu@cmi.ac.in \u2021Indian Institute of Technology, Hyderabad. fahad@iith.ac.in \u00a7University of Warwick, UK. r.maadapuzhi-sridharan@warwick.ac.uk \u00b6Department of Informatics, University of Bergen, Norway and Institute of Mathematical Sciences, HBNI, India,\nsaket@imsc.res.in \u2225Ben-Gurion University of the Negev, Israel. meiravze@bgu.ac.il\nar X\niv :2\n30 8.\n01 59\n8v 1\n[ cs\n.D S]\n3 A\nug 2\nContents"
        },
        {
            "heading": "1 Introduction 1",
            "text": ""
        },
        {
            "heading": "2 Our Contributions and Methodology 2",
            "text": "2.1 Our First Meta-theorem: H is Characterized by the Absence of Finitely Many Induced Subgraphs . . 2 2.2 Our Second Meta-theorem: H is Characterized by the Absence of Infinitely Many Induced Subgraphs 4 2.3 Our Third Algorithmic Result: A Framework for Cut Problems . . . . . . . . . . . . . . . . . . . . . . 7 2.4 Refinement of the Class SemiPS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9"
        },
        {
            "heading": "3 Related Work 9",
            "text": ""
        },
        {
            "heading": "4 Preliminaries 10",
            "text": "4.1 Splitters and Separating Families . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 4.2 Semi-streaming Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 4.3 Graphs and Graph Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n5 From Recognition to Vertex Deletion toH with Finitely Many Obstructions 13 5.1 The Fixed-parameter Semi-streaming Algorithm for Vertex Deletion toH . . . . . . . . . . . . . . 13 5.2 Corollaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n6 From Reconstruction to Vertex Deletion toH with Infinitely Many Obstructions 17 6.1 Proper Interval Vertex Deletion in O(log2 n) Passes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n6.1.1 Reconstruction Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 6.1.2 Post-processing Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n6.2 Block Vertex Deletion in One Pass . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 6.2.1 Reconstruction Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 6.2.2 Post-processing Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37"
        },
        {
            "heading": "7 Cut Problems 43",
            "text": "7.1 Odd Cycle Transversal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 7.2 Subset Feedback Vertex Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 7.3 Multiway Cut . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n8 Our Refinement of The SemiPS Class 48"
        },
        {
            "heading": "9 Lower Bounds 49",
            "text": ""
        },
        {
            "heading": "10 Concluding Remarks and Discussion 51",
            "text": "A Problem Definitions 58"
        },
        {
            "heading": "1 Introduction",
            "text": "The Parameterized Streaming model was proposed independently by Fafianie and Kratsch [FK14] and Chitnis, Cormode, Hajiaghayi and Monemizadeh [CCHM15] with the goal of studying space-bounded parameterized algorithms for NP-complete problems. In this setting, the space is restricted to O\u0303(kO(1)) (that is, O(kO(1) \u00b7 polylog(n))), where the parameter k is a non-negative integer that aims to express some structure in the input. A feature of this model is that it allows one to design (exact) streaming algorithms for certain NP-complete graph problems such as Vertex Cover (where the parameter k is the size of the solution, i.e., the vertex cover).\nUnfortunately, even allowing O(kO(1) \u00b7 polylog(n)) space can only lead to limited success as numerous NP-complete graph problems (when parameterized by the solution size) require space \u2126\u0303(n) even when k is a fixed constant (e.g., k = 0) [FK14, CCHM15]. 1 Subsequently, Chitnis and Cormode [CC19] made an important advance by defining a hierarchy of complexity classes for parameterized streaming; among these classes, they defined the SemiPS (parameterized semi-streaming) class. This class, in the spirit of standard semi-streaming [Mut05, FKM+05], includes all graph problems that can be solved by an algorithm that uses O\u0303(f(k)n) space for some computable function f of k.\nThe class SemiPS allows unbounded computational power, both while processing the stream and in post-processing. Notice that this implies that several problems that are not expected to have fixed-parameter algorithms (e.g., problems that are W[1]-hard on planar graphs) are contained in SemiPS, since the entire input can be stored and then solved in post-processing. Thus, the model seems too powerful to combine well with the usual meaning of efficiency in parameterized algorithms (i.e., solvability in time f(k) \u00b7 nO(1)). This leaves a gap in the area which must be addressed. That is, what would be an appropriate refinement of SemiPS that captures problems in FPT? We bridge this gap in the state of the art by initiating the study of parameterized streaming algorithms where the space complexity is bounded by O\u0303(f(k)n) and the time complexity is bounded by g(k)nO(1) at every edge update and in post-processing, for computable functions f and g. We call such algorithms fixed-parameter semi-streaming algorithms (or FPSS algorithms).\nThe study of parameterized streaming algorithms has remained in a relatively early stage, with the state of the art predominantly focused on studying individual problems. In contrast, there has been remarkable progress in incorporating various other domains into the framework of parameterized complexity, such as: Dynamic Graph Algorithms [DKT14, AMW20, CCD+21, MPS23, KMN+23], Approximation Algorithms [DHK05, LPRS17, GLL18, GKW19, LSS20, CCK+20a] and Sensitivity Oracles [BCC+22, AH22, PSS+22]. The wide interest in these domains is also a consequence of various unique challenges that arise in their settings. The setting of parameterized streaming algorithms offers its own unique challenges as well. For instance, since we cannot store all the edges incident to a vertex, it becomes challenging to utilize many of the standard tools and techniques of Parameterized Complexity.\nIn this paper, we significantly advance the study of parameterized streaming algorithms by giving meta-theorems, which lead to the first FPSS algorithms for large classes of problems studied in Parameterized Complexity. This includes algorithms for Vertex Deletion toH, whereH can be a graph class characterized by a finite forbidden family, or it can be a hereditary graph class. We also give a framework for various graph-cut problems and apply it to obtain the first FPSS algorithms for Graph Bipartization (also called Odd Cycle Transversal), Multiway Cut and Subset Feedback Vertex Set. Another key contribution is to show how, in several cases, one can essentially \u201creconstruct\u201d the input graph, providing \u201cquery-access\u201d to its edge-set using only O\u0303(f(k)n) space, thereby allowing the use of various algorithmic\n1For instance, consider the classic NP-complete problem Graph Bipartization, where the goal is to determine, given a graph G and number k, whether removing k vertices from G results in a bipartite graph. For k = 0, this problem is nothing but testing whether G is bipartite, for which there is a \u2126(n log n)-space lower bound for one-pass algorithms [SW15].\ntools in Parameterized Complexity. Of course these tools must then be employed within limited space themselves, which in itself is a non-trivial problem that we address in this paper."
        },
        {
            "heading": "2 Our Contributions and Methodology",
            "text": "Our algorithmic contribution consists of (i) two meta-theorems that yield FPSS algorithms for several basic graph optimization problems, and (ii) a methodology to obtain FPSS algorithms for well-studied graph cut problems. Our results in (i) are arguably the first general purpose theorems applicable to dense graphs in this line of research, and using the machinery we develop in (ii), we resolve an open problem of Chitnis and Cormode [CC19] on whether Odd Cycle Transversal has an O\u0303(f(k)n)-space streaming algorithm. To obtain our results, we introduce novel sparsification methodologies and combinatorial results that could be of independent interest or of use in the design of other parameterized semi-streaming algorithms.\nWe next describe the graph optimization problems we focus on, which are all vertex-deletion problems. Let H be a family of graphs. The canonical vertex-deletion problem corresponding to the family H is defined as follows.\nVertex Deletion toH Parameter: k Input: A graph G, and an integer k. Task: Decide whether there is a vertex set S of size at most k such that G\u2212 S \u2208 H.\nThis family of problems includes fundamental problems in graph theory and combinatorial optimization, e.g., Planar Vertex Deletion, Odd Cycle Transversal, Chordal Vertex Deletion, Interval Vertex Deletion, Feedback Vertex Set, and Vertex Cover (corresponding to H being the class of planar, bipartite, chordal, interval, acyclic or edgeless graphs, respectively). Many vertex-deletion problems are well known to be NP-complete [LY80, Yan78]. Therefore, they have been studied extensively within various algorithmic paradigms such as approximation algorithms, parameterized complexity, and algorithms on restricted input classes [FLMS12, Fuj98, LY94]. However, when the input graph is too large to fit into the available memory, these paradigms on their own are insufficient. This naturally motivates the study of these problems in the streaming model.\nImportantly, in the streaming setting, for Vertex Deletion toH, even the special case of k = 0 (i.e., recognition of graphs inH) is already non-trivial for many natural choices ofH. That is, just the question of determining whether a given graph G belongs toH becomes significantly much harder in the streaming setting compared to the static (i.e., non-streaming) setting and in some cases, it is provably impossible to achieve any non-trivial upper bounds (e.g., as we show in this paper, for chordal graphs). So, there is a significant challenge in developing space-bounded (i.e., O\u0303(n)-space) algorithms for recognition of various graph classes. Our first meta theorem provides some evidence as to why the recognition problem is challenging for many natural graph classes, by drawing a fundamental correspondence between recognition of graphs inH and solving Vertex Deletion toH."
        },
        {
            "heading": "2.1 Our First Meta-theorem: H is Characterized by the Absence of Finitely Many In-",
            "text": "duced Subgraphs\nOur first result can be encapsulated in the following surprising message, whereH is defined by excluding a finite number of forbidden graphs as induced subgraphs.\nVertex deletion toH is not harder than recognition forH.\nThat is, we show that Vertex Deletion to H has an FPSS algorithm if and only if graphs in H can be recognized with a semi-streaming algorithm. Equivalently, one could say that in the streaming model, just checking whether a given graph is a member ofH appears to be as difficult as solving the seemingly much more general Vertex Deletion toH problem.\nTo be precise, we prove the following theorem.\nTheorem 2.1. LetH be a family of graphs defined by a finite number of forbidden induced subgraphs such that H admits a deterministic/randomized p-pass recognition algorithm in the turnstile (resp. insertion-only) model for some p \u2208 N. Then, Vertex Deletion toH admits a deterministic/randomized p-pass O\u0303(kO(1) \u00b7 n)-space streaming algorithm in the turnstile (resp. insertion-only) model with post-processing time 2O(k) \u00b7 nO(1).\nIn the above statement, a p-pass recognition algorithm forH is a p-pass O\u0303(n)-space streaming algorithm with polynomially bounded time between edge updates and in post-processing that, given a graph G, correctly concludes whether or not G \u2208 H. The turnstile model permits edge additions and removals whereas the insertion-only model only permits the former. So, our result guarantees that if one can recognize whether a given graph belongs to H, then one can also solve Vertex Deletion to H within the same number of passes and using only O\u0303(kO(1) \u00b7 n)-space. Notably, the dependency of the running time we attain on k is the best possible under the Exponential Time Hypothesis (ETH)\u2014 for each of the specific Vertex Deletion toH problems for which we draw corollaries from Theorem 2.1 (and in fact, even for the much simpler Vertex Cover problem), it is known that there does not exist a 2o(k)nO(1)-time algorithm under ETH even in the static setting [CFK+15].\nAs a corollary of Theorem 2.1, we get the first FPSS algorithms for well-studied problems such as Feedback Vertex Set on Tournaments (FVST), Split Vertex Deletion (SVD), Threshold Vertex Deletion (TVD) and Cluster Vertex Deletion (CVD). We refer the reader to the Appendix for the formal descriptions of these problems. Proof overview for Theorem 2.1. Suppose that the premise holds for the graph classH and let (G, k) be the given instance of Vertex Deletion toH. Moreover, letR be the finite set of graphs excluded by graphs inH as induced subgraphs. Suppose that the instance is a yes-instance and let S be a hypothetical inclusionwise-minimal solution. Then, there is a set T of size |S|, which is a set ofR-subgraphs (subgraphs isomorphic to graphs inR) of G such that for every graph in T , there is a unique vertex of S that it intersects. Let V (T ) denote the union of the vertex sets of the subgraphs in T and notice that |V (T )| \u2264 dk, where d is the maximum number of vertices among the graphs inR. Note that d is a constant in our setting. We now construct an (n, dk, (dk)2)-splitter family F1 with O\u0303(kO(1)) functions and guess a function f1 \u2208 F1 which is injective on V (T ). We refer the reader to Definition 4.1 in Section 4 for a formal definition of splitter families. At this point, it is sufficient for the reader to know that (i) for positive integers n, x, y, an (n, x, y)-splitter family is a set of functions mapping [n] to [y] such that every subset of [n] of size x is injectively mapped to [y] by at least one of these functions and (ii) there are efficient ways to construct a small enough (n, x, x2)-splitter family.\nReturning to our description, we treat f1 as a function that colors V (G) with at most (dk)2 colors. Now, in a single pass, for every set J of at most d colors, we run the recognition algorithm on the subgraph of G induced by the colors in J . For each of those subgraphs which have been determined to not be inH, we use a second family of splitters (of size O(log n)) to compute a set of at most d \u201ccandidate\u201d vertices that could potentially be part of a minimal solution for the original instance. This gives us a set Z of size\nkO(1) which contains S. At this point, we can obtain a 2O(k log k)n-time post-processing as follows \u2013 guess a subset S\u2032 of Z of size at most k and use the family F1 to check whether there is an R-subgraph of G disjoint from S\u2032. Notice that if such an R-subgraph exists, then there would be a function in F1 that is injective on S\u2032 plus the vertices of this subgraph and since the subgraph only spans at most d color classes of this function, we would have already stored a bit identifying whether or not this subgraph is inH.\nIn order to improve the post-processing time to a single-exponential in k (matching asymptotic lower bounds even in the static setting), we give a non-trivial reduction to the d-Hitting Set problem. Notice that such a reduction in the static setting is trivial \u2013 theR-subgraphs of the input graph correspond to the sets that need to be \u201chit\u201d. However, we require additional work in our case since the space constraints in our setting prohibit us from explicitly identifying the forbidden subgraphs in G. We overcome this obstacle by showing that for every subset of Z of size at most d, our data structure can determine whether a solution needs to intersect it and show that it is also sufficient for a solution to intersect precisely these sets. To compute this d-Hitting Set instance, we employ a further family of splitters with appropriately chosen parameters."
        },
        {
            "heading": "2.2 Our Second Meta-theorem: H is Characterized by the Absence of Infinitely Many",
            "text": "Induced Subgraphs\nBy strengthening the requirements in Theorem 2.1, we obtain a similar result even when the set of forbidden induced subgraphs forH may be of infinite size. For example, the obstruction set that defines the class of proper interval graphs is infinite since it contains all chordless cycles. More generally, our result holds for any hereditary graph class (i.e., graph class closed under taking induced subraphs). Here, we require reconstruction for H rather than recognition for H, which means that for a given graph G, we need to determine whether G \u2208 H (as in recognition), but in case the answer is positive, we also need to output a succinct representation of G. By succinct representation, we mean a data structure that takes O\u0303(n) space and supports \u201cedge queries\u201d\u2014given a pair of vertices u, v, it answer whether {u, v} is an edge in G. In addition to this requirement, we also suppose to be given an algorithm that solves the problem (in O\u0303(n) space) in the static setting, which is clearly an easier task than attaining the same result in the streaming setting. Specifically, we prove the following theorem.\nTheorem 2.2. LetH be a hereditary graph class such that:\n1. H admits a p-pass deterministic/randomized reconstruction algorithm for some p \u2208 N in the turnstile (resp. insertion-only) model, and\n2. Vertex Deletion toH admits a deterministic/randomized O\u0303(n \u00b7 g(k))-space f(k) \u00b7 nO(1)-time (static) algorithm where g and f are some computable functions of k.\nThen, Vertex Deletion toH admits a p-pass deterministic/randomized O\u0303(n \u00b7 g(k) \u00b7 kO(1))-space streaming algorithm with post-processing time 2k \u00b7 f(k) \u00b7 nO(1) in the turnstile (resp. insertion-only) model.\nWe demonstrate the applicability of our theorems for the classes of proper interval graphs and block graphs, where the size of the obstruction set is infinite. For each one of these two problems, we design a reconstruction algorithm that works in O\u0303(n) space in the static setting. Overall, this yields the following corollaries.\nCorollary 2.3. Proper Interval Vertex Deletion admits a randomizedO(log2 n)-pass O\u0303(kO(1)n)-space streaming algorithm with 2O(k) \u00b7 nO(1) post-processing time in the turnstile model.\nCorollary 2.4. Block Vertex Deletion admits a randomized 1-pass O\u0303(kO(1)n)-space streaming algorithm with 2O(k) \u00b7 nO(1) post-processing time in the turnstile model. Proof overview for Theorem 2.2. Using a construction of an (n, k, 2)-separating family, we begin by obtaining a family of kO(1) log n vertex subsets of G, F1, F2, . . . , Ft, with the property that for every pair of vertices u, v, and every vertex subset S of size at most k that excludes u, v, there exists an Fi that contains u, v and is disjoint from S. For each induced subgraph Gi = G[Fi], we call the given reconstruction algorithm and attempt to reconstruct Gi (where all calls are done simultaneously). For all pairs of vertices u, v that never occur together in any Gi that we managed to reconstruct, we prove that every solution to (G, k) must contain at least one vertex from each of these pairs. So, by considering the union G\u0303 of the graphs Gi that we managed to reconstruct, we are able to reconstruct (implicitly) G up to not knowing whether there exist edges between the aforementioned pairs of vertices. However, these pairs of vertices impose \u201cvertex-cover constraints\u201d, and we can directly consider every possibility of getting rid of them by branching (into at most 2k cases). After that, we simulate the given parameterized algorithm on G\u0303 minus the vertices already deleted. Application to Proper Interval Vertex Deletion. In light of Theorem 2.2, we need to design a reconstruction algorithm as well as a (static) parameterized algorithm that uses O\u0303(n) space. Reconstruction. Without loss of generality, we can focus only on connected graphs, and we observe that whenever we remove the closed neighborhood of a vertex in a connected proper interval graph, we get at most two connected components. The latter observation motivates the definition of a \u201cmiddle vertex\u201d, which is a vertex such that each of the (at most two) connected components that result from the removal of its closed neighborhood has at most 910n vertices. We note that a randomly picked vertex has probability at least 45 to be a middle vertex. This gives rise to a divide-and-conquer strategy where, at each step, we will aim to \u201corganize\u201d the unit intervals corresponding to vertices in the closed neighborhood of a middle vertex, and then recurse to organize those corresponding to vertices in each of the connected components resulting from their removal. However, these three tasks are not independent, and therefore we need to define an annotated version of the reconstruction problem. Here, we are given, in addition to G, a partial order on its vertex set, and we need to determine if G admits a unit interval model (and is therefore a unit interval graph) where for pairs of vertices u < v, the interval of u starts before that of v.\nNow, suppose we handle this annotated version, being at some intermediate recursive call, and call the graph corresponding to it by G (which is an induced subgraph of the original input graph). Let v be the middle vertex, M be its closed neighborhood, and L and R be the two connected components of G\u2212M (which may be empty), so that < indicates that L should be ordered before R (or else their naming is chosen arbitrarily). We note that in various arguments, conflicts may arise\u2014for example, here we may have a vertex in one component that is smaller than a vertex in the other (by <), and vice versa, in which case we can directly conclude that the original input graph is not a proper interval graph. It turns out that for L (and symmetrically for R), it sufficient just to solve the problem while refining < so that vertices with higher number of neighbors in M will be bigger than those having lower number of neighbors in M (with the opposite for R); clearly, for all vertices, the number of neighbors in L, M and R can be computed in one pass. We prove that whichever solution (being a unit interval model) will be returned for L and R, it should be possible to \u201cpatch\u201d it with any unit interval ordering of M given that it complies with the following (and that the original graph is a proper interval graphs): we refine the ordering < for M so that vertices with higher degree in L will be smaller, while vertices with higher degree in R will be bigger. As the resolution of L and R is given by the recursive calls, let us now explain how to resolve M .\nTo handle M , we first prove that in any unit interval model of it (if one exists), when we go over the vertices from left to right, their degree in M is non-decreasing, then reaches some pick (that is the degree\nof v), and after that becomes non-increasing. If L and R are empty, then we show that can choose as the leftmost vertex any vertex in M that is smallest by < and has minimum degree in M among such vertices, and if L is not empty (and it is immaterial if R is empty or not), we can choose as the leftmost vertex any vertex in M that has highest degree in L and is simultaneously smallest by <, and has smallest degree in M within these vertices (but possibly not within all vertices in M ). Let this vertex be a. Then, all neighbors of a are ordered from left to right non-decreasingly by their degree in M (taking into account some information from the ordering of L, which we will neglect in this brief overview, in order to break ties), and after them all non-neighbors of a are ordered from left to right non-increasingly by their degree in M . Clearly, to attain the neighbors of a, we just need one more pass.\nOverall, the above yields a potential unit interval model for original input graph G \u2013 in particular, we argue that if G is a proper interval graph, then this must be a model of it. Lastly, the model is verified by another pass on the stream, checking that G and the graph that the model represents are indeed the same graphs. Static Algorithms. Here, we essentially show that the known 2O(k)nO(1) algorithm by van \u2019t Hof and Villanger [vtHV13] can be implemented in O\u0303(kO(1)n) space. Application to Block Vertex Deletion. As before, we start with reconstruction and then turn to the static algorithms (which are here, unlike the case of proper interval graphs, non-trivial). Reconstruction. We provide reconstruction algorithms for a graph class that is broader than the class of block graphs. Here, a t-flow graph is one where between every pair of non-adjacent vertices, the number of vertex-disjoint paths is at most t, and a t-block graph is a t-flow graph that is chordal. A block graph is just a 1-block graph. For the reconstruction of t-flow graphs, the algorithm starts similarly to the proof of Theorem 2.2. We first attain a family of tO(1) log n vertex subsets of G, F1, F2, . . . , Fr , with the property that for every pair of vertices u, v and vertex subset of size at most t, there exists an Fi that contains u, v and is disjoint from S. Using one pass on the stream, for each induced subgraph Gi = G[Fi], we compute a spanning forest, and for each vertex in G, we compute its degree (in G). Then, we let G\u2032 be the union of these spanning forests. In post-processing, we construct (implicitly) a graph G\u0303 from G\u2032 as follows (only G\u2032 is kept explicitly). For every pair of non-adjacent vertices u, v in G\u2032 and every vertex subset of G if size at most t, we choose some Gi that contains both u, v and no vertex from S (which can be shown to exist), and if it holds that u and v are in the same connected component of Gi, then we add the edge {u, v}. If every vertex has the same degree in G and G\u0303, then we conclude the G is a t-flow graph with reconstruction (stored in an implicit manner) G\u0303, and else we conclude that G is not a t-flow graph. For correctness, we note that it can be shown that, necessarily, E(G) \u2286 E(G\u0303), and that in case G is a t-flow graph, then also E(G\u0303) \u2286 E(G) (else it may not be true). The degree test is used to prove that reverse direction, where the algorithm returns true, in which case the degree equalities and the fact that E(G) \u2286 E(G\u0303) imply that G = G\u0303 (and we construct G\u0303 in a way that ensures it is a t-flow graph.\nTo adapt the result to reconstruct t-block graphs, we first reconstruct them as t-flow graphs (because every t-block graph is in particular a t-flow graph), and then, having already this reconstruction at hand, we check whether they have a perfect elimination ordering in polynomial time and O\u0303(n) space. Static Algorithms. We build on the work of Agrawal, Kolay, Lokshtanov and Saurabh [AKLS16] for Block Vertex Deletion. However, implementing their algorithm in space O\u0303(kO(1)n) is a non-trivial task because their 2O(k)nO(1)-time algorithm for this problem uses space (even worse than) \u2126(n2). In their algorithm, they first hit small obstructions by branching (which can clearly be done in O\u0303(kO(1)n) space), and then they know that the resulting graph contains only O(n2) maximal cliques (however, there exist graphs where this bound is tight). They then construct an auxiliary bipartite graph H whose vertex set consists of V (G) and a vertex for each maximal clique in G, and where a vertex in V (G) is adjacent to all cliques that\ncontain it. It is argued that any subset S \u2286 V (G) is a block graph deletion set in G if and only if it is a feedback vertex set in H . So, the problem reduces to seeking a minimum feedback vertex in H that avoids the vertices representing cliques. This can be simply done by an algorithm for Feedback Vertex Set (with undeletable vertices). However, in our case, we cannot even explicitly write the vertex set of H , which can be of size \u2126(n2). So, instead, we employ a very particular known sampling algorithm for Feedback Vertex Set. This is an algorithm by Becker, Bar-Yehuda and Geiger [BBG00], which, after reducing the graph to another graph that has minimum degree 3, uniformly at random selects an edge and randomly chooses an endpoint for it, and that endpoint is deleted and added to the solution. It is argued that, for any feedback vertex set, with probability at least 1/2, the selected edge has at least one endpoint from the feedback vertex set.\nTo simulate this algorithm without constructing H , we show (i) how to compute the degree of every vertex in V (G) in H , and (ii) how to apply the reduction rules to ensure that its minimum degree is 3. We select a vertex in V (G) (to delete and insert to our solution) with probability proportional to its degree. This already gives us a 2O(k)n-time O\u0303(kO(1)n)-space algorithm for Block Vertex Deletion."
        },
        {
            "heading": "2.3 Our Third Algorithmic Result: A Framework for Cut Problems",
            "text": "We devise sparsification algorithms that, in combination with random sampling is used to deal with additional graph problems that are not encompassed by the previous theorems. Of special interest to us in this set of problems is Odd Cycle Transversal (OCT). In this problem, one aims to decide whether there is a set of at most k vertices in the given graph whose deletion leaves a bipartite graph. In other words, the \u201cobstruction\u201d set for OCT is the set of all odd cycles. Chitnis and Cormode [CC19] ask whether there exists a O\u0303(g(k) \u00b7 n)-space streaming algorithm for OCT even if one were to allow f(k)-passes. Furthermore, they point out that already for k = 1, the existence of such an algorithm is open (for k = 0, this is nothing but testing bipartiteness, for which a single-pass semi-streaming algorithm is known [AGM12]). Using our framework, we obtain the following result.\nTheorem2.5. There is a 1-pass O\u0303(kO(1)\u00b7n)-space randomized streaming algorithm forOCTwith O\u0303(3kkO(1)n)time post-processing.\nThus, Theorem 2.5 affirmatively answers the open problem of Chitnis and Cormode [CC19] in its most general form by giving a 1-pass (instead of the f(k)-passes they asked for) semi-streaming algorithm for Odd Cycle Transversal.\nOverview of our framework. Our framework has two high-level steps. The first is generic and the second is problem-specific.\nStep 1: The first step of our framework is a sampling primitive of Guha, McGregor and Tench [GMT15]. The main idea here is to sample roughly O\u0303(kO(1)) vertex subsets V1, . . . , V\u2113 of the input graph and argue that with good probability, the subgraph defined by the union of the edges in the sampled graphs preserves important properties of the input graph. In our case, we prove that at least one \u201cno-witness\u201d of every non-solution is preserved in the sampled subgraph.\nMore precisely, we show that for every set S \u2286 V (G) that is disjoint from some forbidden substructure in G (e.g., odd cycles) and hence not a solution, the subgraph of G defined by the union of the sampled subgraphs also contains a forbidden substructure disjoint from S. This allows us to identify a set of O\u0303(kO(1)) subgraphs that can always provide a witness when a vertex set is not a solution for the problem at hand. For\nproblems closed under taking subgraphs, this implies that solving the problem on the sampled subgraph is sufficient. Step 2: At the end of Step 1, however, we are still left with a major obstacle. That is, the sampled subgraphs may still be dense and it is far from obvious how one could \u201csparsify\u201d them while preserving the aforementioned properties. Therefore, as the second step in our template, one needs to also provide a problem-specific O\u0303(kO(1)n)-space sparsification step that allows us to reduce the number of edges we keep from each of the sampled subgraphs to O(n), while ensuring that non-solutions can still be witnessed by a substructure in the union of the sparsified subgraphs. If this is achieved, one may invoke existing linear-time (static) FPT algorithms for the problem on the sparsified instance and show that a solution for this reduced instance is also a solution for the original instance.\nWe next briefly sketch our sparsification procedure for Odd Cycle Transversal that leads to Theorem 2.5. The bipartite double cover of a graph G is the bipartite graph with two copies of the original vertex set V (say Va and Vb) and two copies of each edge (for an edge (u, v) in the original graph, there are two edges (ua, vb) and (ub, va), where for each z \u2208 {u, v} and x \u2208 {a, b}, zx is the copy of z contained in Vx). Ahn, Guha and McGregor [AGM12] used this auxiliary graph in their bipartiteness-testing algorithm by observing that G is bipartite precisely when its bipartite double cover has exactly twice as many connected components as G. In our work, we conduct a closer examination of bipartite double covers and exploit the fact that odd-length closed walks in G (which must exist if G is non-bipartite) that contain a vertex v correspond precisely to va-vb paths in the bipartite double cover of G. We build upon this fact to show that the edges preserved by computing a dynamic connectivity sketch for all the sampled subgraphs together preserve odd-length closed walks in the union of these subgraphs. Finally, we argue that solving OCT with a static FPT algorithm on the sparsified instance is equivalent to solving OCT on the original instance.\nApplying the framework to other cut problems. Recall that each specific application of the framework boils down to designing, for the cut problem at hand, (i) a problem-specific sparsification subroutine and (ii) a linear-space (or ideally, linear-time) FPT algorithm for use in post-processing. For instance, consider the classic Subset Feedback Vertex Set and Multiway Cut problems. We show that these two problems also fall under the same framework. For Subset Feedback Vertex Set, the obstruction set is the family of all cycles that contain \u201cterminals\u201d\u2014the objective of Subset Feedback Vertex Set is to determine whether one can choose at most k vertices that intersect all cycles in the input graph G that pass through at least one designated vertex, called a terminal (the input contains, in addition to G and k, a subset of vertices called terminals). In the case of Multiway Cut the obstruction set is the family of all paths that connect pairs of \u201cterminals\u201d. In this problem, the input is G, k and a vertex subset called terminals and the objective is to determine whether a set of at most k vertices intersects every path in G between a pair of terminals. For both these problems, we show how to combine the sampling primitive behind our algorithm for Odd Cycle Transversal along with problem-specific sparsifications for these (to handle Point (i) above) and the invocation of existing linear-time FPT algorithms (to handle Point (ii) above). Roughly speaking, in the sparsification step for Subset FVS, we maintain a dynamic connectivity sketch for the sampled subgraphs along with the edges incident on terminals and for Multiway Cut, we show that it is sufficient to maintain a dynamic connectivity sketch for the sampled subgraphs This leads us to the following two results.\nTheorem 2.6. There is a 1-pass O\u0303(kO(1) \u00b7 n)-space randomized streaming algorithm for Subset Feedback Vertex Set with O\u0303(2O(k) \u00b7 n)-time post-processing.\nTheorem 2.7. There is a 1-pass O\u0303(kO(1) \u00b7 n)-space randomized streaming algorithm forMultiway Cut with O\u0303(4kkO(1) \u00b7 n)-time post-processing.\n2.4 Refinement of the Class SemiPS\nOur algorithmic results demonstrate that the notion of fixed-parameter semi-streaming algorithms is widely applicable to parameterized versions of graph optimization problems. As a result, we obtain an associated natural complexity class (which we call FPT-Semi-PS) that is the analogue of the class FPT (fixed-parameter tractable problems) in the semi-streaming setting. In the same spirit, we also introduce notions of semistreaming kernelization (and semi-streaming compression), where the algorithm uses O\u0303(kO(1)n) space overall and polynomial time at each edge update and in post-processing, and eventually outputs an equivalent instance of size f(k) of the same problem (or a different problem, respectively). This output is called a kernel (or a compression, respectively). We show that our definitions are robust and faithfully reflect their analogues in the static setting. That is, we show (see Theorem 8.5) that:"
        },
        {
            "heading": "A (decidable) parameterized problem has an FPSS algorithm if and only if it has a semi-streaming kernelization.",
            "text": "Notice that FPT-Semi-PS is contained in FPT. We show that there are problems in FPT that are not in FPT-Semi-PS by proving a \u2126(n2)-space lower bound for the Chordal Vertex Deletion problem even when k = 0, that is, for the problem of recognizing whether a given graph is chordal.\nIn summary, our contributions in this paper are grounded in a novel exploration of parameterized streaming algorithms. By developing unified algorithms through meta-theorems, proposing a complexity class and demonstrating its richness through containment of numerous well-studied parameterized graph problems, our work significantly extends the boundaries of the field. Our advances also naturally point to a large number of open questions in parameterized streaming (see Section 10 for a discussion)."
        },
        {
            "heading": "3 Related Work",
            "text": "Recently, Chakrabarti et.al [CGMV20] studied vertex-ordering problems in digraphs such as testing Acyclicity and computing Feedback Vertex (Arc) sets. In brief, they gave space lower bounds of \u2126(n1+1/p) in general digraphs and \u2126(n/p) in Tournaments for these problems, where p is the number of passes. Moreover, they analyze the post-processing complexity of their algorithm and show that both the time and space complexity of their post-processing are essentially optimal. We refer to [McG14, CGMV20] for more details and further references.\nFafianie and Kratsch [FK14] introduced a notion of streaming kernelization, which is an algorithm that takes polynomial time, \u2126(p(k) log n) space and outputs an equivalent instance whose size is bounded polynomially in the parameter k, where p is some polynomial function of k, and n is the input size. In this setting they gave streaming kernelizations for certain problems such as d-Hitting Set in 1-pass and Edge Dominating Set in 2-passes. On the other hand, they obtained \u2126(m)-space lower-bounds for 1-pass streaming kernelization for many problems including Feedback Vertex Set, Odd Cycle Transversal, Cluster Vertex Deletion and interestingly, Edge Dominating Set. Here m denotes the number of edges. Further, they obtained multi-pass lower bounds for Cluster Editing and Chordal Completion \u2013 they gave a \u2126(n/t)-space lower bound for t-pass algorithms. Chitnis et.al [CCHM15, CCE+16] studied parameterized streaming algorithms for Vertex Cover and the more general d-Hitting Set problem and gave a O\u0303(kd)-space streaming kernelization even on dynamic streams. We remark that in [CCHM15], a O\u0303(nk)-space 1-pass streaming FPT algorithm for Feedback Vertex Set was presented, along with an \u2126(n) lower-bound.\nIn the previously discussed work of Chitnis and Cormode [CC19], they proposed a hierarchy of complexity classes for parameterized streaming. In particular they defined the classes FPS, SubPs, SemiPS, SupPS and BrutePS that bound space usage to O\u0303(f(k)), f(k) \u00b7 o(n), O\u0303(f(k) \u00b7 n), O\u0303(f(k) \u00b7 n1+\u03f5) for 0 \u2264 \u03f5 < 1 and O\u0303(n2), respectively. In their setting there is no restriction on time, i.e. an unbounded amount of time may be spent during the streaming phase and post-processing (although this was not exploited for their positive results). Then it is clear that every decidable graph problem lies in BrutePS, since we can store the entire graph and solve it via brute force computation. They show that certain problems such as Dominating Set and Girth are tight for BrutePS in 1-pass, i.e. they require \u2126(n2) space. Similarly, they show that Feedback Vertex Set and k-Path are tight for SemiPS, i.e. require O\u0303(f(k) \u00b7 n) space. They also proved a general result placing all minor-bidimensional problems [DH05] in the class SemiPS. Their argument implies that these problems are also typically in the class FPT-Semi-PS depending on whether or not they have a static linear-space fixed-parameter algorithm. However, the problems we consider in this paper are not minor-bidimensional and so, this theorem is inapplicable in our case. Furthermore, as mentioned earlier, Vertex Cover and d-Hitting Set lie in FPS, i.e. they require O\u0303(f(k)) space for some function f of k alone.\nLet us remark that, in light of this result for d-Hitting Set, one could be tempted to conclude that Vertex Deletion to H (for H characterized by finite forbidden induced subgraphs) can be reduced to an instance of d-Hitting Set in the natural way (i.e., forbidden subgraphs of the input graph correspond to sets in the d-Hitting Set instance). However, in the streaming setting, with only O\u0303(f(k) \u00b7 n)-space available, this reduction is no longer feasible since we are unable to store all edges and enumerate all obstructions. As an illustrative example, consider the question of recognizing whether an input graph is k-vertex deletions away from being a cluster graph in the semi-streaming setting. Recall that cluster graphs are exactly the induced-P3-free graphs. Since the edges forming a P3 may arrive far apart in time, one cannot hope to simply reduce the problem to a 3-Hitting Set instance and solve it, unless one stores the entire graph. Therefore, in spite of the O\u0303(kd)-space streaming kernelization for d-Hitting Set [CCE+16], this approach cannot be used to resolve such graph modification problems. In this work we give a novel data structure (see Section 5 and the discussion following the proof of Theorem 2.1) using which one can indeed reduce the given instance of any Vertex Deletion toH problem (for suchH) to an instance of d-Hitting Set that is bounded polynomially in k, using O\u0303(kO(1)n) space.\nFinally, it is important to mention the work of Feigenbaum et.al. [FKSV02], who also considered time complexity in the context of streaming algorithms. In particular, they defined a class called PASST(s, t) (stands for probably approximately correct streaming space complexity s and time complexity t) that additionally bounds the per-item processing time during the streaming phase. However, in this work also the post-processing time is not bounded. Chitnis and Cormode (see Remark 43 [CC19]) also consider restricting the per-item processing time and the post-processing time to only nO(1). However, while this is suitable for streaming kernelization algorithms [FK14], it is too restrictive when asking for parameterized streaming algorithms."
        },
        {
            "heading": "4 Preliminaries",
            "text": "When clear from the context, we use m and n to denote the number of edges and vertices respectively."
        },
        {
            "heading": "4.1 Splitters and Separating Families",
            "text": "Definition 4.1. [NSS95] Consider n, k, \u2113 \u2208 N such that k \u2264 n, \u2113. An (n, k, \u2113)-splitter F is a family of functions from [n] to [\u2113] such that for every set S \u2286 [n] of size k, there exists a function f \u2208 F that is injective on S.\nProposition 4.2 (Splitter construction). [NSS95] For every n, k \u2265 1, one can construct an (n, k, k2)- splitter of size O(k6 log k log n) in time (and space) kO(1)n log n.\nWe also require the following construction of a family of subsets over a set.\nDefinition 4.3 ((n, k, \u2113)-Separating Family). Let U be a universe of n elements. An (n, k, \u2113)-separating family over U is a family F of subsets of U , such that for any pair of disjoint subsets A and B of U where |A| \u2264 k and |B| \u2264 \u2113, there exists F \u2208 F such that A \u2229 F = \u2205 and B \u2286 F .\nLemma 4.4. Let U be a universe of n elements, and let \u2113 \u2264 k be two integers. There exists an (n, k, \u2113)separating family of sizeO((k+\u2113)2\u2113+6 log(k+\u2113) log n) that can be enumerated inO((k+\u2113)2\u2113+O(1) \u00b7n log n) time (and space).\nProof. Let q = \u2113 + k. We begin by enumerating an (n, q, q2)-splitterH over U . Recall thatH is a collection of functions from U to {1, 2, . . . , q2} such that, for any subset X of U of size at most q, there exists a function h \u2208 H such that h(i) \u0338= h(j) for any two distinct i, j \u2208 X . From Proposition 4.2, we have a construction of H containing O(q6 log q log n) functions in O(qO(1) \u00b7 n log n) time (and space). For each function h \u2208 H, we enumerate the following family of subsets of U . For each subset Y of size \u2113 of {1, 2, . . . , q2} we output h\u22121(Y ) \u2286 U . Note that, for each h \u2208 H we enumerate at most q2\u2113 subsets of U , and we denote them by Fh. We define the (n, k, \u2113)-separating family F as the union of these subsets, i.e. F = \u22c3 h\u2208HFh. Observe that F contains O(q2\u2113+6 log q log n) subsets of U , and it can be enumerated in O(q2\u2113 \u00b7 qO(1) \u00b7 n log n) time (and space). It only remains to argue that F is indeed a (n, k, \u2113)-separating family over U . Towards this, consider any two disjoint subsets A and B of U of size at most k and \u2113, respectively. Then there is a function h \u2208 H such that h(i) \u0338= h(j) for all i \u0338= j \u2208 A \u222a B. Let Y = {h(i) | i \u2208 B}, then observe that h\u22121(Y ) \u2208 F is disjoint from A and contains B. This holds for any choice of the subsets A and B, and hence F is a (n, k, \u2113)-separating family over U .\nWe require the following corollary of the above lemma, where we wish to separate pairs of vertices from vertex subsets of size at most k in a graph.\nCorollary 4.5. Let G be a graph on n vertices. Then, there is a family F of O((k + 2)10 log(k + 2) log n) subsets of V (G) such that for any pair of vertices u, v and any subset X of at most k vertices where u, v /\u2208 X , there existsF \u2208 F such that u, v \u2208 F andX\u2229F = \u2205. Such a familyF can be enumerated inO(kO(1) \u00b7n log n) time (and space)."
        },
        {
            "heading": "4.2 Semi-streaming Algorithms",
            "text": "We assume standard word RAM model of computation with words of bitlength O(log n), where n is the vertex count of the input graph. Vertex labels are assumed to fit within single machine words and can be operated on in O(1)-time.\nInsertion-only streams. Let P be a problem parameterized by k \u2208 N. Let (I, k) be an instance of P that has an input X = {x1, . . . , xi, . . . , xm} with input size |I| = m. Let S be a stream of INSERT(xi) (i.e., the insertion of an element xi) operations of underlying instance (I, k). In particular, the stream S is a permutation X \u2032 = {x\u20321, . . . , x\u2032i, . . . , x\u2032m} for x\u2032i \u2208 X of an input X .\nDynamic/turnstile streams. Let P be a problem parameterized by k \u2208 N. Let (I, k) be an instance of P that has an input X = {x1, . . . , xi, . . . , xm} with input size |I| = m. We say that stream S is a turnstile parameterized stream if S is a stream of INSERT(xi) (i.e., the insertion of an element xi) and DELETE(xi) (i.e., the deletion of an element xi) operations applying to the underlying instance (I, k) of P .\nThroughout this paper, when we refer to a (semi-)streaming algorithm without explicitly mentioning the number of passes required, then the number of passes is 1. Similarly, when the type of input stream (whether it is insertion-only or turnstile) is not explicitly mentioned, then it is to be understood that the input stream being referred to is a turnstile stream. We also assume that in either stream, when the input is an instance (I, k) of a parameterized graph problem P , the algorithm is aware of the vertex set of the input graph. Moreover, k is first given in the stream in unary and never deleted. It is only then that the stream begins providing I . Note that the elements in I can potentially undergo deletion and reinstertions, depending on the input model.\nDefinition 4.6 (k-sparse recovery algorithm). A k-sparse recovery algorithm is a data structure which accepts insertions and deletions of elements from [n] and recovers all elements of the stream if, at the recovery time, the number of elements stored in it is at most k.\nWe require the following result of Barkay, Porat and Shalem [BPS15] which we have specialized to our setting.\nProposition 4.7 (Lemma 9, [BPS15]). There is a deterministic structure, SRS with parameter k, denoted by SRSk, that that keeps a sketch of stream I (comprising insertions and deletions of elements from [n]) and can recover all of I\u2019s elements if I contains at most k distinct elements. It uses O(k log(n)) bits of space, and is updated in O(log2 k) operations amortized.\nIn other words, Barkay, Porat and Shalem [BPS15] have given a deterministic k-sparse recovery algorithm that uses O\u0303(k) space.\nWe also require the following version of the dynamic connectivity result of Ahn, Guha and McGregor [AGM12].\nProposition 4.8. [AGM12] For every c \u2208 N, there exists a 1-pass O\u0303(n)-space streaming algorithm in the turnstile model that, in post-processing, constructs a spanning forest of the input graph with probability at least 1\u2212 1/nc in time O\u0303(n)."
        },
        {
            "heading": "4.3 Graphs and Graph Classes",
            "text": "Fix a set of graphsR. Any graph that does not contain a graph inR as an induced subgraph is called an R-free graph. We use dR to denote the maximum number of vertices among the graphs inR. We say that S is anR-deletion set of a graph G if G\u2212 S isR-free. We say that a subgraph of G is anR-subgraph if it is isomorphic to a graph inR.\nIn the rest of this section, we recall the various graph classes we consider in this paper and characterizations of these classes that we use in our algorithms.\nAcyclic tournaments are precisely those tournaments that exclude directed triangles [Die00]. Split graphs are graphs whose vertex set can be partitioned into two disjoint sets, one of which is a clique and the other is an independent set. Split graphs are also characterized by the exclusion of {2K2, C4, C5} [Gol04]. Cluster graphs are graphs where every connected component is a clique. These are also characterized by the exclusion of {P3} [Gol04]. Threshold graphs are precisely those graphs that are characterized by the exclusion of {2K2, C4, P4} respectively [Gol04]. Block graph are graphs in which every biconnected component is a clique. It is known that they are characterized by the exclusion of {D4, C\u2113+4, \u2113\u22650} [BLS99]. Here D4 = K4 \u2212 e for some edge e \u2208 E(K4), and C\u2113+4 denotes an induced cycle on \u2113 + 4 vertices.\n5 From Recognition to Vertex Deletion to H with Finitely Many Obstructions\nRecall that for a class H of graphs, in the Vertex Deletion to H problem, the input is a graph G and integer k and the objective is to decide whether there is a set S \u2286 V (G) of size at most k such that G\u2212 S \u2208 H. The standard parameterization is k, the size of the solution. In this section, we only focus on the case whereH is characterized by a finite set of forbidden induced subgraphs.\nWe begin by formally capturing the notion of an efficient semi-streaming algorithm that recognizes graphs inH.\nDefinition 5.1. A class of graphsH admits a p-pass recognition algorithm if there exists a p-pass O\u0303(n)-space streaming algorithm with polynomially bounded time between edge updates and in post-processing that, given a graph G, correctly concludes whether or not G \u2208 H.\n5.1 The Fixed-parameter Semi-streaming Algorithm for Vertex Deletion toH\nWe are now ready to prove our first meta theorem.\nTheorem 2.1. LetH be a family of graphs defined by a finite number of forbidden induced subgraphs such that H admits a deterministic/randomized p-pass recognition algorithm in the turnstile (resp. insertion-only) model for some p \u2208 N. Then, Vertex Deletion toH admits a deterministic/randomized p-pass O\u0303(kO(1) \u00b7 n)-space streaming algorithm in the turnstile (resp. insertion-only) model with post-processing time 2O(k) \u00b7 nO(1).\nProof. LetR denote the finite set of graphs excluded by graphs inH as induced subgraphs. In what follows, let d = dR denote the size of the largest graph in the fixed set of graphsR. Note that d is a constant in this setting. Recall that we know V (G) (and hence n) and d apriori, while k is provided at the beginning of the stream. Let \u03b1 = max{dk, k + d} and \u03b2 = d2 \u00b7 (\u03b1 d ) \u00b7 \u03b1c ln n + d (where c is the constant in the O(\u00b7) notation in the size of the splitter family as given in Proposition 4.2).\n(i) We construct an (n, \u03b1, \u03b12)-splitter family F1 of size at most \u03b1c ln n, which can be constructed in time \u03b1O(1) \u00b7 n ln n (Proposition 4.2).\n(ii) We construct an (n, d + 1, (d + 1)2)-splitter family F2 of size dO(1) ln n, which can be constructed in time dO(1) \u00b7 n ln n.\n(iii) We construct an (n, \u03b2, \u03b22)-splitter family F3 of size at most \u03b2c ln n, which can be constructed in time \u03b2O(1) \u00b7 n ln n.\nBefore describing our (post-)processing steps, we define some useful notation.\n\u2022 For every f1 \u2208 F1, and J \u2286 [\u03b12], we denote by Gf1,J the graph G[f\u221211 (J)], i.e., the subgraph induced by those vertices of G whose image under f1 is contained in J .\n\u2022 Similarly, for every f3 \u2208 F3, and J \u2286 [\u03b22], we denote by Gf3,J the graph G[f\u221213 (J)], i.e., the subgraph induced by those vertices of G whose image under f3 is contained in J .\n\u2022 For every f2 \u2208 F2, i \u2208 [(d + 1)2] and graph Gf1,J , we denote by Gf2,i,f1,J the graph Gf1,J \u2212 f\u221212 (i). That is, the graph obtained from Gf1,J by deleting those vertices whose image under f2 is i.\n\u2022 Let X denote the set: {Gf1,J | f1 \u2208 F1, J \u2286 [\u03b12], |J | \u2264 d}\u22c3\n{Gf2,i,f1,J | f1 \u2208 F1, f2 \u2208 F2, i \u2208 [(d + 1)2], J \u2286 [\u03b12], |J | \u2264 d}\u22c3 {Gf3,J | f3 \u2208 F3, J \u2286 [\u03b22], |J | \u2264 d}.\nNotice that |X | \u2264 |F1|\u00b7d\u00b7 (\u03b12\nd\n) +|F1|\u00b7|F2|\u00b7d\u00b7 (\u03b12 d ) \u00b7(d+1)2+|F3|\u00b7d\u00b7 (\u03b22 d ) = O\u0303((kd)O(d)) = O\u0303(kO(1)).\nProcessing the stream: We process the graph stream by running the p-pass recognition algorithm (call this algorithm, A) assumed in the premise of the theorem for each of the graphs in X . Since |X | = O\u0303(kO(1)), the space used by our algorithm is O\u0303(kO(1) \u00b7 n) as required. Moreover, for each graph G\u2032 \u2208 X , the premise guarantees that we can decide whether G\u2032 \u2208 H by running a polynomial-time post-processing algorithm on the data-structure constructed by AlgorithmA, denoted by \u27e8G\u2032\u27e9. We call this post-processing algorithm, Algorithm B. We say that B(\u27e8G\u2032\u27e9) = \u22a4 if G\u2032 \u2208 H and B(\u27e8G\u2032\u27e9) = \u22a5 otherwise.\nWe are now ready to describe our fixed-parameter post-processing algorithm. Post-processing: For every f1 \u2208 F1 we construct a vertex set Zf1 as follows. For every v \u2208 V (G), we add v to the set Zf1 if and only if there exists J \u2286 [\u03b12] of size at most d such that (i) v \u2208 V (Gf1,J), (ii) B(\u27e8Gf1,J\u27e9) = \u22a5 and (iii) for every f2 \u2208 F2, B(\u27e8Gf2,f2(v),f1,J\u27e9) = \u22a4. Clearly, computing Zf1 takes kO(1) \u00b7 nO(1)-time. Therefore, computing the set Z = {Zf1 | f1 \u2208 F1} can be done in kO(1) \u00b7 nO(1)-time and additional O\u0303(kO(1)n)-space.\nLet Z\u22c6 = \u222aZ\u2208ZZ . We now construct a d-set system E with universe Z\u22c6 as follows. For every L \u2286 Z\u22c6 of size at most d, we add L to E if and only if there is an f3 \u2208 F3 and a set J \u2286 [\u03b22] of size at most d such that J is disjoint from f3(Z\u22c6 \\ L) and B(\u27e8Gf3,J\u27e9) = \u22a5. This completes the construction of E . Notice that the number of sets in E is bounded by d \u00b7 |Z\u22c6|d.\nFinally, we execute the standard linear-space O\u2217(dk)-time branching FPT algorithm for d-Hitting Set on the instance (Z\u22c6, E , k) (see, for example, [CFK+15]) and return the answer returned by this execution. This completes the description of the algorithm. We now argue the correctness of this algorithm.\nWe begin by bounding the size of Z\u22c6.\nClaim 5.2. |Z\u22c6| \u2264 d2 \u00b7 (\u03b12\nd\n) \u00b7 \u03b1c ln n.\nProof. To prove the claim, it suffices to prove that for every f1 \u2208 F1 and J \u2286 [\u03b12] such that |J | \u2264 d, at most d vertices of Gf1,J can be added to the set Zf1 . The claim then follows from the bound of d \u00b7 (\u03b12 d ) on possible values of J and the bound of \u03b1c ln n on the size of |F1|. We say that a vertex v is contributed to Zf1 by a set J \u2286 [\u03b12] of size at most d if v \u2208 V (Gf1,J), B(\u27e8Gf1,J\u27e9) = \u22a5, and for every f2 \u2208 F2, B(\u27e8Gf2,f2(v),f1,J\u27e9) = \u22a4. We now argue that each J contributes at most d vertices to Zf1 . To do so, we show that a vertex of Gf1,J is contributed to Zf1 by J precisely if it\nintersects everyR-subgraph of Gf1,J , that is, Gf1,J \u2212 v \u2208 H. Since each graph in R contains at most d vertices, there can be at most d such vertices.\nSuppose to the contrary that a vertex v \u2208 V (Gf1,J) is contributed to Zf1 by J and Gf1,J \u2212 v is not in H. Let H be anR-subgraph of Gf1,J \u2212 v and let f2 \u2208 F2 be a function which is injective on V (H) \u222a {v}. SinceF2 is an (n, (d+1), (d+1)2)-splitter, such an f2 exists. However, notice that B(\u27e8Gf2,f2(v),f1,J\u27e9) = \u22a5, contradicting our assumption that v is contributed to Zf1 by J . This completes the proof of the claim.\nWe next observe that if (G, k) is a yes-instance of Vertex Deletion toH, then it is sufficient to look for our solution within Z\u22c6.\nClaim 5.3. Every minimal solution of size at most k in G is contained in Z\u22c6.\nProof. Let S be an inclusionwise-minimal solution of size at most k (also called anR-deletion set). That is, G\u2212 S \u2208 H. Let T denote a set of obstructions witnessing the minimality of S. In other words, T is a set ofR-subgraphs of G such that for every graph in T , there is a unique vertex of S that it intersects. Since S is a minimalR-deletion set, such a set of |S| R-subgraphs must exist. For each v \u2208 S, we denote by Tv the unique graph in T that contains v. Let V (T ) denote the union of the vertex sets of the subgraphs in T and notice that |V (T )| \u2264 dk.\nNow, consider a function f1 \u2208 F1 that is injective on V (T ). Since F1 is an (n, dk, (dk)2)-splitter family, such an f1 exists. We argue that S \u2286 Zf1 . For each v \u2208 S, let Jv \u2286 [(dk)2] denote the set {f1(u) | u \u2208 V (Tv)}. Notice that |Jv| \u2264 d. Moreover, it must be the case that for every v \u2208 S , the graph G[f\u221211 (Jv)] has at least one minimalR-deletion set of size exactly 1 (which is the vertex v) and at most d distinct minimalR-deletion sets of size exactly 1. The former is a consequence of the fact that G[f\u221211 (Jv)] is disjoint from S \\ {v} and the latter is a consequence of the fact that the graphs inR have size bounded by d.\nNotice that for each v \u2208 S, since v is anR-deletion set of G[f\u221211 (Jv)], it follows that for every f2 \u2208 F2, the graph Gf2,f2(v),f1,J \u2208 H and therefore, it must be the case that B(\u27e8Gf2,f2(v),f1,J\u27e9) = \u22a4. In other words, the vertex v is contributed to Zf1 by Jv (see proof of Claim 5.2 for the definition). Hence, we conclude that S \u2286 Zf1 \u2286 Z\u22c6. This completes the proof of the claim.\nClaim 5.4. A set S \u2286 V (G) is a solution for the instance (G, k) of Vertex Deletion toH if and only if it is a solution for the d-Hitting Set instance (Z\u22c6, E , k).\nProof. Suppose that (G, k) is a yes-instance of Vertex Deletion toH and let S \u2286 V (G) be a solution. By Claim 5.3, we have that S \u2286 Z\u22c6. Now, suppose that S is not a solution for the d-Hitting Set instance (Z\u22c6, E , k) and let L \u2208 E be a set disjoint from S. Then, by the construction of E , we have that there is a function f3 and a set J \u2286 [\u03b22] disjoint from f3(S) such that B(\u27e8Gf3,J) = \u22a5. This implies that there is a subgraph of G, i.e., Gf3,J that contains an R-subgraph and is disjoint from S, a contradiction to our assumption that S is anR-deletion set in G.\nConversely, suppose that S is a solution for the d-Hitting Set instance (Z\u22c6, E , k), but not an Rdeletion set in G. Then, there is an R-subgraph H in G \u2212 S. Let L = V (H) \u2229 Z\u22c6. Notice that |L| \u2264 d since |V (H)| \u2264 d. Moreover, we claim that in the construction of E , we would have added the set L to E . To see this, first observe that Z\u22c6 \u222a V (H) has size at most \u03b2 and so, there is a function f3 \u2208 F3 which is injective on Z\u22c6 \u222a V (H). Therefore, for J = f3(V (H)), we have that J is disjoint from f3(Z\u22c6 \\ L) and B(\u27e8Gf3,J\u27e9) = \u22a5, ensuring that L is contained in E . Since S is a solution for the d-Hitting Set instance (Z\u22c6, E , k), it follows that S intersects L and hence also intersects V (H), a contradiction to our assumption that S is not anR-deletion set in G. This completes the proof of the claim.\nThis completes the proof of Theorem 2.1.\nFurther insights that can be drawn from our proof ofTheorem 2.1. First of all, notice that that in the proof of this theorem, if there is a randomized p-pass recognition algorithm forHwhere the post-processing succeeds with high probability (i.e., with probability at least 1\u2212 1/nc for any c \u2208 N), then one obtains a randomized p-pass O\u0303(kO(1)n)-space streaming algorithm for Vertex Deletion toHwith 2O(k)nO(1)-time post-processing and a randomized p-pass O\u0303(kO(1) \u00b7n)-space polynomial streaming compression for Vertex Deletion toH, both of which succeed with high probability. Similarly, if we have a recognition algorithm forH only on insertion-only streams, then we can still use Theorem 2.1, with the caveat that the resulting algorithms for Vertex Deletion toH also only work for insertion-only streams.\nSecondly, our algorithm can be used to obtain a polynomial compression from Vertex Deletion to H to d-Hitting Set. Indeed, if dk < n, then the fixed-parameter post-processing algorithm we use can be seen to solves the problem in polynomial time, allowing us to produce a trivial equivalent instance of d-Hitting Set as the output. On the other hand, if dk > n, then the size of the d-Hitting Set instance (Z\u22c6, E , k) is already bounded by d \u00b7 |Z\u22c6|d \u2264 d \u00b7 d2 \u00b7 (\u03b12 d ) \u00b7 \u03b1c ln n = kO(1) as required."
        },
        {
            "heading": "5.2 Corollaries",
            "text": "Lemma 5.5. For each of the following graph classesH, there is a finite familyR such thatH is precisely the class of graph that exclude graphs inR as induced subgraphs: Acyclic tournaments, split graphs, threshold graphs and cluster graphs. Moreover, the first three graph classes have a deterministic 1-pass recognition algorithms and cluster graphs have a randomized 1-pass recognition algorithm that succeeds with probability at least 1\u2212 1/nc for any given c > 0.\nProof. As discussed in Section 4.3, it is known that acyclic tournaments are precisely those tournaments that exclude directed triangles [Die00]. Split graphs, cluster graphs and threshold graphs are characterised by the exclusion of {2K2, C4, C5}, {P3}, and {2k2, C4, P4} respectively [Gol04]. Furthermore, acyclic tournaments [Die00], split graphs and threshold graphs [Gol04] have characterizations through their degree sequence. That is, it is sufficient to know the degrees of each vertex in order to be able to recognize graphs from these classes. As storing the degree of each vertex can be trivially done in O\u0303(1) space, the algorithm follows.\nFor cluster graphs, it is straightforward to see that they can be recognized from a spanning forest and the degree sequence. Indeed, a graph G is a cluster graph if and only if for every tree T in a spanning forest of G and every vertex v \u2208 V (T ), the degree of v in G is precisely |V (T )| \u2212 1. In order to compute a spanning forest of the input graph with high probability, we use Proposition 4.8. This completes the proof of the lemma.\nAs immediate corollaries of Theorem 2.1 and Lemma 5.5, we obtain in one shot the first 1-pass O\u0303(kO(1) \u00b7 n)-space streaming algorithms for several vertex-deletion problems such as Feedback Vertex Set on Tournaments, Split VertexDeletion, Threshold VertexDeletion andCluster VertexDeletion (for the last of which the algorithms are randomized). Moreover, our data structures enable the post-processing for these algorithms to be done by a single-exponential fixed-parameter algorithm parameterized by the solution size. Furthermore, notice that the post-processing time used by the 1-pass recognition algorithms for the above specific graph classes (in Lemma 5.5) is O\u0303(n). Combining this fact with a closer inspection of the proof of Theorem 2.1 indicates that the polynomial factor in the running times of the fixed-parameter post-processing routines for these problems is in fact only O\u0303(n). Thus, we have the following results.\nFurther impact of our techniques in the form of new algorithms for Vertex Deletion to H in the static setting. As discussed above, a closer examination of the proof of Theorem 2.1 implies an FPT algorithm for Vertex Deletion to H where the polynomial factor in the running time is n \u00b7 T (n) where T (n) is the time required to recognize a graph inH. In the standard 2O(k)nO(1) branching algorithm for Vertex Deletion toH, this factor is at least T \u2032(n) where T \u2032(n) is the time required to compute an obstruction, i.e., anR-subgraph in the input graph (assumingR is the set of forbidden induced subgraphs forH). The computation of obstructions for various graph classes is typically achieved through a certifying recognition algorithm, i.e., an algorithm that returns an obstruction if it concludes that the input is not in the graph class. However, designing certifying recognition algorithms that are nearly (or just as) efficient as a normal recognition algorithm is a non-trivial task. Indeed, Heggernes and Kratsch [HK07] note that usually different and sometimes deep insights are needed to produce useful certificates. Therefore, our approach allows one to improve the polynomial dependence in the standard 2O(k)nO(1) branching algorithm for Vertex Deletion to H in cases where recognition of H is efficient but the time required to find an obstruction is worse by a factor of n or more.\n6 From Reconstruction to Vertex Deletion toH with Infinitely Many Obstructions\nIn this section, we present a meta theorem to reduce the design of streaming algorithms for deletion to hereditary graph classes to the design of reconstruction algorithms for these classes.\nTowards the presentation of our theorem, we first need to define the meaning of reconstruction. This is done in the following two definitions.\nDefinition 6.1. Given an n-vertex graph G, a succinct representation of G is a data structure that uses O\u0303(n) space and supports an O\u0303(n)-space polynomial-time procedure that, given two vertices u, v \u2208 V (G), correctly answers whether {u, v} \u2208 E(G).\nDefinition 6.2. For an integer p \u2265 0, a class of graphsH admits a p-pass reconstruction algorithm if there exists a p-pass O\u0303(n)-space streaming algorithm with polynomial post-processing time that, given a graph G, correctly concludes whether G \u2208 H, and in case G \u2208 H, outputs a succinct representation of G.\nWe are now ready to prove our meta theorem.\nTheorem 2.2. LetH be a hereditary graph class such that:\n1. H admits a p-pass deterministic/randomized reconstruction algorithm for some p \u2208 N in the turnstile (resp. insertion-only) model, and\n2. Vertex Deletion toH admits a deterministic/randomized O\u0303(n \u00b7 g(k))-space f(k) \u00b7 nO(1)-time (static) algorithm where g and f are some computable functions of k.\nThen, Vertex Deletion toH admits a p-pass deterministic/randomized O\u0303(n \u00b7 g(k) \u00b7 kO(1))-space streaming algorithm with post-processing time 2k \u00b7 f(k) \u00b7 nO(1) in the turnstile (resp. insertion-only) model.\nProof. Let G denote the input graph, which is presented to us as a stream of edges. Let n = |V (G)|. We say that a vertex subset S \u2286 V (G) is a solution to (G, k) if |S| \u2264 k and G\u2212 S \u2208 H. Let F = {F1, F2, . . . , Ft} be an (n, k, 2)-separating family over V (G). Note that such a family contains t = kO(1) log n vertex subsets, and it can be constructed in O(kO(1)n log n) time and space (Corollary 4.5). Given the family F , for each\n1 \u2264 i \u2264 t, let Gi = G[Fi]. For brevity, let A denote the algorithm of Item 1, which can reconstruct a graph in the classH in p-passes. And let B denote the static algorithm for Vertex Deletion toH of Item 2. Our streaming algorithm for Vertex Deletion toH is as follows.\n\u2022 Streaming Phase. In the streaming phase, we construct a collection of data-structures from the input stream of edges using the reconstruction algorithm A. We first construct the family F of subsets of V (G). Then for each graph Gi = G[Fi], where 1 \u2264 i \u2264 t, we apply algorithm A, in parallel. At the end of the stream, for each Gi, the algorithm either concludes that Gi \u2208 H and outputs a succinct representation of it, or else it concludes that Gi /\u2208 H. Let Di denote the data-structure output by A whenever Gi \u2208 H, and Di = \u2205 otherwise. Observe that each data-structure Di requires O\u0303(n) space, and there are at most t = kO(1) log n of them. We store the family F and the collection of these data-structures {Di}1\u2264i\u2264t. Note that, we require p-passes and O\u0303(kO(1) \u00b7 g(k) \u00b7 n) space in the streaming phase.\n\u2022 Post-processing Phase. Let us now describe the post-processing phase of our algorithm. Let us define a graph G\u0303 as follows: V (G\u0303) = V (G) and E(G\u0303) = \u22c3 1\u2264i\u2264t : Di \u0338=\u2205 E(Gi). Observe that G\u0303 is a\nsubgraph of G, although it may not be an induced subgraph. Note that the graph G\u0303 is not explicitly constructed, but a succinct representation of G\u0303 is obtained from the data-structures {Di | 1 \u2264 i \u2264 t} as follows: given any two vertices u, v \u2208 V (G), to determine if {u, v} \u2208 E(G\u0303), we query every Di for the edge {u, v}; if any one of these queries succeed we output that {u, v} is an edge in G\u0303, otherwise we output that {u, v} is a non-edge of G\u0303. Next, let E\u2032 = {{u, v} \u2208 V \u00d7 V | u \u0338= v and \u2200 1 \u2264 i \u2264 t such that Di \u0338= \u2205, |Fi \u2229 {u, v}| \u2264 1}. Let G\u2032 = (V (G), E\u2032), and note that it is not necessarily a subgraph of G (although it can be shown to contain every edge in E(G)\\E(G\u0303)). The graph G\u2032 is also not explicitly constructed, but it is reconstructed from the vertex subsets {Fi | 1 \u2264 i \u2264 t, Di \u0338= \u2205}. To construct a solution to (G, k), we do the following. We first enumerate every minimal vertex cover of size at most k in the graph G\u2032. Note that there are at most 2k minimal vertex covers of G\u2032 of size at most k [CFK+15]. This is accomplished by a simple branching algorithm, that processes the edges of G\u2032 one by one. This algorithm runs in 2k \u00b7 nO(1) time and O\u0303(n) space. For each vertex cover X of G\u2032 of size at most k produced by the above enumeration, we apply the algorithm B to (G\u0303\u2212X, k \u2212 |X|), and either obtain a solution S\u0303 to (G\u0303\u2212X, k \u2212 |X|) or no such solution exists. If we do indeed find a solution S\u0303 to (G\u0303\u2212X, k \u2212 |X|), then we output S\u0303 \u222aX as the solution to (G, k). Otherwise, for every X the algorithm B fails to find a solution to (G\u2212X, k \u2212 |X|), and we output that there is no solution to (G, k). This completes the description of the algorithm.\nIt clear that the above algorithm requires p-passes, and usedO(n\u00b7g(k)\u00b7kO(1)) space and (2k \u00b7f(k))\u00b7nO(1) time. It only remains to argue the correctness of our algorithm. Towards this, first recall that F has the following property: for any pair of vertices u, v and any S \u2286 V (G) such that u, v /\u2208 V (G) and |S| \u2264 k, there is a subset Fi \u2208 F such that u, v \u2208 Fi and S \u2229 Fi = \u2205. Next, we have the following claim: If S is a solution to (G, k) and e = {u, v} \u2208 E\u2032, then |S \u2229 {u, v}| \u2265 1. That is, we claim that S is a (not necessarily minimal) vertex cover for G\u2032. We prove this claim using the properties of the (n, k, 2)-separation family F over V (G). Suppose the claim is false, and let {u, v} \u2208 E\u2032 such that S \u2229 {u, v} = \u2205. Then there exists Fi \u2208 F such that {u, v} \u2286 Fi and S \u2229 Fi = \u2205. Observe that Gi = G[Fi] is an induced subgraph of G\u2212 S, and G\u2212 S \u2208 H. SinceH is hereditary, Gi \u2208 H as well. Therefore, Di \u0338= \u2205, and hence by the construction of E\u2032, we have {u, v} /\u2208 E\u2032. This is a contradiction.\nNext, consider any vertex cover X of G\u2032. We claim that G\u0303 \u2212 X = G \u2212 X . First observe that, as V (G) = V (G\u0303), we have V (G) \\X = V (G\u0303) \\X . Next suppose that there are u, v \u2208 V (G\u0303) \\X such that\n{u, v} \u2208 E(G) \\ E(G\u0303). Then by the definition of G\u0303, there is no vertex subset Fi \u2208 F such that Gi \u2208 H and u, v \u2208 Fi. In other words, for any Fj \u2208 F such that u, v \u2208 Fj , we have Gj /\u2208 H and hence Dj = \u2205. Hence, by definition {u, v} \u2208 E\u2032, and therefore X \u2229 {u, v} =\u0338 \u2205. But this is again a contradiction. Hence we conclude G\u0303\u2212X = G\u2212X .\nNow, let us argue that (G, k) has a solution if and only if our algorithm concludes that there is a solution to (G, k). In the forward direction, consider a solution S\u22c6 to (G, k). Let Y \u2286 S\u22c6 be a minimal subset that is a vertex-cover of G\u2032, and note that |Y | \u2264 k. Then as H is hereditary, S\u22c6 \u2212 Y is a solution to the instance (G\u2212 Y, k \u2212 |Y |). Recall that our post-processing algorithm enumerates all minimal vertex covers of G\u2032 of size at most k, and in particular Y . Then for the vertex cover Y of G\u2032, it computes a solution to (G\u0303 \u2212 Y, k \u2212 |Y |) using algorithm B. Here, recall that G\u0303 \u2212 Y = G \u2212 Y and hence it admits a solution S\u0303 = S\u22c6 \\ Y of size at most k \u2212 |Y |. Therefore, by invoking algorithm B on (G\u0303\u2212 Y, k \u2212 |Y |), we correctly conclude that (G, k) admits a solution. In the reverse direction, suppose that our algorithm outputs S\u0303 \u222aX as a solution to (G, k), where X is a vertex cover of G\u2032 and S\u0303 is a solution to (G\u0303\u2212X, k\u2212 |X|). Recall that G\u0303\u2212X = G\u2212X , and hence G\u2212 (S\u0303 \u222aX) = G\u0303\u2212 (S\u0303 \u222aX). Hence it follows that G\u2212 (S\u0303 \u222aX) \u2208 H, i.e. S\u0303 \u222aX is a solution (G, k). This concludes the proof of this lemma.\nFinally, we remark that the results of this section also hold for digraphs (with the same proof).\n6.1 Proper Interval Vertex Deletion in O(log2 n) Passes Formally, the class of proper interval graphs can be defined as follows.\nDefinition 6.3 (Proper Interval Graph). A graph G is a proper interval graph if there exists a function f that assigns to each vertex in G an open interval of unit length on the real line such that every two vertices in G are adjacent if and only if their intervals intersect. Such a function f is called a representation, and given a vertex v \u2208 V (G), we let beginf (v) and endf (v) denote the beginning and end of the interval assigned to v by f (as if it was closed).\nEquivalently, the demand that each interval will be of unit length can be replaced by the demand that no interval will properly contain another interval.2\nWe remark that whenever we have a representation, we can slightly perturb it so that no two vertices will be assigned the same interval, or, more generally, no two endpoints (start or end) of intervals will coincide. Further, given a representation of the second \u201ctype\u201d (where intervals can have different lengths), it is possible to construct a representation of the first \u201ctype\u201d with the same ordering of the starting and ending points of all intervals assigned, and that every representation of the first \u201ctype\u201d is also of the second \u201ctype\u201d.\nThe purpose of this section is to prove the following theorems. The second theorem implies the first but requires additional arguments.\nTheorem 6.4. Proper Interval Vertex Deletion admits an O(log2 n)-pass semi-streaming algorithm with 2O(k) \u00b7 nO(1) post-processing time.\nTo prove this lemma, we present the reconstruction and post-processing algorithms for the class of proper interval graphs as required by Theorem 2.2.\n2To be more precise, when intervals are required to have unit length, then the graph is called a unit interval graph, and when intervals should not properly contain one another, it is called a proper interval graph. However, these two notions are known to be equivalent."
        },
        {
            "heading": "6.1.1 Reconstruction Algorithm",
            "text": "The purpose of this section is to prove the following lemma.\nLemma 6.5. The class of proper interval graphs admits an O(log2 n)-pass reconstruction algorithm.\nWe first observe that it suffices to focus on the class of connected proper interval graphs. Indeed, this follows by running an algorithm for the connected case on all connected components simultaneously, and answering \u201cyes\u201d if and only if the answer to all components is \u201cyes\u201d; in case the answer is \u201cyes\u201d, the output representation is the union of the representations of the connected components.\nObservation 6.6. The class of connected proper interval graphs admits an x-pass reconstruction algorithm with polynomial post-processing time, then so does the class of proper interval graphs.\nIn particular, dealing with connected proper interval graphs allows us to make use of the following result regarding the number of connected components left after the removal of any closed neighborhood.\nLemma 6.7. Let G be a connected proper interval graph with representation f . For any v \u2208 V (G), the graph G\u2212N [v] consists of at most two connected components: one on the set of vertices whose intervals end at or before the interval of v starts (according to f ), and the other on the set of vertices whose intervals start at or after the interval of v ends.\nProof. Let L be the subgraph of G induced by the set of vertices whose intervals end at or before the interval of v starts. Let R be the subgraph of G induced the set of vertices whose intervals start at or after the interval of v ends. Note that every vertex not in V (L) \u222a V (R) has an interval that intersects that of v, and the set that consists of these vertices is precisely N [v]. Further, the intervals of two vertices that belong to different graphs among L and R do not intersect, and hence they are not neighbors. So, to conclude the proof, it remains to argue that each graph among L and R is connected. We will only show this for L as the proof for R is symmetric. Consider two vertices u, v \u2208 V (L). Then, because G is connected, there exists a (simple) path P between u and v in G. If P belongs to L, we are done. Else, P can be rewritten as u\u2212P1\u2212 x\u2212 y\u2212P2\u2212 z\u2212w\u2212P3\u2212 v (possibly y = z and P1, P2, P3 can be empty) where V (P1) \u222a V (P3) \u222a {x, w} \u2286 V (L) and y, z \u2208 N [v]. So, (i) startf (x) < startf (y) < endf (x) < startf (v), and (ii) startf (w) < startf (z) < endf (w) < startf (v).\nWithout loss of generality, suppose that (iii) startf (z) < startf (y). We claim that startf (x) < startf (z) < endf (x), which will imply (by (ii)) that f(x) and f(w) intersect. Clearly, startf (x) < startf (z) because f(x) ends before f(v) starts while f(z) does not. Moreover, startf (z) < endf (x), because otherwise, by (iii), endf (x) < startf (z) < startf (y) which is a contradiction to (i). So, u\u2212P1\u2212 x\u2212w\u2212P3\u2212 v is a path within L.\nIn order to proceed, we need to define an annotated version of the reconstruction problem, where we only seek proper interval graphs with representations that comply with a given order on the intervals assigned to vertices. This annotation will be encountered since a step (which will be encapsulated by a lemma ahead) of our algorithm will reduce a problem instance to smaller annotated instances (and will reduce these smaller annotated instances to even smaller annotated instances, and so on, based on divide on conquer).\nDefinition 6.8. The Annotated Proper Interval Reconstruction problem is defined as follows. Given a graph G and a partial ordering < on V (G), decide whether G is a proper interval graph that admits a representation f where for every different u, v \u2208 V (G), no endpoint of f(u) coincides with an endpoint of f(v),\nand such that if u < v, then we have that beginf (u) < beginf (v) (such a representation is said to comply with <). Moreover, in case G is such a graph, output a succinct representation of G that is the permutation on {beginf (v) : v \u2208 V (G)} \u222a {endf (v) : v \u2208 V (G)} corresponding to f .3\nFrom now on, as we justify immediately, our objective will be to prove the following lemma.\nLemma 6.9. The Annotated Proper Interval Reconstruction problem admits an O(log2 n)-pass algorithm.\nIndeed, to prove Lemma 6.5, it suffices to prove Lemma 6.9 because we can choose the order < to define all vertices as incomparable, and thereby make < immaterial.\nThe proof of Lemma 6.9 will be based on an inductive argument. The main part of the proof is given by Lemma 6.13 ahead. Before this, we state the following definition and lemmas that will be used in its proof.\nDefinition 6.10. Let G be an n-vertex graph. A vertex v is a middle vertex if the size of every connected component of G\u2212N [v] is at most 910n.\nLemma 6.11. Let G be a connected proper interval graph. Then, by selecting a vertex v \u2208 V (G) uniformly at random, v is a middle vertex with probability at least 45 .\nProof. Let f be a representation of G, and n = |V (G)|. For every vertex v, let Lv and Rv be the first and second connected components (which may be empty) defined in Lemma 6.7. Order V (G) = {v1, v2, . . . , vn} so that f(vi) starts at or before f(vj) starts. Then, for any i \u2208 {1, 2, . . . , n}, |V (Lvi)| \u2264 i \u2212 1 and |V (Rvi)| \u2264 n\u2212 i. So, whenever 110 \u2264 i \u2264 9 10 , |V (Lvi)| \u2264 9 10n and |V (Rvi)| \u2264 9 10n, and then vi is a middle vertex. So, there are at least 45n mid vertices, which implies the desired probability.\nLemma 6.12. There exists a 1-pass O\u0303(n)-space polynomial-time algorithm that given two graphs G and H on the same vertex set V and a succinct representation of H (where the representation is stored in memory and not part of the stream), decides whether G is equal to H .4\nProof. The algorithm works as follows. Using one pass on the stream, it computes the degree of every vertex in G, and also for each edge in G (when it appears in the stream), it checks that it belongs to H using the succinct representation and if not it returns that G \u0338= H . Afterwards, it computes the degree of every vertex in H (using the succinct representation) and checks that it equals the degree computed for G, and if not then it returns that G \u0338= H . At the end, it returns that G = H .\nClearly, this is a 1-pass O\u0303(n)-space polynomial-time algorithm. Moreover, correctness follows by observing that G = H if and only if E(G) \u2286 E(H) and the degree of every vertex is the same in G and H .\nWe now turn to state and proof the aforementioned Lemma 6.13.\nLemma 6.13. Let n, s \u2208 N. Suppose that Annotated Proper Interval Reconstruction admits a 5 \u00b7 s \u00b7 log 10\n9 n\u0303-pass algorithm on n\u0303-vertex graphs where n\u0303 \u2264 910n with success probability at least 1\u2212( 1 5) s \u00b7 n\u0303 log 10 9 n\u0303. Then, Annotated Proper Interval Reconstruction admits a 5 \u00b7 s \u00b7 log 10\n9 n-pass algorithm on n-vertex\ngraphs with success probability at least 1\u2212 (15) s \u00b7 n log 10 9 n.5\n3Here, we mean that intervals are scanned from left to right. Note that this is indeed a succinct representation because it takes space O\u0303(n), and to check whether two vertices u, v are neighbors, we just need to check whether beginf (v) < beginf (u) < endf (v) or beginf (u) < beginf (v) < endf (u).\n4That is, for any pair of vertices u, v \u2208 V , we have that u, v are adjacent in G if and only if they are adjacent in H . 5We remark that the constant 5 was not optimized. For example, just by sacrificing modularity and not checking the validity of\nour reconstruction here (at each step) but only once in the end, it reduces to 4.\nProof. Let A denote the algorithm guaranteed by the supposition of the lemma.\nAlgorithm. The algorithm works as follows.\n1. For i = 1, 2, . . . , s:\n(a) Select uniformly at random a vertex v\u22c6 \u2208 V (G). (b) Go over the stream once to compute N(v\u22c6). (c) Go over the stream once using a connectivity sketch to compute the connected components of\nG \u2212N [v\u22c6]. By Lemma 6.7, there are at most two such components, which we denote by C1 and C2 (where possibly one or both of them are empty).\n(d) If |V (C1)| \u2264 910n and |V (C2)| \u2264 9 10n, then go directly to Step 3.\n2. Return failure.\n3. Rename C1 and C2 as L and R (where C1 can be either) such that for every pair of comparable vertices u, w \u2208 V (G) such that u < w, at least one of the following holds: (i) u \u2208 V (L); (ii) w \u2208 V (R); (iii) u, w \u2208 N [v]. If this is not possible, then return \u201cno-instance\u201d. Also, denote M = G[N [v]].\n4. Go over the stream once to compute for every u \u2208 V (G): dL(u) = |N(u) \u2229 V (L)|, dR(u) = |N(u) \u2229 V (R)| and dM (u) = |N(u) \u2229 V (M)|.\n5. Here, we consider several cases:\n(a) V (L) \u0338= \u2205. Among all vertices u \u2208 M with maximum dL(u) and that are smallest by <, let a be one with minimum dM (u) (if there is more than one choice, then select one arbitrarily). If a cannot be chosen (i.e., there is no vertex that has maximum dL(u) and is simultaneously smallest by < among all vertices in M ), then return \u201cno-instance\u201d. Afterwards:\ni. Go over the stream once to compute N(a). ii. If M \\N [a] \u0338= \u2205, then among all vertices u \u2208 M \\N [a] with maximum dR(u) and that\nare largest by <, let b be one with minimum dM (u) (if there is more than one choice, then select one arbitrarily). If b cannot be chosen (i.e., there is no vertex that has maximum dR(u) and is simultaneously largest by < among all vertices in M \\ N [a]), then return \u201cno-instance\u201d.\niii. Else, among all vertices u \u2208M with maximum dR(u) and that are largest by <, choose some vertex b arbitrarily. If b cannot be chosen (i.e., there is no vertex that has maximum dR(u) and is simultaneously largest by < among all vertices in M ), then return \u201cno-instance\u201d.\n(b) V (L) = \u2205 and V (R) \u0338= \u2205. Among all vertices u \u2208 M with maximum dR(u) and that are largest by <, let b be one with minimum dM (u) (if there is more than one choice, then select one arbitrarily). If b cannot be chosen (i.e., there is no vertex that has maximum dR(u) and is simultaneously largest by < among all vertices in M ), then return \u201cno-instance\u201d. Afterwards:\ni. Go over the stream once to compute N(b). ii. If M \\N [b] \u0338= \u2205, then among all vertices u \u2208M \\N [b] with maximum dL(u) and that are\nsmallest by <, let a be one with minimum dM (u) (if there is more than one choice, then select one arbitrarily). If a cannot be chosen (i.e., there is no vertex that has maximum dR(u) and is simultaneously smallest by < among all vertices in M \\N [b]), then return \u201cno-instance\u201d.\niii. Else, among all vertices u \u2208M with maximum dR(u) and that are smallest by <, choose some vertex a arbitrarily. If a cannot be chosen (i.e., there is a conflict between having minimum dM (u) and being smallest by <), then return \u201cno-instance\u201d.\n(c) V (L) = V (R) = \u2205. Among all vertices u \u2208M that are smallest by <, let a be one of minimum dM (u) (if there is more than one choice, then select one arbitrarily). Repeat Steps 5(a)i, 5(a)ii and 5(a)iii to define b.\n6. Call the algorithm in the supposition of the lemma on L with <L defined as follows: for all u, v \u2208 V (L), if u < v or dM (u) < dM (v), then u <L v. If a conflict arises in the definition of <L or the algorithm returns \u201cno-instance\u201d, then return \u201cno-instance\u201d, and else let PermL be the permutation it returns (supposedly corresponding to some representation gL of L that complies with <L). Simultaneously,6 call the algorithm in the supposition of the lemma on R with <R defined as follows: for all u, v \u2208 V (R), if u < v or dM (u) > dM (v), then u <R v. If a conflict arises in the definition of <R or the algorithm \u201cno-instance\u201d, then return \u201cno-instance\u201d, and else let PermR be the permutation it returns (supposedly corresponding to some representation gR of R that complies with <R).\n7. Now, for some (unknown and possibly incorrect) representation f , we define an ordering on starting points, beginf (\u00b7), as follows. First, the starting points of the intervals of all vertices in L and R are ordered exactly as in PermL and PermR, and all starting points of the intervals of vertices in L appear before those in M , and for those in M , they appear before those in R. Internally, the starting points of the vertices in M are ordered as follows. For every u, v \u2208 M , if at least one of the following conditions is true, then beginf (u) < beginf (v):\n(a) u < v (where < is the input partial order on V (G)); (b) dL(u) > dL(v); (c) dR(u) < dR(v); (d) u, v \u2208 N(a) and dM (u) < dM (v); (e) u, v /\u2208 N(a) and dM (u) > dM (v); (f) u \u2208 N(a) and v /\u2208 N(a).\nIn case a conflict occurs, that is, the above conditions imply that both beginf (u) < beginf (v) and beginf (v) < beginf (u) for some u, v \u2208 V (G), then we return \u201cno-instance\u201d. Besides this, ties are broken arbitrarily.\n8. We proceed by inserting the ending points of the intervals of all vertices in V (L) \u222a V (R) within the ordering of the starting points. First, the ending points of the intervals of all vertices in L with no neighbors in M are ordered exactly as in PermL (and are inserted before the starting points of the intervals of all vertices in M ). Second, the ending points of the intervals of all vertices in R are ordered exactly as in PermR (and are inserted after the starting points of the intervals of all vertices in M ). Third, for every vertex v \u2208 V (L) with neighbours in M , insert endf (v) between beginf (x) and beginf (y) where x is the dM (v)-th vertex in M according to the already established ordering of starting points of intervals, and y is the vertex whose starting point is ordered immediately after that of x (which might not exist, in which case endf (v) is just placed after all starting points of intervals of vertices in M and before all those of vertices in R).\n6That is, use one pass on G to simulate one pass on L as well as one pass on R.\n9. Lastly, we insert the ending points of the intervals of all vertices in V (M) within the ordering of the starting points. For every vertex v \u2208 V (M) with dR(v) > 0, insert endf (v) between beginf (x) and beginf (y) where x is the dR(v)-th vertex in R according to the already established ordering of starting points of intervals, and y is the vertex whose starting point is ordered immediately after that of x (which might not exist, in which case endf (v) is just placed after all starting points). Additionally, for every vertex v \u2208 V (M) with dR(v) = 0, if the starting point of f(v) was placed after the starting point of f(v\u22c6), then place the ending point of f(v) after the starting point of all vertices in M but before those of all vertices in R; else, insert endf (v) between beginf (x) and beginf (y) where x is the dM (v)-th vertex in M according to the already established ordering of starting points of intervals, and y is the vertex whose starting point is ordered immediately after that of x (which might not exist, in which case endf (v) is just placed after all starting points of intervals of vertices in M and before all those of vertices in R).\n10. To complete the ordering of all starting points and ending points, it remains only to define the ordering between ending points that were inserted between the same two starting points\u2014for every two such ending points endf (u) and endf (v), we order endf (u) before endf (v) if and only beginf (u) before beginf (v).\n11. Check whether in the constructed succinct representation (that is the ordering of starting and ending points) no interval properly contains another. If this check fails, return \u201cno-instance\u201d.\n12. Go over the stream once using the algorithm in Lemma 6.12 to verify whether the graph given by the constructed succinct representation yields a graph equal to G. If the answer is yes, then return \u201cyes-instance\u201d and the representation, and otherwise return \u201cno-instance\u201d.\nThis completes the description of the algorithm.\nSpace, Time, Number of Passes and Success Probability. Clearly, the space complexity of the algorithm is O\u0303(n) and it works in polynomial time. Regarding the number of passes, observe that the number of passes it makes is at most\n2s + 3 + max 1 10 n\u2264\u2113\u2264 9 10 n 5s log 10 9 \u2113 \u2264 5s(1 + max 1 10 n\u2264\u2113\u2264 9 10 n log 10 9\n\u2113) = 5s(1 + log 10\n9\n9 10n)\n= 5s log 10 9 n.\nMoreover, by Lemma 6.11 and union bound, its failure probability is at most\n(15) s + max 1\n10 n\u2264\u2113\u2264 9 10 n ((15) s \u00b7 \u2113 log 10 9 \u2113 + (15) s \u00b7 (n\u2212 \u2113) log 10 9 (n\u2212 \u2113))\n\u2264 (15) s + (15) s \u00b7max 1 10 n\u2264\u2113\u2264 9 10 n (\u2113 log 10 9 9 10n + (n\u2212 \u2113) log 109 9 10n) = (15) s + (15) s \u00b7 n log 10 9 9 10n \u2264 ( 1 5) s \u00b7 n log 10 9 n.\nSo, the success probability is at least 1\u2212 (15) s \u00b7 n log 10 9 n as claimed.\nCorrectness: Reverse Direction. For correctness, first observe that by Steps 11 and 12, if the algorithm returns \u201cyes-instance\u201d, then this is correct and so does the representation (because the answer and representation are verified in these steps). The difficult part in the proof is to show the other direction.\nCorrectness: Forward Direction. In the rest of the proof, we assume that G is a proper interval graph that admits a representation that complies with <, and aim to prove that in this case the algorithm returns\n\u201cyes-instance\u201d (in which case, due to our verification, the representation will be correct). To this end, we need to show that there exists some representation for G that complies with < and with our ordering of starting and ending points\u2014then, necessarily, the checks in the last two steps succeed and the algorithm returns \u201cyes-instance\u201d. For this, we will have a sequence of claims that will justify the decisions made in the different steps of the algorithm. We begin by justifying Step 3 with the following claim, whose correctness follows directly from the definition of a representation, and by observing that taking the mirror image of a representation also gives a representation, but which may not comply with <.\nClaim 6.14. The algorithm does not answer \u201cno-instance\u201d in Step 3, and there exists a representation of G that complies with < and where all intervals of vertices in L begin before all intervals of vertices in M begin, and all intervals of vertices in M begin before all intervals of vertices in R begin.\nNext, we claim that the vertices a and b have leftmost and rightmost intervals among the vertices in M , addressing Step 5.\nClaim 6.15. The algorithm does not answer \u201cno-instance\u201d in Step 3, and there exists a representation of G that satisfies the conditions in Claim 6.14 and where a (resp. b) is the vertex in M whose interval\u2019s starting point is leftmost (resp. rightmost).\nProof. We only consider now representations that satisfy the conditions in Claim 6.14 (and we know that at least one such representation exists). Clearly, given two vertices x, y in M such that the interval of x (in any of the representations we consider) starts before that of y, it must be that (i) x has at least as many neighbors in L as y, (ii) y has at least as many neighbors as x in R, and (iii) either x, y are incomparable or x < y. Moreover, vertices in M that have the same number of neighbors in L (resp. R) have also the exact same neighbors in L (resp. R)\u2014to see this, suppose that the interval of y (resp. x) starts before that of x (resp. y), let u be a neighbor of y (resp. x) in L, and notice that every intersection point of the intervals of y (resp. x) and u also belongs to the interval of x (resp. y); see Fig. 1 (the case of R is symmetric). We also note that no vertex can have neighbors in both L and R.\nWe proceed to present arguments that justify the choices we make based on dM (\u00b7). For this purpose, let a\u2032 and b\u2032 be the vertices in M having the leftmost and rightmost intervals in some representation that does not assign the same interval to two different vertices. Then, notice that V (M) \u2286 N [a\u2032] \u222aN [b\u2032] (see Fig. 2). Moreover, notice that for every u \u2208 N(a\u2032)\u2229V (M), we have that N [a\u2032]\u2229V (M) \u2286 N [u]\u2229V (M)\u2014indeed, the interval of every vertex in N(a\u2032) \u2229 V (M) must intersect the (open) right endpoint of the interval of a\u2032, and the interval of u intersects it as well, and hence the intervals of the neighbor and of u intersect each other (see Fig. 2). Symmetrically, for every u \u2208 N(b\u2032) \u2229 V (M), we have that N(b\u2032) \u2229 V (M) \u2286 N(u) \u2229 V (M). In particular, this means that when we look at vertices from left to right according to the starting point of their intervals, dM (\u00b7) is non-decreasing, and after reaching some peak, becomes non-increasing (see Fig. 2).\nFurthermore, two vertices that have minimum dM (\u00b7) and are neighbors themselves, have the exact same neighbors in M .\nOverall, the above arguments justify our choice of a and b (i.e., that there exists at least one representation among those we consider that makes the same choice). For the sake of clarity, let us show this explicitly for the case where V (L) \u0338= \u2205 (the arguments for the other two cases follows the same lines). As argued above, the leftmost vertex must have, among the vertices in M , maximum dL(\u00b7) (which is greater than 1) and, simultaneously, be smallest by <. Further, among these vertices with maximum dL(\u00b7) (which, therefore, are neighbors of each other and have the same neighborhood in L) and that are smallest by <, it must have minimum dM (\u00b7). All the vertices that can be chosen in this manner also have the same neighborhood also in M (and no neighbors in R), and hence the choice among them is arbitrary. This justifies the choice of a. Now, in the easier case where M \u2286 N [a], then G[M ] is in fact a clique. So, among all vertoces with largest dR(\u00b7) (all of which have the same neighborhood in R) and which is largest by <, we can pick one as b arbitrarily. In case M \\ N [a] \u0338= \u2205, then G[M ] is not a clique, and, in particular, the leftmost vertex is not a neighbor of a, yet it has minimum dM (\u00b7) among all non-neighbors of a (and all of the vertices that satisfy this condition have the same neighborhood in M ). So, among the non-neighbors of a vertices with maximum dR(\u00b7) and that are largest by <, we can choose b as a vertex with minimum dM (\u00b7) (we remark that b might not have minimum dM (\u00b7) among all vertices in M , but it should have it among all the non-neighbors of a). Notice that is some choice is not possible, then we have a \u201cno-instance\u201d.\nFor the recursive calls in Step 6 on L and R, we have the following claim.\nClaim 6.16. The algorithm does not answer \u201cno-instance\u201d in Step 6. Moreover, for any pair of representations gL of L and gR of R that comply with <L and <R, respectively, there exists a representation of G that satisfies the conditions in Claim 6.15 and that the restrictions of its ordering of starting and ending points to L and R is the same as gL and gR, respectively.\nProof. To prove the first part of the claim, let f be a representation of G that complies with <. Let fL and fR be the restrictions of f to L and R, respectively. Then, fL and fR are clearly representations of L and R that comply with the restrictions of < to V (L) and V (R), respectively. Further, for any u, v \u2208 V (L) such that dL(u) < dL(v), it must be that the starting point of u is to the left of that of v\u2014indeed, this follows from the observation that for any two vertices x, y \u2208 V (L) such that f(x) starts before f(y), every neighbor of x in M is also a neighbor of y in M . Symmetrically, for any u, v \u2208 V (R) such that\ndL(u) > dL(v), it must be that the starting point of u is to the left of that of v. So, fL and fR comply with <L and <R, respectively, which means that the recursive calls are made with yes-instances. Therefore, the algorithm does not answer \u201cno-instance\u201d in Step 6.\nTo prove the second part of the claim, it suffices to show that there exists a representation f of G that satisfies the conditions in Claim 6.15, and whose restriction to L (resp. R) is gL (resp. gR). We will only show a modification to ensure restriction to L is gL, since the modification for R is symmetric (and can be done after the the property for L is derived without altering it) Towards this, let h be a representation of G that satisfies the conditions in Claim 6.15. Then, for some implicit f that is meant to be a representation (which, until proved below, maybe incorrect), we define an ordering of the starting and ending points of the intervals of vertices as follows. The internal ordering between endpoints corresponding to vertices in V (M) \u222a V (R) is the same as in f , and the ordering between endpoints corresponding to vertices in V (L) is the same as in gL. All starting points corresponding to vertices in V (L) appear before all those of vertices in V (M), and all ending points corresponding to vertices in V (L) appear before all those of vertices in V (M) and before all starting points corresponding to vertices in V (R). It remains to specify the relation between the ending points corresponding to V (L) and the starting points corresponding to V (M). To this end, let v1, v2, . . . , v\u2113 where \u2113 = |V (L)| be the ordering of the vertices in L by the starting points (from left to right) of the intervals assigned to them by gL. Let u1, u2, . . . , u\u2113 be defined in the same way but with respect to h. Additionally, let w1, w2, . . . , wm where m = |V (M)| be the ordering of the vertices in M by the starting points (from left to right) of the intervals assigned to them by h. Then, for any i \u2208 {1, 2, . . . , \u2113}:\n\u2022 If dM (vi) = 0, then place the ending point of f(vi) before the starting points of all intervals (assigned by f ) of vertices in M .\n\u2022 If dM (vi) = |V (M)|, then place the ending point of f(vi) after the starting points of all intervals (assigned by f ) of vertices in M .\n\u2022 Else, place the ending point of f(vi) between the starting points of f(wdM (vi)) and f(wdM (vi+1)).\nWe need to argue that no conflicts arose, that is, that we do not have two vertices vi, vj \u2208 V (L) such that the ordering of their ending points in gL is different than the ordering implied when we placed them between starting points corresponding to vertices in M . Suppose, by contradiction, that such a conflict arose. Then, there exist vi, vj \u2208 V (L) such that there exists wt \u2208 V (M) so that we have ordered endf (vj) < startf (wt) < endf (vi), but i < j (i.e., endgL(vi) < endgL(vj)). Having endf (vj) < startf (wt) < endf (vi) means that dM (vj) < dM (vi), which, by the definition of <L, implies that vj <L vi. But then, it cannot be that endgL(vi) < endgL(vj), because this contradicts the demand that gL complies with <L. So, we have reached a contradiction, which means that no conflict arose.\nClearly, if f that corresponds to our ordering is a representation of G, then it should be clear that f satisfies the conditions in Claim 6.15 and that the restriction of its ordering of starting and ending points to\nL is the same as gL and gR. So, it remains to prove that f is a representation. Directly from the definition of the ordering for f , for every pair of intervals such that one belongs to a vertex in L and the other to a vertex in R, their intervals do not intersect and indeed they are not adjacent (see Fig. 3). Further, because gL and h are representation, directly from the definition of the ordering for f , every two vertices that are both in V (L) or both in V (M) \u222a V (R), their intervals (as assigned by f ) intersect if and only if they are adjacent. It remains to consider the case where we have a vertex vi \u2208 V (L) and a vertex wj \u2208 V (M). Then, we need to show that startf (wj) < endf (vi) if and only if vi and wj are adjacent in G.\nTo prove the above, let t \u2208 {1, 2, . . . , \u2113} be such that vi = ut. We will claim that the placements of the ending point ut by f and by h among the starting points intervals of vertices in M (as assigned by f or h\u2014the ordering of these starting points by f and h is the same) are the same. Given that this claim is correct, then because h is a representation, we can conclude that startf (wj) < endf (vi) if and only if vi and wj are adjacent in G. So, it remains to prove this claim. This follows from the observation that if h(ut) intersects h(wq) for some wq \u2208 {1, 2, . . . , m}, then h(ut) also intersect h(wp) for all p \u2208 {1, 2, . . . , m}. Hence, because ut intersects exactly dM (ut) vertices in M , the ending point of h(ut) must be placed within the starting points of the intervals of vertices in M (as assigned by h) exactly as we have placed the ending point of f(vi) within them. This completes the proof.\nNow, we consider the correctness of the ordering of starting points as defined in Step 7.\nClaim 6.17. The algorithm does not answer \u201cno-instance\u201d in Step 7, and there exists a representation of G that satisfies the conditions in Claim 6.16 and where the starting points of the intervals of all vertices are ordered in the way defined in Step 7.\nProof. Consider all represetations of G that satisfy the conditions in Claim 6.15 (where we know that at least one such representation exists). So, by the condition in Claim 6.14, all intervals of vertices in L begin before all intervals of vertices in M begin, and all intervals of vertices in M begin before all intervals of vertices in R begin. With respect to the internal ordering of the starting points of the intervals of vertices in V (L) and V (R), correctness is guaranteed by the condition in Lemma 6.16. Lastly, by following the same lines of arguments as those given in the proof of Claim 6.15, we conclude that among the representation we consider, at least one has the internal ordering of starting points of the intervals of vertices in V (M) as the one defined in Step 7.\nNext, we consider the correctness of the ordering of ending points for vertices in L and R as defined in Step 8. With respect to vertices in L with no neighbors in M , and vertices in R, correctness is immediate. With respect to vertices in L with neighbors in M , clearly the endpoints should occur after the first starting point of intervals of vertices in M and before all starting points of intervals of vertices in R (because no vertex in L can be a neighbor of a vertex in R; see Fig. 3). Moreover, in any representation, if a vertex in L has d neighbors in M , then this d must be the d vertices in M whose starting points are leftmost in that representation. So, this justifies our placement of all ending points of vertices in L and R within the starting points.\nClaim 6.18. There exists a representation of G that satisfies the conditions in Claim 6.17 and where the ending points of the intervals of all vertices in V (L) \u222a V (R) are ordered in the way defined in Step 8.\nWe proceed to consider the correctness of the ordering of ending points for vertices in M as defined in Step 9. For vertices in M that have neighbors in R (i.e., dR(\u00b7) > 0), the correctness follows the symmetric arguments as for the vertices in L that have neighbors in M in the previous claim. For vertices u in M with no neighbors in R, in case their intervals start after that of v\u22c6, then they must end after the ending point of\nthe interval of v\u22c6 which is, in turn, after the starting points of all vertices in M . Because such u have no neighbors in R, the ending points of their intervals must also be before the starting points of all intervals in R. Now, in case their intervals start before the interval of v\u22c6, then they must too intersect a, and so they intersect the first dM (u) vertices in M , which justifies the placement of the ends of their intervals.\nClaim 6.19. There exists a representation of G that satisfies the conditions in Claim 6.18 and where the ending points of the intervals of all vertices in V (M) are ordered in the way defined in Step 9.\nWe proceed to consider the correctness of the \u201cinternal ordering\u201d of ending points as defined in Step 10. This part is clear because if the starting point of the interval of one vertex is more to the left than another, so is the relation between their ending points (since all intervals are of the same unit length).\nClaim 6.20. There exists a representation of G that satisfies the conditions in Claim 6.19 and where the ending points of the intervals of all vertices are ordered in the way defined in Step 10.\nOverall, when we reach Claim 6.20, we have, in fact, defined a strict ordering of the starting and ending points of the intervals of all vertices. As we argued before this sequence of claims, this completes the proof.\nWe are now ready to conclude the proof of Lemma 6.9, which, as argued earlier, implies Lemma 6.5.\nProof of Lemma 6.9. Let s \u2208 N. We claim that for any n \u2208 N0, Annotated Proper Interval Reconstruction admits a 5 \u00b7 s \u00b7 log 10\n9 n-pass algorithm on n-vertex graphs with success probability at least\n1\u2212 (15) s \u00b7 n log 10 9 n. This follows by induction on n, where at the basis n is a constant (or just 0) and hence the claim is trivial, and the step follows from Lemma 6.13. Now, we pick s = log5(n2). Then, the number of passes is 5 \u00b7 log5(n2) \u00b7 log 109 n = O(log\n2 n), and the success probability is 1\u2212 (15) log5(n2) \u00b7 n log 10 9 n = 1\u2212 1 n2 \u00b7 n log 109 n > 9 10 assuming that n is larger than some fixed constant. This completes the proof."
        },
        {
            "heading": "6.1.2 Post-processing Algorithm",
            "text": "The purpose of this section is to prove the following lemma.\nLemma 6.21. Proper Interval Vertex Deletion admits an O\u0303(n)-space 2O(k) \u00b7 nO(1)-time (static) algorithm.\nTowards this proof, we need to recall the alternative characterization of proper interval graphs in terms of forbidden induced subgraphs. For this purpose, we remind that for any integer i \u2265 3, Ci in the induced (i.e. chordless) cycle on i vertices, and it is termed a hole. A claw, net and tent are specific graphs on four, six and six, respectively, vertices, as illustrated in Fig. 4.\nProposition 6.22 ([Weg67, BLS99]). A graph G is a proper interval graph if and only if is admits no claw, net, tent and hole.\nWe also need the definition of a proper circular-arc graph (see Fig. 5).\nDefinition 6.23. A graph G is a proper circular-arc if there exist a circle C on the Euclidean plane and a function f that assigns to each vertex in G an open interval of C such that no interval properly contains another, and every two vertices in G are adjacent if and only if their intervals intersect. Such a function f is called a representation, and given a vertex v \u2208 V (G), we let beginf (v) and endf (v) denote the beginning and end (in clockwise order) of the interval assigned to v by f (as if it was closed).\nWe note the the class of proper circular-arc graphs is not equivalent to the class of unit circular-arc graphs.\nNotice that any Ci (hole on i vertices) is a proper circular-arc graph, and hence the class of proper arc-circular graphs is a strict superclass of the class of proper interval graphs. Our proof will build upon two results by van \u2019t Hof and Villanger [vtHV13]:\nProposition 6.24 ([vtHV13]). Let G be a graph that that admits no claw, net, tent, C4, C5 and C6 as induced subgraphs. Then, G is a proper circular-arc graph.\nProposition 6.25 ([vtHV13]). Let G be a proper circular-arc graph with representation f . Then, any minimal subset U \u2286 V (G) such that G\u2212 U is a proper interval graph satisfies that there exists v \u2208 V (G) such that U = {u \u2208 V (G) : endf (v) \u2208 f(u)}.7 Moreover, for every v \u2208 V (G), we have that U = {u \u2208 V (G) : endf (v) \u2208 f(u)} satisfies that G\u2212 U is a proper interval graph.\nSo, Propositions 6.24 and 6.25 present a straightforward way to prove Lemma 6.21 given that we know how to obtain a representation of a proper circular-arc graph in O\u0303(n) space and polynomial time. This can indeed be done\u2014for example, thee linear (in the number of vertices and edges) algorithm for this purpose given in [DHH96] can be seen to work in O\u0303(n) space. In what follows, we given an alternative approach, which shows that we can also solve the problem in O\u0303(n) space and polynomial time without the\n7Note that v /\u2208 U (as f(v) is an open interval).\nrepresentation\u2014while the proof is not short, it yields a very simple algorithm (see the proof of Lemma 6.21 ahead), which may be of independent interest.\nWe refine one direction of Proposition 6.25 as follows.\nLemma 6.26. Let G be a proper circular-arc graph with representation f that has an independent set of size at least 4. Then, any minimal subset U \u2286 V (G) such that G\u2212U is a proper interval graph satisfies that there exists v \u2208 V (G) such that U = {u \u2208 V (G) : endf (v) \u2208 f(u), N [v] \u0338= N [u]}.\nProof. Let U be a minimal subset of V (G) such that G\u2212U is a proper interval graph. Then, by Proposition 6.25, there exists w \u2208 V (G) such that U = {u \u2208 V (G) : endf (w) \u2208 f(u)}. Now, let v \u2208 U be a vertex such that N [v] = N [w] and when we go in clockwise order starting at endf (v) (and neglecting vertices whose intervals coincide with that of v apart from v itself), the last end endf (\u00b7) that we encounter among those of all vertices in U that have the same neighborhood as w is that of v. In particular, as the maximum independent set size is at least 4, this means that there does not exist a vertex u with the same closed neighborhood as v (and in particular, which is a neighbor of w) and yet \u201cends after v\u201d, that is, endf (v) \u2208 f(u). So, T = {u \u2208 V (G) : endf (v) \u2208 f(u), N [v] \u0338= N [u]} = {u \u2208 V (G) : endf (v) \u2208 f(u)} \u2286 U (see Fig. 6). If w = v, we are done. Else, we have that T \u2282 U because v \u2208 U but v /\u2208 T . By Proposition 6.25, G\u2212 T is a proper interval graph. However, this contradicts the minimality of U .\nRecall that the crux of the proof should be in the following lemma.\nLemma 6.27. Consider Proper Interval Vertex Deletion on proper circular-arc graphs that admit no claw, net, tent, C4, C5, C6 and C7 as induced subgraphs. Then, it admits an O\u0303(n)-space 2O(k) \u00b7 nO(1)-time (static) algorithm.\nTowards the proof of this lemma, we have the following lemma. In particular, this lemma gives a characterization of minimal solutions that does not depend on f .\nLemma 6.28. LetG be a proper circular-arc graph with representation f and that has an independent set of size at least 4. Let v \u2208 V (G), and denote U = {u \u2208 V (G) : endf (v) \u2208 f(u), N [v] \u0338= N [u]}. Then, there exists x \u2208 V (G) such that U = Wv,x where Wv,x = {u \u2208 N [v] \u2229N [x] : N [u] \u0338= N [v], N [u] \u2286 N [v] \u222aN [x]}.\nProof. Let x be a vertex such that x \u2208 U (and so endf (v) \u2208 f(x)) and among all vertices in U the end of its interval endf (x) is furthest from endf (v) (when distance is measure in clockwise order); see Fig. 7. In what follows, we show that U = Wv,x.\nIn one direction, consider some u \u2208 U . Then, because endf (v) \u2208 f(u), endf (v) \u2208 f(x) and G has an independent set of size at least 4, and by the choice of w, this means that when we go from startf (v) in clockwise order, we observe the ordering startf (v) < startf (u) \u2264 startf (x) < endf (v) < endf (u) \u2264 endf (x); see Fig. 7. So, f(u) has non-empty intersection with both f(v) and f(x), and it is contained in their union, which means that u \u2208 N [v] \u2229N [x] and N [u] \u2286 N [v] \u222aN [x]. Because u \u2208 U , it also holds that N [u] \u0338= N [v], and hence u \u2208Wv,x.\nIn the other direction, consider some u \u2208Wv,x. Because u \u2208 N [v] \u2229N [x] and in particular u \u2208 N(v), we have that endf (v) \u2208 f(u), startf (v) \u2208 f(u) or f(v) = f(u). Because N [u] \u0338= N [v] while N [u] \u2286 N [v] \u222aN [x], there exists a vertex that is a neighbor of u and x but not of v. However, by the choice of x and because G has an independent set of size at least 4, in case startf (v) \u2208 f(u) or f(v) = f(u), this is not possible. For intuition, see Fig. 7 (where it can be seen that any vertex in N [u] \\N [x], which in this case is 5, must be \u201cmore to the left\u201d than x, which imply that u is \u201cmore to the left\u201d than v) and Fig. 8. So, necessarily, endf (v) \u2208 f(u).\nWe complement Lemma 6.28 with the following simple observation.\nObservation 6.29. Let G be a proper circular-arc graph with representation f such that the maximum independent set size of G is at most 3, and which admits no claw, net, tent, C4, C5, C6 and C7 as induced subgraphs. Then, G is a proper interval graph.\nProof. Targeting a contradiction, suppose that G is not a proper interval graph. Then, as G admits no claw, net, tent, C4, C5, C6 and C7 as induced subgraphs, by Proposition 6.22, it must admit some hole Ci for i \u2265 8 as an induced subgraph. As Ci for any i \u2265 8 has an independent set of size at least 4, so does G, and therefore we have reached a contradiction.\nNow, it becomes easy to prove Lemma 6.27:\nProof of Lemma 6.27. The algorithm works as follows. It first checks in O\u0303(n) space and polynomial time whether G is already proper interval graph by making use of the algorithm in Lemma 6.5, and if the answer is positive, then it returns that we have a yes-instance (with solution \u2205). Notice that although the algorithm in Lemma 6.5 works for streams, we can simulate it by iterating over the edges in G.\nAfterwards, for every pair of vertices v, x \u2208 V (G), it computes Wv,x = {u \u2208 N(v) \u2229N(x) : N [u] \u0338= N [v], N(u) \u2286 N(v) \u222aN(x)} and if |Wv,x| \u2264 k, then:\n\u2022 It checks in O\u0303(n) space and polynomial time whether G\u2212Wv,x is a proper interval graph by making use of the algorithm in Lemma 6.5.\n\u2022 If the answer is positive, then it returns that we have a yes-instance (with solution Wv,x).\nAt the end, having not returned a positive answer so far, the algorithm returns \u201cno-instance\u201d. This completes the description of the algorithm.\nClearly, our algorithm uses O\u0303(n) space and polynomial time. We now argue that it is correct. In one direction, suppose that (G, k) is a yes-instance, and let U be a solution for it. If G is already a proper interval graph, then by the correctness of the algorithm in Lemma 6.5, our algorithm returns \u201cyes-instance\u201d. Else, by Observation 6.29, G has an independent set of size at least 4. Then, Lemmas 6.26 and 6.28 imply that there exists a pair of vertices v, x \u2208 V (G) such that U = Wv,x. By the correctness of the algorithm in Lemma 6.5, in the iteration corresponding to this pair our algorithm should return \u201cyes-instance\u201d.\nIn the other direction, suppose that our algorithm returns \u201cyes-instance\u201d. By the correctness of the algorithm in Lemma 6.5, either G is already a proper interval graph, or our algorithm has found a subset of vertices W of size at most k such that G\u2212W is a proper interval graph. So, (G, k) is a yes-instance.\nFinally, we are ready to prove Lemma 6.21.\nProof of Lemma 6.21. The algorithm works as follows. We first consider every subset X \u2286 V (G) of size at most 6, and for each such subset X , we check whether it induces a claw, net, tent, C4, C5, C6 or C7; in case the answer is positive, we branch on which vertex to delete from X (that is, the algorithm calls itself recursively on (G\u2212 v, k \u2212 1) for each v \u2208 X). After this, we call the algorithm in Lemma 6.27 and return the same answer.\nBy Proposition 6.22 and because we select which vertices to delete to hit all claws, nets, tents, C4\u2019s, C5\u2019s, C6\u2019s and C7\u2019s in an exhaustive manner, there exists a solution to (G, k) if and only if there exists a solution to one of the instances with whom we call the algorithm in Lemma 6.27. Moreover, by Proposition 6.24, each call is made with a proper circular-arc graph. So, by the correctness of the algorithm in Lemma 6.27, our algorithm is correct.\nFor the first part of our algorithm, notice that going over every subset X \u2286 V (G) of size at most 7 and doing brute-force to check isomorphism are done in O\u0303(n) space. Moreover, the total time required by this part if 7k \u00b7 nO(1) (since we branch in at most 7 ways, and in each the parameter k is decreased). So, by the space and time complexities of the algorithm in Lemma 6.27, we conclude that the space and time complexities of our algorithm are as stated.\nBased on Theorem 2.2, 6.5 and 6.21, we conclude the correctness of Theorem 6.4."
        },
        {
            "heading": "6.2 Block Vertex Deletion in One Pass",
            "text": "Recall (see Section 4.3) that a graph G is a block graph if every biconnected component of it is a clique and equivalently, if it is {D4, C\u2113+4, \u2113\u22650}-free.\nThe purpose of this section is to prove the following theorem.\nTheorem 6.30. Block Vertex Deletion admits a 1-pass semi-streaming algorithm with 2O(k) \u00b7 nO(1) post-processing time."
        },
        {
            "heading": "6.2.1 Reconstruction Algorithm",
            "text": "In this section we present a somewhat more general result on the reconstruction of block graphs. We begin by defining t-flow graphs and t-block graphs that generalize block graphs. Next, we present a 1-pass randomized streaming algorithm for reconstruction of t-flow graphs. Then, combined with a simple recognition algorithm, based on Perfect Elimination Ordering, we obtain a 1-pass randomized streaming algorithm for reconstruction of t-block graphs. As a corollary we obtain a one-pass randomized reconstruction algorithm for block graphs.\nDefinition 6.31. For an integer t \u2265 1, a graph G is called t-flow graph if and only if for each pair of vertices u, v \u2208 V (G) either {u, v} \u2208 E(G), or there is a subset S of at most t vertices such that u and v are disconnected in G\u2212 S.\nDefinition 6.32. For an integer t \u2265 1, a graph G is called a t-block graph if it is a chordal graph where any two maximal cliques intersect in at most t vertices.\nNote that 1-block graphs are the same as block graphs. Recall that a clique-tree decomposition of a graph G is a tree-decomposition (T, \u03b2) such that every bag \u03b2(v) for v \u2208 V (T ) induces a clique in G [BLS99]. Then recall that a graph G is chordal if and only if it admits a clique-tree decomposition [BLS99]. Then following observation is immediate.\nObservation 6.33. A graph G is a t-block graph if and only if it is a chordal t-flow graph.\nLet us begin with a reconstruction algorithm for t-flow graph.\nLemma 6.34. Let t \u2265 1 be an integer. The class of t-flow graphs has a 1-pass randomized reconstruction algorithm, with nt+O(1) post-processing time and O\u0303(n) space.\nProof. Let F = {V1, V2, . . . , Vr} be a (n, t, 2)-separating family over V (G). Note that such a family contains r = (t + 2)10 log(t + 2) log n vertex subsets, and it can be constructed in O(tO(1)n log n) time and space (Corollary 4.5). Recall that, for any pair of vertices {u, v} and any Q \u2286 V (G) such that |Q| \u2264 t, there is an Vi \u2208 F such that u, v \u2208 Vi and Vi \u2229 S = \u2205. For Vi \u2208 F , let Gi = G[Vi]. We now describe our algorithm.\n\u2022 Streaming Phase. With the family F in hand, our algorithm computes the following data structures in 1-pass: (i) the degree dG(v) of every vertex v \u2208 V (G), and (ii) for each Gi, a (randomized) connectivity sketch Di (Proposition 4.8). Note that Di is a spanning-forest of Gi and we can enumerate E(Di). Further, we require O\u0303(r \u00b7 n) space to store all these data-structures. Let G\u2032 be the graph with vertex set V (G) and edge-set \u222a1\u2264i\u2264rE(Di), and note that we can explicitly construct G\u2032, which requires O\u0303(r \u00b7 n) space.\n\u2022 Reconstruction Algorithm. Next, let us describe the post-processing algorithm to reconstruct G. Recall that our goal is to devise an nt+O(1)-time and O\u0303(n)-space algorithm that, given a pair of vertices u, v \u2208 V (G) as input, outputs that either {u, v} \u2208 E(G), or {u, v} /\u2208 E(G), or else G is not a t-flow graph. This algorithm is as follows. We first define a graph G\u0303 on the vertex V (G), and compute the degree d\nG\u0303 (v) of every vertex v \u2208 V (G). Note that this graph G\u0303 is not explicitly\nconstructed. Initially, let G\u0303 = G\u2032. Then we consider every distinct pair of non-adjacent vertices x, y in G\u0303. For each vertex pair x, y, we determine if {x, y} \u2208 E(G) or not as follows. We consider every subset S of at most t vertices such that x, y /\u2208 S. For each choice of S, we first determine Vi \u2208 F such that x, y \u2208 Vi and S \u2229 Vi = \u2205. Then we check if x and y are connected in Gi = G[Vi] by using its connectivity sketch Di. If x and y are connected in Gi for every choice of S, then we conclude that edge {x, y} is in G\u0303 and increment d\nG\u0303 (x) and d G\u0303 (y) by 1 each. Furthermore, if the pair x, y is\nthe input pair u, v, then we also remember if this particular pair forms an edge or a non-edge. Finally, when all vertex pairs have been processed, we check if dG(v) is equal to dG\u0303(v) for all v \u2208 V (G). If not, then we output that G is not a t-flow graph. Otherwise, we output that G is not a t-flow graph, and the succinct representation queries, given u, v, whether or not {u, v} \u2208 E(G\u0303). Observe that, it is clear that the above algorithm requires nt+O(1) time and O\u0303(n) space.\nWe now argue that above reconstruction algorithm is correct. Towards this, we first show that E(G) \u2286 E(G\u0303), irrespective of whether or not G is a t-flow graph. Consider any edge {x, y} \u2208 E(G), and consider any subset of vertices S \u2286 V (G) such that |S| \u2264 t and x, y /\u2208 S. Then, the separating-family F contains Vi such that x, y \u2208 Vi and S \u2229 Vi = \u2205. Since {x, y} \u2208 E(Gi) and Di is a spanning forest of Gi = G[Vi] (from the connectivity sketch by Proposition 4.8), we have that x, y must in the same connected component of Di. Hence, x, y are connected in Gi. Since this holds for every choice of S, it follows that {x, y} \u2208 E(G\u0303). By applying this argument to every edge in E(G), we obtain that E(G) \u2286 E(G\u0303).\nNext, let us argue that E(G\u0303) \u2286 E(G), assuming that G is a t-flow graph. Towards this, consider an edge {x, y} \u2208 E(G\u0303). As G\u2032 is a subgraph of both G and G\u0303, if {x, y} \u2208 E(G\u2032) then {x, y} \u2208 E(G). Otherwise, {x, y} /\u2208 E(G\u2032). Then, for every S \u2286 V (G) such that |S| \u2264 t and x, y /\u2208 S, consider Vi \u2208 F such that x, y \u2208 Vi and S \u2229 Vi = \u2205. Observe that, as {x, y} \u2208 E(G\u0303), there is a path in Gi = G[Vi] from x to y. This path is also present in the graph G\u2032 \u2212 S. Since this holds for every choice of S, the minimum-separator\nof x and y in G\u2032 has t + 1 or more vertices. Therefore, assuming that G is a t-flow graph, {x, y} \u2208 E(G). Finally, this argument holds for every edge in G\u0303, and hence E(G\u0303) \u2286 E(G). Combined with the above we obtain that E(G) = E(G\u0303), when ever G is a t-flow graph.\nFinally, let us argue that our reconstruction algorithm is correct. In one direction let G be a t-flow graph. Then, as E(G) = E(G\u0303), we have dG(v) = dG\u0303(v) for every vertex v \u2208 V (G). Hence the reconstruction algorithm correctly concludes that G is a t-flow graph (and the succinct representation is correct). In the reverse direction, suppose that the algorithm concludes that G is a t-flow graph. This means that dG(v) = dG\u0303(v) for every vertex v \u2208 V (G). We give a proof by contradiction, and let us assume that G is not a t-flow graph. This means there exists u, v \u2208 V (G) such that {u, v} /\u2208 E(G) and for every S \u2286 V (G), |S| \u2264 t, u and v are connected in G\u2212 S. Then {u, v} \u2208 E(G\u0303), and as E(G) \u2286 E(G\u0303), it must be the case that d\nG\u0303 (v) \u2265 dG(v) + 1. But this is a contradiction since dG(v) = dG\u0303(v). Therefore, G must be a t-flow\ngraph. This concludes the proof of this lemma.\nWe are now ready to present a reconstruction algorithm for t-block graphs. Towards this we require a few results about chordal graphs.\nDefinition 6.35. A perfect elimination ordering of a graph G is an ordering v1, v2, . . . vn of the vertex set V (G) such that for any i \u2208 {1, 2, . . . n}, NGi(vi) is a clique in the graph Gi = G\u2212 {v1, v2, . . . vi\u22121}.\nThe following is a well-known characterization of chordal graph. Recall that a vertex v in a graph G is called simplician if N(v) induces a clique in G.\nProposition 6.36 ([BLS99]). A graph G is a chordal graph if and only if it has a perfect elimination ordering. Furthermore, given a chordal graph G such an ordering can be obtained (greedily) by repeatedly picking a simplicial vertex in the current graph and deleting it.\nLemma 6.37. Let t \u2265 1 be an integer. The class of t-block graphs has a 1-pass randomized reconstruction algorithm, with nt+O(1) post-processing time and O\u0303(n) space.\nProof. Let G denote the input graph. We begin by applying the reconstruction algorithm for t-flow graph from Lemma 6.34 to G. If it concludes that G is not a t-flow graph, then we output that G is not a t-block graph. Otherwise, G is a t-flow graph we obtain a succinct representation of G. Now ,our goal is to test if G is also a chordal graph. Here we apply the algorithm of Proposition 6.36, which requires that we repeatedly pick a simplicial vertex in the current graph and removing it. Observe that it is enough to describe a O\u0303(n) algorithm to find a simplicial vertex in the current remaining graph. This algorithm is as follows. We examine the vertices one by one, and for each vertex v we first enumerate its neighborhood N(v), and then test if every pair of vertices in it forms an edge or not. If so, we conclude that v is a simplicial vertex. Otherwise, v is not a simplicial vertex. It is clear that this runs in nO(1) time and O\u0303(n) space.\nOur algorithm tests if the t-flow graph is chordal by attempting to compute a perfect elimination ordering of it. If it succeeds, then we output that G is a t-block graph, and also output its succinct representation from Lemma 6.34. Otherwise, we output that G is not a t-block graph. To argue the correctness of this algorithm, observe that if the algorithm does succeed in computing a perfect elimination ordering of G, then it is a chordal by Proposition 6.36. Hence, G is a t-block graph by Observation 6.33. In the reverse direction, if G is a t-block graph, then it is a chordal t-flow graph. Hence, by Proposition 6.36, our algorithm produces a perfect elimination ordering of G. Hence it outputs that G is a t-block graph. This concludes the proof of this lemma.\nLet us remark that the above lemma, which describes a linear-space algorithm to recognize whether a given t-flow graph is also chordal, crucially depends on the fact that the t-flow graphs have a linear-space reconstruction algorithm. In contrast, for general graphs we obtain a lower-bound \u2126(n2) for recognizing chordal graphs (see Theorem 9.2)."
        },
        {
            "heading": "6.2.2 Post-processing Algorithm",
            "text": "In this section we present the post-processing algorithm for Block Vertex Deletion (BVD). This algorithm takes as input a graph G and an integer k, and outputs a vertex subset S \u2286 V (G) such that G \u2212 S is a block graph, if one exists. This algorithm uses O\u0303(n) space, and in particular we assume that the input graph G is presented in read-only memory. Our algorithm follows the approach of [AKLS16] (to obtain the fastest possible algorithm) with suitable modifications to use only O\u0303(n) space.\nLet us first consider the case when the input graph G is {C4, D4}-free. Then, we have the following proposition from [AKLS16].\nProposition 6.38 (Lemma 6 [AKLS16]). Let G be a graph that is {C4, D4}-free. Then G has at most n2 maximal cliques, and any two maximal cliques intersect in at most one vertex.\nGiven a graph G that is C4 and D4 free, consider the auxiliary graph H constructed from G as follows. H is a bipartite graph with vertex set V (H) = V (G) \u222a VC where C is the collection of all maximal cliques in G and VC is a collection of vertices, with one vertex vC for each element C of C. The edge set E(H) consists of all pairs (v, vC), where v \u2208 V (G), vC \u2208 VC and C \u2208 C, such that the vertex v belongs to the clique C .\nProposition 6.39 (Lemma 7 [AKLS16]). Let G be a {C4, D4}-free graph, and let H be the auxiliary graph of G. Then, S \u2286 V (G) is a block vertex deletion set of G if and only if S is a feedback vertex set of H .\nAgrawal, Kolay, Lokshtanov and Saurabh [AKLS16] explicitly constructed H and used an algorithm for Feedback Vertex Set on H (while using weights to ensure that only vertices from V (G) are picked). We cannot do this, since just storing the vertex set of H takes O(n2) space. So, we have a more difficult task of resolving the Feedback Vertex Set problem on H without even constructing its vertex set explicitly.\nFor our algorithm, we require the following subroutine that counts the number of maximal cliques in G that contain a specified vertex v.\nLemma 6.40. Let G be a graph and let v be any vertex. Then there is an algorithm that counts the number of maximal cliques in G that contain v using O\u0303(n \u00b7 log \u03b1) space in time \u03b1 \u00b7 nO(1), where \u03b1 denotes the number of maximal cliques in G that contain v.\nProof. We present the algorithm in the following pseudo-code. The input is a graph G and a vertex v. We assume that the vertices of G are numbered from 1 to n in some arbitrary order.\nThe algorithm is implemented a simple branching algorithm. We start by defining an arbitrary ordering \u03c3 of the vertices in V (G) such that v is the first vertex; note that this requires O(n) space and nO(1) time. We then define a global length-n bit-vector X that contains the vertices of the current (partial) maximal clique. The algorithm is implemented via the function Count-X-Cliques() that makes recursive calls at each branching. When this function is called, it iterates over all the common neighbors u of X in V (G) \\X such that \u03c3(u) > \u03c3(w) \u2200w \u2208 X , one by one from smallest to largest. For each u, it counts the number of maximal cliques containing X \u222a {u}. It adds up all these numbers and returns the sum as the number of maximal cliques in G containing X . Observe that, to determine the next common neighbor of\nAlgorithm 1: Counting the number of Maximal Cliques in G containing vertex v Input: Graph G on n vertices, vertex v Output: Number of maximal cliques in G containing vertex v // GLOBAL VARIABLES 1 \u03c3 \u2190 an arbitrary ordering of the vertices in V (G) where \u03c3(v) = 1 // bitvector of the current partial maximal clique 2 X \u2190 bit-vector of length n initialized to all 0 3 X[1]\u2190 1 // Add v to X 4 Function Count-X-Cliques(): 5 Stop\u2190 False 6 uPrev \u2190 0 7 numCliques\u2190 0 8 while not Stop do 9 u\u2190 the common neighbor of X in V (G) \\X minimizing \u03c3(u) such that\n\u03c3(u) > \u03c3(uPrev) and \u03c3(u) > \u03c3(w) \u2200w \u2208 X 10 if u = NULL then 11 if numCliques = 0 then\n// then the input X cannot be extended to a larger clique\n12 numCliques\u2190 1 13 end 14 Stop\u2190 True 15 else 16 uPrev \u2190 u 17 X[\u03c3(u)]\u2190 1 // Extend X by the vertex u\n// Recursively count maximal cliques containing X extended by u\n18 uCliques\u2190 Count-X-Cliques() 19 numCliques\u2190 numCliques + uCliques 20 X[\u03c3(u)]\u2190 0 // Restore X 21 end 22 end 23 return numCliques\nX , it only needs to remember the previous common neighbor and check all larger vertices in V (G) \\X one by one. Note that this can be done in nO(1) time and O(log n) space. If no common neighbor of X exists, then X itself is a maximal clique and we return 1. It is clear that every maximal clique in G that contains v is generated and counted once, in the lexicographic order induced by \u03c3 on subsets of V (G). Indeed, for any two common neighbors u, u\u2032 of X such that \u03c3(u) < \u03c3(u\u2032), the maximal cliques that contains both vertices are only generated in the branch for X \u222a u (and not in the branch for X \u222a u\u2032). Next, we show the claimed bounds on space and time.\nObserve that each call to the function Count-X-Cliques() requires only a constant number of local-variables, that each require at most log \u03b1 bits to store. Further, the depth of recursion is upperbounded by n since each recursive call sets a 0-bit of X to 1. Hence the total space used by the algorithm is O\u0303(n \u00b7 log \u03b1). Finally, observe that after any n successive calls made to Count-X-Cliques(), we must encounter a maximal clique of G that contains v, and each call internally requires nO(1) time. Hence the total time required by this algorithm is \u03b1 \u00b7 nO(1).\nAs a corollary of Proposition 6.38 and Lemma 6.40, we obtain the following.\nLemma 6.41. Let G be a graph that is {C4, D4}-free. Then in nO(1) time and O\u0303(n) space, we can count and store the number of maximal cliques in G that contain v for every vertex v \u2208 V (G).\nNext, we present a few lemmas and reduction rules that will be useful for our algorithm.\nLemma 6.42. Let G be a graph that is {C4, D4}-free. Then the following statements hold.\n\u2022 Let v \u2208 V (G) be a vertex that lies in only one maximal clique of G. Then, S \u2286 V (G) is a block vertex deletion set of G if and only if it is a block vertex deletion set for G\u2212 v.\n\u2022 Let G\u2032 be the graph obtained from G by iteratively removing all vertices that lie in only one maximal clique. Then, G\u2032 can be computed in nO(1) time and using O\u0303(n) space. Moreover, if G is a block-graph then G\u2032 is the empty graph.\n\u2022 Let H \u2032 be the auxiliary graph of G\u2032. Then, every vertex of H \u2032 has at least two distinct neighbors.\nProof. Consider the first statement. One direction is clear\u2014if S is a solution to G, then it is also a solution to G\u2212 v. In the reverse direction, consider the block graph (G\u2212 v)\u2212 S. Then observe that, adding back v to (G \u2212 v) \u2212 S results in a block graph as well, since the neighborhood of v in G is a clique. For the second statement, to compute the graph G\u2032, we find a vertex v in G that lies in only one maximal clique. Here we apply Lemma 6.40, and it is clear that the required space and time bounds are obtained. Next, if G were a block graph then it has a perfect elimination ordering (see Definition 6.35 and Proposition 6.36) that is obtained by greedily removing simplicial vertices from G one by one. Hence, iteratively removing all vertices of G that lie in only one maximal clique results in an empty graph. Finally, for the third statement observe that, as each vertex in G is part of two distinct maximal cliques, in H it has at least two neighbors. Similarly, any maximal clique in G contains at least two vertices, and hence it has at least two neighbors in H .\nLemma 6.43. Let G be a {C4, D4}-free graph such that every vertex of G lies in at least two maximal cliques. Further, suppose that there is no connected component of G that is just a cycle. Let H be the auxiliary graph of G.\n(i) In nO(1) time and O(n) space, we can identify and mark each vertex v \u2208 V (G) such that dG(v) = 2 and dG(u) = dG(u\u2032) = 2 where u, u\u2032 are the two neighbors of v in G.\n(ii) Let P be a maximal path in H such that all of its vertices are of degree 2 in H , P is not a cycle and the end-vertices are from V (G). Then all internal vertices of P that lie in V (G) are marked, and the two end-vertices are unmarked.\n(iii) If v is a marked vertex, then there is a maximal path P in H such that all vertices of P are of degree 2, P is not a cycle, the endpoints of P lie in V (G) and they are unmarked.\n(iv) Let S \u2286 V (G) be a feedback vertex set of H . Then, there exists another feedback vertex set S\u2032 \u2286 V (G) whose vertices are all unmarked and such that |S\u2032| \u2264 |S|.\nProof. For (i), we simply enumerate each vertex v of degree 2 in G, and then test if the two neighbors of v are also of degree 2. Here we note that every vertex of G lies in at least 2 maximal cliques, and therefore there are no vertices of degree 1 in G. After this marking procedure, observe that if Q is a maximal path in G such that every vertex of Q has degree 2 in G, then all internal vertices of Q are marked, while the two endpoints are unmarked. Since V (G) \u2286 V (H), we can carry over the marking in G to the auxiliary graph H .\nFor (ii), let is let u, v be the two endpoints of P and note that u, v \u2208 V (G). Let u\u2032 and u\u2032\u2032 be the neighbors of u in V (H) \\ V (P ) and V (P ), respectively. Note that u\u2032, u\u2032\u2032 \u2208 VC correspond to maximal cliques of G. Consider u\u2032 and let K \u2208 C be the maximal clique of G corresponding to it. Note that we have two cases: either the K contains at least 3 vertices, or only 2 vertices. In the first case u \u2208 V (K) has at least 3 neighbors in G, 2 in V (K) and another in the maximal clique corresponding to u\u2032\u2032. Hence u is unmarked (indeed, we can further argue that P must exclude u). In the second case u\u2032 is of degree 2 in H , and it has a neighbor x \u2208 V (G) in H . Then u and x are adjacent in G (forming the clique C corresponding to u\u2032). However, as P is maximal and x /\u2208 V (P ) it must be the case that dH(x) \u2265 3. Then it is clear that dG(x) \u2265 3. Hence, in the graph G, while dG(v) = 2, one of it\u2019s neighbors x has degree at least 3. Therefore, once again, u is not marked. Similar arguments apply to the vertex v, and hence u, v are not marked. Now consider any internal vertex w of P that lies in V (G), and observe that dG(w) = 2 and for the two neighbors w\u2032, w\u2032\u2032 of w in G, dG(w\u2032) = dG(w\u2032\u2032) = 2. Hence, every internal vertex of P that lie in V (G) are marked.\nFor (iii), recall that v is marked in G, only if dG(v) = 2 and the two neighbors of v in G, u, w are also of degree 2 in G. Then observe that, corresponding to the path u\u2212 v \u2212 w in G, we have a path P \u2032 in H that consists of u\u2212 x\u2212 v \u2212 y \u2212 w where x, y \u2208 VC correspond to the maximal cliques {u, v} and (v, w) of G, respectively. Next consider a maximal path P \u2032\u2032 of H that contains P \u2032 such that all vertices of P \u2032\u2032 are of degree 2 in H . If P \u2032\u2032 is a cycle of H then by construction it corresponds to a cycle C in G whose vertices have degree 2 in G. This means that C is a connected component of G that is just a cycle, which is forbidden by the premise of the lemma. Hence P \u2032\u2032 is not a cycle in H , and it contains a maximal sub-path P whose both-endpoints are in V (G). By (ii), the two endpoints of P are unmarked.\nFor (iv), first observe that any vertex v \u2208 V (G) \u2286 V (H) such that dH(v) \u2265 3 must satisfy dG(v) \u2265 3, and hence it is unmarked. Next, observe that as G has no connected component that is an isolated cycle, H has no cycle whose all vertices are of degree 2 in H . Therefore, any cycle C of H can be partitioned into maximal paths whose vertices are of degree 2 in H and the remaining vertices that have degree 3 or more. Each such maximal path P \u2032 contains another maximal path P \u2032\u2032 such that the endpoints of P \u2032\u2032 lie in V (G). By (ii), the endpoints of P \u2032\u2032 are unmarked. Now consider the feedback vertex set S \u2286 V (G) of H and consider any marked vertex w \u2208 S. By (iii), w lies in a maximal path P of H such that all vertices of P are of degree 2, P is not a cycle, the end-vertices of P lie in V (G) and they are unmarked. Since any cycle containing w must contain both u and v, it is clear (S \\ {w}) \u222a {u} is another feedback vertex set of\nH of same or smaller size. Therefore, by replacing every marked vertex in S, we can obtain a feedback vertex set S\u2032 that contains only unmarked vertices and |S\u2032| \u2264 |S|. This concludes the proof.\nLet us now describe our algorithm for Block Vertex Deletion on the class of {C4, D4}-free graphs.\nLemma 6.44. Let G be a {C4, D4}-free graph and let k be an integer. Then there is a randomized algorithm that can decide if there is a block vertex deletion set of cardinality at most k in G, and compute one if it exists. This algorithm runs in 17knO(1) time, uses O\u0303(nk) space and succeeds with constant probability > 2/3.\nProof. Our algorithm is based on Proposition 6.39 and a simple randomized branching algorithm for Feedback Vertex Set ([BBYG00]; see also Chapter 5 in [CFK+15]). Let H be the auxiliary graph of G, and recall that we seek a feedback vertex set of cardinality at most k in H that is a subset of V (G). Note that, as the number of maximal cliques in G could be O(n2), it is not possible for us to explicitly construct the graph H . Therefore, we must extract the required information about H from G in O\u0303(n) space and nO(1) time.\nTo simplify the algorithm, let us immediately deal with a special case. Suppose that G contains a connected component that is an isolated cycle C of length 4 or more. Then, observe that corresponding to C we obtain a connected component C \u2032 of H that is also a cycle whose vertices correspond to V (C) and E(C). For such cycles, we simply pick an arbitrary vertex of C into our solution, decrease k by 1, and remove the rest of C from G. The optimality and correctness of this step is clear. When this reduction is not applicable, we can assume that there is no connected component of G that is just a cycle. Hence, there is a vertex of degree at least 3 in every connected component of G.\nThe randomized branching algorithm for feedback vertex set [CFK+15], first applies some simple reduction rules to ensure that every vertex has at least 3 distinct neighbors. Then, it can be shown that if S is any feedback vertex set, then at least half the edges have an endpoint in S. In our setting, where space is bounded, applying these reduction rules becomes a little more challenging. Towards this, we first apply Lemma 6.42 and Lemma 6.43, which can be done in O\u0303(n) space and nO(1) time. Further, Lemma 6.43 ends up marking a subset of vertices of V (G) \u2286 V (H). Then, we prove the following claim.\nClaim 6.45. Let S \u2286 V (G) is a feedback vertex set of H that contains only unmarked vertices, and let E\u0303 \u2286 E(H) be the collection of all those edges that have an unmarked endpoint. Then if we pick an edge e \u2208 F uniformly at random, then with probability at least 1/17, one endpoint of e lies in S.\nTo prove this claim, observe that by Lemma 6.42, every vertex in H has two distinct neighbors. Moreover, by Lemma 6.43, if P is a maximal path made of degree-2 vertices in H , then all vertices of P \u2229V (G) except perhaps the two end-vertices of P and their immediate neighbors in P are marked. Let us consider every vertex in VC \u2286 V (H) of degree-2 in H whose both neighbors from V (G) have been marked, as another marked vertex. Then for every maximal path P of degree-2 vertices in H , all vertices are marked except for at most 6 vertices, the two endpoints and the 4 vertices in P that closest to them. Note that, we don\u2019t need to explicitly mark these vertices, but only require them for analysis. Also note that if v \u2208 V (H) is marked then dH(v) = 2. The proof of this claim, now easily follows from Lemma 5.1 of [CFK+15] that states that when graph X has minimum degree 3, and Y is any feedback vertex set of X , then a randomly sampled edge of X has an endpoint in Y with probability at least 1/2.\nIndeed, consider the graph H \u2032 obtained by contracting each edge whose both endpoints are marked vertices in H one by one, until every edge has at least one unmarked endpoint. Observe that there is a bijection between the edges of H \u2032 and the edges of H with at least one unmarked endpoint. Further observe that any maximal path of degree-2 vertices of H \u2032 have length at most 7. Moreover, any feedback vertex set of H \u2032 is a feedback vertex set of H , and any feedback vertex set of H that contains only unmarked vertices\nis a feedback vertex set of G. Now consider a feedback vertex set X of H , and consider the forest H \u2032 \u2212X . Let Y = V (H \u2032) \\X , and we claim that |Y | \u2264 16|E(X, Y )| where E(X, Y ) denotes the edges of H \u2032 with one endpoint in X and the other in Y . Let V1, V2, V3 denote the subsets of vertices of H \u2032\u2212X of degree 1, 2 and \u2265 3 respectively. Note that |V3| \u2264 |V1|, by a standard result on forests. And, as the minimum degree of H \u2032 is two, each vertex in V1 has a distinct edge in H \u2032 whose other endpoint lies in X , i.e. |V1| \u2264 |E(X, Y )|. Hence, |V3|+ |V1| \u2264 2|E(X, Y )|. Next, to bound |V2| consider the forest H \u2032\u2032 obtained from H \u2032 \u2212X , by contracting every vertex of degree 2. Then |E(H \u2032\u2032)| \u2264 |V3| + |V1| \u2212 1. Observe that each edge of H \u2032\u2032 corresponds to a maximal path of degree 2 vertices in H \u2032 \u2212 Y whose length is upper-bounded by 7, and these paths partition V2. Hence |V2| \u2264 7|E(H \u2032\u2032)| \u2264 7(|V3|+ |V1| \u2212 1) \u2264 14|E(X, Y )|, and therefore we conclude that |Y | \u2264 16|E(X, Y )|. Then, we conclude that |E(H \u2032 \u2212X)| \u2264 |Y | \u2264 16|E(X, Y )|. Finally, let E(X) be the set of edges with at least one endpoint in X and note that |E(X)| \u2265 |E(X, Y )| \u2265 |V1|. And let E(Y ) be the set of edges with both endpoints in Y ; |E(Y )| = |E(H \u2032 \u2212X)| \u2264 16|E(X, Y )|. Therefore the probability that an edge that is sampled uniformly at random from E(H \u2032) has an endpoint in X is at least 1/17.\nFollowing this claim, and Proposition 6.39, a simple randomized algorithm could be as follows: sample an edge e \u2208 E\u0303, then select the endpoint v of e from V (G) into the solution, and then solve (H \u2212 v, k \u2212 1). This algorithm would produce a solution in polynomial time with probability 1/17k. Unfortunately, as H is not explicitly constructed, we cannot easily sample edge of E\u0303. However, observe the following. Let V \u2032 \u2286 V (G) be all the unmarked vertices. The probability that a vertex v \u2208 V \u2032 is selected by the above random process is equal to dH(v)/|E\u0303|. Here we rely on the fact that if v is an unmarked vertex in H , then all edges incident on v are present in E\u0303. Hence, if we sample a vertex v \u2208 V (G) with probability dH(v)/|E\u0303|, then with probability 1/17, v \u2208 S. To implement this sampling process, we only need to know the degrees of the vertices in V (G) and as H is bipartite we have |E\u0303| = \u2211 v\u2208V (G) : v is unmarked dH(v). These values can obtained from Lemma 6.41 in nO(1)) time and O\u0303(n) space. After sampling, v we can recursively solve the instance (H \u2212 v, k \u2212 1). Here the base case of this algorithm where k = 0 is handled by Lemma 6.42. It allows us to test if G is a block graph in polynomial time and O\u0303(n) space. If this test fails, we output that there is no solution, or else there is a solution of size 0 for G. Observe that this leads to a polynomial time algorithm that requires O\u0303(nk) space and outputs a feedback vertex set S \u2286 V (G) of size k with probability at least 1/17k. By repeating this algorithm O(17k) times we obtain a simple randomized algorithm for Block Vertex Deletion in {C4, D4}-free graphs that 17k \u00b7nO(1) time and uses O\u0303(nk) space. By standard arguments, it follows that this algorithm succeeds with probability > 2/3 (which can be boosted to any constant by further repetitions).\nFinally, we extend the above lemma to an algorithm for Block Vertex Deletion.\nLemma 6.46. Block Vertex Deletion admits a randomized FPT-algorithm that runs in time 17knO(1) time O\u0303(nk) space, where k is the parameter denoting the solution size. It outputs a solution with constant probability.\nProof. Let G be the input graph. Our algorithm is implemented in two stages. In the first stage, we have a simple branching algorithm that finds C4 or a D4 in G and branches on which of it\u2019s vertices lies in a solution of size k. This process can be represented via a branching tree of depth k, where each node has four child-nodes. At the leaf of each node, either we obtain a subgraph G\u2032 that is {C4, D4}-free, or conclude that the choices made to arrive at that node does nnt lead to a solution of size k. Note that this stage of the algorithm can be implemented in time O(4kn4) and space O(k log n). In the next stage, we apply Lemma 6.44 to the graph G\u2032 along with the parameter k\u2032. Here k\u2032 = k \u2212 (the number of vertices\nselected in Stage 1). It follows that Stage 2 runs in time 17knO(1) and O\u0303(nk) space, and succeeds with constant probability. Hence, we obtain the required algorithm for Block Vertex Deletion.\nFrom Theorem 2.2, Lemma 6.37 and Lemma 6.46 we obtain Theorem 6.30. Here we also rely on the fact that the class of block graphs are hereditary."
        },
        {
            "heading": "7 Cut Problems",
            "text": "Our starting point is the sampling primitive of Guha, McGregor and Tench [GMT15] (with appropriately set parameters). The main idea here is to sample roughly O\u0303(kO(1)) vertex subsets of the input graph so that with good probability, for every set S \u2286 V (G) that is disjoint from some forbidden substructure (of potentially unbounded size) in G, there is a set of sampled subgraphs that are disjoint from S and whose union also contains a forbidden substructure for the problem concerned. This allows us to produce O\u0303(kO(1)n) subgraphs that can still certify when a vertex set is not a solution for the problem at hand. However, this is only the first part of our approach and problem-specific steps need to be taken following this.\nSampling Primitive (V (G), n, k, q)a: Sample \u2113 = 64qk3 ln n vertex subsets V1, . . . , V\u2113 of G. Each Vi is sampled by independently picking each vertex of G with probability 1/2k. Let Gi = G[Vi] for every i \u2208 [\u2113], let L = {G1, . . . , G\u2113} and for every S \u2286 V (G), let LS = {Gi \u2208 L | V (Gi) \u2229 S = \u2205}.\naWe assume that n, k, q \u2265 1.\nWe now summarize a useful property of the sampling primitive, which is required for the correctness of some of our algorithms.\nLemma 7.1 (Properties of Sampling Primitive (V (G), n, k, q)). Fix a set {C1, . . . , Cr} where r \u2264 nq and each Ci is a set of subgraphs of G. With probability at least 1 \u2212 2/n, the following event occurs: For every k-vertex set S \u2208 V (G) and for every Ci, if S is disjoint from some C \u2208 Ci, then \u22c3 G\u2208LS G contains some C \u2032 \u2208 Ci.\nProof. Let Sk denote the set of all k-vertex sets in G. For every fixed S \u2208 Sk, the expected number of sampled vertex subsets disjoint from S,\nE[ |LS | ] = (1\u2212 1/2k)k \u00b7 \u2113 \u2265 \u2113/4 = 16qk3 ln n.\nUsing standard Chernoff bounds we get:\nProb[ |LS | < 8qk3 ln n ] \u2264 e2qk 3 ln n \u2264 1/n2k.\nLet Y denote the event that for every S \u2208 Sk, |LS | \u2265 8qk3 ln n. Taking the union bound over all S \u2208 Sk, we conclude that:\nProb[ \u2203S \u2208 Sk : |LS | < 8qk3 ln n ] = Prob[Y ] \u2264 1/nk.\nWe say that S \u2208 Sk is good if for every i \u2208 [r] at least one element of Ci disjoint from S is contained in the union of the graphs in LS . We say that S \u2208 Sk is bad otherwise. Let X denote the event that every S \u2208 Sk is good. Recall that:\nProb[X ] \u2264 Prob[Y ] + Prob[X | Y ].\nNow, we observe the following for a fixed S \u2208 Sk:\nProb[ S is bad | Y ] \u2264 nq \u00b7 n2 \u00b7 (1\u2212 1/(2k)2)8qk3 ln n \u2264 1/n2k.\nHere, for each i \u2208 [r], we fixed a graph C in Ci, used union bound along with the fact that the number of edges in C is at most n2 and then took union bound over the Ci\u2019s. Finally, taking the union bound over all S \u2208 Sk, we conclude that:\nProb[ \u2203S \u2208 Sk : S is bad | Y ] = Prob[X | Y ] \u2264 1/nk.\nTherefore, with probability at least 1\u2212 2/nk \u2265 1\u2212 2/n, we conclude that every k-vertex set in Sk is good. This completes the proof of the lemma.\nIn the rest of this section, we use the above sampling primitive as the first step in our fixed-parameter semi-streaming algorithms for well-studied cut problems. As discussed above, this primitive identifies O\u0303(kO(1)n) subgraphs that can still certify when a vertex set is not a solution for the problem at hand. However, these subgraphs may still be large and dense. Therefore, for the problems we consider in this section, we provide a problem-specific sparsification step that allows us to shrink the number of edges in each subgraph while ensuring that non-solutions can be witnessed by a substructure in the union of the sparsified subgraphs."
        },
        {
            "heading": "7.1 Odd Cycle Transversal",
            "text": "Recall that in the Odd Cycle Transversal (OCT) problem, the input is a graph G and integer k and the goal is to decide whether there is a set of at most k vertices that intersect every odd cycle in G.\nBefore we proceed, we recall the notion of the bipartite double cover of a graph.\nDefinition 7.2 ([AGM12]). For a graph G, the bipartite double cover of G is the graph D constructed from G as follows. For each v \u2208 V (G), construct va, vb \u2208 V (D) and for each edge (u, v) \u2208 E(G), create two edges (ua, vb) and (ub, va).\nThe above definition was used by Ahn, Guha and McGregor [AGM12] to give the first dynamic semistreaming algorithm to test bipartiteness. In this work, we use the properties of bipartite double covers to generalize their result and give a fixed-parameter semi-streaming algorithm for checking if a graph is at most k vertices away from being bipartite, i.e., OCT.\nTheorem2.5. There is a 1-pass O\u0303(kO(1)\u00b7n)-space randomized streaming algorithm forOCTwith O\u0303(3kkO(1)n)time post-processing.\nProof. If k = 0, then we simply need to check whether the input graph is bipartite. For this, we use the aforementioned algorithm of Ahn, Guha and McGregor [AGM12]. Hence, we may assume that k \u2265 1. Let G be the input graph. We run Sampling Primitive (V (G), n, k, 2) to generate the vertex sets V1, . . . , V\u2113 \u2286 V (G) and then process the input stream as follows. For each sampled vertex set Vi, we use Proposition 4.8 to maintain a connectivity sketch for the bipartite double cover of Gi, which is denoted by Gauxi (see\nDefinition 7.2). Recall that Gauxi has exactly 2|Vi| vertices. Therefore, the space requirement for each Vi is bounded by O\u0303(n). This completes the processing step. Since \u2113 = O\u0303(kO(1)), the space used by our processing step is O\u0303(kO(1) \u00b7 n) as required.\nIt remains for us to describe our fixed-parameter post-processing routine. Recall that for any c > 0 and i \u2208 [\u2113], with probability at least 1\u2212 1/nc, we can recover a spanning forest of Gauxi . By choosing c to be large enough and taking the union bound over polynomially many subgraphs, we obtain a spanning forest Ti of Gauxi for each i \u2208 [\u2113] and conclude that with probability at least 1\u2212 1/n, each Ti is indeed a spanning forest of Gauxi . Now, we define Hi to be the subgraph of Gi induced by edges that contribute a copy to Ti. That is, an edge e = (u, v) \u2208 E(Gi) is added to Hi if and only if (ua, vb) or (ub, va) is contained in E(Ti). Notice that the number of edges in each Hi is bounded by O(n), implying that the number of edges in the graph \u22c3 i\u2208[\u2113] Hi is O\u0303(kO(1)n).\nClaim 7.3. With probability at least 1\u2212 3/n, the following holds: For every S \u2286 V (G) of size k, if there is an odd cycle in G\u2212 S, then there is an odd cycle present in the subgraph \u22c3 Gi\u2208LS Hi.\nProof. Observe that an undirected graph has an odd cycle if and only if it has an odd-length closed walk and let C1 denote the set of odd-length closed walks in G. Invoking Lemma 7.1 with r = q = 1, we conclude that with probability at least 1\u2212 2/n, if S is a set of size at most k such that there are no odd-length closed walks in the graph \u22c3 Gi\u2208LS Gi, then S hits all odd-length closed walks in G.\nTowards the proof of the claim we next argue that for each i \u2208 [\u2113] and (u, v) \u2208 E(Gi), there is an odd u-v walk in Hi. That is, even if we have ignored the edge (u, v) in the sparsification, we would have at least preserved an odd u-v walk, which we later argue would suffice for our purposes. Indeed, notice that since (u, v) \u2208 E(Gi), it follows that (ua, vb) \u2208 E(Gauxi ). Therefore, it must be the case that ua and vb lie in the same tree in the spanning forest Ti. Call this tree \u0393u,vi and let e1, . . . , er be the edges that comprise the unique ua-vb path in \u0393u,vi and notice that the edges of Gi corresponding to the edges in {e1, . . . , er} are present in Hi by definition. Moreover, notice that r must be odd since ua and vb lie on opposite sides of the bipartite graph Gauxi . Hence, we obtain a u-v walk in Hi containing an odd number of edges as required. Given this, we are ready to complete the proof of the claim.\nWe have already observed that with probability at least 1\u2212 2/n, for any vertex set S of size at most k, if there is an odd cycle in G \u2212 S (and hence an odd-length closed walk), then there is an odd-length closed walk CS = xS1 , . . . , xSrS , x S 1 in \u22c3 Gi\u2208LS Gi. Fix an S such that G\u2212 S contains an odd cycle and let e1, . . . , erS be the edges in the odd-length closed walk CS . We have argued above that for every j \u2208 [rS ] and ej = (xj , xj+1(mod rS)), there is an odd xj-xj+1(mod rS) walk in \u22c3 Gi\u2208LS Hi, implying an odd-length\nclosed walk in \u22c3\nGi\u2208LS Hi as required. This completes the proof of the claim.\nGiven the above claim, we conclude that with probability at least 1 \u2212 3/n, any set S \u2286 V (G) is a solution for the OCT instance (G, k) if and only if S is a solution for the OCT instance (G\u2032, k) where G\u2032 = \u22c3 Gi\u2208L Hi. Therefore, our post-processing algorithm computes the sparsified instance (G\n\u2032, k) with O\u0303(kO(1)n) edges and invokes the O(3kk3(m + n))-time kO(1)(m + n)-space algorithm from [KMRS20] for OCT. This completes the proof of the theorem."
        },
        {
            "heading": "7.2 Subset Feedback Vertex Set",
            "text": "Recall that in the Subset Feedback Vertex Set problem, the input is a graph G, a set T \u2286 V (G) of vertices called terminals and an integer k. The goal is to determine whether there is a set S \u2286 V (G) of size at most k that intersects all cycles in G that contain a vertex of T . We assume the following input model\nfor instances of this problem. For each terminal, when the first edge incident on it is inserted, it is inserted along with a pair of bits that indicate whether (and if so, which of) the endpoints of this edge are terminals.\nTheorem 2.6. There is a 1-pass O\u0303(kO(1) \u00b7 n)-space randomized streaming algorithm for Subset Feedback Vertex Set with O\u0303(2O(k) \u00b7 n)-time post-processing.\nProof. Let G be the input graph. We run Sampling Primitive (V (G), n, k + 1, 2) to generate the vertex sets V1, . . . , V\u2113 \u2286 V (G) and then process the input stream as follows. We use Proposition 4.7 to construct a (k + 1)n-sparse recovery data structure X of size O\u0303(kn) and for each terminal, we insert all edges adjacent to it, into this data structure. We also have a O(log n)-bit counter that counts the number of such edges. Moreover, for each vertex set Vi produced by the sampling primitive, we maintain a dynamic connectivity sketch of Gi = G[Vi] (call this data structure Di) using Proposition 4.8. This completes the processing. Since \u2113 = O\u0303(kO(1)) and X has size O\u0303(kn) the space used by our processing step is O\u0303(kO(1) \u00b7n) as required.\nIn the post-processing step, we first check the counter to determine whether the number of edges incident on terminals exceeds (k + 1)n. If the answer is yes, then we return No. Otherwise, we do the following. We recover all edges incident on T by extracting all elements from X (see Proposition 4.7). Call this set EX . For every i \u2208 [\u2113], we construct a spanning forest of Gi from Di (Proposition 4.8). Choosing c to be large enough and applying the union bound over all {Gi | i \u2208 [\u2113]}, we conclude that with probability at least 1 \u2212 1/n, for every i \u2208 [\u2113], Hi is a spanning forest of Gi. We now run the 25.6k(m + n)-time kO(1)(m + n)-space randomized algorithm from [LRS18]8 for O(log n) repetitions to solve the instance (EX \u222a \u22c3 i\u2208[\u2113] Hi, T, k).\nWe now prove the correctness of our algorithm.\nClaim 7.4. The following statements hold.\n1. If (G, T, k) is a yes-instance, then the number of edges incident to T is at most (k + 1)n.\n2. With probability at least 1 \u2212 3/n, every S \u2286 V (G) is a solution for (G, T, k) if and only if S is a solution for (EX \u222a \u22c3 Gi\u2208L Hi, T, k).\nProof. For the first statement, fix a solution S for (G, T, k) and consider the edges incident on T that do not have a vertex in S as an endpoint. It is sufficient to prove that the number of such edges is at most n. And indeed, this is the case since each edge incident on a terminal must form a biconnected component of G\u2212 S on its own and the number of biconnected components of a graph is bounded by n.\nConsider the second statement. Let G\u2032 be the subgraph of G obtained by taking the subgraph \u22c3\nGi\u2208L Hi and then adding the edges in EX . Since G\u2032 is a subgraph of G, it follows that if S is a solution for (G, T, k), it is also a solution for (G\u2032, T, k).\nWe now consider the converse direction. For every u, v \u2208 V (G), let Cuv denote the set of all u-v paths in G. Consider the set {Cuv | u, v \u2208 V (G)} which has size at most n2. Invoking Lemma 7.1 guarantees that with probability at least 1\u2212 2/n, for every set P \u2286 V (G) of size at most k + 1, and every u, v \u2208 V (G), if there is a u-v path in G \u2212 P then there is a u-v path in G\u2032 \u2212 P . Henceforth, we assume that this event indeed occurs. Now, suppose that S is a solution for (G\u2032, T, k), but is not a solution for (G, T, k). Let t \u2208 T be such that C is a t-cycle in G \u2212 S which is not present in G\u2032 \u2212 S. Recall that every block of G\u2032 \u2212 S that t is contained in, consists of a single edge incident on t. Moreover, since G\u2032 contains every edge in G that is incident on t, it follows that every edge in G that is incident on t but not incident on S is already present in G\u2032 \u2212 S. We now observe that for t to have a flow of 2 to some vertex in G\u2212 S, there must be a\n8This algorithm is in fact a kO(1)(m+n)-time (and so, also a kO(1)(m+n)-space) algorithm with success probability 1/25.6k .\npair of adjacent vertices u, v /\u2208 T that lie on a t-cycle in G\u2212 S, but which have no path between them in G\u2032\u2212S\u2212{t} (i.e., they lie in distinct blocks of G\u2032\u2212S that are separated by t). Consider the set S\u2032 = S\u222a{t} and notice that we have inferred the existence of a u-v path in G\u2212 S\u2032. As already argued using Lemma 7.1, there must be a u-v path in G\u2032 \u2212 S\u2032, a contradiction. This completes the proof of the claim.\nSince the instance (EX \u222a \u22c3 i\u2208[\u2113] Hi, T, k) has n vertices and O\u0303(kO(1)n) edges, the theorem follows."
        },
        {
            "heading": "7.3 Multiway Cut",
            "text": "Recall that in the Multiway Cut problem, the input is a graph G, a set T \u2286 V (G) of vertices called terminals and an integer k. The goal is to determine whether there is a set S \u2286 V (G) of size at most k such that there is no connected component of G \u2212 S containing two terminals. As was the case for Subset Feedback Vertex Set, we assume the following input model for instances of this problem. For each terminal, when the first edge incident on it is inserted, it is inserted along with a pair of bits that indicate whether (and if so, which of) the endpoints of this edge are terminals.\nTheorem 2.7. There is a 1-pass O\u0303(kO(1) \u00b7 n)-space randomized streaming algorithm forMultiway Cut with O\u0303(4kkO(1) \u00b7 n)-time post-processing.\nProof. We run Sampling Primitive (V (G), n, k, 2) to generate the vertex sets V1, . . . , V\u2113 \u2286 V (G) and then process the input stream as follows. For each vertex set Vi produced by the sampling primitive, we maintain a dynamic connectivity sketch of Gi = G[Vi] (call this data structure Di) using Proposition 4.8. This completes the processing. Since \u2113 = O\u0303(kO(1)), the space used by our processing step is O\u0303(kO(1) \u00b7 n) as required.\nIn the post-processing step, for every i \u2208 [\u2113], we construct a spanning forest of Gi from Di (Proposition 4.8). Choosing c to be large enough and applying the union bound over all {Gi | i \u2208 [\u2113]}, we conclude that with probability at least 1 \u2212 1/n, for every i \u2208 [\u2113], Hi is a spanning forest of Gi. We now run the known O(4kkO(1)(m + n))-time kO(1)(m + n)-space fixed-parameter algorithm for Multiway Cut (see, for example, [CFK+15]) on the instance ( \u22c3 i\u2208[\u2113] Hi, T, k) which has n vertices and O\u0303(kO(1)n) edges.\nWe now prove the correctness of our algorithm.\nClaim 7.5. With probability at least 1\u2212 3/n, every S \u2286 V (G) is a solution for (G, T, k) if and only if S is a solution for ( \u22c3 Gi\u2208L Hi, T, k).\nProof. Let G\u2032 = \u22c3\nGi\u2208L Hi. Since G \u2032 is a subgraph of G, it follows that if S is a solution for (G, T, k), it is\nalso a solution for (G\u2032, T, k). We now consider the converse direction. For every u, v \u2208 V (G), let Cuv denote the set of all u-v paths in G. Consider the set {Cuv | u, v \u2208 V (G)} which has size at most n2. Invoking Lemma 7.1 guarantees that with probability at least 1\u2212 2/n, for every set P \u2286 V (G) of size at most k, and every u, v \u2208 V (G), if there is a u-v path in G \u2212 P then there is a u-v path in G\u2032 \u2212 P . Henceforth, we assume that this event occurs. Now, suppose that S is a solution for (G\u2032, T, k), but is not a solution for (G, T, k). Let t1, t2 \u2208 T be such that Q is a t1-t2 path in G \u2212 S. But then, there must be a t1-t2 path in G\u2032 \u2212 S\u2032 also, yielding a contradiction. This completes the proof of the claim.\nSince the instance ( \u22c3\ni\u2208[\u2113] Hi, T, k) has n vertices and O\u0303(kO(1)n) edges, the theorem follows.\nNotice that in contrast to the static setting, the edge deletion variants of the above problems cannot be trivially reduced to the vertex deletion variants by, say, subdividing edges. This is because the number of\nvertices now blows up, plus the two edges that correspond to a single original edge may now appear far apart in time. Hence, one has to treat the edge deletion variants separately. Our focus in this paper is on the vertex deletion variants and we leave the edge deletion variants for future work.\n8 Our Refinement of The SemiPS Class\nWe recall the class SemiPS introduced by Chitnis and Cormode [CC19] and then formally define our new notions related to parameterized semi-streaming algorithms.\nDefinition 8.1 (SemiPS). [CC19]The class SemiPS comprises precisely those parameterized problems that are solvable using O\u0303(f(k) \u00b7 n) bits for some computable function f , allowing unbounded computation at each edge update, and also at the end of the stream, i.e., in post-processing.\nDefinition 8.2 (FPT-Semi-PS and FPSS algorithms). The class FPT-Semi-PS comprises precisely those parameterized graph problems that are solvable using a O\u0303(f(k) \u00b7 n)-space streaming algorithm for some computable function f , allowing f(k)nO(1)-time at each edge update, and also at the end of the stream, i.e., in postprocessing. We call algorithms of this form, fixed-parameter semi-streaming algorithms, or FPSS-algorithms.\nClearly, FPT-Semi-PS is contained in SemiPS, but the converse (restricted to graph problems) is not true as SemiPS contains W-hard problems, whereas FPT-Semi-PS is clearly contained in FPT. We recall that, in this paper all FPSS-algorithms we designed only require O\u0303(kO(1) \u00b7 n)-space and polynomially bounded time at each edge update. Therefore, we in fact have worked within a further refinement of FPT-Semi-PS that is already very rich in the amount and type of graph problems it contains as we have shown.\nWe next refine the class FPT-Semi-PS by introducing the notion of (polynomial) semi-streaming kernelization and also introduce the weaker notion of (polynomial) semi-streaming compression. Recall that Fafianie and Kratsch [FK14] first introduced the notion of streaming kernelization, which, for a parameterized problem P is a polynomial-time kO(1) log n-space streaming algorithm A that, on input (I, k), outputs an instance (I \u2032, k\u2032) of P , where (I, k) is a yes-instance if and only if (I \u2032, k\u2032) is a yes-instance and |I \u2032|, k\u2032 \u2264 f(k) for some polynomially bounded function f . However, for vast numbers of well-studied parameterized graph problems, this definition places insurmountable constraints and so, we introduce an appropriate notion of semi-streaming kernelization. We show through Theorem 8.5 that this definition is robust and consistent with our definition of parameterized semi-streaming algorithms and mimics the relation between (static) kernelization and (static) parameterized algorithms.\nDefinition 8.3 (Semi-streaming Kernelization). Let P be a graph problem parameterized by k \u2208 N. A semistreaming kernelization for P is an O\u0303(kO(1)n)-space streaming algorithmA with polynomially bounded time at each edge update and polynomial post-processing time that, on input (I, k), outputs an instance (I \u2032, k\u2032) of P , where (I, k) is a yes-instance if and only if (I \u2032, k\u2032) is a yes-instance and |I \u2032|, k\u2032 \u2264 f(k) for some computable function f . If f is a polynomial function, then we say that A is a polynomial semi-streaming kernelization.\nDefinition 8.4 (Semi-streaming Compression). Let P be a graph problem parameterized by k \u2208 N and let Q be any language. A semi-streaming compression of P into Q is an O\u0303(kO(1)n)-space streaming algorithm A polynomially bounded time at each edge update and polynomial post-processing time that, on input (I, k), outputs an instance I \u2032 of Q such that (I, k) is a yes-instance of P if and only if I \u2032 is a yes-instance of Q and |I \u2032| \u2264 f(k) for some computable function f . If f is a polynomial function, then we say thatA is a polynomial semi-streaming compression of P into Q. We also simply say that A is a (polynomial) semi-streaming compression for P .\nTheorem 8.5. Let P be a parameterized graph problem. Then, P is in FPT-Semi-PS if and only if it is decidable and has a semi-streaming kernelization.\nProof. Let P be parameterized by k \u2208 N. Suppose that P \u2208 FPT-Semi-PS and let A be a O\u0303(f(k) \u00b7 n)space streaming algorithm for P that uses f(k)nO(1)-time for post-processing and between edge updates. Decidability trivially follows from the existence of A. If f(k) > log n, then, we can simply store the input graph using space bounded by 22f(k) and output it as the required equivalent instance of P . On the other hand, if f(k) < log n, then A itself is a O\u0303(n)-space streaming algorithm with polynomially bounded post-processing time and polynomially bounded time between edge updates. Hence, we can use A to solve the input instance and output an equivalent trivial instance of P . This gives a semi-streaming kernelization for P .\nConversely, suppose that P has a semi-streaming kernelizationA. Then, we runA on the input instance, say (I, k), and use decidability to solve the computed equivalent instance (I \u2032, k\u2032) (whose size is bounded by some f(k)) using additional space bounded by g(k) for some computable g. This is a fixed-parameter semi-streaming algorithm for P as required.\nAs in the case of static kernelization, the primary classification goal in semi-streaming kernelization is to identify problems that have polynomial semi-streaming kernelization and for those that do, to obtain outputs whose size can be bounded by the slowest-growing polynomial function possible. We extend the definitions of semi-streaming kernelization and compression from single passes to multiple passes in the natural way."
        },
        {
            "heading": "9 Lower Bounds",
            "text": "In this section, we show lower bounds implying that (i) there are problems in FPT that are not in FPT-SemiPS, and (ii) our corollary for Theorem 2.1 whenH is the class of split graphs is tight (forH being cluster graphs, a lower bound is already known from [CCE+16]).\nWe use the two party communication model, introduced by Yao [Yao79] to prove lower bounds on streaming algorithms. In this model of communication, there are two players, Alice and Bob, holding inputs x \u2208 X and y \u2208 Y respectively, where X and Y are two arbitrary sets. Their objective is to compute a given function f : X \u00d7 Y \u2192 {0, 1}, by communicating as few bits as possible. It is assumed that both players have infinite computational power. The minimum number of bits communicated, for any pair of inputs (x, y), to compute the function f , is called the (deterministic) communication complexity of f , denoted by D(f). For a randomized protocol P , we say P has error probability at most \u03b5 if Pr(P (x, y) = f(x, y)) \u2265 1\u2212 \u03b5 for all inputs x \u2208 X and y \u2208 Y . Here, the randomness is over the private coin tosses of Alice and Bob. The randomized communication complexity of f , denote by R(f), is the minimum communication cost over all the randomized protocols for f with error probability at most 1/3. In the one-way communication model, only Alice is allowed to send one message to Bob and no other message is allowed to be sent. We use D1\u2212way(f) and R1\u2212way(f) to denote the one way deterministic and randomized communication complexity of f , respectively. Notice that D(f) \u2265 R(f) andD1\u2212way(f) \u2265 R1\u2212way(f).\nLower bounds on D1\u2212way(f) and R1\u2212way(f) can be used for proving lower bounds on deterministic and randomized 1-pass streaming algorithms via standard reductions. That is, given a function f , Alice creates a stream \u03c3x from her input x and Bob creates a stream \u03c3y from his input y. First Alice runs the streaming algorithm on \u03c3x and passes the state of the algorithm to Bob. Then, Bob continues the execution of the streaming algorithm on \u03c3y . Finally, the output of the streaming algorithm is used to solve the problem\nf . This provides space complexity lower bound of the streaming algorithm to be at least D1\u2212way(f) and R1\u2212way(f).\nNext, we describe some well known communication problems and state their communication lower bounds.\nINDEX. The INDEX problem is one of the most commonly used communication problems to prove lower bounds on streaming algorithms. In the INDEX problem, Alice is given an n-length bit string x1 . . . xn \u2208 {0, 1}n and Bob is given an index i \u2208 [n]. Bob wants to find the bit xi.\nProposition 9.1 ([KNR99]). R1\u2212way(INDEX) = \u2126(n).\nGRAPH INDEX. In this problem, Alice is given a bipartite graph G with bipartition V (G) = A \u228e B such |A| = |B| = n. Bob is given a pair (a, b) \u2208 A \u00d7 B and he wants to test whether {a, b} \u2208 E(G) or not. A reduction from INDEX implies that R1\u2212way(GRAPH INDEX) = \u2126(n2) (see Proof of Theorem"
        },
        {
            "heading": "2.1 [CGMV20]).",
            "text": "Chordal Recognition. We prove that any 1-pass streaming algorithm to recognize a chordal graph requires \u2126(n2) space.\nTheorem 9.2. Any 1-pass streaming algorithm to test whether a graph is chordal requires \u2126(n2) space.\nProof. We give a reduction from GRAPH INDEX. In this problem, Alice is given a bipartite graph G with bipartition A \u222a B, where |A| = |B| = n, A = {a1, . . . , an} and B = {b1, . . . , bn}. Bob is given a pair (ai, bj) \u2208 A\u00d7B and he want to test whether (ai, bj) \u2208 E(G). Alice and Bob will construct a graph H such that H is chordal if and only if (ai, bj) \u2208 E(G) as follows. The vertex set of H is A\u222aB \u222a{xi, yi : i \u2208 [n]}. Alice will add all the edges of G to H and make A \u222a {x1, . . . , xn} a clique. Then, Alice will add the set of edges {(xr, yr\u2032) : r \u0338= r\u2032}. Recall that (ai, bj) is the pair Bob has. Bob will add the edges (ai, yi), (yi, bj), and {(bj , xr) : r \u2208 [n]}. This completes the construction of H .\nNext we prove that H is a chordal graph if and only if (ai, bj) \u2208 E(G). From the construction of H , we have that C = ai, yi, bj , xi, ai is a cycle of length 4 and (xi, yi) /\u2208 E(H). Now, if (ai, bj) /\u2208 E(G), then (ai, bj) /\u2208 E(H) and hence C is an induced C4 in H . That is, if (ai, bj) /\u2208 E(G), then H is not a chordal graph. Next, we prove the other direction of the correctness proof. That is, if (ai, bj) \u2208 E(G), then H is a chordal graph. Let e = (yi, bj). First, it is easy to see that H\u2212e is a split graph with A\u2032 = A\u222a{x1, . . . , xn} being a clique and B\u2032 = B \u222a {y1, . . . , yn} being an independent set in H \u2212 e. That is, e is the only edge present in H[B\u2032]. For the sake of contradiction, suppose H is not a chordal graph. Then, by the structure of H , there is an induced C4 in H containing e. Let yi, bj , q, q\u2032 be an induced C4 in H . As H \u2032 is a split graph, we have that q, q\u2032 \u2208 A\u2032. As {(bj , xr) : r \u2208 [n]} \u2286 E(H), q\u2032 \u2208 A\u2032, and yi, bj , q, q\u2032 is an induced C4 in H , we have that q\u2032 \u2208 A. Moreover, by the construction of H , the only one vertex in A which is adjacent to yi is ai. Therefore, q\u2032 = ai. Then, since (ai, bj) = (q\u2032, bj) \u2208 E(H), we got a contradiction that yi, bj , q, q\u2032 is an induced C4 in H .\nSplit Graph Recognition. Here, we prove a streaming lower bound for recognizing split graphs that implies that our corollary for Theorem 2.1 whenH is the class of split graphs, is essentially tight.\nTheorem 9.3. Any 1-pass streaming algorithm to test whether the graph is a split graph requires \u2126(n) space.\nProof sketch. We give a reduction from the INDEX problem. In this problem Alice has a bit string x1 . . . xn and Bob has an index i \u2208 [n]. Bob wants to know that whether xi = 1 or not. Alice and Bob will construct a graph G as follows. The vertex set of G is {y1, . . . , yn} \u222a {z1, . . . , zn}. For each 1 \u2264 j < j\u2032 \u2264 n such that xi = xj = 1 Alice will add an edge (yj , yj\u2032). Recall that Bob has an index i. He will add edges between xi and {z1, . . . , zn}. Notice that if xi = 1, then G graph is a split graph. Otherwise G is not a split graph. Thus, by Proposition 9.1, the theorem follows.\nA similar lower bound for Custer Vertex Deletion is already known from [CCE+16]."
        },
        {
            "heading": "10 Concluding Remarks and Discussion",
            "text": "In this paper, we have given a framework to design semi-streaming algorithms for NP-hard cut problems and proved two meta theorems that reduce the task of solving, for any graph classH, the corresponding Vertex Deletion toH problem, to just the recognition problem (i.e. solving it for just for k = 0) when: (i)H is characterized by a finite set of forbidden induced subgraphs, or (ii)H is hereditary, where additionally \u201creconstruction\u201d rather than just recognition is required. The second case encompasses graph classes that are characterized by a possibly infinite set of obstructions. We have exemplified the usage of our theorems with several applications to well-studied graph problems, and we believe that these will serve as building blocks for many more applications in the future. We remark that the running times in many of our results are also optimal under ETH.\nA point to note here is that considering Vertex Deletion toH whereH is defined by excluding a set of forbidden graphs as minors or topological minors is not very interesting in our setting. In particular, if H is defined by excluding a finite set of forbidden graphs as minors or topological minors (e.g.,H is the class of planar graphs), then the number of edges in any G \u2208 H is upper bounded by O(n). Thus, given an instance (G, k) of Vertex Deletion toH one can check whether the number of edges in G is O(kn). If the answer is no, then we have a no-instance. Otherwise, we can simply store the entire graph. This means that Vertex Deletion toH for suchH trivially belongs to the class SemiPS [CC19]. Further, we know that for all suchH, Vertex Deletion toH is in FPT (see, for example, [CFK+15]), which implies that in fact, whether or not Vertex Deletion toH belongs to the class FPT-Semi-PS (which is contained in SemiPS) simply depends on whether there is a static linear-space FPT algorithm for the problem that can be used in post-processing. While this is an interesting research direction in itself, it presents different challenges to those we encounter when the goal is to sketch the input graph stream. On the other hand, suppose thatH is defined by excluding an infinite number of forbidden graphs as minors. It is well-known from the Graph Minors project that if a graph class is characterized by an infinite set of forbidden minors, then it is also characterized by a finite set of forbidden minors, as a result of which we fall back into the previous case. Finally, to the best of our knowledge, there are no natural graph classes characterized by an infinite set of forbidden topological minors.\nLet us conclude the paper with a few open questions and further research directions.\n\u2022 A central tool in Parameterized Complexity is the usage of graph decompositions. Which among them is relevant to parameterized problems in the semi-streaming model? Also, which of the widthparameters corresponding to them is relevant? With respect to tree decompositions, once a graph has bounded treewidth w, its number of edges is already O(nw), which means that it can just be stored explicitly. More interestingly, we believe that the \u201cunbreakability decompositions\u201d (which generalize tree decompositions) given in [CLP+19, CKL+21] can be computed in O\u0303(kO(1)n) space. If this is achieved, then the classic Minimum Bisection problem (see Appendix for the formal definition) can\nbe dealt in the same manner as we deal with other cut problems in this paper, yielding a parameterized algorithm for it in the semi-streaming model. We leave this as an interesting question.\n\u2022 One of the main inspirations behind Parameterized Complexity is the graph minors project of Robertson and Seymour [Dow12, LSZ20]. Here, the central algorithms are for Minor Containment and Disjoint Paths, also on specific graph classes. Could one develop a theory for algorithmic graph minors in the semi-streaming model?\n\u2022 Our work naturally motivates revisiting and improving classic algorithmic methods in Parameterized Complexity where space exceeds O\u0303(kO(1)n). For example, consider the celebrated matroid-based technique to design polynomial kernels by Kratsch and Wahlstro\u0308m [KW20, KW14]\u2014can it be implemented in O\u0303(kO(1)n) space? If the answer is positive, then, for example, composed with our sketch for Odd Cycle Transversal, we may derive a semi-streaming kernelization for this problem. Here, and in many other foundational techniques, completely new ideas may be required. As we mentioned above, in light of semi-streaming in particular, and big data in general, increasing importance must be given to space complexity.\n\u2022 In recent years, parameterized approximation algorithms and lossy kernelization have become a very active subject of research (see, e.g., [Mar08, FKLM20, CCK+20b, LPRS17, KS20, KLM19, LMR+21, LSS20]). Indeed, we do not have to choose between parameterized analysis and approximation, but combine them and \u201cenjoy the best of both worlds\u201d\u2014for example, we can develop a (1 + \u03f5)approximation algorithm that runs in 2O(k) \u00b7 nO(1) time for some problems that are both APX-hard and W[1]-hard. Naturally, we can use approximation also in the context of parameterized algorithms in the semi-streaming model. Then, we may use the same definition, but seek an approximate rather than exact solution.\n\u2022 Lastly, we would like to remark that the study of parameterized (graph) problems in the semistreaming model can also be of significant interest when the input graph is restricted to belong to a certain graph class. Here, of course, it only makes sense to consider dense classes of graphs. For example, most geometric intersection graphs classes are dense (containing cliques of any size), and, recently, they are being extensively studied from the viewpoint of Parameterized Complexity (see, e.g., [GKW08, FLP+20, dBBK+18, PSZ19, FLP+19]). So, they may be natural candidates in this regard. In particular, recognizing the family of interval graphs in the semi-streaming model is an interesting open question."
        },
        {
            "heading": "A Problem Definitions",
            "text": "Feedback Vertex Set on Tournaments Parameter: k Input: A tournament T and integer k. Question: Is there a set S \u2286 V (G) of size at most k such that T \u2212 S is acyclic.\nSplit Vertex Deletion Parameter: k Input: A graph G and integer k. Question: Is there a set S \u2286 V (G) of size at most k such that G\u2212 S is a split graph, i.e., the vertex set can be partitioned into two \u2013 one inducing a complete graph and the other, an independent set.\nThreshold Vertex Deletion Parameter: k Input: A graph G and integer k. Question: Is there a set S \u2286 V (G) of size at most k such that G\u2212 S is a threshold graph, i.e., a split graph that also excludes the induced path on 4 vertices.\nCluster Vertex Deletion Parameter: k Input: A graph G and integer k. Question: Is there a set S \u2286 V (G) of size at most k such that G\u2212 S is a cluster graph, i.e., every connected component is a complete graph.\nMinimum Bisection Parameter: k Input: A graph G and an integer k. Question: Does there exists a partition (A, B) of V (G) such that ||A| \u2212 |B|| \u2264 1 and E(A, B) \u2264 k?"
        }
    ],
    "title": "Meta-theorems for Parameterized Streaming Algorithms",
    "year": 2023
}