{
    "abstractText": "The generic homomorphism problem, which asks whether an input graph G admits a homomorphism into a fixed target graph H, has been widely studied in the literature. In this article, we provide a fine-grained complexity classification of the running time of the homomorphism problem with respect to the clique-width of G (denoted cw) for virtually all choices of H under the Strong Exponential Time Hypothesis. In particular, we identify a property of H called the signature number s(H) and show that for each H, the homomorphism problem can be solved in time O\u2217(s(H)cw). Crucially, we then show that this algorithm can be used to obtain essentially tight upper bounds. Specifically, we provide a reduction that yields matching lower bounds for each H that is either a projective core or a graph admitting a factorization with additional properties\u2014allowing us to cover all possible target graphs under long-standing conjectures. 2012 ACM Subject Classification Theory of computation \u2192 Parameterized complexity and exact algorithms",
    "authors": [
        {
            "affiliations": [],
            "name": "Robert Ganian"
        },
        {
            "affiliations": [],
            "name": "Thekla Hamm"
        },
        {
            "affiliations": [],
            "name": "Viktoriia Korchemna"
        },
        {
            "affiliations": [],
            "name": "Karolina Okrasa"
        },
        {
            "affiliations": [],
            "name": "Kirill Simonov"
        }
    ],
    "id": "SP:1009d65a61f686b24a28df7d515fd9d19d6625cd",
    "references": [
        {
            "authors": [
                "R\u00e9my Belmonte",
                "Eun Jung Kim",
                "Michael Lampis",
                "Valia Mitsou",
                "Yota Otachi"
            ],
            "title": "Grundy distinguishes treewidth from pathwidth",
            "venue": "Annual European Symposium on Algorithms, ESA 2020,",
            "year": 2020
        },
        {
            "authors": [
                "Jan B\u00f6ker"
            ],
            "title": "Graph similarity and homomorphism densities",
            "venue": "48th International Colloquium on Automata, Languages, and Programming,",
            "year": 2021
        },
        {
            "authors": [
                "Andrei A. Bulatov",
                "Amineh Dadsetan"
            ],
            "title": "Counting homomorphisms in plain exponential time",
            "venue": "47th International Colloquium on Automata, Languages, and Programming,",
            "year": 2020
        },
        {
            "authors": [
                "Bruno Courcelle",
                "Johann A. Makowsky",
                "Udi Rotics"
            ],
            "title": "Linear time solvable optimization problems on graphs of bounded clique-width",
            "venue": "Theory Comput. Syst.,",
            "year": 2000
        },
        {
            "authors": [
                "Bruno Courcelle",
                "Stephan Olariu"
            ],
            "title": "Upper bounds to the clique width of graphs",
            "venue": "Discrete Applied Mathematics,",
            "year": 2000
        },
        {
            "authors": [
                "Marek Cygan",
                "Fedor V. Fomin",
                "Alexander Golovnev",
                "Alexander S. Kulikov",
                "Ivan Mihajlin",
                "Jakub Pachocki",
                "Arkadiusz Soca\u0142a"
            ],
            "title": "Tight lower bounds on graph embedding problems",
            "venue": "J. ACM,",
            "year": 2017
        },
        {
            "authors": [
                "Reinhard Diestel"
            ],
            "title": "Graph Theory, 4th Edition, volume 173 of Graduate texts in mathematics",
            "year": 2012
        },
        {
            "authors": [
                "L\u00e1szl\u00f3 Egri",
                "D\u00e1niel Marx",
                "Pawe\u0142"
            ],
            "title": "Rz\u0105\u017cewski. Finding list homomorphisms from boundedtreewidth graphs to reflexive graphs: a complete complexity characterization",
            "venue": "In 35th Symposium on Theoretical Aspects of Computer Science,",
            "year": 2018
        },
        {
            "authors": [
                "Tom\u00e1s Feder",
                "Pavol Hell",
                "Jing Huang"
            ],
            "title": "Bi-arc graphs and the complexity of list homomorphisms",
            "venue": "J. Graph Theory,",
            "year": 2003
        },
        {
            "authors": [
                "Tom\u00e1s Feder",
                "Moshe Y. Vardi"
            ],
            "title": "The computational structure of monotone monadic SNP and constraint satisfaction: A study through datalog and group theory",
            "venue": "SIAM J. Comput.,",
            "year": 1998
        },
        {
            "authors": [
                "Fedor V. Fomin",
                "Pinar Heggernes",
                "Dieter Kratsch"
            ],
            "title": "Exact algorithms for graph homomorphisms",
            "venue": "Theory Comput. Syst.,",
            "year": 2007
        },
        {
            "authors": [
                "Martin Grohe"
            ],
            "title": "The complexity of homomorphism and constraint satisfaction problems seen from the other side",
            "venue": "J. ACM,",
            "year": 2007
        },
        {
            "authors": [
                "Pavol Hell",
                "Jaroslav Ne\u0161et\u0159il"
            ],
            "title": "On the complexity of H-coloring",
            "venue": "J. Comb. Theory, Ser. B,",
            "year": 1990
        },
        {
            "authors": [
                "Sang il Oum",
                "Paul Seymour"
            ],
            "title": "Approximating clique-width and branch-width",
            "venue": "Journal of Combinatorial Theory, Series B,",
            "year": 2006
        },
        {
            "authors": [
                "Russell Impagliazzo",
                "Ramamohan Paturi"
            ],
            "title": "On the complexity of k-sat",
            "venue": "J. Comput. Syst. Sci.,",
            "year": 2001
        },
        {
            "authors": [
                "Russell Impagliazzo",
                "Ramamohan Paturi",
                "Francis Zane"
            ],
            "title": "Which problems have strongly exponential complexity",
            "venue": "J. Comput. Syst. Sci.,",
            "year": 2001
        },
        {
            "authors": [
                "Michael Lampis"
            ],
            "title": "Finer tight bounds for coloring on clique-width",
            "venue": "SIAM J. Discret. Math.,",
            "year": 2020
        },
        {
            "authors": [
                "Beno\u00eet Larose"
            ],
            "title": "Families of strongly projective graphs",
            "venue": "Discuss. Math. Graph Theory,",
            "year": 2002
        },
        {
            "authors": [
                "Beno\u00eet Larose",
                "Claude Tardif"
            ],
            "title": "Strongly rigid graphs and projectivity",
            "venue": "Multiple-Valued Logic,",
            "year": 2001
        },
        {
            "authors": [
                "Daniel Lokshtanov",
                "D\u00e1niel Marx",
                "Saket Saurabh"
            ],
            "title": "Lower bounds based on the exponential time hypothesis",
            "venue": "Bull. EATCS,",
            "year": 2011
        },
        {
            "authors": [
                "Karolina Okrasa",
                "Marta Piecyk",
                "Pawe\u0142"
            ],
            "title": "Rz\u0105\u017cewski. Full complexity classification of the list homomorphism problem for bounded-treewidth graphs",
            "venue": "Annual European Symposium on Algorithms, ESA 2020,",
            "year": 2020
        },
        {
            "authors": [
                "Karolina Okrasa",
                "Pawe\u0142"
            ],
            "title": "Rz\u0105\u017cewski. Fine-grained complexity of the graph homomorphism problem for bounded-treewidth graphs",
            "venue": "SIAM J. Comput.,",
            "year": 2021
        },
        {
            "authors": [
                "Sang-il Oum"
            ],
            "title": "Approximating rank-width and clique-width quickly",
            "venue": "Graph-Theoretic Concepts in Computer Science,",
            "year": 2005
        },
        {
            "authors": [
                "Marta Piecyk",
                "Pawe\u0142"
            ],
            "title": "Rz\u0105\u017cewski. Fine-grained complexity of the list homomorphism problem: Feedback vertex set and cutwidth",
            "venue": "38th International Symposium on Theoretical Aspects of Computer Science,",
            "year": 2021
        },
        {
            "authors": [
                "Neil Robertson",
                "Paul D. Seymour"
            ],
            "title": "Graph minors. II. algorithmic aspects of tree-width",
            "venue": "J. Algorithms,",
            "year": 1986
        },
        {
            "authors": [
                "Pawe\u0142 Rz\u0105\u017cewski"
            ],
            "title": "Exact algorithm for graph homomorphism and locally injective graph homomorphism",
            "venue": "Inf. Process. Lett.,",
            "year": 2014
        },
        {
            "authors": [
                "Magnus Wahlstr\u00f6m"
            ],
            "title": "New plain-exponential time classes for graph homomorphism",
            "venue": "Theory Comput. Syst.,",
            "year": 2011
        }
    ],
    "sections": [
        {
            "text": "2012 ACM Subject Classification Theory of computation \u2192 Parameterized complexity and exact algorithms\nKeywords and phrases homomorphism, clique-width, fine-grained complexity\nFunding Robert Ganian: Robert Ganian acknowledges support by the Austrian Science Fund (FWF, projects Y1329 and P31336). Thekla Hamm: Thekla Hamm acknowledges support by the Austrian Science Fund (FWF, projects"
        },
        {
            "heading": "P31336 and Y1329).",
            "text": "Viktoriia Korchemna: Viktoriia Korchemna acknowledges support by the Austrian Science Fund (FWF, project Y1329). Karolina Okrasa: Karolina Okrasa acknowledges support by the European Research Council, grant agreement No 714704. Parts of this work were performed while visiting TU Wien, Vienna, Austria. Kirill Simonov: Kirill Simonov acknowledges support by the Austrian Science Fund (FWF, project P31336).\n1 Introduction\nA homomorphism from a graph G to a graph H is an edge-preserving mapping from the vertices of G to the vertices of H. Homomorphisms are fundamental constructs which have been studied from a wide variety of perspectives [2, 3, 13]. Our focus here will be on the class of problems which ask whether an input n-vertex graph G admits a homomorphism to a fixed target graph H. This \u201cmeta-problem\u201d\u2014which we simply call Hom(H)\u2014captures, among others, the classical c-Coloring problems when H is set to the complete graph on c\nar X\niv :2\n21 0.\n06 84\n5v 1\n[ cs\n.C C\n] 1\n3 O\nct 2\n02 2\nvertices. Famously, Hell and Ne\u0161et\u0159il [15] proved that Hom(H) is polynomial-time solvable if H is bipartite or has a loop, and NP-complete otherwise. While the aforementioned result provides a basic classification of the complexity of Hom(H), it does not say much in terms of how quickly one can actually solve these problems. Indeed, the usual assumption that P 6= NP is not sufficient to obtain tight bounds for the running times of algorithms. While upper bounds can be straightforwardly obtained by designing a suitable algorithm, the corresponding lower bounds usually rely on the Exponential Time Hypothesis (ETH) or the Strong Exponential Time Hypothesis (SETH), which allows for even tighter bounds [18,19,23]. It is not difficult to design a brute-force algorithm for the homomorphism problem that runs in time O\u2217(|V (H)|n) for every choice of H, and thanks to the breakthrough result of Cygan et al. we now know that this running time is essentially tight under the Exponential Time Hypothesis (ETH) [6] as long as one considers only the dependency on n and |V (H)|. Still, it is often possible to circumvent this lower bound and obtain significantly better runtime guarantees. One approach to do so is to consider restrictions on the class of targets: if H is a complete graph then Hom(H) can be solved in time O\u2217(2n), and there are also several algorithms that achieve running times of the form O\u2217(\u03b1(H)n) where \u03b1(H) is some structural parameter of H [12, 29, 30]. The other is to exploit the properties of the input graph G, which are commonly captured by a suitably defined structural parameter. The most commonly used graph parameter in this respect is treewidth [28], which informally measures how \u201ctree-like\u201d a graph is. When considering treewidth, it is once again not difficult to obtain an algorithm that runs in time O\u2217(|V (H)|tw), where tw is the treewidth of G; as before, it was much more difficult to show that this is essentially optimal. The first SETH-based tight lower bound in this setting was actually shown for special cases of the related problem of LHom(H), where each vertex in the graph G comes with a list of admissible targets for the homomorphism [9]; this was later lifted to a full classification [24]. A nearly-complete SETH-based lower bound result for Hom(H) itself was only obtained recently by Okrasa and Rz\u0105\u017cewski [25]; in particular, the result covers all targets which are so-called projective cores. It is known that almost all graphs are projective cores [16, 25, 31], and it is worth noting that the authors showed that their result can be lifted to all targets under long-standing conjectures on the properties of projective cores [21,22]. While treewidth is the most prominent structural graph parameter, it is not the most general1 one that can be used to efficiently solve Hom(H). Indeed, standard dynamic programming techniques can be used to obtain a O\u2217((2|V (H)|)cw) time algorithm for the problem, where cw stands for clique-width [4]: a well-studied graph parameter that is bounded not only on all graph classes of bounded treewidth, but also on well-structured dense classes such as complete graphs. But is this basic algorithm generally optimal (mirroring the situation for treewidth [25]), or can one obtain better runtime dependencies on clique-width? Contribution. Our aim is to obtain a detailed understanding of the fine-grained complexity of Hom(H) in terms of the clique-width of G and the fixed target H. As a starting point for our investigation, we note that Lampis used the SETH to obtain tight bounds for c-Coloring with respect to clique-width [20]. Interestingly, already for this special case, the upper and lower bounds differ from those of the aforementioned simple dynamic programming algorithm: if H is a complete graph, then Hom(H) can be solved in time O\u2217((2|V (H)| \u2212 2)cw) [20] and this is tight under the SETH. However, as noted by Piecyk and Rz\u0105\u017cewski [27], it was not at all obvious how these bounds can be lifted to general choices of H. In order to achieve our"
        },
        {
            "heading": "1 There is a hierarchy of graph parameters (see, e.g., [1, Figure 1]), where parameter A is more general",
            "text": "than parameter B if there are graph classes of bounded A and unbounded B but the opposite is not true.\ngoals we need to improve upon the basic dynamic programming idea to identify a \u201chopefully correct\u201d base of the exponent for every choice of H. Towards our first result, we identify a structural property of H called the signature number (denoted s(H)) which, intuitively, captures the number of non-trivial neighborhood classes of vertex subsets in H (the signature set). We then obtain a non-trivial dynamic programming algorithm that solves Hom(H) in time where the base of the exponent is precisely the signature number. We note that s(H) is 2|V (H)| \u2212 2 for complete graphs H, and so this result also provides a succinct and broader explanation for the running time of Lampis\u2019 algorithm [20].\nI Theorem 1. Let H be a fixed graph. Hom(H) can be solved in time O\u2217(s(H)cw(G)) for each input graph G, assuming an optimal clique-width expression of G is provided as part of the input.\nWith this upper bound, we proceed to the main technical contribution of this paper: establishing a corresponding lower bound under the SETH. The main difficulty here is that we need a reduction that is delicate on one hand, since it needs to preserve the clique-width, but is on the other hand also flexible enough to work for many different choices of H; moreover, the reduction has to rely on the signature numbers of these graphs in some way. To provide an intuitive description of the reduction, let us focus for now on the case where H is a projective core. On a high level, the main building block is an S-gadget which, given an arbitrary set S of pairs of vertices in H and two vertices p and q of the input graph G, ensures that every homomorphism f satisfies (f(p), f(q)) \u2208 S. After providing a generic construction for such S-gadgets which is clique-width preserving and works for every valid choice of H, we use these to obtain implication gadgets and or gadgets which restrict how a solution homomorphism can behave on a selected set of vertices in G. The formalization of these gadgets is the main technical hurdle towards the desired result; once that is done, we can lift the idea used in the earlier reduction of Lampis [20] that established clique-width lower bounds for c-Coloring by reducing from Constraint Satisfaction (CSP) to Hom(H). One crucial distinction in our reduction is that we use elements of the signature set (as opposed to color sets) to represent domain values in the CSP instance. To lift these considerations to cases where H is not a projective core, we unfortunately need to add an extra layer of complexity. Similarly as in the previous treewidth-based lower bound for Hom(H) [25], one can base this step on conjectures of Larose and Tardif [21, 22] that classify all remaining targets as certain graph products with special properties (notably, all of the factors must be \u201ctruly projective\u201d). The approach used for treewidth [25] was then to essentially repeat all steps of the proof for projective cores, with the added difficulty that one uses the properties of products instead of dealing directly with projective cores. While this approach could be used here as well, instead we unify the two cases (H being a projective core, and H being a product) by defining the notion of W -projectivity for some factor W of H. In particular, if H is a projective core then it itself is H-projective, while if H is a product with truly projective factor Hi then it is Hi-projective. As our main result, we obtain an SETH-based lower bound which essentially shows that for each W -projective graph H, s(W ) is the optimal base of the clique-width exponent for solving Hom(H):\nI Theorem 2. If H is Hi-projective for some i \u2208 [m] then there is no algorithm solving Hom(H) in time O\u2217((s(Hi)\u2212 \u03b5)cw(G)) for any \u03b5 > 0, unless the SETH fails.\nBy also deliberately considering prime factorizations in the algorithm which we provide for Theorem 1, we can obtain an upper bound on the complexity of Hom(H) that matches the lower bound from Theorem 2. For a discussion explicitly relating these complexity bounds in the context of the aforementioned conjectures of Larose and Tardif, we refer to Section 6.\n2 Preliminaries\nWe use standard terminology for graph theory [7]. Let [i] denote the set {1, . . . , i}. For a mapping f : A\u2192 B and A\u2032 \u2286 A, let f |A\u2032 denote the restriction of f to A\u2032. We will use the O\u2217(\u00b7) notation to suppress factors polynomial in the input size."
        },
        {
            "heading": "Homomorphisms and Cores",
            "text": "For two graphs G and H, a homomorphism from G to H is a mapping h : V (G)\u2192 V (H), such that for every uv \u2208 E(G) we have h(u)h(v) \u2208 E(H). If there exists a homomorphism from G to H, we denote this fact by G \u2192 H, and if h is a homomorphism from G to H, we denote that by h : G \u2192 H. If there is no homomorphism from G to H, we write G 6\u2192 H. If G \u2192 H and H \u2192 G, we say that G and H are homomorphically equivalent. In particular, since the composition of homomorphisms is a homomorphism, if G and H are homomorphically equivalent, then for every graph F we have that F \u2192 G if and only if F \u2192 H. It is straightforward to verify that homomorphic equivalence is an equivalence relation on the class of all graphs. On the other hand, if G 6\u2192 H and H 6\u2192 G for some graphs G,H, we say that G and H are incomparable.\nWe note that if H is a clique on c vertices, then homomorphisms form G to H are precisely proper vertex c-colorings of G.\nWe say that a graph H is a core if every homomorphism h : H \u2192 H is an automorphism. Equivalently, H is a core if for every proper induced subgraph H \u2032 of H it holds that H 6\u2192 H \u2032. We say that a core H \u2032 is a core of H if H \u2032 is an induced subgraph of H and H \u2192 H \u2032. Clearly, each core graph is a core of itself. Each graph has a unique (up to isomorphism) core, and the core of H can be equivalently defined as the smallest (with respect to the number of vertices) graph that is homomorphically equivalent with H [16].\nA graph H is ramified if N(u) 6\u2286 N(v) for every two distinct vertices u, v of H. Observe that each core is ramified; otherwise one could define f : H \u2192 H that is an identity on all vertices of H but u and set f(u) = v. This would be a homomorphism to a proper subgraph of H, contradicting the fact that H is a core.\nWe say that a graph H is trivial if its core has at most two vertices.\nI Observation 3 ([15]). A graph H is trivial if and only if it is either bipartite or contains a vertex with a loop.\nProof. It is straightforward to observe that there exist three trivial cores: K1, K2, and K\u22171 , where by K\u22171 we denote the graph that consists of one vertex with a loop.\nIf H contains a vertex a with a loop, then K\u22171 is the core of H, as mapping every vertex of H to v yields a homomorphism. If H is bipartite, then the core of H is either K1 (if H has no edges) or K2 (since mapping the vertices of one bipartition class to one vertex of K2, and another bipartition class to the other, is a homomorphism).\nFor the other direction, assume that H is a non-bipartite loopless graph. Since it is loopless, K\u22171 cannot be its core. Clearly, H has at least one edge, and therefore H 6\u2192 K1 Moreover, H contains an odd cycle C2k+1 as a subgraph, hence, C2k+1 \u2192 H. If now H \u2192 K2, composition of these homomorphism gives that C2k+1 \u2192 K2, which is equivalent to stating that C2k+1 is 2-colorable, a contradiction. J\nObserve that trivial cores H correspond precisely to the polynomial cases of the Hom(H) problem. Since our aim is to focus on the NP-hard cases of the problem, from here onward we will assume that the target graph is non-trivial."
        },
        {
            "heading": "Signature Sets",
            "text": "For a vertex v of a graph H, let NH(v) denote the set of neighbors of v in H. If the graph is clear from the context, we will omit the subscript H and write N(v). For a non-empty set T \u2286 V (H) we say that S(T ) is the signature set of T if S(T ) =\u22c2 t\u2208T N(t). We say that a non-empty set S \u2286 V (H) is a signature set, if there exists T such that S = S(T ). We denote by S(H) the set of all signature sets of H, and we note that {V (H), \u2205} \u2229 S(H) = \u2205.\nI Observation 4. If T is a proper non-empty subset of V (H), and a \u2208 T , b \u2208 S(T ), then ab \u2208 E(H). Moreover, for non-empty subsets A,B \u2286 V (H), S(A \u222aB) = S(A) \u2229 S(B).\nWe note that the operation of taking a signature set is reversible on S(H):\nI Observation 5. For every A \u2208 S(H), S(S(A)) = A.\nProof. By the definition of signature set, A \u00d7 S(A) \u2286 E(H), so A \u2286 S(S(A)). For the converse direction observe that as A \u2208 S(H), there exists a non-empty subset T of V (H) such that A = S(T ). Pick any x \u2208 S(S(A)), then E(H) \u2287 {x}\u00d7S(A) = {x}\u00d7S(S(T )) \u2287 {x}\u00d7T . Hence by definition x \u2208 S(T ) = A. J\nLet the signature number of H, denoted s(H), be defined as |S(H)|. As mentioned in the introduction, the signature number will play a crucial role in our upper and lower bounds.\nObserve that, if H is a target and hence non-trivial, for every nonempty T \u2286 V (H) we have that S(T )\u2229T = \u2205. From that it is easy to see that V (H) never belongs to S(H). Since, by definition, \u2205 /\u2208 S(H), we get the following bounds for s(H).\nI Observation 6. Let H be a graph with no loops. Then s(H) 6 2|V (H)| \u2212 2.\nNotice that since 2|V (H)| \u2212 2 is the number of all proper non-empty subsets of V (H), the equality in Observation 6 holds if and only if H is a clique.\nIf S \u2208 S(H), we call T such that S(T ) = S a witness of S. Clearly, we can have distinct T1, T2 such that S(T1) = S(T2), however, notice that in such a case there exists T = T1 \u222a T2 such that S(T ) = S(T1) = S(T2). Hence, there exists a unique maximal (with respect to inclusion) witness of S, and we denote it by M(S). In fact, it is not difficult to see that M(S) = {v \u2208 V (H) | S \u2286 NH(v)}; for S(M(S)) = S to hold, it is clearly necessary that S \u2286 NH(v) for all v \u2208M(S). On the other hand, as M(S) is maximal all v for which this is true are contained in M(S).\nIn this way signature sets and their witnesses are in one-to-one correspondence. While not necessary to obtain our algorithmic and lower bounds for Hom(H) parameterized by clique-width, this offers an alternative perspective on the role of signatures in our results.\nIn fact, the signature number could equivalently be defined as the \u2018maximal witness number\u2019 and signature sets could be replaced by maximal witnesses in all our proofs:\nI Observation 7. LetM(H) = {M(S) : S \u2208 S(H)}, then S(H) =M(H).\nProof. Let T be a fixed non-empty subset of V (H) such that S(T ) 6= \u2205. Observe that the definition and the maximality of M(S(T )) implies that S(S(T )) = \u22c2 t\u2208S(T ) N(t) = M(S(T )). Since T and S(T ) are non-empty, we get that S(H) \u2287 M(H). For the other direction observe that M(M(S(T ))) = S(T ). Assume the contrary, then there exists a vertex v /\u2208 S(T ) such that N(v) \u2283 M(S(T )). However, T \u2286 M(S(T )) \u2286 N(v) meaning that v \u2208 S(T ), a contradiction. Thus, S(H) =M(H). J\nWe note that if H is a core graph, we can also bound the minimum cardinality of S(H).\nI Observation 8. Let H be a core graph, H 6= K1. Then s(H) > |V (H)|.\nProof. Observe that if H is a core distinct from K1, then it does not contain isolated vertices. Therefore, for each v \u2208 V (H) we have N(v) \u2208 S(H). On the other hand, since H is a core, it is ramified. In particular, for every distinct v, w \u2208 V (H) we have N(v) 6= N(w). Hence different vertices give rise to different signature sets. J"
        },
        {
            "heading": "Clique-Width and Clique-Width Expressions",
            "text": "For a positive integer k, we let a k-graph be a graph whose vertices are labeled by [k]. For convenience, we consider a graph to be a k-graph with all vertices labeled by 1. We call the k-graph consisting of exactly one vertex v (say, labeled by i) an initial k-graph and denote it by i(v).\nThe clique-width of a graph G is the smallest integer k such that G can be constructed from initial k-graphs by means of iterative application of the following three operations: 1. Disjoint union (denoted by \u2295); 2. Relabeling: changing all labels i to j (denoted by \u03c1i\u2192j); 3. Edge insertion: adding an edge from each vertex labeled by i to each vertex labeled by j\n(i 6= j; denoted by \u03b7i,j). A construction of a k-graph G using the above operations can be represented by an algebraic term composed of \u2295, pi\u2192j and \u03b7i,j (where i 6= j and i, j \u2208 [k]). Such a term is called a k-expression defining G, and we often view it as a tree with each node labeled with the appropriate operation. Conversely, we call the k-graph that arises from a k-expression its evaluation. The clique-width of G is the smallest integer k such that G can be defined by a k-expression which we then also call a clique-width expression of G.\nMany graph classes are known to have constant clique-width; examples include all graph classes of constant treewidth and co-graphs [5]. Moreover a fixed-parameter algorithm is known to compute a k-expression of the input where k is bounded in f(cw) [26].\n3 Algorithm\nAs our first contribution, we obtain an algorithm that will play a crucial role for upperbounding the fine-grained complexity of Hom(H).\nI Theorem 1. Let H be a fixed graph. Hom(H) can be solved in time O\u2217(s(H)cw(G)) for each input graph G, assuming an optimal clique-width expression of G is provided as part of the input.\nProof. Assume, w.l.o.g., that G is connected and |V (G)| > 1. We will describe a dynamic program that proceeds in a leaf-to-root fashion along the provided k-expression \u03c3 of G. For a subexpression \u03c4 \u2286 \u03c3, we denote the evaluation of \u03c4 by G\u03c4 , and by V i\u03c4 \u2286 V (G\u03c4 ) the vertex set that has label i in G\u03c4 . We say that i is a live label in \u03c4 if there is an edge of G which is incident to V i\u03c4 and does not appear in G\u03c4 . Denote the set of live labels in \u03c4 by L\u03c4 . Since G is connected, L\u03c4 6= \u2205 for any proper subexpression \u03c4 of \u03c3.\nFor each subexpression \u03c4 of \u03c3, we will compute a set P\u03c4 consisting of functions p : L\u03c4 \u2192 S(H) where p \u2208 P\u03c4 if and only if there exists a homomorphism hp from G\u03c4 to H such that p(i) \u2286 S(hp(V i\u03c4 )), i \u2208 L\u03c4 . We will say that p \u2208 P\u03c4 describes the homomorphism hp in \u03c4 or, equivalently, that hp witnesses p in \u03c4 . Intuitively, we will use p(i) to preemptively store the images of the neighbors of V i\u03c4 in the final graph G\u2014that is why we store not only the exact\nsignature, but all signatures that occur as subsets. We remark that storing the \u201ccurrent\u201d images of the neighbors of V i\u03c4 in G\u03c4 would be sufficient to obtain a conceptually simpler fixed-parameter algorithm parameterized by clique-width, but in that case it is not obvious how one can avoid a quadratic dependency on clique-width in the exponent.\nObserve that for any homomorhism h : G\u03c4 \u2192 H, images of vertices with live labels should be connected in H with images of their future neighbors. In particular, for any i \u2208 L\u03c4 , S(h(V i\u03c4 )) 6= \u2205 and hence S(h(V i\u03c4 )) \u2208 S(H). Therefore h is described in \u03c4 by some p \u2208 P\u03c4 . By definition, L\u03c3 = \u2205 and hence G is homomorphic to H if and only if P\u03c3 contains the empty mapping, i.e., if P\u03c3 = {\u2205} (as opposed to P\u03c3 = \u2205). It remains to show how to correctly compute each P\u03c4 . To do so, we distinguish based on the outermost operation of \u03c4 :\n\u03c4 = i(v) for some i \u2208 [cw(G)].\nIn this case L\u03c4 = {i}, and P\u03c4 contains all functions p : {i} 7\u2192 S(H) such that p(i) \u2286 NH(u) for some u \u2208 V (H).\n\u03c4 = \u03c1i\u2192j(\u03c4 \u2032) and P\u03c4 \u2032 has already been computed.\nIf i 6\u2208 L\u03c4 \u2032 , we can correctly set L\u03c4 = L\u03c4 \u2032 and P\u03c4 = P\u03c4 \u2032 . If i \u2208 L\u03c4 \u2032 and j 6\u2208 L\u03c4 \u2032 , then L\u03c4 = (L\u03c4 \u2032 \\ {i}) \u222a {j} and\nP\u03c4 = { p : L\u03c4 \u2192 S(H) | \u2203p\u2032 \u2208 P\u03c4 \u2032 : p(`) = { p\u2032(`) if ` 6= j p\u2032(i) if ` = j } .\nFinally, if {i, j} \u2286 L\u03c4 \u2032 , then L\u03c4 = L\u03c4 \u2032 \\ {i} and P\u03c4 = {p\u2032|L\u03c4 | p\u2032 \u2208 P\u03c4 \u2032 \u2227 p\u2032(i) = p\u2032(j)}. For correctness in the last case, let h be a homomorphism from G\u03c4 to H and S` \u2208 S(H) be such that S` \u2286 S(h(V `\u03c4 )), ` \u2208 L\u03c4 . Observe that V `\u03c4 = V `\u03c4 \u2032 for ` \u2208 L\u03c4 \\ {j} and V j\u03c4 = V j \u03c4 \u2032 \u222aV i\u03c4 \u2032 . In particular, Sj \u2286 S(h(V i\u03c4 \u2032)) and Sj \u2286 S(h(V j \u03c4 \u2032)). By definition of P\u03c4 \u2032 , there exists p\u2032 \u2208 P\u03c4 \u2032 such that p\u2032(`) = S` for ` \u2208 L\u03c4 \\ {j} and p\u2032(i) = p\u2032(j) = Sj . The function p \u2208 P\u03c4 , defined by p = p\u2032|L\u03c4 , satisfies p(`) = S` for each ` \u2208 L\u03c4 .\nOn the other hand, fix some p \u2208 P\u03c4 . Let p\u2032 \u2208 P\u03c4 \u2032 be a function such that p arises from p\u2032 in the construction of P\u03c4 . Consider a witness h of p\u2032 in \u03c4 \u2032. For every ` \u2208 L\u03c4 \\ {j} we have V `\u03c4 = V `\u03c4 \u2032 and so p(`) = p\u2032(`) \u2286 S(h(V `\u03c4 )). Moreover, p(j) = p\u2032(j) \u2286 S(h(V j \u03c4 \u2032)) and p(j) = p\u2032(i) \u2286 S(h(V i\u03c4 \u2032)). By Observation 4, we have p(j) \u2286 S(h(V i\u03c4 \u2032)) \u2229 S(h(V j \u03c4 \u2032)) = S(h(V i\u03c4 \u2032 \u222a V j \u03c4 \u2032)) = S(h(V j\u03c4 )). Hence p witnesses h in \u03c4 .\n\u03c4 = \u03c4 (1) \u2295 \u03c4 (2) where P\u03c4(1) and P\u03c4(2) have already been computed."
        },
        {
            "heading": "In this case L\u03c4 = L\u03c4(1) \u222a L\u03c4(2) and",
            "text": "P\u03c4 = {p = p1 \u222a p2 | p1 \u2208 P\u03c4(1) \u2227 p2 \u2208 P\u03c4(2) \u2227 (\u2200` \u2208 L\u03c4(1) \u2229 L\u03c4(2) : p1(`) = p2(`))}\nIntuitively, we construct a homomorphism on the disjoint union of two subgraphs by \u201cgluing together\u201d the homomorphisms on the subgraphs. If the subgraphs share any live labels, after this step they will all be treated equally. For this reason we require the images of the neighbors of such labels to be the same in both subgraphs. For correctness, let h be a homomorphism from G\u03c4 to H and S` \u2208 S(H) be such that S` \u2286 S(h(V `\u03c4 )), ` \u2208 L\u03c4 . Observe that for every ` \u2208 L\u03c4(1) \u2229 L\u03c4(2) , V `\u03c4 \u2287 V `\u03c4(i) , so S` \u2286 S(h(V ` \u03c4(i)\n)), i = 1, 2. By definition, there exists pi \u2208 P\u03c4(i) such that pi(`) = S` for ` \u2208 L\u03c4(i) , i = 1, 2. Then for p = p1 \u222a p2 we have p(`) = S`, ` \u2208 L\u03c4 .\nFor the converse, fix some p \u2208 P\u03c4 . Let p1 \u2208 P\u03c4(1) , p2 \u2208 P\u03c4(2) be functions such that p = p1 \u222a p2. Let hi be a witness of pi in \u03c4 (i), i = 1, 2. We define h = h1 \u222a h2. Since G\u03c4 doesn\u2019t contain edges between V (G\u03c4(1)) and V (G\u03c4(2)), h is a homomorphism from G\u03c4 to H. For all ` \u2208 L\u03c4(1) \\ L\u03c4(2) , we have p(`) = p1(`) \u2286 S(h1(V `\u03c4 )) = S(h(V `\u03c4 )), similarly for ` \u2208 L\u03c4(2) \\ L\u03c4(1) . For ` \u2208 L\u03c4(1) \u2229 L\u03c4(2) , we have p(`) = pi(`) \u2286 S(hi(V `\u03c4(i))), i = 1, 2, so p(`) \u2286 S(h1(V `\u03c4(1))) \u2229 S(h2(V ` \u03c4(2) )) = S(h(V `\u03c4 )). Hence h is a witness of p in \u03c4 .\n\u03c4 = \u03b7i,j(\u03c4 \u2032) and P\u03c4 \u2032 has already been computed.\nIn this case L\u03c4 = L\u03c4 \u2032 \\ I where I \u2286 {i, j} is the set of live labels in \u03c4 \u2032 that are no longer live labels in \u03c4 . We set P\u03c4 equal to\n{p : L\u03c4 \u2192 S(H) | \u2203p\u2032 \u2208 P\u03c4 \u2032 : p\u2032(i) \u2287 S(p\u2032(j)) \u2227p|L\u03c4\\{i,j} = p \u2032|L\u03c4\\{i,j} \u2227 p(i) \u2286 p \u2032(i) \u2227 p(j) \u2286 p\u2032(j)}.\nIntuitively, we can add the edges between two live labels if and only if there are edges between their images in H. Our restriction on p\u2032 is an expression of this condition in terms of images of neighbors and their signatures. Indeed, for correctness, let h be a homomorphism from G\u03c4 to H and S` \u2208 S(H) be such that S` \u2286 S(h(V `\u03c4 )), ` \u2208 L\u03c4 . There exists p\u2032 \u2208 P\u03c4 \u2032 such that p\u2032(`) = S` for all ` \u2208 L\u03c4 \\ {i, j}, p\u2032(i) = S(h(V i\u03c4 \u2032)) and p\u2032(j) = S(h(V j \u03c4 \u2032)). As h is a homomorphism, we have h(V i\u03c4 \u2032)\u00d7 h(V j \u03c4 \u2032) \u2286 E(H), which means that S(h(V j \u03c4 \u2032)) \u2287 h(V i\u03c4 \u2032), i.e. p\u2032(j) \u2287 h(V i\u03c4 \u2032). Then S(p\u2032(j)) \u2286 S(h(V i\u03c4 \u2032)) = p\u2032(i) and hence p\u2032 gives rise to p \u2208 P\u03c4 such that p(`) = S`, ` \u2208 L\u03c4 .\nOn the other hand, let p \u2208 P\u03c4 arise from p\u2032 \u2208 P\u03c4 \u2032 . Consider a witness h : G\u03c4 \u2032 \u2192 H of p\u2032 in \u03c4 \u2032. To see that h preserves edges between V i\u03c4 \u2032 and V j \u03c4 \u2032 , recall that p\u2032(i) \u2287 S(p\u2032(j)), so S(h(V i\u03c4 \u2032)) \u2287 p\u2032(i) \u2287 S(p\u2032(j)) \u2287 S(S(h(V j \u03c4 \u2032))) \u2287 h(V j \u03c4 \u2032). Hence h(V i\u03c4 \u2032)\u00d7 h(V j \u03c4 \u2032) \u2286 E(H), so h is a homomorphism. By construction, for every ` \u2208 L\u03c4 it holds that p(`) \u2286 p\u2032(`) \u2286 S(h(V `\u03c4 )). Therefore h witnesses p in \u03c4 .\nIt is easy to verify that |P\u03c4 | 6 s(H)cw(G) for each subexpression \u03c4 of \u03c3. This means that in each step, the computation requires time O(cw(G)s(H)2s(H)cw((G))). Overall this yields a complexity of O(|V (G)|cw(G)s(H)2s(H)cw((G))) \u2286 O\u2217(s(H)cw(G)). J\n4 On Products and Projectivity\nWhile Theorem 1 will serve as the upper bound that will match our target SETH-based lower bounds for Hom(H) for the \u201cmost difficult\u201d choices of H, in many cases one can in fact supersede the algorithm\u2019s runtime by exploiting well-known properties of target graphs.\nAs a simple example showcasing this, consider the wheel graph W6 (see Figure 1). Since W6 is 3-colorable, it holds that W6 \u2192 K3, and since K3 is a core and an induced subgraph of W6, it is the core of W6. We recall that if H is a core of H \u2032, then for every graph G it holds that G\u2192 H if and only if G\u2192 H \u2032. Hence, having an instance G of Hom(W6), we can compute a core of W6 (since we assume that the target graph is fixed, this can be done in constant time), and use Theorem 1 for H = K3 to decide whether G\u2192W6 in total running time O\u2217(s(K3)cw(G)). As s(K3) < s(W6) (as showcased in Figure 1), this yields a better running time bound than the direct use of Theorem 1. While this example shows that the signature number can decrease by taking an induced subgraph, we remark that it can never increase.\nI Observation 9. Let H and H \u2032 be graphs such that H is an induced subgraph of H \u2032. Then s(H) 6 s(H \u2032).\n12\n3\n4 5\n6 0\n\u2192\nFigure 1 The graphs W6 (left) and K3 (right). Colors\non the vertices of W6 indicate the homomorphism h : W6 \u2192 K3. We note that {{0}}\u222a{{0, i} | i \u2208 [6]} \u2286 S(W6). Since K3 is a clique, we have s(K3) = 6 < 7 6 s(W6).\nProof. Given a connected graph Q without loops, one may consider an equivalence relation \u223cQ on the set of nonempty subsets of V (Q) defined as follows: V1 \u223cQ V2 if and only if V1 and V2 have the same signature sets in Q. Observe that s(Q) is equal to the number of equivalence classes of \u223cQ minus one (as there are subsets V such that S(V ) = \u2205). Hence to prove the claim, it suffices to show that whenever two subsets of V (H) belong to different equivalence classes of \u223cH , they also belong to different equivalence classes of \u223cH\u2032 . For this, consider any two non-empty subsets V1 and V2 of V (H) such that V1 H V2. Without loss of generality, we assume that there exists v \u2208 ( \u22c2 t\u2208V1 NH(t)) \\ ( \u22c2 t\u2208V2 NH(t)). Then vt \u2208 E(H) \u2286 E(H \u2032) for every t \u2208 V1, i.e., v belongs to the signature set of V1 in H \u2032. On the other hand, vt0 /\u2208 E(H) for some t0 \u2208 V2. As H is induced subgraph of H \u2032, it means that vt0 /\u2208 E(H \u2032), so v doesn\u2019t belong to the signature set of V2 in H \u2032 and hence V1 H\u2032 V2. J\nAt this point, we may ask whether the procedure of simply computing the unique core H of the fixed target H \u2032 and then applying Theorem 1 for H could yield a tight upper bound for Hom(H \u2032). Unfortunately, the situation is more complicated than that, and we need to introduce a few important notions in order to capture the problem\u2019s fine-grained complexity.\nLet the direct product H1 \u00d7H2 of graphs H1, H2 be the graph defined as follows:\nV (H1 \u00d7H2) = V (H1)\u00d7 V (H2), E(H1 \u00d7H2) = {(x1, x2)(y1, y2) : xiyi \u2208 E(Hi) for every i \u2208 {1, 2}}.\nWe call H1 and H2 the factors of H1 \u00d7H2. Clearly, the operation \u00d7 is commutative, and since it is also associative, we can naturally extend the definition of direct product to more than two factors, i.e., H1 \u00d7H2 \u00d7 . . . \u00d7Hm = H1 \u00d7 (H2 \u00d7 . . . \u00d7Hm). Note that for every graph H it holds that H \u00d7K\u22171 = H..\nIn the remaining part of the paper we will often consider vertices that are tuples. If such a vertex is an argument of some function and in cases where this does not lead to confusion, we omit one pair of brackets; similarly, we omit internal brackets in nested tuples where this does not lead to confusion. Moreover, for any graph H and for an integer `, we denote by H` the graph `\ufe37 \ufe38\ufe38 \ufe37\nH \u00d7 . . .\u00d7H. As an example, instead of writing ((x1, x2), y1) \u2208 ((H1 \u00d7H1)\u00d7H2), we write (x1, x2, y1) \u2208 (H21 \u00d7H2).\nIf H = H1 \u00d7 . . . \u00d7 Hm for some graphs H1, . . . ,Hm, we say that H1 \u00d7 . . . \u00d7 Hm is a factorization of H. A graph H on at least two vertices is prime if the fact that H = H1\u00d7H2 for some graphs H1, H2 implies that H1 = K\u22171 or H2 = K\u22171 . If H has a factorization H1 \u00d7 . . .\u00d7Hm such that for every i \u2208 [m] the graph Hi is prime, we call H1 \u00d7 . . .\u00d7Hm a prime factorization of H.\nI Theorem 10 ([8, 14]). Any connected non-bipartite graph with more than one vertex has a unique prime factorization (into factors with possible loops).\nConsider a graphH1\u00d7. . .\u00d7Hm, and let i \u2208 [m]. A mapping \u03c0i : V (H1\u00d7. . .\u00d7Hm)\u2192 V (Hi) such that \u03c0i(x1, . . . , x`) = xi is called the (i-th) projection of H1 \u00d7 . . .\u00d7Hm. Clearly, such a mapping is always a homomorphism.\nI Observation 11. Let G,H1, . . . ,Hm be graphs. Then G\u2192 H1 \u00d7 . . .\u00d7Hm if and only if for every i \u2208 [m] we have G\u2192 Hi.\nProof. Let f : G \u2192 H1 \u00d7 . . . \u00d7 Hm. Then for every i \u2208 [m] we have a homomorphism \u03c0i : G \u2192 Hi. Conversely, if for every i \u2208 [m] we have gi : G \u2192 Hi, then we can define g : G\u2192 H1 \u00d7 . . .\u00d7Hm as g(x) = (g1(x), . . . , gm(x)). J\nCrucially, since there exist cores that are not prime [25], in some cases Observation 11 allows us to improve the bounds given by Theorem 1 even if H is a core, simply by considering all possible factorizations of H.\nI Corollary 12. Let H be a graph with factorization H1\u00d7 . . .\u00d7Hm, and let G be an instance graph of Hom(H). Assuming that the clique-width expression \u03c3 of G of width cw(G) is given, the Hom(H) problem can be solved in time maxi\u2208[m]O\u2217 ( s(Hi)cw(G) ) .\nProof. Observe that if G is an instance of Hom(H), by Theorem 1 for every i \u2208 [m] we can decide whether G\u2192 Hi in time O\u2217 ( s(Hi)cw(G) ) . Then, if G is a yes-instance of Hom(Hi) for every i \u2208 [m], we return that G is a yes-instance of Hom(H). Otherwise, we return that G is a no-instance of Hom(H). The correctness of this procedure follows from Observation 11. J\nOn the other hand, the notion of signature sets we introduced in the previous section behaves multiplicatively with respect to taking direct product of graphs.\nI Observation 13. Let H = H1 \u00d7H2. Then S(H) = S(H1)\u00d7 S(H2).\nProof. We prove that S(H) is of form {S(T1)\u00d7 S(T2) : Ti \u2286 V (Hi), S(Ti) 6= \u2205 for i = 1, 2}. Let T1 and T2 be some subsets of, respectively, V (H1) and V (H2). Clearly,\nS(T1)\u00d7 S(T2) = [ \u22c2 t\u2208T1 N(t)]\u00d7 [ \u22c2 t\u2032\u2208T2 N(t\u2032)] = \u22c2 (t,t\u2032)\u2208T1\u00d7T2 N(t, t\u2032) = S(T1 \u00d7 T2). (1)\nTherefore, if S(T1) and S(T2) are non-empty, we get that S(T1)\u00d7 S(T2) \u2208 S(H). To see that S(H) \u2286 S(H1) \u00d7 S(H2), we show that for every T \u2286 V (H) set S(T ) is of the form S(T1) \u00d7 S(T2) for some T1, T2. Define T1 and T2 to be minimal sets such that T \u2286 T1\u00d7T2. Hence, by (1), S(T1)\u00d7S(T2) = S(T1\u00d7T2) \u2286 S(T ). On the other hand, for every (s, s\u2032) \u2208 S(T ) we have s \u2208 \u22c2 t\u2208T1 N(t) and s \u2032 \u2208 \u22c2 t\u2032\u2208T2 N(t \u2032), so the equality follows. J\nIn particular, it follows from Observation 13 that if H is a graph with factorization H1 \u00d7 . . .\u00d7Hm, then s(H) = s(H1) \u00b7 . . . \u00b7 s(Hm). Therefore if there exist at least two factors Hi, Hj such that s(Hi) > 1, s(Hj) > 1, Corollary 12 yields a better running time than Theorem 1.\nIn order to analyze the possible matching lower bounds for our algorithms, in the remaining part of the section, we focus only on connected non-trivial cores H that are provided with their unique prime factorization H1 \u00d7 . . .\u00d7Hm; if H is prime, we technically consider this factorization to be H \u00d7K\u22171 (noting that this is not a prime factorization, and that K\u22171 is the only non-simple graph in this article). We note that the factors of a core must satisfy some necessary conditions.\nI Observation 14 ([25]). Let H be a connected, non-trivial core with factorization H = H1 \u00d7 . . .\u00d7Hm such that Hi 6= K\u22171 for all i \u2208 [m]. Then for every i \u2208 [m] the graph Hi is a connected non-trivial core, incomparable with Hj for j \u2208 [m]\u2212 {i}.\nObservation 14 in particular implies that if H is a connected non-trivial graph with factorization H1 \u00d7 . . . \u00d7Hm, then at least one of the factors Hi must be non-trivial, and that K1 and K2 never appear as factors of a connected non-trivial graph.\nIn the remaining part of this section we introduce a few more important definitions, in particular, the well-established notion of projectivity for non-trivial graphs H.\nWe say that a homomorphism f : H` \u2192 H, for some ` > 2, is idempotent if for each x \u2208 V (H) it holds that f(x, . . . , x) = x. Graph H is projective if for every ` > 2, every idempotent homomorphism f : H` \u2192 H is a projection. We note that every projective graph on at least three vertices must be connected, ramified, non-bipartite and prime [22].\nHere, we introduce a generalization of the projectivity property for non-trivial cores, which turns out to be the central component required to establish the lower bound for our problem. As a first step towards this, we lift the notion of idempotency as follows. Let H be a connected, non-trivial prime core, and let W be either a connected core on at least three vertices incomparable with H, or the graph K\u22171 . Let f : A\u2192 H be a homomorphism where A = H`\u00d7W ; observe that ` is uniquely determined by either W being incomparable with the prime coreH, orW beingK\u22171 . We say that f isH-idempotent if for each x \u2208 V (H), y \u2208 V (W ) it holds that f(x, . . . , x, y) = x.\nNow, let us consider a non-trivial core H which admits a prime factorization H1\u00d7. . .\u00d7Hm and let i \u2208 [m]. We say that H is Hi-projective if Hi is non-trivial and every Hi-idempotent homomorphism f : H1\u00d7. . .\u00d7Hi\u22121\u00d7H`i\u00d7Hi+1\u00d7. . .\u00d7Hm \u2192 Hi is a projection. In other words, for every homomorphism f : H1\u00d7 . . . Hi\u22121\u00d7H`i \u00d7Hi+1\u00d7 . . .\u00d7Hm \u2192 Hi such that for every x \u2208 V (Hi), yj \u2208 V (Hj) for j \u2208 [m]\u2212{i} it holds that f(y1, . . . , yi\u22121, x, . . . , x, yi+1, . . . , ym) = x, we must have that there exists q \u2208 {i, . . . , i + ` \u2212 1} such that f \u2261 \u03c0q. Recall that if H is a non-trivial projective core, then it must be prime, so H \u00d7 K\u22171 is its only possible factorization. It is straightforward to verify that in a such case H is H-projective.\nSince the direct product of graphs is commutative, if H = H1\u00d7 . . .\u00d7Hm is Hi-projective for some i \u2208 [m], to simplify the notation we will often assume w.l.o.g. that i = 1.\n5 Hardness\nIn this section, we focus on establishing the desired lower bounds, stated below.\nI Theorem 2. If H is Hi-projective for some i \u2208 [m] then there is no algorithm solving Hom(H) in time O\u2217((s(Hi)\u2212 \u03b5)cw(G)) for any \u03b5 > 0, unless the SETH fails.\nWe divide our proof into two main steps. First, we show that in our setting, instead of considering the Hom(H) problem, we may focus on the Homomorphism Extension problem, denoted HomExt(H). For a fixed H, HomExt(H) takes as an instance a pair (G\u2032, h\u2032), where G\u2032 is a graph and h\u2032 : V \u2032 \u2192 V (H) is a mapping from some V \u2032 \u2286 V (G\u2032). We ask whether there exists an extension of h\u2032 to G\u2032, i.e., a homomorphism h : G\u2032 \u2192 H such that h|V \u2032 \u2261 h\u2032.\nThe HomExt(H) is clearly a generalization of the Hom(H) problem. However, as the first step of our proof, we show that if H is a fixed non-trivial core, each instance (G\u2032, h\u2032) of HomExt(H) can be transformed in polynomial time into an instance G of Hom(H), such that cw(G\u2032) and cw(G) differ only by a constant.\nI Theorem 15. Let H be a fixed non-trivial core. Given an instance (G\u2032, h\u2032) of HomExt(H), we can construct an equivalent instance G of Hom(H) such that cw(G) 6 cw(G\u2032) + |V (H)|.\nProof. Let V \u2032 \u2286 V (G\u2032) be the domain of h\u2032. We construct G by taking a copy G\u0302\u2032 of G\u2032 and a copy H\u0302 of H. Then, for every v \u2208 V \u2032 we add all the edges with one endpoint in v and another one in NH\u0302(h\u2032(v)).\nObserve that if there exists an extension h : G\u2032 \u2192 H of h\u2032, then h can be also extended to G, by setting h(v) = v for every v \u2208 V (H\u0302). Indeed, let uv \u2208 E(G). If u, v \u2208 V (G\u0302\u2032), then h(u)h(v) \u2208 E(H), by definition of the extension of h\u2032 to G\u2032. If u, v \u2208 V (H\u0302), then h(u)h(v) = uv \u2208 E(H). Finally, assume that u \u2208 V (G\u0302\u2032), v \u2208 V (H\u0302). Note that, by definition of G, this can happen only if u \u2208 V \u2032 and v is adjacent to h\u2032(u). Hence, h(u)h(v) = h\u2032(u)v \u2208 E(H).\nFor the reverse direction, assume that there exists a homomorphism f : G \u2192 H. We show that there exists an extension h : G\u2032 \u2192 H of h\u2032. Let \u03c3 : H\u0302 \u2192 H be a restriction of f to H\u0302. Since H is a core, \u03c3 is an automorphism of H. We claim that g = \u03c3\u22121 \u25e6 f : G\u2192 H, restricted to G\u2032, is an extension of h\u2032. Clearly, g is a composition of homomorphisms, so also a homomorphism. Therefore, it remains to show that for every v \u2208 V \u2032 we have h\u2032(v) = g(v). Since H is a core, and NH\u0302(h\u2032(v)) \u2286 NG(v), we have that f(v) = f(h\u2032(v)). It follows that g(v) = \u03c3\u22121 \u25e6 f(v) = \u03c3\u22121 \u25e6 f(h\u2032(v)) = g(h\u2032(v)). However, recall that for every u \u2208 V (H) we have that g(u) = u, so in particular, g(h\u2032(v)) = h\u2032(v).\nTo see that cw(G) 6 cw(G\u2032) + |V (H)|, observe that we added exactly |V (H)| vertices to G\u2032. This means we can modify a clique-width expression \u03c3 for G\u2032 to obtain a clique-width expression of G as follows. Each added vertex is introduced with a designated label that is distinct from all labels used in \u03c3. Then each subexpression of \u03c3 that introduces a vertex of G\u2032 can be replaced by an expression that introduces the vertex and inserts all required edges to the added vertices. Finally, one can insert the missing edges between added vertices. J\nAs the second step, we prove the following theorem.\nI Theorem 16. Let H be a fixed non-trivial core with prime factorization H1 \u00d7 . . .\u00d7Hm. Assume that H is Hi-projective for some i \u2208 [m]. Then there is no algorithm solving HomExt(H) in time O\u2217((s(Hi)\u2212 \u03b5)cw(G \u2032)) for any \u03b5 > 0, unless the SETH fails.\nBefore we proceed to the proof of Theorem 16, we show that it implies Theorem 2. Theorem 16 \u2192 Theorem 2: Let H be a non-trivial core with a prime factorization H1 \u00d7 . . . \u00d7Hm. W.l.o.g. assume that H is H1-projective. Suppose that Theorem 2 does not hold, i.e., there exists an algorithm A that solves every instance G of Hom(H) in time O\u2217((s(H1)\u2212 \u03b5)cw(G)).\nLet (G\u2032, h\u2032) be an instance of HomExt(H). We use Theorem 15 to transform (G\u2032, h\u2032) into an equivalent instance G of Hom(H), such that cw(G) 6 cw(G\u2032) + |V (H)|. Then, we use A to decide whether G\u2192 H in time\nO\u2217 ( (s(H1)\u2212 \u03b5)cw(G) ) = O\u2217 ( (s(H1)\u2212 \u03b5)cw(G \u2032) \u00b7 (s(H1)\u2212 \u03b5)|V (H)| ) .\nSinceH is a fixed graph, (s(H1)\u2212\u03b5)|V (H)| is a constant, and thereforeO\u2217 ( (s(H1)\u2212 \u03b5)cw(G) ) =\nO\u2217 ( (s(H1)\u2212 \u03b5)cw(G \u2032) ) . Since G\u2192 H if and only if (G\u2032, h\u2032) is a yes-instance of HomExt(H), we get a contradiction with Theorem 16. We will prove Theorem 16 for i = 1, which covers\nother cases by commutativity of direct products. We begin by constructing certain gadgets that will be used later. Let H be a fixed core with factorization H1 \u00d7 . . . \u00d7 Hm. We define W = H2 \u00d7 . . . \u00d7Hm if m > 2, and W = K\u22171 otherwise. Clearly, H1 \u00d7W is a (not necessarily prime) factorization ofH. Moreover, if for some graph G we have a homomorphism f : G\u2192 H1\u00d7 . . .\u00d7Hm, for i \u2208 [m] we denote by fi the homomorphism \u03c0i \u25e6 f : G\u2192 Hi. Let S be a set of pairs of vertices of H1, and let w,w\u2032 \u2208 V (W ). We say that a tuple (F, h\u2032, p, q),\nsuch that F is a graph, h\u2032 : V \u2032 \u2192 H is a mapping with domain V \u2032 \u2286 V (F ), and p, q \u2208 V (F ), is an (S,w,w\u2032)-gadget if (S1) for every extension h : F \u2192 H of h\u2032, it holds that (h1(p), h1(q)) \u2208 S, (S2) for every pair (s1, s2) \u2208 S there exists an extension h : F \u2192 H of h\u2032 such that\nh(p) = (s1, w) and h(q) = (s2, w\u2032).\nI Lemma 17. Let H be a non-trivial connected core with factorization H1 \u00d7W , let S \u2286 V (H1)2, and let w,w\u2032 \u2208 V (W ). Assume that H is H1-projective. Then there exists an (S,w,w\u2032)-gadget.\nProof. Let S = {(s11, s12), . . . , (s`1, s`2)}. Define\nF = H`1 \u00d7W, and p = (s11, . . . , s`1, w), and q = (s12, . . . , s`2, w\u2032).\nLet V \u2032 = {(x, x, . . . , x, y) | x \u2208 V (H1), y \u2208 V (W )}, and let h\u2032(x, . . . , x, y) = (x, y). We claim that (F, h\u2032, p, q) is an (S,w,w\u2032)-gadget.\nThe condition 1 follows from the fact that H is H1-projective. Indeed, if h : F \u2192 H1\u00d7W is an extension of h\u2032, observe that h1 must be H1-idempotent, and hence a projection on one of the ` first coordinates. Therefore, we must have (h1(p), h1(q)) \u2208 S.\nFor (S2), take any (si1, si2) \u2208 S and let h : F \u2192 H1 \u00d7W , h(x) = (\u03c0i(x), \u03c0`+1(x)). Clearly, h is an extension of h\u2032, and it is easy to verify that h(p) = (si1, w) and h(q) = (si2, w\u2032). J\nWe say that S \u2286 V (H1)2 is proper, if for every coordinate there exist two elements in S that differ on that coordinate, i.e., S is not of the form {s}\u00d7U nor U\u00d7{s} for some s \u2208 V (H1) and U \u2286 V (H1). Note that if S is proper and (F, h\u2032, p, q) is an (S,w,w\u2032)-gadget constructed as in Lemma 17, then neither p nor q belong to the domain of h\u2032. For fixed vertices a, b \u2208 V (H1), let Sa,b = {(a\u2032, b\u2032) : a\u2032 6= a, b\u2032 \u2208 V (H1)}\u222a{(a, b)}. We call the (Sa,b, w, w\u2032)-gadget (F, h\u2032, p, q) an ((a, b), w, w\u2032)-implication-gadget. Intuitively, an ((a, b), w, w\u2032)-implication-gadget works as the implication a\u21d2 b, since in every homomorphism h : F \u2192 H that extends h\u2032, if h1(p) = a, then h1(q) = b. Let a, b, c \u2208 V (H1), w \u2208 V (W ), and let t be an integer. A triple (F, h\u2032, R) such that F is a graph, h\u2032 : V \u2032 \u2192 H1 \u00d7W is a partial mapping from some V \u2032 \u2286 V (F ), and R is a subset of V (F ) of cardinality t is an t-or-gadget with domain ((a, b, c), w) if (O1) for every homomorphism h : F \u2192 H that is an extension of h\u2032, and for every u \u2208 R we have that h1(u) \u2208 {a, b, c} and there exists v \u2208 R such that h1(v) = a, (O2) for every v \u2208 R there exists a homomorphism h : F \u2192 H that is an extension of h\u2032,\nsuch that h(v) = (a,w) and for every u \u2208 R\u2212 {v} it holds that h(u) \u2208 {(b, w), (c, w)}.\nI Lemma 18. Let H be a non-trivial core with factorization H1 \u00d7W . Assume that H is H1-projective. Then for every distinct a, b, c \u2208 V (H1), every w \u2208 V (W ) and every t, there exists a t-or-gadget (F, h\u2032, R) with domain ((a, b, c), w).\nProof. We consider separately the cases t = 1 and t = 2. Observe that in case t = 1 our gadget needs to be a graph that has a vertex r \u2208 R that is always mapped to (a,w). Hence, we set F = K1, R = V (F ), and h\u2032(v) = (a,w) for v \u2208 V (F ).\nIf t = 2, let S = {(a, b), (b, a), (a, a)}, we introduce an independent set R = {r1, r2} and (S,w,w)-gadget (F, h\u2032, r1, r2). To see that (F, h\u2032, R) satisfies 1, consider any extension f : F \u2192 H of h\u2032. As (F, h\u2032, r1, r2) is (S,w,w)-gadget, we have (f1(r1), f1(r2)) \u2208 {(a, b), (a, a), (b, a)}. For 2, recall that by the property 2 of S-gadget there exist extensions f (1) and f (2) of h\u2032 such that (f (1)1 (r1), f (1) 1 (r2)) = (a, b) and (f (2) 1 (r1), f (2) 1 (r2)) = (b, a).\nAssume then that t > 2, and let\nS = {a, b, c}2 \u2212 {(b, c), (c, b)}, Sleft = {(a, a), (a, b), (a, c), (c, a), (c, c)}, Sright = {(a, a), (a, b), (b, a), (b, b), (c, a)}\nbe subsets of V (H1)2. We introduce an independent set R = {r1, . . . , rt} of t vertices and one copy of (Sleft, w, w)-gadget (F1, h\u20321, r1, r2). Then, for j \u2208 {2, . . . , t\u2212 2}, we introduce an (S,w,w)-gadget (Fj , h\u2032j , rj , rj+1) (we note that if t = 3, we do not introduce these). Last, we introduce one copy of (Sright, w, w)-gadget (Ft\u22121, h\u2032t\u22121, rt\u22121, rt). We note that sets S, Sleft, and Sright are proper, so the domains of the partial mappings h\u2032j , j \u2208 {1, . . . , t \u2212 1}, are pairwise disjoint. In particular, the union h\u2032 = \u22c3t j=1 h \u2032 j is a well-defined mapping. We define F to be the union of all the graphs from the introduced gadgets and claim that (F, h\u2032, R) is a t-or-gadget.\nWe first show that 1 holds. Assume that there exists an extension f : F \u2192 H of h\u2032, and j\u2032 \u2208 [t] such that f1(rj\u2032) /\u2208 {a, b, c}. This implies that there exists j \u2208 {j\u2032 \u2212 1, j\u2032} such that (f1(rj), f1(rj+1)) /\u2208 S\u2032 for any S\u2032 \u2208 {Sleft, S, Sright}. This is a contradiction with (F,h\u2032j , pj , qj) being an (S\u2032, w, w)-gadget, as it violates 1.\nNow assume that there exists an extension f : F \u2192 H of h\u2032 such that for every j \u2208 [t] we have that f1(rj) \u2208 {b, c}. The definition of Sleft and Sright, respectively, implies that f1(r1) = c and f1(rt) = b. Hence, there exists j \u2208 [t\u22121] such that f1(rj) = c and f1(rj+1) = b. However, observe that the pair (c, b) does not belong to set S\u2032, for S\u2032 \u2208 {Sleft, S, Sright}, and since we introduced an S\u2032-gadget from rj to rj+1, this leads to a contradiction.\nTo see that 2 holds as well, fix some rj \u2208 R and define\nf \u2032(r`) =  (a,w), if ` = j, (c, w), if ` < j, (b, w), if ` > j,\nIf j = 1, then since (a, b) \u2208 Sleft, (b, b) \u2208 S and (b, b) \u2208 Sright, the property 2 asserts that we can construct a homomorphism f : F \u2192 H that extends h\u2032 and f \u2032. The same holds also if j = t, (since (c, c) \u2208 Sleft, (c, c) \u2208 S and (c, a) \u2208 Sright), and if 1 < j < t (since (c, c) \u2208 Sleft, (c, c), (c, a), (a, b), (b, b) \u2208 S and (b, b) \u2208 Sright). J\nFinally, all that remains is to prove Theorem 16. Our reduction generalizes the construction used by Lampis [20] to reduce an SETH lower-bounded constraint satisfaction problem to k-Coloring. Intuitively speaking, in that construction possible variable assignments are encoded by mapping specified vertices to arbitrary non-trivial subsets of the colors. The straightforward generalization of this approach to our setting would be to map to non-trivial subsets of V (H). However, the structure of H allows only certain configurations of subsets as images for the specified vertices in a solution for Hom(H)\u2014which is precisely where the signature sets come into play.\nLet q,B > 2 be integers. We will reduce from the q-CSP-B problem that is defined as follows. An instance of q-CSP-B consists of a set X of variables and a set C of q-constraints. A q-constraint c \u2208 C is a q-tuple of elements from X and a set P (c) of q-tuples of elements from [B] (i.e., P (c) \u2286 [B]q). The q-CSP-B problem asks whether there exists an assignment \u03b3 : X \u2192 [B], such that each constraint is satisfied, i.e., if c = ((x1, . . . , xq), P (c)) \u2208 C, then (\u03b3(x1), . . . , \u03b3(xq)) \u2208 P (c). Note that we can assume that q-constraints in our q-CSP-B\ninstance may have less than q vertices, as it is always possible to add at most q \u2212 1 dummy variables to X and add them to constraints that are of smaller size.\nWe will use the following theorem.\nI Theorem 19 ([20]). For any B > 2, \u03b5 > 0 we have the following: assuming the SETH, there exists q such that n-variable q-CSP-B cannot be solved in time O\u2217((B \u2212 \u03b5)n).\nWe have all the tools to perform the final reduction.\nProof of Theorem 16. Recall that it is sufficient to prove the theorem when H = H1 \u00d7W is non-trivial H1-projective core (W = K\u22171 if H = H1). Fix \u03b5 > 0 and set B = s(H1). As H is H1-projective, H1 is non-trivial and hence contains at least three distinct vertices a, b and c. In particular, B > 3 by Observation 8. Since H = H1 \u00d7W is a non-trivial core, W must have at least one edge ww\u2032 (it may happen that w = w\u2032). From now on a, b, c, w and w\u2032 are fixed. Let q be the smallest number such that q-CSP-B on n variables cannot be solved in time O\u2217((B \u2212 \u03b5)n) assuming the SETH, given by Theorem 19.\nLet \u03d5 be an instance of q-CSP-B, where X = {x1, . . . , xn} is the set of variables and C = {c0, . . . , cm\u22121} is the set of constraints. For every j \u2208 {0, . . . ,m\u2212 1} denote by Xj the set of variables that appear in the constraint cj . Let P (cj) = {f j1 , . . . , f jpj} be the set of assignments from Xj to [B] that satisfy the constraint cj . Let L = m(n|H1|+ 1), and let \u03bb : [B]\u2192 S(H1) be some fixed bijection.\nWe construct the instance G\u03d5 of HomExt(H). For each j \u2208 {0, . . . L \u2212 1}, let j\u2032 = j mod m. Let Rj = {rj1, . . . , rjpj\u2032}, where each vertex r j k corresponds to the assignment f j\u2032\nk . We introduce the pj\u2032 -or-gadget (Fj , h\u2032j , Rj) with domain ((a, b, c), w).\nFor each xi \u2208 Xj\u2032 , and for each f j \u2032\nk \u2208 P (cj\u2032) we do the following: 1. Let y = f j \u2032\nk (xi) \u2208 [B]. Construct an independent set V j,k i of |\u03bb(y)| vertices and an\nindependent set U j,ki of |S(\u03bb(y))| vertices. 2. For each d \u2208 \u03bb(y) select a distinct vertex z \u2208 V j,ki and add an ((a, d), w, w\u2032)-implication-\ngadget from rjk to z. For each d \u2208 S(\u03bb(y)) select a distinct vertex z \u2208 U j,k i and add an\n((a, d), w, w\u2032)-implication-gadget from rjk to z. 3. Connect all vertices of U j,ki with all vertices of previously constructed sets V `,k\u2032\ni for ` < j and k\u2032 \u2208 [p`] (see Figure 2).\nThe partial mapping h\u2032 is the union of all the partial mappings that are introduced by all the gadgets. This finishes the construction of the instance (G\u03d5, h\u2032) of HomExt(H).\nB Claim 20. If \u03d5 is a yes-instance of q-CSP-B, then there exists a homomorphism h : G\u03d5 \u2192 H that extends h\u2032.\nProof of Claim. If \u03d5 is a yes-instance of q-CSP-B, then there exists an assignment \u03b3 : X \u2192 [B] satisfying each constraint. We define h : G\u03d5 \u2192 H as follows.\nFix j \u2208 {0, . . . , L\u2212 1}, and consider the or-gadget (Fj , h\u2032j , Rj). Recall that the set P (cj\u2032) consists of all assignments of variables in Xj\u2032 that satisfy the constraint cj\u2032 . Therefore, there exists an assignment f j \u2032\nk \u2208 P (cj\u2032) such that \u03b3|Xj\u2032 \u2261 f j\u2032 k . Consider the vertex r j k that\ncorresponds to that assignment. By the property 2 of the or-gadget, we know that there exists a H-coloring of Fj that extends h\u2032, such that (i) h1(rjk) = a and (ii) for every r j k\u2032 \u2208 Rj , k\u2032 6= k we have that h1(rjk\u2032) \u2208 {b, c}. Let xi \u2208 Xj\u2032 and let y = f j \u2032\nk (xi) \u2208 [B]. Since for each d \u2208 \u03bb(y) there exists a vertex z \u2208 V j,ki such that there is an ((a, d), w, w\u2032)-implication-gadget from r j k to z, the condition (i) implies that h1(V j,ki ) = \u03bb(y). We color the vertices of V j,k i in a way that h(V j,k i ) = \u03bb(y)\u00d7{w}.\nAlso, since for each d \u2208 S(\u03bb(y)) there exists a vertex z \u2208 U j,ki such that there is an (a, d)-implication-gadget from rjk to z, the condition (i) implies that h1(U j,k i ) = S(\u03bb(y)). We color the vertices of U j,ki in a way that h(U j,k i ) = S(\u03bb(y))\u00d7 {w\u2032}.\nBecause of (ii), the implication gadgets from rk\u2032 to the vertices of V j,k \u2032 i \u222a U j,k\u2032\ni do not put any constraints on the coloring of the sets V j,k \u2032 i and U j,k\u2032 i . Therefore, for each v \u2208 V j,k\u2032 i we set h(v) to be any vertex from \u03bb(y). Similarly, for each u \u2208 U j,k \u2032\ni we set h(u) to be any vertex from S(\u03bb(y)). Since (b, z), (c, z) \u2208 Sa,d for any z \u2208 V (H1) and d \u2208 \u03bb(y) \u222a S(\u03bb(y)), property 2 applied to the implication gadgets asserts that since h1(rjk\u2032) \u2208 {b, c}, we can always extend this mapping to a homomorphism of the whole gadget to H.\nIt remains to argue that the edges between the sets V j1,k1i and U j2,k2 i are mapped to edges of H, for any j1 < j2 and k1, k2. However, observe that since \u03b3 is an extension of some f j\u20321 k1 \u2208 Sj\u20321 and f j\u20322 k2 \u2208 Sj\u20322 , we must have f j\u20321 k1 (xi) = f j\u20322 k2\n(xi) = y. Hence, h maps every v \u2208 V j1,k1i to some element of \u03bb(y)\u00d7 {w}, and every u \u2208 U j2,k2i to some element of S(\u03bb(y))\u00d7 {w\u2032}. By Observation 4, and since ww\u2032 \u2208 E(W ), we get that h(v)h(u) \u2208 E(H). That concludes the proof of the claim. J\nB Claim 21. If there exists a homomorphism h : G\u03d5 \u2192 H that extends h\u2032, then \u03d5 is a yes-instance of q-CSP-B.\nProof of Claim. We will define the assignment \u03b3 : X \u2192 [B] that makes every constraint from C satisfied.\nFix j \u2208 {0, . . . , L \u2212 1}, and consider the pj\u2032-or-gadget (Fj , h\u2032j , Rj). By the property 1 of the or-gadget, there exists kj \u2208 [pj\u2032 ] such that h1(rjkj ) = a. Implication gadgets whose p-vertices were identified with rjkj assert that h1(V j,kj i ) \u2208 S(H) and h1(U j,kj i ) is the signature of h1(V j,kj i ). Then, by Observation 5, h1(V j,kj i ) is a signature of h1(U j,kj i ). Denote h1(U j,kj i ) by T ji , then h1(V j,kj i ) = S(T j i ) and S(S(T j i )) = T j i . Let y j i = f j\u2032 kj (xi) be the candidate assignment for xi \u2208 Xj\u2032 at index j, recall that yji = \u03bb\u22121(S(T j i )). Let i \u2208 [n] be fixed and let j1, j2 \u2208 [L], j1 < j2 be such that xi \u2208 Xj\u20321\u2229Xj\u20322 . Observe that in such case T j1 i \u2287 T j2 i . Indeed, denote k1 = kj1 , k2 = kj2 , then we have (1) h1(V j1,k1 i ) = S(T j1 i ) and h1(U j1,k1 i ) = T j1 i , and (2) h1(V j2,k2i ) = S(T j2 i ) and h1(U j2,k2 i ) = T j2 i . Recall that each vertex from U j2,k2 i is adjacent to each vertex from V j1,k1i . Since h1 is a homomorphism, the same holds for their images: each vertex from T j2i is adjacent to each vertex from S(T j1 i ). Then S(T j2 i ) \u2287 S(T j1 i ), so T j1i = S(S(T j1 i )) \u2287 S(S(T j2 i )) \u2287 T j2 i . We say that the index j1 \u2208 {0, . . . , L \u2212 1} is problematic for i if there is j2 > j1 such that xi \u2208 Xj\u20321 \u2229Xj\u20322 and T j1 i 6= T j2 i . Since for each variable we have at most |H1| problematic indices, there are at most |H1| \u00b7 n problematic indices for all variables. Since L = m(|Hi| \u00b7 n+ 1), by pigeonhole principle we get that there exists a set J \u2286 {0, . . . , L\u22121} of m consecutive indices such that none of them is problematic for any i. For every i \u2208 [n], we fix some j \u2208 J such that xi \u2208 Xj\u2032 and set \u03b3(xi) = yji (observe that the choice of j does not matter). We claim that \u03b3 is an assignment that satisfies every constraint from \u03d5. Indeed, for any j\u2032 \u2208 [m] there exists j \u2208 J such that j\u2032 = j mod m. For every i \u2208 Xj\u2032 , we have \u03b3(xi) = yji = f j\u2032 kj (xi), so \u03b3 satisfies the constraint cj\u2032 . J\nFinally, it remains to adapt the arguments of Lampis [20] to establish the desired linear clique-width bound.\nB Claim 22. G\u03d5 can be constructed in time polynomial in |\u03d5|, and we have cw(G\u03d5) 6 n+ f(\u03b5, \u03bd) for some function f , where \u03bd = |V (H)|.\nProof of Claim. Observe that any (S,w,w\u2032)-gadget constructed as in Lemma 17 for i = 1 has at most |V (Hi)||S|\u22121 \u00b7 |V (H)| 6 \u03bd|S| vertices. In particular, we can ensure that every implication gadget in G\u03d5 has at most \u03bdO(\u03bd\n2) vertices. Moreover, we will assume that all the or-gadgets of G\u03d5 are constructed as in Lemma 18 and the subgadgets for S, Sleft and Sright contain at most \u03bd7 vertices. Then for every j \u2208 {0, . . . , L\u2212 1}, pj\u2032 -or-gadget (Fj , h\u2032j , Rj) has at most (pj\u2032 \u2212 1) \u00b7 \u03bd7 vertices. For fixed H and \u03b5 > 0 we have that B = s(Hi) 6 2|V (Hi)| \u2212 2 and q is a constant that only depends on B, \u03b5 (that is, on |V (Hi)|, \u03b5). Each constraint of the q-CSP-B instance has at most Bq satisfying assignments. In particular, the number of vertices in each or-gadget is upper-bounded by Bq \u00b7 \u03bd7. Therefore, it is not hard to see that the whole construction can be performed in polynomial time, if H is fixed and \u03b5 is a constant. For clique-width we use the following labels:\n1. n main labels, representing the variables of \u03d5.\n2. A single done label. Its informal meaning is that a vertex that receives this label will not be connected to anything else not yet introduced in the graph.\n3. Bq \u00b7 \u03bd7 constraint work labels.\n4. qBq \u00b7 \u03bdO(\u03bd2) variable-constraint incidence work labels. To give a clique-width expression we will describe how to build the graph, following essentially the steps given in the description of the construction by maintaining the following invariant: before starting iteration j, all vertices of the set W ji = \u22c3 j\u2032<j \u22c3 k\u2208[pj\u2032 ] V j \u2032,k\ni have label i, and all other vertices have the done label. This invariant is vacuously satisfied before the first iteration, since the graph is empty. Suppose that for some j \u2208 {0, . . . , L\u2212 1} the invariant is true. We use the Bq \u00b7 \u03bd7 constraint work labels to introduce the vertices of the pj\u2032 -or-gadget (Fj , h\u2032j , Rj), giving each vertex a distinct label. We use join operations to construct the internal edges of the or-gadget. Then, for each variable xi that appears in the current constraint we do the following: we use Bq \u00b7 \u03bdO(\u03bd2) of the variable-constraint incidence work labels to introduce for all k \u2208 [pj\u2032 ] the vertices of V j,ki and U j,k i as well as the implication gadgets connecting these to rjk . Again we use a distinct label for each vertex, but the number of vertices (including internal vertices of the implication gadgets) is Bq \u00b7 \u03bdO(\u03bd2), so we have sufficiently many labels to use distinct labels for each of the q variables of the constraint. We use join operations to add the edges inside all implication gadgets. Then we use join operations to connect U j,ki to all vertices W j i . This is possible, since the invariant states that all the vertices of W ji have the same label i. We then rename all the vertices of U j,k i for all k to the done label, and do the same also for internal vertices of all implication gadgets. We proceed to the next variable of the same constraint and handle it using its own Bq \u00b7 \u03bdO(\u03bd2) labels. Once we have handled all variables of the current constraint, we rename all vertices of each V j,ki to label i for all k. We then rename all vertices of the pj\u2032 -or-gadget (Fj , h\u2032j , Rj) gadget to the done label and increase j by 1. It is not hard to see that we have maintained the invariant and constructed all edges induced by the vertices introduced in steps up to j, so repeating this process constructs the graph. J\nTogether the claims imply Theorem 16 in the following way: For an arbitrary instance of q-CSP-B, our construction produces an instance of HomExt(H), and the instances are equivalent by Claim 20 and Claim 21. If one could solve HomExt(H) in O\u2217((s(Hi)\u2212\u03b5)cw(G)) for some \u03b5 > 0, one could use our construction to solve q-CSP-B, and by our choice of B and Claim 22 this procedure would have complexity O\u2217((B \u2212 \u03b5)n+c) for some constant c. By our choice of q according to Theorem 19, this contradicts the SETH. J\n6 Summary and Concluding Remarks\nExtensions and Corollaries. We observe that Corollary 12 can be combined with Theorem 2 to obtain the following statement, which summarizes our results.\nI Theorem 23. Let H \u2032 be a fixed graph with the non-trivial connected core H. Let H1 \u00d7 . . .\u00d7Hm be the factorization of H. Let i \u2208 [m] be such that s(Hi) = maxj\u2208[m] s(Hj). Let G be an instance of Hom(H \u2032). 1. Assuming a clique-width expression \u03c3 of G of width cw(G) is given, the Hom(H \u2032) problem\ncan be solved in time maxi\u2208[m]O\u2217(s(Hi)cw(G)). 2. Assuming SETH, if H is Hi-projective, then there is no algorithm to solve Hom(H \u2032) in\ntime maxi\u2208[m]O\u2217((s(Hi)\u2212 \u03b5)cw(G)) for any \u03b5 > 0.\nWe note that the restriction to connected targets can be avoided by known properties of homomorphisms to disconnected graphs [25]; on the algorithmic side, one branches over all connected components of H, while for the lower bound one considers the component with maximum signature number.\nIt is clear that obtaining a full complexity classification with respect to clique-width may require weakening the assumption in the second statement of Theorem 23. We recall that an analogous situation occurs in the work of Okrasa and Rz\u0105\u017cewski [25]; as mentioned in the introduction, the authors obtain the SETH-conditioned tight complexity bound for the Hom(H) problem parameterized by treewidth for all targets H, assuming two conjectures of Larose and Tardif [21,22]. The notion of Hi-projectivity allows us to restate these conjectures as one, which is not only sufficient in our setting but is also weaker in the sense of it being implied by the former two conjectures, but not necessarily equivalent to them.\nI Conjecture 1. Let H be a non-trivial core with prime factorization H1 \u00d7 . . .\u00d7Hm and let i \u2208 [m]. Then H is Hi-projective.\nUsing Conjecture 1, we can restate our main result as follows.\nI Theorem 24. Let H \u2032 be a fixed graph with the non-trivial connected core H. Let H1 \u00d7 . . .\u00d7Hm be the prime factorization of H. Let G be an instance of Hom(H \u2032). 1. Assuming the clique-width expression \u03c3 of G of width cw(G) is given, the Hom(H \u2032)\nproblem can be solved in time maxi\u2208[m]O\u2217(s(Hi)cw(G)). 2. Assuming that Conjecture 1 and SETH hold, there is no algorithm to solve Hom(H \u2032) in\ntime maxi\u2208[m]O\u2217((s(Hi)\u2212 \u03b5)cw(G)) for any \u03b5 > 0.\nWe also observe that since each non-trivial projective core H is H-projective, in this case we already obtain a tight complexity bound.\nI Corollary 25. Let H \u2032 be a fixed graph with the non-trivial connected projective core H. Let G be an instance of Hom(H \u2032). 1. Assuming the clique-width expression \u03c3 of G of width cw(G) is given, the Hom(H \u2032)\nproblem can be solved in time O\u2217(s(H)cw(G)). 2. There is no algorithm to solve Hom(H \u2032) in time O\u2217((s(H) \u2212 \u03b5)cw(G)) for any \u03b5 > 0,\nunless the SETH fails.\nGeneralizations and Other Research Directions. We remark that our hardness reduction is via HomExt(H), and in fact our algorithm can also easily be adapted to this setting (by removing all records that do not adhere to the partial mapping from the input graph to H) without an increase in complexity. However, since the dichotomy between P and\nNP-complete cases of HomExt(H) is more complicated (see [11], studied as the graph-retract problem) there exist target graphs H that are not covered by Theorem 24. On a similar note, let us also point out that setting up the SETH-conditioned tight complexity bounds for clique-width for a more general list problem LHom(H) [10,27] is widely open.\nAnother direction that is very closely related to our results is to determine similarly tight complexity bounds for the rank-width (rw) of the input graph: rank-width [17, 26] is a graph parameter that is known to be asymptotically equivalent to clique-width and is in fact used as an approximation of clique-width that can be computed in fixed-parameter tractable time. Our results together with the known relationship between clique-width and rank-width imply an upper bound of O\u2217(s(H)2rw +1) and a SETH lower bound of (s(H)\u2212 \u03b5)rw on the complexity of Hom(H) for projective H parameterized by the rank-width of the input.\nReferences 1 R\u00e9my Belmonte, Eun Jung Kim, Michael Lampis, Valia Mitsou, and Yota Otachi. Grundy\ndistinguishes treewidth from pathwidth. In Fabrizio Grandoni, Grzegorz Herman, and Peter Sanders, editors, 28th Annual European Symposium on Algorithms, ESA 2020, September 7-9, 2020, Pisa, Italy (Virtual Conference), volume 173 of LIPIcs, pages 14:1\u201314:19. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2020. 2 Jan B\u00f6ker. Graph similarity and homomorphism densities. In Nikhil Bansal, Emanuela Merelli, and James Worrell, editors, 48th International Colloquium on Automata, Languages, and Programming, ICALP 2021, July 12-16, 2021, Glasgow, Scotland (Virtual Conference), volume 198 of LIPIcs, pages 32:1\u201332:17. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2021. 3 Andrei A. Bulatov and Amineh Dadsetan. Counting homomorphisms in plain exponential time. In Artur Czumaj, Anuj Dawar, and Emanuela Merelli, editors, 47th International Colloquium on Automata, Languages, and Programming, ICALP 2020, July 8-11, 2020, Saarbr\u00fccken, Germany (Virtual Conference), volume 168 of LIPIcs, pages 21:1\u201321:18. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2020. 4 Bruno Courcelle, Johann A. Makowsky, and Udi Rotics. Linear time solvable optimization problems on graphs of bounded clique-width. Theory Comput. Syst., 33(2):125\u2013150, 2000. 5 Bruno Courcelle and Stephan Olariu. Upper bounds to the clique width of graphs. Discrete Applied Mathematics, 101(1-3):77\u2013114, 2000. 6 Marek Cygan, Fedor V. Fomin, Alexander Golovnev, Alexander S. Kulikov, Ivan Mihajlin, Jakub Pachocki, and Arkadiusz Soca\u0142a. Tight lower bounds on graph embedding problems. J. ACM, 64(3):18:1\u201318:22, 2017. doi:10.1145/3051094. 7 Reinhard Diestel. Graph Theory, 4th Edition, volume 173 of Graduate texts in mathematics. Springer, 2012. 8 Willibald D\u00f6rfler. Primfaktorzerlegung und Automorphismen des Kardinalproduktes von Graphen. Glasnik Matemati\u010dki, 9:15\u201327, 1974. 9 L\u00e1szl\u00f3 Egri, D\u00e1niel Marx, and Pawe\u0142 Rz\u0105\u017cewski. Finding list homomorphisms from boundedtreewidth graphs to reflexive graphs: a complete complexity characterization. In 35th Symposium on Theoretical Aspects of Computer Science, STACS 2018, February 28 to March 3, 2018, Caen, France, pages 27:1\u201327:15, 2018. 10 Tom\u00e1s Feder, Pavol Hell, and Jing Huang. Bi-arc graphs and the complexity of list homomorphisms. J. Graph Theory, 42(1):61\u201380, 2003. doi:10.1002/jgt.10073. 11 Tom\u00e1s Feder and Moshe Y. Vardi. The computational structure of monotone monadic SNP and constraint satisfaction: A study through datalog and group theory. SIAM J. Comput., 28(1):57\u2013104, 1998. doi:10.1137/S0097539794266766. 12 Fedor V. Fomin, Pinar Heggernes, and Dieter Kratsch. Exact algorithms for graph homomorphisms. Theory Comput. Syst., 41(2):381\u2013393, 2007. doi:10.1007/s00224-007-2007-x. 13 Martin Grohe. The complexity of homomorphism and constraint satisfaction problems seen from the other side. J. ACM, 54(1):1:1\u20131:24, 2007.\n14 Richard H. Hammack, Wilfried Imrich, and Sandi Klav\u017ear. Handbook of product graphs. CRC press, 2011. 15 Pavol Hell and Jaroslav Ne\u0161et\u0159il. On the complexity of H-coloring. J. Comb. Theory, Ser. B, 48(1):92\u2013110, 1990. doi:10.1016/0095-8956(90)90132-J. 16 Pavol Hell and Jaroslav Ne\u0161et\u0159il. The core of a graph. Discret. Math., 109(1-3):117\u2013126, 1992. 17 Sang il Oum and Paul Seymour. Approximating clique-width and branch-width. Jour-\nnal of Combinatorial Theory, Series B, 96(4):514\u2013528, 2006. URL: https://www. sciencedirect.com/science/article/pii/S0095895605001528, doi:https://doi.org/10. 1016/j.jctb.2005.10.006.\n18 Russell Impagliazzo and Ramamohan Paturi. On the complexity of k-sat. J. Comput. Syst. Sci., 62(2):367\u2013375, 2001. 19 Russell Impagliazzo, Ramamohan Paturi, and Francis Zane. Which problems have strongly exponential complexity? J. Comput. Syst. Sci., 63(4):512\u2013530, 2001. URL: http://dx.doi. org/10.1006/jcss.2001.1774, doi:10.1006/jcss.2001.1774. 20 Michael Lampis. Finer tight bounds for coloring on clique-width. SIAM J. Discret. Math., 34(3):1538\u20131558, 2020. doi:10.1137/19M1280326. 21 Beno\u00eet Larose. Families of strongly projective graphs. Discuss. Math. Graph Theory, 22(2):271\u2013 292, 2002. doi:10.7151/dmgt.1175. 22 Beno\u00eet Larose and Claude Tardif. Strongly rigid graphs and projectivity. Multiple-Valued Logic, 7:339\u2013361, 2001. 23 Daniel Lokshtanov, D\u00e1niel Marx, and Saket Saurabh. Lower bounds based on the exponential time hypothesis. Bull. EATCS, 105:41\u201372, 2011. 24 Karolina Okrasa, Marta Piecyk, and Pawe\u0142 Rz\u0105\u017cewski. Full complexity classification of the list homomorphism problem for bounded-treewidth graphs. In Fabrizio Grandoni, Grzegorz Herman, and Peter Sanders, editors, 28th Annual European Symposium on Algorithms, ESA 2020, September 7-9, 2020, Pisa, Italy (Virtual Conference), volume 173 of LIPIcs, pages 74:1\u201374:24. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2020. doi:10.4230/LIPIcs. ESA.2020.74. 25 Karolina Okrasa and Pawe\u0142 Rz\u0105\u017cewski. Fine-grained complexity of the graph homomorphism problem for bounded-treewidth graphs. SIAM J. Comput., 50(2):487\u2013508, 2021. 26 Sang-il Oum. Approximating rank-width and clique-width quickly. In Dieter Kratsch, editor, Graph-Theoretic Concepts in Computer Science, pages 49\u201358, Berlin, Heidelberg, 2005. Springer Berlin Heidelberg. 27 Marta Piecyk and Pawe\u0142 Rz\u0105\u017cewski. Fine-grained complexity of the list homomorphism problem: Feedback vertex set and cutwidth. In Markus Bl\u00e4ser and Benjamin Monmege, editors, 38th International Symposium on Theoretical Aspects of Computer Science, STACS 2021, March 16-19, 2021, Saarbr\u00fccken, Germany (Virtual Conference), volume 187 of LIPIcs, pages 56:1\u201356:17. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2021. 28 Neil Robertson and Paul D. Seymour. Graph minors. II. algorithmic aspects of tree-width. J. Algorithms, 7(3):309\u2013322, 1986. 29 Pawe\u0142 Rz\u0105\u017cewski. Exact algorithm for graph homomorphism and locally injective graph homomorphism. Inf. Process. Lett., 114(7):387\u2013391, 2014. 30 Magnus Wahlstr\u00f6m. New plain-exponential time classes for graph homomorphism. Theory Comput. Syst., 49(2):273\u2013282, 2011. doi:10.1007/s00224-010-9261-z. 31 Tomasz \u0141uczak and Jaroslav Ne\u0161et\u0159il. Note on projective graphs. J. Graph Theory, 47(2):81\u201386, 2004."
        }
    ],
    "title": "The Fine-Grained Complexity of Graph Homomorphism Parameterized by Clique-Width",
    "year": 2022
}