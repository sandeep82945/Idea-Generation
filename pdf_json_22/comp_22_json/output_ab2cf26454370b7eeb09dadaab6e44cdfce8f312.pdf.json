{
    "abstractText": "This paper revisits Key-Policy Attribute-Based Encryption (KP-ABE), allowing delegation of keys, traceability of compromised keys, and key anonymity, as additional properties. Whereas delegation of rights has been addressed in the seminal paper by Goyal et al. in 2006, introducing KP-ABE, this feature has almost been neglected in all subsequent works in favor of better security levels. However, in multi-device scenarios, this is quite important to allow users to independently authorize their own devices, and thus to delegate their initial rights with possibly more restrictions to their everyday-use devices. But then, one may also require tracing capabilities in case of corrupted devices and anonymity for the users and their devices. To this aim, we define a new variant of KP-ABE including delegation, with switchable attributes, in both the ciphertexts and the keys, and new indistinguishability properties. We then provide a concrete and efficient instantiation with adaptive security under the sole SXDH assumption in the standard model. We eventually explain how this new primitive can address all our initial goals.",
    "authors": [
        {
            "affiliations": [],
            "name": "C\u00e9cile Delerabl\u00e9e"
        },
        {
            "affiliations": [],
            "name": "L\u00e9na\u00efck Gouriou"
        },
        {
            "affiliations": [],
            "name": "David Pointcheval"
        },
        {
            "affiliations": [],
            "name": "L\u00e9n\u00e4\u0131ck Gouriou"
        }
    ],
    "id": "SP:256c833ea1ef6715d01acb6c28e768cbf9f22e5e",
    "references": [
        {
            "authors": [
                "AT20. Nuttapong Attrapadung",
                "Junichi Tomida"
            ],
            "title": "Unbounded dynamic predicate compositions in ABE from standard assumptions",
            "venue": "Part III,",
            "year": 2020
        },
        {
            "authors": [
                "BDJR97. Mihir Bellare",
                "Anand Desai",
                "Eric Jokipii",
                "Phillip Rogaway"
            ],
            "title": "A concrete security treatment of symmetric encryption",
            "venue": "In 38th FOCS,",
            "year": 1997
        },
        {
            "authors": [
                "BN08. Dan Boneh",
                "Moni Naor"
            ],
            "title": "Traitor tracing with constant size ciphertext",
            "venue": "CCS",
            "year": 2008
        },
        {
            "authors": [
                "BS95. Dan Boneh",
                "James Shaw"
            ],
            "title": "Collusion-secure fingerprinting for digital data (extended abstract)",
            "venue": "In Don Coppersmith, editor, CRYPTO\u201995,",
            "year": 1995
        },
        {
            "authors": [
                "BSW06. Dan Boneh",
                "Amit Sahai",
                "Brent Waters"
            ],
            "title": "Fully collusion resistant traitor tracing with short ciphertexts and private keys",
            "venue": "In Serge Vaudenay, editor, EUROCRYPT 2006,",
            "year": 2006
        },
        {
            "authors": [
                "BW06. Dan Boneh",
                "Brent Waters"
            ],
            "title": "A fully collusion resistant broadcast, trace, and revoke system",
            "venue": "CCS",
            "year": 2006
        },
        {
            "authors": [
                "Benny Chor",
                "Amos Fiat",
                "Moni Naor"
            ],
            "title": "Tracing traitors",
            "venue": "Yvo Desmedt, editor, CRYPTO\u201994,",
            "year": 1994
        },
        {
            "authors": [
                "CGW15. Jie Chen",
                "Romain Gay",
                "Hoeteck Wee"
            ],
            "title": "Improved dual system ABE in prime-order groups via predicate encodings",
            "year": 2015
        },
        {
            "authors": [
                "CGW18. Jie Chen",
                "Junqing Gong",
                "Hoeteck Wee"
            ],
            "title": "Improved inner-product encryption with adaptive security and full attribute-hiding",
            "year": 2018
        },
        {
            "authors": [
                "CLL13. Jie Chen",
                "Hoon Wei Lim",
                "San Ling",
                "Huaxiong Wang",
                "Hoeteck Wee"
            ],
            "title": "Shorter IBE and signatures via asymmetric pairings",
            "venue": "PAIRING 2012,",
            "year": 2013
        },
        {
            "authors": [
                "GPSW06. Vipul Goyal",
                "Omkant Pandey",
                "Amit Sahai",
                "Brent Waters"
            ],
            "title": "Attribute-based encryption for finegrained access control of encrypted data",
            "venue": "CCS",
            "year": 2006
        },
        {
            "authors": [
                "KSW08. Jonathan Katz",
                "Amit Sahai",
                "Brent Waters"
            ],
            "title": "Predicate encryption supporting disjunctions, polynomial equations, and inner products",
            "venue": "In Nigel P. Smart, editor, EUROCRYPT 2008,",
            "year": 2008
        },
        {
            "authors": [
                "LLLW17. Xiaoyi Li",
                "Kaitai Liang",
                "Zhen Liu",
                "Duncan S. Wong"
            ],
            "title": "Attribute based encryption: Traitor tracing, revocation and fully security on prime order groups",
            "year": 2017
        },
        {
            "authors": [
                "Allison B. Lewko",
                "Tatsuaki Okamoto",
                "Amit Sahai",
                "Katsuyuki Takashima",
                "Brent Waters"
            ],
            "title": "Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption",
            "venue": "EUROCRYPT 2010,",
            "year": 2010
        },
        {
            "authors": [
                "LT18. Junzuo Lai",
                "Qiang Tang"
            ],
            "title": "Making any attribute-based encryption accountable, efficiently",
            "venue": "ESORICS 2018, Part II,",
            "year": 2018
        },
        {
            "authors": [
                "LW10. Allison B. Lewko",
                "Brent Waters"
            ],
            "title": "New techniques for dual system encryption and fully secure HIBE with short ciphertexts",
            "venue": "In Daniele Micciancio, editor, TCC 2010,",
            "year": 2010
        },
        {
            "authors": [
                "LW15. Zhen Liu",
                "Duncan S. Wong"
            ],
            "title": "Practical ciphertext-policy attribute-based encryption: Traitor tracing, revocation, and large universe",
            "venue": "ACNS 15,",
            "year": 2015
        },
        {
            "authors": [
                "OT08. Tatsuaki Okamoto",
                "Katsuyuki Takashima"
            ],
            "title": "Homomorphic encryption and signatures from vector decomposition",
            "venue": "PAIRING 2008,",
            "year": 2008
        },
        {
            "authors": [
                "OT10. Tatsuaki Okamoto",
                "Katsuyuki Takashima"
            ],
            "title": "Fully secure functional encryption with general relations from the decisional linear assumption",
            "venue": "In Tal Rabin, editor, CRYPTO 2010,",
            "year": 2010
        },
        {
            "authors": [
                "OT12a. Tatsuaki Okamoto",
                "Katsuyuki Takashima"
            ],
            "title": "Adaptively attribute-hiding (hierarchical) inner product encryption",
            "venue": "EUROCRYPT 2012,",
            "year": 2012
        },
        {
            "authors": [
                "OT12b. Tatsuaki Okamoto",
                "Katsuyuki Takashima"
            ],
            "title": "Fully secure unbounded inner-product and attributebased encryption",
            "venue": "ASIACRYPT 2012,",
            "year": 2012
        },
        {
            "authors": [
                "Tar03. G\u00e1bor Tardos"
            ],
            "title": "Optimal probabilistic fingerprint codes",
            "venue": "In 35th ACM STOC,",
            "year": 2003
        }
    ],
    "sections": [
        {
            "text": ""
        },
        {
            "heading": "1 Introduction",
            "text": "Multi-device scenarios have become prevalent in recent years, as it is now quite usual for people to own multiple phones and computers for personal and professional purposes. Users manage multiple applications across different devices, which brings forth new kinds of requirements. One must be able to granularly control what each of his devices can do for numerous applications, with a cost that is minimal for the user and the overall system. In particular, it is expected that one can control what each of its devices can access, for example restricting the rights to read sensitive documents from a professional laptop or phone during travel. Furthermore, if one suspects a key to be compromised, it should be possible to trace and change it without impacting the service. At the same time, these operations must happen transparently between different devices from the perspective of the user. This means each device should be autonomously configurable with regards to interactions with a central authority or to other devices. Eventually, one may also expect the delegated keys to be unlinkable, for some kind of anonymity for the users, even when devices are explored or corrupted by an adversary.\nUsual current authentication means defining a unique account for the user, providing the same access-rights to all the devices, is equivalent to a key-cloning approach, where the user clones his key in every device. In this case, all the devices of the same user are easily linked together, from their keys. This also prevents countermeasures against specific devices.\nKey-Policy Attribute-Based Encryption (KP-ABE), in the seminal paper of Goyal et al. [GPSW06], offers interesting solutions to these issues. Indeed, a policy is embedded inside each user\u2019s private key, any user can finely-tune the policy for each of his devices when delegating his keys, for any more restrictive policy. Besides, since keys become different in each device, one could expect to trace and revoke keys independently. However, delegation and tracing capabilities might look contradictory with current approaches, as explained below. But we bridge this gap and we also suggest complementing these features with a certain level of unlinkability between the different keys of a single user in order to better protect the privacy of users."
        },
        {
            "heading": "1.1 Related Work",
            "text": "Attribute-Based Encryption (ABE) has first been proposed in the paper by Goyal et al. [GPSW06]. In an ABE system, on the one hand, there is a policy P and, on the other hand, there are some attributes (Ai)i, and one can decrypt a ciphertext with a key if the\n2 policy P is satisfied on the attributes (Ai)i. They formally defined two approaches: Key-Policy Attribute-Based Encryption (KP-ABE), where the policy is specified in the decryption key and the attributes are associated to the ciphertext; Ciphertext-Policy Attribute-Based Encryption (CP-ABE), where the policy is specified in the ciphertext and the attributes are associated to the decryption key.\nIn their paper, they proposed a concrete construction of KP-ABE, for any monotonous access structure defined by a policy expressed as an access-tree with threshold internal gates and leaves associated to attributes. Attributes in the ciphertext are among a large universe U (not polynomially bounded). Given an access-tree T embedded in a private key, and a set of attributes \u0393 \u2282 U associated to a ciphertext, one can decrypt if and only if \u0393 satisfies T . Furthermore, they laid down the bases for delegation of users\u2019 private keys: one can delegate a new key, associated with a more restrictive access-tree.\nThis first paper on KP-ABE allows fine-grained access-control for multiple devices, dealing with delegation of keys for more restrictive policies. However, their approach for delegation of keys is conflictual with traceability. Indeed, on the one hand, for delegation to work properly, users must be given enough information in the public key to be able to produce valid delegated keys. On the other hand, for the tracing process to be effective in a black-box way, attackers must not be able to detect it. From our knowledge, this natural tension between the two features is in all the existing literature.\nPredicate Encryption/Inner-Product Encryption (IPE) were used by Okamoto and Takashima [OT10,OT12a,OT12b], together with LSSS: the receiver can read the message if a predicate is satisfied on some information in the decryption key and in the ciphertext. Innerproduct encryption (where the predicate checks whether the vectors embedded in the key and in the ciphertext are orthogonal) is the major tool. Their technique of Dual Pairing Vector Space (DPVS) provided two major advantages in KP-ABE applications: whereas previous constructions were only secure against selective attacks (the attributes in the challenge ciphertext were known before the publication of the keys), this technique allowed full security (a.k.a. adaptive security, where the attributes in the challenge ciphertext are chosen at the challenge-query time). In addition, it allows the notion of attribute-hiding (from [KSW08]) where no information leaks about the attributes associated to the ciphertext, except for the fact that they are accepted or not by the policies in the keys. It gets closer to our goals, as tracing might become undetectable. However, it does not seem any longer compatible with delegation, as the security proofs require all the key generation material to remain a secret information for the key issuer only.\nAs follow-up works, Chen et al. [CGW15,CGW18] designed multiple systems for IPE, with adaptive security, and explored full attribute-hiding with weaker assumptions and shorter ciphertexts and secret keys than in the previous work of Okamoto-Takashima. However, it does not fit our expectations on delegation, for the same reasons. On the other hand, Attrapadung also proposed new ABE schemes based on Pair Encoding Systems, which allow for all possible predicates and large universes [AT20], but this deals neither with delegation nor with any kind of attribute-hiding, as we would need."
        },
        {
            "heading": "1.2 Contributions",
            "text": "Since the approach of [OT12a] is close to our goal, with attribute-hiding that seems promising for traceability, we extend the original construction to make it compatible with delegation. We propose and prove, in the appendix D, a simple variant that handles delegation with adaptive security under the SXDH assumption. Then, we target delegatable KP-ABE with some additional attribute-hiding property in the ciphertext to allow undetectable tracing.\nTo this aim, we first detail one of the main limitation we have to overcome in order to get delegation and traceability: with the original approach of [GPSW06], attributes associated to\nthe ciphertext are explicitly stated as elements in the ciphertext. Removing some attributes can thus allow to single out specific private keys, but this is a public process, and thus incompatible with any tracing procedure, that would then be detectable by the adversary. To prevent that, our first contribution is the new primitive: Switchable-Attribute Key-Policy Attribute-Based Encryption (SA-KP-ABE), where one can invalidate some attributes in the ciphertext, without removing them. More precisely, we will bring new properties to the attributes in ciphertexts (for undetectable tracing) but also symmetrically to the leaves in keys (for anonymity).\nIn a SA-KP-ABE scheme, attributes in a ciphertext and leaves in an access-tree T defining the policy in a key can be switched in two different states: Attributes can be set to valid or invalid in a ciphertext at encryption time, using a secret encryption key. We then denote \u0393 = \u0393v \u00b7\u222a \u0393i, the set of attributes for a ciphertext, as the disjoint union of valid and invalid attributes; Leaves can be set to passive or active in the access-tree in a key at key generation time, using the master secret key. We also denote L = Lp \u00b7\u222a La, the set of leaves, as the disjoint union of passive and active leaves. A set of valid/invalid attributes \u0393 = \u0393v \u00b7\u222a \u0393i is accepted by an access-tree T with passive/active leaves L = Lp \u00b7\u222a La, if the tree T is accepting when all the leaves in L associated to an attribute in \u0393 are set to True, except if the leaf is active (in La) and the associated attribute invalid (in \u0393i). As already presented above, passive/active leaves in L are decided during the Key Generation procedure by the authority, using the master secret key. Then the keys are given to the users. During the Encryption procedure, a ciphertext is generated for attributes in \u0393 , but one might specify some attributes to be invalid by using a secret tracing key, which virtually and secretly switches some active leaves to False. Passive leaves are not impacted by invalid attributes.\nA second contribution is a concrete and efficient instantiation of SA-KP-ABE, with security proofs under the SXDH assumption. We eventually explain how one can deal with delegatable and traceable KP-ABE from such a primitive. As shown on Figure 1, our scheme is the first one that can combine both delegation and traceability of keys for KP-ABE. Computational assumptions are recalled in the next section and in the appendix A.1.\nOur first simple construction (in the appendix D) following the initial proof from [OT12a], only allows a polynomial-size universe for the attributes involved in the policy, encoded as a Boolean access-tree. This is due to a limited theorem with static attributes in the change of basis in the DPVS framework (see the next section). The latter construction will allow an unbounded universe for the attributes, with an adaptive variant in the change of basis (see Theorem 3). This result is of independent interest.\nDiscussions. Our setting bears common characteristics with recent KP-ABE approaches, but with major differences. First, Waters [Wat09] introduced the Dual System Encryption (DSE) technique, to improve the security level of KP-ABE, from selective security in [GPSW06] to adaptive security. In DSE, keys and ciphertexts can be set semi-functional, which is in the same vein as our active leaves in keys and invalid attributes in ciphertexts. However, DSE solely uses semi-functional keys and ciphertexts during the simulation, in the security proof, while our construction exploits them in the real-life construction. The security proof thus needs another layer of tricks.\n4 Second, the attribute-hiding notions are strong properties that have been well studied in different IPE works. However, one does not need to achieve such a strong result for tracing: Our (Distinct) Attribute-Indistinguishability is properly tailored for KP-ABE and tracing.\nFinally, we detail the advantage of our solution over a generic KEM approach that would combine a Delegatable KP-ABE and a black-box traitor-tracing scheme. This generic solution works if one is not looking for optimal bounds on collusion-resistance during tracing: The main issue with such a use of two independent schemes is that for each user, the KP-ABE key and the traitor-tracing key are not linked. As a consequence, the encryptions of the ABE part and the tracing part are done independently. The colluding users can all try to defeat the traitor tracing without restriction: the collusion-resistance for tracing in the global scheme will exactly be the collusion-resistance of the traitor tracing scheme. On the other hand, our construction will leverage the collusion-resistance of KP-ABE to improve the collusion-resistance of tracing: only players non-revoked by the KP-ABE part can try to defeat the traitor tracing part. Hence, during tracing, one can revoke arbitrary users thanks to the policy/attributes part. This allows to lower the number of active traitors, possibly keeping them below the collusion-resistance of the traitor tracing scheme, so that tracing remains effective."
        },
        {
            "heading": "2 Preliminaries",
            "text": "We will make use of a pairing-friendly setting G = (G1,G2,Gt, e,G1, G2, q), with a bilinear map e from G1 \u00d7 G2 into Gt, and G1 (respectively G2) is a generator of G1 (respectively G2). We will use additive notation for G1 and G2, and multiplicative notation in Gt.\nDefinition 1 (Decisional Diffie-Hellman Assumption). The DDH assumption in G, of prime order q with generator G, states that no algorithm can efficiently distinguish the two distributions\nD0 = {(a \u00b7G, b \u00b7G, ab \u00b7G), a, b $\u2190 Zq} D1 = {(a \u00b7G, b \u00b7G, c \u00b7G), a, b, c $\u2190 Zq}\nAnd we will denote by AdvddhG (T ) the best advantage an algorithm can get in distinguishing the two distributions within time bounded by T . Eventually, we will make the following more general Symmetric eXternal Diffie-Hellman (SXDH) Assumption which makes the DDH assumptions in both G1 and G2. Then, we define AdvsxdhG (T ) = max{AdvddhG1 (T ),Adv ddh G2 (T )}."
        },
        {
            "heading": "2.1 Dual Pairing Vector Spaces",
            "text": "We review the main points on Dual Pairing Vector Spaces (DPVS) to help following the intuition provided in this paper. Though not necessary for the comprehension of the paper, the full details are provided in the appendix C. DPVS have been used for schemes with adaptive security [OT08,LOS+10,OT10,OT12b] in the same vein as Dual System Encryption (DSE) [Wat09], in prime-order groups under the DLIN assumption. In [LW10], and some subsequence works, DSE was defined using pairings on composite-order elliptic curves. Then, prime-order groups have been used, for efficiency reasons, first with the DLIN assumption and then with the SXDH assumption [CLL+13]. In all theses situations, one exploited indistinguishability of sub-groups or sub-spaces. While we could have used any of them, the latter prime-order groups with the SXDH assumption lead to much more compact and efficient constructions.\nIn this paper, we thus use the SXDH assumption in a pairing-friendly setting G, with the additional law between elements X \u2208 Gn1 and Y \u2208 Gn2 : X\u00d7Y def = \u220f i e(Xi,Yi). If X = (Xi)i =\n~x \u00b7G1 \u2208 Gn1 and Y = (Yi)i = ~y \u00b7G2 \u2208 Gn2 : (~x \u00b7G1) \u00d7 (~y \u00b7G2) = X \u00d7Y = \u220f ie(Xi, Yi) = g \u3008~x,~y\u3009 t , where gt = e(G1, G2) and \u3008~x, ~y\u3009 is the inner product between vectors ~x and ~y. From any basis B = (~bi)i of Znq , we can define the basis B = (bi)i of Gn1 , where bi = ~bi \u00b7G1. Such a basis B is equivalent to a random invertible matrix B $\u2190 GLn(Zq), the matrix with\n5 ~bi as its i-th row. If we additionally use B\u2217 = (b\u2217i )i, the basis of Gn2 associated to the matrix B\u2032 = (B\u22121)>, as B \u00b7B\u2032> = In, bi \u00d7 b\u2217j = (~bi \u00b7G1)\u00d7 (~b\u2032j \u00b7G2) = g \u3008~bi,~b\u2032j\u3009 t = g \u03b4i,j t , where \u03b4i,j = 1 if i = j and \u03b4i,j = 0 otherwise, for i, j \u2208 {1, . . . , n}: B and B\u2217 are called Dual Orthogonal Bases. A pairing-friendly setting G with such dual orthogonal bases B and B\u2217 of size n is called a Dual Pairing Vector Space."
        },
        {
            "heading": "2.2 Change of Basis",
            "text": "Let us consider the basis U = (ui)i of Gn associated to a random matrix U \u2208 GLn(Zq), and the basis B = (bi)i of Gn associated to the product matrix BU , for any B \u2208 GLn(Zq). For a vector ~x \u2208 Znq , we denote (~x)B = \u2211 ixi \u00b7 bi. Then, (~x)B = (~y)U where ~y = ~x \u00b7 B. Hence, (~x)B = (~x \u00b7B)U and (~x \u00b7B\u22121)B = (~x)U where we denote B def = B \u00b7U. For any invertible matrix B, if U is a random basis, then B = B \u00b7 U is also a random basis. Furthermore, if we consider the random dual orthogonal bases U = (ui)i and U\u2217 = (u\u2217i )i of Gn1 and Gn2 respectively associated to a matrix U (which means that U is associated to the matrix U and U\u2217 is associated to the matrix U \u2032 = (U\u22121)>): the bases B = B \u00b7 U and B\u2217 = B\u2032 \u00b7 U\u2217, where B\u2032 = (B\u22121)>, are also random dual orthogonal bases:\nbi \u00d7 b\u2217j = g ~bi\u00b7~b\u2032\n> j\nt = g ~ui\u00b7B\u00b7(B\u22121)>\u00b7~u\u2032\n> j\nt = g ~ui\u00b7~u\u2032\n> j\nt = g \u03b4i,j t .\nAll the security proofs will exploit changes of bases, from one game to another game, with two kinds of changes: formal or computational.\nFormal Change of Basis, where we start from two dual orthogonal bases U and U\u2217 of dimension 2, and set\nB = ( 1 1 0 1 ) B\u2032 = ( 1 0 \u22121 1 ) B = B \u00b7 U B\u2217 = B\u2032 \u00b7 U\u2217\nthen, (x1, x2)U = (x1, x2 \u2212 x1)B (y1, y2)U\u2217 = (y1 + y2, y2)B\u2217 (1) (0, x2)U = (0, x2)B (0, y2)U\u2217 = (y2, y2)B\u2217 (2)\nIn practice, this change of basis makes b1 = u1 + u2, b2 = u2, b \u2217 1 = u \u2217 1, b \u2217 2 = \u2212u\u22171 + u\u22172. If u1/b1 and u \u2217 2/b \u2217 2 are kept private, the adversary cannot know whether we are using (U,U\u2217) or (B,B\u2217). This will be used to duplicate some component, from a game to another game, as shown in the above example (2).\nComputational Change of Basis, where we define vectors in a dual orthogonal basis (U,U\u2217) of dimension 2. From a Diffie-Hellman challenge (a \u00b7G1, b \u00b7G1, c \u00b7G1), where c = ab+ \u03c4 mod q with either \u03c4 = 0 or \u03c4\n$\u2190 Z\u2217q , one can set\nB = ( 1 a 0 1 ) B\u2032 = ( 1 0 \u2212a 1 ) B = B \u00b7 U B\u2217 = B\u2032 \u00b7 U\u2217 (3)\nthen, in basis (B,B\u2217), we implicitly define\n(b, c)U + (x1, x2)B = (b, c\u2212 ab)B + (x1, x2)B = (x1 + b, x2 + \u03c4)B (y1, y2)U\u2217 = (y1 + ay2, y2)B\u2217\nwhere \u03c4 can be either 0 or random, according to the Diffie-Hellman challenge. And the two situations are indistinguishable. We should however note that in this case, b\u22172 cannot be computed, as a \u00b7G2 is not known. This will not be a problem if this element is not provided to the adversary.\n6 Partial Change of Basis: in the constructions, bases will be of higher dimension, but we will often only change a few basis vectors. We will then specify the vectors as indices to the change of basis matrix: in a space of dimension n,\nB = ( 1 a 0 1 ) 1,2\nB\u2032 = ( 1 0 \u2212a 1 ) 1,2\nB = B \u00b7 U B\u2217 = B\u2032 \u00b7 U\u2217 (4)\nmeans that only the two first coordinates are impacted, and thus b1,b2 and b \u2217 1,b \u2217 2. We complete the matrices B and B\u2032 with the identity matrix: bi = ui and b \u2217 i = u \u2217 i , for i \u2265 3."
        },
        {
            "heading": "2.3 Particular Changes",
            "text": "The security proofs will rely on specific indistinguishable modifications that we detail here. We will demonstrate the first of them to give the intuition of the methodology to the reader. A full demonstration for the other modifications can be found in the appendix C.5. These results hold under the DDH assumption in G1, (but it can also be applied in G2), on random dual orthogonal bases B and B\u2217.\nWith the above change of basis provided in equation (4), we can compute B = (bi)i, as we know a \u00b7G1 and all the scalars in U :\nbi = \u2211 k Bi,k \u00b7 uk bi,j = \u2211 k Bi,k \u00b7 uk,j = \u2211 k Bi,kUk,j \u00b7G1 = \u2211 k Uk,j \u00b7 (Bi,j \u00b7G1).\nHence, to compute bi, one needs all the scalars in U , but only the group elements Bi,j \u00b7G1, and so G1 and a \u00b7G1. This is the same for B\u2217, except for the vector b\u22172 as a \u00b7G2 is missing. One can thus publish B and B\u2217\\{b\u22172}.\nIndistinguishability of Sub-Spaces (3). As already remarked, for such a fixed matrix B, if U is random, so is B too, and (~x)B = (~x \u00b7B)U, so (~x)U = (~x \u00b7B\u22121)B. Note that B\u22121 = B\u2032>. So, (b, c, 0, . . . , 0)U = (b, c\u2212 ab, 0, . . . , 0)B, then\n(b, c, 0, . . . , 0)U + (x1, x2, x3, . . . , xn)B = (x1 + b, x2 + \u03c4, x3, . . . , xn)B\nwhere \u03c4 can be either 0 or random. Note that whereas we cannot compute b\u22172, this does not exclude this second component in the computed vectors, as we can use (y1, . . . , yn)U\u2217 = (y1 + ay2, y2, . . . , yn)B\u2217 .\nTheorem 2. Under the DDH Assumption in G1, for random dual orthogonal bases B and B\u2217, once having seen B and B\u2217\\{b\u22172}, and any vector (y1, y2, . . . , yn)B\u2217, for any y2, . . . , yn \u2208 Zq, but unknown random y1\n$\u2190 Zq, one cannot distinguish (x1, x\u20322, x3, . . . , xn)B and (x1, x2, x3, . . . , xn)B, for any x2, . . . , xn \u2208 Zq, but unknown random x1, x\u20322 $\u2190 Zq.\nSome scalar coordinates can be chosen (and thus definitely known) by the adversary, whereas some other must be random. Eventually the adversary only sees the vectors in Gn1 and Gn2 . We now directly state two other properties for which the demonstration (which works similarly as the SubSpace-Ind one) can be found in the appendix C.5.\nSwap-Ind Property, on (B,B\u2217)1,2,3: from the view of B and B\u2217\\{b\u22171,b\u22172}, and the vector (y1, y1, y3, . . . , yn)B\u2217 , for any y1, y3, . . . , yn \u2208 Zq, one cannot distinguish the vectors (x1, 0, x3, x4, . . . , xn)B and (0, x1, x3, x4, . . . , xn)B, for any x1, x4, . . . , xn \u2208 Zq, but unknown random x3\n$\u2190 Zq. (Static) Index-Ind Property, on (B,B\u2217)1,2,3: from the view of B and B\u2217\\{b\u22173}, for fixed t 6=\np \u2208 Zq, and the (\u03c0 \u00b7 (t,\u22121), y3, . . . , yn)B\u2217 , for any y3, . . . , yn \u2208 Zq, but unknown random \u03c0\n$\u2190 Zq, one cannot distinguish (\u03c3 \u00b7 (1, p), x3, x4, . . . , xn)B and (\u03c3 \u00b7 (1, p), x\u20323, x4, . . . , xn)B, for any x\u20323, x3, x4, . . . , xn \u2208 Zq, but unknown random \u03c3 $\u2190 Zq.\n7 We stress that, in this static version, t and p must be fixed, and known before the simulation starts in the security analysis, as they will appear in the matrix B. In the Okamoto-Takashima\u2019s constructions [OT10,OT12b], such values t and p were for bounded names of attributes. In the following, we want to consider unbounded attributes, we thus conclude this section with an adaptive version, where t and p do not need to be known in advance, from a large universe:\nTheorem 3 (Adaptive Index-Ind Property). Under the DDH Assumption in G1, for random dual orthogonal bases B and B\u2217, once having seen B and B\u2217\\{b\u22173}, and (\u03c0 \u00b7(t,\u22121), y3, 0, 0, y6, . . . , yn)B\u2217, for any t, y3, y6, . . . , yn \u2208 Zq, but unknown random \u03c0 $\u2190 Zq, one cannot distinguish (\u03c3 \u00b7(1, p), x3, 0, 0, x6, . . . , xn)B and (\u03c3 \u00b7(1, p), x\u20323, 0, 0, x6, . . . , xn)B, for any x3, x\u20323, x6, . . . , xn \u2208 Zq, and p 6= t, but unknown random \u03c3 $\u2190 Zq, with an advantage better than 8 \u00d7 AdvddhG1 (T ) + 4 \u00d7 AdvddhG2 (T ), where T is the running time of the adversary.\nProof. For the sake of simplicity, we will prove indistinguishability between (\u03c3 \u00b7 (1, p), 0, 0, 0)B and (\u03c3 \u00b7 (1, p), x3, 0, 0)B, in dimension 5 only, instead of n. Additional components could be chosen by the adversary. Applied twice, we obtain the above theorem. The proof follows a sequence of games.\nGame G0: The adversary can choose p 6= t and x3, y3 in Zq, but \u03c0, \u03c3 $\u2190 Zq are unknown to it:\nk\u2217 = (\u03c0(t,\u22121), y3, 0, 0)B\u2217 c0 = (\u03c3(1, p), 0, 0, 0)B c1 = (\u03c3(1, p), x3, 0, 0)B\nVectors (b1,b2,b3,b \u2217 1,b \u2217 2) and (cb,k \u2217) are provided to the adversary that must decide on b: Adv0 is its advantage in correctly guessing b. Only k\n\u2217 and c0 will be modified in the following games, so that eventually c0 = c1 in the last game, which leads to perfect indistinguishability.\nGame G1: We replicate the first sub-vector (t,\u22121), with \u03c1 $\u2190 Zq, in the hidden components: k\u2217 = (\u03c0(t,\u22121), y3, \u03c1(t,\u22121))B\u2217 . To show the indistinguishability, one applies the SubSpaceInd property on (B\u2217,B)1,2,4,5. Indeed, we can consider a triple (a \u00b7 G2, b \u00b7 G2, c \u00b7 G2), where c = ab + \u03c4 mod q with either \u03c4 = 0 or random, which are indistinguishable under the DDH assumption in G2. Let us assume we start from random dual orthogonal bases (V,V\u2217). We define\nB\u2032 =  1 0 a 0 0 1 0 a 0 0 1 0 0 0 0 1  1,2,4,5\nB =  1 0 0 0 0 1 0 0 \u2212a 0 1 0 0 \u2212a 0 1  1,2,4,5\nB\u2217 = B\u2032 \u00b7 V\u2217 B = B \u00b7 V\nThe vectors b4,b5 can not be computed, but they are hidden from the adversary\u2019s view, and are not used in any vector. We compute the new vectors:\nk\u2217 = (b(t,\u22121), y3, c(t,\u22121))V\u2217 c0 = (\u03c3(1, p), 0, 0, 0)B = (b(t,\u22121), y3, (c\u2212 ab)(t,\u22121)B\u2217 = (b(t,\u22121), y3, \u03c4(t,\u22121)B\u2217\nOne can note that when \u03c4 = 0, this is the previous game, and when \u03c4 random, we are in the new game, with \u03c0 = b and \u03c1 = \u03c4 : Adv0 \u2212 Adv1 \u2264 AdvddhG2 (T ).\nGame G2: We replicate the non-orthogonal sub-vector (1, p), with \u03b8 $\u2190 Zq:\nk\u2217 = (\u03c0(t,\u22121), y3, \u03c1(t,\u22121))B\u2217 c0 = (\u03c3(1, p), 0, \u03b8(1, p))B\nTo show the indistinguishability, one applies the SubSpace-Ind property on (B,B\u2217)1,2,4,5. Indeed, we can consider a triple (a \u00b7G1, b \u00b7G1, c \u00b7G1), where c = ab+ \u03c4 mod q with either \u03c4 = 0\n8 or random, which are indistinguishable under the DDH assumption in G1. Let us assume we start from random dual orthogonal bases (V,V\u2217). Then we define the matrices\nB =  1 0 a 0 0 1 0 a 0 0 1 0 0 0 0 1  1,2,4,5\nB\u2032 =  1 0 0 0 0 1 0 0 \u2212a 0 1 0 0 \u2212a 0 1  1,2,4,5\nB = B \u00b7 V B\u2217 = B\u2032 \u00b7 V\u2217\nThe vectors b\u22174,b \u2217 5 can not be computed, but they are hidden from the adversary\u2019s view. We compute the new vectors in V and V\u2217:\nc0 = (b(1, p), 0, c(1, p))V k \u2217 = (\u03c0\u2032(t,\u22121), y3, \u03c1(t,\u22121))V\u2217\n= (b(1, p), 0, (c\u2212 ab)(1, p))B = ((\u03c0\u2032 + a\u03c1)(t,\u22121), y3, \u03c1(t,\u22121))B\u2217 = (b(1, p), 0, \u03c4(1, p))B\nOne can note that when \u03c4 = 0, this is the previous game, and when \u03c4 random, we are in the new game, with \u03c0 = \u03c0\u2032 + a\u03c1, \u03c3 = b, and \u03b8 = \u03c4 : Adv1 \u2212 Adv2 \u2264 AdvddhG1 (T ).\nGame G3: We randomize the two non-orthogonal sub-vectors, with random scalars u1, u2, v1, v2 $\u2190 Zp:\nk\u2217 = (\u03c0(t,\u22121), y3, u1, u2)B\u2217 c0 = (\u03c3(1, p), 0, v1, v2)B\nTo show the indistinguishability, one makes a formal change of basis on (B\u2217,B)4,5, with a random unitary matrix Z, with z1z4 \u2212 z2z3 = 1:\nB\u2032 = Z = ( z1 z2 z3 z4 ) 4,5\nB = ( z4 \u2212z3 \u2212z2 z1 ) 4,5\nB\u2217 = B\u2032 \u00b7 V\u2217 B = B \u00b7 V\nThis only impacts the hidden vectors (b4,b5), (b \u2217 4,b \u2217 5). If one defines k \u2217 and c0 in (V\u2217,V), this translates in (B\u2217,B):\nk\u2217 = (\u03c0(t,\u22121), y3, \u03c1(t,\u22121))V\u2217 = (\u03c0(t,\u22121), y3, \u03c1(tz1 \u2212 z3, tz2 \u2212 z4))B\u2217 c0 = (\u03c3(1, p), 0, \u03b8(1, p))V = (\u03c3(1, p), 0, \u03b8(z4 \u2212 pz2,\u2212z3 + pz1))B\nLet us consider random u1, u2, v1, v2 $\u2190 Zp, and solve the system in z1, z2, z3, z4. This system admits a unique solution, if and only if t 6= p. And with random \u03c1, \u03b8, and random unitary matrix Z,\nk\u2217 = (\u03c0(t,\u22121), y3, u1, u2)B\u2217 c0 = (\u03c3(1, p), 0, v1, v2)B\nwith random scalars u1, u2, v1, v2 $\u2190 Zp. In bases (V,V\u2217), we are in the previous game, and in bases (B,B\u2217), we are in the new game, if p 6= t: Adv2 = Adv3.\nGame G4: We now randomize the third component in c0:\nk\u2217 = (\u03c0(t,\u22121), y3, u1, u2)B\u2217 c0 = (\u03c3(1, p), x3, v1, v2)B\nTo show the indistinguishability, one applies the SubSpace-Ind property on (B,B\u2217)4,3. Indeed, we can consider a triple (a \u00b7 G1, b \u00b7 G1, c \u00b7 G1), where c = ab + \u03c4 mod q with either \u03c4 = 0 or \u03c4 = x3, which are indistinguishable under the DDH assumption in G1. Let us assume we start from random dual orthogonal bases (V,V\u2217). Then we define the matrices\nB = ( 1 0 a 1 ) 3,4\nB\u2032 = ( 1 \u2212a 0 1 ) 3,4\nB = B \u00b7 V B\u2217 = B\u2032 \u00b7 V\u2217\n9 The vectors b\u22173 can not be computed, but it is not into the adversary\u2019s view. We compute the new vectors:\nk\u2217 = (\u03c0(t,\u22121), y3, u\u20321, u2)V\u2217 c0 = (\u03c3(1, p), c, b, v2)V = (\u03c0(t,\u22121), y3, u\u20321 + ay3, u2)B\u2217 = (\u03c3(1, p), c\u2212 ab, b, v2)B\n= (\u03c3(1, p), \u03c4, b, v2)B\nOne can note that when \u03c4 = 0, this is the previous game, and when \u03c4 = x3, we are in the new game, with v1 = b and u1 = u \u2032 1 + ay3: Adv3 \u2212 Adv4 \u2264 2\u00d7 AdvddhG1 (T ), by applying twice the Diffie-Hellman indistinguishability game.\nWe can undo successively games G3, G2, and G1 to get, after a gap bounded by Adv ddh G1 (t) + AdvddhG2 (t): k \u2217 = (\u03c0(t,\u22121), y3, 0, 0)B\u2217 and c0 = (\u03c3(1, p), x3, 0, 0)B. In this game, the advantage of any adversary is 0. The global difference of advantages is bounded by 4\u00b7AdvddhG1 (T )+2\u00b7Adv ddh G2 (T ), which concludes the proof."
        },
        {
            "heading": "3 Key-Policy ABE with Switchable Attributes",
            "text": "Classical definitions and properties for KP-ABE, and more details about policies, are reviewed in the appendix A.2, following [GPSW06]. We recall here the main notions on labeled access-trees as a secret sharing to embed a policy in keys."
        },
        {
            "heading": "3.1 Policy Definition",
            "text": "Access Trees. As in the seminal paper [GPSW06], we will consider an access-tree T to model the policy on attributes in an unbounded universe U , but with only AND and OR gates instead of more general threshold gates: an AND-gate being an n-out-of-n gate, whereas an OR-gate is a 1-out-of-n gate. This is also a particular case of the more general LSSS technique. Nevertheless, such an access-tree with only AND and OR gates is as expressive as with any threshold gates or LSSS. For any monotonic policy, we define our access-tree in the following way: T is a rooted labeled tree from the root \u03c1, with internal nodes associated to AND and OR gates and leaves associated to attributes. More precisely, for each leaf \u03bb \u2208 L, A(\u03bb) \u2208 U is an attribute, and any internal node \u03bd \u2208 N is labeled with a gate G(\u03bd) \u2208 {AND,OR} as an AND or an OR gate to be satisfied among the children in children(\u03bd). We will implicitly consider that any access-tree T is associated to the attribute-labeling A of the leaves and the gate-labeling G of the nodes. For any leaf \u03bb \u2208 L of T or internal node \u03bd \u2208 N\\{\u03c1}, the function parent links to the parent node: \u03bd \u2208 children(parent(\u03bd)) and \u03bb \u2208 children(parent(\u03bb)).\nOn a given list \u0393 \u2286 U of attributes, each leaf \u03bb \u2208 L is either satisfied (considered or set to True), if A(\u03bb) \u2208 \u0393 , or not (ignored or set to False) otherwise: we will denote L\u0393 the restriction of L to the satisfied leaves in the tree T (corresponding to an attribute in \u0393 ). Then, for each internal node \u03bd, one checks whether all children (AND-gate) or at least one of the children (ORgate) are satisfied, from the attributes associated to the leaves, and then \u03bd is itself satisfied or not. By induction, if for each node \u03bd we denote T\u03bd the subtree rooted at the node \u03bd, T = T\u03c1. A leaf \u03bb \u2208 L is satisfied if \u03bb \u2208 L\u0393 then, recursively, T\u03bd is satisfied if the AND/OR-gate associated to \u03bd via G(\u03bd) is satisfied with respect to status of the children in children(\u03bd): we denote T\u03bd(\u0393 ) = 1 when the subtree is satisfied, and 0 otherwise:\nT\u03bb(\u0393 ) = 1 iff \u03bb \u2208 L\u0393 for any leaf \u03bb \u2208 L T\u03bd(\u0393 ) = 1 iff \u2200\u03ba \u2208 children(\u03bd), T\u03ba(\u0393 ) = 1 when G(\u03bd) = AND T\u03bd(\u0393 ) = 1 iff \u2203\u03ba \u2208 children(\u03bd), T\u03ba(\u0393 ) = 1 when G(\u03bd) = OR\n10\nEvaluation Pruned Trees. In the above definition, we considered an access-tree T on leaves L and a set \u0393 of attributes, with the satisfiability T (\u0393 ) = 1 where the predicate defined by T is true when all the leaves \u03bb \u2208 L\u0393 are set to True. A \u0393 -evaluation tree T \u2032 \u2282 T is a pruned version of T , where one children only is kept to OR-gate nodes, down to the leaves, so that T \u2032(\u0393 ) = 1. Basically, we keep a skeleton with only necessary True leaves to evaluate the internal nodes up to the root. We will denote EPT(T , \u0393 ) the set of all the evaluation pruned trees of T with respect to \u0393 . EPT(T , \u0393 ) is non-empty if and only if T (\u0393 ) = 1.\nFigure 2 gives an illustration of such an access-tree for a policy: when the colored leaves {\u03bb1, \u03bb3, \u03bb5, \u03bb8, \u03bb9, \u03bb10} are True, the tree is satisfied, and there are two possible evaluation pruned trees: down to the leaves {\u03bb1, \u03bb3, \u03bb5, \u03bb8} or {\u03bb1, \u03bb3, \u03bb5, \u03bb9, \u03bb10}.\nPartial Order on Policies. Delegation will only be possible for a more restrictive access-tree, or a less accessible tree T \u2032, than T with the following partial order: T \u2032 \u2264 T , if and only if for any subset \u0393 of attributes, T \u2032(\u0393 ) = 1 =\u21d2 T (\u0393 ) = 1. In our case of access-trees, a more restrictive access-tree is, for each node \u03bd: if G(\u03bd) = AND, one or more children are added (i.e., more constraints); if G(\u03bd) = OR, one or more children are removed (i.e., less flexibility); the node \u03bd is moved one level below as a child of an AND-gate at node \u03bd \u2032, with additional sub-trees as children to this AND-gate (i.e., more constraints)."
        },
        {
            "heading": "3.2 Labeling of Access-Trees",
            "text": "Labeled Access-Trees. We will label such trees with integers so that some labels on the leaves will be enough/necessary (according to the policy) to recover the labels above, up to the root, as illustrated on Figure 3.\nDefinition 4 (Random y-Labeling). For an access-tree T and any y \u2208 Zp, the probabilistic algorithm \u039by(T ) sets a\u03c1 \u2190 y for the root, and then in a top-down manner, for each internal node \u03bd, starting from the root: if G(\u03bd) = AND, with n children, a random n-out-of-n sharing of a\u03bd is associated to each children; if G(\u03bd) = OR, with n children, each children is associated to the value a\u03bd .\nAlgorithm \u039by(T ) outputs \u039by = (a\u03bb)\u03bb\u2208L, for all the leaves \u03bb \u2208 L of the tree T . Because of the linearity, from any y-labeling (a\u03bb)\u03bb of the tree T , and a random z-labeling (b\u03bb)\u03bb of T , the sum (a\u03bb + b\u03bb)\u03bb is a random (y+ z)-labeling of T . In particular, from any y-labeling (a\u03bb)\u03bb of T , and a random zero-labeling (b\u03bb)\u03bb of T , the values c\u03bb \u2190 a\u03bb + b\u03bb provide a random y-labeling of T . Labels on leaves are a secret sharing of the root that allows reconstruction of the secret if and only if the policy is satisfied, as explained below:\n11\nProperties of Labelings. For an acceptable set \u0393 for T and a labeling \u039by of T for a random y, given only (a\u03bb)\u03bb\u2208L\u0393 , one can reconstruct y = a\u03c1. Indeed, as T (\u0393 ) = 1, we use an evaluation pruned tree T \u2032 \u2208 EPT(T , \u0393 ). Then, in a bottom-up way, starting from the leaves, one can compute the labels of all the internal nodes, up to the root.\nOn the other hand, when T (\u0393 ) = 0, with a random labeling \u039by of T for a random y, given only (a\u03bb)\u03bb\u2208L\u0393 , y is unpredictable: for any y, y\n\u2032 \u2208 Zp, Dy and Dy\u2032 are perfectly indistinguishable, where Dy = {(a\u03bb)\u03bb\u2208L\u0393 , (a\u03bb)\u03bb\n$\u2190 \u039by(T )}. Intuitively, given (a\u03bb)\u03bb\u2208L\u0393 , as T (\u0393 ) = 0, one can complete the labeling so that the label of the root is any y.\nFor our notion of Attribute-Indistinguishability, we need to identify a specific property called independent leaves, which describes leaves for which the secret share leaks no information in any of the other leaves in the access-tree.\nDefinition 5 (Independent Leaves). Given an access-tree T and a set \u0393 so that T (\u0393 ) = 0, we call independent leaves, in L\u0393 with respect to T , the leaves \u00b5 such that, given only (a\u03bb)\u03bb\u2208L\u0393 \\{\u00b5}, a\u00b5 is unpredictable: for any y, the two distributions D $ y(\u0393 ) = {(a\u03bb)\u03bb\u2208L\u0393 } and Dy(\u0393, \u00b5) = {(b\u00b5) \u222a (a\u03bb)\u03bb\u2208L\u0393 \\{\u00b5}} are perfectly indistinguishable, where (a\u03bb)\u03bb $\u2190 \u039by(T ) and b\u00b5 $\u2190 Zp.\nWith the illustration on Figure 3, with non-satisfied tree, when only colored leaves are set to True, leaves \u03bb3 and \u03bb5 are independent among the True leaves {\u03bb3, \u03bb5, \u03bb8, \u03bb9, \u03bb10}. But leaves \u03bb8, \u03bb9 and \u03bb10 are not independent as a\u03bb8 = a\u03bb9 + a\u03bb10 mod 7 for any random labeling. Intuitively, given (a\u03bb)\u03bb\u2208L\u0393 \\{\u00b5} and any a\u00b5, one can complete it into a valid labeling (with any random root label y as T (\u0393 ) = 0), for \u00b5 \u2208 {3, 5}, but not for \u00b5 \u2208 {8, 9, 10}."
        },
        {
            "heading": "3.3 Switchable Leaves and Attributes",
            "text": "For a Key-Policy ABE with Switchable Attributes (SA-KP-ABE), leaves in the access-tree can be made active or passive, and attributes in the ciphertext can be made valid or invalid. We thus enhance the access-tree T into T\u0303 = (T ,La,Lp), where the implicit set of leaves L = La \u00b7\u222aLp is now the explicit disjoint union of the active-leaf and passive-leaf sets. Similarly, a ciphertext will be associated to the pair (\u0393v, \u0393i), also referred as a disjoint union \u0393 = \u0393v \u00b7\u222a \u0393i, of the valid-attribute and invalid-attribute sets.\nWe note T\u0303 (\u0393v, \u0393i) = 1 if there is an evaluation pruned tree T \u2032 of T that is satisfied by \u0393 = \u0393v \u00b7\u222a\u0393i (i.e., T \u2032 \u2208 EPT(T , \u0393 )), with the additional condition that all the active leaves in T \u2032 correspond only to valid attributes in \u0393v: \u2203T \u2032 \u2208 EPT(T , \u0393 ), \u2200\u03bb \u2208 T \u2032 \u2229 La, A(\u03bb) \u2208 \u0393v. In other words, this means that an invalid attribute in the ciphertext should be considered as inexistent for active leaves, but only for those leaves.\nWe also have to enhance the partial order on T to T\u0303 , so that we can deal with delegation: T\u0303 \u2032 = (T \u2032,L\u2032a,L\u2032p) \u2264 T\u0303 = (T ,La,Lp) if and only if T \u2032 \u2264 T , L\u2032a \u2229Lp = L\u2032p \u2229La = \u2205 and L\u2032a \u2286 La. More concretely, T \u2032 must be more restrictive, existing leaves cannot change their passive or active status, and new leaves can only be passive."
        },
        {
            "heading": "3.4 Key-Policy Attribute-Based Encapsulation with Switchable Attributes",
            "text": "We can now define the algorithms of an SA-KP-ABE, with the usual description of Key Encapsulation Mechanism, that consists in generating an ephemeral key K and its encapsulation C. The encryption of the actual message under the key K, using a symmetric encryption scheme is then appended to C. We will however call C the ciphertext, and K the encapsulated key in C. In our definitions, there are two secret keys: the master secret key MK for the generation of users\u2019 keys, and the secret key SK for running the advanced encapsulation with invalid attributes:\nSetup(1\u03ba). From the security parameter \u03ba, the algorithm defines all the global parameters PK, the secret key SK and the master secret key MK;\n12\nKeyGen(MK, T\u0303 ). The algorithm outputs a key dkT\u0303 which enables the user to decapsulate keys generated under a set of attributes \u0393 = \u0393v \u00b7\u222a \u0393i if and only if T\u0303 (\u0393v, \u0393i) = 1; Delegate(dkT\u0303 , T\u0303 \u2032). Given a key dkT\u0303 , generated from either the KeyGen or the Delegate algo-\nrithms, for a policy T\u0303 and a more restrictive policy T\u0303 \u2032 \u2264 T\u0303 , the algorithm outputs a decryption key dkT \u2032 ; Encaps(PK, \u0393 ). For a set \u0393 of (valid only) attributes, the algorithm generates the ciphertext C and an encapsulated key K; Encaps\u2217(SK, \u0393v, \u0393i). For a pair (\u0393v, \u0393i) of disjoint sets of valid/invalid attributes, the algorithm generates the ciphertext C and an encapsulated key K;\nDecaps(dkT\u0303 , C). Given the key dkT\u0303 from either KeyGen or Delegate, and the ciphertext C, the algorithm outputs the encapsulated key K.\nWe stress that fresh keys (from the KeyGen algorithm) and delegated keys (from the Delegate algorithm) are of the same form, and can both be used for decryption and can both be delegated. This allows multi-hop delegation.\nOn the other hand, one can note the difference between Encaps with PK and Encaps\u2217 with SK, where the former runs the latter on the pair (\u0393, \u2205). And as \u0393i = \u2205, the public key is enough. This is thus still a public-key encryption scheme when only valid attributes are in the ciphertext, but the invalidation of some attributes require the secret key SK. For the advanced reader, this will lead to secret-key traceability, as only the owner of SK will be able to invalidate attributes for the tracing procedure (as explained in Section 5). For correctness, the Decaps algorithm should output the encapsulated key K if and only if C has been generated for a pair (\u0393v, \u0393i) that satisfies the policy T\u0303 of the decryption key dkT\u0303 : T\u0303 (\u0393v, \u0393i) = 1. The following security notion enforces this property. But some other indistinguishability notions need to be defined in order to be able to exploit these switchable attributes in more complex protocols."
        },
        {
            "heading": "3.5 Security Notions",
            "text": "For the sake of simplicity, we focus on one-challenge definitions (one encapsulation with Real-orRandom encapsulated key, one user key with Real-or-All-Passive leaves, and one encapsulation with Real-or-All-Valid attributes), in the same vein as the Find-then-Guess security game. But the adversary could generate additional values, as they can either be publicly generated or an oracle is available. Then, the definitions can be turned into multi-challenge security games, with an hybrid proof, as explained in [BDJR97].\nDefinition 6 (Delegation-Indistinguishability for SA-KP-ABE). Del-IND security for SAKP-ABE is defined by the following game:\nInitialize: The challenger runs the Setup algorithm of SA-KP-ABE and gives the public parameters PK to the adversary;\nOracles: The following oracles can be called in any order and any number of times, except for RoREncaps which can be called only once. OKeyGen(T\u0303 ): this models a KeyGen-query for any access-tree T\u0303 = (T ,La,Lp). It generates\nthe decryption key but only outputs the index k of the key; ODelegate(k, T\u0303 \u2032): this models a Delegate-query for any more restrictive access-tree T\u0303 \u2032 \u2264 T\u0303 ,\nfor the k-indexed generated decryption key for T\u0303 . It generates the decryption key but only outputs the index k\u2032 of the new key;\nOGetKey(k): the adversary gets back the k-indexed decryption key generated by OKeyGen or ODelegate oracles; OEncaps(\u0393v, \u0393i): The adversary may be allowed to issue Encaps \u2217-queries, with (K,C) \u2190\nEncaps\u2217(SK, \u0393v, \u0393i), and C is returned;\n13\nRoREncaps(\u0393v, \u0393i): The adversary submits a unique real-or-random encapsulation query on a set of attributes \u0393 = \u0393v \u00b7\u222a \u0393i. The challenger asks for an encapsulation query on (\u0393v, \u0393i) and receives (K0, C). It also generates a random key K1. It eventually flips a random coin b, and outputs (Kb, C) to the adversary; Finalize(b\u2032): The adversary outputs a guess b\u2032 for b. If for some access-tree T\u0303 \u2032 corresponding to a key asked to the OGetKey-oracle, T\u0303 \u2032(\u0393v, \u0393i) = 1, on the challenge set (\u0393v, \u0393i), \u03b2 $\u2190 {0, 1}, otherwise one sets \u03b2 = b\u2032. One outputs \u03b2.\nAdvdel-ind(A) denotes the advantage of an adversary A in this game.\nIn the basic form of Del-IND-security, where Encaps\u2217 encapsulations are not available, the RoREncaps-oracle only allows \u0393i = \u2205, and no OEncaps-oracle is available. But as Encaps (with \u0393i = \u2205) is a public-key algorithm, the adversary can generate valid ciphertexts by himself. We will call it \u201cDel-IND-security for Encaps\u201d. For the more advanced security level, RoREncapsquery will be allowed on any pair (\u0393v, \u0393i), with the additional OEncaps-oracle. We will call it \u201cDel-IND-security for Encaps\u2217\u201d.\nWith these disjoint unions of L = La \u00b7\u222a Lp and \u0393 = \u0393v \u00b7\u222a \u0393i, we will also consider some indistinguishability notions on (La,Lp) and (\u0393v, \u0393i), about which leaves are active or passive in L = La \u00b7\u222aLp for a given key, and which attributes are valid or invalid in \u0393 = \u0393v \u00b7\u222a\u0393i for a given ciphertext. The former will be the key-indistinguishability, whereas the latter will be attributeindistinguishability. Again, as Encaps is public-key, the adversary can generate valid encapsulations by himself. However, we may provide access to an OEncaps-oracle to allow Encaps\u2217 queries, but with constraints in the final step, to exclude trivial attacks against key-indistinguishability. Similarly there will be constraints in the final step on the OKeyGen/ODelegate-queries for the attribute-indistinguishability.\nDefinition 7 (Key-Indistinguishability). Key-IND security for SA-KP-ABE is defined by the following game:\nInitialize: The challenger runs the Setup algorithm of SA-KP-ABE and gives the public parameters PK to the adversary; Oracles: OKeyGen(T\u0303 ), ODelegate(k, T\u0303 \u2032), OGetKey(k), OEncaps(\u0393v, \u0393i), and RoAPKeyGen(T\u0303 ): The adversary submits one Real or All-Passive KeyGen-query for any\naccess structure T\u0303 of its choice, with a list L = La \u00b7\u222a Lp of active and passive leaves, and gets dk0 = KeyGen(MK, (T ,La,Lp)) or dk1 = KeyGen(MK, (T , \u2205,L)). It eventually flips a random coin b, and outputs dkb to the adversary;\nFinalize(b\u2032): The adversary outputs a guess b\u2032 for b. If for some (\u0393v, \u0393i) asked to the OEncaps-\noracle, T (\u0393v \u00b7\u222a \u0393i) = 1, for the challenge access-tree T where L = La \u00b7\u222a Lp, \u03b2 $\u2190 {0, 1}, otherwise one sets \u03b2 = b\u2032. One outputs \u03b2.\nAdvkey-ind(A) denotes the advantage of an adversary A in this game.\nIn this first definition, the constraints in the finalize step require the adversary not to ask for an encapsulation on attributes that would be accepted by the policy with all-passive attributes in the leaves.\nA second version deals with accepting policies: it allows encapsulations on attributes that would be accepted by the policy with all-passive leaves in the challenge key, until attributes associated to the active leaves in the challenge key and invalid attributes in the ciphertexts are distinct. Hence, the Distinct Key-Indistinguishability (dKey-IND) where Finalize(b\u2032) reads: The adversary outputs a guess b\u2032 for b. If some active leaf \u03bb \u2208 La from the challenge key corresponds to some invalid attribute t \u2208 \u0393i in an OEncaps-query, then set \u03b2 $\u2190 {0, 1}, otherwise set \u03b2 = b\u2032. One outputs \u03b2.\nDefinition 8 (Attribute-Indistinguishability). Att-IND security for SA-KP-ABE is defined by the following game:\n14\nInitialize: The challenger runs the Setup algorithm of SA-KP-ABE and gives the public parameters PK to the adversary; Oracles: OKeyGen(T\u0303 ), ODelegate(k, T\u0303 \u2032), OGetKey(k), OEncaps(\u0393v, \u0393i), and RoAVEncaps(\u0393v, \u0393i): The adversary submits one Real-or-All-Valid encapsulation query on\ndistinct sets of attributes (\u0393v, \u0393i). The challenger generates (K,C)\u2190 Encaps\u2217(SK, \u0393v, \u0393i) as the real case, if b = 0, or (K,C)\u2190 Encaps(PK, \u0393v \u00b7\u222a\u0393i) as the all-valid case, if b = 1, and outputs C to the adversary;\nFinalize(b\u2032): The adversary outputs a guess b\u2032 for b. If for some access-tree T\u0303 \u2032 corresponding to a key asked to the OGetKey-oracle, T\u0303 \u2032(\u0393v \u00b7\u222a \u0393i, \u2205) = 1, on the challenge set (\u0393v, \u0393i), \u03b2 $\u2190 {0, 1}, else one sets \u03b2 = b\u2032. One outputs \u03b2.\nAdvatt-ind(A) denotes the advantage of an adversary A in this game.\nThis definition is a kind of attribute-hiding, where a user with keys for access-trees that are not satisfied by \u0393 = \u0393v \u00b7\u222a \u0393i cannot distinguish valid from invalid attributes in the ciphertext.\nAs above on key-indistinguishability, this first definition excludes accepting policies on the challenge ciphertext. However, for tracing, one also needs to deal with ciphertexts on accepting policies. More precisely, we must allow keys and a challenge ciphertext that would be accepted in the all-valid case, and still have indistinguishability, until attributes associated to the active leaves in the keys and invalid attributes in the challenge ciphertext are distinct. Hence, the Distinct Attribute-Indistinguishability (dAtt-IND) where Finalize(b\u2032) reads: The adversary outputs a guess b\u2032 for b. If some attribute t \u2208 \u0393i from the challenge query corresponds to some active leaf \u03bb \u2208 L\u2032a in a OGetKey-query, then set \u03b2\n$\u2190 {0, 1}, otherwise set \u03b2 = b\u2032. One outputs \u03b2.\n4 Our SA-KP-ABE Scheme\n4.1 Description of our KP-ABE with Switchable Attributes\nWe extend the basic KP-ABE scheme proven in the appendix D, with leaves that can be made active or passive in a decryption key, and some attributes can be made valid or invalid in a ciphertext, and prove that it still achieves the Del-IND-security. For our construction, we will use two DPVS, of dimensions 3 and 9 respectively, in a pairing-friendly setting (G1,G2,Gt, e,G1, G2, q), using the notations introduced in Section 2.1. Essentially, we introduce a 7-th component to deal with switchable attributes. The two new basis-vectors d7 and d \u2217 7 are in the secret key SK and the master secret key MK respectively. The two additional 8-th and 9-th components are to deal with the unbounded universe of attributes, to be able to use the adaptive Index-Ind property (see Theorem 3), instead of the static one. These additional components are hidden, and for the proof only:\nSetup(1\u03ba). The algorithm chooses two random dual orthogonal bases\nB = (b1,b2,b3) B\u2217 = (b\u22171,b\u22172,b\u22173) D = (d1, . . . ,d9) D\u2217 = (d\u22171, . . . ,d\u22179).\nIt sets the public parameters PK = {(b1,b3,b\u22171), (d1,d2,d3,d\u22171,d\u22172,d\u22173)}, whereas the master secret key is MK = {b\u22173,d\u22177} and the secret key is SK = {d7}. Other basis vectors are kept hidden. KeyGen(MK, T\u0303 ). For an extended access-tree T\u0303 = (T ,La,Lp), the algorithm first chooses a random a0\n$\u2190 Zq, and a random a0-labeling (a\u03bb)\u03bb of the access-tree T , and builds the key: k\u22170 = (a0, 0, 1)B\u2217 k \u2217 \u03bb = (\u03c0\u03bb(1, t\u03bb), a\u03bb, 0, 0, 0, r\u03bb, 0, 0)D\u2217\nfor all the leaves \u03bb, where t\u03bb = A(\u03bb), \u03c0\u03bb $\u2190 Zq, and r\u03bb $\u2190 Z\u2217q if \u03bb is an active leaf in the key (\u03bb \u2208 La) or else r\u03bb = 0 for a passive leaf (\u03bb \u2208 Lp). The decryption key dkT\u0303 is then (k\u22170, (k \u2217 \u03bb)\u03bb).\n15\nDelegate(dkT\u0303 , T\u0303 \u2032). Given a private key for a tree T\u0303 and a more restrictive subtree T\u0303 \u2032 \u2264 T\u0303 ,\nthe algorithm creates a delegated key dkT\u0303 \u2032 . It chooses a random a \u2032 0 $\u2190 Zq and a random a\u20320-labeling (a \u2032 \u03bb)\u03bb of T \u2032; Then, it updates k\u22170 \u2190 k\u22170 + (a\u20320, 0, 0)B\u2217 ; It sets k\u2217\u03bb \u2190 (\u03c0\u2032\u03bb \u00b7 (1, t\u03bb), a \u2032 \u03bb, 0, 0, 0, 0, 0, 0)B\u2217 for a new leaf, or updates k \u2217 \u03bb \u2190 k\u2217\u03bb+(\u03c0\u2032\u03bb\u00b7(1, t\u03bb), a\u2032\u03bb, 0, 0, 0, 0, 0, 0)B\u2217 for an old leaf, with \u03c0\u2032\u03bb $\u2190 Zq. Encaps(PK, \u0393 ). For a set \u0393 of attributes, the algorithm first chooses random scalars \u03c9, \u03be $\u2190 Zq.\nIt then sets K = g\u03bet and generates the ciphertext C = (c0, (ct)t\u2208\u0393 ) where\nc0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(t,\u22121), \u03c9, 0, 0, 0, 0, 0, 0)D\nfor all the attributes t \u2208 \u0393 , with \u03c3t $\u2190 Zq. Encaps\u2217(SK, (\u0393v, \u0393i)). For a disjoint union \u0393 = \u0393v \u00b7\u222a \u0393i of sets of attributes (\u0393v is the set of\nvalid attributes and \u0393i is the set of invalid attributes), the algorithm first chooses random scalars \u03c9, \u03be $\u2190 Zq. It then sets K = g\u03bet and generates the ciphertext C = (c0, (ct)t\u2208(\u0393v \u00b7\u222a\u0393i)) where\nc0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(t,\u22121), \u03c9, 0, 0, 0, ut, 0, 0)D\nfor all the attributes t \u2208 \u0393v \u00b7\u222a \u0393i, \u03c3t $\u2190 Zq and ut $\u2190 Z\u2217q if t \u2208 \u0393i or ut = 0 if t \u2208 \u0393v. Decaps(dkT\u0303 , C). The algorithm first selects an evaluation pruned tree T\n\u2032 of T that is satisfied by \u0393 = \u0393v \u222a\u0393i, such that any leaf \u03bb in T \u2032 is either passive in the key (\u03bb \u2208 Lp) or associated to a valid attribute in the ciphertext (t\u03bb \u2208 \u0393v). This means that the labels a\u03bb for all the leaves \u03bb in T \u2032 allow to reconstruct a0 by simple additions, where t = t\u03bb:\nct \u00d7 k\u2217\u03bb = g \u03c3t\u00b7\u03c0\u03bb\u00b7\u3008(t,\u22121),(1,t\u03bb)\u3009+\u03c9\u00b7a\u03bb+ut\u00b7r\u03bb t = g \u03c9\u00b7a\u03bb t ,\nas ut = 0 or r\u03bb = 0. Hence, the algorithm can derive g \u03c9\u00b7a0 t . From c0 and k \u2217 0, it can also compute c0 \u00d7 k\u22170 = g \u03c9\u00b7a0+\u03be t , which then easily leads to K = g \u03be t .\nFirst, note that the delegation works as b\u22171, d \u2217 1,d \u2217 2,d \u2217 3 are public. This allows to create a new key for T\u0303 \u2032 \u2264 T\u0303 . But as d\u22177 is not known, any new leaf is necessarily passive, and an active existing leaf in the original key cannot be converted to passive, and vice-versa. Indeed, all the randomnesses are fresh, except for the last components r\u03bb that remain unchanged: this is perfectly consistent with the definition of T\u0303 \u2032 \u2264 T\u0303 .\nSecond, in encapsulation, for invalidating a contribution ct in the ciphertext with a non-zero ut, for t \u2208 \u0393i, one needs to know d7, hence the Encaps\u2217 that requires SK, whereas Encaps with \u0393i = \u2205 just needs PK.\nEventually, we stress that in the above decryption, one can recover g\u03c9\u00b7a0t if and only if there is an evaluation pruned tree T \u2032 of T that is satisfied by \u0393 and the active leaves in T\u0303 \u2032 correspond to valid attributes in \u0393v (used during the encapsulation). And this holds if and only if T\u0303 (\u0393v, \u0393i) = 1.\n4.2 Del-IND-Security of our SA-KP-ABE for Encaps\nFor this security notion, we first consider only valid contributions in the challenge ciphertext, with indistinguishability of the Encaps algorithm. Which means that \u0393i = \u2205 in the challenge pair. And the security result holds even if the vector d7 is made public:\nTheorem 9. Our SA-KP-ABE scheme is Del-IND for Encaps (with only valid attributes in the challenge ciphertext), even if d7 is public.\nThe proof essentially reduces to the IND-security result of the KP-ABE scheme, and is available in the appendix E.1. We present an overview of the proof, as the structure of the first games is common among most of our proofs. The global sequence of games is described on Figure 4, where (c0, (ct)) is the challenge ciphertext for all the attributes t \u2208 \u0393 , and (k\u2217`,0, (k\u2217`,\u03bb)) are the keys, for 1 \u2264 ` \u2264 K, and \u03bb \u2208 L` for each `-query, with active and passive leaves. In the\ntwo first games G1 and G2, one is preparing the floor with a random \u03c4 and random masks zt in the ciphertexts ct (actually, the challenge ciphertext corresponding to the attribute t). Note that until the actual challenge query is asked, one does not exactly know the attributes in \u0393 (as we are in the adaptive-set setting), thus we will decide on the random mask zt, where t is virtually associated to the number of the attribute in their order of apparition in the security game. The main step is to get to Game G3, starting with an additional labeling (s`,0, (s`,\u03bb)\u03bb), using hybrid games that begins from Game G2. To do this, the new labelling is added in each `-th key, then each label is masked by the random zt for each attribute t. One then exploits the limitations expected from the adversary in the security game: the adversary cannot ask keys on access-trees T such that T (\u0393 ) = 1, for the challenge set \u0393 . This limitation translates into the value s`,0 being unpredictable for the adversary with regards to (s`,\u03bb)\u03bb, as for each key requested by the adversary, there is at least one s`,\u03bb by lack of a corresponding ciphertext. Thus, we can replace s`,0 by a random independent r`,0 without giving any advantage to the adversary. To formally mask the shares s`,\u03bb, we need another level of hybrid games: we will change all the keys associated with a specific attribute \u03bb at the same time, by using the Adaptive Index-Ind technique. This allows us to mask the s`,\u03bb share in each key with zt, one \u03bb at a time inside the `-th key.\nSimulation of delegation can just be done by using the key generation algorithm, making sure we use the same randomness for all the keys delegated from the same one. As the vector d\u22177 is known to the simulator, this is easy. As d7 is public, the adversary can run by himself both Encaps and Encaps\u2217.\nWe stress that our construction makes more basis vectors public, than in the schemes from [OT12b], as only b\u22173 is for the key issuer. This makes the proof more tricky, but this is the reason why we can deal with delegation for any user.\n4.3 Del-IND-Security of our SA-KP-ABE for Encaps\u2217\nWe now study the full indistinguishability of the ciphertext generated by an Encaps\u2217 challenge, with delegated keys. The intuition is that when ut \u00b7 r`,\u03bb 6= 0, the share a`,\u03bb in g \u03c9\u00b7a`,\u03bb+ut\u00b7r`,\u03bb t is hidden, but we have to formally prove it.\n17\nThe main issue in this proof is the need to anticipate whether ut \u00b7 r`,\u03bb = 0 or not when simulating the keys, and the challenge ciphertext as well (even before knowing the exact query (\u0393v, \u0393i)). Without being in the selective-set setting where both \u0393v and \u0393i would have to be specified before generating the public parameters PK, we ask to know disjoint super-sets Av, Ai \u2286 U of attributes. Then, in the challenge ciphertext query, we will ask that \u0393v \u2286 Av and \u0393i \u2286 Ai. We will call this setting the semi-adaptive super-set setting, where the super-sets have to be specified before the first decryption keys are issued. Furthermore, the set of attributes \u0393 = \u0393v \u00b7\u222a \u0393i used in the real challenge query is only specified at the moment of the challenge, as in the adaptive setting.\nFor this proof, d7 must be kept secret (cannot be provided to the adversary). We will thus give access to an Encaps\u2217 oracle. We then need to simulate it.\nTheorem 10. Our SA-KP-ABE scheme is Del-IND for Encaps\u2217, in the semi-adaptive super-set setting (where Av, Ai \u2286 U so that \u0393v \u2286 Av and \u0393i \u2286 Ai are specified before asking for keys).\nWe stress that the semi-adaptive super-set setting is much stronger than the selective-set setting where the adversary would have to specify both \u0393v and \u0393i before the setup. Here, only supersets have to be specified, and just before the first key-query. The adversary is thus given much more power.\nThe full proof can be found in the appendix E.2, we provide some hints, that extend the above sketch: we only consider keys that are really provided to the adversary, and thus delegated keys. They can be generated as fresh keys except for the r\u03bb\u2019s that have to be the same for leaves in keys delegated from the same initial key. However, in order to randomize s`,0 once all of the shares have been masked, one cannot directly conclude that s`,0 is independent from the view of the adversary: we only know T\u0303`(\u0393v, \u0393i) = 0, but not necessarily T`(\u0393v \u00b7\u222a \u0393i) = 0, as in the previous proof.\nTo this aim, we revisit this gap with an additional sequence where we focus on the k-th key and the challenge ciphertext. In that sequence, we first prepare with additional random values y`,\u03bb in all the keys, with the same repetition properties as the r`,\u03bb. Thereafter, in another subsequence of games on the attributes, we can use the Swap-Ind property to completely randomize sk,\u03bb when utk,\u03bb \u00b7 rk,\u03bb 6= 0. Hence, the sk,\u03bb are unknown either when ztk,\u03bb is not known (the corresponding element is not provided in the challenge ciphertext) or this is a random s\u2032k,\u03bb when utk,\u03bb \u00b7 rk,\u03bb 6= 0. The property of the access-tree then makes sk,0 perfectly unpredictable, which can be replaced by a random independent rk,0."
        },
        {
            "heading": "4.4 Distinct Indistinguishability Properties",
            "text": "We first claim easy results, for which the proofs are symmetrical:\nTheorem 11. Our SA-KP-ABE scheme is dKey-IND, even if d\u22177 is public.\nTheorem 12. Our SA-KP-ABE scheme is dAtt-IND, even if d7 is public.\nBoth proofs can be found in the appendix E.3. In these alternative variants, all the invalid attributes in all the queried ciphertexts do not correspond to any active leaf in the challenge keys (for dKey-IND) or all active leaves in all the queried keys do not correspond to any invalid attribute in the challenge ciphertext (for dAtt-IND). Then, we can gradually replace all the real keys by all-passive in the former proof or all the real ciphertexts by all-valid in the latter proof."
        },
        {
            "heading": "4.5 Attribute-Indistinguishability",
            "text": "Theorem 13. Our SA-KP-ABE scheme is Att-IND, even if d7 is public, if all the active keys correspond to independent leaves with respect to the set of attributes \u0393 = \u0393v \u00b7\u222a\u0393i in the challenge ciphertext.\n18\nThe proof can be found in the appendix E.5. This is an important result with respect to our target application of tracing, combined with possible revocation. Indeed, with such a result, if a user is excluded independently of the tracing procedure (the policy would reject him even if all his passive leaves match valid attributes in the ciphertext), he will not be able to detect whether there are invalid attributes in the ciphertext and thus that the ciphertext is from a tracing procedure. This gives us a strong resistance to collusion."
        },
        {
            "heading": "5 Application to Tracing",
            "text": "In our Traitor-Tracing approach, any user would be given a key associated to a word in a traceable code at key generation time. To embed a word inside a key, the key generation authority only needs to create a new policy for a user with policy T : the new policy will be a root AND gate, that connects the original access-tree T as one child, and a word-based access-tree composed of active leaves as another child, as illustrated on Figure 5.\nFrom there, the tracing authority, using the secret key SK, could trace any Pirate Decoder by invalidating attributes associated to the positions in words, one position at a time. Since an adversary cannot know whether attributes are valid or invalid, until it is not impacted by the invalid attributes (thanks to the Distinct Attribute-Indistinguishability), he will answer each queries of the tracer, when it is able to do it, effectively revealing the bits of his word on each position, until the tracer finds his complete word, to eventually trace back the traitors, from the traceable-code properties. Furthermore, thanks to the Attribute-Indistinguishability (not Distinct), a traitor that has been identified by the tracing authority can be removed from the target set at tracing time, and can thus no longer participate in the coalition, as it will be excluded from the policy, whatever the valid/invalid attributes. We stress that the secret key SK is required for invalidating some attributes, and so for the tracing. We thus have secret-key black-box traceability. More details are given in the appendix B."
        },
        {
            "heading": "6 Conclusion",
            "text": "We have designed a KP-ABE scheme that allows an authority to generate keys with specific policies for each user, so that these users can thereafter delegate their keys for any more restrictive rights. Thanks to the (Distinct) Attribute-Indistinguishability and AttributeIndistinguishability, it can also include key material for tracing a compromised key involved in a pirate device while limiting the size of collusions. In addition, with Key-Indistinguishability on active leaves and perfect randomization on passive leaves, one achieves a strong level of anonymity: one cannot detect whether two keys have been delegated by the same original key."
        },
        {
            "heading": "Acknowledgments",
            "text": "This work was supported in part by the French ANR Project ANR-19-CE39-0011 PRESTO."
        },
        {
            "heading": "A More Definitions",
            "text": "A.1 Computational Assumptions\nFirst, we recall the assumptions used in some related work:\nDefinition 14 (Decisional Linear Assumption (DLIN)). The DLIN assumption in G, of prime order q with generator G, states that no algorithm can efficiently distinguish the two distributions, where a, b, c, x, y, z $\u2190 Zq,\nD0 = {(a \u00b7G, b \u00b7G, c \u00b7G, ax \u00b7G, by \u00b7G, c(x+ y) \u00b7G)} D1 = {(a \u00b7G, b \u00b7G, c \u00b7G, ax \u00b7G, by \u00b7G, z \u00b7G)}\nDefinition 15 (External Decisional Linear Assumption (XDLIN)). The XDLIN assumption in G1,G2, of prime order q with generators G1, G2 respectively, states that no algorithm can efficiently distinguish the two distributions, where a, b, c, x, y, z $\u2190 Zq,\nD0 = {(a \u00b7G1, b \u00b7G1, c \u00b7G1, ax \u00b7G1, by \u00b7G1, a \u00b7G2, b \u00b7G2, c \u00b7G2, ax \u00b7G2, by \u00b7G2, c(x+ y) \u00b7G2)} D1 = {(a \u00b7G1, b \u00b7G1, c \u00b7G1, ax \u00b7G1, by \u00b7G1, a \u00b7G2, b \u00b7G2, c \u00b7G2, ax \u00b7G2, by \u00b7G2, z \u00b7G2)}\nHowever, for our proofs, in the sequence of games, we will sometimes use the following DSDH assumption, that is equivalent to the DDH assumption:\nDefinition 16 (Decisional Separation Diffie-Hellman Assumption). The DSDH assumption in G, of prime order q with generator G, between two constant values x, y, states that no algorithm can efficiently distinguish the two distributions, where a, b $\u2190 Zq,\nDx = {(a \u00b7G, b \u00b7G, (ab+ x) \u00b7G)} Dy = {(a \u00b7G, b \u00b7G, (ab+ y) \u00b7G)}\nAs c + x and c + y are perfectly indistinguishable for a random c, then the best advantage an algorithm can get in distinguishing the two distributions within time T is upper-bounded by 2 \u00b7 AdvddhG (T ).\nA.2 Definitions for KP-ABE\nWe now recall the definition of KP-ABE from [GPSW06], with access-trees to define policies in the keys:\nSetup(1\u03ba). From the security parameter \u03ba, the algorithm defines all the global parameters PK and the master secret key MK; KeyGen(MK, T ). For a master secret key MK and an access-tree T , the algorithm outputs a private key dkT ; Encaps(PK, \u0393 ). For a list \u0393 of attributes and global parameters PK, the algorithm generates the ciphertext C and an encapsulated key K;\nDecaps(dkT , C). Given the private key dkT and the ciphertext C, the algorithm outputs the encapsulated key K.\nFor correctness, the Decaps algorithm should output the encapsulated key K if and only if C has been generated for a set \u0393 that satisfies the policy T of the decryption key dkT : T (\u0393 ) = 1.\n21\nDelegation. A major feature in [GPSW06] is delegation of decryption keys: a user with a decryption key dk corresponding to an access-tree T can compute a new decryption key corresponding to any more restrictive access-tree, or a less accessible tree T \u2032, than T with the following partial order: T \u2032 \u2264 T , if and only if for any subset \u0393 of attributes, T \u2032(\u0393 ) = 1 =\u21d2 T (\u0393 ) = 1. More concretely, in our case of access-trees, a more restrictive access-tree is, for each node \u03bd,\n1. if G(\u03bd) = AND, one or more children are added (i.e., more constraints); 2. if G(\u03bd) = OR, one or more children are removed (i.e., less flexibility); 3. the node \u03bd is moved one level below as a child of an AND-gate at node \u03bd \u2032, with additional\nsub-trees as children to this AND-gate (i.e., more constraints).\nWe illustrate the last rule, with a simple example in Figure 6. There is thus the additional algorithm:\nDelegate(dkT , T \u2032). Given a key dkT , generated from either the KeyGen or the Delegate algorithms, for a policy T and a more restrictive policy T \u2032 \u2264 T , the algorithm outputs a decryption key dkT \u2032 .\nSecurity Notions. Whereas we could recall the classical indistinguishability, with only KeyGenqueries, we extend it to handle delegation queries: if one can ask several more restrictive delegations from an access-tree T , one should not be able to distinguish an encapsulated key in a ciphertext under a non-trivial list of attributes, according to the obtained delegated keys only. Note that this definition allows for an adversary to make delegation requests on keys that are delegated keys themselves, without limit.\nDefinition 17 (Delegation-Indistinguishability). Del-IND security for KP-ABE is defined by the following game between the adversary and a challenger:\nInitialize: The challenger runs the Setup algorithm of KP-ABE and gives the public parameters PK to the adversary;\nOracles: The following oracles can be called in any order and any number of times, except for RoREncaps which can be called only once. OKeyGen(T ): to model KeyGen-queries for any access-tree T . It generates the decryption\nkey but only outputs the index k of the key; ODelegate(k, T \u2032): to model Delegate-queries for any more restrictive access-tree T \u2032 \u2264 T ,\nfor the k-th generated decryption key for T . It generates the decryption key but only outputs the index k\u2032 of the new key;\nOGetKey(k): the adversary gets back the k-th decryption key generated by OKeyGen or ODelegate oracles;\nRoREncaps(\u0393 ): the challenge real-or-random encapsulation query on a set of attributes \u0393 is asked once only. The challenger asks for an encapsulation query on \u0393 and receives (K0, C). It also generates a random key K1. It eventually flips a random coin b, and outputs (Kb, C) to the adversary; Finalize(b\u2032): The adversary outputs a guess b\u2032 for b. If for some access-tree T corresponding to a key asked to the OGetKey-oracle, T (\u0393 ) = 1, on the challenge set \u0393 , \u03b2 $\u2190 {0, 1}, otherwise one sets \u03b2 = b\u2032. One outputs \u03b2.\n22\nThe advantage of an adversary A in this game is defined as\nAdvdel-ind(A) = Pr[\u03b2 = 1|b = 1]\u2212 Pr[\u03b2 = 1|b = 0].\nOne could of course consider Chosen-Ciphertext security, where the adversary could have access to some decryption oracles, without the decryption key itself. On the more limited side, one can consider Selective-Set security, where the adversary declares \u0393 at the initialization step, as in [GPSW06]. This Delegation-Indistinguishability is definitely stronger than basic Indistinguishability as the adversary can ask for an OGetKey(k)-query right after the OKeyGen(T )- query that provides index k to get the decryption key for T ."
        },
        {
            "heading": "B Application to Traitor-Tracing",
            "text": "Black-Box Traitor-Tracing. In a black-box traitor-tracing system, a tracing authority can interact with a Pirate Decoder (PD) that non-legitimately decrypts ciphertexts, using one or more decryption keys of legitimate users (the traitors). The keys used by the PD, or the aggregated key, are unknown to the tracing authority when we are dealing with black-box tracing, the most reasonable scenario. The goal of traitor-tracing is to determine which user\u2019s private keys are used by the PD, only interacting with the PD in a black-box way, in turn allowing to identify the traitors or the compromised devices. An approach is to embed codewords (also called \u201dfingerprints\u201d) with specific properties in the decryption keys. These codewords can then be recovered, under some marking assumptions that address collusion of traitors, after only a few interactions with the PD. Boneh and Shaw [BS95] proposed a tracing technique by embedding codewords in each ciphertext. With this approach, the ciphertext size has to be linear in the length of the codeword, and this length quickly increases with the size of the possible collusion. Boneh and Naor [BN08] improved this approach with a shorter ciphertext: only some bits of the codeword are involved in each ciphertext, but in this case tracing requires additional assumptions on the decryption capabilities of the PD.\nBoneh et al. [BSW06], followed by [BW06], proposed traceability (and revocation) whatever the size of the collusion, but with ciphertexts of size \u221a N , where N is the maximal number of\nusers. Wong et al. [LW15,LLLW17] combined this technique into a CP-ABE, with policy encoded in a Linear Secret Sharing Scheme (LSSS). Those techniques nevertheless seem incompatible with delegation properties. Intuitively, their approach assigns each single user to a different cell in a table, and then methodically tests each cell of the table for a traitor, with linear tracing. This is quite exclusive with delegation for the users, as one cannot add more cells in the table.\nLai and Tang [LT18] proposed a framework for traitor-tracing in ABE. Their technique is a generic transformation to make any ABE into a traceable ABE, following above Boneh and Shaw [BS95] methodology. By representing bits in fingerprinting codewords as attributes, they successfully embed the words into any ABE key. However, their construction is a generic one, and the additional layer excludes delegation for the usual ABE scheme. Nevertheless, our approach will be in this vein, but for a very specific construction.\nB.1 Delegatable and Traceable KP-ABE\nOur initial motivation was to adapt KP-ABE with delegation to support tracing, which should not be detectable by the pirate decoder. We now explain how our SA-KP-ABE primitive allows that. We recall the definitions of tracing, and then we illustrate with a possible family of policies with switchable leaves and attributes. We first add a Tracing algorithm to initial definition of delegatable KP-ABE from the appendix A.2:\nSetup(1\u03ba, n, t). From the security parameter \u03ba, the total number n of users in the system, and the maximal size t on the collusion, the algorithm defines all the global parameters PK, the master secret key MK, and the tracing key TK;\n23\nKeyGen(MK, T , id). From a master key MK and an access tree T , the algorithm outputs a key dkid,T , specific to the user id; Delegate(dkid,T , T \u2032, id\u2032). Given a key dkid,T and a more restrictive access-tree T \u2032 \u2264 T , the algorithm outputs a decryption key dkid\u2032,T \u2032 ; Encaps(PK, \u0393 ). For a set \u0393 of attributes, the algorithm generates the ciphertext C and an encapsulated key K;\nDecaps(dkid,T , C). Given the key dkid,T and the ciphertext C, the algorithm outputs the encapsulated key K; TraceD(SK, \u0393 ). Given the secret key SK, and a black-box access to a Pirate Decoder D, the tracing algorithm outputs an index set I which identifies a set of malicious users, among the users id and id\u2032 compatible with \u0393 .\nIn the above definition, id\u2032 might be for a specific device of user id. Then the authority generates keys for users, and users delegate for devices, with any more restrictive policy T \u2032 \u2264 T : one can consider that id\u2032 = id\u2016d, for device d. One can then trace users and devices.\nWe expect two properties from the Trace algorithm on a perfect Pirate Decoder for a set \u0393 (that always decrypts the encapsulated key), when the number of traitors compatible with \u0393 is at most t: it always outputs a non-empty set of traitors, but does never wrongly accuse anybody.\nDefinition 18 (Traceability).\nInitialize: The challenger runs the Setup algorithm and gives the public parameters PK to the adversary; OKeyGen(id, T ): The adversary is allowed to issue KeyGen-queries for any access-tree T of\nits choice, the corresponding secret key dkid,T is generated; ODelegate(id, T , id\u2032, T \u2032): The adversary is allowed to issue several Delegate-queries for any\nmore restrictive access-tree T \u2032 \u2264 T of its choice, for an already generated decryption key for T , and the corresponding secret key dkid\u2032,T \u2032 is generated; OGetKey(id, T ): The adversary can then ask and see the secret key dkid,T , if it has been generated, else it gets \u22a5;\nFinalize: The adversary generates a set of attributes \u0393 and a perfect Decoder D on \u0393 , the challenger runs TraceD(SK, \u0393 ) to get back I. Let us denote Uc (corrupted users) the set of id\u2032 for which T \u2032 has been asked such that T \u2032(\u0393 ) = 1. If the size of Uc is at most t, but I 6\u2282 Uc or I is empty, one outputs 1, otherwise one outputs 0.\nThe success Advtrace(A) of an adversary A in this game is the probability to have 1 as output.\nWe stress that the above definition requires a perfect Pirate Decoder. This could be relaxed, but this is enough for our illustration.\nB.2 Fingerprinting Code\nOur technique will exploit traceable codes as in [CFN94] that allow to trace back codewords from words that have been derived from legitimate codewords. It uses the definition of feasible set, the list the words that can be derived from a set of words:\nDefinition 19 (Feasible Set). Let W = {w(1), . . . , w(t)} be a set of t words in {0, 1}`. We say a word w \u2208 {0, 1}` is feasible for W if for all i = 1, . . . , `, there is a j \u2208 {1, . . . , t} such that wi = w (j) i . The set of words feasible for W is the feasible set of W , denoted F (W ) = {w \u2208 {0, 1}`,\u2200i,\u2203w\u2032 \u2208W,wi = w\u2032i}.\nA fingerprinting code is a particular traceable code. It defines a set of codewords that allows correct and efficient tracing to recover the traitor codewords from a word derived from them (in the feasible set). For the sake of clarity, we focus on binary codes:\n24\nDefinition 20 (Fingerprinting Code). A fingerprinting code is a pair of algorithms (G,T ) defined as follows:\nCode generator G is a probabilistic algorithm that takes a tuple (n, t) as input, where n is the number of codewords to output, and t is the maximal collusion size. The algorithm outputs a code \u03a0 of n codewords of bit-length `. Tracing algorithm T is a deterministic algorithm that takes as input a word w\u2217 \u2208 {0, 1}` to trace. The algorithm T outputs a subset S \u2286 \u03a0 of possible traitors.\nSuch a fingerprinting code is said t-secure if for all n > t and all subsets C \u2286 {1, . . . , n} of size at most t, when we set \u03a0 = {w(1), . . . , w(n)} \u2190 G(n, t) and WC = {w(i)}i\u2208C , for any word w\u2217 \u2208 F (WC), then \u2205 6= T (w\u2217) \u2286 C. Again, we could relax the definition with error probabilities in identifying a traitor and in framing an honest user. Tardos codes [Tar03] are examples of short codes with probabilistic tracing capabilities and low error rates.\nB.3 Traceable and Delegatable KP-ABE from SA-KP-ABE\nWe now explain how our SA-KP-ABE primitive is enough for tracing. For the sake of simplicity, in the following, we will keep id\u2032 = id, without specifying the device, still with any T \u2032 \u2264 T , but then devices of the same user cannot be traced. Only users can be traced, but various devices might have different policies:\nSetupTr(1\u03ba, n, t). The algorithm calls Setup(1\u03ba) and gets back PK,MK, SK. It also calls code generator algorithm G(n, t) to get the code \u03a0. It sets the parameters as PKTr = PK, MKTr = (MK, \u03a0) and TKTr = (SK, T ). KeyGenTr(MKTr, id, T ). For an access-tree T , the algorithm defines T Tr, where T Tr = T \u2227 TTr are linked by an AND-gate at their root. The access-tree TTr is constructed as follows (see Figure 5) :\n\u2013 Choose a word wid = wid,1 . . . wid,` from \u03a0, for any new id; \u2013 Set TTr as the AND of active leaves \u03bbi associated to the attributes Ai,wid,i , for i = 1, . . . , `. The algorithm then calls KeyGen(MK, T\u0303 Tr), where all leaves are passive in T and all leaves are active in TTr, and gets back dkT\u0303 Tr , and finally sets dk Tr id,T \u2190 dkT\u0303 Tr . DelegateTr(dkTrid,T , T \u2032). Given a private key for an access-tree T and a more restrictive subtree T \u2032 \u2264 T , but for the same identity (as we focus on id\u2032 = id), the algorithm calls Delegate(dkT\u0303 , T\u0303\n\u2032), where T\u0303 and T\u0303 \u2032 are T and T \u2032 combined with TTr as above, to get a new delegated key dkT\u0303 \u2032 , and sets dk Tr id,T \u2032 = dkT\u0303 \u2032 .\nEncapsTr(PKTr, \u0393 ). For a set \u0393 of attributes, the algorithm defines \u0393Tr = {A1,0, A1,1, . . . , A`,0, A`,1}. It then calls Encaps(PK, \u0393 \u222a \u0393Tr) and gets the output K and C. It then sets KTr = K and CTr = C. DecapsTr(dkTrid,T , C). The algorithm calls Decaps Tr(dkT\u0303 , C), for dkT\u0303 = dk Tr id,T , to get K, and\noutputs KTr = K. TraceTr(TKTr, \u0393 ). On input the tracing key TKTr = (SK, T ), and access to a perfect Pirate\nDecoder D, the algorithm repeats the following experiment, for j = 1, . . . , `, to build the word w\u2217: 1. Set \u0393 (0) v = \u0393 \u222a {Ak,`, k 6= j, ` \u2208 {0, 1}} \u222a {Aj,0} and \u0393 (0) i = {Aj,1};\n2. Set \u0393 (1) v = \u0393 \u222a {Ak,`, k 6= j, ` \u2208 {0, 1}} \u222a {Aj,1} and \u0393 (1) i = {Aj,0}; 3. Compute the two challenges (K0, C0) \u2190 Encaps\u2217(SK, (\u0393 (0)v , \u0393 (0)i )) and (K1, C1) \u2190 Encaps\u2217(SK, (\u0393 (1) v , \u0393 (1) i )); 4. Flip a random coin b $\u2190 {0, 1}, and ask for the decryption K \u2032 of Cb to D; 5. If K \u2032 = Kb then set w \u2217 j \u2190 b, else set w\u2217j \u2190 1\u2212 b. Eventually, the algorithm runs the tracing algorithm T (w\u2217) to get S, the set of traitors, that it outputs.\n25\nSecurity Analysis. Again, we stress that we assume perfect Pirate Decoder D, but relaxed version would be possible. Hence, here, we know that D will successfully decrypt any normal ciphertext when \u0393 is acceptable for all the traitors. Then, during the tracing procedure, for any index j, there are three possibilities:\n\u2013 If wj = b for all keys in Uc, then the ciphertext Cb is indistinguishable from the one where Aj,1\u2212b is in \u0393v because of the Distinct Attribute-Indistinguishability (Att-IND) property of the scheme, hence D will always output Kb. We correctly set w \u2217 j = b. \u2013 If wj = 1 \u2212 b for all keys in Uc, Kb will be unpredictable because of the DelegationIndistinguishability for Encaps\u2217, we correctly set w\u2217j = 1\u2212 b. \u2013 If wj has mixed values in 0 and 1 among users in Uc, D can detect that Cb involves active keys. But we could anyway set w\u2217j \u2190 0 or w\u2217j \u2190 1.\nThis way, the built word w\u2217 satisfies that, for each position j, w\u2217j = wj , for some w in Uc: w\u2217 \u2208 F (Uc). If the fingerprinting code is t-secure, since the size of Uc is at most t, \u2205 6= T (w\u2217) \u2286 Uc. As a consequence, under the Distinct Attribute-Indistinguishability and the DelegationIndistinguishability for Encaps\u2217, the delegatable KP-ABE is traceable.\nDiscussions. Our tracing system is presented with basic fingerprinting notions, for the sake of clarity, but more advanced features are possible. In particular, our tracing algorithm works as well with non-perfect Pirate Decoder, at the cost of more calls to D to increase the quality of the estimation. It is also compatible with [BN08], to drastically reduce the ciphertext size. Eventually, one could also let the user to delegate traceable keys to each devices. However, as we do not allow public traceability, only the tracing authority can run the tracing procedure, to trace users or devices."
        },
        {
            "heading": "C Dual Pairing Vector Spaces",
            "text": "In this section, we provide a brief review of the Dual Pairing Vector Spaces (DPVS), that have been proposed for efficient constructions with adaptive security [OT08,LOS+10,OT10,OT12b], as Dual Systems [Wat09], in prime-order groups under the DLIN assumption. In [LW10], Dual Systems were using pairing on composite order elliptic curves. Then, prime-order groups have been used with the SXDH assumption, in a pairing-friendly setting of primer order, which means that the DDH assumptions hold in both G1 and G2 [CLL+13]. In all theses situations, one exploited indistinguishability of sub-groups or sub-spaces. In this section, for the sake of efficiency, we use the SXDH assumption in a pairing-friendly setting (G1,G2,Gt, e,G1, G2, q) of primer order q.\nC.1 Pairing Vector Spaces\nLet us be given any cyclic group (G = \u3008G\u3009,+) of prime order q, denoted additively. We can define the Zq vector space of dimension n,\nGn = {X = ~x \u00b7G def= (X1 = x1 \u00b7G, . . . ,Xn = xn \u00b7G) | ~x \u2208 Znq },\n26\nwith the following laws:\n(X1, . . . , Xn) + (Y1, . . . , Yn) def = (X1 + Y1, . . . , Xn + Yn)\na \u00b7 (X1, . . . , Xn) def = (a \u00b7X1, . . . , a \u00b7Xn)\nEssentially, all the operations between the vectors in Gn are applied on the vectors in Znq :\n~x \u00b7G+ ~y \u00b7G def= (~x+ ~y) \u00b7G a \u00b7 (~x \u00b7G) def= (a \u00b7 ~x) \u00b7G\nwhere ~x + ~y and a \u00b7 ~x are the usual internal and external laws of the vector space Znq . For the sake of clarity, vectors will be row-vectors.\nIf we are using a pairing-friendly setting (G1,G2,Gt, e,G1, G2, q), with a bilinear map e from G1\u00d7G2 into Gt, we can have an additional law between an element X \u2208 Gn1 and Y \u2208 Gn2 : X \u00d7 Y def= \u220f i e(Xi, Yi), where Gt is usually denoted multiplicatively.\nNote that if X = (X1, . . . , Xn) = ~x \u00b7G1 \u2208 Gn1 and Y = (Y1, . . . , Yn) = ~y \u00b7G2 \u2208 Gn2 :\n(~x \u00b7G1)\u00d7 (~y \u00b7G2) = X\u00d7Y = \u220f i e(Xi, Yi) = \u220f i e(xi \u00b7G1, yi \u00b7G2)\n= \u220f i gxi\u00b7yit = g ~x\u00b7~y> t = g \u3008~x,~y\u3009 t\nwhere gt = e(G1, G2) and \u3008~x, ~y\u3009 is the inner product between vectors ~x and ~y.\nC.2 Dual Pairing Vector Spaces\nWe define E = (~ei)i the canonical basis of Znq , where ~ei = (\u03b4i,1, . . . , \u03b4i,n), with the classical \u03b4i,j = 1 if i = j and \u03b4i,j = 0 otherwise, for i, j \u2208 {1, . . . , n}. We can also define E = (ei)i the canonical basis of Gn, where ei = ~ei \u00b7G = (\u03b4i,j \u00b7G)j . More generally, given any basis B = (~bi)i of Znq , we can define the basis B = (bi)i of Gn, where bi = ~bi \u00b7G.\nChoosing a random basis B of Gn is equivalent to a random choice of an invertible matrix B\n$\u2190 GLn(Zq), the definition B \u2190 B \u00d7 E , where B = (~bi)i is a basis of Znq (B is essentially the matrix with ~bi as its i-th row, as ~bi = \u2211 j Bi,j \u00b7 ~ej), and then B\u2190 (bi)i where bi = ~bi \u00b7G: B is the basis of Gn associated to the matrix B as\nbi = ~bi \u00b7G = \u2211 j Bi,j \u00b7 ~ej \u00b7G = \u2211 j Bi,j \u00b7 ej : B = B \u00b7 E.\nIn case of pairing-friendly setting, for a dimension n, we will denote E = (ei)i and E\u2217 = (e\u2217i )i the canonical bases of Gn1 and Gn2 , respectively:\nei \u00d7 e\u2217j = (~ei \u00b7G1)\u00d7 (~ej \u00b7G2) = g \u3008~ei,~ej\u3009 T = g \u03b4i,j T .\nThe same way, if we denote B = (bi)i = B \u00b7 E the basis of Gn1 associated to a matrix B, and B\u2217 = (b\u2217i )i = B\u2032 \u00b7 E\u2217 the basis of Gn2 associated to the matrix B\u2032 = (B\u22121)>, as B \u00b7B\u2032 > = In,\nbi \u00d7 b\u2217j = (~bi \u00b7G1)\u00d7 (~b\u2032j \u00b7G2) = g \u3008~bi,~b\u2032j\u3009 t = g \u03b4i,j t .\nB and B\u2217 are called Dual Orthogonal Bases. We have seen above the canonical bases E and E\u2217 are dual orthogonal bases, but for any random invertible matrix U $\u2190 GLn(Zq), the bases U of Gn1 associated to the matrix U and U\u2217 of Gn2 associated to the matrix (U\u22121)> are Random Dual Orthogonal Bases. A pairing-friendly setting (G1,G2,Gt, e,G1, G2, q), with such dual orthogonal bases U and U\u2217 of size n, is called a Dual Pairing Vector Space (DPVS).\n27\nC.3 Change of Basis\nLet us consider the basis U = (ui)i of Gn associated to a matrix U \u2208 GLn(Zq), and the basis B = (bi)i of Gn associated to the product matrix BU , for any B \u2208 GLn(Zq). For a vector ~x \u2208 Zq, we can define\n(~x)B = \u2211 i xi \u00b7 bi = \u2211 i xi \u00b7~bi \u00b7G = ~x \u00b7BU \u00b7G = (~x \u00b7B) \u00b7 U \u00b7G = ~y \u00b7 U \u00b7G\n= \u2211 i yi \u00b7 ~ui \u00b7G = \u2211 i yi \u00b7 ui = (~y)U where ~y = ~x \u00b7B.\nHence, (~x)B = (~x\u00b7B)U and (~x\u00b7B\u22121)B = (~x)U where we denote B def = B\u00b7U. For any invertible matrix B, if U is a random basis, then B = B \u00b7U is also a random basis. Then, with B\u22121 = (~b\u2032 > 1 , . . . , ~b\u2032 > n ), ~x = ~y \u00b7 (~b\u2032 > 1 , . . . , ~b\u2032 > n ):\nB = B \u00b7 U, B\u2032 =  ~b \u2032 1 ... ~b\u2032n  , and (~x)B = (~y)U =\u21d2 ~x = (\u3008~y, ~b\u20321\u3009, . . . , \u3008~y, ~b\u2032n\u3009). Let us consider the random dual orthogonal bases U = (ui)i and U\u2217 = (u\u2217i )i of Gn1 and Gn2 respectively associated to a matrix U (which means that U is associated to the matrix U and U\u2217 is associated to the matrix (U\u22121)>): the bases B = B \u00b7U and B\u2032 = (B\u22121)> \u00b7U\u2217 are also dual orthogonal bases:\nbi \u00d7 b\u2217j = g ~bi\u00b7~b\u2032\n> j t = g ~ui\u00b7B\u00b7(B\u22121)>\u00b7~u\u2217>j t = g ~ui\u00b7~u\u2217>j t = g \u03b4i,j t .\nC.4 Partial Change of Basis\nWe will often just have to partially change a basis, on a few vectors only: the transition matrix\nB = (t)i1,...,im =  t1,1 . . . t1,m... ... tm,1 . . . tm,m  i1,...,im\nmeans the n\u00d7 n matrix B where\nBi,j = \u03b4i,j , if any i, j 6\u2208 {i1, . . . , im} Bik,i` = tk,`, for all k, ` \u2208 {1, . . . ,m}\nAs a consequence, from a basis U, B = B \u00b7 U corresponds to the basis\nbi = ui, if i 6\u2208 {i1, . . . , im} bik = \u2211 ` tk,` \u00b7 ui` , if k 6\u2208 {i1, . . . , im}\nAs we need to have B\u2217 = (B\u22121)> \u00b7U\u2217, we need the dual transition matrix B\u2032 to be B\u2032 = (t\u2032)i1,...,im where t\u2032 = (t\u22121)>. Indeed, in such a case, we have\nb\u2217i = u \u2217 i , if i 6\u2208 {i1, . . . , im} b\u2217ik = \u2211 ` t\u2032k,` \u00b7 u\u2217i` , if k 6\u2208 {i1, . . . , im}\nso,\n\u2013 if both i, j 6\u2208 {i1, . . . , im}, bi \u00d7 b\u2217j = ui \u00d7 u\u2217j = g \u03b4i,j t ;\n28\n\u2013 if i = ik \u2208 {i1, . . . , im}, but j 6\u2208 {i1, . . . , im},\nbi \u00d7 b\u2217j = bik \u00d7 u \u2217 j = (\u2211 ` tk,` \u00b7 ui` ) \u00d7 u\u2217j = \u220f ` (ui` \u00d7 u \u2217 j ) tk,` = 1\n\u2013 if i 6\u2208 {i1, . . . , im}, but j = ik \u2208 {i1, . . . , im},\nbi \u00d7 b\u2217j = ui \u00d7 b\u2217ik = ui \u00d7 (\u2211 ` t\u2032k,` \u00b7 u\u2217i` ) = \u220f ` (ui \u00d7 u\u2217i`) t\u2032k,` = 1\n\u2013 if i = ik and j = i`,\nbi \u00d7 b\u2217j = (\u2211 p tk,p \u00b7 uip ) \u00d7 (\u2211 p t\u2032`,p \u00b7 u\u2217ip )\n= \u220f p (uip \u00d7 u\u2217ip) tk,p\u00b7t\u2032`,p = g \u2211 p tk,p\u00b7t\u2032`,p t = g \u2211 p tk,p\u00b7t\u2032 > p,` t = g \u03b4k,` t = g \u03b4i,j t\nC.5 Particular Changes\nLet us consider a triple (a \u00b7 G1, b \u00b7 G1, c \u00b7 G1), that is either a Diffie-Hellman tuple (i.e., c = ab mod q) or a random tuple (i.e., c = ab + \u03c4 mod q, for \u03c4\n$\u2190 Z\u2217q). For any random dual orthogonal bases U and U\u2217 associated to the matrices U and U \u2032 = (U\u22121)>, respectively, we can set\nB = ( 1 a 0 1 ) 1,2\nB\u2032 = ( 1 0 \u2212a 1 ) 1,2\nB = B \u00b7 U B\u2217 = B\u2032 \u00b7 U\u2217\nNote that we can compute B = (bi)i, as we know a \u00b7G1 and all the scalars in U : bi = \u2211 k Bi,k \u00b7 uk bi,j = \u2211 k Bi,k \u00b7 uk,j = \u2211 k Bi,kUk,j \u00b7G1 = \u2211 k Uk,j \u00b7 (Bi,j \u00b7G1).\nHence, to compute bi, one needs all the scalars in U , but only the group elements Bi,j \u00b7G1, and so G1 and a \u00b7G1. This is the same for B\u2217, excepted for the vector b\u22172 as a \u00b7G2 is missing. One can thus publish B and B\u2217\\{b\u22172}.\nIndistinguishability of Sub-Spaces. As already remarked, for such a fixed matrix B, if U is random, so is B too, and (~x)B = (~x \u00b7B)U, so (~x)U = (~x \u00b7B\u22121)B. Note that B\u22121 = B\u2032>. So, in particular\n(b, c, 0, . . . , 0)U + (x1, x2, x3, . . . , xn)B\n= (b, c\u2212 ab, 0, . . . , 0)B + (x1, x2, x3, . . . , xn)B = (x1 + b, x2 + \u03c4, x3, . . . , xn)B\nwhere \u03c4 can be either 0 or random. Note that whereas we cannot compute b\u22172, this does not exclude this second component in the computed vectors: (~y)U\u2217 = (~y \u00b7B\u2032\u22121)B\u2217 = (~y \u00b7B>)B\u2217 . So, in particular\n(y1, . . . , yn)U\u2217 = (y1 + ay2, y2, . . . , yn)B\u2217 .\nTheorem 21. Under the DDH Assumption in G1, for random dual orthogonal bases B and B\u2217, once having seen B and B\u2217\\{b\u22172}, and any vector (y1, y2, . . . , yn)B\u2217, for chosen y2, . . . , yn \u2208 Zq, but unknown random y1\n$\u2190 Zq, one cannot distinguish the vectors (x1, x\u20322, x3, . . . , xn)B and (x1, x2, x3, . . . , xn)B, for chosen x2, . . . , xn \u2208 Zq, but unknown random x1, x\u20322 $\u2190 Zq.\n29\nUsing the DSDH assumption instead of the DDH assumption, on two chosen values x2 and x \u2032 2, one can show that no algorithm can efficiently distinguish (x1, x2, x3, . . . , xn)B from (x1, x \u2032 2, x3, . . . , xn)B, for chosen x\u20322, x2, . . . , xn \u2208 Zq, but unknown random x1 $\u2190 Zq:\nTheorem 22 (SubSpace-Ind Property). Under the DSDH Assumption in G1, for random dual orthogonal bases B and B\u2217, once having seen B and B\u2217\\{b\u22172}, and any vector (y1, y2, . . . , yn)B\u2217, for chosen y2, . . . , yn \u2208 Zq, but unknown random y1 $\u2190 Zq, one cannot distinguish the vectors (x1, x \u2032 2, x3, . . . , xn)B and (x1, x2, x3, . . . , xn)B, for chosen x \u2032 2, x2, . . . , xn \u2208 Zq, but unknown random x1 $\u2190 Zq.\nWe stress that for this property, we only work with (b1,b2) and (b \u2217 1,b \u2217 2), but without publishing b\u22172.\nIndistinguishability of Position. Let us consider another change of basis:\nB = 1 0 00 1 0 a \u2212a 1  1,2,3\nB\u2032 = 1 0 \u2212a0 1 a 0 0 1  1,2,3\nB = B \u00b7 U B\u2217 = B\u2032 \u00b7 U\u2217\nIn this case, we can compute B = (bi)i, but not the vectors b\u22171 and b\u22172 as a \u00b7G2 is missing.\n(c,\u2212c, b, x4, . . . , xn)U = (c\u2212 ab,\u2212c+ ab, b, x4, . . . , xn)B = (\u03c4,\u2212\u03c4, b, x4, . . . , xn)B (\u03b8, \u03b8, y3, y4, . . . , yn)U\u2217 = (\u03b8, \u03b8, a\u03b8 \u2212 a\u03b8 + y3, y4, . . . , yn)B\u2217 = (\u03b8, \u03b8, y3, . . . , yn)B\u2217\nThere is the limitation for the first two components in B\u2217 to be the same:\nTheorem 23 (Pos-Ind Property). Under the DDH Assumption in G1, for random dual orthogonal bases B and B\u2217, once having seen B and B\u2217\\{b\u22171,b\u22172} and (y1, y1, y3, . . . , yn)B\u2217, for chosen y1, y3, . . . , yn \u2208 Zq, one cannot distinguish the vectors (x1,\u2212x1, x3, x4, . . . , xn)B and (0, 0, x3, x4, . . . , xn)B, for chosen x4, . . . , xn \u2208 Zq, but unknown random x1, x3 $\u2190 Zq.\nWe stress again that for this property, we only work with (b1,b2,b3) and (b \u2217 1,b \u2217 2,b \u2217 3), but without publishing (b\u22171,b \u2217 2).\nBut more useful, using the DSDH assumption on 0 and x1, which claims indistinguishability between (a \u00b7 G, b \u00b7 G, (ab + 0) \u00b7 G) and (a \u00b7 G, b \u00b7 G, (ab + x1) \u00b7 G), we have indistinguishability between\n(0, x1, x3, . . . , xn)B + (ab,\u2212ab, b, 0, . . . , 0)U = (0, x1, x3, . . . , xn)B + (ab\u2212 ab,\u2212ab+ ab, b, 0, . . . , 0)B = (0, x1, x3, . . . , xn)B (0, x1, x3, . . . , xn)B + (ab+ x1,\u2212ab\u2212 x1, b, 0, . . . , 0)U = (0, x1, x3, . . . , xn)B + (ab+ x1 \u2212 ab,\u2212ab\u2212 x1 + ab, b, 0, . . . , 0)B = (x1, 0, x3, . . . , xn)B\n(y1, y1, y3, y4, . . . , yn)U\u2217 = (y1, y1, ay1 \u2212 ay1 + y3, y4, . . . , yn)B\u2217 = (y1, y1, y3, . . . , yn)B\u2217\nHence,\nTheorem 24 (Swap-Ind Property). Under the DSDH Assumption in G1, for random dual orthogonal bases B and B\u2217, once having seen B and B\u2217\\{b\u22171,b\u22172} and (y1, y1, y3, . . . , yn)B\u2217, for chosen y1, y3, . . . , yn \u2208 Zq, one cannot distinguish the vectors (x1, 0, x3, x4, . . . , xn)B and (0, x1, x3, x4, . . . , xn)B, for chosen x1, x4, . . . , xn \u2208 Zq, but unknown random x3 $\u2190 Zq.\nAgain, for this property, we only work with (b1,b2,b3) and (b \u2217 1,b \u2217 2,b \u2217 3), but without publishing (b\u22171,b \u2217 2).\n30\nIndexing and Randomness Amplification. The crucial tool introduced in [OT12b] is the following change of basis, for chosen scalars t 6= p \u2208 Zq:\nB = 1\nt\u2212 p \u00d7  t \u2212p at\u22121 1 \u2212a 0 0 t\u2212 p  1,2,3\nB\u2032 =  1 1 0p t 0 \u2212a 0 1  1,2,3\nIn this case, we can compute B = (bi)i, but not the vectors b\u22173 as a \u00b7G2 is missing.\n(b, 0, c, x4, . . . , xn)U = (b, bp, c\u2212 ab, x4, . . . , xn)B = (b \u00b7 (1, p), \u03c4, x4, . . . , xn)B\n((t\u2212 p) \u00b7 (\u03c0, 0), \u03b4, y4, . . . , yn)U\u2217 = (\u03c0t+ at\u03b4/(t\u2212 p),\u2212\u03c0 \u2212 a\u03b4/(t\u2212 p), \u03b4, y4, . . . , yn)B\u2217 = ((\u03c0 + a\u03b4/(t\u2212 p)) \u00b7 (t,\u22121), \u03b4, y4, . . . , yn)B\u2217\nThere is the limitation for the first two components in B and B\u2217 not to be orthogonal: \u3008(1, p), (t,\u22121)\u3009 = (t\u2212 p) 6= 0: Theorem 25. Under the DDH Assumption in G1, for random dual orthogonal bases B and B\u2217, once having seen B and B\u2217\\{b\u22173}, and (\u03c0 \u00b7 (t,\u22121), y3, . . . , yn)B\u2217, for chosen y3, . . . , yn \u2208 Zq, but unknown random \u03c0\n$\u2190 Zq, and for any chosen t 6= p \u2208 Zq, one cannot distinguish the vectors (b \u00b7 (1, p), \u03c4, x4, . . . , xn)B and (b \u00b7 (1, p), 0, x4, . . . , xn)B, for chosen x4, . . . , xn \u2208 Zq, but unknown random b, \u03c4\n$\u2190 Zq. As above, we can have a more convenient theorem under the DSDH assumption:\nTheorem 26 ((Static) Index-Ind Property). Under the DSDH Assumption in G1, for random dual orthogonal bases B and B\u2217, once having seen B and B\u2217\\{b\u22173}, and (\u03c0\u00b7(t,\u22121), y3, . . . , yn)B\u2217, for chosen y3, . . . , yn \u2208 Zq, but unknown random \u03c0 $\u2190 Zq, and for any chosen t 6= p \u2208 Zq, one cannot distinguish the vectors (\u03c3\u00b7(1, p), x3, x4, . . . , xn)B and (\u03c3\u00b7(1, p), x\u20323, x4, . . . , xn)B, for chosen x\u20323, x3, x4, . . . , xn \u2208 Zq, but unknown random \u03c3\n$\u2190 Zq. For this property, we only work with (b1,b2,b3) and (b \u2217 1,b \u2217 2,b \u2217 3), but without publishing b \u2217 3. For a fixed t, we can iteratively update all the other other indices p 6= t. A recap of all the modifications can be found in Figure 8.\nD KP-ABE Scheme\nOur ultimate goal is the design of a new KP-ABE scheme with Switchable Attributes. We start from a variation of the fully-secure attribute-based encryption from [OT12b], that provides some kind of attribute-hiding property. It is in the same vein as [GPSW06]. But for the sake of clarity, just using the static Index-Ind theorem, it can only handle a polynomially-bounded universe of attributes and delegation, but with adaptive-set security (see Definition 17).\n31\nD.1 Description of the KP-ABE Scheme\nFor the construction, we will use two DPVS, of dimensions 3 and 6 respectively, in a pairingfriendly setting (G1,G2,Gt, e,G1, G2, q), using the notations introduced in Section 2.1:\nSetup(1\u03ba). The algorithm chooses two random dual orthogonal bases\nB = (b1,b2,b3) B\u2217 = (b\u22171,b\u22172,b\u22173) D = (d1,d2,d3,d4,d5,d6) D\u2217 = (d\u22171,d\u22172,d\u22173,d\u22174,d\u22175,d\u22176).\nIt sets the public parameters PK = {(b1,b3,b\u22171), (d1,d2,d3,d\u22171,d\u22172,d\u22173)}, whereas the master secret key MK = {b\u22173}. Other basis vectors are kept hidden. KeyGen(MK, T ). For an access-tree T , the algorithm first chooses a random a0 $\u2190 Zq, and a random a0-labeling (a\u03bb)\u03bb of the access-tree T , and builds the key:k\u22170 = (a0, 0, 1)B\u2217 k\u2217\u03bb = (\u03c0\u03bb(1, t\u03bb), a\u03bb, 0, 0, 0)D\u2217 for all the leaves \u03bb, where t\u03bb = A(\u03bb) and \u03c0\u03bb\n$\u2190 Zq. The decryption key dkT is then (k\u22170, (k \u2217 \u03bb)\u03bb). Delegate(dkT , T \u2032). The algorithm first generates zero-label credentials for the new attributes, with k\u2217\u03bb \u2190 (\u03c0\u03bb\u00b7(1, t\u03bb), 0, 0, 0, 0)D\u2217 , with \u03c0\u03bb\n$\u2190 Zq, for a new leaf. Keeping only the credentials useful in T \u2032, it gets a valid key from dkT . It can thereafter be randomized with a random a\u20320\n$\u2190 Zq and a random a\u20320-labeling (a\u2032\u03bb) of T \u2032, with k\u22170 \u2190 k\u22170 + (a\u20320, 0, 0)B\u2217 , and k\u2217\u03bb \u2190 k\u2217\u03bb + (\u03c0 \u2032 \u03bb \u00b7 (1, t\u03bb), a\u2032\u03bb, 0, 0, 0)D\u2217 , for \u03c0\u2032\u03bb\n$\u2190 Zq. Encaps(PK, \u0393 ). For the set \u0393 of attributes, the algorithm first chooses random scalars \u03c9, \u03be\n$\u2190 Zq. It then sets K = g\u03bet and generates the ciphertext C = (c0, (ct)t\u2208\u0393 ) where c0 = (\u03c9, 0, \u03be)B and ct = (\u03c3t(t,\u22121), \u03c9, 0, 0, 0)D, for all the attributes t \u2208 \u0393 and \u03c3t $\u2190 Zq. Decaps(dkT , C). The algorithm first selects an evaluation pruned tree T \u2032 of T that is satisfied by \u0393 . This means that the labels a\u03bb for all the leaves \u03bb in T \u2032 allow to reconstruct a0 by simple additions. Note that from every leaf \u03bb in T \u2032 and t = t\u03bb = A(\u03bb) \u2208 \u0393 , it can compute\nct \u00d7 k\u2217t = g \u03c3t\u00b7\u03c0\u03bb\u00b7\u3008(t,\u22121),(1,t)\u3009+\u03c9\u00b7a\u03bb t = g \u03c9\u00b7a\u03bb t .\nHence, it can derive g\u03c9\u00b7a0t . From c0 and k \u2217 0, it gets c0\u00d7k\u22170 = g \u03c9\u00b7a0+\u03be t which then easily leads to K = g\u03bet . We stress that in the above decryption, one can recover g\u03c9\u00b7a0t if and only if there is an evaluation pruned tree T \u2032 of T that is satisfied by \u0393 . And this holds if and only if T (\u0393 ) = 1. Additionally, since b\u22173 is not public but in MK only, for the key issuer, only the latter can issue keys, but anybody can delegate a key for a tree T into a key for a more restrictive tree T \u2032. As everything can be randomized (the random coins \u03c0\u03bb and the labeling), the delegated keys are perfectly indistinguishable from fresh keys. Hence, given two keys possibly delegated from a common key, one cannot decide whether they have been independently generated or delegated.\nD.2 Security Analysis of the KP-ABE\nWe first consider the security analysis, without delegation, as it is quite similar to [OT12b], but under the SXDH assumption instead of the DLIN assumption:\nTheorem 27. Under the SXDH assumption, no adversary can win the IND security game (without delegation) against our KP-ABE scheme, in the Adaptive-Set setting, with non-negligible advantage.\nThis theorem is proven in details in the appendix D.3, with exact bound for an adversary with running time bounded by t, where P is the size of the universe of the attributes and K is the number of queries to the OKeyGen-oracle:\nAdvind(A) \u2264 2(KP 2 + 1)\u00d7 AdvddhG1 (t) + (3P + 1)K \u00d7 Adv ddh G2 (t)\n\u2264 (2KP 2 + 3KP +K + 2)\u00d7 Advsxdh(t)\n32\nThe global sequence of games is described on Figure 9, with another sequence of sub-games on Figure 10. In the two first games G1 and G2, one is preparing the floor with a random \u03c4\nand random masks zt in the ciphertexts ct (actually, the challenge ciphertext corresponding to the attribute t). Note that until the challenge query is asked, one does not exactly know the attributes in \u0393 (as we are in the adaptive-set setting), but we prepare all the material for all possible ct, and only the ones corresponding to attributes in \u0393 will be provided to the adversary. The main step is to get to Game G3, with an additional labeling (s`,0, (s`,\u03bb)\u03bb), using hybrid games starting from Game G2. The sequence on Figure 10 gives more details: the new labelling is added in each `-th key (in G2.k.1), then each label is masked by the random zt for each attribute t (in G2.k.2). In order to go to game G2.k.3 one exploits the limitations one expects\n33\nfrom the adversary in the security game: the adversary cannot ask keys on access-trees T such that T (\u0393 ) = 1, for the challenge set \u0393 .\nWe stress that this construction makes more basis vectors public, than in the original proof from [OT12b], and only b\u22173 is for the key issuer. This is the reason why we can deal with delegation for any user. In addition, as delegation provides keys that are perfectly indistinguishable from fresh keys, one can easily get the full result:\nCorollary 28. Under the SXDH assumption, no adversary can win the Del-IND security game against the KP-ABE scheme, in the Adaptive-Set setting, with non-negligible advantage.\nThe bound is the same, except K is the global number of OKeyGen and ODelegate queries.\nD.3 IND-Security Proof of the KP-ABE Scheme\nIn this section, we will focus on the IND-security proof of the KP-ABE scheme, where the definition is quite similar to Definition 17, but without the Delegation-Oracle.\nDefinition 29 (Indistinguishability). IND-security for KP-ABE is defined by the following game:\nInitialize: The challenger runs the Setup algorithm of KP-ABE and gives the public parameters PK to the adversary; OKeyGen(T : The adversary is allowed to issue KeyGen-queries for any access-tree T of its choice, and gets back the decryption key dkT ; RoREncaps(\u0393 ): The adversary submits one real-or-random encapsulation query on a set of attributes \u0393 . The challenger asks for an encapsulation query on \u0393 and receives (K0, C). It also generates a random key K1. It eventually flips a random coin b, and outputs (Kb, C) to the adversary; Finalize(b\u2032): The adversary outputs a guess b\u2032 for b. If for some access-tree T asked to the OKeyGen-oracle, T (\u0393 ) = 1, on the challenge set \u0393 , \u03b2 $\u2190 {0, 1}, otherwise one sets \u03b2 = b\u2032. One outputs \u03b2.\nThe advantage of an adversary A in this game is defined as\nAdvind(A) = Pr[\u03b2 = 1|b = 1]\u2212 Pr[\u03b2 = 1|b = 0].\nThe global sequence of games will follow the steps shown on Figure 9. But while the first steps (from G0 to G2) will be simple, the big step from G2 to G3 will need multiple hybrid games, presented on Figure 10. All theses games work in a pairing-friendly setting (G1,G2,Gt, e,G1, G2, q), with two random dual orthogonal bases (B,B\u2217) and (D,D\u2217) of size 3 and 6, respectively.\nIn the following proof, we will use t to denote attributes, and thus the indices for the possible ciphertexts ct associated to each attribute in the challenge ciphertext. We indeed anticipate all the possible ct, before knowing the exact set \u0393 , as we are in the adaptive setting. The variable p will be used in hybrid proofs to specify a particular attribute. We will denote P the size of the universe of attributes. Then 1 \u2264 t, p \u2264 P . Similarly, we will use ` to denote key queries, and thus the index of the global `-th key k\u2217` , whereas \u03bb will we used for the leaf in the tree of the key-query: k\u2217`,\u03bb is thus the specific key for leaf \u03bb in the global `-th key. The variable k will be used in hybrid proofs to specify a particular key-query index. We will denote K the maximal number of key-queries. Then 1 \u2264 `, k \u2264 K.\nGame G0: This is the real game where the simulator generates all the private information and sets PK = {(b1,b3,b\u22171), (d1,d2,d3,d\u22171,d\u22172,d\u22173)} and MK = {b\u22173}. The public parameters PK are provided to the adversary\n34\nOKeyGen(T`): The adversary is allowed to issue KeyGen-queries on an access-tree T` (for the `-th query), for which the challenger chooses a random scalar a`,0\n$\u2190 Zq and a random a`,0-labeling (a`,\u03bb)\u03bb of the access-tree T`, and builds the key:\nk\u2217`,0 = (a`,0, 0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0)D\u2217\nfor all the leaves \u03bb, where t`,\u03bb = A(\u03bb) is the attribute associated to the leaf \u03bb in T` and \u03c0`,\u03bb $\u2190 Zq. The decryption key dk` is then (k\u2217`,0, (k\u2217`,\u03bb)\u03bb);\nRoREncaps(\u0393 ): On the unique query on a set of attributes \u0393 , the challenger chooses random\nscalars \u03c9, \u03be, \u03be\u2032 $\u2190 Zq. It then sets K0 = g\u03bet and K1 = g\n\u03be\u2032\nt . It generates the ciphertext C = (c0, (ct)t\u2208\u0393 ) where\nc0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(1, t), \u03c9, 0, 0, 0)D\nfor all the attributes t \u2208 \u0393 and \u03c3t $\u2190 Zq. According to the real or random game (bit b\n$\u2190 {0, 1}), one outputs (Kb, C). Eventually, on adversary\u2019s guess b\u2032 for b, if for some T`, T`(\u0393 ) = 1, then \u03b2 $\u2190 {0, 1}, otherwise \u03b2 = b\u2032. Then Adv0 = Pr[\u03b2 = 1|b = 1]\u2212 Pr[\u03b2 = 1|b = 0]. In the next games, we gradually modify the simulations of OKeyGen and RoREncaps oracles, but always (at least) with random \u03c9, \u03be, \u03be\u2032, (\u03c3t)\n$\u2190 Zq, (a`,0), (\u03c0`,\u03bb) $\u2190 Zq, and random a`,0labeling (a`,\u03bb)\u03bb of the access-tree T` for each OKeyGen-query.\nGame G1: One chooses random \u03c4 $\u2190 Zq, and sets (which differs for the ciphertext only)\nc0 = (\u03c9, \u03c4, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, 0)D\nk\u2217`,0 = (a`,0, 0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0)D\u2217\nThe previous game and this game are indistinguishable under the DDH assumption in G1: one applies the SubSpace-Ind property from Theorem 22, on (B,B\u2217)1,2 and (D,D\u2217)3,4. Indeed, we can consider a triple (a \u00b7 G1, b \u00b7 G1, c \u00b7 G1), where c = ab + \u03c4 mod q with either \u03c4 = 0 or \u03c4\n$\u2190 Z\u2217q , which are indistinguishable situations under the DDH assumption. Let us assume we start from random dual orthogonal bases (U,U\u2217) and (V,V\u2217) of size 3 and 6 respectively. Then we define the matrices\nB = ( 1 a 0 1 ) 1,2\nB\u2032 = ( 1 0 \u2212a 1 ) 1,2\nD = ( 1 a 0 1 ) 3,4\nD\u2032 = ( 1 0 \u2212a 1 ) 3,4\nB = B \u00b7 U B\u2217 = B\u2032 \u00b7 U\u2217 D = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nNote that we can compute all the basis vectors excepted b\u22172 and d \u2217 4, that nobody needs: the vectors below have these coordinates at zero. So one can set\nc0 = (b, c, \u03be)U = (b, \u03c4, \u03be)B ct = (\u03c3t(1, t), b, c, 0, 0)V = (\u03c3t(1, t), b, \u03c4, 0, 0)D\nk\u2217`,0 = (a`,0, 0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0)D\u2217\nWhen \u03c4 = 0, this is exactly the previous game, with \u03c9 = b, for a random \u03c4 , this is the current game: Adv0 \u2212 Adv1 \u2264 AdvddhG1 (t).\nGame G2: One continues to modify the ciphertext, with random \u03c4, (zt) $\u2190 Zq:\nc0 = (\u03c9, \u03c4, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt)D\nk\u2217`,0 = (a`,0, 0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0)D\u2217\nThe previous game and this game are indistinguishable under the DDH assumption in G1: one applies again the SubSpace-Ind property from Theorem 22, on (D,D\u2217)(1,2),6. Indeed, we\n35\ncan consider a triple (a \u00b7 G1, b \u00b7 G1, c \u00b7 G1), where c = ab + \u03b6 mod q, with either \u03b6 = 0 or \u03b6\n$\u2190 Z\u2217q , which are indistinguishable situations under the DDH assumption. Let us assume we start from random dual orthogonal bases (B,B\u2217) and (V,V\u2217) of size 3 and 6 respectively. Then we define the matrices\nD = 1 0 a0 1 a 0 0 1  1,2,6\nD\u2032 =  1 0 00 1 0 \u2212a \u2212a 1  1,2,6\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nNote that we can compute all the basis vectors excepted d\u22176, that nobody needs: the vectors below have these coordinates at zero. One chooses additional random scalars \u03b1t, \u03b2t $\u2190 Zq to virtually set bt = \u03b1t \u00b7 b+ \u03b2t and ct = \u03b1t \u00b7 c+ \u03b2t \u00b7 a, which makes ct \u2212 abt = \u03b1t \u00b7 \u03b6. One can set\nc0 = (\u03c9, \u03c4, \u03be)B ct = (bt(1, t), \u03c9, \u03c4, 0, ct(t+ 1))V\n= (bt(1, t), \u03c9, \u03c4, 0, ct(t+ 1)\u2212 abt \u2212 abtt)D = (bt(1, t), \u03c9, \u03c4, 0, ct(t+ 1)\u2212 abt(1 + t))D = (bt(1, t), \u03c9, \u03c4, 0, \u03b1t \u00b7 \u03b6 \u00b7 (t+ 1))D = (bt(1, t), \u03c9, \u03c4, 0, \u03c4zt)D\nk\u2217`,0 = (a`,0, 0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0)D\u2217\nwhere zt = \u03b1t \u00b7 \u03b6 \u00b7 (t + 1)/\u03c4 . When \u03b6 = 0, this is exactly the previous game, as zt = 0, with \u03c0t = bt = \u03b1t \u00b7b+\u03b2t, whereas for a random \u03b6, this is the current game: Adv1\u2212Adv2 \u2264 AdvddhG1 (t).\nGame G3: We introduce a second independent s`,0-labeling s`,\u03bb for each access-tree T` and a random r`,0 to define\nk\u2217`,0 = (a`,0, r`,0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, s`,\u03bb/ztk,\u03bb)D\u2217\nBut to this, we move to a sub-sequence of hybrid games, with distinct ways for answering the k \u2212 1 first key queries and the last ones, as explained on Figure 10: for the `-th key generation query on T`, the challenger chooses three random scalars a`,0, r`,0, s`,0 $\u2190 Zq, and two random a`,0-labeling (a`,\u03bb)\u03bb and s`,0-labeling (s`,\u03bb)\u03bb of the access-tree T`, and builds the key (k\u2217`,0, (k \u2217 `,\u03bb)\u03bb), with \u03c0`,\u03bb $\u2190 Zq:\n` < k k\u2217`,0 = (a`,0, r`,0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, s`,\u03bb/zt`,\u03bb)D\u2217 ` \u2265 k k\u2217`,0 = (a`,0, 0, 1)B\u2217 k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0)D\u2217\nFor this game, we have to anticipate the values zt, for each attribute t, before knowing \u0393 , for the challenge ciphertext, as we have to introduce zt`,\u03bb during the creation of the leaves. These zt are thus random values chosen as soon as an attribute t is involved in the security game. When k = 1, this is exactly the game G2: G2 = G2.1.0, whereas for k = K + 1 this is exactly the expected game G3: G3 = G2.K+1.0. We now consider any k \u2208 {1, . . . ,K}, to show that G2.k.3 = G2.k+1.0, where all the keys for ` 6= k will be defined using the basis vectors of (B\u2217,D\u2217) and known scalars. We only focus on the k-th key and the ciphertext, but still with random \u03c9, \u03c4, \u03be, \u03be\u2032, (\u03c3t), (zt)\n$\u2190 Zq, random ak,0, (\u03c0k,\u03bb) $\u2190 Zq, as well as a random ak,0labeling (ak,\u03bb)\u03bb of the access-tree Tk, but also sk,0 $\u2190 Zq and a second independent random sk,0-labeling (sk,\u03bb)\u03bb of the access-tree Tk: Game G2.k.0: This is exactly as described above, for ` = k:\nc0 = (\u03c9, \u03c4, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt)D\nk\u2217k,0 = (ak,0, 0, 1)B\u2217 k \u2217 k,\u03bb = (\u03c0k,\u03bb(tk,\u03bb,\u22121), ak,\u03bb, 0, 0, 0)D\u2217\n36\nGame G2.k.1: One now introduces the second labeling:\nc0 = (\u03c9, \u03c4, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt)D k\u22170 = (ak,0, sk,0, 1)B\u2217 k \u2217 k,\u03bb = (\u03c0k,\u03bb(tk,\u03bb,\u22121), ak,\u03bb, sk,\u03bb, 0, 0)D\u2217\nThis game is indistinguishable from the previous one under the DDH assumption in G2: one applies the SubSpace-Ind property from Theorem 22 on (B\u2217,B)1,2 and (D\u2217,D)3,4. Indeed, we can consider a triple (a \u00b7G2, b \u00b7G2, c \u00b7G2), where c = ab+ \u03c1 mod q, with either \u03c1 = 0 or \u03c1\n$\u2190 Z\u2217q , which are indistinguishable situations under the DDH assumption. Let us assume we start from random dual orthogonal bases (U,U\u2217) and (V,V\u2217) of size 3 and 6 respectively. Then we define the matrices\nB\u2032 = ( 1 a 0 1 ) 1,2\nB = ( 1 0 \u2212a 1 ) 1,2\nD\u2032 = ( 1 a 0 1 ) 3,4\nD = ( 1 0 \u2212a 1 ) 3,4\nB\u2217 = B\u2032 \u00b7 U\u2217 B = B \u00b7 U D\u2217 = D\u2032 \u00b7 V\u2217 D = D \u00b7 V\nNote that we can compute all the basis vectors excepted b2 and d4. But we can define the ciphertext vectors in the original bases (U,V), and all the keys in bases (B\u2217,D\u2217), excepted the k-th one:\nc0 = (\u03c9, \u03c4, \u03be)U = (\u03c9 + a\u03c4, \u03c4, \u03be)B\nct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt)V = (\u03c3t(1, t), \u03c9 + a\u03c4, \u03c4, 0, \u03c4zt)D\nk\u2217k,0 = (b0, 0, 1)B\u2217 + (b, c, 0)U\u2217 = (b0, 0, 1)B\u2217 + (b, \u03c1, 0)B\u2217 = (b0 + b, \u03c1, 1)B\u2217 k\u2217k,\u03bb = (\u03c0k,\u03bb(tk,\u03bb,\u22121), b\u03bb, 0, 0, 0)D\u2217 + (0, 0, b \u00b7 b\u2032\u03bb, c \u00b7 b\u2032\u03bb, 0, 0)V\u2217 = (\u03c0k,\u03bb(tk,\u03bb,\u22121), b\u03bb, 0, 0, 0)D\u2217 + (0, 0, b \u00b7 b\u2032\u03bb, \u03c1 \u00b7 b\u2032\u03bb, 0, 0)D\u2217 = (\u03c0k,\u03bb(tk,\u03bb,\u22121), b\u03bb + b \u00b7 b\u2032\u03bb, \u03c1 \u00b7 b\u2032\u03bb, 0, 0)D\u2217\nwith b0 $\u2190 Zq, a random b0-labeling (b\u03bb)\u03bb, and a random 1-labeling (b\u2032\u03bb)\u03bb of Tk. When \u03c1 = 0, this is exactly the previous game, with \u03c9 = \u03c9 + a\u03c4 , and ak,0 = b0 + b, ak,\u03bb = b\u03bb + b \u00b7 b\u2032\u03bb, whereas for a random \u03c1, this is the current game, with additional sk,0 = \u03c1, sk,\u03bb = \u03c1 \u00b7 b\u2032\u03bb: Adv2.k.0 \u2212 Adv2.k.1 \u2264 AdvddhG2 (t).\nGame G2.k.2: With the same inputs, one just changes as follows\nc0 = (\u03c9, \u03c4, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zk)D\nk\u2217k,0 = (ak,0, sk,0, 1)B\u2217 k \u2217 k,\u03bb = (\u03c0k,\u03bb(tk,\u03bb,\u22121), ak,\u03bb, 0, 0, sk,\u03bb/zk)D\u2217\nUnfortunately, for the latter gap, which intuitively exploits the Swap-Ind property from Theorem 24, we cannot do all the changes at once. Then, the Index-Ind property will be applied first, with Theorem 26. We will thus describe another sequence of games, as shown on Figure 11, where G2.k.1.p.0 with p = 1 is the previous game: G2.k.1 = G2.k.1.1.0; for any p, G2.k.1.p.5 is G2.k.1.p+1.0; and G2.k.1.p.0 with p = P + 1 is the current game: G2.k.2 = G2.k.1.P+1.0. For each p, we prove that\nAdv2.k.1.p.0 \u2212 Adv2.k.1.p.5 \u2264 2P \u00d7 AdvddhG1 (t) + 3\u00d7 Adv ddh G2 (t).\nHence, globally, we have\nAdv2.k.1 \u2212 Adv2.k.2 \u2264 2P 2 \u00d7 AdvddhG1 (t) + 3P \u00d7 Adv ddh G2 (t).\nBut before proving this huge gap, let us conclude the analysis.\n37\nGame G2.k.3: In the above game, to be a legitimate attack (that does not output a random bit \u03b2 in the Finalize procedure, but the actual output b\u2032 of the adversary), for all the key queries T`, one must have T`(\u0393 ) = 0. In particular, Tk(\u0393 ) = 0: this means that there are missing attributes in the ciphertext, and thus false leaves to make the access-tree no acceptable. More concretely, a missing attribute t means ct is not provided to the adversary, and so no information about zt is leaked. As the key only contains sk,\u03bb/ztk,\u03bb , the missing ztk,\u03bb guarantees that no information leaks about sk,\u03bb: all the false leaves \u03bb correspond to these sk,\u03bb that are unknown: only (sk,\u03bb)\u03bb\u2208L\u0393 is known, and so the root sk,0 is unpredictable.\nRemark 30. One may wonder whether previous keys that involve those ztk,\u03bb could leak some information and contradict the above argument. Let us focus on the leaf \u03bb associated to the attribute p, and so the information one could get about zp when cp is not part of the challenge ciphertext. At least, this argument holds for the first key generation, when we are in the first sequence of games, in G2.k.2 with k = 1: zp is only used in cp, that is not revealed to the adversary, and so s1,\u03bb/zp does not leak any information about s1,\u03bb. And this is the same for all the leaves associated to missing attributes. Then s1,0 can definitely be replaced by a random and independent r1,0: which is the current game G2.k.3 for k = 1. When we are in G2.k.2 for k = 2, the adversary may now have some information about s1,\u03bb/zp and s2,\u03bb/zp, but no information about s1,0 that has already been replaced by a random r1,0, which makes s1,\u03bb unpredictable, and so no additional information leaks about zp: s2,\u03bb is unpredictable. Again, the same argument holds for all the leaves associated to missing attributes: s2,0 can also be replaced by a random and independent r2,0. This is the reason of this hybrid sequence of game: if we would have first introduced the zp in all the keys, it would not have been possible to replace all the s`,0 by r`,0 in the end. This is only true when all the previous keys have already been modified. One can thus modify the key generation algorithm for the k-th key, with an independent rk,0 $\u2190 Zq:\nc0 = (\u03c9, \u03c4, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt)D\nk\u2217k,0 = (ak,0, rk,0, 1)B\u2217 k \u2217 k,\u03bb = (\u03c0k,\u03bb(tk,\u03bb,\u22121), ak,\u03bb, 0, 0, sk,\u03bb/ztk,\u03bb)D\u2217\nThis concludes this sequence of sub-games with, for each k,\nAdv2.k.0 \u2212 Adv2.k.3 \u2264 2P 2 \u00d7 AdvddhG1 (t) + (3P + 1)\u00d7 Adv ddh G2 (t).\nHence, globally, we have\nAdv2 \u2212 Adv3 \u2264 2KP 2 \u00d7 AdvddhG1 (t) + (3P + 1)K \u00d7 Adv ddh G2 (t).\nGame G4: In this game, one chooses a random \u03b8 to define the matrices\nB = ( 1 \u2212\u03b8 0 1 ) 2,3\nB\u2032 = ( 1 0 \u03b8 1 ) 2,3\nB = B \u00b7 U B\u2217 = B\u2032 \u00b7 U\u2217\nwhich only modifies b2, which is hidden, and b \u2217 3, which is kept secret:\nc0 = (\u03c9, \u03c4, \u03be)U = (\u03c9, \u03c4, \u03c4\u03b8 + \u03be)B = (\u03c9, \u03c4, \u03be \u2032\u2032)B\nk\u2217`,0 = (a`,0, r`,0, 1)U\u2217 = (a`,0, r \u2032 `,0, 1)D\u2217\nAs a consequence, any value for \u03b8 can be used, without impacting the view of the adversary, as r\u2032`,0 is indeed independent of the other variables. In this last game, a random value \u03be \u2032\u2032 is used in the ciphertext, whereas K0 = g \u03be t and K1 = g \u03be\u2032\nt : the advantage of any adversary is 0 in this last game.\n38\nIf we combine all the steps:\nWe still focus on the challenge ciphertext (c0, (ct)) and the k-th key we will denote, for the sake of clarity, as\nk\u2217k,0 = (a0, 0, 1)B\u2217 + s0 \u00b7 h\u22170 k\u2217k,\u03bb = (\u03a0k,\u03bb(tk,\u03bb,\u22121), a\u03bb, 0, 0, 0)D\u2217 + s\u03bb \u00b7 h\u2217tk,\u03bb\nwhere h\u22170 = (\u03b4, \u03c1, 0)B\u2217 and h \u2217 t = (\u03c0t(t,\u22121), \u03b4, \u03c1, 0, 0)D\u2217 for all the possible attributes. This corresponds to\nak,0 = a0 + \u03b4 \u00b7 s0 ak,\u03bb = a\u03bb + \u03b4 \u00b7 s\u03bb sk,0 = \u03c1 \u00b7 s0 sk,\u03bb = \u03c1 \u00b7 s\u03bb\n\u03c0k,\u03bb = \u03a0k,\u03bb + s\u03bb \u00b7 \u03c0tk,\u03bb\n39\nAll the other keys will be generated using the basis vectors: we stress that they all have a zero 5-th component, then d\u22175 will not be needed. In the new hybrid game, the critical point will be the p-th attribute, where, when p = 1, G2.k.1.p.0 is exactly the above Game G2.k.1, and when p = P + 1 this is the above Game G2.k.2. And it will be clear, for any p, that G2.k.1.p.5 = G2.k.1.p+1.0: with random \u03c9, \u03c4, \u03be, \u03be \u2032, \u03b4, \u03c1, (zt), (\u03c3t), (\u03c0t) $\u2190 Zq,\nGame G2.k.1.p.0: One defines the hybrid game for p:\nc0 = (\u03c9, \u03c4, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt)D h\u22170 = (\u03b4, \u03c1, 0)B\u2217 h \u2217 t = (\u03c0t(t,\u22121), \u03b4, 0, 0, \u03c1/zt)D\u2217 t < p\nh\u2217t = (\u03c0t(t,\u22121), \u03b4, \u03c1, 0, 0)D\u2217 t \u2265 p\nGame G2.k.1.p.1: One defines the matrices\nD = ( 1 \u22121 0 1 ) 4,5\nD\u2032 = ( 1 0 1 1 ) 4,5\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nwhich modifies the hidden vectors d4 and d \u2217 5, and so are not in the view of the adversary:\nct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt)V = (\u03c3t(1, t), \u03c9, \u03c4, \u03c4, \u03c4zt)D\nh\u2217t = (\u03c0t(t,\u22121), \u03b4, 0, 0, \u03c1/zt)V\u2217 = (\u03c0t(t,\u22121), \u03b4, 0, 0, \u03c1/zt)D\u2217 t < p h\u2217t = (\u03c0t(t,\u22121), \u03b4, \u03c1, 0, 0)V\u2217 = (\u03c0t(t,\u22121), \u03b4, \u03c1, 0, 0)D\u2217 t \u2265 p\nFor all the other keys, as the 5-th component is 0, the writing in basis V\u2217 is the same in basis D\u2217. Hence, the perfect indistinguishability between the two games: Adv2.k.1.p.1 = Adv2.k.1.p.0.\nGame G2.k.1.p.2: We apply the Swap-Ind property from Theorem 24, on (D\u2217,D)2,4,5: Indeed, we can consider a triple (a \u00b7 G2, b \u00b7 G2, c \u00b7 G2), where c = ab + \u03b8 mod q with either \u03b8 = 0 or \u03b8 = \u03c1, which are indistinguishable situations under the DSDH assumption. Let us assume we start from random dual orthogonal bases (B,B\u2217) and (V,V\u2217) of size 3 and 6 respectively. Then we define the matrices\nD\u2032 = 1 a \u2212a0 1 0 0 0 1  2,4,5\nD =  1 0 0\u2212a 1 0 a 0 1  2,4,5\nD\u2217 = D\u2032 \u00b7 V\u2217 D = D \u00b7 V\nNote that we can compute all the basis vectors excepted d4,d5, but we define the ciphertext on the original basis V:\nct = (\u03c3t(1, t), \u03c9, \u03c4, \u03c4, \u03c4zt)V = (\u03c3t, \u03c3tt+ a\u03c4 \u2212 a\u03c4, \u03c9, \u03c4, \u03c4, \u03c4zt)D = (\u03c3t(1, t), \u03c9, \u03c4, \u03c4, \u03c4zt)D\nh\u2217t = (\u03c0t(t,\u22121), \u03b4, 0, 0, \u03c1/zt)D\u2217 t < p h\u2217p = (\u03c0p(p,\u22121), \u03b4, \u03c1, 0, 0)D\u2217 + (b(p,\u22121), 0,\u2212c, c, 0)V\u2217\n= (\u03c0p(p,\u22121), \u03b4, \u03c1, 0, 0)D\u2217 + (b(p,\u22121), 0, ab\u2212 c,\u2212ab+ c, 0)D\u2217 = (\u03c0p(p,\u22121), \u03b4, \u03c1\u2212 \u03b8, \u03b8, 0)D\u2217\nh\u2217t = (\u03c0t(t,\u22121), \u03b4, \u03c1, 0, 0)D\u2217 t > p\nWith \u03b8 = 0, this is as in the previous game, with \u03b8 = \u03c1, this is the current game: Adv2.k.1.p.1\u2212 Adv2.k.1.p.2 \u2264 2 \u00b7 AdvddhG2 (t).\n40\nGame G2.k.1.p.3: We keep the \u03c4 value (at the 5-th hidden position) in the ciphertext for the p-th attribute only, and replace all the other values by \u03c4zt/zp:\ncp = (\u03c3t(1, t), \u03c9, \u03c4, \u03c4, \u03c4zt)D ct = (\u03c3t(1, t), \u03c9, \u03c4, \u03c4zt/zp, \u03c4zt)D t 6= p\nTo show this is possible without impacting the other vectors, we use the Index-Ind property from Theorem 26, but in another level of sequence of hybrid games, for \u03b3 \u2208 {1, . . . , P}\\{p}: Game G2.k.1.p.2.\u03b3: We consider\ncp = (\u03c3p(1, p), \u03c9, \u03c4, \u03c4, \u03c4zp)D ct = (\u03c3t(1, t), \u03c9, \u03c4, \u03c4zt/zp, \u03c4zt)D p 6= t < \u03b3 ct = (\u03c3t(1, t), \u03c9, \u03c4, \u03c4, \u03c4zt)D t \u2265 \u03b3 h\u2217t = (\u03c0t(t,\u22121), \u03b4, 0, 0, \u03c1/zt)D\u2217 t < p h\u2217p = (\u03c0p(p,\u22121), \u03b4, 0, \u03c1, 0)D\u2217 h\u2217t = (\u03c0t(t,\u22121), \u03b4, \u03c1, 0, 0)D\u2217 t > p\nWhen \u03b3 = 1, this is the previous game: G2.k.1.p.2.1 = G2.k.1.p.2, whereas with \u03b3 = P + 1, this is the current game: G2.k.1.p.2.P+1 = G2.k.1.p.3. For any \u03b3 \u2208 {1, . . . , P}, we consider a triple (a \u00b7G1, b \u00b7G1, c \u00b7G1), where c = ab+ \u03b6 mod q, with either \u03b6 = 0 or \u03b6 = \u03c4(z\u03b3/zp \u2212 1), which are indistinguishable situations under the DSDH assumption. We define the matrices\nD = 1\np\u2212 \u03b3 \u00d7  p \u2212\u03b3 ap\u22121 1 \u2212a 0 0 p\u2212 \u03b3  1,2,5\nD\u2032 =  1 1 0\u03b3 p 0 \u2212a 0 1  1,2,5\nand then D = D \u00b7 V, D\u2217 = D\u2032 \u00b7 V\u2217: we cannot compute d\u22175, but the components on this vector are all 0 excepted for h\u2217p we will define in V\u2217:\ncp = (\u03c3p(1, p), \u03c9, \u03c4, \u03c4, \u03c4zp)D c\u03b3 = (b, 0, \u03c9, \u03c4, \u03c4 + c, \u03c4z\u03b3)V = (b, b\u03b3, \u03c9, \u03c4, \u03c4 + c\u2212 ab, \u03c4z\u03b3)D = (b(1, \u03b3), \u03c9, \u03c4, \u03c4 + \u03b6, \u03c4z\u03b3)D ct = (\u03c3t(1, t), \u03c9, \u03c4, \u03c4zt/zp, \u03c4zt)D p 6= t < \u03b3 ct = (\u03c3t(1, t), \u03c9, \u03c4, \u03c4, \u03c4zt)D t > \u03b3 h\u2217t = (\u03c0t(t,\u22121), \u03b4, 0, 0, \u03c1/zt)D\u2217 t < p h\u2217p = ((p\u2212 \u03b3) \u00b7 (\u03c0, 0), \u03b4, 0, \u03c1, 0)V\u2217\n= (p \u00b7 \u03c0 + ap\u03c1,\u2212\u03c0 \u2212 a\u03c1, \u03b4, 0, \u03c1, 0)D\u2217 = ((\u03c0 + a\u03c1) \u00b7 (p,\u22121), \u03b4, 0, \u03c1, 0)D\u2217\nh\u2217t = (\u03c0t(t,\u22121), \u03b4, \u03c1, 0, 0)D\u2217 t > p\nwhich is the hybrid game with \u03c0p = \u03c0+ a\u03c1 and the 5-th component of c\u03b3 is \u03c4 + \u03b6, which is either \u03c4 when \u03b6 = 0, and thus the game G2.k.1.p.2.\u03b3 or \u03c4z\u03b3/zp when \u03b6 = \u03c4z\u03b3/zp\u2212\u03c4 , which is G2.k.1.p.2.\u03b3+1: hence, the distance between two consecutive games is bounded by Adv dsdh G1 (t).\nHence, we have Adv2.k.1.p.2 \u2212 Adv2.k.1.p.3 \u2264 2P \u00d7 AdvddhG1 (t).\nGame G2.k.1.p.4: We can now insert 1/zp in the p-th last component, and then make some\ncleaning with the matrices, for \u03b1 $\u2190 Z\u2217q\nD = ( \u03b1/\u03c1 0 1/zp 1 ) 5,6\nD\u2032 =\n( \u03c1/\u03b1 \u2212\u03c1/\u03b1zp\n0 1\n) 5,6\n41\nand then D = D \u00b7 V, D\u2217 = D\u2032 \u00b7 V\u2217. As the four vectors d5,d6 and d\u22175,d\u22176 are hidden, the modifications will not impact the view of the adversary. This consists in applying successively the matrices :\nD =\n( 1/zp 0\n0 1 ) 5,6\nD = ( 1 0 1 1 ) 5,6\nD =\n( \u03b1zp/\u03c1 0\n0 1 ) 5,6\nThen, working in (V,V\u2217) gives, in (D,D\u2217):\ncp = (\u03c3p(1, p), \u03c9, \u03c4, \u03c4, \u03c4zp)V = (\u03c3p(1, p), \u03c9, \u03c4, 0, \u03c4zp)D\nct = (\u03c3t(1, t), \u03c9, \u03c4, \u03c4zt/zp, \u03c4zt)V\n= (\u03c3t(1, t), \u03c9, \u03c4, (\u03c4zt/zp \u2212 \u03c4zt/zp) \u00b7 \u03c1/\u03b1, \u03c4zt)D t 6= p = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt)D h\u2217t = (\u03c0t(t,\u22121), \u03b4, 0, 0, \u03c1/zt)V\u2217 = (\u03c0t(t,\u22121), \u03b4, 0, 0, \u03c1/zt)D\u2217 t < p h\u2217p = (\u03c0p(p,\u22121), \u03b4, 0, \u03c1, 0)V\u2217 = (\u03c0p(p,\u22121), \u03b4, 0, \u03b1, \u03c1/zp)D\u2217 h\u2217t = (\u03c0t(t,\u22121), \u03b4, \u03c1, 0, 0)V\u2217 = (\u03c0t(t,\u22121), \u03b4, \u03c1, 0, 0)V\u2217 t > p\nWe stress again that for all the other keys, as the 5-th component is 0, the writing in basis V\u2217 is the same in basis D\u2217. Hence, the perfect indistinguishability between the two games: Adv2.k.1.p.4 = Adv2.k.1.p.3.\nGame G2.k.1.p.5: We can now remove the \u03b1 value in the p-th element of the key: We can\nconsider a triple (a \u00b7G2, b \u00b7G2, c \u00b7G2), where c = ab+ \u03b1 mod q, with either \u03b1 = 0 or \u03b1 $\u2190 Z\u2217q , which are indistinguishable situations under the DDH assumption. We define the matrices\nD\u2032 = ( 1 a 0 1 ) 2,5\nD = ( 1 0 \u2212a 1 ) 2,5\nand then D = D \u00b7V, D\u2217 = D\u2032 \u00b7V\u2217: we cannot compute d5, but the components on this vector are all 0:\ncp = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt)D ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt)D t 6= p h\u2217t = (\u03c0t(t,\u22121), \u03b4, 0, 0, \u03c1/zt)D\u2217 t < p h\u2217p = (\u2212b(p,\u22121), \u03b4, 0, c, \u03c1/zp)V\u2217 = (\u2212b(p,\u22121), \u03b4, 0, c\u2212 ab, \u03c1/zp)D\u2217\n= (\u2212b(p,\u22121), \u03b4, 0, \u03b1, \u03c1/zp)D\u2217 h\u2217t = (\u03c0t(t,\u22121), \u03b4, \u03c1, 0, 0)D\u2217 t > p\nwhich is the either the previous game when \u03b1 6= 0 or the current game with \u03b1 = 0, where \u03c0p = \u2212b: Adv2.k.1.p.4 \u2212 Adv2.k.1.p.5 \u2264 AdvddhG2 (t).\nE Security Proofs of our SA-KP-ABE Scheme\nE.1 Proof of Theorem 9 \u2013 Del-IND-Security for Encaps\nProof. We will proceed to prove this by a succession of games. At some point, our game will be in the same state as Game G0 in the proof of IND for the KP-ABE scheme, in the appendix D.3, which allows us to conclude. We stress that we use the Adaptive Index-Ind instead of the static version, but this just impacts the way we enumerate the attributes: instead of enumerating all the universe that was polynomial-size, we enumerate them in the order the appear in the security game (either in a policy or in a ciphertext). This will be important for hybrid sequences of games on attributes: t or p will actually be the attributes but also associated to their order number when they appear for the first time in the security game.\n42\nGame G0: The first game is the real game, where the simulator honestly runs the setup, with PK = {(b1,b3,b\u22171), (d1,d2,d3,d\u22171,d\u22172,d\u22173)}, SK = {d7}, and MK = {b\u22173,d\u22177}, from random dual orthogonal bases. OKeyGen(T\u0303`): The adversary is allowed to issue KeyGen-queries on an access-tree T\u0303` (for the\n`-th query), for which the simulator chooses a random scalar a`,0 $\u2190 Zq and a random a`,0-labeling (a`,\u03bb)\u03bb of the access-tree T\u0303`, and builds the key:\nk\u2217`,0 = (a`,0, 0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0, r`,\u03bb, 0, 0)D\u2217\nfor all the leaves \u03bb, where t`,\u03bb = A(\u03bb) in T`, \u03c0`,\u03bb $\u2190 Zq and r`,\u03bb $\u2190 Z\u2217q if \u03bb is an active leave or r`,\u03bb = 0 if it is passive. The decryption key dk` = (k \u2217 `,0, (k \u2217 `,\u03bb)\u03bb) is kept private, and will be used for delegation queries;\nODelegate(T\u0303 , T\u0303 \u2032): The adversary is allowed to issue Delegate-queries for an access-tree T\u0303 \u2032, of an already queried decryption key with access-tree T\u0303 = T\u0303`, with the only condition that T\u0303 \u2032 \u2264 T\u0303 . From dk` = (k\u22170, (k\u2217\u03bb)\u03bb), for \u03bb \u2208 L, then the simulator computes the delegated key as, \u2200\u03bb \u2208 L\u2032:\nk\u2032\u22170 = k \u2217 0 + (a \u2032 0, 0, 0)B\u2217 k \u2032\u2217 \u03bb = k \u2217 \u03bb + (\u03c0 \u2032 \u03bb(t\u03bb,\u22121), a\u2032\u03bb, 0, 0, 0, 0, 0, 0)D\u2217 ,\nwhere k\u2217\u03bb = (0, 0, 0, 0, 0, 0, 0)D\u2217 if \u03bb was not in L, and a\u20320 $\u2190 Zq and (a\u2032\u03bb)\u03bb is an a\u20320-labeling of T \u2032.\nRoREncaps(\u0393v, \u0393i = \u2205): On the unique query on a set of attributes \u0393 = \u0393v, the simulator chooses random scalars \u03c9, \u03be, \u03be\u2032 $\u2190 Zq. It then sets K0 = g\u03bet and K1 = g \u03be\u2032\nt . It generates the ciphertext C = (c0, (ct)t\u2208\u0393 ) where\nc0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(1, t), \u03c9, 0, 0, 0, 0, 0, 0)D\nfor all the attributes t \u2208 \u0393 and \u03c3t $\u2190 Zq. According to the real or random game (bit b\n$\u2190 {0, 1}), one outputs (Kb, C). From the adversary\u2019s guess b\u2032 for b, if for some T\u0303 \u2032 asked as a delegation-query, T\u0303 \u2032(\u0393v, \u0393i) = 1, then \u03b2\n$\u2190 {0, 1}, otherwise \u03b2 = b\u2032. We denote Adv0 = Pr[\u03b2 = 1|b = 1]\u2212 Pr[\u03b2 = 1|b = 0]. We stress that in this game, we deal with delegation queries, but only want to show they do not help to break indistinguishability of the encapsulated keys with the official Encaps algorithm, and not the private Encaps\u2217 one. Hence, \u0393i = \u2205 in the challenge ciphertext.\nGame G1: We now show it can be reduced to Game G0 from the IND security game on the KP-ABE, in the proof provided in the appendix D.3. The challenge ciphertext is already exactly the same, as we only consider Encaps. But we have to emulate the key-generation and key-delegation oracles OKeyGen and ODelegate using only the key-generation oracle from Game G0 in the proof provided in the appendix D.3, we denote OKeyGen\n\u2032, as it only partially generates our new keys, with a 7-th coordinate r`,\u03bb. First, we instantiate a list \u039b. OKeyGen(T\u0303`). The simulator calls the oracle OKeyGen\u2032(T`), and chooses r`,\u03bb $\u2190 Z\u2217q or sets r`,\u03bb \u2190 0 according to whether \u03bb \u2208 La or \u03bb \u2208 Lp. It then adds the last component r`,\u03bb on every k\u2217`,\u03bb using d \u2217 7 which is known to the simulator. Finally, it updates \u039b with a new\nentry \u039b` = (r`,\u03bb)\u03bb;\nODelegate(T\u0303`, T\u0303 \u2032). The simulator calls the oracle OKeyGen\u2032(T \u2032) to get the decryption key dk. As already noted, in the KP-ABE, a delegated key is indistinguishable from a fresh key. Then, we pick the entry r`,\u03bb from \u039b`, to the last component r`,\u03bb on every k \u2217 \u03bb using d \u2217 7\nwhich is known to the simulator. We stress that for any new leaf, not present in T\u0303` is necessarily passive in the delegated tree T\u0303 \u2032. So, if a leaf is not in \u039b`, r`,\u03bb = 0.\n44\nIn this new game, we are exactly using the security game from the IND security on the KPABE, and simulating the 7-th component using d\u22177. As this component does not change nor intervene at all in any of the games from the proof in the appendix D.3, and this is exactly the same situation as in Game G0 in that proof, we conclude by following those security games, which leads to the adversary having zero advantage in the last game.\nWe stress that this simulation of ODelegate will be used in all the following proofs: a delegated key is identical to a fresh key, excepted the common r`,\u03bb for keys delegated from the same original key.\nE.2 Proof of Theorem 10 \u2013 Del-IND-Security for Encaps\u2217\nProof. The proof will proceed by games, with exactly the same sequence as in the previous proof following the IND-security proof of the KP-ABE in the appendix D.3, except the RoREncapschallenge that allows non-empty \u0393i. For the same reason, the OEncaps-queries on pairs (\u0393v, \u0393i), with \u0393i 6= \u2205 can be simulated. Indeed, as above, everything on the 7-th component can be done independently, knowing both d7 and d \u2217 7, as these vectors will be known to the simulator, almost all the time, except in some specific gaps. In theses cases, we will have to make sure how to simulate the OEncaps ciphertexts. As explained in the proof, Section E.1, we can simulate ODelegate-queries as OKeyGen-queries, since a delegated key is identical to a fresh key, except the common r`,\u03bb for keys delegated from the same original key. We thus just have to take care about the way we choose r`,\u03bb. This will be critical in G2.k.2.3.p.6, and it will be correct as the same constraint will be applied to y`,\u03bb introduced in G2.k.2.2\nAs in the IND-security proof of the KP-ABE, the idea of the sequence is to introduce an additional labeling (s`,0, (s`,\u03bb)\u03bb) in each `-th key (in G2.k.1, from Figure 10), where each label is masked by a random zt for each attribute t (in G2.k.2).\nHowever, in order to go to game G2.k.3, one cannot directly conclude that sk,0 is independent from the view of the adversary: we only know T\u0303k(\u0393v, \u0393i) = 0, but not necessarily Tk(\u0393v \u00b7\u222a\u0393i) = 0, as in the previous proof. Hence, we revisit this gap with an additional sequence presented in the Figure 14 where we focus on the k-th key and the ciphertext, with random \u03c9, \u03c4, \u03be, \u03be\u2032, (\u03c3t), (zt)\n$\u2190 Zq, but for all the OKeyGen-query, random a`,0, (\u03c0`,\u03bb)\n$\u2190 Zq, as well as a random a`,0-labeling (a`,\u03bb)\u03bb of the access-tree Tk, but also s`,0 $\u2190 Zq and a second independent random s`,0-labeling (s`,\u03bb)\u03bb of the access-tree Tk, and an independent random r`,0 $\u2190 Zq. The goal is to replace each label sk,\u03bb by a random independent value s \u2032 k,\u03bb when utk,\u03bb \u00b7 rk,\u03bb 6= 0. As a consequence, we will consider below that s\u2032k,\u03bb denotes either the label sk,\u03bb when utk,\u03bb \u00b7 rk,\u03bb = 0 or a random scalar:\nGame G2.k.2.0: The first game is exactly G2.k.2, where the simulator honestly runs the setup, with PK = {(b1,b3,b\u22171), (d1,d2,d3,d\u22171,d\u22172,d\u22173)}, SK = {d7}, and MK = {b\u22173,d\u22177}, from random dual orthogonal bases. OKeyGen(T`) (or ODelegate-queries): The simulator builds the `-th key:\n` < k k\u2217`,0 = (a`,0, r`,0, 1)B\u2217 k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, s\u2032`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 ` = k k\u2217k,0 = (ak,0, sk,0, 1)B\u2217 k\u2217k,\u03bb = (\u03c0k,\u03bb(tk,\u03bb,\u22121), ak,\u03bb, 0, 0, sk,\u03bb/ztk,\u03bb , rk,\u03bb, 0, 0)D\u2217 ` > k k\u2217`,0 = (a`,0, 0, 1)B\u2217\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0, r`,\u03bb, 0, 0)D\u2217\nwith r`,\u03bb $\u2190 Zq if \u03bb \u2208 La or r`,\u03bb = 0 if \u03bb \u2208 Lp. The decryption key dk` is then (k\u2217`,0, (k\u2217`,\u03bb)\u03bb).\n48\nOEncaps(\u0393m,v, \u0393m,i): The simulator builds the m-th ciphertext using all the known vectors of the basis:\ncm,0 = (\u03c9m, 0, \u03bem)B cm,t = (\u03c3m,t(t,\u22121), \u03c9m, 0, 0, 0, um,t, 0, 0)D\nwith \u03c9m, \u03bem $\u2190 Zq, \u03c3m,t $\u2190 Zq and um,t $\u2190 Z\u2217q if t \u2208 \u0393m,i or um,t \u2190 0 if t \u2208 \u0393m,v. The ciphertext Cm is then (cm,0, (cm,t)t);\nRoREncaps(\u0393v, \u0393i): On the unique query on a set of attributes (\u0393v \u00b7\u222a \u0393i), the simulator generates the ciphertext C = (c0, (ct)t\u2208(\u0393v \u00b7\u222a\u0393i)) where\nc0 = (\u03c9, \u03c4, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, ut, 0, 0)D\nfor all the attributes t \u2208 (\u0393v \u00b7\u222a \u0393i), with ut $\u2190 Zq if t \u2208 \u0393i or ut = 0 if t \u2208 \u0393v. According to the real or random game (bit b\n$\u2190 {0, 1}), one outputs (Kb, C). From the adversary\u2019s guess b\u2032 for b, if for some T\u0303 , T\u0303 (\u0393v, \u0393i) = 1, then \u03b2 $\u2190 {0, 1}, otherwise \u03b2 = b\u2032. We denote Adv2.k.2.0 = Pr[\u03b2 = 1|b = 1] \u2212 Pr[\u03b2 = 1|b = 0]. The goal of this sequence of games is to replace sk,0, that can be derived by an acceptable set of sk,\u03bb, by a random and independent value rk,0, in the key generated during the k-th OKeyGen-query. Indeed, to be a legitimate attack (that does not randomize the adversary\u2019s guess b\u2032), for all the key queries T\u0303`, one must have T\u0303`(\u0393v, \u0393i) = 0. In particular, T\u0303k(\u0393v, \u0393i) = 0: this means that\n\u2013 either the regular access-tree policy is not met, i.e., Tk(\u0393v \u00b7\u222a \u0393i) = 0.\n\u2013 or the regular access-tree policy is met, but one active key leaf matches one invalid ciphertext attribute: \u2200T \u2032 \u2208 EPT(Tk, \u0393v \u00b7\u222a \u0393i),\u2203\u03bb \u2208 T \u2032 \u2229 La, A(\u03bb) \u2208 \u0393i, and from the assumptions, for any such tree T \u2032, the active leave is an independent leave.\nIn both cases, we will use the same technique to show sk,0 is independent from any other value. But first, we will replace all the active leaves associated to invalid ciphertexts in the challenge ciphertext by inactive leaves. Of course, in the following sequence, we will have to take care of the simulation of the challenge ciphertext, but also of the OEncaps-oracle. For the latter, we will have to clarify how we do the simulation when public vectors (d1,d2,d3) or the private vector d7 are impacted.\nGame G2.k.2.1: In this game, we first clean the 4-th column of the ciphertext from the \u03c4 . To this aim, we are given a tuple (a \u00b7G1, b \u00b7G1, c \u00b7G1) in G1, where c = ab+\u00b5 mod q with either \u00b5 = 0 or \u00b5 = \u03c4 (fixed from c0). When we start from random dual orthogonal bases (U,U\u2217) and (V,V\u2217) of size 3 and 7 respectively, one considers the matrices:\nD = ( 1 a 0 1 ) 3,4\nD\u2032 = ( 1 0 \u2212a 1 ) 3,4\nD\u2217 = D\u2032 \u00b7 V\u2217 D = D \u00b7 V\nWe can calculate all vectors but d\u22173. Hence, there is no problem for simulating the OEncapsqueries. For the challenge ciphertext, we exploit the DSDH assumption:\nct = (\u03c3t(1, t), b, c, 0, \u03c4zt, ut, 0, 0)V = (\u03c3t(1, t), b, c\u2212 ab, 0, \u03c4zt, ut, 0, 0)D = (\u03c3t(1, t), b, \u00b5, 0, \u03c4zt, ut, 0, 0)D\nwhich is correct, with \u03c9 = b and according to \u00b5, this is either \u03c4 , as in the previous game or 0 as in this game. For the keys, one notes that the 4-th component is 0, and so the change of basis has no impact on the 3-rd component, when using basis V\u2217:\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, . . .)V\u2217 = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, . . .)D\u2217\nThen, we have Adv2.k.2.0 \u2212 Adv2.k.2.1 \u2264 2 \u00b7 AdvddhG1 (t).\n49\nGame G2.k.2.2: In this game, we can now introduce noise in the 4-th column the keys. In order to properly deal with delegated keys, as for r`,\u03bb that have to be the same values for all the leaves delegated from the same initial key, we will also set the same random y`,\u03bb. To this aim, we are given a tuple (a \u00b7 G2, b \u00b7 G2, c \u00b7 G2) in G2, where c = ab + \u03b6 mod q with either \u03b6 = 0 or \u03b6\n$\u2190 Z\u2217q . We choose additional random scalars \u03b1`,\u03bb, \u03b2`,\u03bb $\u2190 Zq (but the same \u03b1`,\u03bb for\nall the leaves delegated from the same initial key), to virtually set b`,\u03bb = \u03b1`,\u03bb \u00b7 b + \u03b2`,\u03bb and c`,\u03bb = \u03b1`,\u03bb \u00b7 c+ \u03b2`,\u03bb \u00b7 a, then c`,\u03bb \u2212 ab`,\u03bb = \u03b6 \u00b7 \u03b1`,\u03bb, which are either 0 or independent random values. When we start from random dual orthogonal bases (U,U\u2217) and (V,V\u2217) of size 3 and 7 respectively, one considers the matrices:\nD = ( 1 0 a 1 ) 2,4\nD\u2032 = ( 1 \u2212a 0 1 ) 2,4\nD\u2217 = D\u2032 \u00b7 V\u2217 D = D \u00b7 V\nWe can calculate all vectors but d4, which is not used anywhere. Then, for the keys, we exploit the DDH assumption:\nk\u2217`,\u03bb = (b`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, c`,\u03bb, . . .)V\u2217 = (b`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, c`,\u03bb \u2212 ab`,\u03bb, . . .)D\u2217 = (b`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, \u03b6 \u00b7 \u03b1`,\u03bb, . . .)D\u2217\nWhich is either the previous game, with \u03c0`,\u03bb = b`,\u03bb, when \u03b6 = 0, or the current game with y`,\u03bb = \u03b6 \u00b7 \u03b1`,\u03bb (the same random y`,\u03bb for all the leaves delegated from the same initial key): Adv2.k.2.1 \u2212 Adv2.k.2.2 \u2264 AdvddhG2 (t).\nGame G2.k.2.3: In this game, we duplicate every r`,\u03bb into the 5-th column of the key. To this aim, one defines the matrices\nD = ( 1 1 0 1 ) 5,7\nD\u2032 = ( 1 0 \u22121 1 ) 5,7\nD\u2217 = D\u2032 \u00b7 V\u2217 D = D \u00b7 V\nwhich only modifies d5, which is hidden, and d \u2217 7, which is secret, so the change is indistinguishable for the adversary. One can compute the keys and ciphertexts as follows, for all leaves \u03bb of each query ` of the adversary:\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, 0, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)V\u2217 = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bb, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217\nct = (\u03c3t(1, t), \u03c9, 0, 0, \u03c4zt, ut, 0, 0)V = (\u03c3t(1, t), \u03c9, 0, 0, \u03c4zt, ut, 0, 0)D\nAs the 5-th component in the ciphertext is 0, the change of basis makes no change. And this is the same for the ciphertexts generated by the OEncaps-simulation. Hence, the perfect indistinguishability between the two games: Adv2.k.2.3 = Adv2.k.2.2.\nGame G2.k.2.4: In this game, we target the k-th OKeyGen-query, and replace sk,\u03bb by an independent s\u2032k,\u03bb for all the active leaves that correspond to an invalid attribute in the challenge ciphertext. For the sake of simplicity, s\u2032`,\u03bb is either the label s`,\u03bb when r`,\u03bb \u00b7 ut`,\u03bb = 0, or a random independent scalar in Zq:\nk\u2217k,0 = (ak,0, sk,0, 1)B\u2217 k\u2217k,\u03bb = (\u03c0k,\u03bb(tk,\u03bb,\u22121), ak,\u03bb, yk,\u03bb, 0, s\u2032k,\u03bb/ztk,\u03bb , rk,\u03bb, 0, 0)D\u2217\nBut to this aim, we will need an additional sequence of sub-games G2.k.2.3.p.\u2217, that will operate iteratively on each attribute p, to convert G2.k.2.3 into G2.k.2.4, as presented in the Figure 15. But we first complete the first sequence, and details the sub-sequence afterwards.\n50\nGame G2.k.2.5: For the k-th key query, one can now replace sk,0 by rk,0. Indeed, as explained in the Remark 30, for missing ciphertexts in the challenge ciphertext, the associated leaves in the key have unpredictable sk,\u03bb. In addition, for active leaves that correspond to invalid attributes in the challenge ciphertext, sk,\u03bb have been transformed into s \u2032 k,\u03bb, random independent values.\nThen, we can consider that all the leaves associated to attributes not in \u0393 are false, but also active leaves associated to attributes in \u0393i are false. As T\u0303k(\u0393v, \u0393i) = 0, the root label is unpredictable. One thus generates the k-th key query as:\nk\u2217k,0 = (ak,0, rk,0, 1)B\u2217 k\u2217k,\u03bb = (\u03c0k,\u03bb(tk,\u03bb,\u22121), ak,\u03bb, yk,\u03bb, 0, s\u2032k,\u03bb/ztk,\u03bb , rk,\u03bb, 0, 0)D\u2217\nGame G2.k.2.6: We can now invert the above step, when we added y`,\u03bb: Adv2.k.2.5\u2212Adv2.k.2.6 \u2264 AdvddhG2 (t).\nGame G2.k.2.7: We can now invert the above step, when we removed \u03c4 from the ciphertext: Adv2.k.2.6 \u2212 Adv2.k.2.7 \u2264 2 \u00b7 AdvddhG1 (t).\nWe now detail the sub-sequence starting from G2.k.2.3.p.0 to prove the indistinguishability between G2.k.2.3 and G2.k.2.4. In the new hybrid game G2.k.2.3.p.0, the critical point will be the p-th ciphertext, where, when p = 1, this is exactly the above Game G2.k.2.3, and when p = P + 1, this is the above Game G2.k.2.4. And it will be clear, for any p, that G2.k.2.3.p.11 = G2.k.2.3.p+1.0.\nWith random \u03c9, \u03c4, \u03be, \u03be\u2032, (\u03c3t), (zt) $\u2190 Zq, but for all the OKeyGen-query, random a`,0, (y\u03bb), (\u03c0`,\u03bb) $\u2190 Zq, as well as a random a`,0-labeling (a`,\u03bb)\u03bb of the access-tree Tk, but also s`,0 $\u2190 Zq and a second independent random s`,0-labeling (s`,\u03bb)\u03bb of the access-tree Tk, and an independent random r`,0 $\u2190 Zq:\nGame G2.k.2.3.p.0: One defines the hybrid game for p:\nk\u2217k,0 = (ak,0, sk,0, 1)B\u2217\ntk,\u03bb < p k \u2217 k,\u03bb = (\u03c0k,\u03bb(tk,\u03bb,\u22121), ak,\u03bb, yk,\u03bb, rk,\u03bb, s\u2032k,\u03bb/ztk,\u03bb , rk,\u03bb, 0, 0)D\u2217 tk,\u03bb \u2265 p k\u2217k,\u03bb = (\u03c0k,\u03bb(tk,\u03bb,\u22121), ak,\u03bb, yk,\u03bb, rk,\u03bb, sk,\u03bb/ztk,\u03bb , rk,\u03bb, 0, 0)D\u2217\nwhere s\u2032`,\u03bb is either the label s`,\u03bb when r`,\u03bb \u00b7 ut`,\u03bb = 0, or a random independent scalar in Zq (when this is an active leaf that corresponds to an invalid ciphertext). So one can note that if at the challenge query p \u2208 \u0393v, then up = 0, and so we can jump to G2.k.2.3.p.11, but we do not know it before the challenge-query is asked, whereas we have to simulate the keys. This is the reason why we need to know the super sets Av and Ai: the challenge ciphertext is anticipated with up = 0 if p \u2208 Av or with up $\u2190 Z\u2217q if p \u2208 Ai.\nGame G2.k.2.3.p.1: The previous game and this game are indistinguishable under the DDH assumption in G1: one essentially uses theorem 24. Given a tuple (a \u00b7 G1, b \u00b7 G1, c \u00b7 G1) in G1, where c = ab + \u00b5 mod q with either \u00b5 = 0 or \u00b5 = up, the 7-th component of the p-th ciphertext. When we start from random dual orthogonal bases (U,U\u2217) and (V,V\u2217) of size 3 and 7 respectively, one considers the matrices:\nD = 1 a \u2212a0 1 0 0 0 1  1,5,7\nD\u2032 =  1 0 0\u2212a 1 0 a 0 1  1,5,7\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nWe can calculate all vectors but d\u22175 and d \u2217 7, which are not in the public key. Through V, we calculate the challenge ciphertext for the attribute of the p-th ciphertext\ncp = (0, 0, \u03c9, 0, 0, \u03c4zp, up, 0, 0)D + (b(1, p), 0, 0, c, 0,\u2212c, 0, 0)V = (0, 0, \u03c9, 0, 0, \u03c4zp, up, 0, 0)D + (b(1, p), 0, 0, c\u2212 ab, 0, ab\u2212 c, 0, 0)D = (b(1, p), \u03c9, 0, \u00b5, \u03c4zp, up \u2212 \u00b5, 0, 0)D\n51\nIf \u00b5 = 0, we are in the previous game. If \u00b5 = up, then we are in the current game. Then, every other ciphertext is computed directly in D:\n\u2200t 6= p, ct = (\u03c3t(1, t), \u03c9, 0, 0, \u03c4zt, ut, 0, 0)D\nas well as the answers to OEncaps-queries. The keys are calculated through V\u2217 but are unchanged by the change of basis because the 5-th and 7-th components are exactly the same for every key query `, and thus cancel themselves in the 1st component. We thus have Adv2.k.2.3.p.0 \u2212 Adv2.k.2.3.p.1 \u2264 2 \u00b7 AdvddhG1 (t).\nGame G2.k.2.3.p.2: We keep the r`,\u03bb value (at the 5-th hidden position) in the keys such that t`,\u03bb = p, and replace it in all other keys by 0, in order to prepare the possibility to later modify the ciphertexts on this component. To show this is possible without impacting the other vectors, we use the Index-Ind property from Theorem 3, but in another level of sequence of hybrid games, for \u03b3 \u2208 {1, . . . , P}\\{p}. We will enumerate \u03b3 in their order of appearance in the security game (wether in key queries, or ciphertexts), therefore we can treat an unbounded number of \u03b3. Game G2.k.2.3.p.1.\u03b3: We consider the following hybrid game, where the first satisfied condition\non the indices is applied:\ncp = (\u03c3p(1, p), \u03c9, 0, up, \u03c4zp, 0, 0, 0)D ct = (\u03c3t(1, t), \u03c9, 0, 0, \u03c4zt, ut, 0, 0)D t 6= p\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bb, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 t`,\u03bb = p k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, 0, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 p 6= t`,\u03bb < \u03b3 k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bb, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 p 6= t`,\u03bb \u2265 \u03b3\nwhere s\u2217`,\u03bb is either s \u2032 `,\u03bb, s`,\u03bb, or 0:\ns\u2217`,\u03bb = s \u2032 `,\u03bb if ` < k, or ` = k, tk,\u03bb < p s\u2217`,\u03bb = s`,\u03bb if ` = k, tk,\u03bb \u2265 p s\u2217`,\u03bb = 0 if ` > k\nWhen \u03b3 = 1, this is the previous game: G2.k.2.3.p.1.1 = G2.k.2.3.p.1, whereas with \u03b3 = P + 1, this is the current game: G2.k.2.3.p.1.P+1 = G2.k.2.3.p.2. We will gradually replace the r`,\u03bb values, at the 5-th hidden position, by 0 (when t`,\u03bb 6= p): in this game, we deal with the case t`,\u03bb = \u03b3, for all the `-th keys. For this, we use the Adaptive Index-Ind property on (D,D\u2217)1,2,5,8,9, with:\ncp = (\u03c3p(1, p), \u03c9, 0, up, \u03c4zp, 0, 0, 0)D\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bb, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 t`,\u03bb = \u03b3\nWith all this sequence, we have Adv2.k.2.3.p.1\u2212Adv2.k.2.3.p.2 \u2264 2P \u00b7(8\u00d7AdvddhG1 (t)+4\u00d7Adv ddh G2 (t)).\nGame G2.k.2.3.p.3: The previous game (in bases (U,U\u2217,V,V\u2217)) and this game (in bases (B,B\u2217,D,D\u2217)) are perfectly indistinguishable by using a formal change of basis, on hidden vectors, with\nD = ( \u03c4zp up ) 5\nD\u2032 = ( up \u03c4zp ) 5\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nThe challenge ciphertext and keys that are impacted become:\ncp = (\u03c3p(1, p), \u03c9, 0, up, \u03c4zp, 0, 0, 0)V\n= (\u03c3p(1, p), \u03c9, 0, \u03c4zp, \u03c4zp, 0, 0, 0)D\n\u2200`, t`,\u03bb = p, k\u2217`,\u03bb = (\u03c0`,\u03bb(p,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bb, s\u2217`,\u03bb/zp, r`,\u03bb, 0, 0)V\u2217 = (\u03c0`,\u03bb(p,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bbup/\u03c4zp, s\u2217`,\u03bb/zp, r`,\u03bb, 0, 0)D\u2217\n52\nAll the other vectors have a zero in these components (included the OEncaps-ciphertexts). Hence, Adv2.k.2.3.p.3 = Adv2.k.2.3.p.2. Note however this is because of this game the security result requires the semi-adaptive super-set setting: the change of basis needs to know that up 6= 0.\nGame G2.k.2.3.p.4: We keep the \u03c4zp value (at the 5-th hidden position) in the ciphertext for the p-th attribute only, and replace all the other values from 0 to \u03c4zt, which is the same value as in the 6-th component of each ciphertext, to allow a later swap of the key elements from the 6-th component to the 5-th:\ncp = (\u03c3t(1, t), \u03c9, 0, \u03c4zp, \u03c4zp, 0, 0, 0)D ct = (\u03c3t(1, t), \u03c9, 0, \u03c4zt, \u03c4zt, ut, 0, 0)D t 6= p\nTo show this is possible without impacting the other vectors, we use the Index-Ind property from Theorem 3, but in another level of sequence of hybrid games, for \u03b3 \u2208 {1, . . . , P}\\{p}. We will enumerate \u03b3 in their order of appearance in the security game (wether in key queries, or in ciphertexts), therefore we can treat an unbounded number of \u03b3. Game G2.k.2.3.p.4.\u03b3: We consider\ncp = (\u03c3p(1, p), \u03c9, 0, \u03c4zp, \u03c4zp, 0, 0, 0)D ct = (\u03c3t(1, t), \u03c9, 0, \u03c4zt, \u03c4zt, ut, 0, 0)D p 6= t < \u03b3 ct = (\u03c3t(1, t), \u03c9, 0, 0, \u03c4zt, ut, 0, 0)D p 6= t \u2265 \u03b3 k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bb, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 t`,\u03bb = p k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, 0, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 t`,\u03bb 6= p\nWhen \u03b3 = 1, this is the previous game: G2.k.2.3.p.4.1 = G2.k.2.3.p.3, whereas with \u03b3 = P + 1, this is the current game: G2.k.2.3.p.4.P+1 = G2.k.2.3.p.4. For this, we use the Adaptive Index-Ind property on (D\u2217,D)1,2,5,8,9, with:\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bb, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 t`,\u03bb = p ct = (\u03c3t(1, t), \u03c9, 0, 0, \u03c4zt, ut, 0, 0)D t = \u03b3\nWith all this sequence, we have Adv2.k.2.3.p.3\u2212Adv2.k.2.3.p.4 \u2264 2P \u00b7(8\u00d7AdvddhG2 (t)+4\u00d7Adv ddh G1 (t)).\nGame G2.k.2.3.p.5: All ciphertexts now have exactly the same value in 5-th and 6-th positions. We will thus use r`,\u03bb in the 5-th position, for keys with t`,\u03bb = p, to modify the 6-th position of said keys with a swap. The previous game and this game are indistinguishable under the DDH assumption in G2: one essentially uses theorem 24. We consider a triple (a \u00b7G2, b \u00b7G2, c \u00b7G2), where c = ab+\u03b6 mod q with either \u03b6 = 0 or \u03b6 = up/\u03c4zp, which are indistinguishable under the DSDH assumption. When we start from random dual orthogonal bases (U,U\u2217) and (V,V\u2217) of size 3 and 7 respectively, one considers the matrices:\nD =  1 0 0\u2212a 1 0 a 0 1  1,5,6\nD\u2032 = 1 a \u2212a0 1 0 0 0 1  1,5,6\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nWe can calculate all vectors but d5 and d6, which are not in the public key: However the challenge ciphertext computation through V is trivial since the 5-th and 6-th components cancel each other out. We can thus simulate them in D. For challenge ciphertexts, we set\ncp = (\u03c3t(1, t), \u03c9, 0, \u03c4zp, \u03c4zp, 0, 0, 0)V = (\u03c3t(1, t), \u03c9, 0, \u03c4zp, \u03c4zp, 0, 0, 0)D ct = (\u03c3t(1, t), \u03c9, 0, \u03c4zt, \u03c4zt, ut, 0, 0)V = (\u03c3t(1, t), \u03c9, 0, \u03c4zt, \u03c4zt, ut, 0, 0)D t 6= p\n53\nThe only keys that are calculated through V\u2217 are the ones from the k-th query so that tk,\u03bb = p. We choose additional random scalars \u03b2k,\u03bb\n$\u2190 Zq, to virtually set bk,\u03bb = rk,\u03bb \u00b7 b + \u03b2k,\u03bb and ck,\u03bb = rk,\u03bb \u00b7 c+ \u03b2k,\u03bb \u00b7 a, then ck,\u03bb \u2212 abk,\u03bb = \u03b6 \u00b7 rk,\u03bb, which is either 0 or rk,\u03bb \u00b7 up/\u03c4zp.\nk\u2217k,\u03bb = (0, 0, ak,\u03bb, yk,\u03bb, 0, 0, rk,\u03bb, 0, 0)D\u2217 + (b(p,\u22121), 0, 0, 0, rk,\u03bb \u00b7 up/\u03c4zp \u2212 ck,\u03bb, ck,\u03bb + sk,\u03bb/zp, 0, 0, 0)V\u2217 k\u2217k,\u03bb = (0, 0, ak,\u03bb, yk,\u03bb, 0, 0, rk,\u03bb, 0, 0)D\u2217\n+ (b(p,\u22121), 0, 0, bk,\u03bb, rk,\u03bb \u00b7 up/\u03c4zp \u2212 (ck,\u03bb \u2212 abk,\u03bb), (ck,\u03bb \u2212 abk,\u03bb) + sk,\u03bb/zp, 0, 0, 0)D\u2217\nk\u2217k,\u03bb = (b(p,\u22121), ak,\u03bb, yk,\u03bb, rk,\u03bb \u00b7 up/\u03c4zp \u2212 \u03b6 \u00b7 rk,\u03bb, \u03b6 \u00b7 rk,\u03bb + sk,\u03bb zp , rk,\u03bb, 0, 0)D\u2217\nIf \u03b6 = 0, we are in the previous game. If \u03b6 = up/\u03c4zp, then \u03b6 \u00b7 rk,\u03bb = rk,\u03bb \u00b7up/\u03c4zp and we are in the current game. All other keys are unchanged and calculated through D\u2217 directly, without any change. And, Adv2.k.2.3.p.4 \u2212 Adv2.k.2.3.p.5 \u2264 2 \u00b7 AdvddhG2 (t).\nGame G2.k.2.3.p.6: In this game, we want to replace rk,\u03bb when tk,\u03bb = p by a random value in the 7-th column, independently of the value in the 6-th column, so that this 6-th column value can be really random and independent from other values. We will exploit the random yk,\u03bb in the 4-th column: We consider a triple (a \u00b7G2, b \u00b7G2, c \u00b7G2), where c = ab+\u03b6 mod q with either \u03b6 = 0 or \u03b6\n$\u2190 Z\u2217q , which are indistinguishable under the DDH assumption. We choose additional random scalars \u03b1\u03bb, \u03b2\u03bb\n$\u2190 Zq, to virtually set b\u03bb = \u03b1\u03bb \u00b7b+\u03b2\u03bb and c\u03bb = \u03b1\u03bb \u00b7c+\u03b2\u03bb \u00b7a, then c\u03bb\u2212ab\u03bb = \u03b6 \u00b7\u03b1\u03bb, which are either 0 or independent random values. When we start from random dual orthogonal bases (U,U\u2217) and (V,V\u2217) of size 3 and 7 respectively, one considers the matrices:\nD = ( 1 0 \u2212a 1 ) 4,7\nD\u2032 = ( 1 a 0 1 ) 4,7\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nWe can calculate all vectors but d7, which is not in the public key. Through V, we calculate the challenge ciphertext, and the OEncaps-answers, when the 7-th component is non-zero, as the 0 value of the 4-th component does not impact the 7-th during the change of basis. On the other hand, all the keys can be directly generated in D\u2217, except kk,\u03bb when tk,\u03bb = p, for which we use the DDH assumption:\nk\u2217k,\u03bb = (\u03c0k,\u03bb(p,\u22121), ak,\u03bb, 0, 0, sk,\u03bb + rk,\u03bb \u00b7 up/\u03c4\nzp , rk,\u03bb, 0, 0)D\u2217\n+ (0, 0, 0, b\u03bb, 0, 0, c\u03bb, 0, 0)V\u2217\n= (\u03c0k,\u03bb(p,\u22121), ak,\u03bb, 0, 0, sk,\u03bb + rk,\u03bb \u00b7 up/\u03c4\nzp , rk,\u03bb, 0, 0)D\u2217\n+ (0, 0, 0, b\u03bb, 0, 0, c\u03bb \u2212 ab\u03bb, 0, 0)D\u2217\n= (\u03c0k,\u03bb(p,\u22121), ak,\u03bb, b\u03bb, 0, sk,\u03bb + rk,\u03bb \u00b7 up/\u03c4\nzp , rk,\u03bb + \u03b6 \u00b7 \u03b1\u03bb, 0, 0)V\u2217\nWhen \u03b6 = 0, this is the previous game, with yk,\u03bb = b\u03bb, when tk,\u03bb = p. Whereas when \u03b6 $\u2190 Z\u2217q , r\u2032k,\u03bb = rk,\u03bb+\u03b6 \u00b7\u03b1\u03bb is independent of rk,\u03bb, which makes s\u2032k,\u03bb = (sk,\u03bb+rk,\u03bb \u00b7up/\u03c4)/zp independent of sk,\u03bb when rk,\u03bb \u00b7 up 6= 0. Then, Adv2.k.2.3.p.5 \u2212 Adv2.k.2.3.p.6 \u2264 AdvddhG2 (t). In order to keep the same r`,\u03bb for all the leaves delegated from the same initial key, we also apply this additional vector (0, 0, 0, b\u03bb, 0, 0, c\u03bb)V\u2217 . This will also keep the same y`,\u03bb for all these leaves.\n54\nGame G2.k.2.3.p.7: All ciphertexts have exactly the same value in 5-th and 6-th positions. We will thus use the Swap-Ind property to revert the change made in game G2.k.2.3.p.5, with the notable difference we are now working with r\u2032k,\u03bb (which has just been randomized) instead of rk,\u03bb, for keys with tk,\u03bb = p. We are thus not restoring the initial sk,\u03bb but we get a truly random value s\u2032k,\u03bb. The previous game and this game are indistinguishable under the DDH assumption in G2: one essentially uses theorem 24. We consider a triple (a \u00b7G2, b \u00b7G2, c \u00b7G2), where c = ab+\u03b6 mod q with either \u03b6 = 0 or \u03b6 = up/\u03c4zp, which are indistinguishable under the DSDH assumption. When we start from random dual orthogonal bases (U,U\u2217) and (V,V\u2217) of size 3 and 7 respectively, one considers the matrices:\nD =  1 0 0\u2212a 1 0 a 0 1  4,5,6\nD\u2032 = 1 a \u2212a0 1 0 0 0 1  4,5,6\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nWe can calculate all vectors but d5 and d6, which are not in the public key: However, the challenge ciphertext computation through V is trivial since the 5-th and 6-th component cancel each other out. We can thus simulate them through V. We can revert as above by setting in V\u2217 the keys from the k-th query so that tk,\u03bb = p. And, Adv2.k.2.3.p.6\u2212Adv2.k.2.3.p.7 \u2264 2 \u00b7 AdvddhG2 (t). We stress that after the swap, we get, for tk,\u03bb = p\nk\u2217k,\u03bb = (\u03c0k,\u03bb(p,\u22121), ak,\u03bb, yk,\u03bb, r\u2032k,\u03bbup/\u03c4zp, (s\u2032k,\u03bb \u2212 r\u2032k,\u03bbup/\u03c4)/zp, r\u2032k,\u03bb, 0, 0)D\u2217\nwhere s\u2032k,\u03bb is a truly random value independent of r \u2032 k,\u03bb. So we are not back to game G2.k.2.3.p.4, but still with a random value in the 6-th component of the key.\nGame G2.k.2.3.p.8: We keep the \u03c4zp value (at the 5-th hidden position) in the ciphertext for the p-th attribute only, and replace all the other values from \u03c4zt to 0\ncp = (\u03c3t(1, t), \u03c9, 0, \u03c4zp, \u03c4zp, 0, 0, 0)D ct = (\u03c3t(1, t), \u03c9, 0, 0, \u03c4zt, ut, 0, 0)D t 6= p\nTo show this is possible without impacting the other vectors, we use the Index-Ind property from Theorem 3, but in another level of sequence of hybrid games, for \u03b3 \u2208 {1, . . . , P}\\{p}. We will enumerate \u03b3 in their order of appearance in the security game (wether in key queries, or in ciphertexts), therefore we can treat an unbounded number of \u03b3. Game G2.k.2.3.p.8.\u03b3: We consider\ncp = (\u03c3p(1, p), \u03c9, 0, \u03c4zp, \u03c4zp, 0, 0, 0)D ct = (\u03c3t(1, t), \u03c9, 0, 0, \u03c4zt, ut, 0, 0)D p 6= t < \u03b3 ct = (\u03c3t(1, t), \u03c9, 0, \u03c4zt, \u03c4zt, ut, 0, 0)D p 6= t \u2265 \u03b3 k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, r\u2032`,\u03bb, s\u2217`,\u03bb/zt`,\u03bb , r \u2032 `,\u03bb, 0, 0)D\u2217 t`,\u03bb = p k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, 0, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 t`,\u03bb 6= p\nWhen \u03b3 = 1, this is the previous game: G2.k.2.3.p.8.1 = G2.k.2.3.p.7, whereas with \u03b3 = P + 1, this is the current game: G2.k.2.3.p.8.P+1 = G2.k.2.3.p.8. For this, we use the Adaptive Index-Ind property on (D\u2217,D)1,2,5,8,9, with:\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, r\u2032`,\u03bb, s\u2217`,\u03bb/zt`,\u03bb , r \u2032 `,\u03bb, 0, 0)D\u2217 t`,\u03bb = p\nct = (\u03c3t(1, t), \u03c9, 0, \u03c4zt, \u03c4zt, ut, 0, 0)D t = \u03b3\nWith all this sequence, we have Adv2.k.2.3.p.7\u2212Adv2.k.2.3.p.8 \u2264 2P (8\u00d7AdvddhG2 (t)+4\u00d7Adv ddh G1 (t)).\n55\nGame G2.k.2.3.p.9: The previous game (in bases (U,U\u2217,V,V\u2217)) and this game (in bases (B,B\u2217,D,D\u2217)) are perfectly indistinguishable by using a formal change of basis, on hidden vectors, with\nD = ( up \u03c4zp ) 5\nD\u2032 = ( \u03c4zp up ) 5\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nThe challenge ciphertext and keys that are impacted become:\ncp = (\u03c3p(1, p), \u03c9, 0, \u03c4zp, \u03c4zp, 0, 0, 0)V\n= (\u03c3p(1, p), \u03c9, 0, up, \u03c4zp, 0, 0, 0)D\n\u2200`, t`,\u03bb = p, k\u2217`,\u03bb = (\u03c0`,\u03bb(p,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bb \u00b7 up/\u03c4zp, s\u2217`,\u03bb/zp, r`,\u03bb, 0, 0)D\u2217 = (\u03c0`,\u03bb(p,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bb, s\u2217`,\u03bb/zp, r`,\u03bb, 0, 0)V\u2217\nAll the other vectors have a zero in these components (included the OEncaps-ciphertexts). Hence, Adv2.k.2.3.p.9 = Adv2.k.2.3.p.8.\nGame G2.k.2.3.p.10: We keep the r \u2032 `,\u03bb value (at the 5-th hidden position) in the keys such that\nt`,\u03bb = p, and replace back the 0 in all other keys by r`,\u03bb, in order to prepare the possibility to later modify the ciphertexts on this component. To show this is possible without impacting the other vectors, we use the Index-Ind property from Theorem 3, but in another level of sequence of hybrid games, for \u03b3 \u2208 {1, . . . , P}\\{p}. We will enumerate \u03b3 in their order of appearance in the security game (wether in key queries, or in ciphertexts), therefore we can treat an unbounded number of \u03b3. Game G2.k.2.3.p.9.\u03b3: We consider the following hybrid game, where the first satisfied condition\non the indices is applied:\ncp = (\u03c3p(1, p), \u03c9, 0, up, \u03c4zp, 0, 0, 0)D ct = (\u03c3t(1, t), \u03c9, 0, 0, \u03c4zt, ut, 0, 0)D t 6= p\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bb, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 t`,\u03bb = p k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, r`,\u03bb, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 p 6= t`,\u03bb < \u03b3 k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, 0, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 p 6= t`,\u03bb \u2265 \u03b3\nwhere s\u2217`,\u03bb is either s \u2032 `,\u03bb, s`,\u03bb, or 0 When \u03b3 = 1, this is the previous game: G2.k.2.3.p.9.1 = G2.k.2.3.p.9, whereas with \u03b3 = P + 1, this is the current game: G2.k.2.3.p.9.P+1 = G2.k.2.3.p.10. We will gradually replace the 0 values, at the 5-th hidden position, by r`,\u03bb (when t`,\u03bb 6= p): in this game, we deal with the case t`,\u03bb = \u03b3, for all the `-th keys. For this, we use the Adaptive Index-Ind property on (D,D\u2217)1,2,5,8,9, with:\ncp = (\u03c3p(1, p), \u03c9, 0, up, \u03c4zp, 0, 0, 0)D\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, y`,\u03bb, 0, s\u2217`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 t`,\u03bb = \u03b3\nWith all this sequence, we have Adv2.k.2.3.p.9\u2212Adv2.k.2.3.p.10 \u2264 2P \u00b7(8\u00d7AdvddhG1 (t)+4\u00d7Adv ddh G2 (t)).\nGame G2.k.2.3.p.11: The previous game and this game are indistinguishable under the DDH assumption in G1: one essentially uses theorem 24. Given a tuple (a \u00b7 G1, b \u00b7 G1, c \u00b7 G1) in G1, where c = ab + \u00b5 mod q with either \u00b5 = 0 or \u00b5 = up, the 5-th component of the p-th ciphertext. When we start from random dual orthogonal bases (U,U\u2217) and (V,V\u2217) of size 3 and 7 respectively, one considers the matrices:\nD = 1 a \u2212a0 1 0 0 0 1  1,5,7\nD\u2032 =  1 0 0\u2212a 1 0 a 0 1  1,5,7\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\n56\nWe can calculate all vectors but d\u22175 and d \u2217 7, which are not in the public key. Through V, we calculate the challenge ciphertext for the attribute of the p-th ciphertext\ncp = (0, 0, \u03c9, 0, 0, \u03c4zp, up)D + (b(1, p), 0, 0, c, 0,\u2212c, 0, 0)V = (0, 0, \u03c9, 0, 0, \u03c4zp, up)D + (b(1, p), 0, 0, c\u2212 ab, 0, ab\u2212 c, 0, 0)D = (b(1, p), \u03c9, 0, \u00b5, \u03c4zp, up \u2212 \u00b5, 0, 0)D\nIf \u00b5 = up, we are in the previous game. If \u00b5 = 0, then we are in the current game. Then, every other ciphertext is computed directly in D:\n\u2200t 6= p, ct = (\u03c3t(1, t), \u03c9, 0, 0, \u03c4zt, ut, 0, 0)D as well as the answers to OEncaps-queries. The keys are calculated through V\u2217 but are unchanged by the change of basis because the 5-th and 7-th components are exactly the same for every key query `, and thus cancel themselves in the 1st component. We thus have Adv2.k.2.3.p.10 \u2212 Adv2.k.2.3.p.11 \u2264 2 \u00b7 AdvddhG1 (t).\nE.3 Proof of Theorem 11 \u2013 dKey-IND-Security\nProof. In this security game, the adversary has access to the OEncaps-oracle, but only for distinct key-indistinguishability: all the invalid attributes t \u2208 \u0393m,i in a OEncaps-query correspond to passive leaves \u03bb \u2208 Lp from the challenge key. We will prove it as usual with a sequence of games:\nGame G0: The first game is the real game where the simulator plays the role of the challenger, with PK = {(b1,b3,b\u22171), (d1,d2,d3,d\u22171,d\u22172,d\u22173,d\u22177)}, SK = {d7}, and MK = {b\u22173}, from random dual orthogonal bases. We note that d\u22177 can be public. OKeyGen(T\u0303`) (or ODelegate-queries): The adversary is allowed to issue KeyGen-queries on an\naccess-tree T\u0303` = (T`,L`,a,L`,p) (for the `-th query), for which the simulator chooses a random scalar a`,0\n$\u2190 Zq and a random a`,0-labeling (a`,\u03bb)\u03bb of the access-tree T`, and builds the key:\nk\u2217`,0 = (a`,0, 0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0, r`,\u03bb, 0, 0)D\u2217\nfor all the leaves \u03bb, where t`,\u03bb = A(\u03bb), \u03c0`,\u03bb $\u2190 Zq and r`,\u03bb $\u2190 Z\u2217q if \u03bb \u2208 L`,a, or else\nr`,\u03bb \u2190 0 if \u03bb \u2208 L`,p. The decryption key dk` is then (k\u2217`,0, (k\u2217`,\u03bb)\u03bb); OEncaps(\u0393m,v, \u0393m,i): The adversary is allowed to issue Encaps\n\u2217-queries on disjoint unions \u0393m = \u0393m,v \u00b7\u222a \u0393m,i of sets of attributes, for which the simulator chooses random scalars \u03c9m, \u03bem\n$\u2190 Zq. It then setsKm = g\u03bemt and generates the ciphertext Cm = (cm,0, (cm,t)t\u2208(\u0393m,v \u00b7\u222a\u0393m,i)) where\ncm,0 = (\u03c9m, 0, \u03bem)B cm,t = (\u03c3m,t(t,\u22121), \u03c9m, 0, 0, 0, um,t, 0, 0)D\nfor all the attributes t \u2208 \u0393m,v \u00b7\u222a \u0393m,i, \u03c3m,t $\u2190 Zq and um,t $\u2190 Z\u2217q if t \u2208 \u0393m,i or um,t \u2190 0 if t \u2208 \u0393m,v.\nRoAPKeyGen(T\u0303 ,La,Lp): On the unique query on an access-tree T\u0303 of its choice, with a list L = (La \u00b7\u222aLp) of active and passive leaves, the simulator chooses a random scalar a0 $\u2190 Zq, and a random a0-labeling (a\u03bb)\u03bb of the access-tree. It then sets the real key dk0 as follows,\nwith r\u03bb $\u2190 Z\u2217q if \u03bb \u2208 La, or r\u03bb \u2190 0 if \u03bb \u2208 Lp:\nk\u22170 = (a0, 0, 1)B\u2217 k \u2217 \u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, r\u03bb, 0, 0)D\u2217\nOn the other hand, it sets the all-passive key dk1 as:\nk\u22170 = (a0, 0, 1)B\u2217 k \u2217 \u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, 0, 0, 0)D\u2217\nfor all \u03bb. According to the real or all-passive (b $\u2190 {0, 1}), one outputs dkb.\nGame G1: In the second and final game, we set r\u03bb \u2190 0 for all the leaves in the real key dk0:\nk\u22170 = (a0, 0, 0)B\u2217 k \u2217 \u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, 0, 0, 0)D\u2217\nIt is then clear than Adv1 = 0, as all challenge keys are independent from b. We detail the sub-sequence starting from G0.p.0 to prove the indistinguishability between G0 and G1. In the new hybrid sequence G0.p.\u2217, we will modify all the keys associated to the p-th attribute, in an indistinguishable way, using the Index-Ind property. It is clear that G0.1.0 = G0, whereas G0.P+1.0 = G1, and G0.p.4 = G0.p+1.0.\n58\nGame G0.p.0: One defines the hybrid game for p :\ncm,t = (\u03c3m,t(1, t), \u03c9m, 0, 0, 0, um,t, 0, 0)D\nt\u03bb < p k \u2217 \u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, 0, 0, 0)D\u2217 t\u03bb \u2265 p k\u2217\u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, r\u03bb, 0, 0)D\u2217\nGame G0.p.1: In this game, we duplicate every um,t into the 5-th column of the ciphertext. To this aim, one defines the matrices\nD = ( 1 0 1 1 ) 6,7\nD\u2032 = ( 1 \u22121 0 1 ) 6,7\nD\u2217 = D\u2032 \u00b7 V\u2217 D = D \u00b7 V\nwhich only modifies d7, which is secret, and d \u2217 6, which is hidden, so the change is indistinguishable for the adversary. One can compute the keys and ciphertexts as follows, for all leaves \u03bb, and for each of each query m of the adversary:\ncm,t = (\u03c3m,t(1, t), \u03c9m, 0, 0, 0, um,t, 0, 0)V\n= (\u03c3m,t(1, t), \u03c9m, 0, 0, um,t, um,t, 0, 0)D\nt\u03bb < p k \u2217 \u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, 0, 0, 0)V\u2217 = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, 0, 0, 0)D\u2217 t\u03bb \u2265 p k\u2217\u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, r\u03bb, 0, 0)V\u2217\n= (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, r\u03bb, 0, 0)D\u2217\nHence, the perfect indistinguishability between the two games: Adv0.p.1 = Adv0.p.0.\nGame G0.p.2: The previous game and this game are indistinguishable under the DSDH assumption in G2: one essentially uses theorem 24. Given a tuple (a \u00b7 G2, b \u00b7 G2, c \u00b7 G2) in G2, where c = ab+\u00b5 mod q with either \u00b5 = 0 or \u00b5 = 1, the 7-th component of the leaf \u03bb of the challenge key, with t\u03bb = p. When we start from random dual orthogonal bases (U,U\u2217) and (V,V\u2217) of size 3 and 7 respectively, one considers the matrices:\nD =  1 0 0a 1 0 \u2212a 0 1  2,6,7\nD\u2032 = 1 \u2212a a0 1 0 0 0 1  2,6,7\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nWe can calculate all vectors but d6 and d7, which are not in the public key. Through V, we calculate the challenge key for the attribute of the p-th ciphertext We choose additional random scalars \u03b2\u03bb\n$\u2190 Zq, to virtually set b\u03bb = r\u03bb \u00b7 b + \u03b2\u03bb and c\u03bb = r\u03bb \u00b7 c+ \u03b2\u03bb \u00b7 a, then c\u03bb \u2212 ab\u03bb = \u00b5 \u00b7 r\u03bb, which is either 0 or r\u03bb.\nt\u03bb = p k \u2217 \u03bb = (0, 0, a\u03bb, 0, 0, 0, r\u03bb)D\u2217 + (b\u03bb(t\u03bb,\u22121), 0, 0, 0, c\u03bb,\u2212c\u03bb, 0, 0)V\u2217\n= (0, 0, a\u03bb, 0, 0, 0, r\u03bb, 0, 0)D\u2217 + (b\u03bb(t\u03bb,\u22121), 0, 0, 0, c\u03bb \u2212 ab\u03bb,\u2212c\u03bb + ab\u03bb, 0, 0)D\u2217 = (b\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, \u00b5 \u00b7 r\u03bb, r\u03bb \u2212 \u00b5 \u00b7 r\u03bb, 0, 0)D\u2217\nIf \u00b5 = 0, we are in the previous game. If \u00b5 = 1, then we are in the current game. Then, every other key is computed directly in D\u2217:\nt\u03bb < p k \u2217 \u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, 0, 0, 0)D\u2217 t\u03bb > p k \u2217 \u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, r\u03bb, 0, 0)D\u2217\nas well as the answers to OKeyGen-queries. The ciphertexts are calculated through V but are unchanged by the change of basis because the 6-th and 7-th components are exactly the same for every ciphertext query m, and thus cancel themselves in the 2nd component. We thus have Adv0.p.1 \u2212 Adv0.p.2 \u2264 2 \u00b7 AdvddhG2 (t).\n59\nGame G0.p.3: We keep the um,p value (at the 6-th hidden position) in the ciphertexts, and replace it in all other ciphertexts by 0. To show this is possible without impacting the other vectors, we use the Index-Ind property from Theorem 3, but in another level of sequence of hybrid games, for \u03b3 \u2208 {1, . . . , P}\\{p}. We will enumerate \u03b3 in their order of appearance in the security game (wether in key queries, or in ciphertexts), therefore we can treat an unbounded number of \u03b3. Game G0.p.2.\u03b3: We consider the following hybrid game, where the first satisfied condition\non the indices is applied:\ncm,p = (\u03c3m,p(1, p), \u03c9m, 0, 0, um,p, um,p, 0, 0)D cm,t = (\u03c3m,t(1, t), \u03c9m, 0, 0, 0, um,t, 0, 0)D p 6= t < \u03b3 cm,t = (\u03c3m,t(1, t), \u03c9m, 0, 0, um,t, um,t, 0, 0)D p 6= t \u2265 \u03b3\nKeys are unchanged throughout the hybrid game\nk\u2217\u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, 0, 0, 0)D\u2217 t\u03bb < p k\u2217\u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, r\u03bb, 0, 0, 0)D\u2217 t\u03bb = p k\u2217\u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, 0, r\u03bb, 0, 0)D\u2217 t\u03bb > p\nWhen \u03b3 = 1, this is the previous game: G0.p.2.1 = G0.p.2, whereas with \u03b3 = P + 1, this is the current game: G0.p.2.P+1 = G0.p.3. We will gradually replace the um,t values, at the 6-th hidden position, by 0 (when t 6= p): in this game, we deal with the case t = \u03b3, for the m-th ciphertext query. For this, we use the Adaptive Index-Ind property on (D\u2217,D)1,2,6,8,9, with:\nk\u2217\u03bb = (\u03c0\u03bb(t\u03bb,\u22121), a\u03bb, 0, 0, r\u03bb, 0, 0, 0)D\u2217 t\u03bb = p cm,t = (\u03c3m,t(1, t), \u03c9m, 0, 0, um,t, um,t, 0, 0)D t = \u03b3\nWe remind that um,p = 0 because r\u03bb 6= 0. If r\u03bb = 0, then we would have skipped directly to the hybrid p+ 1 game.\nWith all this sequence, we have Adv0.p.2 \u2212 Adv0.p.3 \u2264 2P \u00b7 (8\u00d7 AdvddhG2 (t) + 4\u00d7 Adv ddh G1 (t)).\nGame G0.p.4: In this final game for p, we can finally cancel out r\u03bb in each key with t\u03bb = p because it corresponds to a coordinate where all other values (in keys and ciphertexts) are 0. We consider a triple (a \u00b7 G2, b \u00b7 G2, c \u00b7 G2), where c = ab + \u03b1 mod q, with either \u03b1 = 0 or \u03b1 = r\u03bb. One defines the matrices\nD = ( 1 0 a 1 ) 1,6\nD\u2032 = ( 1 \u2212a 0 1 ) 1,6\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nNote that we can compute all the basis vectors excepted d6, but all the ciphertexts have a 0 components in 6-th position. So one can set all the values honestly in D and D\u2217, except for\nk\u03bb = (0, 0, a\u03bb, 0, 0, 0, 0, 0, 0)D + (b(p,\u22121), 0, 0, 0, c, 0, 0, 0)V = (0, 0, a\u03bb, 0, 0, 0, 0, 0, 0)D + (b(p,\u22121), 0, 0, 0, c\u2212 ab, 0, 0, 0)D = (b(1, p), a\u03bb, 0, 0, \u03b1, 0, 0, 0)D\nWhen \u03b1 = 0, this is exactly the current game, with \u03c0\u03bb = b, whereas \u03b1 = r\u03bb, this is the previous game. Then, Adv0.p.3 \u2212 Adv0.p.4 \u2264 2 \u00b7 AdvddhG2 (t).\nIn total, this sequence of games, for a given p, satisfies Then,\nAdvG0.p.4 \u2212 AdvG0.p.0 \u2264 4 \u00b7 AdvddhG2 (t) + 2P \u00b7 (8\u00d7 Adv ddh G2 (t) + 4\u00d7 Adv ddh G1 (t))\n\u2264 (24P + 4) \u00b7 Advsxdh(t)\nIn the last game, the adversary has zero advantage. Indeed, whether b = 0 or b = 1, the distributions of dk0 and dk1 are perfectly identical, with all-passive leaves.\n60\nE.4 Proof of Theorem 12 \u2013 dAtt-IND-Security\nProof. We start with the distinct variant, where all the invalid attributes in the challenge ciphertext do not correspond to any active leaf in the obtained keys. Our proof will proceed by games.\nGame G0: This is the real security game, where the simulator honestly emulates the challenger, with PK = {(b1,b3,b\u22171), (d1,d2,d3,d7,d\u22171,d\u22172,d\u22173)} and MK = {b\u22173,d\u22177}, from random dual orthogonal bases. The public parameters PK are provided to the adversary. Since d7 is public (empty SK), there is no need to provide access to an encryption oracle. OKeyGen(T\u0303`) (or ODelegate-queries): The adversary is allowed to issue KeyGen-queries on an\naccess-tree T\u0303` = (T`,L`,a,L`,p) (for the `-th query), for which the simulator chooses a random scalar a`,0\n$\u2190 Zq and a random a`,0-labeling (a`,\u03bb)\u03bb of the access-tree T`, and builds the key:\nk\u2217`,0 = (a`,0, 0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0, r`,\u03bb, 0, 0)D\u2217\nfor all the leaves \u03bb, where t`,\u03bb = A(\u03bb), \u03c0`,\u03bb $\u2190 Zq and r`,\u03bb $\u2190 Z\u2217q if \u03bb is an active leaf, or r`,\u03bb \u2190 0 otherwise. The decryption key is dk` = (k\u2217`,0, (k\u2217`,\u03bb)\u03bb); RoAVEncaps(\u0393v, \u0393i): The challenge ciphertext is built on a set of attributes \u0393v \u00b7\u222a \u0393i, with random scalars \u03c9, \u03be\n$\u2190 Zq to set K = g\u03bet . Then, the simulator generates the ciphertext C0 = (c0, (ct)t), for all the attributes t \u2208 \u0393v \u00b7\u222a \u0393i, with \u03c3t $\u2190 Zq, and where ut $\u2190 Z\u2217q if t \u2208 \u0393i, or ut = 0 if t \u2208 \u0393v:\nc0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(1, t), \u03c9, 0, 0, 0, ut, 0, 0)D\nOn the other hand, it computes C1 = (c0, (ct)t) for all t \u2208 \u0393v \u00b7\u222a \u0393i as:\nc0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(1, t), \u03c9, 0, 0, 0, 0, 0, 0)D\nAccording to the real or all-valid game (bit b $\u2190 {0, 1}), one outputs (K,Cb).\nFrom the adversary\u2019s guess b\u2032 for b, if for some T\u0303` = (T`,L`,a,L`,p), there is some active leaf \u03bb \u2208 L`,a such that t\u03bb = A(\u03bb) \u2208 \u0393i, then \u03b2 $\u2190 {0, 1}, otherwise \u03b2 = b\u2032. We denote Adv0 = Pr[\u03b2 = 1|b = 1]\u2212 Pr[\u03b2 = 1|b = 0]. We stress that in this distinct attribute-indistinguishability security game, the invalid attributes in the challenge ciphertext (t \u2208 \u0393i with possibly ut 6= 0) correspond to passive leaves only (\u03bb \u2208 L`,p with r`,\u03bb = 0, for all queries). But we do not exclude accepting access-trees.\nGame G1: The second and final game simply corresponds to the situation where ut = 0 in C0, clearly leading to Adv1 = 0. Using the indexing technique, we can show this game is indistinguishable the previous game. But we need to describe a sub-sequence of games (see Figure 17) for proving the gap from the above G0 to G1, with the sequence G0.p.\u2217, that will modify the p-th ciphertext in the challenge ciphertext, for p \u2208 {1, . . . , P + 1}, where G0 = G0.1.0, and G1 = G0.P+1.0. In these games, we describe how we generate the keys and the real encapsulation C0. C1 will be easily simulated in an honest way.\nGame G0.p.0: One thus chooses random scalars and defines the hybrid game for some p, where the first components of the ciphertext are all-valid, and the last ones are real:\nk\u2217`,0 = (a`,0, 0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0, r`,\u03bb, 0, 0)D\u2217\nc0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(1, t), \u03c9, 0, 0, 0, 0, 0, 0)D t < p c0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(1, t), \u03c9, 0, 0, 0, ut, 0, 0)D t \u2265 p\n62\nOf course, the values r`,\u03bb and ut are random in Z\u2217q or 0 according to L`,a/L`,p and \u0393i/\u0393v. In particular, if up = 0, we can directly go to G0.p.4, as there is no change from this game. The following sequence only makes sense when up 6= 0, but then necessarily r`,\u03bb = 0 for all the pairs (`, \u03bb) such that t`,\u03bb = p. We thus assume this restriction in this sequence: up 6= 0 and r`,\u03bb = 0 for all (`, \u03bb) such that t`,\u03bb = p.\nGame G0.p.1: One defines the matrices\nD = ( 1 1 0 1 ) 6,7\nD\u2032 = ( 1 0 \u22121 1 ) 6,7\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nwhich modifies the hidden and secret vectors d6 and d \u2217 7, and so are not in the view of the adversary:\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0, r`,\u03bb, 0, 0)V\u2217 = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, r`,\u03bb, r`,\u03bb, 0, 0)D\u2217\nct = (\u03c3t(1, t), \u03c9, 0, 0, 0, 0)V = (\u03c3t(1, t), \u03c9, 0, 0, 0, 0, 0, 0)D if t < p ct = (\u03c3t(1, t), \u03c9, 0, 0, 0, ut)V = (\u03c3t(1, t), \u03c9, 0, 0, 0, ut, 0, 0)D if t \u2265 p\nWe thus have Adv0.p.1 = Adv0.p.0.\nGame G0.p.2: We use the Swap-Ind-property on (D,D\u2217)1,6,7: Indeed, we can consider a triple (a \u00b7 G1, b \u00b7 G1, c \u00b7 G1), where c = ab + \u03b8 mod q with either \u03b8 = 0 or \u03b8 = up. We define the matrices\nD = 1 a \u2212a0 1 0 0 0 1  1,6,7\nD\u2032 =  1 0 0\u2212a 1 0 a 0 1  1,6,7\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nNote that we can compute all the basis vectors excepted d\u22176,d \u2217 7, but we define the keys on the original basis V\u2217:\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, r`,\u03bb, r`,\u03bb, 0, 0)V\u2217 = (\u03c0`,\u03bb \u00b7 t`,\u03bb + ar`,\u03bb \u2212 ar`,\u03bb,\u2212\u03c0`,\u03bb, a`,\u03bb, 0, 0, r`,\u03bb, r`,\u03bb, 0, 0)D\u2217 = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, r`,\u03bb, r`,\u03bb, 0, 0)D\u2217\nct = (\u03c3t(1, t), \u03c9, 0, 0, 0, 0, 0, 0)D if t < p cp = (\u03c3(1, p), \u03c9, 0, 0, 0, up, 0, 0)D + (b(1, p), 0, 0, 0, c,\u2212c, 0, 0)V = (\u03c3(1, p), \u03c9, 0, 0, 0, up, 0, 0)D + (b(1, p), 0, 0, 0, c\u2212 ab,\u2212c+ ab, 0, 0)D = ((\u03c3 + b)(1, p), \u03c9, 0, 0, \u03b8, up \u2212 \u03b8, 0, 0)D\nct = (\u03c3t(1, t), \u03c9, 0, 0, 0, ut, 0, 0)D if t > p\nWith \u03b8 = 0, this is as in the previous game, where \u03c3p = \u03c3 + b. When \u03b8 = up, this is the current game: Adv0.p.1 \u2212 Adv0.p.2 \u2264 2 \u00b7 AdvddhG1 (t).\nGame G0.p.3: We make all the r`,\u03bb values (at the 6-th hidden position) in the keys to be 0, excepted for t`,\u03bb = p. The case t`,\u03bb = p is already r`,\u03bb = 0, by assumption in this sequence, as up 6= 0. For that, we iteratively replace all the values by zero, using the Adaptive Index-Ind-property from theorem 3, in another level of sequence of hybrid games, for \u03b3 \u2208 {1, . . . , P}\\{p}. We will enumerate \u03b3 in their order of appearance in the security game (wether in key queries, or in ciphertexts), therefore we can treat an unbounded number of \u03b3.\n63\nGame G0.p.2.\u03b3: We consider\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0, 0, 0, 0)D\u2217 if t`,\u03bb = p k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0, r`,\u03bb, 0, 0)D\u2217 if p 6= t`,\u03bb < \u03b3 k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, r`,\u03bb, r`,\u03bb, 0, 0)D\u2217 if p 6= t`,\u03bb \u2265 \u03b3\nct = (\u03c3t(1, t), \u03c9, 0, 0, 0, 0, 0, 0)D if t < p\ncp = (\u03c3p(1, p), \u03c9, 0, 0, up, 0, 0, 0)D\nct = (\u03c3t(1, t), \u03c9, 0, 0, 0, ut, 0, 0)D if t > p\nWhen \u03b3 = 1, this is the previous game: G0.p.2.1 = G0.p.2, whereas with \u03b3 = P + 1, this is the current game: G0.p.2.P+1 = G0.p.3. For this, we use the Adaptive Index-Ind property on (D\u2217,D)1,2,6,8,9, with:\ncp = (\u03c3p(1, p), \u03c9, 0, 0, up, 0, 0, 0)D\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, r`,\u03bb, r`,\u03bb, 0, 0)D\u2217 t`,\u03bb = \u03b3\nAs a consequence, Adv0.p.2 \u2212 Adv0.p.3 \u2264 2P \u00b7 (8\u00d7 AdvddhG1 (t) + 4\u00d7 Adv ddh G2 (t)).\nGame G0.p.4: One can easily conclude by removing up in the ciphertext cp, as it corresponds to a coordinate where all the other values (in the keys and the ciphertext) are 0. To this aim, we can consider a triple (a \u00b7 G1, b \u00b7 G1, c \u00b7 G1), where c = ab + \u03b1 mod q with either \u03b1 = 0 or \u03b1 = up. One defines the matrices\nD = ( 1 a 0 1 ) 1,6\nD\u2032 = ( 1 0 \u2212a 1 ) 1,6\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nNote that we can compute all the basis vectors excepted d\u22176, which has only 0 components in the keys. So one can set all the values honestly in D and D\u2217, excepted\ncp = (b(1, p), \u03c9, 0, 0, c, 0, 0, 0)V = (b(1, p), \u03c9, 0, 0, c\u2212 ab, 0, 0, 0)D = (b(1, p), \u03c9, 0, 0, \u03b1, 0, 0, 0)D\nWhen \u03b1 = 0, this is exactly the current game, with \u03c3p = b, whereas for \u03b1 = up, this is the previous game. Then, Adv0.p.3 \u2212 Adv0.p.4 \u2264 2 \u00b7 AdvddhG1 (t).\nIn total, this sequence of games, for a given p, satisfies Then,\nAdvG0.p.4 \u2212 AdvG0.p.0 \u2264 4 \u00b7 AdvddhG1 (t) + 2P \u00b7 (8\u00d7 Adv ddh G1 (t) + 4\u00d7 Adv ddh G2 (t))\n\u2264 (4 + 24P ) \u00b7 Advsxdh(t)\nE.5 Proof of Theorem 13 \u2013 Att-IND-Security\nProof. We now prove the attribute-indistinguishability, where there are no restrictions between active leaves in the keys and invalid attributes in the challenge ciphertext, but just that the access-trees of the obtained keys reject the attribute-set of the challenge ciphertext, even in the all-valid case. Our proof will proceed by games. Not that we also assume active keys correspond to independent leaves with respect to the set of attributes \u0393 = \u0393v \u00b7\u222a\u0393i in the challenge ciphertext.\nGame G0: This is the real security game, where the simulator honestly emulates the challenger, with PK = {(b1,b3,b\u22171), (d1,d2,d3,d7,d\u22171,d\u22172,d\u22173)} and MK = {b\u22173,d\u22177}, from random dual orthogonal bases. The public parameters PK are provided to the adversary. Since d7 is public (empty SK), there is no need to provide access to an encryption oracle.\n64\nOKeyGen(T\u0303`) (or ODelegate-queries): The adversary is allowed to issue KeyGen-queries on an access-tree T\u0303` = (T`,L`,a,L`,p) (for the `-th query), for which the simulator chooses a random scalar a`,0\n$\u2190 Zq and a random a`,0-labeling (a`,\u03bb)\u03bb of the access-tree T`, and builds the key:\nk\u2217`,0 = (a`,0, 0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, 0, r`,\u03bb, 0, 0)D\u2217\nfor all the leaves \u03bb, where t`,\u03bb = A(\u03bb), \u03c0`,\u03bb $\u2190 Zq and r`,\u03bb $\u2190 Z\u2217q if \u03bb is an active leaf, or r`,\u03bb \u2190 0 otherwise. The decryption key is dk` = (k\u2217`,0, (k\u2217`,\u03bb)\u03bb); RoAVEncaps(\u0393v, \u0393i): The challenge ciphertext is built on a set of attributes \u0393v \u00b7\u222a \u0393i, with random scalars \u03c9, \u03be\n$\u2190 Zq to set K = g\u03bet . Then, the simulator generates the ciphertext C1 = (c0, (ct)t), for all the attributes t \u2208 \u0393v \u00b7\u222a \u0393i, with \u03c3t $\u2190 Zq:\nc0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(1, t), \u03c9, 0, 0, 0, 0, 0, 0)D\nOn the other hand, it computes C0 = (c0, (ct + (0, 0, 0, 0, 0, 0, ut, 0, 0)D)t), where ut $\u2190 Z\u2217q if t \u2208 \u0393i, or ut = 0 if t \u2208 \u0393v. According to the real or all-valid game (bit b $\u2190 {0, 1}), one outputs (K,Cb). From the adversary\u2019s guess b\u2032 for b, if for some T\u0303` = (T`,L`,a,L`,p), for which tree a key has been obtained, T\u0303`(\u0393v \u00b7\u222a\u0393i, \u2205) = 1 then \u03b2 $\u2190 {0, 1}, otherwise \u03b2 = b\u2032. We denote Adv0 = Pr[\u03b2 = 1|b = 1]\u2212 Pr[\u03b2 = 1|b = 0]. We now proceed with exactly the same sequence as in the IND-security proof of the KP-ABE in the appendix D.3, except the RoREncaps-challenge is instead a RoAVEncaps-challenge, where we require T\u0303`(\u0393v \u00b7\u222a \u0393i, 0) = 0 for all the obtained keys. For the same reason, the OEncaps-queries on pairs (\u0393m,v, \u0393m,i), with \u0393m,i 6= \u2205 can be simulated. Indeed, as above, everything on the 7-th component can be done independently, knowing both d7 and d \u2217 7, as these vectors will be known to the simulator, almost all the time, excepted in some specific gaps. In theses cases, we will have to make sure how to simulate the OEncaps ciphertexts. As in that proof, the idea of the sequence is to introduce an additional labeling (s`,0, (s`,\u03bb)\u03bb) in the hidden components of each key, with a random s`,0, as the trees are rejecting. We are thus able to go as in G3, from Figure 9, where each label is masked by a random zt for each attribute t. The following sequence is described on Figure 18.\nGame G1: This is as G1, with a random \u03c4 in the challenge ciphertext.\nGame G2: This is as G2, with random zt in the challenge ciphertext.\nGame G3: This is as G3, with an additional independent s`,0-labeling (s`,\u03bb) for each accesstree T` and a random r`,0 to define\nk\u2217`,0 = (a`,0, r`,0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, s`,\u03bb/ztk,\u03bb , r`,\u03bb, 0, 0)D\u2217\nWe stress that all these steps are not impacted by the values ut in the 7-th component of the challenge ciphertext:\nc0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, (1\u2212 b) \u00b7 ut, 0, 0)D\nwhere b is the random bit of the challenger: when b = 0, the ciphertext is in the real case, whereas for b = 1, one gets an all-valid ciphertext.\nGame G4: We remove all ut from the RoAVEncaps challenge query, in the case b = 1:\nc0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, 0, 0, 0)D\nk\u2217`,0 = (a`,0, r`,0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, s\u2032`,\u03bb/ztk,\u03bb , r`,\u03bb, 0, 0)D\u2217\nwhere s\u2032`,\u03bb is either the label s`,\u03bb or an independent random value when utk,\u03bb \u00b7 rk,\u03bb 6= 0, in the case b = 0. And nothing is changed when b = 1. To this aim, we use a different sequence G3.p.\u2217 presented in the Figure 19, when b = 1 only, for p \u2208 {1, . . . , P}, that will modify the p-th ciphertext in the challenge ciphertext, where G3 = G3.1.0, and G4 = G3.P+1.0. Game G3.p.0: One thus chooses random scalars and defines the hybrid game for some p, where the first components of the ciphertext are all-valid, and the last ones are real:\nk\u2217`,0 = (a`,0, r`,0, 1)B\u2217 k \u2217 `,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217\nc0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, 0, 0, 0)D if t < p c0 = (\u03c9, 0, \u03be)B ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, ut, 0, 0)D if t \u2265 p\nOf course, the values r`,\u03bb and ut are random in Z\u2217q or 0 according to L`,a/L`,p and \u0393i/\u0393v. In particular, if up = 0, we can directly go to G3.p.5, as there is no change from this game. But there is no need to know it in advance, and so we can follow this sequence in any case and set up in the ciphertext at the challenge-time.\nGame G3.p.1: One defines the matrices\nD = ( 1 1 0 1 ) 5,7\nD\u2032 = ( 1 0 \u22121 1 ) 5,7\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nwhich modifies the hidden and secret vectors d6 and d \u2217 7, and so are not in the view of the adversary:\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)V\u2217 = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, r`,\u03bb, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217\nct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, 0, 0, 0)V = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, 0, 0, 0)D if t < p ct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, ut, 0, 0)V = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, ut, 0, 0)D if t \u2265 p\n67\nWe thus have Adv3.p.1 = Adv3.p.0.\nGame G3.p.2: We use the Swap-Ind-property on (D,D\u2217)1,5,7: Indeed, we can consider a triple (a \u00b7 G1, b \u00b7 G1, c \u00b7 G1), where c = ab + \u03b8 mod q with either \u03b8 = 0 or \u03b8 = up. We define the matrices\nD = 1 a \u2212a0 1 0 0 0 1  1,5,7\nD\u2032 =  1 0 0\u2212a 1 0 a 0 1  1,5,7\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nNote that we can compute all the basis vectors excepted d\u22175,d \u2217 7, but we define the keys on the original basis V\u2217:\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, r`,\u03bb, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)V\u2217 = (\u03c0`,\u03bb \u00b7 t`,\u03bb + ar`,\u03bb \u2212 ar`,\u03bb,\u2212\u03c0`,\u03bb, a`,\u03bb, 0, r`,\u03bb, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, r`,\u03bb, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217\nct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, 0, 0, 0)D if t < p cp = (\u03c3(1, p), \u03c9, \u03c4, 0, \u03c4zp, up)D + (b(1, p), 0, 0, c, 0,\u2212c, 0, 0)V = (\u03c3(1, p), \u03c9, \u03c4, 0, \u03c4zp, up)D + (b(1, p), 0, 0, c\u2212 ab, 0,\u2212c+ ab, 0, 0)D = ((\u03c3 + b)(1, p), \u03c9, \u03c4, \u03b8, \u03c4zp, up \u2212 \u03b8, 0, 0)D\nct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, ut, 0, 0)D if t > p\nWith \u03b8 = 0, this is as in the previous game, where \u03c3p = \u03c3 + b. When \u03b8 = up, this is the current game: Adv3.p.1 \u2212 Adv3.p.2 \u2264 2 \u00b7 AdvddhG1 (t).\nGame G3.p.3: We make all the r`,\u03bb values (at the 5-th hidden position) in the keys to be 0, excepted when t`,\u03bb = p. For that, we iteratively replace all the values by zero, using Adaptive Index-Ind-property from theorem 3, in another level of sequence of hybrid games, for \u03b3 \u2208 {1, . . . , P}\\{p}. We will enumerate \u03b3 in their order of appearance in the security game (wether in key queries, or in ciphertexts), therefore we can treat an unbounded number of \u03b3. Game G3.p.2.\u03b3: We consider\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, r`,\u03bb, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 if t`,\u03bb = p k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, 0, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 if p 6= t`,\u03bb < \u03b3 k\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, r`,\u03bb, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 if p 6= t`,\u03bb \u2265 \u03b3\nct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, 0, 0, 0)D if t < p\ncp = (\u03c3p(1, p), \u03c9, \u03c4, up, \u03c4zp, 0, 0, 0)D\nct = (\u03c3t(1, t), \u03c9, \u03c4, 0, \u03c4zt, ut, 0, 0)D if t > p\nWhen \u03b3 = 1, this is the previous game: G3.p.2.1 = G3.p.2, whereas with \u03b3 = P + 1, this is the current game: G3.p.2.P+1 = G3.p.3. For this, we use the Adaptive Index-Ind property on (D\u2217,D)1,2,5,8,9, with:\ncp = (\u03c3p(1, p), \u03c9, \u03c4, up, \u03c4zp, 0, 0, 0)D\nk\u2217`,\u03bb = (\u03c0`,\u03bb(t`,\u03bb,\u22121), a`,\u03bb, 0, r`,\u03bb, s`,\u03bb/zt`,\u03bb , r`,\u03bb, 0, 0)D\u2217 t`,\u03bb = \u03b3\nGame G3.p.4: We use the SubSpace-Ind-property on (D,D\u2217)6,5: Indeed, we can consider a triple (a \u00b7G1, b \u00b7G1, c \u00b7G1), where c = ab+ \u03b8 mod q with either \u03b8 = 0 or \u03b8 = up. We define the matrices\nD = ( 1 0 a 1 ) 5,6\nD\u2032 = ( 1 \u2212a 0 1 ) 5,6\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\n68\nNote that we can compute all the basis vectors excepted d\u22175 that is not public, and not used excepted for the keys with t`,\u03bb = p, which will be defined in the original basis V\u2217:\nk\u2217`,\u03bb = (\u03c0`,\u03bb(p,\u22121), a`,\u03bb, 0, r`,\u03bb, s`,\u03bb/zp, r`,\u03bb, 0, 0)V\u2217 = (\u03c0`,\u03bb(p,\u22121), a`,\u03bb, 0, r`,\u03bb, s`,\u03bb/zp + ar`,\u03bb, r`,\u03bb, 0, 0)D\u2217 = (\u03c0`,\u03bb(p,\u22121), a`,\u03bb, 0, r`,\u03bb, s\u2032`,\u03bb/zp, r`,\u03bb, 0, 0)D\u2217\nct = (\u03c3t(1, t), \u03c9, b, 0, bzt, 0, 0, 0)D if t < p cp = (\u03c3p(1, p), \u03c9, b, c, bzp, 0, 0, 0)V = (\u03c3p(1, p), \u03c9, b, c\u2212 ab, bzp, 0, 0, 0)D = (\u03c3p(1, p), \u03c9, b, \u03b8, bzp, 0, 0, 0)D\nct = (\u03c3t(1, t), \u03c9, b, 0, bzt, ut, 0, 0)D if t > p\nWhen \u03b8 = 0, this is this game, whereas when \u03b8 = up, this is the previous game, with \u03c4 = b and s\u2032`,\u03bb = s`,\u03bb+azpr`,\u03bb a new random and independent value for each active leaf associated to the attribute p.\nGame G3.p.5: We use the SubSpace-Ind-property on (D\u2217,D)6,5: Indeed, we can consider a triple (a \u00b7G2, b \u00b7G2, c \u00b7G2), where c = ab+ \u03b6 mod q with either \u03b6 = 0 or \u03b6 = 1. We define the matrices\nD\u2032 = ( 1 0 a 1 ) 5,6\nD = ( 1 \u2212a 0 1 ) 5,6\nD = D \u00b7 V D\u2217 = D\u2032 \u00b7 V\u2217\nNote that we can compute all the basis vectors excepted d5 that is not public, and not used in the ciphertext. All the vectors can be computed in the new bases, excepted the keys for t`,\u03bb = p, for which one chooses additional random scalars \u03b2`,\u03bb\n$\u2190 Zq, to virtually set b`,\u03bb = r`,\u03bb \u00b7 b+ \u03b2`,\u03bb and c`,\u03bb = r`,\u03bb \u00b7 c+ \u03b2`,\u03bb \u00b7 a, c`,\u03bb \u2212 ab`,\u03bb = r`,\u03bb \u00b7 \u03b6.\nk\u2217`,\u03bb = (\u03c0`,\u03bb(p,\u22121), a`,\u03bb, 0, c`,\u03bb, b`,\u03bb, r`,\u03bb, 0, 0)V\u2217 = (\u03c0`,\u03bb(p,\u22121), a`,\u03bb, 0, c`,\u03bb \u2212 ab`,\u03bb, b`,\u03bb, r`,\u03bb, 0, 0)D\u2217 = (\u03c0`,\u03bb(p,\u22121), a`,\u03bb, 0, \u03b6 \u00b7 r`,\u03bb, b`,\u03bb, r`,\u03bb, 0, 0)D\u2217\nWhen \u03b6 = 0, this is this game, whereas when \u03b6 = 1, this is the previous game, with s\u2032`,\u03bb = zp \u00b7 b`,\u03bb, a truly random and independent value for each active leaf associated to the attribute p.\nGame G5: Under the assumption of independent active leaves with respect to the set of attributes \u0393 = \u0393v \u00b7\u222a\u0393i in the challenge ciphertext, the random values s\u2032`,\u03bb are indistinguishable from real labels s\u2032`,\u03bb. Indeed, labels that correspond to leaves that are associated to attributes not in \u0393 are unknown, as the masks zt are not revealed. This shows that the advantage of the adversary in this last game is 0."
        }
    ],
    "title": "Key-Policy ABE With Switchable Attributes",
    "year": 2024
}