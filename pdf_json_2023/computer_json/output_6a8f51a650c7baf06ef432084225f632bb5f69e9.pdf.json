{
    "abstractText": "Non-deterministic Finite Automata (NFA) represent regular languages concisely, increasing their appeal for applications such as word recognition. This paper proposes a new approach to generate NFA from an interaction language such as UML Sequence Diagrams or Message Sequence Charts. Via an operational semantics, we generate a NFA from a set of interactions reachable using the associated execution relation. In addition, by applying simplifications on reachable interactions to merge them, it is possible to obtain reduced NFA without relying on costly NFA reduction techniques. Experimental results regarding NFA generation and their application in trace analysis are also presented. 2012 ACM Subject Classification Replace ccsdesc macro with valid one",
    "authors": [
        {
            "affiliations": [],
            "name": "Erwan Mahe"
        },
        {
            "affiliations": [],
            "name": "Boutheina Bannour"
        },
        {
            "affiliations": [],
            "name": "Christophe Gaston"
        },
        {
            "affiliations": [],
            "name": "Arnault Lapitre"
        },
        {
            "affiliations": [],
            "name": "Pascale Le Gall"
        }
    ],
    "id": "SP:31860bf6bb57cbde05daebd767be3fc9186aea28",
    "references": [
        {
            "authors": [
                "Rajeev Alur",
                "Mihalis Yannakakis"
            ],
            "title": "Model checking of message sequence charts",
            "venue": "CONCUR \u201999: Concurrency Theory, 10th International Conference,",
            "year": 1999
        },
        {
            "authors": [
                "Jerome Amilhastre",
                "Philippe Janssen",
                "Marie-Catherine Vilarem"
            ],
            "title": "Fa minimisation heuristics for a class of finite languages",
            "venue": "In Oliver Boldt and Helmut Jurgensen, editors, Automata Implementation,",
            "year": 2001
        },
        {
            "authors": [
                "Valentin Antimirov"
            ],
            "title": "Partial derivatives of regular expressions and finite automata constructions",
            "venue": "editors, STACS",
            "year": 1995
        },
        {
            "authors": [
                "Han\u00eane Ben-Abdallah",
                "Stefan Leue"
            ],
            "title": "Syntactic detection of process divergence and non-local choice in message sequence charts",
            "venue": "Tools and Algorithms for the Construction and Analysis of Systems,",
            "year": 1997
        },
        {
            "authors": [
                "Jean-Marc Champarnaud",
                "Fabien Coulon"
            ],
            "title": "Nfa reduction algorithms by means of regular inequalities",
            "venue": "In Zoltan Esik and Zoltan Fulop, editors, Developments in Language Theory,",
            "year": 2003
        },
        {
            "authors": [
                "Jan Daciuk",
                "Bruce W. Watson",
                "Stoyan Mihov",
                "Richard E. Watson"
            ],
            "title": "Incremental construction of minimal acyclic finite-state automata. Comput. Linguist",
            "year": 2000
        },
        {
            "authors": [
                "Marcelo d\u2019Amorim",
                "Grigore Rosu"
            ],
            "title": "Efficient monitoring of omega-languages",
            "venue": "Computer Aided Verification, 17th International Conference,",
            "year": 2005
        },
        {
            "authors": [
                "Nachum Dershowitz",
                "Jean-Pierre Jouannaud"
            ],
            "title": "Rewrite Systems, page 243\u2013320",
            "year": 1991
        },
        {
            "authors": [
                "Wouter Gelade"
            ],
            "title": "Succinctness of regular expressions with interleaving, intersection and counting",
            "venue": "Theor. Comput. Sci.,",
            "year": 2010
        },
        {
            "authors": [
                "Jaco Geldenhuys",
                "Brink van der Merwe",
                "Lynette van Zijl"
            ],
            "title": "Reducing nondeterministic finite automata with sat solvers",
            "venue": "Finite-State Methods and Natural Language Processing,",
            "year": 2010
        },
        {
            "authors": [
                "Jesper G. Henriksen",
                "Madhavan Mukund",
                "K. Narayan Kumar",
                "Milind A. Sohoni",
                "P.S. Thiagarajan"
            ],
            "title": "A theory of regular MSC languages",
            "venue": "Inf. Comput.,",
            "year": 2005
        },
        {
            "authors": [
                "John E. Hopcroft"
            ],
            "title": "An n log n algorithm for minimizing states in a finite automaton",
            "venue": "Technical report,",
            "year": 1971
        },
        {
            "authors": [
                "Lucian Ilie",
                "Gonzalo Navarro",
                "Sheng Yu"
            ],
            "title": "On NFA Reductions, pages 112\u2013124",
            "year": 2004
        },
        {
            "authors": [
                "Lucian Iliea",
                "Sheng Yu"
            ],
            "title": "Algorithms for computing small nfas",
            "venue": "Mathematical Foundations of Computer Science",
            "year": 2002
        },
        {
            "authors": [
                "Tao Jiang",
                "B. Ravikumar"
            ],
            "title": "Minimal nfa problems are hard",
            "venue": "Automata, Languages and Programming,",
            "year": 1991
        },
        {
            "authors": [
                "T. Kameda",
                "P. Weiner"
            ],
            "title": "On the state minimization of nondeterministic finite automata",
            "venue": "IEEE Transactions on Computers,",
            "year": 1970
        },
        {
            "authors": [
                "Sean Kauffman",
                "Klaus Havelund",
                "Sebastian Fischmeister"
            ],
            "title": "Monitorability over unreliable channels",
            "venue": "Runtime Verification - 19th International Conference,",
            "year": 2019
        },
        {
            "authors": [
                "Martin Korp",
                "Christian Sternagel",
                "Harald Zankl",
                "Aart Middeldorp"
            ],
            "title": "Tyrolean termination tool",
            "venue": "Ralf Treinen, editor, Rewriting Techniques and Applications,",
            "year": 2009
        },
        {
            "authors": [
                "Giorgia Lallai",
                "Andrea Pinna",
                "Michele Marchesi",
                "Roberto Tonelli"
            ],
            "title": "Software engineering for dapp smart contracts managing workers contracts",
            "year": 2020
        },
        {
            "authors": [
                "Ernst Leiss"
            ],
            "title": "Succinct representation of regular languages by boolean automata",
            "venue": "Theoretical Computer Science,",
            "year": 1981
        },
        {
            "authors": [
                "P. Madhusudan",
                "B. Meenakshi"
            ],
            "title": "Beyond message sequence graphs",
            "venue": "FST TCS 2001: Foundations of Software Technology and Theoretical Computer Science,",
            "year": 2001
        },
        {
            "authors": [
                "Erwan Mahe"
            ],
            "title": "An operational semantics of interactions for verifying partially observed executions of distributed systems. Theses, Universit\u00e9 Paris-Saclay",
            "year": 2021
        },
        {
            "authors": [
                "Erwan Mahe",
                "Boutheina Bannour",
                "Christophe Gaston",
                "Arnault Lapitre",
                "Pascale Le Gall"
            ],
            "title": "A small-step approach to multi-trace checking against interactions",
            "venue": "In Proceedings of the 36th Annual ACM Symposium on Applied Computing,",
            "year": 2021
        },
        {
            "authors": [
                "Erwan Mahe",
                "Christophe Gaston",
                "Pascale Le Gall"
            ],
            "title": "Revisiting semantics of interactions for trace validity analysis",
            "venue": "Fundamental Approaches to Software Engineering,",
            "year": 2020
        },
        {
            "authors": [
                "Erwan Mahe",
                "Christophe Gaston",
                "Pascale Le Gall"
            ],
            "title": "Equivalence of denotational and operational semantics for interaction languages",
            "venue": "Theoretical Aspects of Software Engineering - 16th International Symposium, TASE 2022,",
            "year": 2022
        },
        {
            "authors": [
                "Sjouke Mauw",
                "Michel Adriaan Reniers"
            ],
            "title": "High-level message sequence charts. In SDL \u201997 Time for Testing, SDL",
            "venue": "MSC and Trends - 8th International SDL Forum,",
            "year": 1997
        },
        {
            "authors": [
                "Sjouke Mauw",
                "Michel Adriaan Reniers"
            ],
            "title": "Operational semantics for msc\u201996",
            "venue": "Computer Networks,",
            "year": 1999
        },
        {
            "authors": [
                "A.J. Mayer",
                "L.J. Stockmeyer"
            ],
            "title": "The complexity of word problems - this time with interleaving",
            "venue": "Information and Computation,",
            "year": 1994
        },
        {
            "authors": [
                "B.F. Melnikov"
            ],
            "title": "A new algorithm of the state-minimization for the nondeterministic finite automata",
            "venue": "Korean Journal of Computational and Applied Mathematics,",
            "year": 1999
        },
        {
            "authors": [
                "Zolt\u00e1n Micskei",
                "H\u00e9l\u00e8ne Waeselynck"
            ],
            "title": "The many meanings of uml 2 sequence diagrams: a survey",
            "venue": "Software & Systems Modeling,",
            "year": 2011
        },
        {
            "authors": [
                "Anca Muscholl",
                "Doron A. Peled",
                "Zhendong Su"
            ],
            "title": "Deciding properties for message sequence charts",
            "venue": "Held as Part of the European Joint Conferences on the Theory and Practice of Software,",
            "year": 1998
        },
        {
            "authors": [
                "Gordon Plotkin"
            ],
            "title": "A structural approach to operational semantics",
            "venue": "The Journal of Logic and Algebraic Programming,",
            "year": 2004
        },
        {
            "authors": [
                "Libor Polak"
            ],
            "title": "Minimalizations of nfa using the universal automaton",
            "venue": "In Proceedings of the 9th International Conference on Implementation and Application of Automata,",
            "year": 2004
        },
        {
            "authors": [
                "Grigore Ro\u015fu",
                "Mahesh Viswanathan"
            ],
            "title": "Testing extended regular language membership incrementally by rewriting",
            "venue": "Rewriting Techniques and Applications,",
            "year": 2003
        },
        {
            "authors": [
                "Koushik Sen",
                "Grigore Ro\u015fu"
            ],
            "title": "Generating optimal monitors for extended regular expressions",
            "venue": "Electronic Notes in Theoretical Computer Science,",
            "year": 2003
        },
        {
            "authors": [
                "Jocelyn Simmonds",
                "Yuan Gan",
                "Marsha Chechik",
                "Shiva Nejati",
                "Bill O\u2019Farrell",
                "Elena Litani",
                "Julie Waterhouse"
            ],
            "title": "Runtime monitoring of web service conversations",
            "venue": "IEEE Trans. Serv. Comput.,",
            "year": 2009
        },
        {
            "authors": [
                "Harald Zankl",
                "Bertram Felgenhauer",
                "Aart Middeldorp"
            ],
            "title": "Csi \u2013 a confluence tool",
            "venue": "Automated Deduction \u2013",
            "year": 2011
        }
    ],
    "sections": [
        {
            "text": "2012 ACM Subject Classification Replace ccsdesc macro with valid one\nKeywords and phrases Interaction language, Sequence Diagram, Message Sequence Chart, Nondeterministic Finite Automaton\nDigital Object Identifier 10.4230/LIPIcs...\n1 Introduction\nInteractions are behavioral models describing communication flows between actors. Interaction languages include, among others, Message Sequence Charts (MSC) [12, 34], or UML Sequence Diagrams (UML-SD) [37]. Their main advantage is their easy-to-read graphical representation. Let us describe their main elements using the sequence diagram drawn in the top left rectangle of Fig.1. Each actor (here l1, l2 and l3) is associated to a vertical line, called a lifeline. Behaviors are described as traces i.e. successions of atomic communication actions (abbrv. actions) which are either the emission of a message m from a lifeline l or the reception of m by l. In the diagrammatic representation, the emission (resp. reception) of a message is represented by an arrow exiting (resp. entering) a lifeline. By extension, message exchanges (i.e. an emission and a corresponding reception) are represented by contiguous horizontal arrows connecting two lifelines. The name of the exchanged message is represented above the corresponding arrow (e.g. m1, m2 and m3 in our example).\nUsing an asynchronous interpretation of exchanges, these arrows impose a causal order which is that the emission must occur before the corresponding reception (on our example, l1 must emit m1 before l2 can receive it). High-level operators such as various kinds of sequencing, parallel composition, choice and repetition can be used to schedule these atomic exchanges into more complex structured scenarios. A particularity of interactions is the\n\u00a9 E. Mahe et al.; licensed under Creative Commons License CC-BY 4.0\nLeibniz International Proceedings in Informatics Schloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\nar X\niv :2\n30 6.\n02 98\n3v 2\n[ cs\n.F L\n] 3\nA ug\n2 02\ndistinction between strict and weak sequencing. While the former always enforces an order between actions, the latter only does so between actions occurring on the same lifeline. Concurrent-regions (abbrv. co-regions) further improve expressiveness with the ability to detail which lifelines allow interleavings and which ones do not. In practice co-regions behave like parallel composition on certain lifelines and like weak sequencing on the others.\nMost operators are drawn as annotated boxes (for instance, loopS denotes a strictly sequential loop in our example). This is not the case for the weak sequencing operator, which corresponds to the top-to-bottom direction of the diagram and for concurrent regions (co-regions) which are represented using brackets on specific lifelines (e.g. on l2 in our example). Our example illustrates weak sequencing in two manners. If one considers the order of the emission of m2 w.r.t. that of m3, because they both occur on l3, weak sequencing forces l3 to emit m2 before it can emit any instance of m3. By contrast, if one considers the emission of m1 and that of m2, because they resp. occur on l1 and l3, weak sequencing allows them to occur in any order. In our example, the loop allows arbitrarily many instances of the reception of m3 to occur sequentially. The co-region on l2 then allows the reception of m1 to occur before, in-between or after any of these instances of the reception of m3.\nl3!m2\nl1!m1 l2?m1\nl1!m1 l2?m1\nl3!m2\nl3!m3 l2?m3 l3!m3 l2?m3 l3!m3 l2?m3\nl3!m2\nl1!m1 l2?m1\nFigure 1 NFA obtained from i0 drawn in the top left state\nInterestingly, for a subset of interactions, associated trace languages are regular. Therefore, associating them with Finite Automata (FA) is possible. In the literature, translations from interaction to FA generally rely on linearization of partial orders [1] and composition, matching interaction operators to FA ones [43]. In this paper, we explore an alternative approach, taking advantage of a representation of interactions as terms [32] in a process algebraic style. Using this representation we can build in the manner of [4, 42] a NFA in which each state corresponds to\nan equivalence class of such terms. Fig.1 illustrates the approach by representing a NFA obtained in this manner. Each of the 9 states is associated with a distinct interaction and is represented by a rectangle containing the diagrammatic representation of that interaction. The initial state is the target of the transition exiting \u2022, and rectangles with a doubled border correspond to accepting states. Transitions are labelled by actions denoted as either l!m or l?m for resp. the emission or the reception of message m occurring on lifeline l. These actions are immediately executable from the interaction in the source state while the one in the target state specifies continuations of traces specified by the former.\nThis approach is novel and has three advantages over the literature: (1) the translation of a more expressive interaction language, (2) the ability to directly generate NFA with\nfew states without relying on state reduction algorithms and (3) traceability in monitoring because a deviation from the NFA can be uniquely traced-back to an instant in the unfolding of a global scenario represented by an interaction.\nThe paper is organized as follows. After some preliminaries in Sec.2, we introduce our interaction language and its semantics in Sec.3. Sec.4 covers our approach for NFA generation and Sec.5 presents experimental results. Finally, after some remarks and related works in Sec.6, we conclude in Sec.7.\n2 Preliminaries\nFor a set A, P(A) and A\u2217 resp. denote the sets of all subsets of A and of all finite sequences over A. \".\" denotes the concatenation operation and \u03b5 the empty sequence. For w \u2208 A\u2217 and for a \u2208 A, we resp. denote by |w| and |w|a the length of w and the number of occurrences of a in w. A word u is said to be a prefix of w if there exists a word v such that w = u.v.\nGiven two sets X and Y , X \u00d7 Y denotes their Cartesian product and Y X denotes the set of all functions \u03d5 : X \u2192 Y of domain X and codomain Y .\nNon-deterministic Finite Automata (NFA). Def.1 recalls the definition of NFA. A transition (q, x, q\u2032), with q and q\u2032 states in Q and x \u2208 A is denoted as q x\u21dd q\u2032 and is said to be labelled by x. A path from q to q\u2032 is a finite sequence of k > 0 consecutive transitions qi xi+1 \u21dd qi+1 with i \u2208 [0, k \u2212 1] s.t. q0 = q and qk = q\u2032. If we denote by w the word obtained from concatenating their labels i.e. w = x1. \u00b7 \u00b7 \u00b7 .xk, we may then write q w \u21dd q\u2032. By extension, we have q \u03b5\u21dd q for any q \u2208 Q. The language recognized by a NFA A = (A, Q, q0, F,\u21dd) is then the set of words L(A) = {w \u2208 A\u2217 | \u2203 qf \u2208 F s.t. q0 w \u21dd qf }.\n\u25b6 Definition 1. A NFA is a tuple (A, Q, q0, F,\u21dd) s.t. A is a finite alphabet, Q is a finite set of states, q0 \u2208 Q is an initial state, F \u2286 Q is a set of accepting states and \u21dd\u2286 Q \u00d7 A \u00d7 Q is a finite set of transitions.\nTerm rewriting. A set of operation symbols F is a structured set F = \u22c3\nj\u22650 Fj s.t. for any integer j \u2265 0, the set Fj is that of symbols of arity j. Symbols of arity 0 are constants. For any set of variables X , we denote by TF (X ) the set of terms over X defined as the smallest set s.t. (1) F0 \u222a X \u2282 TF (X ) and (2) for any symbol f \u2208 Fj of arity j > 0 and for any terms t1, \u00b7 \u00b7 \u00b7 , tj from TF (X ), f(t1, \u00b7 \u00b7 \u00b7 , tj) \u2208 TF (X ). TF = TF (\u2205) denotes the set of ground terms. A function \u03d5 \u2208 T XF is extended as a substitution \u03d5 \u2208 T TF (X ) F s.t. \u2200 t \u2208 F0, \u03d5(t) = t and for all term the form f(t1, \u00b7 \u00b7 \u00b7 , tj) with f \u2208 Fj , \u03d5(f(t1, \u00b7 \u00b7 \u00b7 , tj)) = f(\u03d5(t1), \u00b7 \u00b7 \u00b7 , \u03d5(tn)). For any t \u2208 TF , we denote by pos(t) \u2208 P(N\u2217) its set of positions [9] which is s.t. \u2200 t \u2208 F\nof the form f(t1, \u00b7 \u00b7 \u00b7 , tj) with f \u2208 Fj we have pos(f(t1, \u00b7 \u00b7 \u00b7 , tj)) = {\u03b5} \u222a \u22c3\nk\u2208[1,j]{k.p | p \u2208 pos(tk)}. For any terms t and s and any position p \u2208 pos(t), t|p denotes the sub-term of t at position p while t[s]p denotes the term obtained by substituting t|p with s in t.\nA rewrite rule x\u21dd y is a syntactic entity which relates two terms x and y from TF (X ). A set of rewrite rules R characterizes a Term Rewrite System (TRS) (see Def.2) \u2192R which relates ground terms. These terms are s.t. we can obtain the right-hand-side by applying a rewrite rule modulo a substitution at a specific position in the left-hand-side i.e. we have t \u2192R t[\u03d5(y)]p with x \u21dd y in R and t|p = \u03d5(x). For instance the integer expression simplification 3 + (5 + 0) \u2192R 3 + 5 can be obtained using R = {x + 0\u21dd x} on X = {x} by applying \u21dd with \u03d5(x) = 5 at position 2 within 3 + (5 + 0).\n\u25b6 Definition 2. A set R of rewrite rules over TF (X ) defines a TRS as a relation: \u2192R= { (t, t\u2032) \u2208 TF \u00d7 TF \u2223\u2223\u2223\u2223\u2223 \u2203 p \u2208 pos(t), \u2203 (x, y) \u2208 R, \u2203 \u03d5 \u2208 T TF (X )Ft|p = \u03d5(x) and t\u2032 = t[\u03d5(y)]p }\nGiven a TRS \u2192R, a term t \u2208 TF is irreducible iff there are no t\u2032 \u0338= t s.t. t \u2192R t\u2032. We denote by \u2192\u2217R the reflexive and transitive closure of \u2192R. A TRS is convergent iff all consecutive applications of \u2192R from a term t necessarily converge to the same irreducible term, i.e. iff \u2203! t\u2032 \u2208 TF s.t. t \u2192\u2217R t\u2032 and t\u2032 is irreducible. For a convergent TRS \u2192R, given a term t, the notation t \u2192!R t\u2032 signifies that t\u2032 is the unique irreducible term s.t. t \u2192\u2217R t\u2032.\n3 Interactions and their execution\n3.1 Syntax and principle of the semantics\nThe basic notion to describe communications within a concurrent system is that of atomic communication actions that can be observed at the interfaces of its sub-systems. Those actions correspond to either the emission or the reception of a message. We use a finite set L of lifelines to describe\ncommunication interfaces on which those actions occur (typically one lifeline l for each sub-system). A finite set M of messages abstracts away all messages that can be transmitted. The set of actions is then denoted by A = {l\u2206m | l \u2208 L, \u2206 \u2208 {!, ?}, m \u2208 M}. Notations ! and ? resp. denote emissions and receptions. For any a \u2208 A of the form l\u2206m with \u2206 \u2208 {!, ?}, \u03b8(a) refers to the lifeline l on which it occurs. Sequences of actions called traces characterize executions of systems. We denote the set of all traces by T = A\u2217.\nAs done in [32], we encode interactions as ground terms TF of a language with constants F0 being either atomic communication actions (elements a \u2208 A) or the empty interaction (denoted as \u2205) which expresses the empty behavior \u03b5. Symbols of arities 1 and 2 are then used to encode high level operators. Def.3 formalizes our encoding in the fashion of [32]. The language includes strict sequencing strict, non-deterministic choice alt, strictly sequential repetition loopS and a set of concurrent-region operators cr\u2113 one per subset \u2113 \u2286 L of lifelines. So as to relate to the more familiar weak sequencing seq and interleaving par operators (see [32]) which are particular cases of co-regions, we denote in the following cr\u2205 by seq and crL by par. Fig.2 illustrates one such interaction term, which encodes as a term the diagrammatic representation of our running example (drawn at the top left of Fig.1).\n\u25b6 Definition 3. The set I of interactions is the set of ground terms TF built over F s.t.:\nF0 = A\u222a {\u2205} F1 = {loopS} F2 = {strict, alt} \u222a \u22c3\n\u2113\u2282L\n{cr\u2113} \u2200 k > 2, Fk = \u2205\nIn this paper, we define a method to build a NFA such as the one from Fig.1 from a term expressed in the language from Def.3 which encodes a sequence diagram. In order to determine the transitions of that NFA we rely on a relation of the form i a\u2212\u2192 i\u2032 where i is an interaction, a is an action which can immediately occur within behaviors specified by i and i\u2032 is an interaction specifying all the continuations of behaviors specified by i that start with the occurrence of a. This kind of relation corresponds to execution relations of structural operational semantics [39].\nIn [32], we have defined such a semantics for interactions in the style of Plotkin [39]. The following introduces a compact rewording of that semantics with two new contributions: (1) the introduction of a delayed-choice rule from [33] which allows the generation of smaller NFA and (2) the handling of concurrent regions.\nIn order to express that semantics we define several predicates inductively on the term structure of interactions. For any i and i\u2032 in I, any \u2113 \u2286 L and any a \u2208 A, these are:\nan evasion predicate i \u2193\u2113 which determines whether or not i is able to express traces which involve no action occurring on a lifeline of \u2113 a pruning relation i\u00d7\u00d7\u2113\u2212\u2192 i\u2032 which characterizes an interaction i\u2032 that exactly specifies all the traces expressed by i that involve no action occurring on a lifeline of \u2113 and finally the non-expression i \u0338a\u2212\u2192 and expression i a\u2212\u2192 i\u2032 relations."
        },
        {
            "heading": "3.2 Structural operational semantics",
            "text": "We say that an interaction i \u2208 I evades a set of lifelines \u2113 \u2286 L if it can express traces that contain no actions occurring on lifelines of \u2113. Its definition in Def.4 follows directly from the meaning of the involved operators: for example, any loop term loopS(i) evades any set of lifelines \u2113 \u2286 L because it specifies the empty behavior \u03b5 which corresponds to repeating 0 times the loop.\n\u25b6 Definition 4 (Evasion). The predicate \u2193 \u2286 I \u00d7 P(L) is s.t. for any \u2113 \u2286 L, any i1 and i2 from I, any f \u2208 {strict} \u222a \u22c3 \u2113\u2032\u2286L{cr\u2113\u2032} we have:\n\u2205 \u2193\u2113 \u03b8(a) \u0338\u2208 \u2113 a \u2193\u2113 ij \u2193\u2113 j \u2208 {1, 2} alt(i1, i2) \u2193\u2113\ni1 \u2193\u2113 i2 \u2193\u2113\nf(i1, i2) \u2193\u2113 loopS(i1) \u2193\u2113\nThe pruning relation from Def.5 characterizes for any interaction i, the existence and unicity of another interaction i\u2032 which accepts exactly all executions of i that do not involve any lifelines in \u2113 \u2286 L.\n\u25b6 Definition 5 (Pruning). The pruning relation \u00d7\u00d7\u2192 \u2282 I \u00d7 P(L) \u00d7 I is s.t. for any \u2113 \u2208 L, any x \u2208 {\u2205} \u222a A, any i1 and i2 from I and any f \u2208 {strict, alt} \u222a \u22c3 \u2113\u2032\u2286L{cr\u2113\u2032}:\nx \u2193\u2113\nx\u00d7\u00d7 \u2113\u2212\u2192 x\nij\u00d7\u00d7 \u2113\u2212\u2192 i\u2032j \u00ac(ik \u2193\u2113) {j, k} = {1, 2} alt(i1, i2)\u00d7\u00d7 \u2113\u2212\u2192 i\u2032j\ni1\u00d7\u00d7 \u2113\u2212\u2192 i\u20321 i2\u00d7\u00d7 \u2113\u2212\u2192 i\u20322 f(i1, i2)\u00d7\u00d7 \u2113\u2212\u2192 f(i\u20321, i\u20322)\ni1\u00d7\u00d7 \u2113\u2212\u2192 i\u20321\nloopS(i1)\u00d7\u00d7 \u2113\u2212\u2192 loopS(i\u20321)\n\u00ac(i1 \u2193\u2113)\nloopS(i1)\u00d7\u00d7 \u2113\u2212\u2192 \u2205\nThe semantics from [32] relies on the definition of an execution relation which relates interactions to (1) the actions which are immediately expressible and (2) the interactions which remain to be expressed afterwards. With Def.6, we can determine which actions cannot be immediately expressed via the \u2192\u0338 relation.\n\u25b6 Definition 6 (Non-expression). The predicate \u2192\u0338 \u2286 I \u00d7 A is s.t. for any a \u2208 A, any x \u2208 {\u2205} \u222a A, any i1 and i2 from I and any \u2113 \u2286 L:\nx \u0338= a x \u0338a\u2212\u2192\ni1 \u0338 a\u2212\u2192\nloopS(i1) \u0338 a\u2212\u2192\ni1 \u0338 a\u2212\u2192 (\u00ac(i1 \u2193L)) \u2228 (i2 \u0338 a\u2212\u2192) strict(i1, i2) \u0338\na\u2212\u2192 i1 \u0338 a\u2212\u2192 (\u00ac(i1 \u2193{\u03b8(a)}\\\u2113)) \u2228 (i2 \u0338 a\u2212\u2192)\ncr\u2113(i1, i2) \u0338 a\u2212\u2192\ni1 \u0338 a\u2212\u2192 i2 \u0338 a\u2212\u2192 alt(i1, i2) \u0338 a\u2212\u2192\nThe relation \u2192 given in Def.7 uses the predicates from Def.4, Def.5 and Def.6 to characterize transformations of the form i a\u2212\u2192 i\u2032 where i \u2208 I is an interaction, a \u2208 A is an action which is immediately executable from i and i\u2032 \u2208 I is a follow-up interaction which characterizes continuations of behaviors specified by i that start with a.\n\u25b6 Definition 7 (Expression). The predicate \u2192 \u2286 I \u00d7 A \u00d7 I is s.t. for any a \u2208 A, any i1, i2, i\u20321 and i\u20322 from I, any f \u2208 {strict} \u222a \u22c3 \u2113\u2032\u2286L{cr\u2113\u2032} and any {j, k} = {1, 2}:\nact a a\u2212\u2192 \u2205 i1 a\u2212\u2192 i\u20321 loop loopS(i1) a\u2212\u2192 strict(i\u20321, loopS(i1)) i1 a\u2212\u2192 i\u20321 f-left f(i1, i2) a\u2212\u2192 f(i\u20321, i2)\ni2 a\u2212\u2192 i\u20322 i1 \u2193L strict-right strict(i1, i2) a\u2212\u2192 i\u20322\ni2 a\u2212\u2192 i\u20322 i1\u00d7\u00d7 {\u03b8(a)}\\\u2113\u2212\u2212\u2212\u2212\u2212\u2192 i\u20321 cr-right cr\u2113(i1, i2) a\u2212\u2192 cr\u2113(i\u20321, i\u20322)\nij a\u2212\u2192 i\u2032j ik \u0338 a\u2212\u2192 alt-choice\nalt(i1, i2) a\u2212\u2192 i\u2032j\ni1 a\u2212\u2192 i\u20321 i2 a\u2212\u2192 i\u20322 alt-delay alt(i1, i2)\na\u2212\u2192 alt(i\u20321, i\u20322) The relation from Def.7 resembles those found in process algebra. Rules \u201cact\u201d, \u201cloop\u201d and \u201cf-left\u201d are self-explanatory. Given i1 and i2 two interactions, we can execute an action a2 on the right of either strict(i1, i2) or cr\u2113(i1, i2) (with \u2113 \u2286 L) i.e. resulting from the execution of i2 iff it does not contradict the partial orders imposed by either strict or cr\u2113 between the actions of i1 and those of i2.\nRule \u201cstrict-right\u201d imposes the termination of i1 before any action from i2 can be executed. This termination is possible iff i1 can express the empty behavior \u03b5 which is characterized by i1 \u2193L because \u03b5 is the only behavior which involves no action occurring on any one of the lifelines of L. If a2 is executed, we then consider that i1 has terminated (otherwise we might subsequently observe actions a1 from i1 which contradicts the order imposed by strict) and there only remains to execute i\u20322 which is s.t. i2\na\u2212\u2192 i\u20322. If \u2113 = L, we are in the presence of interleaving operator par = crL. In that case, it is always possible to execute a2 from i2 because any action a1 from i1 can occur either before or after a2. This is reflected by the fact that {\u03b8(a)} \\ L = \u2205 and that i1\u00d7\u00d7\n\u2205\u2212\u2192 i1 always holds. Hence we have i\u20321 = i1 and the predicate i1\u00d7\u00d7\n\u2205\u2212\u2192 i1 = \u22a4 which makes rule \u201ccr-right\u201d coincide with the classical right-rule for interleaving [32].\nIf \u2113 = \u2205, we are in the presence of weak sequencing operator seq = cr\u2205. In that case let us consider an action a1 from i1 occurring on the lifeline \u03b8(a2) on which a2 occurs. If a1 must occur whenever i1 is executed, then it must logically occur before a2 (as imposed by seq). Hence, if a2 occurs first, this means a1 must not occur at all. It is possible for i1 not to express a1 (and any other action occurring on \u03b8(a2)) iff i1 \u2193{\u03b8(a)}. In that case, in order to compute a follow-up to the execution of a2 from i2 in seq(i1, i2), we need to clean-up i1 from any action occurring on \u03b8(a2). This is the role of the pruning predicate \u00d7\u00d7\u2192 which intervenes in \u201ccr-right\u201d via the condition of the existence of a i\u20321 s.t. i1\u00d7\u00d7\n{\u03b8(a)}\u2212\u2212\u2212\u2212\u2192 i\u20321. In the pruned interaction i\u20321, we only preserve behaviors of i1 that do not contradict the fact that a2 occurs before any action from i1. In that sense, and because \u2113 = \u2205, the \u201ccr-right\u201d rule coincides with the classical right-rule for weak sequencing [32].\nFor all the other cases i.e. whenever \u2113 \u228a L and \u2113 \u0338= \u2205, the condition i1\u00d7\u00d7 {\u03b8(a)}\\\u2113\u2212\u2212\u2212\u2212\u2212\u2192 i\u20321 of rule \u201ccr-right\u201d makes so that cr\u2113 behaves like interleaving for actions occurring on lifelines of \u2113 and like weak sequencing for those occurring on L \\ \u2113. Fig.3a illustrates the use of a co-region and of pruning on an example. Here cr{l1} makes so that the emission of m1 and m2 can occur in any order but that m1 must be received before m2 if it is ever received. When we execute l1!m2, because it can occur after l1!m1 due to the concurrent region on l1, the pruning predicate \u00d7\u00d7l1\u2212\u2192 does not force the choice of a branch of the alternative. However, when we execute l2?m2, pruning forces the right branch of the alternative (containing the empty interaction \u2205) to be chosen. Otherwise, we would risk having l2?m1 occur afterwards, which is forbidden by the weak sequencing. \u25b6 Remark 8. The par = crL operator is the most permissive scheduling operator (among strict and all the cr\u2113 with \u2113 \u2286 L which includes seq = cr\u2205). Indeed, all left rules have\nthe same form and thus allow the same derivations while the right rules contain restrictive conditions for strict and all cr\u2113 (resp. i1 \u2193L for strict and i1\u00d7\u00d7\n{\u03b8(a)}\\\u2113\u2212\u2212\u2212\u2212\u2212\u2192 i\u20321 for cr\u2113 with \u2113 \u228a L) but not for par = crL because {\u03b8(a)} \\ L = \u2205 and we always have that i1\u00d7\u00d7\n\u2205\u2212\u2192 i1 holds. As a result, any f \u2208 {strict} \u222a \u22c3 \u2113\u2286L{cr\u2113} allows less derivations than par = crL by construction.\nIn our formalism strict sequencing strict is used to enforce a strict order between any two actions. We use it to encode the asynchronous passing or broadcast of a message in e.g. strict(l1!m, l2?m) and also as the scheduling operator associated to the strictly sequential loop loopS . The co-region operators encode both parallel composition and weak sequencing and provides additional expressiveness w.r.t. [32]. It can be used e.g. for specifying that some messages are emitted in a specific order but may be received in any order.\nThere are several trace-equivalent (as opposed to bissimilar) manners to define an operational rule for the non-deterministic choice alt operator. Fig.3b and Fig.3c present two such manners. In [31, 30], we have presented the manner described on Fig.3b in which choice of alternative branches is made as soon as possible. In this paper, we rather favor the one described on Fig.3c that is called delayed-choice in [33] as its use will further reduce the number of states of generated NFA.\n\u25b6 Definition 9 (Semantics). \u03c3 : I \u2192 P(T) is defined by:\ni \u2193L \u03b5 \u2208 \u03c3(i) t \u2208 \u03c3(i\u2032) i a\u2212\u2192 i\u2032 a.t \u2208 \u03c3(i)\nThe predicates from Def.4 and Def.7 enable us to define an operational semantics of interactions in Def.9. The set \u03c3(i) of traces of an interaction i contains all (possibly empty) sequences a1a2 . . . ak of actions such that there exist some execution steps i a1\u2212\u2192 i1, i1 a2\u2212\u2192 i2, . . . ik\u22121 ak\u2212\u2192 ik with ik \u2193L. In particular, if the sequence is empty, then i \u2193L and \u03b5 \u2208 \u03c3(i). We denote by \u2217\u2192 the reflexive and transitive closure of the execution relation \u2192. The above predicate definitions are consistent in the sense that they are interdependent and complementary. For instance, for any \u2113 \u2286 L, any i in I, i \u2193\u2113 iff there exists a unique i\u2032 in I s.t. i\u00d7\u00d7\u2113\u2212\u2192 i\u2032. Other such properties can be stated about the operational semantics, but are not essential for the rest of the paper. In the sequel we essentially use the rules of Def.7.\n4 Deriving NFA from interactions\n4.1 Our approach\nA FA generated from an interaction describing a real-world system may be extremely large (in number of states) which poses problems related to the time for building the FA or the space for storing it.\nState reduction and state minimization correspond to obtaining an equivalent FA with resp. fewer states and as few states as possible. It is known that a minimal DFA may have an exponentially larger number of states than that of an equivalent minimal NFA [22]. For instance, given alphabet {a, b}, the regular expression (a|b)\u2217a(a|b)n\ncan be encoded as a NFA with n + 2 states while an equivalent minimal DFA has 2n+1 states. Because interactions can encode such expressions, choosing NFA as a target formalism is preferable if we want to optimise towards state reduction. Also, operators such as par = crL, seq = c\u2205, alt and loopS make behaviors of interactions non-deterministic and cyclic.\nHowever, the problem of state minimization for NFA is PSPACE-complete [16]. Various algorithms exist, such as Kameda-Weiner [18] or [36, 40]. Still, scalability is problematic, as demonstrated by the search for approximal solutions (i.e. to find reduced but not minimal NFA in a more reasonable time) [6, 14, 15, 11]. [15] relies on identifying and merging equivalent states while [11] encodes the problem in SAT. Yet, experimental validation is limited to small NFA (in [11] they consider at most 15 states). Vastly more efficient algorithms exist for strict subsets of NFA such as DFA (e.g. Hopcroft [13]) or acyclic automata [7, 2] but they cannot be used to minimize FA obtained from interactions (for which the minimal FA is a minimal NFA which can be cyclic and non deterministic).\nFig.4 describes two manners to generate reduced NFA from interactions. The red path uses of a translation mechanism that is not optimized for state reduction followed by that a NFA state reduction technique. By contrast, the green path uses a translation mechanism which incorporates on-the-fly state reduction so as to directly obtain a reduced NFA. Due to the aforementioned difficulty of NFA reduction, we argue that such an approach is preferable.\nIn the following, we detail one such mechanism. We prove that the set of interactions reachable by iterating the application of elementary steps i a\u2212\u2192 i\u2032 is finite which enables the construction of a NFA in which each state corresponds to an interaction. We explain how we can reduce the number of states on-the-fly by simplifying interactions as they are discovered (using term rewriting). Memoization of already encountered simplified terms allows building the set of states of the NFA while the identification of transformations i a\u2212\u2192 i\u2032 allows building its set of transitions and a state corresponding to a term i is accepting iff i \u2193L."
        },
        {
            "heading": "4.2 Details of the NFA generation mechanism",
            "text": "Given an interaction i, the set of interactions reachable from i with the relation \u2192 is finite. This allows us to define a finite set reach(i) of such terms.\n\u25b6 Lemma 10. For any i \u2208 I, the set reach(i) = {i\u2032 | i \u2217\u2192 i\u2032} is finite.\nProof. For any interaction i \u2208 I let us reason by induction on interactions in I. For i = \u2205, reach(i) is reduced to {\u2205} since no rule is applicable. For i = a \u2208 A, reach(i) = {a,\u2205} since only rule \u201cact\u201d is applicable and yields a a\u2212\u2192 \u2205.\nConsidering par = crL, for i = par(i1, i2), we have reach(i) = {par(j1, j2) | j1 \u2208 reach(i1), j2 \u2208 reach(i2)}. Indeed, from terms of this form, we can apply either rule \u201cf-left\u201d or \u201ccr-right\u201d. The former replaces the sub-term i1 by a certain i\u20321 leading to a term of the form par(i\u20321, i2). Because whichever is the action a that is executed we have {\u03b8(a)} \\ L = \u2205, we always have i1\u00d7\u00d7\n\u2205\u2212\u2192 i1 as the right-hand-side condition of the application of \u201ccr-right\u201d. As a result, applying it yields a term of the form par(i1, i\u20322), with i1 being preserved and i\u20322 reached from i2. The same two rules are again the only ones applicable from these terms so that by applying them several times, successive derivations result in all terms of the form par(j1, j2) with j1 (resp j2) reachable from i1 (resp. i2), i.e. j1 \u2208 reach(i1) (resp. j2 \u2208 reach(i2)). Both reach(i1) and reach(i2) are finite by induction and hence reach(i) is also finite.\nFor i = f(i1, i2) with f \u2208 {strict} \u222a \u22c3\n\u2113 \u228a Lcr\u2113, we have |reach(i)| \u2264 |reach(par(i1, i2))|. Indeed, as per Rem.8, these operators enable less interleavings than par. Derivations from a term of the form f(i1, i2) lead to terms of the form f(i\u20321, i\u20322) with the property that the derivation par(i1, i2)\na\u2212\u2192 par(i\u20321, i\u20322) also holds. As by hypothesis (previous point), reach(par(i1, i2)) is finite, reach(f(i1, i2)) is also finite.\nFor i = alt(i1, i2), then reach(i) \u2282 {i} \u222a reach(i1) \u222a reach(i2) \u222a {alt(j1, j2) | j1 \u2208 reach(i1), j2 \u2208 reach(i2)}. Indeed, a derivation alt(i1, i2)\na\u2212\u2192 i\u2032 comes from either the rule \u201calt-choice\u201d or the rule \u201calt-delay\u201d:\nif it comes from the rule \u201calt-choice\u201d, then it means that there is a k \u2208 {1, 2} s.t. ik a\u2212\u2192 i\u2032 and i\u2032 \u2208 reach(ik) as well as all the following interactions. if it comes from the rule \u201calt-delay\u201d, then i\u2032 is of the form alt(i\u20321, i\u20322) and, by induction, all continuations are in either reach(i\u20321), reach(i\u20322) or {alt(j1, j2) | j1 \u2208 reach(i\u20321), j2 \u2208 reach(i\u20322)} The induction hypothesis implies that both reach(i1) and reach(i2) are finite. Hence reach(i) is also finite.\nFor i = loopS(i1), then reach(i) = {i} \u222a {strict(j1, i) | j1 \u2208 reach(i1)}. For such terms, only rule \u201cloop\u201d is applicable so that the first derivation (if it exists) results in a term of the form strict(i\u20321, loopS(i1)). From there:\nif we apply the \u201cf-left\u201d rule, we obtain a term of the form strict(i\u2032\u20321 , loopS(i1)) with i\u20321\na\u2212\u2192 i\u2032\u20321 . With further applications of rule \u201cf-left\u201d, we obtain all terms of the form strict(j1, loopS(i1)) with j1 \u2208 reach(i1). if we apply \u201cstrict-right\u201d, it means that i\u20321 \u2193L and that we have loopS(i1)\na\u2212\u2192 strict(i\u22171, loopS(i1)) with i1 a\u2212\u2192 i\u22171 so that we obtain strict(i\u20321, loopS(i1)) a\u2212\u2192 strict(i\u22171, loopS(i1)). As i\u22171 belongs to reach(i1), by applying the \u201cstrict-right\u201d rule, we find yet again an interaction of the form strict(j1, i) with j1 \u2208 reach(i1).\nDue to the induction hypothesis, reach(i1) is finite and as a result, reach(i) = {i} \u222a {strict(j1, i) | j1 \u2208 reach(i1)} is also finite. \u25c0\nLem.10 defines the set reach(i) of all the interactions that can be reached from i via the execution relation \u2192 and states that this set is always finite. In Def.11, this enables building a NFA whose recognized language coincides with the set of traces of the interaction i.\n\u25b6 Definition 11. For any i0 \u2208 I, nfa(i0) = (A, Q, q0, F,\u21dd) is the NFA whose elements are defined by: Q = reach(i0), q0 = i0, F = {i | i \u2208 Q, i \u2193L} and \u21dd= {(i, a, i\u2032) |(i, i\u2032) \u2208 Q2, a \u2208 A, i a\u2212\u2192 i\u2032}.\nDef.11 is well founded. Indeed, the set Q is finite according to Lem.10, the subset F of accepting states and the transition relation \u21dd are defined thanks to predicates \u2193L and \u2192 from Def.4 and Def.7.\nTh.12 states the soundness of the translation i.e. that the language recognized by nfa(i) corresponds to the semantics \u03c3(i).\n\u25b6 Theorem 12. For any interaction i \u2208 I, we have L(nfa(i)) = \u03c3(i)\nProof. The construction of the automaton reflects the construction of the execution tree: there is a transition i\u2032 a\u21dd i\u2032\u2032 in nfa(i) for each execution step i\u2032 a\u2212\u2192 i\u2032\u2032 issued from i\u2032 and reciprocally. As accepting states of nfa(i) coincide with reachable interactions i\u2032 verifying i\u2032 \u2193L, then sequences recognized by nfa(i) are traces of i, i.e. we have L(nfa(i)) = \u03c3(i). \u25c0\nIn most cases, the iterative application of the execution relation \u2192 creates many useless occurrences of \u2205 in the derived interaction terms. These sub-terms can be removed without the set of traces being modified. For example, because of the rule \u201cf-left\u201d derivations from strict(i,\u2205) are exactly those from i. strict(i,\u2205) and i are said to be semantically equivalent. The construction of the NFA associated with an interaction can take advantage of considering such semantically equivalent terms in order to reduce the number of states given that each state corresponds to a term. In order to set up these simplification mechanisms, we provide in Def.13 a set R of rewrite rules aimed at eliminating useless occurrences of \u2205.\n\u25b6 Definition 13. Given a variable x, R is the following set of rewrite rules over TF ({x}):\nR =  \u222af\u2208{strict}\u222a \u22c3 \u2113\u2282L {cr\u2113} {f(\u2205, x)\u21dd x, f(x,\u2205)\u21dd x}\n\u222a {alt(\u2205, loopS(x))\u21dd loopS(x), alt(loopS(x),\u2205)\u21dd loopS(x)} \u222a {alt(\u2205,\u2205)\u21dd \u2205, loopS(\u2205)\u21dd \u2205}  These rewrite rules define a TRS \u2192R which is convergent and preserves the semantics \u03c3\n(as per Lem.14).\n\u25b6 Lemma 14. The TRS characterized by R is convergent and semantically sound i.e. for any i \u2208 I, \u2203! is \u2208 I s.t. i \u2192!R is and we have \u03c3(i) = \u03c3(is).\nProof. \u2192R is both terminating and confluent (see automated proof in [29] using the TTT2 [20] and CSI [44] tools) and hence convergent. To prove semantic equivalence it suffices to prove it for interactions related by all \u21dd\u2208 R which is trivial. \u25c0\nLem.14 stating that the TRS is convergent, for any i \u2208 I, there exists a unique is such that i \u2192!S is. With the index s standing for \u201csimplified\u201d, we use the notation _s to designate simplified terms. This allows us to consider simplified NFA generation in Def.15.\n\u25b6 Definition 15. For any i0 \u2208 I, nfas(i0) = (A, Q, q0, F,\u21dd) is the NFA s.t.: Q = {is \u2208 I | i \u2208 reach(i0)}, q0 = i0s, F = {is | i \u2208 Q, i \u2193L} and\n\u21dd= {(is, a, i\u2032s) |(i, i\u2032) \u2208 reach(i0)2, a \u2208 A, i a\u2212\u2192 i\u2032} .\nIn a few words, nfas(i0) is the quotient NFA of the NFA nfa(i0) by the equivalence relation on interactions defined by: i \u2261 i\u2032 iff is = i\u2032s. In particular, transitions between two simplified interactions j and j\u2032 include all transitions between interactions i and i\u2032 verifying is = j and i\u2032s = j\u2032. Those results can be generalized for any convergent and semantically sound Term Rewrite System for interactions1. In fact, each node of the generated NFA may rather correspond to an equivalence class of (semantically equivalent) interactions according to a certain equivalence relation which preserves semantics \u03c3.\n1 A more complete sound TRS for interactions, taking advantage of algebraic properties of operators (associativity of strict, seq, par, alt, commutativity of alt and par, idempotency of loops etc.) is given in [24] and its convergence proven modulo AC.\nFig.5 illustrates this process on an example and the advantage of using term simplification. On Fig.5c, we represent the NFA nfa(i) associated to the example interaction i drawn on Fig.5a. We deliberately chose a very simple interaction so that the associated NFA is small and easy to visualize. Fig.5b gives the simplified nfas(i) obtained via the simplification of redundant occurrences of \u2205. The use of these simplifications allows a reduction of 2 states (from 5 in nfa(i) to 3 in nfas(i)).\n5 Experiments\nWe have implemented NFA generation from interactions via the nfas function in the tool HIBOU [25]. Simplifications (Def.13) are systematically applied to newly encountered interactions when building the automaton (the object nfa(i) e.g. from Fig.5c is never built and we directly construct nfas(i) e.g. from Fig.5b).\nThe following presents three sets of experiments which main results are resp. given on Fig.6a, Fig.6b and Fig.7. The experiments were performed using an Intel(R) Core(TM)i56360U CPU (2.00GHz) with 8GB RAM. Details of the experiments and the artifacts required to reproduce them are available in [28, 27] and in the appendices.\nAssessing the reduction of generated NFA. As a first step, to assess the size of a generated NFA we compare its number of states to that of equivalent minimal NFA and DFA computed using implementations of resp. the Kameda-Weiner [18] and Brzozowski\u2019s algorithms in the AUTOUR [26] toolbox.\nSo as to highlight the importance of the NFA formalism w.r.t. DFA, let us consider a digital lock mechanism as a first use case. To open the lock, we have to enter 6 digits, the first 3 of them forming a specific sequence w, while the last 3 may be random. Encoded as an interaction, it consists of a single lifeline l, which can receive as inputs combinations of a and b characters. Once the lock is unlocked, it emits a u message. Hence, given L = {l}, M = {a, b, u} this specification accepts traces corresponding, given alphabet A, to the regular expression: (l?a|l?b)\u2217.w.(l?a|l?b)3.l!u. This system with a single lock can be used to define systems with n > 1 locks in which before opening a lock, we might need to unlock first\nseveral others. For instance, let us consider a system with 2 locks l1 and l2 such that l1 must be unlocked first. Its behavior can be characterized using seq(il1 , seq(strict(l1!u, l2?u), il2)) where il1 and il2 resp. correspond to combinations required to open l1 and l2.\nOn Fig.6a, we summarize experiments performed on 3 systems with resp. 1, 4 and 8 locks (each example corresponding to a row). The |Q| nfas, |Q| minNF A and |Q| minDF A columns resp. correspond to the number of states of the generated NFA and equivalent minimal NFA and DFA. The column on their right gives the time required to generate or minimize the FA. We can observe that determinization increases the number of states exponentially. NFA minimization yields a NFA with the same number of states for the smaller example and quickly becomes untractable for the larger ones.\nComparison with compositional NFA generation. In order to compare our approach with those of the literature [1, 43], we have also implemented an alternative \u201ccompositional\u201d method for NFA generation. It involves (1) identifying the maximal \u201cbasic interactions\u201d (i.e. with only strict and seq) sub-terms of an initial interaction i, (2) generating a NFA for each one using our approach and (3) composing them using NFA operators depending on the structure of i to obtain a certain compo(i) NFA.\nBecause there is no NFA operator for weak sequencing, a limitation of this compositional approach (which we further discuss in Sec.4) is that i cannot have seq outside \u201cbasic interactions\u201d. So as to apply it to our examples, we therefore need to replace the seq between the locks with either strict or par. Doing so requires identifying which locks are executed concurrently resp. strictly sequentially (which is normally done by seq organically depending on the exchange of u messages between locks). By manually replacing seq, we obtain a different specification which expresses a slightly different language. We can then compare both approaches (nfas and compo) on these new s&p specifications. Results are presented on Fig.6b. A NFA obtained via compo has fewer states than the minimal DFA but still much more states than the NFA obtained via nfas.\nDistributed system use cases and trace analysis. In this context, trace analysis simply corresponds to assessing whether or not a trace t \u2208 T belongs to the semantics \u03c3(i) of an interaction i. In previous works [31], we used interactions directly to perform trace analysis. Indeed, the relation \u2192 allows trying to re-enact a trace t from an initial i, and, if this is possible, then t \u2208 \u03c3(i). As an alternative, we can leverage the generated NFA to verify t \u2208 L(nfas(i)) which simply consists in trying to read the word in the NFA. The major difference is that this equates to using pre-calculated interaction terms (the reachable simplified interactions) instead of computing them as needed.\nFig.7 summarizes experiments conducted on interactions taken from the literature: a model of the Alternating Bit Protocol [33], a connected platoon of autonomous Rovers [3] and a DApp system for managing Human-Resources [21]. Each use case corresponds to a row on Fig.7. The second and third columns give the number of states of the generated NFA and the time required to compute it. For each use case, we have generated a number of accepted traces and an equal number of error traces. Column T gives this number while column t gives the minimal and maximal size of generated traces. For each accepted trace (resp. error trace), both the interaction and NFA methods (respectively denoted as i and nfas) return a Pass (resp. Fail) verdict. The last four columns of the table correspond to rates (in actions per second) associated with the analysis of traces using either method on either accepted (\u2713) or error (p) traces. As might be expected, empirical evidence goes in favor of using generated NFA for trace analysis. For some long error traces in the HR usecase [21] analysis using interactions may even timeout. Plotting the data reveals that, with the method from [31] the average rate decreases with the length of traces while this is not the case for the NFA-based method. However, let us keep in mind that not all interactions can be translated into NFA (e.g. using weakly sequential loops from [32]).\n6 Comments and related work\nRepetition and boundedness. In addition to loopS , which is related to strict sequencing strict, [32] considered loopW and loopP which are repetitions (Kleene closures) using resp. weak sequencing seq and interleaving par. These loops are problematic for the definition of a translation towards NFA. Indeed, in contrast to loopS , with either loopW or loopP , it is possible that arbitrarily many instances of the loop are active at the same time (i.e. have started but have not yet been entirely executed). Fig.8a illustrates this with a loopW which enables several instances of messages m to be sent by l1 consecutively without any being received by l2. That is \u03c3(i) is the set of words w in {a = l1!m, b = l2?m}\u2217 verifying |w|a = |w|b and for all prefixes u of w, |u|a \u2265 |u|b. Using the pumping lemma from [23], one can state that there is no NFA recognizing this language. Another manner to consider loopW would be to restrict its use to a subclass of \u201cbounded interactions\u201d in the same fashion as \u201cbounded MSC graphs\u201d [38, 12, 1, 23] (see also process divergence in [5]) as illustrated in Fig.8b. Here, because lifeline l1 must wait for\nthe reception of m2 before being able to emit a second instance of message m1, there are only 4\ndistinct global states in which the system may be. Consequently, at most 1 message can be in transit between l1 and l2. Boundedness [38, 12, 1] generalizes this observation, characterizing MSC graphs in which there can only be a finite amount of \u201cbuffered\u201d messages in transit between any two lifelines. Note that deciding boundedness comes at some computational cost (NP-hard, see [38]).\nFA generation from interactions. Several works [1, 43] propose translations of interactions into automata. In [1], basic Message Sequence Charts (bMSC) are described using partial order relations induced by send-receive pairs and local orders of actions on each lifeline. A bMSC contains a sequence of send-receive pairs and corresponds, in our framework, to a sequence of patterns of the form strict(l1!m, l2?m) arranged with seq. bMSC are then combined to form graphs of MSC (MSC-g) in order to support more complex behaviors. Nodes of a MSC-g contain bMSC and its edges, linking two bMSC correspond to a concatenation of the behaviors specified by each. This concatenation can either be interpreted as strict or seq which resp. corresponds to the synchronous and asynchronous interpretation in [1]. For the former, MSC-g are associated to NFA by linearizing the partial orders of each bMSC node and by concatenating the resulting NFA (one per node) along the graph edges. Besides, they point out that the problem of building a NFA from a MSC-g with the asynchronous interpretation is undecidable. [43] proceeds in a somewhat similar fashion with UML-SD. Basic SD (only containing message passing and seq) are identified within the overall SD and individually transformed into NFA. Those NFA are then composed following the structure of the SD. For this, operators of UML-SD are mapped to operators on NFA. For instance, they map alt to NFA union and loop to NFA Kleene star (hence it corresponds to our strictly sequential loop loopS). Because there is no NFA operator equivalent to seq, the use of seq is restricted to basic SD. This method corresponds to the compo used in our experiments in Sec.5.\nWe propose translating any interaction i into an equivalent NFA which states correspond to (sets of) interactions reachable from i and transitions are derived from execution steps i\u2032\na\u2212\u2192 i\u2032\u2032. In our approach, every operator is handled in the same way and hence, unlike [1, 43], the seq operator can be used above complex operators such as alt, par or loopS .\nFig.9a provides an example MSC-g built over 4 bMSC. Under the synchronous interpretation of graph edges, we would translate this MSG-g into the interaction term from Fig.9b. If we were to consider the asynchronous interpretation, using the weak sequential loop operator loopW from [32], we would translate it as the term from Fig.9c. Unlike the former, the latter cannot be translated into a NFA, as stated by the non-decidability result from [1]. However, with our approach, we can provide NFA translation with a greater expressivity, as underlined with the third interpretation of the graph given on Fig.9d. Indeed, using loopS and seq, we\nmay interpret distinct edges of the graph either synchronously or asynchronously. Moreover, this allows using seq at any scope within the specification, unlike [43] where it must be used within basic SD.\nThe principle of our approach lies much closer to that of [4, 42] in which FA are build from regular expressions. [42] extends upon [41] in which, for any regular expression and any letter, a unique derivative expression is defined (in effect constituting a deterministic operational semantics of regular expressions). [42] uses circular coinduction as a decision procedure for the equivalence of regular expressions. It then leverages the unicity of derivatives in [41] to construct a DFA which states correspond to circularities of regular expressions (i.e. groups of regular expressions with the same language) and transitions to the application of derivations. By contrast, in [4], partial derivatives are used on regular expressions written in linear form so as to obtain small NFA (with a number of states no greater than the alphabetic width of the regular expression).\nThe size of NFA generated from basic interactions (with only seq and message passing via strict) is, in the worst case, O(nk) where n is the number of message passing patterns and k is the number of lifelines [1, 43, 35, 10]. Such interactions resembles basic MSC [1, 43] or regular expressions with interleaving over finite words [35]. The witness interaction par(l1!m, par(. . . , ln!m) . . .) consisting of the interleaving of n distinct atomic actions accepts as traces all possible interleavings of those n actions. Any NFA associated to it must have at least 2n states. Hence, the cost of NFA generation with par is \u2126(2n), which relates to results established for regular expressions with interleaving [35, 10].\nFA and trace analysis. FA are extensively used for trace analysis in the domain of monitoring or runtime verification. However, they are mostly generated from logics such as Linear Temporal Logic (LTL) [8, 17, 19] rather than interaction models. [8] focuses on generating FA monitors that recognize the minimal bad prefixes of \u03c9-languages (sets of infinite traces). These monitors are created by reducing B\u00fcchi Automata into Binary Transition Tree Finite State Machines (BTT-FSM). Finite trace analysis against the generated FSM is performed online (as can we using our generated NFA). Overall, automata are preferred in runtime verification due to their compact form, efficient memory usage, and faster processing. They offer various advantages for trace analysis, particularly for distributed systems dealing with unreliable communication channels [19] or lossy traces due to network-related issues [17].\n7 Conclusion\nWe have proposed an approach for generating Non-deterministic Finite Automata (NFA) from Interactions. It employs derivatives and term simplification to generate concise NFA onthe-fly. Our approach is validated through proofs and experiments with several interactions from the literature, showcasing the reduced quality of generated NFA (no need for costly NFA reduction machinery) and their suitability for trace analysis.\nReferences\n1 Rajeev Alur and Mihalis Yannakakis. Model checking of message sequence charts. In Jos C. M. Baeten and Sjouke Mauw, editors, CONCUR \u201999: Concurrency Theory, 10th International Conference, Eindhoven, The Netherlands, August 24-27, 1999, Proceedings, volume 1664 of Lecture Notes in Computer Science, pages 114\u2013129. Springer, 1999. doi: 10.1007/3-540-48320-9\\_10.\n2 Jerome Amilhastre, Philippe Janssen, and Marie-Catherine Vilarem. Fa minimisation heuristics for a class of finite languages. In Oliver Boldt and Helmut Jurgensen, editors, Automata Implementation, pages 1\u201312, Berlin, Heidelberg, 2001. Springer Berlin Heidelberg.\n3 Maroneze Andre, Massonnet Philippe, Dupont Sebastien, Nigam Vivek, Plate Henrik, Sykosch Arnold, Cakmak Eren, Thanasis Sfetsos, Jimenez Victor, Amparan Estibaliz, Martinez Cristina, Lopez Angel, Garcia-Alfaro Joaquin, Segovia Mariana, Rubio-Hernan Jose, Blanc Gregory, Debar Herve, Carbone Roberto, Ranise Silvio, Verderame Luca, Spaziani-Brunella Marco, Yautsiukhin Artsiom, Morgagni Andrea, Klein Jacques, Bissyande Tegawende, and Samhi Jordan. Assessment specifications and roadmap. In EC, editor, Technical report. SPARTA project, 2020.\n4 Valentin Antimirov. Partial derivatives of regular expressions and finite automata constructions. In Ernst W. Mayr and Claude Puech, editors, STACS 95, pages 455\u2013466, Berlin, Heidelberg, 1995. Springer Berlin Heidelberg.\n5 Han\u00eane Ben-Abdallah and Stefan Leue. Syntactic detection of process divergence and non-local choice in message sequence charts. In Ed Brinksma, editor, Tools and Algorithms for the Construction and Analysis of Systems, pages 259\u2013274, Berlin, Heidelberg, 1997. Springer Berlin Heidelberg.\n6 Jean-Marc Champarnaud and Fabien Coulon. Nfa reduction algorithms by means of regular inequalities. In Zoltan Esik and Zoltan Fulop, editors, Developments in Language Theory, pages 194\u2013205, Berlin, Heidelberg, 2003. Springer Berlin Heidelberg.\n7 Jan Daciuk, Bruce W. Watson, Stoyan Mihov, and Richard E. Watson. Incremental construction of minimal acyclic finite-state automata. Comput. Linguist., 26(1):3\u201316, mar 2000. doi:10.1162/089120100561601.\n8 Marcelo d\u2019Amorim and Grigore Rosu. Efficient monitoring of omega-languages. In Kousha Etessami and Sriram K. Rajamani, editors, Computer Aided Verification, 17th International Conference, CAV 2005, Edinburgh, Scotland, UK, July 6-10, 2005, Proceedings, volume 3576 of Lecture Notes in Computer Science, pages 364\u2013378. Springer, 2005. doi:10.1007/11513988\\ _36.\n9 Nachum Dershowitz and Jean-Pierre Jouannaud. Rewrite Systems, page 243\u2013320. MIT Press, Cambridge, MA, USA, 1991.\n10 Wouter Gelade. Succinctness of regular expressions with interleaving, intersection and counting. Theor. Comput. Sci., 411(31-33):2987\u20132998, 2010. doi:10.1016/j.tcs.2010.04.036.\n11 Jaco Geldenhuys, Brink van der Merwe, and Lynette van Zijl. Reducing nondeterministic finite automata with sat solvers. In Anssi Yli-Jyra, Andras Kornai, Jacques Sakarovitch, and Bruce Watson, editors, Finite-State Methods and Natural Language Processing, pages 81\u201392, Berlin, Heidelberg, 2010. Springer Berlin Heidelberg.\n12 Jesper G. Henriksen, Madhavan Mukund, K. Narayan Kumar, Milind A. Sohoni, and P. S. Thiagarajan. A theory of regular MSC languages. Inf. Comput., 202(1):1\u201338, 2005. doi: 10.1016/j.ic.2004.08.004.\n13 John E. Hopcroft. An n log n algorithm for minimizing states in a finite automaton. Technical report, Stanford, CA, USA, 1971.\n14 Lucian Ilie, Gonzalo Navarro, and Sheng Yu. On NFA Reductions, pages 112\u2013124. Springer Berlin Heidelberg, Berlin, Heidelberg, 2004. doi:10.1007/978-3-540-27812-2\\_11.\n15 Lucian Iliea and Sheng Yu. Algorithms for computing small nfas. In Krzysztof Diks and Wojciech Rytter, editors, Mathematical Foundations of Computer Science 2002, pages 328\u2013340, Berlin, Heidelberg, 2002. Springer Berlin Heidelberg.\n16 Tao Jiang and B. Ravikumar. Minimal nfa problems are hard. In Javier Leach Albert, Burkhard Monien, and Mario Rodriguez Artalejo, editors, Automata, Languages and Programming, pages 629\u2013640, Berlin, Heidelberg, 1991. Springer Berlin Heidelberg.\n17 Yogi Joshi, Guy Martin Tchamgoue, and Sebastian Fischmeister. Runtime verification of LTL on lossy traces. In Ahmed Seffah, Birgit Penzenstadler, Carina Alves, and Xin Peng, editors,\nProceedings of the Symposium on Applied Computing, SAC 2017, Marrakech, Morocco, April 3-7, 2017, pages 1379\u20131386. ACM, 2017. doi:10.1145/3019612.3019827.\n18 T. Kameda and P. Weiner. On the state minimization of nondeterministic finite automata. IEEE Transactions on Computers, C-19(7):617\u2013627, 1970. doi:10.1109/T-C.1970.222994. 19 Sean Kauffman, Klaus Havelund, and Sebastian Fischmeister. Monitorability over unreliable channels. In Bernd Finkbeiner and Leonardo Mariani, editors, Runtime Verification - 19th International Conference, RV 2019, Porto, Portugal, October 8-11, 2019, Proceedings, volume 11757 of Lecture Notes in Computer Science, pages 256\u2013272. Springer, 2019. doi:10.1007/ 978-3-030-32079-9\\_15. 20 Martin Korp, Christian Sternagel, Harald Zankl, and Aart Middeldorp. Tyrolean termination tool 2. In Ralf Treinen, editor, Rewriting Techniques and Applications, pages 295\u2013304, Berlin, Heidelberg, 2009. Springer Berlin Heidelberg. 21 Giorgia Lallai, Andrea Pinna, Michele Marchesi, and Roberto Tonelli. Software engineering for dapp smart contracts managing workers contracts. 03 2020. 22 Ernst Leiss. Succinct representation of regular languages by boolean automata. Theoretical Computer Science, 13(3):323\u2013330, 1981. doi:10.1016/S0304-3975(81)80005-9. 23 P. Madhusudan and B. Meenakshi. Beyond message sequence graphs. In Ramesh Hariharan, Madhavan Mukund, and V. Vinay, editors, FST TCS 2001: Foundations of Software Technology and Theoretical Computer Science, 21st Conference, Bangalore, India, December 13-15, 2001, Proceedings, volume 2245 of Lecture Notes in Computer Science, pages 256\u2013267. Springer, 2001. doi:10.1007/3-540-45294-X\\_22. 24 Erwan Mahe. An operational semantics of interactions for verifying partially observed executions of distributed systems. Theses, Universit\u00e9 Paris-Saclay, July 2021. URL: https://theses.hal.science/tel-03369906. 25 Erwan Mahe. Hibou tool. github.com/erwanM974/hibou_label, 2022. 26 Erwan Mahe. Autour toolbox. github.com/erwanM974/autour_core, 2023. 27 Erwan Mahe. experiments with generated nfa trace analysis. github.com/erwanM974/hibou_ nfa_trace_analysis, 2023. 28 Erwan Mahe. experiments with nfa generation. github.com/erwanM974/hibou_nfa_ generation, 2023. 29 Erwan Mahe. proof of convergence for interaction simplification. github.com/erwanM974/ hibou_trs_simplify_empty, 2023. 30 Erwan Mahe, Boutheina Bannour, Christophe Gaston, Arnault Lapitre, and Pascale Le Gall.\nA small-step approach to multi-trace checking against interactions. In Proceedings of the 36th Annual ACM Symposium on Applied Computing, SAC \u201921, page 1815\u20131822, New York, NY, USA, 2021. Association for Computing Machinery. doi:10.1145/3412841.3442054.\n31 Erwan Mahe, Christophe Gaston, and Pascale Le Gall. Revisiting semantics of interactions for trace validity analysis. In Heike Wehrheim and Jordi Cabot, editors, Fundamental Approaches to Software Engineering, pages 482\u2013501, Cham, 2020. Springer International Publishing. 32 Erwan Mahe, Christophe Gaston, and Pascale Le Gall. Equivalence of denotational and operational semantics for interaction languages. In Yamine A\u00eft Ameur and Florin Craciun, editors, Theoretical Aspects of Software Engineering - 16th International Symposium, TASE 2022, Cluj-Napoca, Romania, July 8-10, 2022, Proceedings, volume 13299 of Lecture Notes in Computer Science, pages 113\u2013130. Springer, 2022. doi:10.1007/978-3-031-10363-6\\_8. 33 Sjouke Mauw and Michel Adriaan Reniers. High-level message sequence charts. In SDL \u201997 Time for Testing, SDL, MSC and Trends - 8th International SDL Forum, Proceedings, pages 291\u2013306. Elsevier, 1997. 34 Sjouke Mauw and Michel Adriaan Reniers. Operational semantics for msc\u201996. Computer Networks, 31(17):1785\u20131799, 1999. doi:10.1016/S1389-1286(99)00060-2. 35 A.J. Mayer and L.J. Stockmeyer. The complexity of word problems - this time with interleaving. Information and Computation, 115(2):293\u2013311, 1994. URL: https://www.sciencedirect.com/ science/article/pii/S0890540184710984, doi:10.1006/inco.1994.1098.\n36 B. F. Melnikov. A new algorithm of the state-minimization for the nondeterministic finite automata. Korean Journal of Computational and Applied Mathematics, page 277\u2013290, may 1999. doi:10.1007/BF03014374. 37 Zolt\u00e1n Micskei and H\u00e9l\u00e8ne Waeselynck. The many meanings of uml 2 sequence diagrams: a survey. Software & Systems Modeling, 10(4):489\u2013514, 2011. 38 Anca Muscholl, Doron A. Peled, and Zhendong Su. Deciding properties for message sequence charts. In Maurice Nivat, editor, Foundations of Software Science and Computation Structure, First International Conference, FoSSaCS\u201998, Held as Part of the European Joint Conferences on the Theory and Practice of Software, ETAPS\u201998, Lisbon, Portugal, March 28 - April 4, 1998, Proceedings, volume 1378 of Lecture Notes in Computer Science, pages 226\u2013242. Springer, 1998. doi:10.1007/BFb0053553. 39 Gordon Plotkin. A structural approach to operational semantics. The Journal of Logic and Algebraic Programming, 60-61:17\u2013139, 07 2004. doi:10.1016/j.jlap.2004.05.001. 40 Libor Polak. Minimalizations of nfa using the universal automaton. In Proceedings of the 9th International Conference on Implementation and Application of Automata, CIAA\u201904, page 325\u2013326, Berlin, Heidelberg, 2004. Springer-Verlag. doi:10.1007/978-3-540-30500-2\\_37. 41 Grigore Ro\u015fu and Mahesh Viswanathan. Testing extended regular language membership incrementally by rewriting. In Robert Nieuwenhuis, editor, Rewriting Techniques and Applications, pages 499\u2013514, Berlin, Heidelberg, 2003. Springer Berlin Heidelberg. 42 Koushik Sen and Grigore Ro\u015fu. Generating optimal monitors for extended regular expressions. Electronic Notes in Theoretical Computer Science, 89(2):226\u2013245, 2003. RV \u20192003, Run-time Verification (Satellite Workshop of CAV \u201903). doi:10.1016/S1571-0661(04)81051-X. 43 Jocelyn Simmonds, Yuan Gan, Marsha Chechik, Shiva Nejati, Bill O\u2019Farrell, Elena Litani, and Julie Waterhouse. Runtime monitoring of web service conversations. IEEE Trans. Serv. Comput., 2(3):223\u2013244, 2009. doi:10.1109/TSC.2009.16. 44 Harald Zankl, Bertram Felgenhauer, and Aart Middeldorp. Csi \u2013 a confluence tool. In Nikolaj Bj\u00f8rner and Viorica Sofronie-Stokkermans, editors, Automated Deduction \u2013 CADE-23, pages 499\u2013505, Berlin, Heidelberg, 2011. Springer Berlin Heidelberg.\nA NFA generation experiments on digital locks usecases"
        },
        {
            "heading": "A.1 Comparison to minimal DFA",
            "text": "A known example for showing that an equivalent minimal DFA may have exponentially more state that the associated minimal NFA is the following: given the alphabet {a, b}, the regular expression (a|b)\u2217.a.(a|b)n can be encoded as a NFA with n + 2 states while the associated minimal DFA has 2n+1 states. This is due to the fact that this construction must keep track of the last n states.\nTaking inspiration from this let us consider the following toy usecase. We consider a door which is initially closed. It can be opened by entering a combination of A and B of the form A.A.B.#.#.# i.e. the code is AAB followed by any three characters. In order to open the door we may therefore enter any word of the regular language (A|B)\u2217.A.A.B.(A|B)3.\nIn order to encode this specification as an interaction, we consider the door to be a lifeline called door which can receive A and B messages as inputs and, once it is unlocked, it emits\nmessage unlock. This interaction is drawn on the left column of Fig.10. Using interaction execution with term simplification to explore its semantic with memoization of previously encountered terms we obtain the NFA nfas(i) drawn in the middle column of Fig.10. This NFA turns out to be the minimal NFA which can express this language. As expected, if we determinize it and then minimize the resulting DFA we get a FA with more states (here 14 states instead of 8). This DFA is given on the right column of Fig.10.\nAs a distributed/concurrent system, this usecase can be described as a single door having inputs and outputs. More complex structure of linked doors can be formed, with the unlocking of a door allowing another one to be opened and so on. The left of Fig.11 describes one such system with 4 locks. Opening the first one allows trying to enter the codes for the 2 following doors. Then, we need to open these two doors to start trying to open the final\ndoor. On the right of Fig.11 the generated NFA corresponding to this specification is given.\nFig.12 illustrates our second network example, which involves 8 locks. The generated NFA, which is not drawn for a lack of space, has 2881 states.\nA.2 Comparison with compositional approach\nWe also compare the NFA generated using our method with NFA obtained using a compositional method. Fig.13 represents the NFA generated using both methods for our example with 1 lock. While nfas(i) has 8 states, compo(i) has 13 states. We can remark that compo(i) has less states than an equivalent minimal DFA (14 states as seen on Fig.10) but still more than nfas(i) which has the same number of states (8) as the equivalent minimal NFA.\nFig.14 likewise represents nfas(i) and compo(i) for the example network with 4 locks. While the former has 97 states, the latter has 223 states.\nB Trace analysis experiments\nIn the following we consider several usecases. Each usecase is modelled by an interaction which specifies its set of accepted behaviors.\nUsing the trace generation feature of HIBOU [25] we generate three datasets of traces, one for each example usecase.\nEach dataset consists of: a set of accepted prefixes a set of error traces obtained by adding random actions at the end of accepted traces\nWe then analyze these traces against the specifying interaction using two methods: the trace analysis algorithm from [31] which directly analyze traces against interactions via the execution relation \u2192 a simple NFA word analysis technique applied to the NFA generated using nfas\nWe compare the results of analyzing the traces using both methods and make sure that: for the accepted prefixes, both methods return a Pass for the error traces, both methods return a Fail\nB.1 The Platoon [3] usecase\nThe interaction on the left of Fig.15 describes the Platoon [3] usecase. It consists of three self-driving rovers that drive in formation. The NFA generated from this interaction is drawn on the right of Fig.15.\nFig.16 plots the results of trace analysis for the accepted prefixes and Fig.17 for the error traces. In these plots, each point corresponds to a given trace. Its position corresponds to the time taken to analyze it (on the y axis), and its length i.e. total number of actions (on the x axis, with some jitter added to better see distinct points). The time on the y axis is given on a logarithmic scale. The color represents the method used, blue for interaction global trace analysis and green for nfa word analysis.\nB.2 Human Resources [21] usecase\nSimilarly, while Fig.18 describes the expected behaviors of the Human Resources [21] usecase, experimental results for trace analysis are given on Fig.19 (for accepted traces) and Fig.20 (for error traces).\nB.3 Alternating Bit Protocol [33] usecase\nFinally the Alternating Bit Protocol [33] usecase is described on Fig.21. Fig.22 and Fig.23 resp. present experimental results for the accepted traces and error traces."
        }
    ],
    "title": "A Term-based Approach for Generating Finite Automata from Interaction Diagrams",
    "year": 2023
}