{
    "abstractText": "In this paper, we prove that a linear block code with girth 2(t+1) is a t-sequential-recovery locally repairable codes (LRCs) with locality r if its parity-check matrix has column weight at least 2 and row weight at most r+1. This gives a new connection between sequential-recovery LRCs and linear block codes. We also derive that the repair time of the t-sequential-recovery LRCs from the linear block codes by this connection is at most dt/2e. INDEX TERMS Locally repairable codes, joint sequential-parallel-recovery, girth, repair time.",
    "authors": [
        {
            "affiliations": [],
            "name": "ZHI JING"
        },
        {
            "affiliations": [],
            "name": "HONG-YEOP SONG"
        },
        {
            "affiliations": [],
            "name": "Hong-Yeop SONG"
        }
    ],
    "id": "SP:70fb69e97a0c7c9c3bcf5d723b43134fb5a44600",
    "references": [
        {
            "authors": [
                "F. Amirzade",
                "M. Sadeghi"
            ],
            "title": "Lower Bounds on the Lifting Degree of QC-LDPC Codes by Difference Matrices",
            "venue": "IEEE Access, vol. 6, pp. 23688- 23700, 2018.",
            "year": 2018
        },
        {
            "authors": [
                "S.B. Balaji",
                "G.R. Kini",
                "P.V. Kumar"
            ],
            "title": "A tight rate bound and matching construction for locally recoverable codes with sequential recovery from any number of multiple erasures",
            "venue": "IEEE Trans. Inf. Theory, vol. 66, no. 2, pp. 1023-1052, Feb., 2020.",
            "year": 2020
        },
        {
            "authors": [
                "T. Etzion",
                "A. Trachtenberg",
                "A. Vardy"
            ],
            "title": "Which codes have cycle-free Tanner graphs?",
            "venue": "IEEE Trans Inf. Theory, vol. 45,",
            "year": 1999
        },
        {
            "authors": [
                "P. Gopalan",
                "C. Huang",
                "H. Simitci",
                "S. Yekhanin"
            ],
            "title": "On the locality of codeword symbols",
            "venue": "IEEE Trans. Inf. Theory, vol. 58, no. 11, pp. 6925- 6934, Nov. 2012.",
            "year": 2012
        },
        {
            "authors": [
                "M. Gholami",
                "M. Samadieh",
                "G. Raeisi"
            ],
            "title": "Column-weight three QC LDPC codes with girth 20",
            "venue": "IEEE Commun. Lett., vol. 17, no. 7, pp. 1439- 1442, Jul., 2013.",
            "year": 2013
        },
        {
            "authors": [
                "J. Hao",
                "S.-T. Xia"
            ],
            "title": "Constructions of optimal binary locally repairable codes with multiple repair groups",
            "venue": "IEEE Commun. Lett., vol. 20, no. 6, pp. 1060-1063, Jun., 2016.",
            "year": 2016
        },
        {
            "authors": [
                "P. Huang",
                "E. Yaakobi",
                "H. Uchikawa",
                "P.H. Siegel"
            ],
            "title": "Linear locally repairable codes with availability",
            "venue": "Proc. IEEE ISIT, Hong Kong, 2015, pp. 1871-1875.",
            "year": 2015
        },
        {
            "authors": [
                "X. Jiang",
                "H. Hai",
                "H. Wang",
                "M.H. Lee"
            ],
            "title": "Constructing Large Girth QC Protograph LDPC Codes Based on PSD-PEG Algorithm",
            "venue": "IEEE Access, vol. 5, pp. 13489-13500, 2017.",
            "year": 2017
        },
        {
            "authors": [
                "J. Fan"
            ],
            "title": "Array codes as LDPC codes",
            "venue": "Proc. 2nd Int. Symp. Turbo Codes, Brest, France, 2001, pp. 543\u2013546.",
            "year": 2001
        },
        {
            "authors": [
                "Z. Jing",
                "H.-Y. Song"
            ],
            "title": "Some new sequential-recovery LRCs based on good polynomials",
            "venue": "IEEE Access, vol. 10, pp. 42844-42850, 2022.",
            "year": 2022
        },
        {
            "authors": [
                "Z. Jing",
                "H.-Y. Song"
            ],
            "title": "Almost-parallel-recovery LRCs with blockdiagonal parity-check matrices",
            "venue": "Finite Fields and Their Applications, submitted, 2022.",
            "year": 2022
        },
        {
            "authors": [
                "I. Kim",
                "T. Kojima",
                "H.-Y. Song"
            ],
            "title": "Some short-length girth-8 QC-LDPC codes from primes of the form t2 + 1",
            "venue": "IEEE Commun. Lett., vol. 26, no. 6, pp. 1211-1215, June 2022.",
            "year": 2022
        },
        {
            "authors": [
                "I. Kim",
                "H.-Y. Song"
            ],
            "title": "Some new constructions of girth-8 QC-LDPC codes for future GNSS",
            "venue": "IEEE Commun. Lett., vol. 25, no. 12, pp. 3780- 3784, Dec., 2021.",
            "year": 2021
        },
        {
            "authors": [
                "I. Kim",
                "H.-Y. Song"
            ],
            "title": "A construction for girth-8 QC-LDPC codes using Golomb rulers",
            "venue": "Electronics Lett., accepted, 2022.",
            "year": 2022
        },
        {
            "authors": [
                "D.J.C. MacKay"
            ],
            "title": "Good error-correcting codes based on very sparse matrices",
            "venue": "IEEE Trans. Inf. Theory, vol. 45, no.2, pp. 399-431, Feb., 1999.",
            "year": 1999
        },
        {
            "authors": [
                "S. Naseri",
                "A.H. Banihashemi"
            ],
            "title": "Construction of time invariant spatially coupled LDPC codes free of small trapping sets",
            "venue": "IEEE Trans. Commun., vol. 69, no. 6, pp. 3485-3501, Jun., 2021.",
            "year": 2021
        },
        {
            "authors": [
                "N. Prakash",
                "G.M. Kamath",
                "V. Lalitha",
                "P.V. Kumar"
            ],
            "title": "Optimal linear codes with a local-error-correction property",
            "venue": "Proc. IEEE ISIT, Cambridge, USA, 2012, pp. 2776-2780.",
            "year": 2012
        },
        {
            "authors": [
                "N. Prakash",
                "V. Lalitha",
                "S.B. Balaji",
                "P.V. Kumar"
            ],
            "title": "Codes with locality for two erasures",
            "venue": "IEEE Trans. Inf. Theory, vol. 65, no. 12, pp. 7771-7789, Dec., 2019.",
            "year": 2019
        },
        {
            "authors": [
                "W. Song",
                "K. Cai",
                "C. Yuen",
                "K. Cai",
                "G. Han"
            ],
            "title": "On sequential locally repairable codes",
            "venue": "IEEE Trans. Inf. Theory, vol. 64, no. 5, pp. 3513-3527, May, 2018.",
            "year": 2018
        },
        {
            "authors": [
                "W. Song",
                "C. Yuen"
            ],
            "title": "Locally repairable codes with functional repair and multiple erasure tolerance",
            "venue": "arXiv preprint arXiv:1507.02796, 2015.",
            "year": 2015
        },
        {
            "authors": [
                "A. Tasdighi",
                "A.H. Banihashemi",
                "M.-R. Sadeghi"
            ],
            "title": "Efficient search of girth-optimal QC-LDPC codes",
            "venue": "IEEE Trans. Inf. Theory, vol. 62, no. 4, pp. 1552-1564, Apr., 2016.",
            "year": 2016
        },
        {
            "authors": [
                "A. Wang",
                "Z. Zhang"
            ],
            "title": "Repair locality with multiple erasure tolerance",
            "venue": "IEEE Trans. Inf. Theory, vol. 60, no. 11, pp. 6979-6987, Nov., 2014.",
            "year": 2014
        },
        {
            "authors": [
                "E. Yavari",
                "M. Esmaeili"
            ],
            "title": "Locally Repairable Codes: Joint Sequential\u2013Parallel Repair for Multiple Node Failures",
            "venue": "IEEE Trans. Inf. Theory, vol. 66, no. 1, pp. 222-232, Jan. 2020.",
            "year": 2020
        },
        {
            "authors": [
                "S. Zhao",
                "X. Huang",
                "X. Ma"
            ],
            "title": "Structural Analysis of Array-Based Non- Binary LDPC Codes",
            "venue": "IEEE Trans. Commun., vol. 64, no. 12, pp. 4910- 4922, Dec. 2016.",
            "year": 2016
        }
    ],
    "sections": [
        {
            "text": "INDEX TERMS Locally repairable codes, joint sequential-parallel-recovery, girth, repair time.\nI. INTRODUCTION As an erasure-correcting code, the locally repairable codes (LRCs) [4] was proposed to improve the repair efficiency, which needs only a few nodes to repair any erasure. For an erasure, its locality is the number of other symbols needed to repair it, which is the key concept of LRCs. A linear code is an LRC with locality r if each symbol is locally repaired by at most r other symbols [4].\nVarious LRCs for multiple erasures were proposed [17], [18], [22]. These LRCs are divided into sequential- and parallel-recovery LRCs based on whether the repair process is either sequential or parallel. Let C be a linear code of length n and c = (c1, c2, . . . , cn) be a codeword of C. The code C is said to be a t-sequential-recovery (t-seq) LRC if, for any s \u2264 t erasures, there exists an arrangement (j1, j2, . . . , js) of s erasure positions such that for each u = 1, 2, . . . , s, there exists a subset R(ju) \u2282 {1, 2, . . . , n}\\{ju} satisfying\n1) |R(ju)| \u2264 r, 2) R(ju) \u2229 {ju, ju+1, . . . , js} = \u2205, and 3) cju = \u2211 l\u2208R(ju) alcl, for some al \u2208 Fq .\nRecently, several constructions of binary and non-binary tseq LRCs have been proposed by various techniques, such as good polynomial [10], graph [18], configuration [19], [20] and designing the parity-check matrix [2], [11], [18]. The binary codes is implemented easily and provides a lower complexity [2], [18]\u2013[20], whereas the non-binary codes provides a larger minimum distance [10], [11], [18].\nRepair time is another metric for t-seq LRCs, which is the maximum number of steps that are needed to repair any\nt erasures [23]. Obviously, the repair time of t-seq LRCs is at most t and it is indeed t in general. To reduce the repair time, the LRC with joint sequential-parallel-recovery is proposed for any t erasures [23], where some u(\u2264 t) erasures can be repaired locally and parallelly. So, its repair time is at most t \u2212 u + 1. Note that a t-para LRC has the repair time 1 for any t.\nLet C be a linear block (or low-density parity-check) code with a parity-check matrix H = (hi,j , i = 1, 2, . . . ,m; j = 1, 2, . . . , n). H can be represented as a Tanner graph with m check nodes and n variable nodes [15]. The ith check node and the jth variable node are connected if the element hi,j is non-zero. In the Tanner graph, the length of all cycles is even and greater than or equal to four [3]. The girth is the length of the shortest cycle in its Tanner graph. The girth is an important issue for low-density parity-check (LDPC) codes, since it heavily affects its performance with sumproduct decoding [5]. A lot of constructions for LDPC codes with a large girth were proposed [1], [5], [8], [9], [12]\u2013[14], [21], [24], [25]. A cycle of length 2s can be seen in the corresponding matrix when the graph has a cycle of length 2s. The patterns of 4-cycle and 6-cycle in the matrix are summarized as shown in Fig. 1 [13], [16].\nSome connections between parallel-recovery LRCs and regular LDPC codes were proposed [6], [7]. An LDPC code is called regular with (\u03c4, \u03c1) if its parity-check matrix has constant column weight \u03c4 and constant row weight \u03c1. The 4- cycle free regular (\u03c4, \u03c1)-LDPC code is shown to be an LRC with all-symbol availability (\u03c1\u2212 1, \u03c4) [7]. An optimal LRC with information-symbol availability (\u03c1, \u03c4) was proposed from the 4-cycle free regular (\u03c4, \u03c1)-LDPC code [6]."
        },
        {
            "heading": "2 VOLUME 4, 2016",
            "text": "This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nJing and Song: Girth-based sequential-recovery LRCs\nFIGURE 1. Patterns of 4-cycle and 6-cycle\nConsider the definition of the sequential-recovery LRCs from the viewpoint of the parity-check matrix. The linear code C is a t-seq LRC if, for any s \u2264 t erasures, there exists a row of its parity-check matrix whose support contains the coordinate of precisely one of the s erasures. Therefore, we want to know what is the form of the parity-check matrix that satisfies the above condition of the t-seq LRCs.\nOur contribution: In this paper, we prove two theorems for sequential-recovery LRCs as follows.\nTheorem 1 A linear block code is a t-seq LRC with locality r if its parity-check matrix satisfies the following:\n1) the girth is 2(t+ 1), 2) the column weight is at least 2, and 3) the row weight is at most r + 1.\nTheorem 2 The repair time of the t-seq LRCs from Theorem 1 is at most dt/2e.\nThe t-seq LRCs from the linear block by Theorem 1 has two advantages. One is that both the parameters t and r of the LRCs from Theorem 1 apply to any positive integer. The other is that t-seq LRCs from Theorem 1 has a small repair time compared to some other known t-seq LRCs as shown in Table 1. In general, the performance of LRCs is considered in terms of repair efficiency r, local repair capacity t, and repair time, which is different from those of other errorcorrecting codes [23]. These three metrics have been fully discussed. So, the various t-seq LRCs can be obtained from the parity-check matrix with different girth, column weight and row weight.\nSection II shows the proof of Theorem 1. Section III calculates the repair time of the t-seq LRCs from the linear block code by Theorem 1. Section IV concludes the paper.\nII. RELATIONSHIP BETWEEN T -SEQ LRCS AND GIRTH The support of a vector u = (u1, u2, . . . , un) is defined as supp(u) = {i | ui 6= 0}, and w(u) = |supp(u)| is the weight of u. A matrix M = (mi,j , i = 1, 2, . . . ,m; j = 1, 2, . . . , n) is represented as a Tanner graph (bipartite) with m row nodes r1, r2, . . . , rm on one side and n column nodes c1, c2, . . . , cn on the other side. In this graph, nodes ri and\ncj are connected if mi,j 6= 0. Figure 2 shows two matrices and their corresponding Tanner graphs.\nWe will consider the connectivity of columns of a matrix as follows. Two columns of a matrix are said to be connected if the corresponding column nodes are connected by a path in its Tanner graph. A matrix is said to be connected if every pair of columns of M are connected. Figure 2 shows two matrices which are connected in (a) and non-connected in (b). Observed that the second column in (b) is not connected to the remaining columns. Note that a path does not have to be a cycle. Therefore, a connected matrix M has a property that there exists a rearrangement of all columns such that the intersection of the supports of any two adjacent columns is non-empty. For example, the columns of H1 in Fig.2 can be reordered (second and fifth are swapped) so that any two adjacent columns are connected.\nNext, for a connected matrix, we give a sufficient condition for the existence of a cycle.\nProposition 1 Let m and s be positive integers. Let M be a connected matrix of size m \u00d7 s whose columns all have weight at least 2. Let h be a column of length m and weight at least 2. Then, the augmented matrix (M | h) has a cycle of length \u2264 2(s+1) if |I1(M)\u2229supp(h)| \u2265 2, where I1(M) is the set of row indices of M whose row weight is 1.\nProof: Since M is a connected matrix, without loss of generality, we may assume that all the adjacent columns of M are connected. That is, if we use h1,h2, . . . ,hs to denote the columns of M , then\nsupp(hi) \u2229 supp(hi+1) 6= \u2205,\nfor 1 \u2264 i < s. We denote by bi the ith row of M , i = 1, 2, . . . ,m. Since |I1(M)\u2229supp(h)| \u2265 2, we may let u and v be two elements of this intersection. Then,\nsupp(bu) = {\u03b1} and supp(bv) = {\u03b2},\nVOLUME 4, 2016 3\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nJing and Song: Girth-based sequential-recovery LRCs\nfor some \u03b1, \u03b2. Without loss of generality again, we may assume that 1 \u2264 \u03b1 \u2264 \u03b2 \u2264 s. If \u03b1 = \u03b2, then the augmented matrix (M | h) has a 4-cycle. Otherwise, a cycle is constructed by columns\nh\u03b1,h\u03b1+1, . . . ,h\u03b2 ,h,\nand the length is 2 [(\u03b2 \u2212 \u03b1+ 1) + 1] \u2264 2(s + 1). We note that the equality is achieved when \u03b1 = 1 and \u03b2 = s.\nLemma 1 Let C be a linear block code of length n and girth 2(t + 1). Let H be its parity-check matrix of size m \u00d7 n, whose column weight is at least 2. Let E be an s-subset of {1, 2, . . . , n}, for 1 \u2264 s \u2264 t, and H(E) be the corresponding submatrix containing only the columns indexed by E. Then, the corresponding submatrix H(E) has at least two rows whose weight is 1.\nProof: Let hj be the jth column of H , for j = 1, 2, . . . , n. For any subset E, we denote by I1(E) the set of row indices of the corresponding submatrix H(E) whose row weight is 1:\nI1(E) , {i | w(bi) = 1, i = 1, 2, . . . ,m}, (1)\nwhere bi is the ith row of H(E). That is to say, we will claim that, for any nonempty subset E of size \u2264 t,\n|I1(E)| \u2265 2.\nThe proof will be distinguished in two cases: 1) H(E) is a connected matrix and 2) H(E) is a non-connected matrix.\nFirst, Case 1) is proved by induction on the size of E. When |E| = s = 1, it is obvious that |I1(E)| \u2265 2 since the column weight of H is at least 2. When 2 \u2264 s \u2264 t, the s-subset E is divided as follows.\nE = E\u2032 \u222a {\u03b4}.\nwhere E\u2032 is an (s \u2212 1)-subset. Assume the induction hypothesis that, |I1(E\u2032)| \u2265 2 for any (s \u2212 1)-subset E\u2032. The number of rows in H(E) whose weight is 1 can be counted as follows.\nI1(E)= ( I1(E \u2032)\\supp(h\u03b4) ) \u222a ( supp(h\u03b4)\\I>0(E\u2032) ) , (2)\nwhere\nI>0(E \u2032) , {i | w(b\u2032i) > 0, i = 1, 2, . . . ,m},\nand b\u2032i is the i th row of H(E\u2032). To count the size of I1(E), we classify the relation between I1(E\u2032) and h\u03b4 into the following three subcases:\ni) |I1(E\u2032) \u2229 supp(h\u03b4)| = 0, ii) |I1(E\u2032) \u2229 supp(h\u03b4)| = 1,\niii) |I1(E\u2032) \u2229 supp(h\u03b4)| \u2265 2. For Subcase i), we can get that, based on (2)\n|I1(E)| \u2265 |I1(E\u2032) \\ supp(h\u03b4)| = |I1(E\u2032)| \u2265 2,\nsince |I1(E\u2032)| \u2265 2 by induction hypothesis.\nFor Subcase ii), let I1(E\u2032) \u2229 supp(h\u03b4) = {u}. If\n{u} = I>0(E\u2032) \u2229 supp(h\u03b4),\nthen we can get that\n|I1(E)| = |I1(E\u2032) \\ {u}|+ |supp(h\u03b4) \\ {u}| \u2265 1 + 1 = 2.\nsince |I1(E\u2032)| \u2265 2 by induction hypothesis and w(h\u03b1) \u2265 2. If {u} \u2282 ( I>0(E \u2032) \u2229 supp(h\u03b4) ) ,\nthen H(E) has a cycle of length \u2264 2s, which is similar to the proof of Proposition 1. It contradicts the code with girth 2(t+ 1).\nFor Subcase iii), it is impossible since H(E) = (H(E\u2032) | h\u03b4) has a cycle of length \u2264 2s by Proposition 1, which contradicts the code with girth 2(t+ 1).\nNext, we consider Case 2). H(E) is a non-connected matrix with \u03c4 connected submatrices H(E1), . . . , H(E\u03c4 ) such that( \u22c3\n\u03b1\u2208Ei\nsupp(h\u03b1) )\u22c2 \u22c3 \u03b2\u2208Ej supp(h\u03b2)  = \u2205, (3) for 1 \u2264 i < j \u2264 \u03c4 . It is obvious that\n|I1(E)| = |I1(E1)|+|I1(E2)|+\u00b7 \u00b7 \u00b7+|I1(E\u03c4 )| \u2265 2\u03c4 > 2.\nNow, we will continue to prove Theorem 1. Let C be a linear block code of length n. Let H = (hi,j , i = 1, 2, . . . ,m; j = 1, 2, . . . , n) be its parity-check matrix, whose column weights are at least 2 and row weights are at most r+1. Then, any s \u2264 t erasures can be repaired locally and sequentially by the following algorithm. For readability, we first give some notations as follows: \u2022 c = (c1, c2, . . . , cn) is a codeword of C; \u2022 ai is the ith row of H for i = 1, 2, . . . ,m; \u2022 E is the index set of erasures; \u2022 H(E) is the corresponding erasure submatrix of H\ncontaining only the columns indexed by E; \u2022 bi is the ith row of H(E) for i = 1, 2, . . . ,m.\nAlgorithm 1 The repair process of s \u2264 t erasures 1: Input E 2: while E 6= \u2205 do 3: Set a row index set I such that\nI = {i | w(bi) = 1, i = 1, 2, . . . ,m}\n4: Set a column index set J such that J = \u22c3 i\u2208I supp(bi)\n5: For each u \u2208 J , cu = \u2212 \u2211 \u03b3\u2208supp(al)\\{u} hl,\u03b3c\u03b3 ,\nwhere l is a row index such that supp(bl) = {u}. 6: E = E \\ J 7: end while"
        },
        {
            "heading": "4 VOLUME 4, 2016",
            "text": "This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nJing and Song: Girth-based sequential-recovery LRCs\nThe size of I in Line 3 is at least 2 as long as E 6= \u2205 by Lemma 1. Clearly, J in Line 4 is also a non-empty set because I is a non-empty set. So, the program can be run until E becomes empty. It means that all s erasures are repaired.\nIn Line 5, for each u \u2208 J , such row index l exists since the elements of J are only from the support of rows whose weight is 1. Since supp(bl) = {u}, the erased symbol cu is repaired by |supp(al) \\ {u}| \u2264 r symbols, which are either unerased symbols or repaired erasures.\nExample 1 A binary 3-seq LRC is constructed by the following parity-check matrix H with girth 8.\nH =  1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 1  Assume c1, c2, c4 are erased, and defined by e1, e2, e4. Set E = {1, 2, 4}.\nStep 1: For H(E), we can get that I = {2, 5} and\nJ = supp(b2) \u222a supp(b5) = {4, 2}.\nThen, the erasure e4 and e2 are locally repaired by the second and fifth row of H , respectively.\ne4 = c5 + c6 and e2 = c5 + c8.\nSet E = {1}. Step 2: The erasure e1 can be locally repaired by the first or the forth row of H .\nRemark 1 The array-based LDPC codes was proposed in [9], [24]. They have girth \u2265 6 and are regular with (\u03b3, p), where \u03b3 = 2, 3 and p \u2265 \u03b3. Therefore, these LDPC codes are 2-seq LRCs with locality p\u2212 1.\nRemark 2 Recently, an irregular girth-8 type-II LDPC codes of length 2mKP was proposed in [13], for any integers m \u2265 3, P > 6 and K \u2265 1. For its mKP \u00d72mKP parity-check matrix, the weight of the first mKP columns is 2 and the last mKP columns is m+1, and the row weight is the constant m+3. Therefore, this LDPC code is a 3-seq LRC with locality m+ 2.\nExample 2 We assume the same m,K and P as in Remark 2, which are the parameters about the code length. Let m = 3, K = 1 and P = 70. A type-II LDPC code C of length 420, target rate 12 and girth 8 is constructed by the following parity-check matrix:\nH =\n( I(2) I(9) 0 I(17) + I(22) I(26) I(31)\n0 I(18) I(34) I(44) I(4) + I(52) I(62)\nI(6) 0 I(51) I(66) I(8) I(27) + I(23)\n) ,\nwhere I(j) is the 70 \u00d7 70 identity matrix with columns cyclically shifted to the right by j positions and 0 is the\nall-zero matrix of size 70 \u00d7 70. The LDPC code C is a 3-seq LRC with locality 5 according to Theorem 1 of this paper."
        },
        {
            "heading": "III. REPAIR TIME OF THE LRCS FROM THEOREM 1",
            "text": "Next, we will show that, in each loop of Algorithm 1, at least 2 erasures can be repaired parallelly when the number of erasures is at least 2.\nLemma 2 Let C be a linear block code of length n and girth 2(t + 1). Let H be its parity-check matrix of size m\u00d7 n, whose column weight is at least 2. Let E be an ssubset of the column indices, for 2 \u2264 s \u2264 t, and H(E) be the corresponding submatrix containing only the columns indexed by E. There exist two rows of H(E) such that both weights are 1 and the supports of those two rows are disjoint.\nProof: Let hj is the jth column of H for j = 1, 2, . . . , n. Let bi be the ith row of H(E) for i = 1, 2, . . . ,m. For any subset E, I1(E) is defined as (1). The proof will be distinguished in two cases: 1) H(E) is a connected matrix and 2) H(E) is a non-connected matrix.\nFor Case 1), from the proof of Lemma 1, the s-subset E is divided as\nE = E\u2032 \u222a {\u03b4},\nwhen 2 \u2264 s \u2264 t. For C with girth 2(t + 1), the possible relation between E\u2032 and h\u03b4 is given as follows:\ni) |I1(E\u2032) \u2229 supp(h\u03b4)| = 0, ii) |I1(E\u2032) \u2229 supp(h\u03b4)| = |I>0(E\u2032) \u2229 supp(h\u03b4)| = 1.\nFor each relation, there exists a row index\nu \u2208 I1(E\u2032)\nsuch that supp(bu) = {l} \u2282 E\u2032, since |I1(E\u2032)| \u2265 2. There exists another row index\nv /\u2208 I>0(E\u2032)\nsuch that supp(bv) = {\u03b4}, since w(h\u03b4) \u2265 2. Therefore, such two rows exist in the connected matrix H(E), for 2 \u2264 |E| \u2264 t.\nFor Case 2), H(E) is a non-connected matrix with \u03c4 connected submatrices H(E1), . . . ,H(E\u03c4 ) such that (3). Let \u03b1l be a row index of I1(El), for 1 \u2264 l \u2264 \u03c4 . It is obvious that the supports of those \u03c4 rows of H(E) indexed by \u03b1l are disjoint.\nNow, we will continue to prove Theorem 2. For the tseq LRCs from Theorem 1, any t erasures are repaired by Algorithm 1. When |E| \u2265 2, there exist at least 2 rows indexed by I such that the supports of those two rows are disjoint by Lemma 2. So, at least two erasures can be locally repaired in each loop when the number of unrepaired erasures is larger than one. Therefore, any t erasures can be repaired in at most dt/2e loops.\nWe compare the repair time of the t-seq LRCs from Theorem 1 with those constructed by others in Table 1. The\nVOLUME 4, 2016 5\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nJing and Song: Girth-based sequential-recovery LRCs\nfirst three codes in Table 1 are the general t-seq LRCs, and t erasures are locally repaired one by one. The last two codes are LRCs with joint sequential-parallel recovery, which have a smaller repair time than the general t-seq LRCs. For the t-seq LRCs from Theorem 1, each loop can repair at least 2 erasures locally and parallelly when there is more than one unrepaired erasure.\nIV. CONCLUDING REMARK In this paper, we propose a new connection between the sequential-recovery LRCs and the girth of linear block codes. A linear block code with girth 2(t+1) is a t-seq LRC if its parity-check matrix has column weight at least 2. It is noted that the other direction is invalid. Let H \u2032 be a new matrix by adding an additional row under H in Example 1 as follows.\nH \u2032 =  1 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 0 0 1  It is obvious that the corresponding code of H \u2032 is also 3-seq LRCs. We can get a 6-cycle in H \u2032 by connecting the 1s that have the underline.\nWe also show that for the t-seq LRCs from Theorem 1, any s \u2264 t erasures are locally repaired in joint sequentialparallel mode. At least 2 erasures are repaired locally and parallelly in each step of the repair process, when the number of the unrepaird erasures is at least 2.\nREFERENCES [1] F. Amirzade and M. Sadeghi, \u201cLower Bounds on the Lifting Degree of\nQC-LDPC Codes by Difference Matrices,\u201d IEEE Access, vol. 6, pp. 23688- 23700, 2018. [2] S. B. Balaji, G. R. Kini, and P. V. Kumar, \u201cA tight rate bound and matching construction for locally recoverable codes with sequential recovery from any number of multiple erasures,\u201d IEEE Trans. Inf. Theory, vol. 66, no. 2, pp. 1023-1052, Feb., 2020.\n[3] T. Etzion, A. Trachtenberg and A. Vardy, \u201cWhich codes have cycle-free Tanner graphs?\u201d IEEE Trans Inf. Theory, vol. 45, no. 6, pp. 2173-2181, Sep. 1999. [4] P. Gopalan, C. Huang, H. Simitci, and S. Yekhanin, \u201cOn the locality of codeword symbols,\u201d IEEE Trans. Inf. Theory, vol. 58, no. 11, pp. 6925- 6934, Nov. 2012. [5] M. Gholami, M. Samadieh, and G. Raeisi, \u201cColumn-weight three QC LDPC codes with girth 20,\u201d IEEE Commun. Lett., vol. 17, no. 7, pp. 1439- 1442, Jul., 2013. [6] J. Hao and S.-T. Xia, \u201cConstructions of optimal binary locally repairable codes with multiple repair groups,\u201d IEEE Commun. Lett., vol. 20, no. 6, pp. 1060-1063, Jun., 2016. [7] P. Huang, E. Yaakobi, H. Uchikawa, and P. H. Siegel, \u201cLinear locally repairable codes with availability,\u201d in Proc. IEEE ISIT, Hong Kong, 2015, pp. 1871-1875. [8] X. Jiang, H. Hai, H. Wang and M. H. Lee, \u201cConstructing Large Girth QC Protograph LDPC Codes Based on PSD-PEG Algorithm,\u201d IEEE Access, vol. 5, pp. 13489-13500, 2017. [9] J. Fan, \u201cArray codes as LDPC codes,\u201d in Proc. 2nd Int. Symp. Turbo Codes, Brest, France, 2001, pp. 543\u2013546. [10] Z. Jing and H.-Y. Song, \u201cSome new sequential-recovery LRCs based on good polynomials,\u201d IEEE Access, vol. 10, pp. 42844-42850, 2022. [11] Z. Jing and H.-Y. Song, \u201cAlmost-parallel-recovery LRCs with blockdiagonal parity-check matrices,\u201d Finite Fields and Their Applications, submitted, 2022. [12] I. Kim, T. Kojima and H.-Y. Song, \u201cSome short-length girth-8 QC-LDPC codes from primes of the form t2 + 1,\u201d IEEE Commun. Lett., vol. 26, no. 6, pp. 1211-1215, June 2022. [13] I. Kim and H.-Y. Song, \u201cSome new constructions of girth-8 QC-LDPC codes for future GNSS,\u201d IEEE Commun. Lett., vol. 25, no. 12, pp. 3780- 3784, Dec., 2021. [14] I. Kim and H.-Y. Song, \u201cA construction for girth-8 QC-LDPC codes using Golomb rulers,\u201d Electronics Lett., accepted, 2022. [15] D. J. C. MacKay, \u201cGood error-correcting codes based on very sparse matrices,\u201d IEEE Trans. Inf. Theory, vol. 45, no.2, pp. 399-431, Feb., 1999. [16] S. Naseri and A. H. Banihashemi, \u201cConstruction of time invariant spatially coupled LDPC codes free of small trapping sets,\u201d IEEE Trans. Commun., vol. 69, no. 6, pp. 3485-3501, Jun., 2021. [17] N. Prakash, G. M. Kamath, V. Lalitha, and P. V. Kumar, \u201cOptimal linear codes with a local-error-correction property,\u201d in Proc. IEEE ISIT, Cambridge, USA, 2012, pp. 2776-2780. [18] N. Prakash, V. Lalitha, S. B. Balaji and P. V. Kumar, \u201cCodes with locality for two erasures,\u201d IEEE Trans. Inf. Theory, vol. 65, no. 12, pp. 7771-7789, Dec., 2019. [19] W. Song, K. Cai, C. Yuen, K. Cai, and G. Han, \u201cOn sequential locally repairable codes,\u201d IEEE Trans. Inf. Theory, vol. 64, no. 5, pp. 3513-3527, May, 2018. [20] W. Song and C. Yuen, \u201cLocally repairable codes with functional repair and multiple erasure tolerance,\u201d arXiv preprint arXiv:1507.02796, 2015. [21] A. Tasdighi, A. H. Banihashemi, and M.-R. Sadeghi, \u201cEfficient search of girth-optimal QC-LDPC codes,\u201d IEEE Trans. Inf. Theory, vol. 62, no. 4, pp. 1552-1564, Apr., 2016. [22] A. Wang and Z. Zhang, \u201cRepair locality with multiple erasure tolerance,\u201d IEEE Trans. Inf. Theory, vol. 60, no. 11, pp. 6979-6987, Nov., 2014. [23] E. Yavari and M. Esmaeili, \u201cLocally Repairable Codes: Joint Sequential\u2013Parallel Repair for Multiple Node Failures,\u201d IEEE Trans. Inf. Theory, vol. 66, no. 1, pp. 222-232, Jan. 2020. [24] S. Zhao, X. Huang and X. Ma, \u201cStructural Analysis of Array-Based NonBinary LDPC Codes,\u201d IEEE Trans. Commun., vol. 64, no. 12, pp. 4910- 4922, Dec. 2016. [25] G. Zhang, Y. Hu, D. Ren, Y. Liu and Y. Yang, \u201c\u2018Type-II QC-LDPC Codes From Multiplicative Subgroup of Prime Field,\u201d IEEE Access, vol. 8, pp. 142459-142467, 2020."
        },
        {
            "heading": "6 VOLUME 4, 2016",
            "text": "This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nJing and Song: Girth-based sequential-recovery LRCs\nZHI JING received her BS degree in Information Engineering from China University of Geoscience, Beijing, China, and MS degree in Information Technology Management from Hong Kong Baptist University, Hong Kong, China, in 2014 and 2015, respectively. She is currently a Ph.D candidate working in Channel Coding Lab. at Yonsei University, Seoul, Korea. Her area of research interest includes coding theory and techniques for distributed storage systems and\ndigital communications.\nHONG-YEOP SONG received his BS degree in Electronic Engineering from Yonsei University in 1984, MSEE and Ph.D degrees from the University of Southern California, Los Angeles, California, USA, in 1986 and 1991, respectively. He spent two years as a research associate at USC and then two years as a senior engineer in standard team of Qualcomm Inc., San Diego, California. Since September 1995, he has been with the Department of Electrical and Electronic\nEngineering, Yonsei University. He had been serving IEEE IT society Seoul Chapter as a chair from 2009 to 2016, and served as a general co-chair of IEEE ITW 2015 in Jeju, Korea. He was awarded the 2017 Special Contribution Award from Korean Mathematical Society for his contribution to the global wide-spread of the fact that S. J. Choi (1646- 1715) from Korea had discovered a pair of orthogonal Latin squares of order nine much earlier than Euler. His area of research interest includes digital communications and channel coding, design and analysis of various pseudo-random sequences for communications and cryptography. He is a member of IEEE, MAA(Mathematical Association of America) and domestic societies KICS, IEIE, KIISC, KMS and NAEK (National Academy of Engineering of Korea).\nVOLUME 4, 2016 7\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/"
        }
    ],
    "title": "Girth-based sequential-recovery LRCs",
    "year": 2022
}