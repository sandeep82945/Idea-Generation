{
    "abstractText": "Large scale scientific instrumentation-and-control FPGA gateware designs have numerous run-time settable parameters. These can be used either for user-level control or by automated processes (e.g., calibration). The number of such parameters in a single design can reach on the order of 1000, and keeps evolving as the gateware and its functionality evolves. One must keep track of which module the registers belong to, where the registers need to be decoded, and how to express the properties (or even semantics) of the register to the next level of user or software. Note, the registers maybe embedded anywhere throughout the module hierarchy. Purely manual handling of these tasks by HDL developers is considered burdensome and error-prone at this scale. Typically these registers are writable via an onchip bus, vaguely VME-like, that is controlled by an on-chip or off-chip CPU. There have been several attempts in the community to address this task at different levels. However, we have found no tool that is able to generate a register map, generate decoders and encoders with minimal overhead to the developer. So, here we present a tool that scours native HDL source files and looks for specific languagesupported attributes and automatically generates a register map and bus decoders, respecting multiple clock domains, and presents a JSON file to the network that maps register names to addresses.",
    "authors": [
        {
            "affiliations": [],
            "name": "Vamsi K Vytla"
        },
        {
            "affiliations": [],
            "name": "Larry Doolittle"
        }
    ],
    "id": "SP:bbc32db4e4ce379a9efcd8ae8a70ec5dbe7e8fe6",
    "references": [],
    "sections": [
        {
            "text": "ar X\niv :2\n30 5.\n09 65\n7v 1\n[ cs\n.A R\n] 1\n6 M\nay 2\n02 3\nIndex Terms\u2014Verilog; VerilogHDL; VHDL; Regsiter map; Automation; Address map; Code generation"
        },
        {
            "heading": "Overview",
            "text": "The document describes newad [3], our address map code generation tool for VerilogHDL designs. Initially, we describe the motivation for developing such a tool, followed by commenting on some design considerations and the design itself. Finally, we describe the tool in some detail, ending with a conclusion of what we think we achieved and what can be done in the future.\nIntroduction"
        },
        {
            "heading": "Motivation",
            "text": "Larger experiments demand larger register map sets. This section elaborates a few reasons of why develop a register map code generation tool.\n1. Repetitive and error prone: With the FPGA LUT count ever increasing, gateware designs today are larger than ever. This invariably leads to a large set of registers/register maps that are managed from software. When lacking automation, the developer manually tracks registers during development or maintenance cycles where new registers are created, removed, and various attributes about them are constantly changing. This process let\nThis work was presented at the 3rd Workshop on Open-Source Design Automation (OSDA) 2023,\nco-hosted with Design, Automation, and Test in Europe Conference (DATE) 2023 in Antwerp, Belgium, on April 17, 2023. For further information and material, please visit the paper\u2019s web page on the workshop website at https://osda.ws/r/ifIbv (just scan the QR code on the right). The copyright is retained by the authors. This work is licensed under the terms of the Creative Commons Attribution license (CC BY), version 4.0, see https://creativecommons.org/licenses/by/4.0. Proceedings of the 3rd Workshop on Open-Source Design Automation (OSDA), Pages 5\u20136, 2023.\n2. Bus decoder: Manually decoding several register values from a system bus (address and data lines) is a tedious task. In addition to the decoding, developer needs to decide in which module should she instantiate the decoder. This is especially tedious in an evolving design. We propose an engine that instantiates the bus decoder at a requested level at pre-compile time. The developer may optionally choose, to provide some register values as readback to the user of the design, depending on the resources available. It is preferable to manage such register decoding/encoding in an automated way. 3. Register attributes: IEEE register attributes, defined [2]. Registers have several attributes that a user is expected to be aware of such as it\u2019s size, read-only nature, bit descriptions, clock domain, a physical formula it relates to, and a human readable description (documentation). The goal is to automatically gather such attributes and present it to both the end user (in a readable format like PDF) and to other software (in a machine comprehensible format like a c-Header/JSON). 4. Documentation generation: Developers don\u2019t need to write documentation outside the source code. All modern languages and tools allow for this. Given code for registers and memory maps can be generated from source code, the documentation about them should be generated as well.\nWith the above motivation in mind, and working with VerilogHDL over the years, we have written a developer tool called newad that parses Verilog code pre-compile time, and accomplishes many of the above tasks."
        },
        {
            "heading": "Design",
            "text": "The register map automation started out of necessity as the designs were steadily increasing in size. Our initial attempt at code generation, was achieved by the developer placing \u201cmagic\u201d-comments throughout a Verilog project. newad looked for these comments and generated the necessary register map, and bus decoders. Relying on comments from source files isn\u2019t a great strategy. Knowing this we looked around for other tools that have solved the problem\nWe came across Cheby [1] developed by engineers at CERN (European Organization for Nuclear Research). Cheby works by requiring the developer to maintain a parallel file to each source file, where the registers being used in the source file are described in YAML. Cheby then source agnostically parses the register (YAML) file and is capable of generating a C header/Documentation/HDL instantiation of the YAML representation. This more or less solves the problems we have discussed above, all the while introducing new ones.\nA serious limitation to Cheby is the requirement that the user needs to maintain a YAML file describing registers. This adds overhead to the developer where now she needs to look into more than one file for the truth. Readability is affected.\nAfter continuing to look for other options the authors decided to leverage using language attributes to encode information that was being put inside magic-comments. Attributes make this a lot cleaner. Verilog attributes are defined to be rather\nsimple but clean and allow for cleanly encoding lots of register related information.\nTo leverage the usage of attributes, and successfully parse them, it made sense to use an existing Verilog parser. In order to accomplish this, we looked at iverilog and Yosys parsers. Attribute parsing wasn\u2019t sufficiently implemented in either of those open source parsers, and it took a few contributions from the authors to add the necessary features. After using both, we stuck with Yosys, for both technical and licensing reasons.\nProject Details"
        },
        {
            "heading": "Registers",
            "text": "Registers maybe marked as \u201cautomatic\u201d using an attribute in any module of the design hierarchy. Registers are marked automatic at module definition site, as shown in the code sample below.\nA developer may also notify newad to generate additional register logic, such as a write strobe for the register, a read strobe, a signal that holds the write value only for single cycle, etc.\nmodule prng( input clk, output [31:0] rnda, output [31:0] rndb, (* external *) input [0:0] run, (* external, signal_type=\"plus-we\" *) input [31:0] iva, input iva_we, // special trailing _we\n);"
        },
        {
            "heading": "Module instances",
            "text": "If a module has any registers described as \u201cautomatic\u201d, it is expected that signals/wires for the register need to be routed through its module instantiation site. When the developer marks the instantiation site with \u201cautomatic\u201d, newad then generates a macro for that instantiation site. The macro contains wires for the automatic registers of to the module being instantiated.\n(* lb_automatic *) prng prng (\n.clk(clk), .rnda(rnda), .rndb(rndb) `AUTOMATIC_prng\n);"
        },
        {
            "heading": "Verilog header files",
            "text": "newad is run as a pre-compile step. Once newad is run the macros are populated inside generated header files. The developer is expected to include these header files. This strictly keeps all generated code away from source. We are still considering a scheme where newad generates a single Verilog file with all modules it has parsed and the generated code.\nContinuing with the example above, for the sake of simplicity let\u2019s say the prng module was included in a top-level file, known as station. The following automatically generated header files can be included inside station.v. First we will look at station_auto.vh which is a headerfile expected to be included with station.v.\n// station_auto.vh // parse_vfile_yosys station.v .. // module=prng instance=prng gvar=None gcnt=None // parse_vfile_yosys :station.v ./prng.v `define AUTOMATIC_prng .run(prng_run),\\\n.iva_we(prng_iva_we),\\ .iva(prng_iva),\\\n..\nSecond, addr_map_station.vh is a generated file that strictly includes the address map that was generated by newad.\n// addr_map_station.vh `define LB_HI 14 .. // prng_iva bw: 0, base_addr: 7203 `define HIT_prng_iva (lb_addr[`LB_HI:0]==7203) // prng_run bw: 0, base_addr: 7205 `define HIT_prng_run (lb_addr[`LB_HI:0]==7205)\nA JSON file is generated as an API for a top-level software to be able to access the register info.\n.. \"prng_iva\": {\n\"access\": \"rw\", \"addr_width\": 0, \"base_addr\": 7203, \"data_width\": 32, \"description\": \"\", \"sign\": \"unsigned\"\n}, \"prng_run\": {\n\"access\": \"rw\", \"addr_width\": 0, \"base_addr\": 7205, \"data_width\": 1, \"description\": \"\", \"sign\": \"unsigned\"\n} .."
        },
        {
            "heading": "Decoder generation",
            "text": "Once newad is notified of a top-level Verilog file, and recursively searches paths for the modules utilized in the design, newad builds a tree with per-module register information. It can then generate a bus decoder upon programmer\u2019s command. Generated code for the decoder is embedded in a macro which is utilized at the intended module."
        },
        {
            "heading": "Conclusion",
            "text": "We believe large, complex projects need a robust scheme to manage their register space. Languages like Verilog, VHDL, and bSystem Verilog that can\u2019t cleanly express such semantics natively demand a tool like Cheby or newad. newad initially emerged out of necessity and evolved into something that is actively supporting several gateware projects. We have seen at least one modern HDL language such as (n)-migen (a Python based DSL for describing gateware), where such register map generation is fully embedded into the language inside a library.\nWe intend to release newad as a stand-alone package for register map automation. Currently, it is embedded inside our framework as a build tool here. We believe such register map automation could be done for VHDL as well. However, VHDL doesn\u2019t play very well with header files.\nnewad is an HDL-developer-centric approach to register space management. It focuses on HDL readability and maintainability, and a single-source-of-truth for generating register maps and their documentation."
        }
    ],
    "title": "Newad: A register map automation tool for Verilog",
    "year": 2023
}