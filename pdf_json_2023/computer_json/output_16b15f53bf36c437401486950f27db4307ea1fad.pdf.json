{
    "abstractText": "The proliferation of IoT comes with many challenges, among which security is one of the most serious issues. Since most IoT devices are designed based on bare-metal devices with low performance, low power, and small form factor, an attacker can easily perform firmware extraction and analysis. In addition, code reuse attacks, such as Return Oriented Programming (ROP) attacks, are possible based on the analyzed firmware information. Since most code reuse attacks are performed through a combination of gadgets that include return instructions, preventing an attacker from analyzing return instructions can be a fundamental solution for these attacks. To prevent code reuse attacks on bare-metal based IoT devices, this paper proposes Return Instruction Obfuscation (RIO). The proposed scheme encrypts all return instructions in the firmware and instruments the modules necessary to decrypt and execute the encrypted return instructions using a Low Level Virtual Machine (LLVM). Since all return instructions in the firmware are encrypted, the proposed scheme can prevent attackers from performing firmware analysis and gadget collection. The proposed scheme was implemented and evaluated on Nuvoton\u2019s NuMakerPFM-M2351 development board with an ARM Cortex-M23 based SoC. INDEX TERMS IoT security, Bare-metal device, LLVM, Code instrumentation, Instruction obfuscation",
    "authors": [
        {
            "affiliations": [],
            "name": "BEOMSEOK KIM"
        },
        {
            "affiliations": [],
            "name": "KIYOUNG LEE"
        },
        {
            "affiliations": [],
            "name": "WOOJIN PARK"
        },
        {
            "affiliations": [],
            "name": "JINSUNG CHO"
        },
        {
            "affiliations": [],
            "name": "BEN LEE"
        }
    ],
    "id": "SP:9ceaca43959382c6e3fb1b26b89086edce2e07e2",
    "references": [
        {
            "authors": [
                "Ericsson"
            ],
            "title": "IoT Market Outlook",
            "venue": "2018. https://www.ericsson. com/en/networks/trending/hot-topics/iot-connectivity/ iot-market-outlook",
            "year": 2018
        },
        {
            "authors": [
                "M. Xu",
                "M. Huber",
                "Z. Sun",
                "P. Enagland",
                "M. Peinado",
                "S. Lee",
                "A. Marochko",
                "D. Matton",
                "R. Spiger",
                "S. Thom"
            ],
            "title": "Dominance as a New Trusted Computing Primitive for the Internet of Things",
            "venue": "Proc. of IEEE Symposium on Security and Privacy, May 2019, pp. 1415\u20131430.",
            "year": 2019
        },
        {
            "authors": [
                "S. Vasile",
                "D. Oswald",
                "T. Chothia"
            ],
            "title": "Breaking All the Things\u2013 A Systematic Survey of Firmware Extraction Techniques for IoT Devices",
            "venue": "Proc. of International Conference on Smart Card Research and Advanced Applications (CARDIS), Montpellier, France, 2018, pp. 171\u2013185.",
            "year": 2018
        },
        {
            "authors": [
                "E.H. Spafford"
            ],
            "title": "The Internet Worm Incident",
            "venue": "Proc. of the European Software Engineering Conference (ESEC), Vol. 387, pp. 446\u2013468, May 2005.",
            "year": 2005
        },
        {
            "authors": [
                "S. Heelan",
                "T. Melham",
                "D. Kroening"
            ],
            "title": "Automatic Heap Layout Manipulation for Exploitation",
            "venue": "Proc. of the 27th USENIX Security Symposium, Apr. 2018, pp. 763\u2013779.",
            "year": 2018
        },
        {
            "authors": [
                "Scut",
                "Team Teso"
            ],
            "title": "Exploiting Format String Vulnerabilities",
            "venue": "Technique Report v1.2, Sep. 2001.",
            "year": 2001
        },
        {
            "authors": [
                "Microsoft"
            ],
            "title": "Data Execution Prevention (DEP)",
            "venue": "2006. https:// support.microsoft.com/en-us/kb/875352/en-us",
            "year": 2006
        },
        {
            "authors": [
                "One"
            ],
            "title": "Smashing The Stack For Fun And Profit",
            "venue": "underground, Vol. 7, Nov. 1996. http://www-inst.eecs.berkeley.edu",
            "year": 1996
        },
        {
            "authors": [
                "H. shacham"
            ],
            "title": "The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86)",
            "venue": "Proc. of the 14th ACM conference on Computer Communication Security (CCS), Sep. 2007, pp. 552\u2013561.",
            "year": 2007
        },
        {
            "authors": [
                "K.Z. Snow",
                "F. Monrose",
                "L. Davi",
                "A. Dmitrienko"
            ],
            "title": "Just- In-Time Code Reuse: On the Effectiveness of Fine-Grained Address Space Layout Randomization",
            "venue": "Proc. of the 2013 IEEE Symposium on Security and Privacy (S&P), May 2013, pp. 574\u2013 588.",
            "year": 2013
        },
        {
            "authors": [
                "T. Bletsch",
                "X. Jiang",
                "V.W. Freeh",
                "Z. Liang"
            ],
            "title": "Jump- Oriented Programming: A New Class of Code-Reuse Attack",
            "venue": "Proc. of the 6th ACM Symposium on Information, Computer and Communications Security (ASIACCS), Mar. 2011, pp. 30\u2013 40.",
            "year": 2011
        },
        {
            "authors": [
                "E. Goktas",
                "E. Athanasopoulos",
                "H. Bos",
                "G. Portokalidis"
            ],
            "title": "Out Of Control: Overcoming Control-Flow Integrity",
            "venue": "Proc. of the 2014 IEEE Symposium on Security and Privacy (S&P), May 2014, pp. 575\u2013589.",
            "year": 2014
        },
        {
            "authors": [
                "F. Schuster",
                "T. Tendyck",
                "C. Liebchen",
                "L. Davi",
                "A.R. Sadeghi",
                "T. Holz"
            ],
            "title": "Counterfeit Object-oriented Programming",
            "venue": "Proc. of the 2015 IEEE Symposium on Security and Privacy (S&P), July 2015, pp. 745\u2013762.",
            "year": 2015
        },
        {
            "authors": [
                "H. Hu",
                "S. Shinde",
                "S. Adrian",
                "Z.L. Chua",
                "P. Saxena",
                "Z. Liang"
            ],
            "title": "Data-Oriented Programming: On the Expressiveness of Non-Control Data Attacks",
            "venue": "Proc. of the 2016 IEEE Symposium on Security and Privacy (S&P), May 2016, pp. 969\u2013986.",
            "year": 2016
        },
        {
            "authors": [
                "M. Abadi",
                "M. Budiu",
                "U. Erlingsson",
                "J. Ligatti"
            ],
            "title": "Control- Flow Integrity Principles, Implementations, and Applications",
            "venue": "ACM Transactions on Information and System Security (TIS- SEC), Vol. 13, pp. 1\u201341, Oct. 2009.",
            "year": 2009
        },
        {
            "authors": [
                "M. Zhang",
                "R. Sekar"
            ],
            "title": "Control flow Integrity for COTS Binaries",
            "venue": "Proc. of the 22nd USENIX conference on Securiy, Aug. 2013, pp. 337\u2013352.",
            "year": 2013
        },
        {
            "authors": [
                "C. Zhang",
                "T. Wei",
                "Z. Chen",
                "L. Duan"
            ],
            "title": "Practical Control Flow Integrity & Randomization for Binary Executables",
            "venue": "Proc. of the 2013 IEEE Symposium on Security and Privacy (S&P), May 2013, pp. 559\u2013573.",
            "year": 2013
        },
        {
            "authors": [
                "B. Niu",
                "G. Tan"
            ],
            "title": "Modular Control-Flow Integrity",
            "venue": "Proc. of the 35th ACM SIGPLAN conference on Programming Language Design and Implementation, June 2014, pp. 577\u2013587.",
            "year": 2014
        },
        {
            "authors": [
                "C. Tice",
                "T. Roeder",
                "P. Collingbourne",
                "S. Checkoway",
                "U. Erlingsson",
                "L. Lozano",
                "G. Pike"
            ],
            "title": "Enforcing Forward-Edge Control Flow Integrity in GCC & LLVM",
            "venue": "Proc. of the 23th USENIX Security Symposium, San Diego, CA, USA, Aug. 2014, pp. 941\u2013 955.",
            "year": 2014
        },
        {
            "authors": [
                "V. Veen",
                "E. Goktas",
                "M. Contag",
                "M. Contag",
                "A. Pawlowski",
                "X. Chen",
                "S. Rawat",
                "H. Bos",
                "T. Holz",
                "E. Athanasopoulos",
                "C. Giuffrida"
            ],
            "title": "A Tough call: Mitigating Advanced Code-Reuse Attacks At The Binary Level",
            "venue": "Proc. of the 2016 IEEE Symposium on Security and Privacy (S&P), Aug. 2016, pp. 934\u2013953.",
            "year": 2016
        },
        {
            "authors": [
                "P. Qiu",
                "Y. Lyu",
                "J. Zhang",
                "D. Wang",
                "G. Qu"
            ],
            "title": "Control Flow Integrity Based on Lightweight Encryption Architecture",
            "venue": "IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, Vol. 37, Issue 7, pp. 1358\u20131369, July 2018.",
            "year": 2018
        },
        {
            "authors": [
                "A. Francillon",
                "C. Castelluccia"
            ],
            "title": "Code Injection Attacks on Harvard-Architecture Devices",
            "venue": "Proc. of the ACM Conference on Computer and Communications Security (CCS),",
            "year": 2008
        },
        {
            "authors": [
                "J. Li",
                "L. Chen",
                "Q. Xu",
                "L. Tian",
                "G. Shi",
                "K. Chen",
                "D. Meng"
            ],
            "title": "Zipper stack: Shadow stacks without shadow",
            "venue": "Proc. of European Symposium on Research in Computer Security (ESORICS 2020, Sep. 2020, pp 338\u2013358.",
            "year": 2020
        },
        {
            "authors": [
                "H. Liljestrand",
                "T. Nyman",
                "L.J. Gunn",
                "J. Ekberg",
                "N. Asokan"
            ],
            "title": "PACStack: An Authenti- cated Call Stack",
            "venue": "Proc of 30th USENIX Security Symposium, Aug. 2021, pp. 357\u2013374.",
            "year": 2021
        },
        {
            "authors": [
                "N.S. Almakhdhub",
                "A.A. Clements",
                "S. Bagchi",
                "M. Payer"
            ],
            "title": "\u03bcRAI: Securing Embedded Systems with Return Address Integrity",
            "venue": "Proc. of Network and Distributed System Security Symposum (NDSS 2020, Feb. 2020, pp. 1\u201318.",
            "year": 2020
        },
        {
            "authors": [
                "T. Nyman",
                "J. Ekberg",
                "L. Davi",
                "N. Asokan"
            ],
            "title": "CFI CaRE: Hardware-supported call and return enforcement for commercial microcontrollers",
            "venue": "Proc. of 20th International Symposium on Research in Attacks, Intrusions, and Defences (RAID 2017), Sep. 2017, pp. 259\u2013284.",
            "year": 2017
        },
        {
            "authors": [
                "F.A.T. Abad",
                "J.V.D. Woude",
                "Yi Lu",
                "S. Bak",
                "M. Caccamo",
                "L. Sha",
                "R. Mancuso",
                "S. Mohan"
            ],
            "title": "On-chip control flow integrity check for real time embedded systems",
            "venue": "Proc. of IEEE International Conference on Cyber-Physical Systems, Network, and Application (CPSNA 2013), Aug. 2013, pp 26\u201331.",
            "year": 2013
        },
        {
            "authors": [
                "P. Yang",
                "L. Tao",
                "H. Wang"
            ],
            "title": "RTTV: A dynamic CFI measurement tool based on TPM",
            "venue": "IET Information Security, Vol. 12, Issue 5, pp. 438\u2013444, Sep. 2018.",
            "year": 2018
        },
        {
            "authors": [
                "A. Francillon",
                "C. Castelluccia"
            ],
            "title": "Code Injection Attacks on Harvard-architecture Devices",
            "venue": "Proc. of the 15th ACM Conference on Computer and Communication Security (CCS 2008), Alexandria, CA, USA, Oct. 2008, pp.15\u201326.",
            "year": 2008
        },
        {
            "authors": [
                "Nuvoton Inc."
            ],
            "title": "NuMaker-PFM-M2351 User Manual Rev 1.00",
            "venue": "2018.",
            "year": 2018
        },
        {
            "authors": [
                "GitHub"
            ],
            "title": "Return Instruction Obfuscation",
            "venue": "2022. https:// github.com/khu-mesl-348/RIO",
            "year": 2022
        },
        {
            "authors": [
                "J. Pallister",
                "S. Hollis",
                "J. Bennett"
            ],
            "title": "BEEBS: Open benchmarks for energy measurements on embedded platforms",
            "venue": "arXiv preprint arXiv:1308.5174, Aug. 2013. https://arxiv.org/abs/ 1308.5174",
            "year": 2013
        },
        {
            "authors": [
                "J. Gustafsson",
                "A. Betts",
                "A. Ermedahl",
                "B. Lisper"
            ],
            "title": "The M\u00e4lardalen WCET Benchmarks: Past, Present and Future",
            "venue": "Proc. of 10th International Workshop on Worst-Case Execution Time Analysis (WCET 2010), Brussels, Belgium, Apr. 2010, pp. 136\u2013146.",
            "year": 2010
        }
    ],
    "sections": [
        {
            "text": "INDEX TERMS IoT security, Bare-metal device, LLVM, Code instrumentation, Instruction obfuscation\nI. INTRODUCTION\nINTERNET of Things (IoT) is a technology usedin various fields such as medical, industrial, and consumer applications, and its adoption has been rapidly spreading in recent years [1], [2]. Most IoT devices are bare-metal devices, which are low-power and inexpensive embedded systems that execute commands directly on hardware without a base operating system. In general, it is used in hard real-time embedded systems, and recently it is being used in various fields for IoT services. Baremetal devices are typically low-cost and low-power embedded systems that have low processing capacity, small memory, and eXecution In Place (XIP)-structured code execution. Since these hardware features lead to various security vulnerabilities [3], in particular, attackers can easily extract and analyze the firmware of bare-metal\ndevices. Meanwhile, code injection attacks replace data packets sent to a target device with a payload containing malicious code. Then, the code is executed through memory corruption by overwriting data in the stack/heap memory [4]\u2013[6]. As countermeasures for these attacks, there are techniques such as W\u2295X, Data Execution Prevention (DEP) [7], etc. On the other hand, code reuse attacks bypass the countermeasures against code injection attacks. An attacker selects and combines gadgets, which are sequences of instructions stored in firmware, to perform data leakage and modification [8]\u2013 [14]. Unlike code injection attacks, code reuse attacks are difficult to detect because they exploit existing codes. In particular, bare-metal IoT devices are more vulnerable to code reuse attacks due to their open characteristics.\nVOLUME 4, 2016 1\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\nBeomSeok Kim et al.: A Secure Platform Model for Low-end IoT Devices\nA number of defenses against code reuse attacks have been studied, but most are post-defense methods that focus on detecting attackers\u2019 gadget collection and exploitation [15]\u2013[20]. In contrast, Qiu et al. proposed a pre-defense method called Lightweight Encryption Architecture - Control Flow Integrity (LEA-CFI) [21]. LEA-CFI is a technique that prevents code reuse attacks on systems based on the x86 architecture, which uses the Advanced Encryption Standard - Counter (AES-CTR) mode to encrypt indirect jump addresses. Moreover, an LEA-AES module is added to the CPU to encrypt indirect jump addresses when programs are loaded into memory to minimize changes to the x86 CPU architecture. When an indirect jump instruction is executed, the LEA-AES module decrypts the encrypted address. This encryption/decryption capability provides robust security and performance benefits. However, LEA-CFI assumes basic security features, such as DEP, are supported by target systems and uses Control Flow Graph (CFG) to detect and encrypt indirect jump addresses in programs loaded into memory. Therefore, it cannot be considered as a general solution against code reuse attacks for bare-metal IoT devices.\nSince the afore-mentioned security schemes are designed for desktop-level or higher systems, they are fundamentally unsuitable for bare-metal IoT devices. In addition, attackers are able to collect gadgets because they can easily acquire firmware from low-cost baremetal IoT devices. A. Francillon et al. proved that baremetal IoT devices are very vulnerable to code reuse attacks by performing code reuse attacks on embedded devices connected to the internet [22]. For these reasons, security techniques specifically applicable to bare-metal IoT devices need to be devised.\nTo prevent code reuse attacks on IoT devices, various CFI schemes have been proposed [23]\u2013[28]. These schemes include modifications to MicroController Unit (MCU) architecture, such as Zipper stack and PACStack, as well as CFI approaches based on ARM TrustZone and Hardware Security Modules (HSMs). However, these CFI schemes have limitations due to high overhead, impractical to implement on bare-metal IoT devices, platform dependence, and additional hardware requirements. Moreover, CFI serves as a control and detection mechanism for code reuse attacks and does not address the prevention of gadget collection, which is necessary for conducting such attacks. Therefore, research is needed to effectively prevent gadget collection with lower overhead specifically tailored for IoT devices.\nBased on the aforementioned discussion, this paper proposes the Return Instruction Obfuscation (RIO) to prevent threats caused by code reuse attacks on baremetal IoT devices. Since the proposed scheme encrypts return instructions, which are the main instructions of gadgets, an attacker cannot analyze the control flow even if the firmware is extracted. The modules necessary\nfor the operation of RIO are implemented with Low Level Virtual Machine (LLVM). The contributions of the proposed RIO scheme are summarized as follows:\n\u2022 It prevents attackers from collecting gadgets by encrypting all return instructions in the firmware binary. \u2022 It is verified through a proof-of-concept (PoC) implementation on Nuvoton\u2019s NuMaker-PFM-M2351 development board with ARM Cortex-M23 based SoC. \u2022 To the best of our knowledge, the proposed scheme is the first attempt against code reuse attack for bare-metal IoT devices.\nThe rest of this paper is organized as follows: Section II presents the related work for the proposed method and describes our preliminary study. The proposed RIO is presented in Section III, and Section IV discusses a PoC implementation and performance evaluation for the proposed RIO. Finally, Section V concludes the paper."
        },
        {
            "heading": "II. RELATED WORK AND A PRELIMINARY STUDY",
            "text": ""
        },
        {
            "heading": "A. CODE REUSE ATTACKS AND DEFENSES",
            "text": "Code reuse attacks modify the control flow of a code stored in memory, which is achieved by selecting and chaining together gadgets from binaries stored in a target device. Since code reuse attacks combine and exploit existing code without additional code insertion, they cannot be detected with the existing code injection defense schemes.\nA history of code reuse attacks and countermeasures is summarized in Figure 1. The existing code reuse attacks can be classified according to the main instruction used for exploiting gadgets. The first type of attacks uses return gadgets that include Return-To-Libc (RTL) [8], Return Oriented Programming (ROP) [9], Just-In-Time (JIT)-ROP [10], etc. The second type of attacks uses indirect function call gadgets, which include Jump Oriented Programming (JOP) [11], Call Oriented Programming (COP) [12], Counterfeit Object Oriented Programming (COOP), etc. [13]. This type of attacks bypasses defenses against return gadgets and exploits"
        },
        {
            "heading": "2 VOLUME 4, 2016",
            "text": "This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\nBeomSeok Kim et al.: A Secure Platform Model for Low-end IoT Devices\na gadget that jumps to the target address based on a pointer.\nMeanwhile, code reuse defenses can be classified into post-defense and pre-defense methods. Most of the existing code reuse defenses are post-defense methods and were developed to focus on detection and verification of forward-edges called indirect control transfer. The most basic post-defense schemes are the NX bit and Control Flow Integrity (CFI) [15], which are general methods against RTL and ROP attacks that abuse return gadgets. However, they have large overhead costs and are vulnerable to bypass attacks such as JIT-ROP and JOP. Various CFI schemes have been proposed to solve these problems, such as Bin-CFI [16], Compact Control Flow Integrity and Randomization (CCFIR) [17], Modular CFI (MCFI) [18], and Virtual Table Verification (VTV) & Indirect Function Call Checks (IFCC) [19]. However, COP and COOP attacks that exploit function entry points or Indirect Control Transfer (ICT) can bypass these CFIs. Subsequently, TypeArmor and Lightweight Encryption Architecture-CFI (LEA-CFI) were proposed as schemes to block the bypassing of COP and COOP [20], [21]. TypeArmor ensures that only functions that strictly match the call site can be executed through an integrated forward-edge CFI policy called Control Flow Containment (CFC). TypeArmor verifies the number of function arguments and the number of registers used. If the number of registers used by the caller is less than the callee, the CFC policy regards this as a memory corruption exploitation using a buffer overflow payload and branching is prohibited. Although TypeArmor provides defenses against COP and COOP, it is still vulnerable to general code reuse attacks such as ROP and JOP.\nAll the aforementioned schemes, with the exception of LEA-CFI, can prevent code reuse attacks using return gadgets through a shadow stack. However, these schemes cannot be implemented in low performance bare-metal IoT devices because they were developed to improve security in a high-performance environment such as desktops. In addition, an attacker can easily to discover new vulnerabilities because the existing CFI schemes allow for firmware analysis via de-soldering flash memory chips. Therefore, they are not complete solutions because attackers cannot be prevented from collecting gadgets.\nOn the other hand, LEA-CFI is a pre-defense method that actively prevents code reuse attacks through obfuscation and verification of backward-edges of return control transfers. LEA-CFI prevents attackers from jumping to desired addresses using the LEA-AES module, which is added to the CPU to encrypt and decrypt return and indirect function call addresses. The LEA-AES module consists of Encryption-Decryption Unit (EDU), KEY_CFI register for storing keys, LEN_CFI register to store the length of commands referenced when performing indirect control transfers, and Random number\nGenerator Unit (RGU) for generating KEY_CFI and LEN_CFI when the device is booted. When a program is loaded into memory, LEA-CFI finds all the return and indirect jump addresses via the CFG analysis, encrypts them using the LEA-AES module, and stores them in the stack memory and registers. Afterwards, when a return or an indirect jump is executed, its encrypted address is decrypted and stored in the Instruction Pointer (IP) register. However, LEA-CFI is not applicable to bare-metal devices for a couple of reasons. First, LEACFI is designed based on AES developed for the x86based system, which assumes the existence of DEP and the use of CFG, making it unsuitable for bare-metal devices designed based on ARM or MIPS. Second, unlike x86 systems, most bare-metal devices cannot apply LEA-CFI because they have an XIP structure that runs programs directly from a flash memory without first loading them into RAM."
        },
        {
            "heading": "B. CODE REUSE ATTACK CASES AND CFI FOR IOT DEVICES",
            "text": "Meanwhile, attacks exploiting the constraints of IoT devices, such as easy firmware extraction and analysis, lower processing power compared to x86 systems, and the absence of program control flow integrity verification capabilities in processors, have been attempted recently. In particular, code reuse attacks that hijack the control flow of the program without code injection, achieved through firmware extraction and gadget analysis, are recognized as prominent attacks targeting IoT devices. These attacks are considered the most advanced methods of targeting IoT devices.\nS. Vasile et al. performed a study on firmware extraction/analysis/modification targeting typical bare-metal IoT devices [3]. This study suggested that firmware installed in bare-metal devices can be extracted through raw flash dump and debug interfaces such as UART and JTAG. They conducted case studies on various devices, such as Amazon Fire TV, Google NEST, Chromecast, LG Smart Refrigerator, and Samsung SHS-5230 Doorlock, to examine the vulnerabilities of bare-metal IoT devices and prove that firmware extraction can be done with ease.\nFrancillon and Castelluccia performed code reuse attacks on bare-metal devices by analyzing the extracted firmware and collecting gadgets [22]. The authors designed two gadgets based on their analysis. The first is reprogramming meta-gadget, which is a sequence of gadgets that copies malicious code into the flash memory of the target bare metal device and executes it. The second is injection meta-gadget that injects a fake stack containing malicious code into an unused memory area. Based on these meta-gadgets, the authors established an attack scenario. When the attack starts, both injection meta-gadget and fragments of the fake stack are injected to the target bare-metal IoT device\nVOLUME 4, 2016 3\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\nBeomSeok Kim et al.: A Secure Platform Model for Low-end IoT Devices\nby sending packets and storing the fake stack into a free memory area of the target. When all the fragments of the fake stack are stored in memory, the attacker sends a reprogramming meta-gadget to copy the fake stack stored in memory to the flash memory and executes it. The authors implemented the scheme in an Atmel AVR-based device and proved that code reuse attacks are possible.\nTo prevent code reuse attacks targeting IoT devices, various CFI schemes have been proposed as countermeasures, including existing x86-based CFI schemes optimized for the IoT device environment. Details of CFI schemes for IoT devices are as follows.\n\u2022 CFI based on modification of microprocessor: Zipper stack is a proposed approach that implements CFI by modifying an MCU architecture that introduces separate registers and key registers [23]. When a function is called, the separate register is\npushed onto the main stack along with the actual return address, and a Message Authentication Code (MAC) for the separate register and return address is generated using the value stored in the key register. This MAC is then stored in the separate register, and the integrity of the control flow is ensured by performing authentication on the return address when a function execution concludes. Similar to Zipper stack, PACStack is an approach that utilizes MAC [24]. It is based on the ARMv8-3-A architecture and subsequent versions, which provide the Pointer Authentication Code (PAC) instruction known as \"pac\" for performing MAC. PACStack verifies the return address after function execution to ensure control flow integrity. \u2022 CFI without modification of microprocessor: \u00b5RAI (unmodified Return Address Integrity) performs Return Address Integrity (RAI) by allocating a specific register as the State register (SR) without modifying the existing MCU [25]. In \u00b5RAI, a Function Key (FK) is assigned to each function call site, and an XOR operation between the value in the SR and the FK value generates a derived Function ID (FID), enabling code verification. When a called function completes its execution and returns, muRAI references the Function Lookup Table (FLT) that stores all FIDs and determines whether there is a match between the FID and SR to detect attacks. \u2022 ARM TrustZone-based CFI: Research has also been conducted on CFI based on ARM TrustZone, which is a prominent security platform for IoT devices. Nyman et al. proposed CFI CaRE, which utilizes the isolated execution environment of ARM TrustZone to ensure CFI [26]. In CFI CaRE, a shadow stack is concealed within the secure zone, and all function calls are replaced with supervisory calls (SCVs) that perform branch monitoring. This effectively monitors all branches and returns to prevent unauthorized modifications to the shadow stack by attackers."
        },
        {
            "heading": "4 VOLUME 4, 2016",
            "text": "This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\nBeomSeok Kim et al.: A Secure Platform Model for Low-end IoT Devices\nFIGURE 4: The firmware binary generation of the proposed RIO.\n\u2022 HSM-based CFI: In addition to MCU architecture modifications and CFI schemes based on ARM TrustZone, several CFI approaches for IoT devices have been explored based on HSM support. Abad et al. proposed a scheme that ensures CFI by adding a separate monitoring module to verify the program counter [27]. Another example is RunTime Trusted Verifier (RTTV), which utilizes Trusted Platform Module (TPM) to store the Control Flow Graph (CFG) and performs periodic measurements based on it [28].\nAs discussed above, numerous CFI schemes have been studied to prevent code reuse attacks targeting IoT devices. However, the CFI schemes mentioned above have limitations regarding practical implementation on bare-metal IoT devices because they incur excessive overhead, rely on radical modifications to MCU architecture, are platform-dependent like ARM TrustZone or require additional HSM support. Furthermore, CFI schemes serve as a control and detection mechanism for code reuse attacks and do not address the fundamental issue of preventing gadget collection, which is a prerequisite for conducting code reuse attacks. Therefore, the existing CFI schemes for IoT devices cannot be regarded as a comprehensive solution for preventing\ncode reuse attacks, and there is a need for research on effectively preventing gadget collection with lower overhead compared to CFI."
        },
        {
            "heading": "C. A PRELIMINARY STUDY: AN ROP ATTACK ON IOT DEVICE",
            "text": "In order to reveal the vulnerability of bare-metal devices to code reuse attacks, an Arduino-based smart metering prototype was implemented to carry out firmware tampering using ROP exploitation similar to the work by Francillon and Castelluccia [29]. Figure 2 illustrates the process of an ROP exploitation on the prototype, where a fabricated value is sent to the cloud server as shown in Figure 3.\nThe attack was performed by extracting and analyzing the firmware to find buffer overflow vulnerabilities. After identifying the portion of the code that stores the metered value, the code was changed to store a fabricated value. This is achieved by searching for gadgets in the firmware including the storage library, which writes data to the flash memory in Arduino, and chaining them to tamper with firmware binaries. Afterwards, a buffer overflow attack is performed and the injected chained gadgets are executed."
        },
        {
            "heading": "III. THE PROPOSED SCHEME",
            "text": "As shown in the preliminary study, bare-metal IoT devices are vulnerable to code reuse attacks. This section presents the proposed RIO to prevent code reuse attacks on bare-metal IoT devices by encrypting all return constructs in the firmware and inserting modules that decrypt and execute the return instructions. The\nVOLUME 4, 2016 5\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\nBeomSeok Kim et al.: A Secure Platform Model for Low-end IoT Devices\nFIGURE 7: The LLVM IR code for the original source code.\nFIGURE 8: The instrumented IR code after performing the module instrumentation.\nencryption/decryption key is assumed to be securely generated and managed.\nFigure 4 shows the firmware generation of RIO. First, the source code of the firmware is compiled using the LLVM compiler to generate an LLVM Intermediate Representation (IR). Second, the necessary modules for the proposed RIO are instrumented using LLVM passes, which involves adding an initialization module at the beginning of the existing firmware and instrumenting a Return Control Flow (RCF) module just before each return instruction. In addition, the instrumented initialization and RCF modules should be implemented as an inline function to avoid including branches that an attacker can exploit. Third, the instrumented IR is then converted into an executable binary for the target bare-metal device. Finally, the obfuscated binary is generated by encrypting all the return instructions of the executable binary and stored in the flash memory of the target device.\nFigure 5 shows the execution sequence of the proposed RIO. First, the initialization module scans all the RCF modules in the binary code. Second, it decrypts the following encrypted return instruction. Third, the decrypted return instruction is stored in the Return Instruction Table in SRAM. After the initialization completes, firmware codes are executed. Finally, during\nexecution, each RCF module before the encrypted return instruction jumps to the corresponding decrypted return instruction in the Return\nAs a result, the proposed RIO can prevent attackers from performing firmware analysis and hijacking, which is the root cause of code reuse attacks."
        },
        {
            "heading": "IV. POC IMPLEMENTATION AND PERFORMANCE EVALUATION",
            "text": "This section discusses our PoC implementation and performance evaluation in order to validate the proposed scheme."
        },
        {
            "heading": "A. POC IMPLEMENTATION",
            "text": "The target device for the PoC implementation is Nuvoton\u2019s NuMaker-PFM-M2351, which is a commercial ARM Cortex-M v8 development board [30]. This board contains the M2351KIAAE SoC that includes 64 MHz Cortex-M23 processor, 96 KB SRAM, 512 KB flash memory, cryptographic accelerator, One-Time Programmable (OTP) memory, and True Random Number Generator (TRNG). The development environment was used to configure the instrumentation and obfuscation on a Linux machine and code instrumentations were implemented using the LLVM version 11.0.1. The cryptographic accelerator in Nuvoton employs AES-128 for"
        },
        {
            "heading": "6 VOLUME 4, 2016",
            "text": "This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\nBeomSeok Kim et al.: A Secure Platform Model for Low-end IoT Devices\nFIGURE 9: The executable binary code in ARM assembly.\nFIGURE 10: The obfuscated binary code in ARM assembly.\nthe obfuscation. The LLVM pass code used in our PoC implementation has been made available on GitHub [31].\nFigure 6 is a sample code for the PoC implementation. The main function calls a function that outputs the string \u201cRIO\". The compiled LLVM IR of the original source code is given in Figure 7 and module instrumentations are performed based on this code. In the LLVM pass for a module instrumentation, a logical space is created by adding basic blocks before and after each return instruction for the entire firmware IR code. Based on this, Figure 8 shows that two basic blocks are added, unlike the existing IR code consisting of only one basic block. The first block is marked with ret_jmp: ; preds = %entry, which corresponds to the instrumented RCF module\n(lines 7\u20139 and 21\u201323). This code performs an indirect jump based on the base address and offset value of the Return Instruction Table. The second block corresponds to the return instruction expressed as obfuscatedreturn: ; preds = %ref_jmp (lines 11\u201312 and 25\u201326), which will be encrypted later.\nFigure 9 shows the ARM assembly code from the LLVM back-end compiler. The instrumented RCF modules are located at lines 8\u201310 and 21\u201323 and the unobfuscated return instructions are located at lines 11\u201312 and 27. In lines 8 and 21, the instrumented RCF module refers to 0x20002c00 (lines 14 and 27, respectively), which is the base address of the Return Instruction\nVOLUME 4, 2016 7\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\nBeomSeok Kim et al.: A Secure Platform Model for Low-end IoT Devices\nTable.1 An offset is added to the base address in lines 9 and 22 and the indirect branch is performed in lines 10 and 23. Finally, the obfuscated binary code in Figure 10 can be obtained by encrypting the return instructions in lines 11\u201312 and 24, which cannot be analyzed by attackers.\nB. PERFORMANCE EVALUATION The empirical experiments have been conducted on our PoC implementation with the Bristol/Embecosm Embedded Benchmark Suite (BEEBS) [32]\u2013[34], which is a set of benchmarks for studying the performance of embedded devices. Table 1 shows the overhead of the proposed RIO on functions in BEEBS in terms of execution time and binary size.\nThe binary sizes for RIO increase by about 29.9% (error range of 2%) for all the functions compared to the original code because of the initialization and RCF modules that are added. In terms of execution time, RIO requires an additional initialization overhead of 318 ms on average compared to the original code because the initialization module decrypts all the encrypted return instructions in the binary code and builds Return Instruction Table in SRAM. In addition, RIO executes RCF modules that perform indirect jumps to the Return\n1Note that the objdump utility displays the base address 0x20002c00 as if it is an instruction.\nInstruction Table, which may increase the execution time. The increase in execution time ranges from 0% to 16.83% depending on the characteristics of the target function, and the overhead increases as the number of sub-function calls for the target function increases. Figure 9 shows that the overhead of a RCF module is just three instructions. Afterwards, most of the overheads in Table 1 are associated with the initialization module that decrypts all the encrypted return instructions. Since the runtime overhead after executing the initialization module of the proposed RIO is negligible, Therefore, the proposed RIO is a competitive solution because the runtime overhead after executing the initialization module is negligible."
        },
        {
            "heading": "V. CONCLUSION",
            "text": "This paper proposed the RIO scheme that prevents threats caused by firmware stealing from bare-metal devices. The proposed RIO encrypts all the return instructions in the firmware binary and securely executes them through instrumented modules via LLVM. The instrumented initialization module decodes all obfuscated return instructions in the firmware and builds Return Instruction Table in SRAM. In addition, before each obfuscated return instruction, the RCF module executes return instructions in the Return Instruction Table through indirect jumps. Our PoC implementation"
        },
        {
            "heading": "8 VOLUME 4, 2016",
            "text": "This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\nBeomSeok Kim et al.: A Secure Platform Model for Low-end IoT Devices\nand its performance evaluation verify that RIO can prevent attackers from collecting gadgets by obfuscating the return instructions and can be applied to off-theshelf bare-metal IoT devices. However, the proposed RIO requires a certain amount of overhead to prevent attackers from collecting gadgets in advance. Therefore, optimizing the proposed RIO to achieve lower overhead is left as a future work.\nREFERENCES [1] Ericsson, \u201cIoT Market Outlook,\u201d 2018. https://www.ericsson.\ncom/en/networks/trending/hot-topics/iot-connectivity/ iot-market-outlook\n[2] M. Xu, M. Huber, Z. Sun, P. Enagland, M. Peinado, S. Lee, A. Marochko, D. Matton, R. Spiger, and S. Thom, \u201cDominance as a New Trusted Computing Primitive for the Internet of Things,\u201d Proc. of IEEE Symposium on Security and Privacy, May 2019, pp. 1415\u20131430. [3] S. Vasile, D. Oswald, and T. Chothia, \u201cBreaking All the Things\u2013 A Systematic Survey of Firmware Extraction Techniques for IoT Devices,\u201d Proc. of International Conference on Smart Card Research and Advanced Applications (CARDIS), Montpellier, France, 2018, pp. 171\u2013185. [4] E. H. Spafford, \u201cThe Internet Worm Incident,\u201d Proc. of the European Software Engineering Conference (ESEC), Vol. 387, pp. 446\u2013468, May 2005. [5] S. Heelan, T. Melham, D. Kroening, \u201cAutomatic Heap Layout Manipulation for Exploitation,\u201d Proc. of the 27th USENIX Security Symposium, Apr. 2018, pp. 763\u2013779. [6] Scut, Team Teso, \u201cExploiting Format String Vulnerabilities,\u201d Technique Report v1.2, Sep. 2001. [7] Microsoft, \u201cData Execution Prevention (DEP),\u201d 2006. https:// support.microsoft.com/en-us/kb/875352/en-us [8] One, \u201cSmashing The Stack For Fun And Profit,\u201d underground, Vol. 7, Nov. 1996. http://www-inst.eecs.berkeley.edu [9] H. shacham, \u201cThe Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86),\u201d Proc. of the 14th ACM conference on Computer Communication Security (CCS), Sep. 2007, pp. 552\u2013561. [10] K. Z. Snow, F. Monrose, L. Davi, and A. Dmitrienko, \u201cJustIn-Time Code Reuse: On the Effectiveness of Fine-Grained Address Space Layout Randomization,\u201d Proc. of the 2013 IEEE Symposium on Security and Privacy (S&P), May 2013, pp. 574\u2013 588. [11] T. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang, \u201cJumpOriented Programming: A New Class of Code-Reuse Attack,\u201d Proc. of the 6th ACM Symposium on Information, Computer and Communications Security (ASIACCS), Mar. 2011, pp. 30\u2013 40. [12] E. Goktas, E. Athanasopoulos, H. Bos, and G. Portokalidis, \u201cOut Of Control: Overcoming Control-Flow Integrity,\u201d Proc. of the 2014 IEEE Symposium on Security and Privacy (S&P), May 2014, pp. 575\u2013589. [13] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A. R. Sadeghi, and T. Holz, \u201cCounterfeit Object-oriented Programming,\u201d Proc. of the 2015 IEEE Symposium on Security and Privacy (S&P), July 2015, pp. 745\u2013762. [14] H. Hu, S. Shinde, S. Adrian, Z. L. Chua, P. Saxena, and Z. Liang, \u201cData-Oriented Programming: On the Expressiveness of Non-Control Data Attacks,\u201d Proc. of the 2016 IEEE Symposium on Security and Privacy (S&P), May 2016, pp. 969\u2013986. [15] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, \u201cControlFlow Integrity Principles, Implementations, and Applications,\u201d ACM Transactions on Information and System Security (TISSEC), Vol. 13, pp. 1\u201341, Oct. 2009. [16] M. Zhang and R. Sekar, \u201cControl flow Integrity for COTS Binaries,\u201d Proc. of the 22nd USENIX conference on Securiy, Aug. 2013, pp. 337\u2013352. [17] C. Zhang, T. Wei, Z. Chen, and L. Duan, \u201cPractical Control Flow Integrity & Randomization for Binary Executables,\u201d Proc.\nof the 2013 IEEE Symposium on Security and Privacy (S&P), May 2013, pp. 559\u2013573. [18] B. Niu and G. Tan, \u201cModular Control-Flow Integrity,\u201d Proc. of the 35th ACM SIGPLAN conference on Programming Language Design and Implementation, June 2014, pp. 577\u2013587. [19] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, U. Erlingsson, L. Lozano, and G. Pike, \u201cEnforcing Forward-Edge Control Flow Integrity in GCC & LLVM,\u201d Proc. of the 23th USENIX Security Symposium, San Diego, CA, USA, Aug. 2014, pp. 941\u2013 955. [20] V. Veen, E. Goktas, M. Contag, M. Contag, A. Pawlowski, X. Chen, S. Rawat, H. Bos, T. Holz, E. Athanasopoulos, and C. Giuffrida, \u201cA Tough call: Mitigating Advanced Code-Reuse Attacks At The Binary Level,\u201d Proc. of the 2016 IEEE Symposium on Security and Privacy (S&P), Aug. 2016, pp. 934\u2013953. [21] P. Qiu, Y. Lyu, J. Zhang, D. Wang, and G. Qu, \u201cControl Flow Integrity Based on Lightweight Encryption Architecture,\u201d IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, Vol. 37, Issue 7, pp. 1358\u20131369, July 2018. [22] A. Francillon and C. Castelluccia, \u201cCode Injection Attacks on Harvard-Architecture Devices\u201d Proc. of the ACM Conference on Computer and Communications Security (CCS), Oct. 2008, pp. 15\u201326. [23] J. Li, L. Chen, Q. Xu, L. Tian, G. Shi, K. Chen, and D. Meng, \u201cZipper stack: Shadow stacks without shadow,\u201d Proc. of European Symposium on Research in Computer Security (ESORICS 2020, Sep. 2020, pp 338\u2013358. [24] H. Liljestrand, T. Nyman, L. J. Gunn, J. Ekberg, and N. Asokan, \u201cPACStack: An Authenti- cated Call Stack,\u201d Proc of 30th USENIX Security Symposium, Aug. 2021, pp. 357\u2013374. [25] N. S. Almakhdhub, A. A. Clements, S. Bagchi, and M. Payer, \u201c\u00b5RAI: Securing Embedded Systems with Return Address Integrity,\u201d Proc. of Network and Distributed System Security Symposum (NDSS 2020, Feb. 2020, pp. 1\u201318. [26] T. Nyman, J. Ekberg, L. Davi, and N. Asokan, \u201cCFI CaRE: Hardware-supported call and return enforcement for commercial microcontrollers,\u201d Proc. of 20th International Symposium on Research in Attacks, Intrusions, and Defences (RAID 2017), Sep. 2017, pp. 259\u2013284. [27] F. A. T. Abad, J. V. D. Woude, Yi Lu, S. Bak, M. Caccamo, L. Sha, R. Mancuso, and S. Mohan, \u201cOn-chip control flow integrity check for real time embedded systems,\u201d Proc. of IEEE International Conference on Cyber-Physical Systems, Network, and Application (CPSNA 2013), Aug. 2013, pp 26\u201331. [28] P. Yang, L. Tao, and H. Wang, \u201cRTTV: A dynamic CFI measurement tool based on TPM,\u201d IET Information Security, Vol. 12, Issue 5, pp. 438\u2013444, Sep. 2018. [29] A. Francillon and C. Castelluccia, \u201cCode Injection Attacks on Harvard-architecture Devices,\u201d Proc. of the 15th ACM Conference on Computer and Communication Security (CCS 2008), Alexandria, CA, USA, Oct. 2008, pp.15\u201326. [30] Nuvoton Inc., \u201cNuMaker-PFM-M2351 User Manual Rev 1.00,\u201d 2018. [31] GitHub, \u201cReturn Instruction Obfuscation,\u201d 2022. https:// github.com/khu-mesl-348/RIO [32] J. Pallister, S. Hollis, and J. Bennett, \u201cBEEBS: Open benchmarks for energy measurements on embedded platforms,\u201d arXiv preprint arXiv:1308.5174, Aug. 2013. https://arxiv.org/abs/ 1308.5174 [33] J. Gustafsson, A. Betts, A. Ermedahl, B. Lisper, \u201cThe M\u00e4lardalen WCET Benchmarks: Past, Present and Future,\u201d Proc. of 10th International Workshop on Worst-Case Execution Time Analysis (WCET 2010), Brussels, Belgium, Apr. 2010, pp. 136\u2013146. [34] M\u00e4lardalen WCET Benchmarks homepage, 2010. www.mrtc. mdh.se/projects/wcet/benchmarks.html\nVOLUME 4, 2016 9\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\nBeomSeok Kim et al.: A Secure Platform Model for Low-end IoT Devices\nBEOMSEOK KIM received his B.S., M.S., and Ph.D. degrees from the Department of computer engineering from Kyung Hee University, Korea, in 2010, 2012, and 2016, respectively. He was an assistant professor at Department of computer software engineering, Changshin University from 2016 to 2018, and a research professor at Department of computer engineering, Kyung Hee University from 2018 to 2019. From 2019\nto 2020, he was a research professor at Department of Computer Science Engineering, Jeonbuk National University. Currently, he is instructor at Department of Computer Engineering, Kyung Hee University. His research interests include wireless sensor & body area networks, embedded systems and network security.\nKIYOUNG LEE received his B.S. degree in Department of electronic engineering from Kookmin University, Korea, in 2014. He is currently M.S. student in Department of computer engineering from Kyung Hee Univerisity, Korea. His research interests include embedded system security, whitebox cryptography and embedded virtualization.\nWOOJIN PARK is currently undergraduate student in Department of computer engineering from Kyung Hee University, Korea. His research interests include embedded system security.\nJINSUNG CHO received the B.S., M.S., and Ph.D. degrees from Seoul National University, South Korea, in 1992, 1994, and 2000, respectively, all in computer engineering. He was a Visiting Researcher with the IBM T. J. Watson Research Center in 1998, and a member of the research staff at Samsung Electronics from 1999 to 2003. He is currently a Professor with the Department of Computer Engineering, Kyung Hee Univer-\nsity, South Korea. His research interests include mobile system security, embedded security, IoT security, and sensor and body networks.\nBEN LEE received the B.E. degree in electrical engineering from the Department of Electrical Engineering, State University of New York, Stony Brook, in 1984, and the Ph.D. degree in computer engineering from Department Electrical and Computer Engineering, Pennsylvania State University, in 1991. He is currently a Professor in the School of Electrical Engineering and Computer Science at Oregon State University.\nHis research interests include multimedia streaming, wireless networks, embedded systems, computer architecture, multithreading and thread-level speculation, and parallel and distributed systems. He was a recipient of the Loyd Carter Award for Outstanding and Inspirational Teaching in 1994, the Alumni Professor Award for Outstanding Contribution to the College and the University from the OSU College of Engineering in 2005, and the HKN Innovation Teaching Award from Eta Kappa Nu, School of Electrical Engineering and Computer Science in 2008. He has been on the program committees and organizing committee for numerous international conferences including the 2005-2012 IEEE Workshop on Pervasive Wireless Networking, and the IEEE International Conference on Pervasive Computing and Communications (PerCom). He was the Workshop Chair for PerCom 2009. He was a Guest Editor for the Special Issue on Wireless Networks and Pervasive Computing of the Journal of Pervasive Computing and Communications. He was also an Invited Speaker at the 2007 International Conference on Embedded Software and System and a Keynote Speaker at the 2014 ACM International Conference on Ubiquitous Information Management and Communication. He was the TPC Chair and the General Chair at 2018 and 2020 IEEE Consumer Communications and Networking Conference (CCNC), respectively."
        },
        {
            "heading": "10 VOLUME 4, 2016",
            "text": "This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/"
        }
    ],
    "title": "RIO: Return Instruction Obfuscation for Bare-metal IoT Devices",
    "year": 2023
}