{
    "abstractText": "On the basis of numerous fluid simulation experiences, researchers have discovered that many common operations can be abstracted to form a general fluid simulation framework. These operations include the discretization of equations and variables, the computation of the coefficients, the assembly of the linear or nonlinear systems, the solving of the systems, etc. Furthermore, all of the operations can be attributed to the operations \u201cin the field\u201d, which is an abstract concept derived from the equations and variables. Thus, fluid simulations can be performed under a field-based general framework. Moreover, in response to the urgent need for large-scale fluid simulations, parallelism is integrated into the framework. Due to the convenience of the field operations, parallelization of the framework can be realized on both the OpenMP and MPI levels. In other words, because of the newly defined \u201cfields\u201d, a series of operations in fluid simulations can be simplified and unified. However, very few studies have noted this advantage, and therefore, this work attempts to fill the void. With the help of a field-based general framework, it is anticipated that the parallel codes of fluid simulations can be generated easily and quickly. As an application of the general framework, a parallel 3D simulator for matrix acidization called Masor is developed. The simulation results are regarded as physically reasonable by many studies, which verifies the correctness and effectiveness of the general framework. In addition, it is noteworthy that the parallel performance of Masor is decided by a solver.",
    "authors": [
        {
            "affiliations": [],
            "name": "Yuanqing WuID"
        },
        {
            "affiliations": [],
            "name": "Shuyu Sun"
        }
    ],
    "id": "SP:a684a7c27c096c3e2f4b6bc3ee4f8d707ca44f2f",
    "references": [
        {
            "authors": [
                "Kajishima Takeo",
                "Taira Kunihiko"
            ],
            "title": "Computational fluid dynamics.",
            "venue": "Cham: Springer International Publishing",
            "year": 2017
        },
        {
            "authors": [
                "Tu Jiyuan",
                "Guan Heng Yeoh",
                "Chaoqun Liu"
            ],
            "title": "Computational fluid dynamics: a practical approach",
            "year": 2018
        },
        {
            "authors": [
                "Demmel James"
            ],
            "title": "LAPACK: A portable linear algebra library for high-performance computers.\" Concurrency: Practice and Experience",
            "year": 1991
        },
        {
            "authors": [
                "A. Davis Timothy"
            ],
            "title": "UMFPACK version 5.2. 0 user guide.",
            "venue": "University of Florida",
            "year": 2007
        },
        {
            "authors": [
                "R. Amestoy Patrick",
                "S. Duff Iain",
                "J-Y. L\u2019excellent"
            ],
            "title": "Multifrontal parallel distributed symmetric and unsymmetric solvers.\" Computer methods in applied mechanics and engineering",
            "year": 2000
        },
        {
            "authors": [
                "Falgout",
                "Robert D",
                "Ulrike Meier Yang"
            ],
            "title": "hypre: A library of high performance preconditioners.",
            "venue": "International Conference on Computational Science",
            "year": 2002
        },
        {
            "authors": [
                "Lie Knut-Andreas"
            ],
            "title": "An introduction to reservoir simulation using MATLAB/GNU Octave: User guide for the MATLAB Reservoir Simulation Toolbox (MRST)",
            "year": 2019
        },
        {
            "authors": [
                "Ning Like"
            ],
            "title": "A review of fully coupled atmosphere-hydrology simulations.",
            "venue": "Journal of Geographical Sciences 29",
            "year": 2019
        },
        {
            "authors": [
                "D Dueben Peter"
            ],
            "title": "Global simulations of the atmosphere at 1.45 km grid-spacing with the Integrated Forecasting System.\" Journal of the Meteorological Society of Japan",
            "year": 2020
        },
        {
            "authors": [
                "Du Chuanbin",
                "Liang Dong"
            ],
            "title": "An efficient S-DDM iterative approach for compressible contamination fluid flows in porous media.",
            "venue": "Journal of Computational Physics 229",
            "year": 2010
        },
        {
            "authors": [
                "Ahadi Mina",
                "Bergstrom Donald J",
                "Kerry Anne Mazurek"
            ],
            "title": "Computational Fluid-Dynamics Modeling of the Flow and Sediment Transport in Stormwater Retention Ponds: A Review.",
            "venue": "Journal of Environmental Engineering 146",
            "year": 2020
        },
        {
            "authors": [
                "Mian",
                "Haris Hameed",
                "Gang Wang",
                "Muhammad Aamir Raza"
            ],
            "title": "Application and validation of HUNS3D flow solver for aerodynamic drag prediction cases.",
            "venue": "Proceedings of 2013 10th International Bhurban Conference on Applied Sciences & Technology (IBCAST). IEEE,",
            "year": 2013
        },
        {
            "authors": [
                "Ma",
                "Boping"
            ],
            "title": "Near field sonic boom analysis with HUNS3D solver.",
            "venue": "55th AIAA Aerospace Sciences Meeting",
            "year": 2017
        },
        {
            "authors": [
                "Jin Haoqiang",
                "Frumkin Michael",
                "Yan Jerry"
            ],
            "title": "Automatic generation of OpenMP directives and its application to computational fluid dynamics codes.",
            "venue": "International Symposium on High Performance Computing",
            "year": 2000
        },
        {
            "authors": [
                "Thomas Jeffrey"
            ],
            "title": "Unsteady flow computation using a harmonic balance approach implemented about the OVERFLOW 2 flow solver.",
            "venue": "19th AIAA Computational Fluid Dynamics",
            "year": 2009
        },
        {
            "authors": [
                "M. Derlaga Joseph",
                "W. Jackson Charles",
                "G. Buning Pieter"
            ],
            "title": "Recent Progress in OVERFLOW Convergence Improvements.",
            "venue": "AIAA Scitech",
            "year": 2020
        },
        {
            "authors": [
                "F Rego"
            ],
            "title": "FIRE PARADOX: an innovative approach of integrated wildland fire management\u2013a joint European initiative.",
            "venue": "Proceeding of 4th International Wildland Fire Conference",
            "year": 2007
        },
        {
            "authors": [
                "M. Fernandes Paulo",
                "C. Rego Francisco",
                "Eric. Rigolot"
            ],
            "title": "The FIRE PARADOX project: towards science-based fire management in Europe.\" Forest ecology and management 261",
            "year": 2011
        },
        {
            "authors": [
                "J Berger Marsha"
            ],
            "title": "Performance of a new CFD flow solver using a hybrid programming paradigm.",
            "venue": "Journal of Parallel and Distributed Computing 65",
            "year": 2005
        },
        {
            "authors": [
                "Jin Haoqiang"
            ],
            "title": "High performance computing using MPI and OpenMP on multi-core parallel systems.",
            "venue": "Parallel Computing 37",
            "year": 2011
        },
        {
            "authors": [
                "J Hawkes"
            ],
            "title": "Performance analysis of massively-parallel computational fluid dynamics.",
            "year": 2014
        },
        {
            "authors": [
                "N Gourdain"
            ],
            "title": "High performance parallel computing of flows in complex geometries: I",
            "venue": "Computational Science & Discovery",
            "year": 2009
        },
        {
            "authors": [
                "N Gourdain"
            ],
            "title": "High performance parallel computing of flows in complex geometries: II. Applications.",
            "venue": "Computational Science & Discovery",
            "year": 2009
        },
        {
            "authors": [
                "Yao Jixian"
            ],
            "title": "Unsteady flow investigations in an axial turbine using the massively parallel flow solver TFLO.\" 39th Aerospace Sciences Meeting and Exhibit",
            "year": 2001
        },
        {
            "authors": [
                "Jia Rongguang",
                "Bengt Sund\u00e9n"
            ],
            "title": "Parallelization of a multi-blocked CFD code via three strategies for fluid flow and heat transfer analysis.",
            "venue": "Computers & fluids 33",
            "year": 2004
        },
        {
            "authors": [
                "Chen Goong"
            ],
            "title": "OpenFOAM for computational fluid dynamics.",
            "venue": "Notices of the AMS 61",
            "year": 2014
        },
        {
            "authors": [
                "Constant Eddy"
            ],
            "title": "An immersed boundary method in OpenFOAM: verification and validation.",
            "venue": "Computers & Fluids",
            "year": 2017
        },
        {
            "authors": [
                "Basermann Achim"
            ],
            "title": "HICFD: highly efficient implementation of CFD codes for HPC Many-Core architectures.\" Competence in High Performance Computing",
            "year": 2010
        },
        {
            "authors": [
                "Shang Zhi"
            ],
            "title": "High performance computing for flood simulation using Telemac based on hybrid MPI/ OpenMp parallel programming.",
            "venue": "International Journal of Modeling, Simulation, and Scientific Computing",
            "year": 2014
        },
        {
            "authors": [
                "Dong Suchuan",
                "George Em Karniadakis"
            ],
            "title": "Dual-level parallelism for high-order CFD methods.",
            "venue": "Parallel Computing",
            "year": 2004
        },
        {
            "authors": [
                "Vajdi Mohammad"
            ],
            "title": "A review on the Comsol Multiphysics studies of heat transfer in advanced ceramics.",
            "venue": "Journal of Composites and Compounds",
            "year": 2020
        },
        {
            "authors": [
                "Zandi Soma",
                "Saxena Prateek",
                "Gorji Nima E"
            ],
            "title": "Numerical simulation of heat distribution in RGO-contacted perovskite solar cells using COMSOL.",
            "venue": "Solar Energy",
            "year": 2020
        },
        {
            "authors": [
                "Ayguade Eduard"
            ],
            "title": "Employing nested OpenMP for the parallelization of multi-zone computational fluid dynamics applications.",
            "venue": "18th International Parallel and Distributed Processing Symposium,",
            "year": 2004
        },
        {
            "authors": [
                "R de Supinski Bronis"
            ],
            "title": "The ongoing evolution of openmp.",
            "venue": "Proceedings of the IEEE 106",
            "year": 2018
        },
        {
            "authors": [
                "Wu Yuanqing",
                "Salama Amgad",
                "Sun Shuyu"
            ],
            "title": "Parallel simulation of wormhole propagation with the Darcy\u2013Brinkman\u2013Forchheimer framework.",
            "venue": "Computers and Geotechnics",
            "year": 2015
        },
        {
            "authors": [
                "Wu Yuanqing"
            ],
            "title": "Parallel Reservoir Simulations with Sparse Grid Techniques and Applications to Wormhole Propagation",
            "year": 2015
        },
        {
            "authors": [
                "Kou Jisheng",
                "Sun Shuyu",
                "Wu Yuanqing"
            ],
            "title": "Mixed finite element-based fully conservative methods for simulating wormhole propagation.",
            "venue": "Computer Methods in Applied Mechanics and Engineering",
            "year": 2016
        },
        {
            "authors": [
                "Kou Jisheng",
                "Sun Shuyu",
                "Wu Yuanqing"
            ],
            "title": "A semi-analytic porosity evolution scheme for simulating wormhole propagation with the Darcy\u2013Brinkman\u2013Forchheimer model.",
            "venue": "Journal of Computational and Applied Mathematics",
            "year": 2019
        },
        {
            "authors": [
                "Wu Yuanqing",
                "Ye Maoqing"
            ],
            "title": "A Newton\u2019s second law abided Darcy-Brinkman-Forchheimer framework in matrix acidization simulation.",
            "venue": "International Conference on Computational & Experimental Engineering and Sciences",
            "year": 2019
        },
        {
            "authors": [
                "Wu Yuanqing"
            ],
            "title": "Thermodynamically consistent Darcy\u2013Brinkman\u2013Forchheimer framework in matrix acidization.\" Oil & Gas Science and Technology\u2013Revue d\u2019IFP Energies nouvelles",
            "year": 2021
        },
        {
            "authors": [
                "Pacheco Peter"
            ],
            "title": "Parallel programming with MPI",
            "year": 1997
        },
        {
            "authors": [
                "Gropp William"
            ],
            "title": "Using MPI: portable parallel programming with the message-passing interface",
            "venue": "Vol. 1. MIT press,",
            "year": 1999
        },
        {
            "authors": [
                "O. Akanni Olatokunbo",
                "A. Nasr-El-Din Hisham",
                "Deepak"
            ],
            "title": "Gusain. \"A computational Navier-Stokes fluid-dynamics-simulation study of wormhole propagation in carbonate-matrix acidizing and analysis of factors influencing the dissolution process.",
            "venue": "SPE Journal 22",
            "year": 2017
        },
        {
            "authors": [
                "Wu Yuanqing"
            ],
            "title": "A Decoupled Scheme to Solve the Mass and Momentum Conservation Equations of the Improved Darcy-Brinkman-Forchheimer Framework in Matrix Acidization.",
            "year": 2008
        },
        {
            "authors": [
                "P. Raju Mandhapati"
            ],
            "title": "Parallel computation of finite element Navier-Stokes codes using MUMPS solver.",
            "venue": "arXiv preprint arXiv:0910.1845",
            "year": 2009
        }
    ],
    "sections": [
        {
            "text": "On the basis of numerous fluid simulation experiences, researchers have discovered that\nmany common operations can be abstracted to form a general fluid simulation framework.\nThese operations include the discretization of equations and variables, the computation of\nthe coefficients, the assembly of the linear or nonlinear systems, the solving of the systems,\netc. Furthermore, all of the operations can be attributed to the operations \u201cin the field\u201d, which\nis an abstract concept derived from the equations and variables. Thus, fluid simulations can\nbe performed under a field-based general framework. Moreover, in response to the urgent\nneed for large-scale fluid simulations, parallelism is integrated into the framework. Due to\nthe convenience of the field operations, parallelization of the framework can be realized on\nboth the OpenMP and MPI levels. In other words, because of the newly defined \u201cfields\u201d, a\nseries of operations in fluid simulations can be simplified and unified. However, very few\nstudies have noted this advantage, and therefore, this work attempts to fill the void. With the\nhelp of a field-based general framework, it is anticipated that the parallel codes of fluid simu-\nlations can be generated easily and quickly. As an application of the general framework, a\nparallel 3D simulator for matrix acidization called Masor is developed. The simulation results\nare regarded as physically reasonable by many studies, which verifies the correctness and\neffectiveness of the general framework. In addition, it is noteworthy that the parallel perfor-\nmance of Masor is decided by a solver."
        },
        {
            "heading": "1. Introduction",
            "text": "Computational fluid dynamics (CFD) [1, 2] focuses on the numerical simulation of fluids using computer technology. The general procedure undertaken for this kind of simulation is to first discretize the mathematical model with numerical schemes. After this step, if there are some implicit schemes used, a series of linear systems are formed. Although some works may generate nonlinear systems and use Newton\u2019s method to solve them, this work will not consider these types of conditions. Because linear systems are sparse, the second step is to compute\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 1 / 25\na1111111111 a1111111111 a1111111111\nOPEN ACCESS\nCitation: Wu Y, Sun S (2022) A field-based general framework to simulate fluids in parallel and the framework\u2019s application to a matrix acidization simulation. PLoS ONE 17(2): e0261134. https:// doi.org/10.1371/journal.pone.0261134\nEditor: Mohammadreza Hadizadeh, Central State University & Ohio University, UNITED STATES\nReceived: July 24, 2021\nAccepted: November 24, 2021\nPublished: February 3, 2022\nCopyright: \u00a9 2022 Wu, Sun. This is an open access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.\nData Availability Statement: All relevant data are within the manuscript and its Supporting Information files.\nFunding: This work is supported by General Program of Natural Science Foundation of Shenzhen (No. 20200801100615003), and Peacock Plan Foundation of Shenzhen (No. 000255).\nCompeting interests: The authors have declared that no competing interests exist.\nthe nonzero entries of the coefficient matrix and the right-hand-side vector of the linear system. Once the linear systems are prepared, the third step is to solve them with appropriate solvers such as LAPACK [3], UMFPACK [4], MUMPS [5] and HYPRE [6] for the variable values at the next time step. Of course, if some variable values at the next time step can be calculated with fully explicit schemes, no corresponding linear systems for the variables exist, and they must be obtained directly from the explicit expressions. The three steps loop until the desired simulation results are achieved. Thus, the simulation procedure, in reality, involves constructing the linear systems and then solving them, which is a procedure that applies to most applications of computational fluid dynamics. With this philosophy, a general framework to simulate fluid dynamics is suggested in this work. Here, \u201cgeneral\u201d means that the framework is not designed for any specific applications of fluid dynamics. Instead, the code of any specific application is easily and quickly generated by the framework. In addition, practical fluid simulations often come from large-scale projects, such as reservoir simulations ([7\u20139]), atmosphere simulations [10, 11] and environmental simulations [12, 13], which necessitates the application of parallel computing technology to accelerate the simulations. In parallelization, one key issue is determining ways to perform domain decompositions and then determining how to assemble the information on different processors. In addition, leveraging the threads in a processor to achieve high speeds is the other key issue. In this work, the general framework is parallelized on both levels of threads (OpenMP) and processors (MPI).\nFrom the discussion above, it is surmised that the main operations in this framework\ninclude the discretization of the equations and variables, the computation of the coefficients, the assembly of the linear systems, the solving of the systems, etc., and it is assumed that all the operations are done on the fields. Thus, the general framework is in reality the union of all the operations on the field elements, i.e., it is a field-based general framework. A field is a subset of a grid. Some grid elements can be selected to form a field, and these grid elements are also called field elements. For example, if there is a 3D regular grid, the x-direction faces, the ydirection faces, the z-direction faces and the center of all the grid cells are the grid elements. All the x-direction faces can form a field, and each of the x-direction faces is a field element. Here, the x-direction face is defined as the cell face that is perpendicular to the x-axis of the coordinate, and the y-direction and z-direction faces have similar definitions. All the discretized variables (DVs) imposed on a field are called the variable fields, and all the algebraic equations (AEs) imposed on a field are called the equation fields.\nBefore looking into the details of this work, it is necessary to give a brief review of the state-\nof-art CFD simulators. Generally, most of the simulators can be run in parallel. However, in a variation of this framework, which can be parallelized with both OpenMP and MPI, some simulators can be parallelized only with either OpenMP or MPI. The simulators parallelized only with OpenMP include HUNS3D [14, 15], ARC3D [16], OVERFLOW [17, 18], FIRE PARADOX [19, 20], etc., and they can be applied in the fields of viscous flow simulations, aerophysics simulations, the design of airfoils and the management of forest fires. This level of parallelization is easy to achieve, and the load of the threads is light [21]. However, its parallel performance when dealing with large-scale simulations is not adequate [22]. Thus, simulators parallelized with MPI are more popular in those conditions. The simulators parallelized only with MPI include ReFESCO [23], elsA [24, 25], TFLO [26], CALC-MP [27], OpenFOAM [28, 29], etc., and they can be used to simulate multiphase viscous flows, the flow behavior in complicated geometries, turbomachinery flows, fluid flows, heat transfers and structural analyses. With the progress of parallelization technology, OpenMP and MPI hybrid simulators have emerged, such as TAU [30], Telemac [31], NetKar [32] and COMSOL [33, 34]. These simulators are trustworthy tools to simulate external flows, environmental flood flows, turbulent flows past a circular cylinder and heat transfers. By hybrid parallelization, both of the\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 2 / 25\nadvantages of OpenMP and MPI can be leveraged, and the parallel performance is further enhanced. Although the concept of the field operation appears in OpenFOAM, it is applied only in the discretization operation. This work further applies the field concept in the operations of coefficient computing and the assembly of the linear system, which covers more of the simulation procedure. The domain decomposition in OpenFOAM is achieved with the help of MPI, which is more or less the same as the hybrid simulators including the general framework in this paper. However, only some code snippets, such as the loops, are parallelized by OpenMP in the former hybrid simulators, which limits the application of OpenMP and reduces the parallel efficiency. In contrast, the general framework in this work applies OpenMP in the entire coefficient computing routine, which greatly improves the parallel efficiency on the thread level.\nThis work is organized as follows: Section 1 is an introduction to the general ideas of the\nframework. Section 2 and Section 3 introduce the discretization library and the coefficient library of this framework, respectively. Section 4 will detail how to construct the linear system, and Section 5 will give the parallelization strategy. Section 6 presents the construction of Masor, which is a matrix acidization simulator developed based on the general framework. The conclusion of this work is in Section 7."
        },
        {
            "heading": "2. The discretization library",
            "text": "According to different application conditions, different mathematical models are proposed to simulate the fluids. However, all the models are derived from the same physical laws, i.e., the mass conservation law, the momentum conservation law, the energy conservation law, etc. As a result, the mass conservation equation, the momentum conservation equation, the energy conservation equation, etc., are formed. For this reason, these equations are composed of similar terms, with each of them representing various physical meanings, although they may have different expressions in different models. For example, almost all the mass conservation equations have the divergence term, which describes the mass diffusion in space. The few differences among the mass conservation equations of different models may only lie in the coefficient of the divergence term and the constant term. Moreover, even in the model itself, the divergence term may exist in different equations, for instance, they may exist in the mass conservation equation and the momentum conservation equation. Thus, for any model, the discretization of the equations can be deemed the discretization of the terms. As a result, there exist common discretization patterns that can describe the discretization of most of the equations. This motivates us to develop the discretization library, which is composed of all the common discretization patterns for the equations.\nIn addition to the fact that the equations need to be discretized, the variables also need to be\ndiscretized. In other words, discretization can be classified into two categories, discretization of the equations and discretization of the variables. When the finite difference method is used for discretization, the entire simulation domain is divided into a regular grid, and the discretized equations and variables are imposed either at the center of the cell or on the face of the cell. For example, variables such as pressure, concentration and temperature are often imposed at the center of the cell, and velocity is often imposed on the face of the cell. The upwind scheme and harmonic method can be used to derive the variable values on the face of the cell if they are imposed at the center of the cell. Although there are other discretization schemes, such as finite element methods, and the discretization can be done in a triangular mesh, these schemes will not be discussed in this work.\nWith this philosophy, discretization can be deemed an operation on the equation and the\nvariable, irrespective of their physical meanings. The equations can be discretized at the center\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 3 / 25\nor on the face of the cell, and the variables can also be discretized in that way, so there are various discretization types. The discretization type can be represented by the letters x, y, z and p, which represent discretization on the x-direction face, the y-direction face, the z-direction face and at the center of the cell, respectively. Moreover, when the discretization type of an equation is given, the discretized positions of all the variables of the equation can then be decided. For example, if the equation below is discretized at the center of a cell, which has the discretization type p, then:\n@p @t \u00fer \ufffd u \u00bc 0; \u00f01\u00de\nThe variable p is discretized at the center of the cell, and the variable u is discretized on all the faces of the cell. The discretized positions of a variable in an equation constitute its discretization configuration. For a variable, its variable discretization configuration in an equation may be the same as its variable discretization configuration in a term. For example, the variable discretization configuration of u in Equation (1) is the same as that in the divergence term. Thus, the name of the variable discretization configuration can be represented by the abbreviations of the name of the term. For example, div, gra, lap and der are the abbreviations of the terms divergence, gradient, Laplace and derivative, respectively, which can be used to represent the corresponding variable discretization configuration of an equation. Different combinations of the discretization type and discretization configuration form different discretization patterns of which the discretization library is composed. In other words, a discretization pattern can be defined by a triple term, as in:\n<equation discretization type, variable discretization type, variable discretization\nconfiguration>.\nIn the code of the discretization library, the subroutines recognize the discretization pat-\nterns, and the naming rule of the subroutines can be determined in a rational pattern. For example, in the subroutine name \u201cdctz_pxdiv\u201d, \u201cdctz\u201d stands for the meaning of discretization, and \u201cpxdiv\u201d is the triple to represent the discretization pattern. Thus, the subroutine name \u201cdctz_pxdiv\u201d means that the equation is discretized at the center of the cell, and the variable is discretized on the x-direction face of the cell. The variable discretization configuration in the equation is the same as that in the divergence term. All the other subroutines obey the same naming rule.\nTo clarify the use of the discretization library, the discretization of the momentum conser-\nvation equation in the matrix acidization simulation can be taken as an example. The equation is shown as below:\nrf @ @t u \ufffd\n\ufffd \ufffd\n\u00fe rf u \ufffd \ufffd r u \ufffd \u00bc rp m K u\u00fer \ufffd mr u \ufffd rf F ffiffiffiffi K p juju\u00fe rf g: \u00f02\u00de\nSince the physical meanings of the variables are not important to the discretization of the equation, they will not be given here. The unknown variables of the equation are the scalar p and the vector u, and all the other variables are supposed to be known and become the coefficients of the equation. In fact, the equation can be discretized in the x-, y-, and z-directions. When the equation is discretized in the x-direction, a discretized equation can be imposed on an xdirection face f. In this condition, p is discretized at the center of the two cells with f being their common face, which can be shown by Fig 1. Thus, the subroutine \u201cdctz_xpgra\u201d is used to discretize p in the equation. u is discretized on the x-direction face, which makes u degenerate into its x-direction component ux in the discretized equation. In the first term and the fourth term, ux is imposed on the face f. In the second term, there are two u, where the left u can be\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 4 / 25\ndeemed known and the right u can be deemed unknown. Thus, ux is imposed on the face f and either adjacent face of f in the x-direction if the upwind scheme is used. The fifth term is in reality a Laplace term, and therefore, ux is imposed on the face f and all its adjacent faces in all three directions, in which there are seven faces in total. The sixth term also has two u, and only the right u is unknown. Thus, ux is imposed on the face f. From the discussion, it is learned that the variable discretization configuration of ux in the equation should be the same as that in the Laplace term, which is shown in Fig 2. Thus, the subroutine \u201cdctz_xxlap\u201d is used to discretize ux in the equation. With the same idea, the subroutine \u201cdctz_yylap\u201d can be used to discretize uy in the equation, and the subroutine \u201cdctz_zzlap\u201d can be used to discretize uz in the equation, in which uy and uz stand for the y-direction and z-direction components of u, respectively. More details of the discretization library can be seen in Section 6."
        },
        {
            "heading": "3. The coefficient library",
            "text": "The equations in the mathematical model are often partial differential equations (PDEs). After discretization, these PDEs become AEs. Some AEs can be collected and arranged in a certain order to form a linear system. When the unknown variables of the linear system are defined, the coefficients of the unknown variables are the nonzero entries of the coefficient matrix, and the terms without unknown variables form the right-hand-side vector. Thus, the next step is to compute the coefficients and the right-hand-side vector.\nTraditionally, the expressions of the coefficients and right-hand-side vector have to be\ngiven by hand before obtaining their values. However, this method wastes time when deriving the expressions and is error prone. Thus, a more straightforward method is proposed to avoid these issues. It is noted that an AE in a linear system is in reality a linear AE in this work, whose general expression can be written as:\nai1x1 \u00fe ai2x2 \u00fe ai3x3 \u00fe \ufffd \ufffd \ufffd \u00fe ainxn bi \u00bc 0; i \u00bc 1; 2; . . . ; n; \u00f03\u00de\nif there are n variables in the linear system. In Eq (3), x stands for the variable, a stands for the coefficient of x and b stands for the right-hand-side vector. With the traditional idea, a and b are known, and x can be calculated from a and b. However, in the opposite way, if x is known, a and b can also be calculated from x. More concretely, if all the x are set to be zero, the left-\nhttps://doi.org/10.1371/journal.pone.0261134.g001\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 5 / 25\nhand side of (3) equals with \u2212bi; if xj is set to be one, and all the other x are set to be zero, the left-hand side of (3) equals with aij\u2212bi. Since bi has been known, aij can also be known. In this way, the coefficients and right-hand-side vector can be calculated directly from Eq (3) without the step of deriving their expressions.\nIf it is deemed an iteration that sets xj as one and the other x as zero, j = 1,2,. . .,n, and setting all the x as zero is also an iteration, a total of n+1 iterations are needed to obtain the values of all the coefficients and the right-hand-side vector, with the method above. However, the number of iterations can be reduced further by the improvement below. For the convenience of the following discussion, b is put to the right-hand side of (3), and there is:\nai1x1 \u00fe ai2x2 \u00fe ai3x3 \u00fe \ufffd \ufffd \ufffd \u00fe ainxn \u00bc bi; i \u00bc 1; 2; . . . ; n: \u00f04\u00de\nFor xj, not all the AEs contain it. Those AEs that contain xj can be called the neighborhood of xj. It is observed that if the neighborhoods of two x overlap, the two x cannot be set as one simultaneously to achieve their corresponding coefficients in the overlapped equation, since in that condition, the left-hand side of Eq (4) equals the sum of their coefficients. For example, if both x1 and x2 are set as one in one of their overlapped equations, the left-hand side of the\nhttps://doi.org/10.1371/journal.pone.0261134.g002\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 6 / 25\noverlapped equation in the form of Eq (4) equals, ai1+ai2, from which ai1 and ai2 cannot be calculated, respectively. In other words, for all x that do not have overlapping neighborhoods, they can be set as one simultaneously to achieve a group of coefficients. In this way, the total number of iterations to achieve all the coefficients and the right-hand-side vector is reduced to the number of groups of x that do not have overlapping neighborhoods. In fact, there are many ways to divide all the x into such groups. However, the way that produces the minimal number of groups is the most interesting, since in that way all the coefficients and right-hand-side vector can be achieved with the minimal number of iterations. For example, it is supposed that a kind of variable is discretized with the pattern \u201cxxlap\u201d. For the DV imposed on the x-direction face f, its neighborhood is composed of seven equations that are imposed on the face f and six adjacent x-direction faces of f. In that condition, the two DVs separated by the other two DVs can be put in a group g111. Then, shifting every DV in this group for one position in the x-direction generates another group g211 of this kind. Furthermore, shifting every DV in g211 for one position in the x-direction generates another group g311. In the same way, it is easy to see that g411 is the same as g111; therefore, no further shifting is needed. This kind of shifting can also be done in the y-direction and z-direction, respectively, which generates twenty-seven groups in total. Fig 3 gives a two-dimensional sketch of this kind of shifting. It is easy to see that the other ways to divide all the DVs will give a larger\nhttps://doi.org/10.1371/journal.pone.0261134.g003\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 7 / 25\nnumber of groups. Thus, only twenty-seven iterations are enough to achieve all the coefficients and right-hand-side vectors, which is a great improvement. From the discussion above, a more general conclusion is that the minimal number of groups of a variable depends on the discretization pattern of the variable. The subroutine \u201cgenExpField\u201d is used to generate all such groups. In addition to the fact that the number of iterations can be greatly reduced, the improvement method above has the other advantage, which makes the task to achieve the coefficients and right-hand-side vector to be done in parallel. Every DV in a group can be allocated a thread to achieve all its relative coefficients, which is done in parallel on the level of threads and can be done by OpenMP [35, 36].\nIn the code, all the subroutines to compute the coefficients, the right-hand-side vector and\nthe subroutine \u201cgenExpField\u201d comprise the coefficient library. It is observed that in Eq (3), if all x are the solutions of the equation, the left-hand side of Eq (3) equals its right-hand side, whose difference is zero. However, if x is not the solution of the equation, there is a difference between the left-hand side and right-hand side of the equation, which is termed the residual of the equation. The coefficient computing method above is in fact a procedure to compute the residuals of the equation under different x. Thus, the naming rule of the subroutine in the coefficient library can be set as \u201cResi_equation name_variable name\u201d. Here, \u201cResi\u201d is the abbreviation of \u201cresidual\u201d. For example, the subroutine \u201cResi_xmom_vx\u201d can be used to compute the coefficients of the x-direction velocity variables in the x-direction momentum conservation equation of (2).\nSince different mathematical models have different PDEs, there are no common subrou-\ntines that can be used to compute the coefficients of all the models. Thus, the coefficient library is open, which means that numerous coefficient computing routines have to be developed by the programmer according to different PDEs. However, the coefficient library will stipulate a unified specification for all routines."
        },
        {
            "heading": "4. The linear system library",
            "text": "A linear system can be constructed from one or more PDEs. For example, after discretization, the concentration equation in the DBF model ([37\u201342]):\n@\u00f0\ufffdCf \u00de @t \u00fer \ufffd uCf \ufffd \ufffd \u00bc r \ufffd \ufffdDe \ufffd rCf \ufffd \ufffd kcav Cf Cs \ufffd \ufffd ; \u00f05\u00de\nwhich is a PDE, forms a linear system, by which the acid concentration can be achieved. However, another linear system in the DBF model, which is the velocity-pressure linear system, is constructed from two PDEs, the momentum conservation equation and the mass conservation equation. All the PDEs may have different discretization positions, either at the center of the cells or on the faces of the cells. Thus, in the linear system, it is stipulated that the AEs imposed on the x-direction faces are put into it first, and then the AEs imposed on the y-direction faces, z-direction faces and at the center of the cells are put into it one after another. The DVs are put into the unknown vector in the same order. If more than one PDE is discretized on the xdirection faces, for example, the order should be that the AEs discretized from the first PDE are put into the linear system first, followed by those from the second PDE, and so on. This rule is the same for the condition of the DVs. Fig 4 shows the linear system Ax = b, where A stands for the coefficient matrix, x stands for the unknown vector and b stands for the righthand-side vector.\nThe row number of an AE in the linear system is called its index. The row number of a DV\nin the unknown vector of the linear system is called its index, or the column number of a DV in the coefficient matrix is called its index. All the x-direction faces in the regular grid form the\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 8 / 25\nx-direction field, and in the same way, the y-direction field and the z-direction field can be formed. All the center of the cells form the center field. Every element of the field has its own coordinates in the field. Since all the AEs and DVs are imposed on the field elements, their indices can be derived from the indices of the field elements. For example, if a regular grid has 4, 8, and 16 cells in the x-, y- and z-directions, respectively, the index of the field element with coordinates (2,3,5) in the center field should be:\n\u00f04\u00fe 1\u00de \ufffd 8\ufffd 16\u00fe 4\ufffd \u00f08\u00fe 1\u00de \ufffd 16\u00fe 4\ufffd 8\ufffd \u00f016\u00fe 1\u00de \u00fe 4\ufffd 8\ufffd \u00f05 1\u00de\n\u00fe 4\ufffd \u00f03 1\u00de \u00fe 2 \u00bc 1898: \u00f06\u00de\nHere, it is stipulated that all the coordinate entries are natural numbers and that the elements of a field are counted in the order of the x-, y-, and z-directions, which means that the element with the coordinate (1,1,1) is counted first, followed by the element with the coordinate (2,1,1), (3,1,1), and so on. The first three terms of (6) represent the element amounts of the x-, y-, and z-direction fields, respectively. Thus, the AE or DV imposed on this element has an index of 1898 if no more than one PDE or variable is imposed on the element of the center field. The index computing is finished by the subroutine \u201ccoordiToGlobalInd\u201d, which will be discussed in more detail later. In fact, the row number of the nonzero entry of the coefficient matrix is the equation index, and the column number is the DV index. Thus, when the two kinds of indices are achieved, the positions of the nonzero entries in the coefficient matrix can be obtained. Since the values of all the nonzero entries of the coefficient matrix and the righthand-side vector have been known with the help of the coefficient library, the construction of the linear system is completed. The routine \u201csetMatValue\u201d is designed to carry out all these steps.\nIn the code, the coefficient matrix is stored in many arrays. All the coefficients of a variable in a PDE should be stored in one array. For example, all the coefficients of the variable p in Eq (2) should be stored in one array, and all the coefficients of the variables ux, uy and uz in Eq (2) should be stored in the other three arrays. If Eq (1) is combined with Eq (2) to form a linear system, another four arrays are needed to store the coefficients of the variables p, ux, uy and uz in Eq (1). In addition, some auxiliary arrays are introduced to accelerate the position location of the coefficients in the array. An example is given as following. If the array \u201cAxxValues\u201d is used to store the coefficients of ux in Eq (2), the arrays \u201cAxxRows\u201d, \u201cAxxCols\u201d, \u201cAxxBase\u201d and\nhttps://doi.org/10.1371/journal.pone.0261134.g004\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 9 / 25\n\u201cAxxNum\u201d are the auxiliary arrays. The first two auxiliary arrays are used to store the row numbers and the column numbers of the coefficients. In that case, AxxRows[i] and AxxCols[i] represent the row number and the column number of AxxValues[i], respectively. Here, \u201ci\u201d is the index of the array entry. It is easy to see that the size of \u201cAxxValues\u201d, \u201cAxxRows\u201d and \u201cAxxCols\u201d equals the number of coefficients of ux. The coefficients of the AE with a smaller index should be put into \u201cAxxValues\u201d before those of the AE with a larger index. Meanwhile, the coefficient of the DV with a smaller index should be put into \u201cAxxValues\u201d before that of the DV with a larger index. In this way, a coefficient can be located in \u201cAxxValues\u201d if its row number and column number are known. The search begins with the head of the array \u201cAxxRows\u201d and stops when it meets the first entry that equals the row number of the searched coefficient. If the index of the entry is \u201ci\u201d, the search then goes to the subarray (from AxxCols[i] to the tail of \u201cAxxCols\u201d) to search for the column number. If the index of the searched column number is \u201cj\u201d, AxxValues[j] is the searched coefficient. The search in \u201cAxxCols\u201d can be finished with a time complexity of O(1). However, the search in \u201cAxxRows\u201d begins with the array head, which leads to the time complexity of O(n). To reduce the time complexity of the search in \u201cAxxRows\u201d to O(1), the arrays \u201cAxxBase\u201d and \u201cAxxNum\u201d are introduced. In the two arrays, the index of the entry represents the index of the AE, and therefore, the size of the two arrays equals the number of AEs. AxxBase[i] records the initial position of the coefficients of ux of the i-th AE in \u201cAxxValues\u201d, and AxxNum[i] records the number of coefficients of ux of the i-th AE. With the help of the two arrays, the search in \u201cAxxRows\u201d, \u201cAxxCols\u201d and \u201cAxxValues\u201d can begin with the index AxxBase[i] for the i-th AE and stop at the index AxxBase[i]+AxxNum[i]. As a result, the search for a coefficient in \u201cAxxValues\u201d can be finished in a time complexity of O(1). The arrays can be shown in Fig 5. When discretizing Eq (2) in the x-direction, the first AE of Eq (2) is located on the x-direction face with coordinates (1,1,1), and it has four coefficients of ux. Thus, if the index of the AE is one, the first four entries of \u201cAxxRows\u201d have values of one, the first four entries of \u201cAxxCols\u201d store the column numbers of the coefficients and the first four entries of \u201cAxxValues\u201d store the four coefficients. Since the coefficients of ux of the first AE are stored from AxxValues[1] to AxxValues[4], there are AxxBase[1] = 1 and AxxNum[1] = 4. In the same way, the second AE is located on the x-direction face with coordinates (2,1,1), and it has five coefficients of ux. Thus, AxxBase[2] = 5, and AxxNum[2] = 5."
        },
        {
            "heading": "5. Parallelization",
            "text": "The configuration of the real domain may be irregular. However, it can be decomposed into many smaller cuboids that are then discretized by regular grids. The cuboids are also called subdomains. In the same way, the entire field is also decomposed into many smaller fields that are called local fields. The two boundaries of the subdomain in the x-direction are called its left and right boundary, respectively, and the x-direction coordinate of the left boundary should be smaller than that of the right boundary. In the same way, the two boundaries of the subdomain in the y-direction are called its down and up boundaries, respectively, and the two boundaries of the subdomain in the z-direction are called its front and back boundaries, respectively. Fig 6 shows a two-dimensional sketch of a domain that is surrounded by thick and solid lines. It is easy to see that the domain is irregular. However, it can be divided into four regular subdomains. The three thin and solid lines inside the domain are the interfaces of the four subdomains. The thin and dashed lines represent the regular grids of the subdomains.\nThe operations relative to one subdomain should be finished only by one processor, while\none processor should process the operations of only one subdomain. As mentioned above, AEs and DVs are imposed either at the center of the cells or on the faces of the cells. Thus, the\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 10 / 25\nhttps://doi.org/10.1371/journal.pone.0261134.g005\nhttps://doi.org/10.1371/journal.pone.0261134.g006\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 11 / 25\noperations relative to a subdomain include the coefficient computation of the AEs and putting the coefficients into the linear system. The operations of the AEs imposed at the center of the cells are automatically finished by the processor allocated to the subdomain. However, to discuss the operations of the AEs imposed on the faces of the cells, the arrangement of the processors has to be given. Generally, all processors form a regular grid. If the processors are counted in the order of the x-, y- and z-directions, the index of a processor can be obtained with the same method mentioned above. Some faces of the cells are the interfaces between two subdomains, and therefore, it is stipulated that the AEs imposed on the interfaces are allocated to the processor with a smaller index. The AEs imposed on the other faces are automatically processed by the processors allocated to their subdomains. With this philosophy, the four subdomains in Fig 6 are allocated to four processors, and the arrangement of the four processors can also be seen in the figure. The three interface lines are in different colors, which means that the blue line is allocated to Processor 1, the yellow line is allocated to Processor 2 and the green line is allocated to Processor 3. The numbers \u201c1\u201d, \u201c2\u201d and \u201c3\u201d are called the IDs of the processors. It is noted that the size of the subdomains is more or less the same, which guarantees the load balance of the processors. The domain decomposition strategy on the level of processors can be implemented by MPI [43, 44]. As mentioned above, the coefficient computing in Section 3 is parallelized on the level of threads and can be implemented by OpenMP; therefore, the parallelization of the general framework can be implemented by both OpenMP and MPI.\nWhen computing the coefficients of an AE in the boundary region of a subdomain, some of\nits DVs may be imposed on the field elements belonging to the neighboring subdomains. Under this condition, the field of this subdomain has to be expanded for these DVs to include the relative field elements of the neighboring subdomains. For the various kinds of DVs, the configurations of the expanded fields are different, which is determined by the discretization patterns. For example, for the discretization pattern \u201cxxlap\u201d, its AEs are imposed on the xdirection field of the subdomain, except for the x-direction faces on the right boundary. Fig 7 shows the positions of the AEs on the subdomain of Processor 1 in Fig 6, which are surrounded by the four circles. Given this, the DVs of the discretization pattern should be imposed on all the elements of the x-direction field of this subdomain and on all the elements\nhttps://doi.org/10.1371/journal.pone.0261134.g007\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 12 / 25\nof the x-direction field that are adjacent to this subdomain, except those adjacent to the right boundary of this subdomain. Here, the elements of the x-direction field that are adjacent to this subdomain are defined as the elements; when they are shifted for one position in any of the three directions, they will become the elements of the x-direction field of this subdomain. Fig 8 shows the positions of the DVs of the AEs on the subdomain of Processor 1 in Fig 6, which are surrounded by the six circles.\nTo compute the coefficients of the DVs imposed on the field elements of the neighboring\nsubdomains, some values of the boundary areas of the neighboring subdomains have to be transferred to this subdomain; in the other direction, some values of the boundary area of this subdomain should also be transferred to its neighboring subdomains. These transmissions constitute the communication cost of the processors, which is also the reason that the linear speedup of the parallel code deteriorates with the increase in the number of processors.\nIn addition, Section 4 gives the indices of the AEs and DVs. The index in a subdomain is\ncalled the local index, and the index in the entire domain is called the global index. It is easy to know that the indices computed from Section 4 are local indices. However, in the parallel code, the indices in a linear system should be global indices. Thus, before constructing the linear system, the local indices have to be changed to global indices. If the indices of the processors begin with zero, it is stipulated that the AEs processed by Processor 0 are arranged in the linear system first, followed by those processed by Processor 1, Processor 2 and so on. As a result, the global index of an AE or DV in a subdomain can be achieved by adding the number of local indices of all the former processors to its local index.\nThis way to construct the linear system can be easily used by many popular solvers. These solvers provide the interfaces and routines to fill the nonzero entries of the coefficient matrix and right-hand-side vector as long as the locations of the nonzero entries are given. The location of a nonzero entry of the coefficient matrix is in reality an ordered pair<row number, column number>. Fortunately, the row number is the AE index, and the column number is the index of the DV. Both of them have been given by the construction method.\nhttps://doi.org/10.1371/journal.pone.0261134.g008\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 13 / 25"
        },
        {
            "heading": "6. Matrix acidization simulator",
            "text": ""
        },
        {
            "heading": "6.1 The mathematical model",
            "text": "A matrix acidization simulator (Masor) based on the general framework suggested above is developed. Masor simulates a reservoir application in which an acid flow is injected into the matrix to produce an oil production channel. Thus, numerical simulation is a topic of computational fluid dynamics. When matrix acidization is simulated under a constant temperature, the energy conservation law is not considered. Thus, based on the mass conservation law and the momentum conservation law, a mathematical model of matrix acidization can be derived, which is the DBF model. In this model, the mass conservation equation is shown as:\n@\ufffd @t \u00fer \ufffd u \u00bc 0: \u00f07\u00de\nEq (2) is the momentum conservation equation, and Eq (5) is the concentration equation. In particular, the momentum conservation equations in the x-direction, the y-direction and the z-direction are called the x-momentum equation, the y-momentum equation and the zmomentum equation, respectively. The meanings of all the variables in these equations are shown in Table 1. Although there are the other equations in this model, they will not be given in this section, since the purpose here is to give an example of the application of the general framework instead of an investigation of the model. The decoupled scheme [45] is used to solve the model. In this scheme, some changes have to be made to the mass conservation equation and the momentum conservation equation. After that, the mass conservation equation is expressed as:\n@\ufffd @t \u00fer \ufffd m K \u00fe rf F ffiffiffiffi K p junj\n\ufffd \ufffd 1\nrpn\u00fe1 \u00fe rf g \ufffd \ufffd \u00bc 0; \u00f08\u00de\nwhich is an elliptic PDE of the unknown variable pn+1. Here, the superscripts represent the time steps. The momentum conservation equation is shown as:\nrf Dt un\u00fe1 \ufffd n\u00fe1 un \ufffd n\n\ufffd \ufffd\n\u00fe m K \u00fe rf F ffiffiffiffi K p junj\n\ufffd \ufffd\nun\u00fe1 un\u00fe1D \ufffd \u00fe rfr \ufffd un\n\ufffd n\nO un\u00fe1\n\ufffd n\u00fe1\n\ufffd \ufffd\nmr2 un\u00fe1\n\ufffd n\u00fe1\n\u00bc 0; \u00f09\u00de\nin which un+1 is the unknown variable. It is noted that uD is an intermediate variable, which\ncan be expressed as:\nun\u00fe1D \u00bc m K \u00fe rf F ffiffiffiffi K p junj\n\ufffd \ufffd 1\n\u00f0 rpn\u00fe1 \u00fe rf g\u00de: \u00f010\u00de"
        },
        {
            "heading": "6.2 The structure of the code",
            "text": "The configuration of the matrix domain to be acidized could be complicated. However, by using the domain decomposition strategy in Section 5, a complicated domain can be divided into a series of subdomains of cuboids, and each of them is allocated to each processor. With the finite difference method on the regular grid, the discretization library is used by each processor to discretize all the equations and variables on its field elements. After that, the coefficient library is used to compute the coefficients of all the AEs. Then, the linear system library is applied, and three linear systems are formed, one is the pressure linear system for solving the pressure, which is composed of the AEs discretized from Eq (8); one is the velocity linear system for solving the velocity, which is composed of the AEs discretized from Eq (9); and the other is the concentration linear system for solving the concentration, which is composed of the AEs discretized from Eq (5).\nThe parallel code of the decoupled scheme of matrix acidization is written in FORTRAN\n90, OpenMP and MPI, and there are nine modules in this code. The libraries in the general framework are also implemented in FORTRAN 90. Thus, the modules can directly call the subroutines of the general framework to finish the simulation. The nine modules are shown in Fig 9. The user can set the experimental parameters in the module \u201cInfile\u201d. The module \u201cModel\u201d stipulates the variables and parameters that must be set by the users before running the code. The module \u201cGlobalData\u201d defines a series of global data that will be used by the entire code. The module \u201cDriver\u201d defines the flow chart of the code and therefore controls its\nhttps://doi.org/10.1371/journal.pone.0261134.g009\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 15 / 25\nrunning. After the experimental parameters are set in the module \u201cInfile\u201d, \u201cInfile\u201d will call the modules \u201cModel\u201d and \u201cDriver\u201d to begin the running of the code. In the running, the module \u201cDriver\u201d will call the modules \u201cModel\u201d, \u201cGlobalData\u201d, \u201cResi\u201d, \u201cConstructMat\u201d and \u201cExportResults\u201d to finish various tasks. Among them, the module \u201cResi\u201d is designed to compute the coefficients of the AEs, and therefore, it will call many subroutines in the coefficient library. The module \u201cConstructMat\u201d is used to discretize the PDEs and construct the linear system. Thus, it will call the subroutines in the discretization library and the linear system library. The module \u201cExportResults\u201d is responsible for outputting the interesting results in either of the two formats, MATLAB and Tecplot, which are implemented by calling the two modules \u201cExport2MATLAB\u201d and \u201cExport2Tecplot\u201d, respectively. It is emphasized that except for the module \u201cInfile\u201d, all the other modules need to call the two modules \u201cModel\u201d and \u201cGlobalData\u201d to finish their tasks."
        },
        {
            "heading": "6.3 The module \u201cDriver\u201d",
            "text": "Since the modules \u201cDriver\u201d, \u201cResi\u201d and \u201cConstructMat\u201d have a close relationship with the libraries of the general framework, their details will be discussed in the following sections. The study of the other modules will not be given.\nIn the module \u201cDriver\u201d, there is a subroutine also called \u201cdriver\u201d, in which a series of calls\nare defined. Its pseudocode is given in Fig 10. From the figure, it can be seen that the main task of the subroutine \u201cdriver\u201d is to control the running of the code. First, initialization is performed to initialize a series of variables and parameters, such as the initial pressure and the initial porosity in the matrix. Moreover, it is observed that the nonzero entry of the linear system may be composed of many terms. The values of some of the terms will not change with time, and therefore, they are called static terms. On the other hand, if the values of the terms change with time, they are called dynamic terms. For example, on the acid injection boundary of the matrix, the injection velocity is prescribed, and therefore Eq (9) deteriorates to:\nu \u00bc uB; \u00f011\u00de\nin which uB is the prescribed injection velocity. In this condition, uB will not change with time, and therefore, it is a static term. Due to the static characteristics of the terms, it is not necessary to update their values at each iteration. Instead, their values should be calculated one time before the time iterations, which is implemented by the calling of the subroutine \u201cgenStaticPara\u201d. It is noted that there are no static terms in the entries of the pressure linear system and the concentration linear system. Then, the time iterations begin. The values of some variables can be obtained directly from the explicit formulae, which is done by the calling of the subroutines \u201ccompute\ufffd\u201d. Here, \u201c\ufffd\u201d is a wildcard and represents the name of the variable. After that, it comes to the processing of the three linear systems. With the decoupled scheme, the pressure at time step n+1, i.e., pn+1, should be computed from the pressure linear system first, and then with pn+1; the intermediate variable un\u00fe1D can be obtained from Eq (10), which is then used to compute the velocity at time step n+1, i.e., un+1. With pn+1 and un+1, the concentration linear system can be used to compute the concentration at the time step n+1, i.e., Cn\u00fe1f . Thus, in the subroutine \u201cdriver\u201d, the pressure linear system is processed first, followed by the processing of the velocity linear system and the concentration linear system. The subroutine \u201cgenDynPara\u201d helps to compute the values of the dynamic terms, and the subroutine \u201csolve\u201d helps to solve the linear system. Afterward, the results at each iteration are output by the subroutine \u201coutputData\u201d. Finally, the subroutine \u201cfinalize\u201d is called to perform some operations to finish the running of the program, such as freeing the memory of the variables. It is noted that the input variable of the subroutines \u201cgenStaticPara\u201d and \u201cgenDynPara\u201d is \u201cfi_kind\u201d, and the input\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 16 / 25\nhttps://doi.org/10.1371/journal.pone.0261134.g010\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 17 / 25\nvariable of the subroutine \u201csolve\u201d is \u201cmat_kind\u201d, which represents a kind of coefficient matrix. More details of the two input variables will be given later. Since the other subroutines of the module \u201cDriver\u201d have little relationship with the general framework, they are not discussed."
        },
        {
            "heading": "6.4 The module \u201cResi\u201d",
            "text": "The module \u201cResi\u201d is used to compute the coefficients of the AEs, and therefore, it needs to call the subroutines in the coefficient library. It is known that these coefficients can be derived from computing the residuals of the AEs. To see how to do that, the subroutine \u201cResi_xmom_vx\u201d is taken as an example. Fig 11 is the head part of the code of the subroutine. The name of the subroutine hints that it will compute the coefficients of the AEs derived from the x-momentum equation of Eq (9). The unknown variable of the x-momentum equation is the x-direction velocity. Thus, the input variable \u201cvelx\u201d represents the field of the x-direction velocity, which is a three-dimensional array. The input variable \u201cresi\u201d is also a three-dimensional array, which is used to store the residuals of the AEs. Considering that the configuration of the x-direction velocity field may be irregular, some entries of \u201cvelx\u201d may not be in the xdirection velocity field. For example, in Fig 8, \u201cvelx\u201d is a 6 \u00d7 5 array on Processor 1. However, the entries at the upper left corner and the upper right corner are not in the x-direction velocity field. The input variable \u201cresi\u201d is also a three-dimensional array, which is used to store the residuals of the AEs. If the AEs are imposed on Processor 1 of Fig 8, \u201cresi\u201d is a 4 \u00d7 4 array. As mentioned above, the field of the x-direction velocity can be divided into 27 groups. The x-direction velocities in the same group can be set as one simultaneously to achieve a group of coefficients. Thus, the subroutine \u201cResi_xmom_vx\u201d will be called 27 times to obtain all the coefficients. For each time, the input variable \u201cvelx\u201d is set to represent one group, i.e., the entries of \u201cvelx\u201d that represent the x-direction velocities in this group are set as one, and the other entries are set as zero. Then, after computation, the entries of \u201cresi\u201d that represent the AEs containing the x-direction velocities in this group are the corresponding residuals, which can be sent to the discretization library to fill them in the coefficient matrix of the velocity linear system. Moreover, the subroutine \u201cResi_xmom_vx\u201d will be called one more time to obtain the right-hand-side vector of the velocity linear system. At this time, all the entries of \u201cvelx\u201d are set as zero. The other subroutines in the module \u201cResi\u201d will not be introduced here."
        },
        {
            "heading": "6.5 The module \u201cConstructMat\u201d",
            "text": "In the module \u201cConstructMat\u201d, the subroutines \u201cdctz_xxlap\u201d, \u201cdctz_yylap\u201d and \u201cdctz_zzlap\u201d in the discretization library are called to discretize u in the x-momentum equation, the ymomentum equation and the z-momentum equation, respectively. Moreover, the subroutine\nhttps://doi.org/10.1371/journal.pone.0261134.g011\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 18 / 25\n\u201cdctz_pplap7\u201d is used to discretize p in the pressure equation, and the subroutine \u201cdctz_pplap19\u201d is used to discretize Cf in the concentration equation. From the name of the two subroutines, it can be infered that both the variable discretization configuration of p in the pressure equation and that of Cf in the concentration equation are the same as in the Laplace term. However, due to the difference in the discretization schemes of the Laplace term in the two equations, the variable discretization configurations of p and Cf are slightly different and are distinguished by the two numbers \u201c7\u201d and \u201c19\u201d in the name of the two subroutines. From Eq (8), it can be seen that when the pressure equation is discretized at the center of a cell, the pressure p can be discretized at the center of the six cells adjacent to the cell and at the center of the cell itself, which is the reason that there is the number \u201c7\u201d in the subroutine name \u201cdctz_pplap7\u201d. However, when the concentration equation is discretized at the center of a cell, due to the existence of the tensor De in the Laplace term of Eq (5), the concentration Cf should be discretized at the center of more than seven cells. In a grid of 3 \u00d7 3 \u00d7 3 cells, if the concentration equation is discretized at the center of the grid, the concentration Cf should be discretized at the center of all the cells of the grid, except the eight cells at the corners of the grid. Thus, the number \u201c19\u201d appears in the name of the subroutine \u201cdctz_pplap19\u201d.\nIn the linear system library, two subroutines, \u201ccoordiToGlobalInd\u201d and \u201csetMatValue\u201d, are\ncalled by all the subroutines \u201cdctz_\ufffd\u201d, to finish the discretization procedure. \u201c\ufffd\u201d is a wildcard. The task of the subroutine \u201ccoordiToGlobalInd\u201d is to convert the coordinate of a field element in a local field to its index in the global linear system. The head part of the code of the subroutine \u201ccoordiToGlobalInd\u201d is given in Fig 12. From the figure, it can be seen that there are six input variables in the parameter list. Among them, \u201cpid\u201d is the processor ID, which indicates the local field on which the field element lies. \u201clocal_i\u201d, \u201clocal_j\u201d and \u201clocal_k\u201d form the coordinates of the field element in the local field, and \u201cglobal_ind\u201d is the index of the field element in the global linear system. The input variable \u201cind_kind\u201d is a three-digit integer. The first digit represents the field element type. There are four kinds of field elements, the x-direction face, the y-direction face, the z-direction face and the center of a cell, which are represented by the digits \u201c1\u201d, \u201c2\u201d, \u201c3\u201d and \u201c4\u201d, respectively. The last two digits represent the type of coefficient matrix. \u201c11\u201d stands for the coefficient matrix of the velocity linear system, \u201c12\u201d stands for the coefficient matrix of the pressure linear system, and \u201c13\u201d stands for the coefficient matrix of the concentration linear system. Then, according to \u201cpid\u201d, \u201cind_kind\u201d and the coordinate, the \u201cglobal_ind\u201d of a field element can be computed with the methods in Section 4 and Section 5.\nFrom the discussions in Section 4, it is understood that if a DV is imposed on this field ele-\nment, the index of the DV in the global linear system is the index of this field element; if an AE\nhttps://doi.org/10.1371/journal.pone.0261134.g012\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 19 / 25\nis imposed on this field element, the index of the AE in the global linear system is also the index of this field element. Furthermore, the index of an AE is the row number of the AE in the coefficient matrix, and the index of a DV is the column number of the DV in the coefficient matrix. Thus, by the two indices, the position of a nonzero entry of the coefficient matrix, i.e., the position of a residual, can be located. Then, the subroutine \u201csetMatValue\u201d is used to fill the residual in its position of the linear system. The head part of the code of the subroutine \u201csetMatValue\u201d is shown in Fig 13. There are six input variables in the parameter list. The input variable \u201ccol\u201d represents the column number of the position, the input variable \u201crow\u201d represents the row number of the position and the input variable \u201cvalue\u201d represents the residual value. The input variable \u201cfi_kind\u201d is a three-digital integer. It stands for the kind of field, which decides the array in which the residual lies. The first digit represents the type of field element, which is the same as that in \u201cind_kind\u201d above. The last two digits represent the type of equation, \u201c51\u201d stands for the static part of the x-momentum equation, \u201c52\u201d stands for the dynamic part of the x-momentum equation, \u201c53\u201d stands for the static part of the y-momentum equation, \u201c54\u201d stands for the dynamic part of the y-momentum equation, \u201c55\u201d stands for the static part of the z-momentum equation, \u201c56\u201d stands for the dynamic part of the z-momentum equation, \u201c57\u201d stands for the mass conservation equation and \u201c58\u201d stands for the concentration equation. Finally, \u201ceq_i\u201d, \u201ceq_j\u201d, and \u201ceq_k\u201d are the equation coordinates in the local equation field, which are used to locate the position of the residual in the array.\nNow, we will study some details of the subroutine \u201cdctz_xxlap\u201d. When the subroutine is\ncalled, it is stipulated that the coefficients and the right-hand-side values of the AEs are already computed by the coefficient library. Thus, the discretization procedure is to put the coefficients and the right-hand-side values of the AEs into the corresponding arrays in the linear system\nhttps://doi.org/10.1371/journal.pone.0261134.g013\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 20 / 25\nlibrary, for example, the arrays in Fig 5. The head part of this subroutine code can be given in Fig 14. From the figure, it can be seen that there are four input variables in the parameter list. The input variable \u201cfield\u201d has the same meaning as \u201cvelx\u201d in the subroutine \u201cResi_xmom_vx\u201d, and the input variable \u201cresi\u201d has the same meaning as that in the subroutine \u201cResi_xmom_vx\u201d. When an entry of the array \u201cfield\u201d is set to one, the residuals of the AEs that contain the entry are sent to the coefficient storage arrays in the linear system library. However, to locate the positions of the residuals in the arrays, the information of the field element and the coefficient matrix should be known. Thus, the input variables \u201cind_kind\u201d and \u201cfi_kind\u201d are needed, which have the same meaning as before. In particular, ind_kind = 111, and fi_kind = 151 or 152 in this condition."
        },
        {
            "heading": "6.6 The evaluation of Masor",
            "text": "Different from the former code-developing pattern in which the entire code should be written from the beginning, the general framework has already implemented most functions of the code, and therefore Masor can be implemented easily and quickly with the general framework. Masor has been applied in many cases of matrix acidization simulations. In the following discussion, those cases using Masor are retold for the purpose of evaluation. One evaluation is to verify the correctness and effectiveness of Masor, and the other evaluation is to show the good parallel performance of Masor. Since the success of Masor has been demonstrated in those works, the corresponding numerical experiments will not be repeated in this work. It is emphasized that in those works, Masor is just a tool to investigate the reasonability of the mathematical model and the effectiveness of the numerical algorithms, and Masor itself, and the general framework behind Masor, have never been the point of interest.\nIn Section 5.3 of [42], the authors used Masor to perform simulations and compared the\nnumerical results of Masor with the work [45]. In that case, a matrix of 0.04 m \u00d7 0.04 m \u00d7 0.1 m, and a grid of 36 \u00d7 36 \u00d7 90 cells are used to discretize the matrix domain. An acid flow is injected into the matrix from the 0.04 m \u00d7 0.04 m face to produce an oil production channel, and the output is at the other 0.04 m \u00d7 0.04 m face. Except for the two faces, the other faces of the matrix are closed. The acid injection velocity is increased from 1.04 \u00d7 10\u22127 m/s to 1.04 \u00d7 10\u22124 m/s, and an acid-efficiency curve can be drawn from the simulation results. From the results, it is concluded that the two acid-efficiency curves of works [42, 45] match each other well. In addition, both works indicate that the optimal injection velocity is 1.04 \u00d7 10\u22126\nhttps://doi.org/10.1371/journal.pone.0261134.g014\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 21 / 25\nm/s. Moreover, five different dissolution patterns in the work [45] can be reproduced by Masor in [42]. Thus, the correctness and effectiveness of Masor\u2019s method are proven by [42]. It is acknowledged that the other works ([37\u201342, 46]) have also done many verification works, and we will not repeat them here.\nIn addition, Section 7 of [42] evaluates the parallel performance of Masor. There, the\nnumerical experiment in the last paragraph is carried out with different numbers of processors, 9, 18, 36, 72 and 144. The percentage of solver time over run time is more than 98%, and therefore, it is the parallel performance of the solver that determines the parallel performance of Masor. In [42], the authors used the solver MUMPS. When the number of processors is increased from 9 to 36, the speedup is more or less linear. However, when the number of processors is increased further, a limited speedup can be achieved. This phenomenon can also be observed in other applications of MUMPS [47]."
        },
        {
            "heading": "7. Conclusion",
            "text": "In this work, a field-based general framework to simulate fluids in parallel is suggested. Based on the experience from the fluid simulations, it is seen that all kinds of operations in the simulations can be attributed to the operations in the fields. With this philosophy, different fluid simulations can be deemed to follow the same kind of pattern, which necessitates building a general framework for all types of fluid simulations, i.e., the field-based general framework. As a result, most of the common operations in different simulations can be finished by the code of the framework, and the development of new simulators can be done easily and quickly.\nThe idea of a field-based general framework is summarized as follows\u2014Due to the conservation laws, there are many common terms among the equations of fluid simulations, such as the divergence term and the Laplace term, so that the variables in the equations have common discretization patterns that are recognized by the discretization library. It is emphasized that the discretization patterns are established with the prerequisite that the equations and the variables are discretized on the field elements, i.e., the discretization patterns are field-based. After discretization, the PDEs become the AEs, and the variables become the DVs. Before assembling the AEs into a linear system, the coefficients of the AEs should be known. It is observed that the coefficient of a DV in an AE is in reality the residual of the AE, which is done by setting the DV as one and the other DVs in the AE as zero. This coefficient computing method is implemented by the coefficient library. Considering that all the AEs and DVs are imposed on the field elements, the coefficient library is also field-based. Then, the linear system library is applied to compute the indices of the residuals and are filled into the linear system. It is noted that the indices of the residuals are also the indices of the field elements, and therefore, the linear system library is field-based. There is no parallelization library to parallelize the field-based general framework. Instead, the parallel philosophy is integrated into the three libraries mentioned above. In parallelization, domain decomposition is performed to decompose the irregular domain into many regular subdomains, and then each subdomain is allocated to each processor. The size of the subdomains should be more or less the same to guarantee a load balance among the processors. With the domain decomposition strategy, the equation fields and the variable fields in the entire domain are decomposed into many local fields on the processors. Moreover, methods to convert the local index of the field element to its global index is another task in parallelization.\nWith the field-based general framework, the code of the decoupled scheme for the matrix acidization simulation, i.e., Masor, can be developed quickly. Matrix acidization is an operation in reservoirs, in which acid flow is injected into the matrix to produce an oil production channel. Thus, it is an application of computational fluid dynamics, and its code can be\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 22 / 25\ndeveloped by the framework. From the simulation results, it is seen that Masor gives reasonable outputs, which is a demonstration of the correctness and effectiveness of the framework.\nIt is emphasized that the field-based general framework introduced in this work is based on\nregular grids, finite difference methods and linear systems. However, the philosophy of this framework can also be applied to irregular grids, finite element methods, finite volume methods, nonlinear systems, etc., and therefore the boundary of this framework can be further expanded. Additional new subroutines should be added into the libraries to cope with those conditions, which is work left for the future.\nSupporting information\nS1 Code. Makefile.mac. https://doi.org/10.6084/m9.figshare.16974196.v1. (TXT)\nS2 Code. Infile.F90. https://doi.org/10.6084/m9.figshare.16974232.v1. (TXT)\nS3 Code. Model.F90. https://doi.org/10.6084/m9.figshare.16974214.v1. (TXT)\nS4 Code. Driver.F90. https://doi.org/10.6084/m9.figshare.16974250.v1. (TXT)\nS5 Code. GlobalData.F90. https://doi.org/10.6084/m9.figshare.16974202.v1. (TXT)\nS6 Code. ExportResults.F90. https://doi.org/10.6084/m9.figshare.16974226.v1. (TXT)\nS7 Code. Resi.F90. https://doi.org/10.6084/m9.figshare.16974193.v1. (TXT)\nS8 Code. ConstructMat.F90. https://doi.org/10.6084/m9.figshare.16974253.v1. (TXT)\nS9 Code. Export2Matlab.F90. https://doi.org/10.6084/m9.figshare.16974199.v1. (TXT)\nS10 Code. Export2tecplot.F90. https://doi.org/10.6084/m9.figshare.16974205.v1. (TXT)\nAuthor Contributions\nConceptualization: Yuanqing Wu, Shuyu Sun.\nData curation: Yuanqing Wu.\nFormal analysis: Yuanqing Wu.\nFunding acquisition: Yuanqing Wu.\nInvestigation: Yuanqing Wu.\nMethodology: Yuanqing Wu, Shuyu Sun.\nProject administration: Yuanqing Wu.\nResources: Yuanqing Wu.\nPLOS ONE | https://doi.org/10.1371/journal.pone.0261134 February 3, 2022 23 / 25\nSoftware: Yuanqing Wu.\nSupervision: Yuanqing Wu.\nValidation: Yuanqing Wu.\nVisualization: Yuanqing Wu.\nWriting \u2013 original draft: Yuanqing Wu.\nWriting \u2013 review & editing: Yuanqing Wu."
        }
    ],
    "title": "A field-based general framework to simulate fluids in parallel and the framework\u2019s application to a matrix acidization simulation",
    "year": 2022
}