{
    "abstractText": "We propose \u03ba-approximate nearest neighbor (ANN) data structures for n polygonal curves under the Fr\u00e9chet distance in R, where \u03ba \u2208 {1 + \u03b5, 3 + \u03b5} and d \u2265 2. We assume that every input curve has at most m vertices, every query curve has at most k vertices, k m, and k is given for preprocessing. The query times are \u00d5(k(mn)0.5+\u03b5/\u03b5d + k(d/\u03b5)O(dk)) for (1 + \u03b5)-ANN and \u00d5(k(mn)0.5+\u03b5/\u03b5d) for (3 + \u03b5)-ANN. The space and expected preprocessing time are \u00d5(k(mndd/\u03b5d)O(k+1/\u03b5 )) in both cases. In two and three dimensions, we improve the query times to O(1/\u03b5)O(k) \u00b7 \u00d5(k) for (1 + \u03b5)-ANN and \u00d5(k) for (3 + \u03b5)-ANN. The space and expected preprocessing time improve to O(mn/\u03b5)O(k) \u00b7 \u00d5(k) in both cases. For ease of presentation, we treat factors in our bounds that depend purely on d as O(1). The hidden polylog factors in the big-\u00d5 notation have powers dependent on d. 2012 ACM Subject Classification Theory of computation \u2192 Computational geometry",
    "authors": [
        {
            "affiliations": [],
            "name": "Siu-Wing Cheng"
        },
        {
            "affiliations": [],
            "name": "Haoqiang Huang"
        }
    ],
    "id": "SP:dc7b77cda52b64668eb0728ecbd8532b16ff89a9",
    "references": [
        {
            "authors": [
                "P.K. Agarwal",
                "J. Matou\u0161ek"
            ],
            "title": "Ray shooting and parametric search",
            "venue": "SIAM Journal on Computing,",
            "year": 1993
        },
        {
            "authors": [
                "P.K. Agarwal",
                "N. Rubin",
                "M. Sharir"
            ],
            "title": "Approximate nearest neighbor search amid higherdimensional flats",
            "venue": "In Proceedings of the European Symposium on Algorithms,",
            "year": 2017
        },
        {
            "authors": [
                "H. Alt",
                "M. Godau"
            ],
            "title": "Computing the Fr\u00e9chet distance between two polygonal curves",
            "venue": "International Journal of Computational Geometry and Applications,",
            "year": 1995
        },
        {
            "authors": [
                "A. Andoni",
                "P. Indyk",
                "R. Krauthgamer",
                "H.L. Nguyen"
            ],
            "title": "Approximate line nearest neighbor in high dimensions",
            "venue": "In Proceedings of the ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2009
        },
        {
            "authors": [
                "K. Bringmann",
                "A. Driemel",
                "A. Nusser",
                "I. Psarros"
            ],
            "title": "Tight bounds for approximate near neighbor searching for time series under Fr\u00e9chet distance",
            "venue": "In Proceedings of the ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2022
        },
        {
            "authors": [
                "S.-W. Cheng",
                "H. Huang"
            ],
            "title": "Curve simplification and clustering under Fr\u00e9chet distance",
            "venue": "In Proceedings of the ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2023
        },
        {
            "authors": [
                "T.H. Cormen",
                "C.E. Leiserson",
                "R.L. Rivest",
                "C. Stein"
            ],
            "title": "Introduction to Algorithms",
            "venue": "MIT Press, second edition,",
            "year": 2001
        },
        {
            "authors": [
                "M. de Berg",
                "D. Halperin",
                "M. Overmars",
                "J. Snoeyink",
                "M. van Kreveld"
            ],
            "title": "Efficient ray shooting and hidden surface removal",
            "year": 1994
        },
        {
            "authors": [
                "A. Driemel",
                "A. Krivo\u0161ija",
                "C. Sohler"
            ],
            "title": "Clustering time series under the Fr\u00e9chet distance",
            "venue": "In Proceedings of the ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2016
        },
        {
            "authors": [
                "A. Driemel",
                "I. Psarros"
            ],
            "title": "-ANN for time series under the Fr\u00e9chet distance",
            "venue": "arXiv preprint arXiv:2008.09406v5,",
            "year": 2021
        },
        {
            "authors": [
                "A. Driemel",
                "F. Silvestri"
            ],
            "title": "Locality-sensitive hashing of curves",
            "venue": "In Proceedings of the International Symposium on Computational Geometry,",
            "year": 2017
        },
        {
            "authors": [
                "T. Eiter",
                "H. Mannila"
            ],
            "title": "Computing discrete Fr\u00e9chet distance",
            "venue": "Technical Report CD-TR 94/64,",
            "year": 1994
        },
        {
            "authors": [
                "I.Z. Emiris",
                "I. Psarros"
            ],
            "title": "Products of Euclidean metrics, applied to proximity problems among curves: Unified treatment of discrete fr\u00e9chet and dynamic time warping distances",
            "venue": "ACM Transactions on Spatial Algorithms and Systems,",
            "year": 2020
        },
        {
            "authors": [
                "A. Filtser",
                "O. Filtser",
                "M.J. Katz"
            ],
            "title": "Approximate nearest neighbor for curves: simple, efficient, and deterministic",
            "venue": "In Proceedings of the International Colloquium on Automata, Languages, and Programming,",
            "year": 2020
        },
        {
            "authors": [
                "S. Har-Peled"
            ],
            "title": "A replacement for Voronoi diagrams of near linear size",
            "venue": "In Proceedings of the Annual IEEE Symposium on Foundations of Computer Science,",
            "year": 2001
        },
        {
            "authors": [
                "S. Har-Peled",
                "P. Indyk",
                "R. Motwani"
            ],
            "title": "Approximate nearest neighbor: towards removing the curse of dimensionality",
            "venue": "Theory of Computing,",
            "year": 2012
        },
        {
            "authors": [
                "P. Indyk"
            ],
            "title": "Approximate nearest neighbor algorithms for Fr\u00e9chet distance via product metrics",
            "venue": "In Proceedings of the Annual Symposium on Computational Geometry,",
            "year": 2002
        },
        {
            "authors": [
                "P. Indyk",
                "R. Motwani"
            ],
            "title": "Approximate nearest neighbor: towards removing the curse of dimensionality",
            "venue": "In Proceedings of the Annual ACM Symposium on Theory of Computing,",
            "year": 1998
        },
        {
            "authors": [
                "M. Mirzanezhad"
            ],
            "title": "On the approximate nearest neighbor queries among curves under the Fr\u00e9chet distance",
            "venue": "arXiv preprint arXiv:2004.08444,",
            "year": 2020
        },
        {
            "authors": [
                "C. Shahabi",
                "M. Kolahdouzan",
                "M. Sharifzadeh"
            ],
            "title": "A road network embedding technique for k-nearest neighbor search in moving object databases",
            "year": 2003
        },
        {
            "authors": [
                "Z. Song",
                "N. Roussopoulos"
            ],
            "title": "K-nearest neighbor search for moving query point",
            "venue": "In Proceedings of the International Symposium on Spatial and Temporal Databases,",
            "year": 2001
        },
        {
            "authors": [
                "Y. Tao",
                "D. Papadias"
            ],
            "title": "Parameterized queries in spatio-temporal databases",
            "venue": "In Proceedings of ACM International Conference on Management of Data,",
            "year": 2002
        }
    ],
    "sections": [
        {
            "text": "2)) in both cases. In two and three dimensions, we improve the query times to O(1/\u03b5)O(k) \u00b7 O\u0303(k) for (1 + \u03b5)-ANN and O\u0303(k) for (3 + \u03b5)-ANN. The space and expected preprocessing time improve to O(mn/\u03b5)O(k) \u00b7 O\u0303(k) in both cases. For ease of presentation, we treat factors in our bounds that depend purely on d as O(1). The hidden polylog factors in the big-O\u0303 notation have powers dependent on d.\n2012 ACM Subject Classification Theory of computation \u2192 Computational geometry\nKeywords and phrases Polygonal curves, Fr\u00e9chet distance, approximate nearest neighbor\nDigital Object Identifier 10.4230/LIPIcs.ICALP.2023.23\n1 Introduction\nGiven a set of trajectories, the nearest neighbor problem is to efficiently report the one most similar to a query trajectory. Trajectories are often represented as polygonal curves, and the nearest neighbor problem is encountered frequently in applications [20, 21, 22].\nVarious similarity metrics have been proposed for polygonal curves. We are interested in the Fr\u00e9chet distance [3] which has attracted much attention in recent years. It is defined as follows. A parameterization of a curve \u03c4 is a function \u03c1 : [0, 1]\u2192 Rd such that, as t increases from 0 to 1, the point \u03c1(t) moves monotonically from the beginning of \u03c4 to its end. We may have \u03c1(t1) = \u03c1(t2) for two distinct values t1 and t2. Two parameterizations \u03c1 and % for curves \u03c4 and \u03c3, respectively, induce a matching M: for all t \u2208 [0, 1],M matches \u03c1(t) with %(t). A point can be matched with multiple partners. The distance between \u03c4 and \u03c3 underM is dM(\u03c4, \u03c3) = maxt\u2208[0,1] d(\u03c1(t), %(t)), where d(\u00b7, \u00b7) denotes the Euclidean distance. The Fr\u00e9chet distance is dF (\u03c4, \u03c3) = minM dM(\u03c4, \u03c3). We call a minimizing matching a Fr\u00e9chet matching.\nLet T = {\u03c41, . . . , \u03c4n} be a set of n polygonal curves with at most m vertices each. Given any value \u03ba \u2265 1, the \u03ba-approximate nearest neighbor (ANN) problem is to construct a data structure so that for any query curve \u03c3, we can quickly report a curve \u03c4l \u2208 T with dF (\u03c3, \u03c4l) \u2264 \u03ba \u00b7min\u03c4i\u2208T dF (\u03c3, \u03c4i). We assume that every query curve has at most k vertices, and k is given for preprocessing. In the literature, if k = m, it is called the symmetric version; if k < m, it is called the asymmetric version. If the query curve is sketched by the user, it is likely that k m and this is the scenario for which we design our data structures. We define the related (\u03ba, \u03b4)-ANN problem as follows: for any query curve, we report \u201cno\u201d or a curve \u03c4l \u2208 T with dF (\u03c3, \u03c4l) \u2264 \u03ba\u03b4; if we report \u2018no\u201d, it must be the case that min\u03c4i\u2208T dF (\u03c3, \u03c4i) > \u03b4.\nThere have been many results on the ANN problem under the discrete Fr\u00e9chet distance d\u0303F , which restricts the definition of dF to parameterizations \u03c1 and % that match each vertex of \u03c4 with at least one vertex of \u03c3, and vice versa. As a result, dF (\u03c4, \u03c3) \u2264 d\u0303F (\u03c4, \u03c3). It is\n\u00a9 Siu-Wing Cheng and Haoqiang Huang; licensed under Creative Commons License CC-BY 4.0\n50th International Colloquium on Automata, Languages and Programming (ICALP 2023). Editors: Uriel Feige; Article No. 23; pp. 23:1\u201323:23\nLeibniz International Proceedings in Informatics Schloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\nar X\niv :2\n30 4.\n14 64\n3v 2\n[ cs\n.C G\n] 2\nM ay\n2 02\n3\npossible that dF (\u03c4, \u03c3) d\u0303F (\u03c4, \u03c3); for example, \u03c3 is a long horizontal line segment, and \u03c4 is a parallel copy near \u03c3 with an extra vertex in the middle. The advantage of d\u0303F is that it can be computed using a simple dynamic programming algorithm [12].\nIndyk and Motwani [18] and Har-Peled [15] proved that a solution for the (\u03ba, \u03b4)-ANN problem for points in a metric space gives a solution for the \u03ba(1 +O(\u03b5))-ANN problem. The result has been simplified in the journal version [16]. The method is general enough that it works for polygonal curves under dF and d\u0303F . Theorem 1 in Section 2 states the deterministic result in our context; the reduction increases the space and query time by polylogarithmic factors. If a probabilistic (\u03ba, \u03b4)-ANN solution with failure probability f is used, the bounds in Theorem 1 also hold, and the ANN solution has an O(f logn) failure probability.\nIndyk [17] proposed the first (\u03ba, \u03b4)-ANN solution under d\u0303F , where \u03ba = O(logm+log logn), for the case that k = m and the vertices come from a discrete point set X. It uses O ( |X| \u221a m(m \u221a mn)2 ) space and answers a query in O ( mO(1) logn ) time.1 Driemel and\nSilverstri [11] developed probabilistic (\u03ba, \u03b4)-ANN solutions under d\u0303F with a failure probability 1/n; they achieve the following combinations of (\u03ba, query time, space) for the case of k = m: ( 4d3/2m,O(m), O(n logn+mn) ) , ( 4d3/2, O(24dmm logn), O(24mdn logn+mn) ) , and(\n4d3/2m/t,O(22tmt logn), O(22tmt\u22121n logn+mn) ) for any integer t \u2265 1. The approximation\nratio has been reduced to 1 + \u03b5 by two research groups later. Filtser et. al. [14] proposed two deterministic (1+\u03b5, \u03b4)-ANN data structures under d\u0303F ; one answers a query in O(kd) time and uses n \u00b7O( 1\u03b5 ) kd space and O(mn(d logm+O( 1\u03b5 ) kd)) expected preprocessing time; the other answers a query in O(kd log dkn\u03b5 ) time and uses n \u00b7O( 1 \u03b5 ) kd space and O(mn log n\u03b5 \u00b7 (d logm+ O( 1\u03b5 ) kd)) worst-case preprocessing time. Emiris and Psarros [13] obtained probabilistic (1+\u03b5)ANN and (1 + \u03b5, \u03b4)-ANN data structures under d\u0303F with failure probabilities 1/2 for the case of k = m. The (1 +\u03b5)-ANN data structure answers a query in O\u0303(d24mmO(1/\u03b5)) time and uses O\u0303(dm2n) \u00b7 (2 + d/ logm)O(dmO(1/\u03b5) log(1/\u03b5)) space and preprocessing time. The (1 + \u03b5, \u03b4)-ANN data structure answers a query in O(d24m logn) time and uses O(dn) + (mn)O(m/\u03b52) space and preprocessing time. The failure probabilities can be reduced to 1/n with an increase in the query time, space, and preprocessing time by an O(logn) factor.\nMost known results under dF are for R. For curves in R (time series), Driemel and Psarros [10] developed the first (\u03ba, \u03b4)-ANN data structures under dF with the following combinations of (\u03ba, query time, space): ( 5+\u03b5,O(k), O(mn)+n \u00b7O( 1\u03b5 ) k ) , ( 2+\u03b5,O(2kk), O(mn)+\nn \u00b7 O(mk\u03b5 ) k ) , and ( 24k + 1, O(k logn), O(n logn + mn) ) . The last one is probabilistic, and the failure probability is 1/poly(n). Later, Bringman et al. [5] obtained improved solutions with the following combinations of (\u03ba, query time, space): ( 1 + \u03b5,O(2kk), n \u00b7O(mk\u03b5 ) k ) ,\n(2 + \u03b5,O(k), n \u00b7O(mk\u03b5 ) k ) , ( 2 + \u03b5,O(2kk), O(mn) + n \u00b7O( 1\u03b5 ) k ) , ( 2 + \u03b5,O( 1\u03b5 ) k+2, O(mn) ) , and(\n3 + \u03b5,O(k), O(mn) + n \u00b7 O( 1\u03b5 ) k ) . They also obtained lower bounds that are conditioned on the Orthogonal Vectors Hypothesis: for all \u03b5, \u03b5\u2032 \u2208 (0, 1), it is impossible to achieve the combination ( 2 \u2212 \u03b5,O(n1\u2212\u03b5\u2032),poly(n) ) in R when 1 k logn and m = kn\u0398(1/k), or(\n3\u2212 \u03b5,O(n1\u2212\u03b5\u2032),poly(n) ) in R when m = k = \u0398(logn), or ( 3\u2212 \u03b5,O(n1\u2212\u03b5\u2032),poly(n) ) in R2 when 1 k logn and m = kn\u0398(1/k). Mirzanezhad [19] described a (1 + \u03b5, \u03b4)-ANN data structure for Rd that answer a query in O(kd) time and uses O(n \u00b7max{ \u221a d/\u03b5, \u221a dD/\u03b52}dk)\nspace, where D is the diameter of the set of input curves. If k is not given, the approximation ratio and space increase to 5 + \u03b5 and n \u00b7O( 1\u03b5 )\ndm, respectively. There is no bound on D in the space complexity of the first solution. We summarize all these previous results in Table 1 for easier comparison.\nWe develop (\u03ba, \u03b4)-ANN data structures under dF in Rd for \u03ba \u2208 {1+\u03b5, 3+\u03b5} and d \u2265 2. We\n1 A tradeoff is also presented in [17].\nDistance Space Query time Approximation\nContinuous Fr\u00e9chet, R\nO (mn) + n \u00b7O (\n1 \u03b5\n)k O(k) (5 + , \u03b4)-ANN [10]\nO (mn) + n \u00b7O ( m k\u03b5 )k O(2kk) (2 + , \u03b4)-ANN [10]\nO (n logn+mn) O(k logn) (24k + 1, \u03b4)-ANN [10]a n \u00b7O ( m k\u03b5 )k O(2kk) (1 + \u03b5, \u03b4)-ANN [5]\nn \u00b7O ( m k\u03b5 )k O(k) (2 + \u03b5, \u03b4)-ANN [5]\nO (mn) + n \u00b7O (\n1 \u03b5\n)k O(2kk) (2 + \u03b5, \u03b4)-ANN [5]\nO (mn) O (\n1 \u03b5 )k+2 (2 + \u03b5, \u03b4)-ANN [5] O (mn) + n \u00b7O ( 1 \u03b5 )k O(k) (3 + \u03b5, \u03b4)-ANN [5]\nContinuous Fr\u00e9chet, Rd O ( n \u00b7max{ \u221a d/\u03b5, \u221a dD/\u03b52}dk ) O(kd) (1 + \u03b5, \u03b4)-ANN [19] n \u00b7O ( 1 \u03b5 )dm O(kd) (5 + \u03b5, \u03b4)-ANN [19]\nO\u0303 ( k(mndd/\u03b5d)O(k+1/\u03b5 2) )\nO\u0303 ( k(mn)0.5+\u03b5/\u03b5d + k(d/\u03b5)O(dk) ) (1 + \u03b5, \u03b4)-ANN, Theorem 9\nO\u0303 ( k(mndd/\u03b5d)O(k+1/\u03b5 2) )\nO\u0303 ( k(mn)0.5+\u03b5/\u03b5d ) (3 + \u03b5, \u03b4)-ANN, Theorem 11\nContinuous Fr\u00e9chet, R2 and R3\nO (\n1 \u03b5 )4d(k\u22121)+1 (mn)4(k\u22121)k log2 n O ( 1 \u03b5 2d(k\u22122) ) k log mn \u03b5 logn (1 + \u03b5, \u03b4)-ANN, Theorem 9\nO (\n1 \u03b5 )2d(k\u22121)+1 (mn)2(k\u22121)k log2 n O (k log mn \u03b5 logn )\n(3 + \u03b5, \u03b4)-ANN, Theorem 11\nDiscrete Fr\u00e9chet, Rd\nO ( |X| \u221a m(m \u221a mn)2 ) O ( mO(1) logn ) (O(logm+ log logn), \u03b4)-ANN [17]\nO(n logn+mn) O(m) (4d3/2m, \u03b4)-ANN [11] O(24mdn logn+mn) O(24dmm logn) (4d3/2, \u03b4)-ANN [11]\nO(22tmt\u22121n logn+mn) O(22tmt logn) (4d3/2m/t, \u03b4)-ANN [11] n \u00b7O ( 1 \u03b5 )kd O(kd)b (1 + \u03b5, \u03b4)-ANN [14]\nO(dn) + (mn)O(m/\u03b5 2) O ( d24m logn ) (1 + \u03b5, \u03b4)-ANNc [13]\na A randomized data structure with a failure probability of 1/poly(n). b The query time is achieved by implementing the dictionary with a hash table. The query time is O(kd log dkn\u03b5 ) when implementing the dictionary with a trie.c A randomized data structure with a failure probability of 12 .\nTable 1 Comparison of our data structures to the previous results.\nassume that every query curve has at most k vertices, k m, and k is given for preprocessing. To simplify the bounds, we assume that k \u2265 3 throughout this paper. There are three design goals. First, the query times are sublinear in mn. Second, the space complexities depend only on the input parameters. Third, the space complexities are neither proportional to min{m\u2126(d), n\u2126(d)} nor exponential in min{m,n}. It would be desirable to remove all exponential dependencies on d, but we are not there yet.\nWe achieve a query time of O\u0303(k(mn)0.5+\u03b5/\u03b5d + k(d/\u03b5)O(dk)) for (1 + \u03b5, \u03b4)-ANN. We remove the exponential dependence on k for (3 + \u03b5, \u03b4)-ANN and obtain an O\u0303(k(mn)0.5+\u03b5/\u03b5d) query time. The space and expected preprocessing time are O\u0303(k(mndd/\u03b5d)O(k+1/\u03b52)) in both cases. For ease of presentation, we treat any factor in our bounds that depends only on d as O(1). The hidden polylog factors in the big-O\u0303 notation have powers dependent on d. In two and three dimensions, we improve the query times to O(1/\u03b5)O(k) \u00b7 O\u0303(k) for (1 + \u03b5, \u03b4)-ANN and O\u0303(k) for (3 + \u03b5, \u03b4)-ANN. The space and expected preprocessing time improve to O(mn/\u03b5)O(k) \u00b7 O\u0303(k) in both cases. Using the reduction in [16] (Theorem 1 in Section 2), we obtain (1 + \u03b5)-ANN and (3 + \u03b5)-ANN data structures by increasing the query time and space by an O(logn) and an O( 1\u03b5 log\n2 n) factors, respectively. More precise bounds are stated in Theorems 9 and 11.\nOur (1 + \u03b5, \u03b4)-ANN result is based on two new ideas. First, we develop a novel encoding of query curves that are based on local grids in the input vertex neighborhoods. Second, we draw a connection to an approximate segment shooting problem which we solve efficiently. We present these ideas in Sections 2 and 4. Our (3 + \u03b5)-ANN result is obtained by simplifying the encoding. We present this result in Section 3.\nWe work in the word RAM model. We use (vi,1, . . . , vi,m) to denote the sequence of vertices of \u03c4i from beginning to end\u2014\u03c4i is oriented from vi,1 to vi,m. We use \u03c4i,a to denote the edge vi,avi,a+1. For any two points x, y \u2208 \u03c4i, we say that x \u2264\u03c4i y if x does not appear\nICALP 2023\nbehind y along \u03c4i, and \u03c4i[x, y] denotes the subcurve between x and y. Given two subsets X,Y \u2286 \u03c4i, X \u2264\u03c4i Y if and only if for every point x \u2208 X and every point y \u2208 Y , x \u2264\u03c4i y. A ball centered at the origin with radius r is denoted by Br. Given two subsets X,Y \u2282 Rd, d(X,Y ) = minx\u2208X,y\u2208Y d(x, y); their Minkowski sum is X \u2295 Y = {x+ y : x \u2208 X, y \u2208 Y }; if X = {p}, we write p\u2295 Y for simplicity. For any x, y \u2208 Rd, xy denotes the oriented segment from x to y, and aff(xy) is the oriented support line of xy that shares the orientation of xy.\n2 (1 +O(\u03b5), \u03b4)-ANN\nHar-Peled et al. [16, Theorem 2.10] proved a reduction from the (1 + \u03b5)-ANN problem to the (1 + \u03b5, \u03b4)-ANN problem. Although the result is described for points in a metric space with a probabilistic data structure for the (1 + \u03b5, \u03b4)-ANN problem, the method is general enough to work for polygonal curves under dF or d\u0303F in Rd and any deterministic solution for the (1 + \u03b5, \u03b4)-ANN problem. We rephrase their result in our context below.\nI Theorem 1 ([16]). Let T be a set of n polygonal curves in Rd. If there is a data structure for the (\u03ba, \u03b4)-ANN problem for T under dF or d\u0303F that has space complexity S, query time Q, deletion time D, and preprocessing time P , then there is a \u03ba(1 +O(\u03b5))-ANN data structure for T under dF or d\u0303F that has space complexity O( 1\u03b5S log\n2 n), query time O(Q logn), and expected preprocessing time O ( 1 \u03b5 log2 nP + (Q+D)n logn ) .\nBy Theorem 1, we can focus on the (1 + \u03b5, \u03b4)-ANN problem. Without loss of generality, we assume that each curve in T has exactly m vertices, and every query curve has exactly k vertices. If necessary, extra vertices can be added in an arbitrary manner to enforce this assumption without affecting the Fr\u00e9chet distance.\nThe high level idea of our preprocessing is to identify all query curves that are within a Fr\u00e9chet distance (1 +O(\u03b5))\u03b4 from each \u03c4i \u2208 T , group the curves that share similar structural characteristics, assign each group a unique key value, and store these key values in a trie D. It is possible for a query curve to belong to multiple groups. Each key value is associated with the subset of curves in T that induce that key value. Correspondingly, given a query curve \u03c3, we generate all possible key values for \u03c3 and search D with them. If some curve in T is retrieved, it is the desired answer; otherwise, we report \u201cno\u201d.\nThere are two challenges to overcome. First, it is impossible to examine all possible query curves. We can only check some space discretization in order to obtain a finite running time. To control the discretization error, it is easy to cover the input curves by a grid with an appropriate cell width; however, the grid size and hence the data structure size would then depend on some non-combinatorial parameters. We propose coarse encodings of query curves so that there are O( \u221a d/\u03b5)4d(k\u22121)(mn)4(k\u22121) of them. A query curve may have O( \u221a d/\u03b5)2d(k\u22122) coarse encodings. The second challenge is to efficiently generate all possible\ncoarse encodings of a query curve at query time. We reduce the coarse encoding generation to an approximate segment shooting problem. This step turns out to be the bottleneck in four and higher dimensions as we aim to avoid any factor of the form m\u2126(d) or n\u2126(d) in the space complexity. It is the reason for the (mn)0.5+\u03b5 term in the query time. In two and three dimensions, the approximate segment shooting problem can be solved more efficiently.\nIn the rest of this section, we present the coarse encoding and a (1 +O(\u03b5), \u03b4)-ANN data structure, using an approximate segment shooting oracle. The approximate segment shooting problem can be solved by the results in [8] in two and three dimensions. We solve the approximate segment shooting problem in four and higher dimensions in Section 4."
        },
        {
            "heading": "2.1 Coarse encodings of query curves",
            "text": "Imagine an infinite grid in Rd of cell width \u03b5\u03b4/ \u221a d. For any subset R \u2282 Rd, we use G(R)\nto denote the set of grid cells that intersect R. Let G1 = \u22c3 i\u2208[n],a\u2208[m]G(vi,a \u2295 B\u03b4). Let\nG2 = \u22c3 i\u2208[n],a\u2208[m]G(vi,a \u2295B(2+12\u03b5)\u03b4). Both G1 and G2 have O(mn/\u03b5d) size.\nThe coarse encoding of a curve \u03c3 = (w1, w2, . . . , wk) is a 3-tuple F = (A,B, C). The component C is sequence of pairs of grid cells ((cj,1, cj,2))j\u2208[k\u22121] such that (cj,1, cj,2) \u2208 (G1 \u00d7 G1) \u222a {null}. Both A and B are arrays of length k \u2212 1, and every element of A and B belongs to G2 \u222a {null}. We first provide the intuition behind the design of (A,B, C) before describing the constraints that realize the intuition.\nImagine that a curve \u03c4i \u2208 T is a (1 +O(\u03b5))-ANN of \u03c3. The data structure needs to cater for the preprocessing, during which the query curve \u03c3 is not available; it also needs to cater for the query procedure, during which we do not want to directly consult the input curves in T in order to avoid a linear dependence in mn.\nIn preprocessing, we use pairs of grid cells as surrogates of the possible query curve edges. The advantage is that we can enumerate all possible pairs of grid cells and hence cater for all possible query curve edges. Specifically, for j \u2208 [k\u2212 1], if (cj,1, cj,2) 6= null, it is the surrogate of wjwj+1, so wjwj+1 should pass near cj,1 and cj,2. Each non-null (cj,1, cj,2) corresponds to a contiguous subsequence vi,a, . . . , vi,b of vertices of \u03c4i that are matched to points in wjwj+1 in a Fr\u00e9chet matching. Of course, we do not know the Fr\u00e9chet matching, so we will need to enumerate and handle all possibilities. Also, since wjwj+1 is unknown in preprocessing, vi,a, . . . , vi,b can only be matched to a segment joining a vertex xj of cj,1 to a vertex yj of cj,2 so that dF (x\u2032jy\u2032j , \u03c4i[vi,a, vi,b]) \u2264 (1 +O(\u03b5))\u03b4 for some subsegment x\u2032jy\u2032j \u2286 xjyj . This property will be enforced in the data structure construction later.\nAt query time, given \u03c3 = (w1, . . . , wk), we will make approximate segment shooting queries to determine a sequence of cell pairs ((cj,1, cj,2))j\u2208[k\u22121]. We do not always use (cj,1, cj,2) as a surrogate for the edge wjwj+1 though. As mentioned in the previous paragraph, a non-null (cj,1, cj,2) denotes the matching of a contiguous subsequence of input curve vertices to wjwj+1; however, we must also allow the matching of a contiguous subsequence of vertices of \u03c3 to a single input edge. Therefore, after determining ((cj,1, cj,2))j\u2208[k\u22121], we still have the choice of using (cj,1, cj,2) as is or substituting it by the null value. For a technical reason, (c1,1, c1,2) and (ck\u22121,1, ck\u22121,2) are always kept non-null, so we have 2k\u22123 possible sequences of pairs of cells. Take one of these sequences. If (cr,1, cr,2) and (cs,1, cs,2) are two non-null pairs such that (cj,1, cj,2) = null for j \u2208 [r + 1, s\u2212 1], it means that no vertex of \u03c4i is matched to wjwj+1 for j \u2208 [r + 1, s\u2212 1]. As a result, the vertices wr+1, . . . , ws of \u03c3 are matched to the edge vi,bvi,b+1 of \u03c4i, where vi,b is the last vertex of \u03c4i matched to wrwr+1 in the current enumeration. We use the pair of cells A[r] and B[s] as the surrogate of the edge vi,bvi,b+1. So we require A[r] and B[s] to be near cr,2 and cs,1, respectively, because (cr,1, cr,2) is the surrogate of wrwr+1, and (cs,1, cs,2) is the surrogate of wsws+1. We have to try all possible locations of A[r] and B[s] in the vicinity of cr,2 and cs,1. A[r] and B[s] can be the surrogate for edges of multiple curves in T , which allows us to compare \u03c3 with multiple input curves simultaneously at query time. The constraint to be enforced is that wr+1, . . . , ws can be matched to a segment joining a vertex xr of A[r] and a vertex xs of B[s] so that dF (x\u2032rx\u2032s, \u03c3[wr+1, ws]) \u2264 (1 +O(\u03b5))\u03b4 for some subsegment x\u2032rx\u2032s \u2286 xrxs. Figure 1 shows a illustration for the intuition above.\nWe present the constraints for (A,B, C) that realize the intuition above. When (cj,1, cj,2) 6= null, a natural choice of cj,1 is the first grid cell in G1 that we hit when walking from wj to wj+1, i.e., segment shooting. In Rd where d \u2208 {2, 3}, there are ray shooting data structures for boxes [8]. In higher dimensions, ray shooting results are known for a single convex\nICALP 2023\npolytope and an arrangement of hyperplanes [1]; even in such cases, the query time is substantially sublinear only if the space complexity is at least the input size raised to a power of \u2126(d). It would be (mn)\u2126(d) in our case. We define a \u03bb-segment query problem below that approximates the ray shooting problem, and we will present an efficient solution for \u03bb = 11\u03b5\u03b4 in Section 4 that avoids an (mn)\u2126(d) term in the space complexity. As mentioned before, the ray shooting result in [8] suffices in two and three dimensions.\n\u03bb-segment query. A set O of objects in Rd is preprocessed into a data structure so that for any oriented query segment pq, the \u03bb-segment query with pq on O returns one of the following answers:\nIf pq intersects an object in O, let x be the first intersection point with an object in O as we walk from p to q. In this case, the query returns an object o \u2208 O such that px intersects o\u2295B\u03bb. Figure 2 shows an illustration. Otherwise, the query returns null or an object o \u2208 O such that d(o, pq) \u2264 \u03bb.\nWe are now ready to state the three constraints on (A,B, C). Constraint 1:\n(a) Both (c1,1, c1,2) and (ck\u22121,1, ck\u22121,2) belong to G1 \u00d7 G1. (b) For j \u2208 [k \u2212 1], if (cj,1, cj,2) 6= null, then:\n(i) cj,1 and cj,2 are the grid cells returned by the (11\u03b5\u03b4)-segment queries with wjwj+1 and wj+1wj on G1, respectively;\np q\nc c\u2032\nc\u2032\u2032 \u2295B\u03bb\nc\u2032 \u2295B\u03bb c\u2032\u2032\nWe remark that if wjwj+1 intersects the interior of the union of cells in G1, constraint 1(b)(ii) is satisfied automatically for (cj,1, cj,2) given constraint 1(b)(i). When wjwj+1 does not intersect the interior of the union of cells in G1, it is possible that the (11\u03b5\u03b4)-segment queries return two cells that violate constraint 1(b)(ii). In this case, the input vertices are too far from wjwj+1 to be matched to any point in wjwj+1 within a distance \u03b4, so we can set (cj,1, cj,2) to be null.\nThe next result shows that any query curve \u03c3 near a curve \u03c4i \u2208 T has a coarse encoding with some additional properties. These properties will be useful in the analysis. Let M denote a matching between \u03c3 and some \u03c4i \u2208 T . For any subcurve \u03c3\u2032 \u2286 \u03c3, we useM(\u03c3\u2032) to denote the subcurve of \u03c4i matched to \u03c3\u2032 byM.\nI Lemma 2. Let \u03c3 = (w1, . . . , wk) be a curve of k vertices. LetM be a matching between \u03c3 and \u03c4i \u2208 T such that dM(\u03c4i, \u03c3) \u2264 \u03b4. Let \u03c0\u0303j = {vi,a : a \u2208 [m\u22121], vi,a \u2208M(wjwj+1)\\M(wj)} for all j \u2208 [k \u2212 1]. Define \u03c0j = \u03c0\u0303j for all j \u2208 [k \u2212 2], \u03c0k\u22121 = {vi,m} \u222a \u03c0\u0303k\u22121, and \u03c00 = {vi,1 . . . , vi,m} \\ \u22c3k\u22121 j=1 \u03c0j. There is a coarse encoding (A,B, C) for \u03c3 that satisfies the following properties. (i) For j \u2208 [2, k \u2212 1], \u03c0j = \u2205 if and only if (cj,1, cj,2) = null. (ii) For all (r, s) \u2208 J , if r = 1 and \u03c01 = \u2205, let b1 = 1; otherwise, let br = max{b : vi,b \u2208 \u03c0r}.\nFor all (r, s) \u2208 J , there exist a point z \u2208 A[r] \u2229 \u03c4i,br and another point z\u2032 \u2208 B[s] \u2229 \u03c4i,br such that z \u2264\u03c4i,br z \u2032.\nProof. We define the component C as follows. Given that vi,1 \u2208 M(w1), w1w2 intersects the interior of the union of cells in G1, so the (11\u03b5\u03b4)-segment query with w1w2 on G1 must return some cell; we define it to be c1,1. Similarly, the (11\u03b5\u03b4)-segment query with w2w1 on G1 must return some cell; we define it to be c1,2. The pair (ck\u22121,1, ck\u22121,2) are also defined in a similar way as vi,m \u2208M(wk). Consider any j \u2208 [2, k\u2212 1]. If vi,a \u2208 \u03c0j for some a \u2208 [m], then vi,a \u2208M(wjwj+1), which implies that wjwj+1 intersects vi,a \u2295B\u03b4 and hence the interior of the union of cells in G1. Thus, (cj,1, cj,2) can be defined using the (11\u03b5\u03b4)-segment queries\nICALP 2023\nwith wjwj+1 and wj+1wj as before. On the other hand, if \u03c0j = \u2205, we define (cj,1, cj,2) to be null. Constraint 1 and property (i) in the lemma are thus satisfied.\nNext, we define A and B to satisfy constraints 2 and 3. As vi,1 \u2208M(w1) and vi,m \u2208M(wk), both d(w1, vi,1) and d(wk, vi,m) are at most \u03b4. So w1 lies in a cell in G(vi,1 \u2295B\u03b4) \u2282 G(vi,1 \u2295B(2+12\u03b5)\u03b4) \u2282 G2; we make this cell B[1]. Similarly, we define A[k \u2212 1] to be the cell in G2 that contains wk. Constraint 2 is thus enforced.\nFor j \u2208 [2, k \u2212 2], if (cj,1, cj,2) = null, let A[j] and B[j] be null, satisfying constraint 3(a). B[1] and A[k \u2212 1] have already been defined, and they belong to G2. Since w1 lies in a cell in G(vi,1 \u2295 B\u03b4) \u2282 G1, we have w1 \u2208 c1,1 \u2295 B11\u03b5\u03b4 by the (11\u03b5\u03b4)-segment query. Then, d(c1,1,B[1]) \u2264 11\u03b5\u03b4 as w1 \u2208 B[1]. Similarly, d(ck\u22121,2,A[k \u2212 1]) \u2264 11\u03b5\u03b4. So B[1] and A[k \u2212 1] satisfy constraint 3(b). It remains to discuss A[j] for j \u2208 [1, k \u2212 2] and B[j] for j \u2208 [2, k \u2212 1].\nConsider an arbitrary j\u2217 \u2208 [k \u2212 1] such that (cj\u2217,1, cj\u2217,2) 6= null. Recall that J is the set of (r, s) \u2208 [k \u2212 1] \u00d7 [k \u2212 1] such that r < s, (cr,1, cr,2) 6= null, (cs,1, cs,2) 6= null, and (cj,1, cj,2) = null for j \u2208 [r + 1, s\u2212 1]. Thus, if j\u2217 \u2264 k \u2212 2, it must exist as the first value in exactly one element of J , and if j\u2217 \u2265 2, it must also exist as the second value in exactly another element of J . As a result, it suffices to define A[r] and B[s] for every (r, s) \u2208 J and verify that constraints 3(b) and 3(c) are satisfied.\nTake any (r, s) \u2208 J . If \u03c0r 6= \u2205, it is legal to define br = max{b : vi,b \u2208 \u03c0r}. If \u03c0r = \u2205, then r = 1 because for any r > 1, \u03c0r 6= null by (i) as (cr,1, cr,2) 6= null by the definition of J . In the case that r = 1 and \u03c01 = \u2205, b1 is defined to be 1. Therefore, br is well defined for all (r, s) \u2208 J . The definition of br implies that br = max{b : vi,b \u2208M(wrwr+1)}. Since (cs,1, cs,2) 6= null and (cj,1, cj,2) = null for j \u2208 [r + 1, s \u2212 1], by (i), \u03c0s 6= \u2205 and \u03c0j = \u2205 for j \u2208 [r + 1, s \u2212 1]. It follows that vi,br+1 \u2208 \u03c0s which is a subset of M(wsws+1). Pick any point p \u2208 wrwr+1 and any point q \u2208 wsws+1 such that vi,br \u2208M(p) and vi,br+1 \u2208M(q).\nWe claim that pwr+1 \u2229 (cr,2 \u2295B11\u03b5\u03b4) and wsq \u2229 (cs,1 \u2295B11\u03b5\u03b4) are non-empty. Since cr,2 is the cell in G1 returned by the (11\u03b5\u03b4)-segment query with wr+1wr, for any intersection point x between wr+1wr and any cell in G1, we have xwr+1 \u2229 (cr,2\u2295B11\u03b5\u03b4) 6= \u2205 by definition. We have p \u2208 wrwr+1 \u2229 (vi,br \u2295 B\u03b4) by our choice of p; it means that p is an intersection point between wrwr+1 and a cell in G(vi,br \u2295B\u03b4) \u2282 G1. We can thus substitute p for x and conclude that pwr+1 \u2229 (cr,2 \u2295B11\u03b5\u03b4) 6= \u2205. Similarly, we get wsq \u2229 (cs,1 \u2295B11\u03b5\u03b4) 6= \u2205.\nBy our claim, when we walk from wr+1 to p, we hit cr,2 \u2295 B11\u03b5\u03b4 at some point p\u2032, and when we walk from ws to q, we hit cs,1\u2295B11\u03b5\u03b4 at some point q\u2032. Pick two points zr \u2208M(p\u2032) and zs \u2208 M(q\u2032). By definition, cr,2 \u2208 G(vir,ar \u2295 B\u03b4) for some \u03c4ir \u2208 T and some index ar \u2208 [m]. The cell width of cr,2 is \u03b5\u03b4/ \u221a d, so cr,2 \u2282 vir,ar \u2295B(1+\u03b5)\u03b4. By triangle inequality, p\u2032 \u2208 vir,ar \u2295B(1+12\u03b5)\u03b4 and hence zr \u2208 vir,ar \u2295B(2+12\u03b5)\u03b4, which implies that zr is contained in a cell in G(vir,ar \u2295B(2+12\u03b5)\u03b4) \u2282 G2. By a similar reasoning, we can also deduce that zs is contained in a cell in G2. We define A[r] and B[s] to be the cells in G2 that contain zr and zs, respectively. Figure 3 shows an illustration.\nSince d(cr,2, zr) \u2264 d(cr,2, p\u2032) + d(p\u2032, zr) \u2264 (1 + 11\u03b5)\u03b4, we get d(cr,2,A[r]) \u2264 (1 + 11\u03b5)\u03b4. Similarly, d(cs,1,B[s]) \u2264 (1 + 11\u03b5)\u03b4. This takes care of constraint 3(b).\nAs vi,br \u2208M(p) and p \u2264wrwr+1 p\u2032, we have vi,br \u2264\u03c4i M(p\u2032). Similarly, we haveM(q\u2032) \u2264\u03c4i vi,br+1 . Therefore, vi,br \u2264\u03c4i M(p\u2032) \u2264\u03c4i M(q\u2032) \u2264\u03c4i vi,br+1 . As zr \u2208M(p\u2032) and zs \u2208M(q\u2032), zr and zs satisfy property (ii) of the lemma. The distance between zr and any vertex xr of A[r] is at most \u03b5\u03b4. So is the distance between zs and any vertex xs of B[s]. Thus, we can use the linear interpolation I between xrxs and zrzs as a matching to get dI(xrxs, zrzs) \u2264 \u03b5\u03b4. Combining M and I shows that there is a matching between \u03c3[p\u2032, q\u2032] and xrxs within a distance of (1 + \u03b5)\u03b4. Since \u03c3[wr+1, ws] \u2286 \u03c3[p\u2032, q\u2032], we have thus verified constraint 3(c). J"
        },
        {
            "heading": "2.2 Data structure organization and construction",
            "text": "We construct G1 and G2 in O(mn/\u03b5d) time and space. We need a point location data structure for G2 which is organized as a multi-level tree as follows. The top-level tree has leaves corresponding to the intervals of the cells on the first coordinate axis. Each leaf is associated with the cells that project to the interval of that leaf, and these cells are stored in a second-level tree with leaves corresponding to the intervals of these cells on the second coordinate axis. Continuing in this manner yields d = O(1) levels, using O(|G2|) = O(mn/\u03b5d) space and O ( (mn/\u03b5d) log mn\u03b5 ) preprocessing time. A point location takes O(log mn\u03b5 ) time.\nThe (1+O(\u03b5), \u03b4)-ANN data structure is a trie D. Each key to be stored in D is a candidate coarse encoding, which is a 3-tuple (A,B, C) just like a coarse encoding. For a candidate coarse encoding, constraints 1(a), 2(a), 3(a), and 3(b) must be satisfied, but constraints 1(b), 2(b), and 3(c) are ignored. This difference is necessary because constraints 1(b), 2(b), and 3(c) require the query curve, which is not available in preprocessing. For each candidate coarse encoding E, let TE be the subset of input curves that are within a Fr\u00e9chet distance of (1 +O(\u03b5))\u03b4 from any query curve that has E as a coarse encoding, we will discuss shortly how to obtain the curves in TE .\nEach key E in D has O(k) size because E stores O(k) cells in G1 and G2. As a trie, D is a rooted tree with as many levels as the length of the key E. Searching in D boils down to visiting the appropriate child of an internal node of D. Each component of the key E is an element of G2 \u222a {null} or (G1 \u00d7 G1) \u222a {null}; there are O(m2n2/\u03b52d) possibilities. We keep a dictionary at each internal node of D for finding the appropriate child to visit in O(log mn\u03b5 ) time. Hence, the total search time of D is O(k log mn\u03b5 ).\nTo bound the size of D, observe that each key E at a leaf of D induces O(k) entries in the dictionaries at the ancestors of that leaf. There are O( \u221a d/\u03b5)4d(k\u22121)(mn)4(k\u22121) candidate\ncoarse encodings. So the total space taken by the dictionaries at the internal nodes is O( \u221a d/\u03b5)4d(k\u22121)(mn)4(k\u22121)k. We will show that if a query curve has E as a coarse encoding,\nany curve in TE is within a Fr\u00e9chet distance of (1 +O(\u03b5))\u03b4 from that query curve. Therefore, we only need to store one of the curves in TE at the leaf for E, and it suffices to store the index of this curve. Therefore, the total space complexity of D is O( \u221a d/\u03b5)4d(k\u22121)(mn)4(k\u22121)k.\nThe construction of D proceeds as follows. We initialize D to be empty. We enumerate all possible candidate coarse encodings based on constraints 1(a), 2(a), 3(a), and 3(b). Take a possible candidate coarse encoding E. The set TE is initialized to be empty. We go through every input curve \u03c4i to determine whether to include \u03c4i in TE . If TE 6= \u2205 in the end, we insert E together with one curve in TE into D. In the following, we discuss the checking of whether to include \u03c4i in TE .\nLet E be (A,B, C). We generate all possible partitions of {vi,1, . . . , vi,m} that satisfy the following properties.\nICALP 2023\nPartition: a sequence of k disjoint subsets (\u03c00, \u03c01, . . . , \u03c0k\u22121) such that \u22c3k\u22121 j=0 \u03c0j = {vi,1, . . . , vi,m}, vi,1 \u2208 \u03c00, vi,m \u2208 \u03c0k\u22121, \u03c0j may be empty for some j \u2208 [k \u2212 2], and for any vi,a \u2208 \u03c0j and any vi,b \u2208 \u03c0l, if j < l, then a < b.\nThere are fewer than mk\u22121 partitions. Given a partition (\u03c00, . . . , \u03c0k\u22121), the vertices in \u03c00 are to be matched with vi,1; for j \u2208 [k \u2212 1], the vertices in \u03c0j are to be matched with points in wjwj+1 \\ {wj}, where wjwj+1 is the j-th edge of the query curve; vi,m and possibly other vertices of \u03c4i are matched with wk. The reference to wjwj+1 is conceptual; we do not need to know the query curve in preprocessing.\nWe describe four tests for each partition below. As soon as we come across a partition that passes all four tests, we insert \u03c4i into TE . If a partition fails any test, we move on to the next partition. If no partition can pass all four tests in the end, we do not include \u03c4i in TE .\nThe first test is that for j \u2208 [2, k \u2212 1], \u03c0j = \u2205 if and only if (cj,1, cj,2) = null. This test takes O(k) time. We exclude \u03c01 from this test because (c1,1, c1,2) 6= null by constraint 1(a), whereas \u03c01 may be empty or not depending on the partition enumerated.\nIn the second test, for j \u2208 [k \u2212 1], if \u03c0j 6= \u2205, let aj , bj \u2208 [m] be the smallest and largest indices such that vi,aj , vi,bj \u2208 \u03c0j , the intuition is that vi,aj , . . . , vi,bj can be matched to the surrogate (cj,1, cj,2) of wjwj+1 within a distance of (1 +O(\u03b5))\u03b4. The second test checks this property as follows. Observe that (cj,1, cj,2) 6= null: (c1,1, c1,2) 6= null by constraint 1(a), and for j \u2208 [2, k\u22121], (cj,1, cj,2) 6= null by the first test. Pick the smallest vertices xj of cj,1 and yj of cj,2 according to the lexicographical order of their coordinates. If xjyj \u2229 (vi,aj \u2295B(1+12\u03b5)\u03b4) or xjyj \u2229 (vi,bj \u2295B(1+12\u03b5)\u03b4) is empty, the test fails. Otherwise, compute the minimum point x\u2032j in xjyj \u2229 (vi,aj \u2295B(1+12\u03b5)\u03b4) and the maximum point y\u2032j in xjyj \u2229 (vi,bj \u2295B(1+12\u03b5)\u03b4) with respect to \u2264xjyj . If it is not the case that x\u2032j \u2264xjyj y\u2032j , the test fails. Suppose that x\u2032j \u2264xjyj y\u2032j . Compute dF (x\u2032jy\u2032j , \u03c4i[vi,aj , vi,bj ]) and check whether it is (1 + 12\u03b5)\u03b4 or less. If all of the above checks succeed for all j \u2208 [k \u2212 1], the second test succeeds; otherwise, the test fails. The test takes O(m logm) time, which is dominated by the computation of dF (x\u2032jy\u2032j , \u03c4i[vi,aj , vi,bj ]) over all j \u2208 [k \u2212 1].\nThe third test is that B[1] \u2208 G(vi,1 \u2295B\u03b4) and A[k\u2212 1] \u2208 G(vi,m \u2295B\u03b4), which boils down to checking whether d(vi,1,B[1]) and d(vi,m,A[k \u2212 1]) are at most \u03b4.\nThe fourth test involves J , the set of (r, s) \u2208 [k\u22121]\u00d7 [k\u22121] such that r < s, (cr,1, cr,2) 6= null, (cs,1, cs,2) 6= null, and (cj,1, cj,2) = null for j \u2208 [r + 1, s\u2212 1]. Note that |J | \u2264 k \u2212 1 and it can be constructed in O(k) time. For every (r, s) \u2208 J , if r = 1 and \u03c01 = \u2205, let b1 = 1; otherwise, let br = max{b : vi,b \u2208 \u03c0r}. It follows that br + 1 = min{a : vi,a \u2208 \u03c0s}. We check if it is the case that \u03c4i,br \u2229 A[r] 6= \u2205, \u03c4i,br \u2229 B[s] 6= \u2205, and we hit A[r] no later than B[s] when we walk from vi,br to vi,br+1. (Recall the intuition that the pair A[r] and B[s] serve as the surrogate of the edge \u03c4i,br = vi,brvi,br+1.) If check fails for any (r, s) \u2208 J , the test fails. Otherwise, the test succeeds. This test runs in O(k) time.\nThe following result summarizes the construction of D and four properties of each candidate coarse encoding in D.\nI Lemma 3. The trie D has O( \u221a d/\u03b5)4d(k\u22121)(mn)4(k\u22121)k size and can be constructed in O( \u221a d/\u03b5)4d(k\u22121)(mn)4(k\u22121)(k log mn\u03b5 + m\nk logm) time. We can search D with a coarse encoding in O(k log mn\u03b5 ) time. For each candidate coarse encoding E = (A,B, C), a curve \u03c4i \u2208 T belongs to TE if and only if there exists a partition (\u03c00, . . . , \u03c0k\u22121) of the vertices of \u03c4i that satisfy the following four properties. For j \u2208 [k \u2212 1], if j = 1 and \u03c01 = \u2205, let b1 = 1; otherwise, if \u03c0j 6= \u2205, let aj = min{a : vi,a \u2208 \u03c0j} and let bj = max{b : vi,b \u2208 \u03c0j}. (i) For j \u2208 [2, k \u2212 1], \u03c0j = \u2205 if and only if (cj,1, cj,2) = null. (ii) For j \u2208 [k\u22121], if \u03c0j 6= \u2205, let xj and yj be the smallest vertices of cj,1 and cj,2 according\nto the lexicographical order of their coordinates, there exist x\u2032\u2032j , y\u2032\u2032j \u2208 xjyj such that x\u2032\u2032j \u2264xjyj y\u2032\u2032j and dF (x\u2032\u2032j y\u2032\u2032j , \u03c4i[vi,aj , vi,bj ]) \u2264 (1 + 12\u03b5)\u03b4.\n(iii) B[1] \u2208 G(vi,1 \u2295B\u03b4) and A[k \u2212 1] \u2208 G(vi,m \u2295B\u03b4). (iv) For every (r, s) \u2208 J , \u03c4i,br \u2229 A[r] 6= \u2205, \u03c4i,br \u2229 B[s] 6= \u2205, and we hit A[r] no later than\nB[s] when we walk from vi,br to vi,br+1."
        },
        {
            "heading": "2.3 Querying",
            "text": "At query time, we are given a curve \u03c3 = (w1, ..., wk). We enumerate all coarse encodings of \u03c3; for each coarse encoding E enumerated, we search the trie D for E; if E is found, we return the curve in TE stored with E as the answer of the query; if no coarse encoding of \u03c3 can be found in D, we return \u201cno\u201d.\nEach search in D takes O(k log mn\u03b5 ) time as stated in Lemma 3. The enumeration of the coarse encodings of \u03c3 require a solution for the (11\u03b5\u03b4)-segment queries on G1 as stated in constraint 1(b)(i) in Section 2.1. We will discuss an efficient solution later.\nFor j \u2208 [k \u2212 1], we make two (11\u03b5\u03b4)-segment queries with wjwj+1 and wj+1wj on G1 to obtain uj,1 and uj,2, respectively. If any of the two queries returns null, define (uj,1, uj,2) to be null. If (uj,1, uj,2) 6= null and the minimum point in wjwj+1 \u2229 (uj,1 \u2295 B11\u03b5\u03b4) does not lie in front of the maximum point in wjwj+1 \u2229 (uj,2 \u2295B11\u03b5\u03b4) with respect to \u2264wjwj+1 , then constraint 1(b)(ii) is not satisfied. It must be the case that wjwj+1 does not intersect the interior of the union of cells in G1, and the (11\u03b5\u03b4)-segment queries just happen to return two cells that violate constraint 1(b)(ii). In this case, the input vertices are too far from wjwj+1 to be matched to any point in wjwj+1 within a distance \u03b4, so we reset (uj,1, uj,2) to be null.\nAfter defining (uj,1, uj,2) for j \u2208 [k \u2212 1], we generate the coarse encodings of \u03c3 as follows. The pairs (c1,1, c1,2) and (ck\u22121,1, ck\u22121,2) are defined to be (u1,1, u1,2) and (uk\u22121,1, uk\u22121,2), respectively. For j \u2208 [2, k \u2212 2], we enumerate all possible C by setting (cj,1, cj,2) to be (uj,1, uj,2) or null. This gives a total of 2k\u22123 possible C\u2019s. We query the point location data structure for G2 to find the cells B[1] and A[k\u22121] that contain w1 and wk, respectively. Then, for each C enumerated, we enumerate A[j] for j \u2208 [1, k\u22122] and B[j] for j \u2208 [2, k\u22121] according to constraints 3(a) and 3(b) in Section 2.1. This enumeration produces O( \u221a d/\u03b5)2d(k\u22122) tuples\nof (A,B, C). For each (A,B, C) enumerated, we check whether it satisfies constraint 3(c), which can be done in O(k log k) time as implied by the following result.\nI Lemma 4. Take any (r, s) \u2208 J . Let xr and xs be the smallest vertices of A[r] and B[s] by the lexicographical order of their coordinates. We can check in O((s\u2212 r) log(s\u2212 r)) time whether there are x\u2032r, x\u2032s \u2208 xrxs such that x\u2032r \u2264xrxs x\u2032s and dF (x\u2032rx\u2032s, \u03c3[wr+1, ws]) \u2264 (1 + \u03b5)\u03b4. I Lemma 5. The query time is O(kQseg) +O( \u221a d/\u03b5)2d(k\u22122)k log mn\u03b5 , where Qseg is the time to answer an (11\u03b5\u03b4)-segment query."
        },
        {
            "heading": "2.4 Approximation guarantee",
            "text": "First, we show that if \u03c3 is within a Fr\u00e9chet distance \u03b4 from some input curve, there exists a coarse encoding E of \u03c3 such that TE 6= \u2205. Hence, E and a curve in TE are stored in D.\nI Lemma 6. If dF (\u03c4i, \u03c3) \u2264 \u03b4, then \u03c4i \u2208 TE for some coarse encoding E of \u03c3.\nProof. LetM be a Fr\u00e9chet matching between \u03c4i and \u03c3. Let E be the coarse encoding specified for \u03c3 in Lemma 2. For any subcurve \u03c3\u2032 \u2286 \u03c3, we use M(\u03c3\u2032) to denote the subcurve of \u03c4i matched to \u03c3\u2032 byM. For j \u2208 [k\u22121], let \u03c0\u0303j = {vi,a : a \u2208 [m\u22121], vi,a \u2208M(wjwj+1)\\M(wj)}.\nICALP 2023\nDefine \u03c0j = \u03c0\u0303j for j \u2208 [k \u2212 2], \u03c0k\u22121 = {vi,m} \u222a \u03c0\u0303k\u22121, and \u03c00 = {vi,1, . . . , vi,m} \\ \u22c3k\u22121 j=1 \u03c0j . We obtain a partition (\u03c00, ..., \u03c0k\u22121) of the vertices of \u03c4i. We prove that E, \u03c4i, and (\u03c00, ..., \u03c0k\u22121) satisfy Lemma 3(i)\u2013(iv) which put \u03c4i in TE . Lemma 3(i) follows directly from Lemma 2(i), Take any j \u2208 [k\u22121] such that \u03c0j 6= \u2205. Let \u03c0j be {vi,a, vi,a+1, . . . , vi,b}. By the definition of \u03c0j , every vertex in \u03c0j belongs toM(wjwj+1), so \u03c4i[vi,a, vi,b] \u2282M(wjwj+1). Then, there must exist two points p, q \u2208 wjwj+1 such that p \u2264wjwj+1 q and dF (pq, \u03c4i[vi,a, vi,b]) \u2264 \u03b4. If j = 1, we have (c1,1, c1,2) 6= null by constraint 1(a); if j \u2208 [2, k\u2212 1], by Lemma 2(i), (cj,1, cj,2) 6= null as \u03c0j 6= null. Therefore, cj,1 and cj,2 are cells in G1 returned by the (11\u03b5\u03b4)-segment queries with wjwj+1 and wj+1wj , respectively. We have shown that dF (pq, \u03c4i[vi,a, vi,b]) \u2264 \u03b4; therefore, p is contained in a cell in G(vi,a \u2295B\u03b4) \u2282 G1. As cj,1 is the cell returned by the (11\u03b5\u03b4)-segment query with wjwj+1, there must be a point zp \u2208 wjwj+1\u2229(cj,1\u2295B11\u03b5\u03b4) such that zp \u2264wjwj+1 p. In a similar way, we can conclude that there must be a point zq \u2208 wjwj+1 \u2229 (cj,2 \u2295B11\u03b5\u03b4) such that q \u2264wjwj+1 zq. That is, zp \u2264wjwj+1 p \u2264wjwj+1 q \u2264wjwj+1 zq. Let xj and yj be the smallest vertices of cj,1 and cj,2 according to the lexicographical order of their coordinates. Both d(zp, xj) and d(zq, yj) are at most 12\u03b5\u03b4. A linear interpolation from zpzq to xjyj maps p and q to two points x\u2032\u2032j and y\u2032\u2032j on xjyj , respectively, such that x\u2032\u2032j \u2264xjyj y\u2032\u2032j . Also, the linear interpolation adds a distance 12\u03b5\u03b4 or less, which gives dF (x\u2032\u2032j y\u2032\u2032j , \u03c4i[vi,a, vi,b]) \u2264 dF (x\u2032\u2032j y\u2032\u2032j , pq) + dF (pq, \u03c4i[vi,a, vi,b]) \u2264 (1 + 12\u03b5)\u03b4. Hence, Lemma 3(ii) is satisfied.\nThe grid cells B[1] and A[k \u2212 1] are defined to contain w1 and wk, respectively. Also, vi,1 \u2208M(w1) and vi,m \u2208M(wk). Hence, B[1] \u2208 G(vi,1 \u2295B\u03b4) and A[k \u2212 1] \u2208 G(vi,m \u2295B\u03b4), satisfying Lemma 3(iii).\nFor any pair (r, s) \u2208 J , by Lemma 2(ii), there exist two points z \u2208 A[r] \u2229 \u03c4i,br and z\u2032 \u2208 B[s] \u2229 \u03c4i,br such that z \u2264\u03c4i,br z\n\u2032. Since A[r] and B[s] are interior-disjoint unless they are equal, we must hit A[r] no later than B[s] when we walk from vi,br to vi,br+1, satisfying Lemma 3(iv). J\nWe show that if E is a coarse encoding of \u03c3, each curve in TE is close to \u03c3.\nI Lemma 7. Let E be a coarse encoding of \u03c3. For every \u03c4i \u2208 TE, dF (\u03c4i, \u03c3) \u2264 (1 + 24\u03b5)\u03b4.\nProof. (Sketch) Suppose that TE 6= \u2205 as the lemma statement is vacuous otherwise. Take any \u03c4i \u2208 TE . We construct a matchingM between \u03c4i and \u03c3 such that dM(\u03c4i, \u03c3) \u2264 (1 + 24\u03b5)\u03b4. Since TE 6= \u2205, there exists a partition (\u03c00, . . . , \u03c0k\u22121) of the vertices of \u03c4i that satisfy Lemma 3(i)\u2013(iv). Using these properties, we can match the vertices of \u03c4i to points on \u03c3 and then the vertices of \u03c3 to points on \u03c4i. Afterwards, \u03c3 and \u03c4i divided into line segments by their vertices and images of their matching partners. We use linear interpolations to match the corresponding line segments. More details can be found in the appendix. J\nIn two and three dimensions, the ray shooting data structure for boxes in [8] can be used as the (11\u03b5\u03b4)-segment query data structure. It has an O(log |G1|) = O(log mn\u03b5 ) query time and an O(|G1|2+\u00b5) = O((mn)2+\u00b5/\u03b5d(2+\u00b5)) space and preprocessing time for any fixed \u00b5 \u2208 (0, 1). If the query segment does not intersect any cell in G1, we return null. In four and higher dimensions, we will prove the following result in Section 4.\nI Lemma 8. We can construct a data structure in O( \u221a d/\u03b5)O(d/\u03b52) \u00b7 O\u0303((mn)O(1/\u03b52)) space\nand preprocessing time such that given any oriented edge e of the query curve \u03c3, the data structure either discovers that min\u03c4i\u2208T dF (\u03c3, \u03c4i) > \u03b4, or reports a correct answer for the (11\u03b5\u03b4)-segment query with e on G1. The query time is O\u0303((mn)0.5+\u03b5/\u03b5d).\nCombining the results in this section with the ray shooting result in [8], Lemma 8, and Theorem 1 gives (1 + \u03b5)-ANN data structures. Theorem 1 uses the deletion cost of a (1 + \u03b5, \u03b4)-ANN data structure. We perform each deletion by reconstructing the data structure from scratch because we do not have a more efficient solution.\nI Theorem 9. For any \u03b5 \u2208 (0, 0.5), there is a (1 +O(\u03b5))-ANN data structure for T under the Fr\u00e9chet distance with the following performance guarantees:\nd \u2208 {2, 3} : query time = O ( 1 \u03b5 )2d(k\u22122) k log mn\u03b5 logn,\nspace = O ( 1 \u03b5 )4d(k\u22121)+1(mn)4(k\u22121)k log2 n, expected preprocessing time = O ( 1 \u03b5\n)4d(k\u22121)(mn)4(k\u22121)(k log mn\u03b5 +mk logm)n logn. d \u2265 4 : query time = O\u0303 ( 1 \u03b5d k(mn)0.5+\u03b5 ) +O (\u221a d \u03b5 )2d(k\u22122) k log mn\u03b5 logn,\nspace = O (\u221a\nd \u03b5 )4d(k\u22121)(mn)4(k\u22121)k \u00b7 1\u03b5 log2 n+O(\u221ad\u03b5 )O(d/\u03b52) \u00b7 O\u0303((mn)O(1/\u03b52)), expected preprocessing time = O (\u221a d \u03b5\n)4d(k\u22121)(mn)4(k\u22121)(k log mn\u03b5 +mk logm)n logn + O (\u221a\nd \u03b5 )O(d/\u03b52) \u00b7 O\u0303((mn)O(1/\u03b52)). 3 (3 +O(\u03b5), \u03b4)-ANN\nGiven a query curve \u03c3 = (w1, w2, . . . , wk), for j \u2208 [k\u22121], we solve the (11\u03b5\u03b4)-segment queries with wjwj+1 and wj+1wj on G1 as before. Let ((cj,1, cj,2))j\u2208[k\u22121] denote the results of the queries. Recall that each (cj,1, cj,2) belongs to (G1 \u00d7 G1) \u222a {null}.\nSuppose that there are k0 \u2264 k \u2212 1 non-null pairs in ((cj,1, cj,2))j\u2208[k\u22121]. Extract these non-null pairs to form the sequence ((cjr,1, cjr,2))r\u2208[k0]. Note that j1 = 1 and jk0 = k \u2212 1 by constraint 1(a). We construct a polygonal curve \u03c30 by connecting the centers of cjr,1 and cjr,2 for r \u2208 [k0] and the centers of cjr,2 and cjr+1,1 for r \u2208 [k0 \u2212 1]. The polygonal curve \u03c30 acts as a surrogate of \u03c3. It has at most 2k \u2212 2 vertices. We will use \u03c30 as the key to search a trie at query time to obtain an answer for a (3 +O(\u03b5), \u03b4)-ANN query. As a result, no enumeration is needed which avoids the exponential dependence of the query time on k.\nIn preprocessing, we enumerate all sequences of 2l cells in G1 for l \u2208 [2, k \u2212 1]. For each sequence, we construct the polygonal curve \u03c3\u2032 that connects the centers of the cells in the sequence, and we find the nearest input curve \u03c4i to \u03c3\u2032. If dF (\u03c3\u2032, \u03c4i) \u2264 (1 + 12\u03b5)\u03b4, we store (\u03c3\u2032, i) in a trie D. There are O( \u221a d/\u03b5)2d(k\u22121)(mn)2(k\u22121) entries in D. We organize\nthe trie D in the same way as described in Section 2.2. The space required by D is O( \u221a d/\u03b5)2d(k\u22121)(mn)2(k\u22121)k. The search time of D is O(k log mn\u03b5 ). The preprocessing time\nis O( \u221a d/\u03b5)2d(k\u22121)(mn)2(k\u22121)(k log mn\u03b5 + kmn log(km)) = O( \u221a d/\u03b5)2d(k\u22121)(mn)2k\u22121k log mn\u03b5 due to the computation of the nearest input curve for each sequence enumerated. At query time, we construct \u03c30 from \u03c3 in O(kQseg) time, where Qseg is the time to answer a (11\u03b5\u03b4)-segment query. We compute dF (\u03c3, \u03c30) in O(k2 log k) time. If dF (\u03c3, \u03c30) > (2 + 12\u03b5)\u03b4, we report \u201cno\u201d. Otherwise, we search D with \u03c30 in O(k log mn\u03b5 ) time. If the search fails, we report \u201cno\u201d. Otherwise, the search returns (\u03c30, i) for some i \u2208 [n].\nI Lemma 10. If dF (\u03c3, \u03c30) \u2264 (2 + 12\u03b5)\u03b4 and the search in D with \u03c30 returns (\u03c30, i), then dF (\u03c3, \u03c4i) \u2264 (3 + 24\u03b5)\u03b4. Otherwise, min\u03c4i\u2208T dF (\u03c3, \u03c4i) > \u03b4.\nCombining the results in this section with the ray shooting results in two and three dimensions [8], Lemma 8, and Theorem 1, we obtain the following theorem.\nICALP 2023\nI Theorem 11. For any \u03b5 \u2208 (0, 0.5), there is a (3 +O(\u03b5))-ANN data structure for T under the Fr\u00e9chet distance with the following performance guarantees:\nd \u2208 {2, 3}: query time = O(k log mn\u03b5 logn), space = O ( 1 \u03b5\n)2d(k\u22121)+1(mn)2(k\u22121)k log2 n, expected preprocessing time = O ( 1 \u03b5\n)2d(k\u22121)(mn)2k\u22121kn log mn\u03b5 logn. d \u2265 4 : query time = O\u0303 ( 1 \u03b5d k(mn)0.5+\u03b5 ) ,\nspace = O (\u221a\nd \u03b5 )2d(k\u22121)(mn)2(k\u22121)k \u00b7 1\u03b5 log2 n+O(\u221ad\u03b5 )O(d/\u03b52) \u00b7 O\u0303((mn)O(1/\u03b52)), expected preprocessing time = O (\u221a d \u03b5\n)2d(k\u22121)(mn)2k\u22121kn log mn\u03b5 logn + O (\u221a\nd \u03b5 )O(d/\u03b52) \u00b7 O\u0303((mn)O(1/\u03b52)). 4 (11\u03b5\u03b4)-segment queries and proof of Lemma 8\nWe describe the (11\u03b5\u03b4)-segment query data structure in Lemma 8. We first present the main ideas before giving the details. Let wjwj+1 be a query segment, which is unknown at preprocessing. There are three building blocks.\nFirst, the intuition is to capture the support lines of all possible query segments using pairs of cells in G1. It would be ideal to retrieve a pair of cells intersected by aff(wjwj+1), but this seems to be as difficult as the ray shooting problem. For a technical reason, we need to use more grid cells in a larger neighborhood of the input vertices than in G1, so define G3 = \u22c3 i\u2208[n],a\u2208[m]G(vi,a \u2295B(1+6\u03b5)\u03b4).\nWe find a grid vertex x of G1 that is a (1 + \u03b5)-approximate nearest grid vertex to aff(wjwj+1). We will show that if d(x, aff(wjwj+1)) > (1 + \u03b5)\u03b5\u03b4, the answer to the (11\u03b5\u03b4)segment query is null; otherwise, we can find a cell \u03b3 \u2208 G3 near x that intersects aff(wjwj+1). We can use any other cell c \u2208 G1 to form a pair with \u03b3 that acts as a surrogate for the support lines of query segments that pass near c and \u03b3.\nSecond, given wjwj+1 at query time, among all possible choices of c, we need to find the right one(s) efficiently so that (c, \u03b3) is a surrogate for aff(wjwj+1). We explain the ideas using the case that wj+1 lies between wj and aff(wjwj+1)\u2229 \u03b3. Note that wj may not be near any cell in G1. In order that min\u03c4i\u2208T d(\u03c3, \u03c4i) \u2264 \u03b4, wj must be within a distance \u03b4 from some input edge \u03c4i,a. We find a maximal packing of aff(\u03c4i,a)\u2295BO(\u03b4) using lines that are parallel to \u03c4i,a and are at distance \u0398(\u03b5\u03b4) or more apart. There are O(\u03b51\u2212d) lines in the packing, and every point in aff(\u03c4i,a)\u2295B\u03b4 is within a distance O(\u03b5\u03b4) from some line in the packing. The projection of wj to the approximately nearest line approximates the location of wj . Hence, we should seek to divide the lines in the packing into appropriate segments so that, given wj and its approximately nearest line in the packing, we can efficiently find the segment that contains the projection of wj and retrieve some precomputed information for that segment.\nThird, let ` be a line in the packing mentioned above, for each possible cell c \u2208 G1, we use the geometric construct F (c, \u03b3) = {x \u2208 Rd : \u2203 y \u2208 \u03b3 s.t. xy \u2229 c 6= \u2205} defined in [6] which can be computed in O(1) time. The projection of (`\u2295B2\u03b5\u03b4)\u2229F (c, \u03b3) in ` is the set of points on ` such that if the projection of wj is in it, then (c, \u03b3) is a surrogate for aff(wjwj+1). As a result, the endpoints of the projections of (`\u2295B2\u03b5\u03b4) \u2229 F (c, \u03b3) over all possible choices of c divide ` into segments that we desire. Each segment may stand for several choices of c\u2019s. For each segment, we store the cell c\u2032 close to that segment because the ideal choice is the cell that we hit first as we walk from wj to wj+1.\nAs described above, we use two approximate nearest neighbor data structures that involve\nlines. The first one is due to Andoni et al. [4] which stores a set of points P such that given a query line, the (1 + \u03b5)-approximate nearest point to the query line can be returned in O\u0303(d3|P |0.5+\u03b5) time. It uses O\u0303 ( d2|P |O(1/\u03b52) ) space and preprocessing time. The second result\nis due to Agarwal et al. [2] which stores a set L of lines such that given a query point, the 2-approximate nearest line to the query point can be returned in O\u0303(1) time. It uses O\u0303(|L|2) space and expected preprocessing time."
        },
        {
            "heading": "4.1 Data structure organization",
            "text": "We restrict \u03b5 to be chosen from (0, 0.5). We construct the data structure of Andoni et al. [4] for the grid vertices of G1 so that for any query line, the (1 + \u03b5)-approximate nearest grid vertex can be returned in O\u0303((mn)0.5+\u03b5/\u03b5d) time. We denote this data structure by Danp. It takes O( \u221a d/\u03b5)O(d/\u03b52) \u00b7 O\u0303((mn)O(1/\u03b52)) space and preprocessing time.\nFor each input edge \u03c4i,a, define a set of lines Li,a as follows. Let H be the hyperplane through vi,a orthogonal to aff(\u03c4i,a). Take a (d\u2212 1)-dimensional grid in H with vi,a as a grid vertex and cell width \u03b5\u03b4/ \u221a d\u2212 1. The set Li,a includes every line that is orthogonal to H and passes through a vertex of this grid in H at distance within (1 + 2\u03b5)\u03b4 from vi,a. The set Li,a has O(\u03b51\u2212d) size, and it can be constructed in O(\u03b51\u2212d) time. Moreover, every point in the cylinder aff(\u03c4i,a)\u2295B\u03b4 is within a distance \u03b5\u03b4 from some line in Li,a.\nDefine L = \u22c3 i\u2208[n],a\u2208[m\u22121] Li,a. The size of L is O(mn/\u03b5d\u22121), and L can be constructed in O(mn/\u03b5d\u22121) time. We construct the data structure of Agarwal et al. [2] for L so that for any query point, a 2-approximate nearest line in L can be returned in O\u0303(1) time. We denote this data structure by Danl. It uses O\u0303((mn)2/\u03b52d\u22122) space and expected preprocessing time.\nRecall that G3 = \u22c3 i\u2208[n],a\u2208[m]G(vi,a \u2295B(1+6\u03b5)\u03b4).\nFor every \u03b3 \u2208 G3 and every c \u2208 G1, we construct F (c, \u03b3) = {x \u2208 Rd : \u2203 y \u2208 \u03b3 s.t. xy \u2229 c 6= \u2205}, which is empty or an unbounded convex polytope of O(1) size that can be constructed in O(1) time as a Minkowski sum [6]. The total time needed is O((mn)2/\u03b52d).\nFor every \u03b3 \u2208 G3, every c \u2208 G1, and every line ` \u2208 L, compute the intersection (`\u2295B2\u03b5\u03b4)\u2229 F (c, \u03b3) and project it orthogonally to a segment in `. Take any line ` \u2208 L. The resulting segment endpoints in ` divide ` into canonical segments. There are O((mn)2/\u03b52d) canonical segments in `. For every cell \u03b3 \u2208 G3 and every canonical segment \u03be \u2286 `, compute the set C\u03b3,\u03be of every cell c \u2208 G1 such that \u03be is contained in the projection of (`\u2295B2\u03b5\u03b4) \u2229 F (c, \u03b3) onto `. Fix an arbitrary point in \u03be and denote it by p\u03be. Each C\u03b3,\u03be has O(mn/\u03b5d) size. The total time needed over all cells in G3 and all canonical segments in all lines in L is O\u0303((mn)5/\u03b55d\u22121).\nLet p\u03b3 be the center of the cell \u03b3. Define c\u03b3,\u03be to be the cell in C\u03b3,\u03be such that p\u03bep\u03b3 \u2229 (c\u03b3,\u03be\u2295B5\u03b5\u03b4) is nearest to p\u03be among {p\u03bep\u03b3 \u2229 (c\u2295B5\u03b5\u03b4) : c \u2208 C\u03b3,\u03be}. The total time to compute c\u03b3,\u03be over all cells in G3 and all canonical segments in all lines in L is O((mn)5/\u03b55d\u22121).\nFinally, for every line ` \u2208 L, we store the canonical segments in ` in an interval tree T` [7]. It uses linear space and preprocessing time. For any query point in `, one can search T` in O(log mn\u03b5 ) time to find the canonical segment in ` that contains the query point. For each canonical segment \u03be stored in T`, we keep a dictionary T\u03be that stores the set {(\u03b3, c\u03b3,\u03be) : \u03b3 \u2208 G3} with \u03b3 as the key. For any cell \u03b3 \u2208 G3, we can search T\u03be in O(log mn\u03b5 ) time to report c\u03b3,\u03be. These interval trees and dictionaries have a total size of O((mn)4/\u03b54d\u22121), and they can be constructed in O\u0303((mn)4/\u03b54d\u22121) time.\nThe data structures Danp, Danl, T` for ` \u2208 L, and T\u03be for all canonical segments \u03be\u2019s are what we need to support the (11\u03b5\u03b4)-segment queries on G1.\nI Lemma 12. We can construct Danp, Danl, T` for ` \u2208 L, and T\u03be for every ` \u2208 L and every canonical segment \u03be \u2282 ` in O( \u221a d/\u03b5)O(d/\u03b52) \u00b7 O\u0303((mn)O(1/\u03b52)) space and preprocessing time.\nICALP 2023\nIn the definition of c\u03b3,\u03be, one may ask what if p\u03bep\u03b3 does not intersect c\u2295B5\u03b5\u03b4 for some c \u2208 C\u03b3,\u03be. We prove that this cannot happen. We also establish some other properties.\nI Lemma 13. Let \u03b3 be a cell in G3. Let \u03be be a canonical segment. Let L\u03be be the cylinder with \u03be as the axis and radius 2\u03b5\u03b4. (i) For every cell c \u2208 G1, if c \u2229 xy 6= \u2205 for some points x \u2208 L\u03be and y \u2208 \u03b3, then c \u2208 C\u03b3,\u03be. (ii) For every point x \u2208 L\u03be, every point y \u2208 \u03b3 and every cell c \u2208 C\u03b3,\u03be, xy \u2229 (c\u2295B5\u03b5\u03b4) 6= \u2205. (iii) Let \u03bb be any value greater than or equal to 11\u03b5\u03b4. When we walk from a point x \u2208 L\u03be\nto a point y \u2208 \u03b3, we cannot hit any c \u2208 C\u03b3,\u03be earlier than c\u03b3,\u03be \u2295B\u03bb irrespective of the choices of x and y."
        },
        {
            "heading": "4.2 Answering a query",
            "text": "Given an oriented segment wjwj+1 of the query curve \u03c3, we answer the (11\u03b5\u03b4)-segment query with wjwj+1 on G1 by the following steps.\nStep 1: We query Danp with aff(wjwj+1) to report a grid vertex x of G1. This takes O\u0303((mn)0.5+\u03b5/\u03b5d) time.\nStep 2: We check the distance d(x, aff(wjwj+1)). If d(x, aff(wjwj+1)) > (1 + \u03b5)\u03b5\u03b4, then aff(wjwj+1) is at distance more than \u03b5\u03b4 from the closest grid vertex of G1, which implies that aff(wjwj+1) does not intersect any cell in G1. In this case, we report null. We also check the distances d(wj ,L) and d(wj+1,L). We query Danl with wj in O\u0303(1) time to find a line `j \u2208 L. If d(wj , `j) > 2\u03b5\u03b4, then d(wj ,L) > \u03b5\u03b4, which implies that wj is at distance farther than \u03b4 from aff(\u03c4i,a) for any \u03c4i \u2208 T and any a \u2208 [m\u2212 1]. As a result, dF (\u03c3, \u03c4i) > \u03b4 for all \u03c4i \u2208 T , so we report \u201cno\u201d for the (\u03ba, \u03b4)-ANN query. Analogously, we query Danl with wj+1 in O\u0303(1) time to find a line `j+1 \u2208 L. If d(wj+1, `j+1) > 2\u03b5\u03b4, we report \u201cno\u201d for the (\u03ba, \u03b4)-ANN query.\nStep 3: Suppose that d(x, aff(wjwj+1)) \u2264 (1 + \u03b5)\u03b5\u03b4, d(wj , `j) \u2264 2\u03b5\u03b4, and d(wj+1, `j+1) \u2264 2\u03b5\u03b4. Then, we check the cells in G(x\u2295B2\u03b5\u03b4) in O(\u03b5\u2212d) time to find one that intersects aff(wjwj+1). Let \u03b3 be this cell. We do not know if \u03b3 belongs to G1 or not. Nevertheless, since x is a grid vertex of G1, \u03b3 is within a distance (1 + 3\u03b5)\u03b4 from some input curve vertex. Therefore, \u03b3 must be a cell in G3. There are three cases depending on the relative positions of wj and \u03b3.\nStep 3(a): wj \u2208 \u03b3 \u2229 aff(wjwj+1). We claim that G1 \u2229G(wj \u2295B7\u03b5\u03b4) is non-empty, and we report an arbitrary cell in it as the answer for the (11\u03b5\u03b4)-segment query. This step takes O(\u03b5\u2212d) time. Step 3(b): wj precedes \u03b3 \u2229 aff(wjwj+1) along aff(wjwj+1) oriented from wj to wj+1. We query T`j to find the canonical segment \u03be \u2282 `j that contains the projection of wj in `j . Then, we query T\u03be with \u03b3 to return c\u03b3,\u03be as the answer for the (11\u03b5\u03b4)-segment query. The time needed is O(log mn\u03b5 ). Step 3(c): \u03b3\u2229aff(wjwj+1) precedes wj along aff(wjwj+1) oriented from wj to wj+1. We query T`j+1 to find the canonical segment \u03be \u2282 `j+1 that contains the projection of wj+1 in `j+1. Then, we query T\u03be with \u03b3 to obtain c\u03b3,\u03be. We claim that G(c\u03b3,\u03be \u2295B5\u03b5\u03b4) \u2282 G3 and some cell in G(c\u03b3,\u03be \u2295 B5\u03b5\u03b4) intersects wjwj+1. Pick one such cell \u03b3\u0302 in O(\u03b5\u2212d) time. Either step 3(a) or 3(b) is applicable with \u03b3 replaced by \u03b3\u0302. Whichever case is applicable, we jump to that case with \u03b3 replaced by \u03b3\u0302 to return an answer for the (11\u03b5\u03b4)-segment query. The time needed is O\u0303(\u03b5\u2212d).\nI Lemma 14. It takes O\u0303((mn)0.5+\u03b5/\u03b5d) time to answer a (11\u03b5\u03b4)-segment query.\nLemmas 12 and 14 gives the performance of the (11\u03b5\u03b4)-segment query data structure in Lemma 8. In Appendix G, we prove the query output correctness in Lemma 8.\n5 Conclusion\nWe present (1 + \u03b5)-ANN and (3 + \u03b5)-ANN data structures that achieve sublinear query times without having space complexities that are proportion to min{m\u2126(d), n\u2126(d)} or exponential in min{m,n}. The query times are O\u0303(k(mn)0.5+\u03b5/\u03b5O(d) + k(d/\u03b5)O(dk)) for (1 + \u03b5)-ANN and O\u0303(k(mn)0.5+\u03b5/\u03b5O(d)) for (3 + \u03b5)-ANN. In two and three dimensions, the query times can be improved to O\u0303(k/\u03b5O(k)) for (1 + \u03b5)-ANN and O\u0303(k) for (3 + \u03b5)-ANN. It is an open problem is to lower the exponential dependence on d and k.\nICALP 2023\nReferences 1 P.K. Agarwal and J. Matou\u0161ek. Ray shooting and parametric search. SIAM Journal on\nComputing, 22(4):794\u2013806, 1993. 2 P.K. Agarwal, N. Rubin, and M. Sharir. Approximate nearest neighbor search amid higher-\ndimensional flats. In Proceedings of the European Symposium on Algorithms, pages 4:1\u20134:13, 2017.\n3 H. Alt and M. Godau. Computing the Fr\u00e9chet distance between two polygonal curves. International Journal of Computational Geometry and Applications, 5:75\u201391, 1995.\n4 A. Andoni, P. Indyk, R. Krauthgamer, and H.L. Nguyen. Approximate line nearest neighbor in high dimensions. In Proceedings of the ACM-SIAM Symposium on Discrete Algorithms, pages 293\u2013301, 2009.\n5 K. Bringmann, A. Driemel, A. Nusser, and I. Psarros. Tight bounds for approximate near neighbor searching for time series under Fr\u00e9chet distance. In Proceedings of the ACM-SIAM Symposium on Discrete Algorithms, pages 517\u2013550, 2022.\n6 S.-W. Cheng and H. Huang. Curve simplification and clustering under Fr\u00e9chet distance. In Proceedings of the ACM-SIAM Symposium on Discrete Algorithms, pages 1414\u20131432, 2023.\n7 T.H. Cormen, C.E. Leiserson, R.L. Rivest, and C. Stein. Introduction to Algorithms. MIT Press, second edition, 2001.\n8 M. de Berg, D. Halperin, M. Overmars, J. Snoeyink, and M. van Kreveld. Efficient ray shooting and hidden surface removal. Algorithmica, 12:30\u201353, 1994.\n9 A. Driemel, A. Krivo\u0161ija, and C. Sohler. Clustering time series under the Fr\u00e9chet distance. In Proceedings of the ACM-SIAM Symposium on Discrete Algorithms, pages 766\u2013785, 2016.\n10 A. Driemel and I. Psarros. (2 + )-ANN for time series under the Fr\u00e9chet distance. arXiv preprint arXiv:2008.09406v5, 2021.\n11 A. Driemel and F. Silvestri. Locality-sensitive hashing of curves. In Proceedings of the International Symposium on Computational Geometry, pages 37:1\u201337:16, 2017."
        },
        {
            "heading": "12 T. Eiter and H. Mannila. Computing discrete Fr\u00e9chet distance. Technical Report CD-TR",
            "text": "94/64, Christian Doppler Laboratory for Expert Systems, TU Vienna, Austria, 1994."
        },
        {
            "heading": "13 I.Z. Emiris and I. Psarros. Products of Euclidean metrics, applied to proximity problems among curves: Unified treatment of discrete fr\u00e9chet and dynamic time warping distances.",
            "text": "ACM Transactions on Spatial Algorithms and Systems, 6(4):1\u201320, 2020."
        },
        {
            "heading": "14 A. Filtser, O. Filtser, and M.J. Katz. Approximate nearest neighbor for curves: simple,",
            "text": "efficient, and deterministic. In Proceedings of the International Colloquium on Automata, Languages, and Programming, pages 48:1\u201348:19, 2020.\n15 S. Har-Peled. A replacement for Voronoi diagrams of near linear size. In Proceedings of the Annual IEEE Symposium on Foundations of Computer Science, pages 94\u2013103, 2001."
        },
        {
            "heading": "16 S. Har-Peled, P. Indyk, and R. Motwani. Approximate nearest neighbor: towards removing",
            "text": "the curse of dimensionality. Theory of Computing, 8:321\u2013350, 2012."
        },
        {
            "heading": "17 P. Indyk. Approximate nearest neighbor algorithms for Fr\u00e9chet distance via product metrics.",
            "text": "In Proceedings of the Annual Symposium on Computational Geometry, pages 102\u2013106, 2002."
        },
        {
            "heading": "18 P. Indyk and R. Motwani. Approximate nearest neighbor: towards removing the curse of",
            "text": "dimensionality. In Proceedings of the Annual ACM Symposium on Theory of Computing, pages 604\u2013613, 1998."
        },
        {
            "heading": "19 Mirzanezhad M. On the approximate nearest neighbor queries among curves under the Fr\u00e9chet",
            "text": "distance. arXiv preprint arXiv:2004.08444, 2020."
        },
        {
            "heading": "20 C. Shahabi, M. Kolahdouzan, and M. Sharifzadeh. A road network embedding technique for",
            "text": "k-nearest neighbor search in moving object databases. GeoInformatica, 7:255\u2013273, 2003.\n21 Z. Song and N. Roussopoulos. K-nearest neighbor search for moving query point. In Proceedings of the International Symposium on Spatial and Temporal Databases, pages 79\u201396, 2001.\n22 Y. Tao and D. Papadias. Parameterized queries in spatio-temporal databases. In Proceedings of ACM International Conference on Management of Data, pages 334\u2013345, 2002.\nA Proof of Lemma 3\nThe performance analysis of D follows from the previous discussion. Among the four necessary and sufficient conditions, (i), (iii), and (iv) follow directly from the first, third, and fourth tests. We show below that the second test and condition (ii) are equivalent. Clearly, if the second test succeeds, condition (ii) is satisfied. It remains to analyze the other direction. By condition (ii), x\u2032\u2032j \u2264xjyj y\u2032\u2032j , x\u2032\u2032j \u2208 vi,aj \u2295B(1+12\u03b5)\u03b4, and y\u2032\u2032j \u2208 vi,bj \u2295B(1+12\u03b5)\u03b4. In the second test, we compute the minimum point x\u2032j in xjyj \u2229 (vi,aj \u2295 B(1+12\u03b5)\u03b4) and the maximum point y\u2032j in xjyj \u2229 (vi,bj \u2295 B(1+12\u03b5)\u03b4) with respect to \u2264xjyj . It follows that x\u2032j \u2264xjyj x\u2032\u2032j \u2264xjyj y\u2032\u2032j \u2264xjyj y\u2032j . We extend the Fr\u00e9chet matching between x\u2032\u2032j y\u2032\u2032j and \u03c4i[vi,aj , vi,bj ] to a matching M between x\u2032jy\u2032j and \u03c4i[vi,aj , vi,bj ] by matching vi,aj with all points in x\u2032jx\u2032\u2032j and vi,bj with all points in y\u2032\u2032j y\u2032j . As x\u2032j , x\u2032\u2032j \u2208 vi,aj \u2295 B(1+12\u03b5)\u03b4, convexity implies that x\u2032jx\u2032\u2032j \u2282 vi,aj \u2295 B(1+12\u03b5)\u03b4. Similarly, y\u2032\u2032j y\u2032j \u2282 vi,bj \u2295 B(1+12\u03b5)\u03b4. Therefore, dF (x\u2032jy\u2032j , \u03c4i[vi,aj , vi,bj ]) \u2264 dM(x\u2032jy\u2032j , \u03c4i[vi,aj , vi,bj ]) \u2264 (1 + 12\u03b5)\u03b4.\nB Proof of Lemma 4\nIf xrxs \u2229 (wr+1 \u2295B(1+\u03b5)\u03b4) or xrxs \u2229 (ws \u2295B(1+\u03b5)\u03b4) is empty, the required x\u2032r and x\u2032s do not exist. Suppose not. Let p be the minimum point in xrxs \u2229 (wr+1 \u2295 B(1+\u03b5)\u03b4) with respect to \u2264xrxs . Let q be the maximum point in xrxs \u2229 (ws \u2295 B(1+\u03b5)\u03b4). We can check p \u2264xrxs q and compute dF (pq, \u03c3[wr+1, ws]) in O((s \u2212 r) log(s \u2212 r)) time. We claim that there is a segment x\u2032rx\u2032s \u2286 xrxs that satisfies the lemma if and only if pq satisfies the lemma. The reverse direction is trivial. The forward direction can be proved in the same way as in the proof of Lemma 3.\nC Proof of Lemma 5\nWe spend O(log mn\u03b5 ) time to obtain B[1] andA[k\u22121]. Then, we spend O(kQseg) time to obtain (uj,1, uj,2) for j \u2208 [k\u22121] and O(k log mn\u03b5 ) search time for each coarse encoding of \u03c3. There are 2k\u22123 combinations in setting (cj,1, cj,2) to be (uj,1, uj,2) or null for j \u2208 [2, k \u2212 2]. This gives 2k\u22123 possible C\u2019s. By constraint 3(b), for j \u2208 [1, k \u2212 2], we have A[j] \u2208 G(cj,2 \u2295B(1+11\u03b5)\u03b4), and for j \u2208 [2, k \u2212 1], we have B[j] \u2208 G(cj,1 \u2295B(1+11\u03b5)\u03b4). Therefore, for each C enumerated, there are O( \u221a d/\u03b5)2d(k\u22122) ways to set A and B. In all, the total number of (A,B, C)\u2019s enumerated and checked is O( \u221a d/\u03b5)2d(k\u22122)2k\u22123 = O( \u221a d/\u03b5)2d(k\u22122). It takes O(k log k) time\nto check each by Lemma 4.\nD Proof of Lemma 7\nSuppose that TE 6= \u2205 as the lemma statement is vacuous otherwise. Take any \u03c4i \u2208 TE . We construct a matchingM between \u03c4i and \u03c3 such that dM(\u03c4i, \u03c3) \u2264 (1 + 24\u03b5)\u03b4. Since TE 6= \u2205, there exists a partition (\u03c00, . . . , \u03c0k\u22121) of the vertices of \u03c4i that satisfy Lemma 3(i)\u2013(iv).\nWe first match the vertices of \u03c4i to points on \u03c3 as follows. We match vi,1 and vi,m to w1 and wk, respectively. According to constraint 2 and Lemma 3(iii), we have d(vi,1, w1) \u2264 (1 + \u03b5)\u03b4 and d(vi,m, wk) \u2264 (1 + \u03b5)\u03b4. By Lemma 3(ii), for j \u2208 [k \u2212 1], if \u03c0j 6= \u2205 and \u03c0j = {vi,aj , vi,aj+1, . . . , va,bj}, there exist a segment x\u2032\u2032j y\u2032\u2032j between vertices of cj,1 and cj,2 such that vi,aj , ..., vi,bj can be matched to some points pi,aj , . . . , pi,bj \u2208 x\u2032\u2032j y\u2032\u2032j within a distance (1+12\u03b5)\u03b4 in order along x\u2032\u2032j y\u2032\u2032j . We have (c1,1, c1,2) 6= null by definition, and Lemma 3(i) implies that if j \u2208 [2, k\u2212 1] and \u03c0j 6= \u2205, then (cj,1, cj,2) 6= null. Then, constraint 1(b) ensure that if j = 1 or\nICALP 2023\n\u03c0j 6= \u2205, there exist two points zj \u2208 wjwj+1 \u2229 (cj,1 \u2295B11\u03b5\u03b4) and z\u2032j \u2208 wjwj+1 \u2229 (cj,2 \u2295B11\u03b5\u03b4) such that zj \u2264wjwj+1 z\u2032j . As x\u2032\u2032j and y\u2032\u2032j are vertices of cj,1 and cj,2, respectively, we have d(zj , x\u2032\u2032j ) \u2264 12\u03b5\u03b4 and d(z\u2032j , y\u2032\u2032j ) \u2264 12\u03b5\u03b4. Therefore, a linear interpolation between x\u2032\u2032j y\u2032\u2032j and zjz \u2032 j sends pi,aj , . . . , pi,bj to points qi,aj , . . . , qi,bj \u2208 zjz\u2032j within a distance of 12\u03b5\u03b4. In all, for l \u2208 [aj , bj ], we can match vi,l to qi,l and d(vi,l, qi,l) \u2264 d(vi,l, pi,l) + d(pi,l, qi,l) \u2264 (1 + 24\u03b5)\u03b4. This takes care of the matching of the vertices of \u03c4i to points on \u03c3.\nNext, we match the vertices of \u03c3 to points on \u03c4i as follows. The vertices w1 and wk have been matched with vi,1 and vi,m, respectively. Take a vertex wj for any j \u2208 [2, k \u2212 1]. There is a unique (r, s) \u2208 J such that r < j \u2264 s. If r = 1 and \u03c01 = \u2205, let b1 = 1; otherwise, let br = max{b : vi,b \u2208 \u03c0r}. By Lemma 3(iv), there exist two points yr \u2208 \u03c4i,br \u2229 A[r] and ys \u2208 \u03c4i,br \u2229 B[s] such that yr \u2264\u03c4i,br ys. By constraint 3(c), there is a matching of wr+1, ..., ws to points zr+1, ..., zs in a segment xrxs between vertices of A[r] and B[s] such that zr+1 \u2264xrxs zr+2 \u2264xrxs . . . \u2264xrxs zs, and d(zl, wl) \u2264 (1+\u03b5)\u03b4 for all l \u2208 [r+1, s]. A linear interpolation between xrxs and yrys sends zr+1, ..., zs to points in \u03c4i,br within a distance \u03b5\u03b4. Combining this linear interpolation with the matching from wr+1, ..., ws to zr+1, ..., zs gives a matching from wr+1, ..., ws to points in order on \u03c4i,br within a distance (1 + 2\u03b5)\u03b4. This takes care of the matching of the vertices of \u03c3 to points on \u03c4i.\nSo far, we have obtained pairs of vertices and their matching partners on \u03c4i and \u03c3. In \u03c3, the vertices of \u03c3 and the matching partners of the vertices of \u03c4i divide \u03c3 into a sequence of line segments. Similarly, the vertices of \u03c4i and the matching partners of the vertices of \u03c3 divide \u03c4i into a sequence of line segments. We complete the matching by linear interpolations between every pair of corresponding segments on \u03c4i and \u03c3. The resulting distance is dominated by the distance bound (1 + 24\u03b5)\u03b4 of the matching of the vertices of \u03c4i to points in \u03c3.\nE Proof of Lemma 10\nLet \u03c30 be the polygonal curve produced for \u03c3. If the search in D returns (\u03c30, i), the construction of D guarantees that dF (\u03c30, \u03c4i) \u2264 (1 + 12\u03b5)\u03b4. Therefore, dF (\u03c3, \u03c4i) \u2264 dF (\u03c3, \u03c30) + dF (\u03c30, \u03c4i) \u2264 (3 + 24\u03b5)\u03b4. It remains to prove that if min\u03c4i\u2208T dF (\u03c3, \u03c4i) \u2264 \u03b4, then dF (\u03c3, \u03c30) \u2264 (2 + 12\u03b5)\u03b4 and the search in D with \u03c30 will succeed.\nLet \u03c4i be the curve in T such that dF (\u03c3, \u03c4i) \u2264 \u03b4. LetM be a Fr\u00e9chet matching between \u03c3 and \u03c4i. Let ((cjr,1, cjr,2))r\u2208[k0] be the non-null cell pairs in the construction of \u03c30 from \u03c3. By construction, for j \u2208 [jr + 1, jr+1 \u2212 1], (cj,1, cj,2) = null, so wjwj+1 does not intersect any cell in G1, which implies that wjwj+1 is at distance more than \u03b4 from any input vertex. Therefore, \u03c3[wjr+1, wjr+1 ] must be matched byM to an edge of \u03c4i, say \u03c4i,a.\nBy the definition of the (11\u03b5\u03b4)-segment query, when we walk from wjr+1 to wjr , we must hit cjr,2 \u2295B11\u03b5\u03b4 at a point, say xr. Similarly, when we walk from wjr+1 to wjr+1+1, we must hit cjr+1,1 \u2295B11\u03b5\u03b4 at a point, say yr+1.\nWe claim that vi,a is matched byM with a point in \u03c3 that lies does not lie behind xr. If not, when we walk from wjr+1 to wjr , we must hit a cell in G(vi,a \u2295B\u03b4) before reaching xr, but this contradicts the definition of cjr,2 being the output of the (11\u03b5\u03b4)-segment query with wjr+1wjr . Similarly, vi,a+1 is matched byM with a point in \u03c3 that does not lie in front of yr+1. Figure 4 shows an illustration.\nHence, M matches the subcurve \u03c3[xr, yr+1] to a segment prqr+1 \u2286 \u03c4i,a. So d(pr, xr) and d(qr+1, yr+1) are at most \u03b4, which implies that dF (prqr+1, xryr+1) \u2264 \u03b4. Therefore, we can combine M with a Fr\u00e9chet matching between prqr+1 and xryr+1 to show that dF (\u03c3[xr, yr+1], xryr+1) \u2264 2\u03b4. Extending the matching from xr to the center z\u2032r of cjr,2 and from yr+1 to the center zr+1 of cjr+1,1 gives dF (\u03c3[xr, yr+1], z\u2032jrzr+1) \u2264 (2 + 12\u03b5)\u03b4. Clearly,\nfrom left to right.\ndF (yrxr, zrz\u2032r) \u2264 12\u03b5\u03b4 because d(yr, zr) and d(xr, z\u2032r) are at most 12\u03b5\u03b4. As a result, we can combine the Fr\u00e9chet matchings between yrxr and zrz\u2032r for r \u2208 [k0] and between \u03c3[xr, yr+1] and z\u2032rzr+1 for r \u2208 [k0\u2212 1] to conclude that dF (\u03c3, \u03c30) \u2264 (2 + 12\u03b5)\u03b4. So \u03c30 will pass the check of the query procedure.\nWe have proved previously that dF (prqr+1, xryr+1) \u2264 \u03b4. Take a Fr\u00e9chet matching between prqr+1 and xryr+1. We extend it from xr to z\u2032r and from yr+1 to zr+1 to obtain dF (prqr+1, z\u2032rzr+1) \u2264 (1+12\u03b5)\u03b4. Recall thatM matches the subcurve \u03c3[xr, yr+1] to prqr+1 \u2286 \u03c4i,a. It follows thatM matches \u03c3[yr, xr] = yrxr to \u03c4i[qr, pr], so dF (yrxr, \u03c4i[qr, pr]) \u2264 \u03b4. As a result, dF (zrz\u2032r, \u03c4i[qr, pr]) \u2264 dF (yrxr, \u03c4i[qr, pr]) + max{d(yr, zr), d(xr, z\u2032r)} \u2264 (1 + 12\u03b5)\u03b4. We conclude that dF (\u03c30, \u03c4i) \u2264 (1 + 12\u03b5)\u03b4. Hence, our preprocessing must have stored an input curve at Fr\u00e9chet distance at most (1 + 12\u03b5)\u03b4 with \u03c30, which will be reported.\nF Proof of Lemma 13\nConsider (i). The existence of y \u2208 \u03b3 such that c \u2229 xy 6= \u2205 implies that x \u2208 F (c, \u03b3). Then, as x \u2208 L\u03be, we get x \u2208 (aff(\u03be) \u2295 B2\u03b5\u03b4) \u2229 F (c, \u03b3). Also, \u03be contains the projection of x because x \u2208 L\u03be. Therefore, as \u03be is a canonical segment, the projection of (aff(\u03be)\u2295B2\u03b5\u03b4) \u2229 F (c, \u03b3) in aff(\u03be) must contain \u03be. It follows that c \u2208 C\u03b3,\u03be by definition.\nConsider (ii). Let x be any point in L\u03be. Let y be any point in \u03b3. By the definition of \u03be, there exists a point x\u2032 \u2208 L\u03be \u2229 F (c, \u03b3) such that d(x, x\u2032) \u2264 4\u03b5\u03b4. As x\u2032 \u2208 F (c, \u03b3), there exists y\u2032 \u2208 \u03b3 such that x\u2032y\u2032 \u2229 c 6= \u2205. We have d(y, y\u2032) \u2264 \u03b5\u03b4 as both belong to \u03b3, so a linear interpolation sends every point in x\u2032y\u2032 to a point in x\u2032y within a distance \u03b5\u03b4. Therefore, x\u2032y \u2229 (c\u2295B\u03b5\u03b4) 6= \u2205. Similarly, as d(x, x\u2032) \u2264 4\u03b5\u03b4, we get xy \u2229 (c\u2295B5\u03b5\u03b4) 6= \u2205. This proves (ii).\nAssume to the contrary that (iii) is false for \u03bb = 11\u03b5\u03b4. So there exists x \u2208 \u03be and y \u2208 \u03b3 such that when we walk from x to y, we hit a cell c \u2208 C\u03b3,\u03be strictly before reaching c\u03b3,\u03be\u2295B11\u03b5\u03b4. It follows that if we shrink c\u03b3,\u03be \u2295B11\u03b5\u03b4 by a distance \u03b5\u03b4, it becomes disjoint from c. Also, c\u03b3,\u03be \u2295B10\u03b5\u03b4 intersects xy by (ii). That is, c and c\u03b3,\u03be \u2295B10\u03b5\u03b4 are disjoint, and c \u2229 xy strictly precedes xy \u2229 (c\u03b3,\u03be \u2295 B10\u03b5\u03b4) with respect to \u2264xy. The disjointness of c and c\u03b3,\u03be \u2295 B10\u03b5\u03b4 implies that c\u2295B5\u03b5\u03b4 and c\u03b3,\u03be \u2295B5\u03b5\u03b4 are disjoint. Both c\u2295B5\u03b5\u03b4 and c\u03b3,\u03be \u2295B5\u03b5\u03b4 intersect xy by (i). As a result, xy \u2229 (c\u2295B5\u03b5\u03b4) strictly precedes xy \u2229 (c\u03b3,\u03be \u2295B5\u03b5\u03b4) with respect to \u2264xy.\nMove the destination of the walk linearly from y to p\u03b3 . By (ii), the intersections with c\u2295B5\u03b5\u03b4 and c\u03b3,\u03be \u2295B5\u03b5\u03b4 remain non-empty throughout the move. Therefore, the intersection order of c\u2295B5\u03b5\u03b4 and c\u03b3,\u03be \u2295B5\u03b5\u03b4 cannot change throughout the move. Similarly, we move the start of the walk linearly from x to p\u03be, and we can conclude that the intersection order of c\u2295B5\u03b5\u03b4 and c\u03b3,\u03be \u2295B5\u03b5\u03b4 does not change throughout the move. But then we should have preferred c to be c\u03b3,\u03be, a contradiction.\nOnce we have established that (iii) holds for \u03bb = 11\u03b5\u03b4, it also holds for larger values of \u03bb\nICALP 2023\nbecause c\u03b3,\u03be \u2295B\u03bb can only become bigger.\nG Proof of Lemma 8\nConsider the query procedure in Section 4.2. Step 2 works correctly according to the output requirements of the (11\u03b5\u03b4)-segment query\nand the (\u03ba, \u03b4)-ANN query. It remains to show that step 3 returns the correct answer. We first show two technical results. The first one bounds the distance between \u03b3 in step 3 and the input vertices.\nI Lemma 15. The cell \u03b3 in step 3 intersects aff(wjwj+1) and is within a distance (1 + 6\u03b5)\u03b4 from some input vertex. Hence, \u03b3 \u2208 G3.\nProof. Suppose that \u03b3 is the cell in G3 computed in step 3 when we come from step 2. The grid vertex x returned by Danp in step 1 is within a distance (1 + \u03b5)\u03b5\u03b4 from aff(wjwj+1). So some cell in G(x\u2295B2\u03b5\u03b4) must intersect aff(wjwj+1). When we come to step 3 from step 2, we must obtain the cell \u03b3 \u2208 G(x\u2295B2\u03b5\u03b4) that intersects aff(wjwj+1). As x is a grid vertex of G1, the distance between \u03b3 and some input vertex is at most (1 + 3\u03b5)\u03b4.\nThe other possibility is that \u03b3 is \u03b3\u0302 obtained in step 3(c) before we jump to step 3(a) or 3(b). To avoid confusion, we use \u03b3 to denote the cell in G3 computed when we come to step 3 from step 2. By definition, c\u03b3,\u03be belongs to G1 which means that c\u03b3,\u03be is within a distance \u03b4 from some input vertex vi,a. As \u03b3\u0302 \u2208 G(c\u03b3,\u03be \u2295B5\u03b5\u03b4), we have d(vi,a, \u03b3\u0302) \u2264 (1 + 6\u03b5)\u03b4. Hence, \u03b3\u0302 \u2208 G(vi,a \u2295B(1+6\u03b5)\u03b4) \u2282 G3. J\nThe second result says that F (\u03b3, c) and F (c, \u03b3) are disjoint if \u03b3 and c are.\nI Lemma 16. If \u03b3 \u2229 c = \u2205, then F (\u03b3, c) \u2229 F (c, \u03b3) = \u2205.\nProof. Assume to the contrary that F (\u03b3, c)\u2229F (c, \u03b3) 6= \u2205. Take a point x \u2208 F (\u03b3, c)\u2229F (c, \u03b3). By the definition of F (c, \u03b3), we can find a point y \u2208 \u03b3 such that xy \u2229 c 6= \u2205. Analogously, by the definition of F (\u03b3, c), we can find another point z \u2208 c such that xz \u2229 \u03b3 6= \u2205. Take two points y\u2032 \u2208 xy \u2229 c and z\u2032 \u2208 xz \u2229 \u03b3. Observe that x, y, z, y\u2032, z\u2032 lie in the same plane spanned by xy and xz. So yz\u2032 \u2229 y\u2032z 6= \u2205. Since c is convex and y\u2032, z \u2208 c, we have y\u2032z \u2282 c. Analogously, we have yz\u2032 \u2282 \u03b3. But then yz\u2032 \u2229 y\u2032z \u2286 c\u2229\u03b3, contradicting the assumption that c\u2229\u03b3 = \u2205. J\nNow, we are ready to show that the query procedure either discovers that min\u03c4i\u2208T d(\u03c3, \u03c4i) > \u03b4, or returns a correct answer for the (11\u03b5\u03b4)-segment query.\nProof of Lemma 8. We first argue that if the query procedure returns a cell, it satisfies the requirement of a correct answer for the (11\u03b5\u03b4)-segment query. A cell cans is returned either in step 3(a) or 3(b). If cans is returned in step 3(a), then cans \u2295B7\u03b5\u03b4 contains wj by construction, so cans must be a correct answer. If cans is returned in step 3(b), it is equal to c\u03b3,\u03be. By the precondition of step 3, wj projects to \u03be and d(wj , \u03be) \u2264 2\u03b5\u03b4. Therefore, by Lemma 13, c\u03b3,\u03be is the correct answer for the (11\u03b5\u03b4)-segment query.\nIt remains to show that if there is a cell in G1 that intersects wjwj+1, the query procedure either discovers that min\u03c4i\u2208T dF (\u03c3, \u03c4i) > \u03b4 or returns a cell. Since G1 contains a cell that intersects wjwj+1 by assumption, aff(wjwj+1) is within a distance \u03b5\u03b4 from some grid vertices of G1, so Danp must return a grid vertex x at distance (1 + \u03b5)\u03b5\u03b4 or less from aff(wjwj+1). As a result, step 2 cannot return null. If step 2 returns \u201cno\u201d as the answer to the (\u03ba, \u03b4)-ANN query, it must be the case that min\u03c4i\u2208T dF (\u03c3, \u03c4i) > \u03b4. The remaining possibility is that the query procedure proceeds to step 3.\nSuppose that step 3(a) is applicable. In this case, wj \u2208 \u03b3, and by Lemma 15, \u03b3 is within a distance (1 + 6\u03b5)\u03b4 from some input vertex vi,a. Therefore, wj is at distance 7\u03b5\u03b4 or less from some cell in G(vi,a \u2295 B\u03b4) \u2282 G1. Hence, step 3(a) will succeed in returning one in G(wj \u2295B7\u03b5\u03b4).\nIf step 3(b) is applicable, then c\u03b3,\u03be will be returned. Suppose that step 3(c) is applicable. Let \u03be be the canonical segment in `j+1 that contains the projection of wj+1 in `j+1 By Lemma 13(ii), c\u03b3,\u03be \u2295 B5\u03b5\u03b4 intersects wj+1wj . Since c\u03b3,\u03be belongs to G1, it is within a distance \u03b4 from some input vertex vi,a, which implies that c\u03b3,\u03be\u2295B5\u03b5\u03b4 is covered by the cells in G(vi,a\u2295B(1+6\u03b5)\u03b4) \u2282 G3. Therefore, step 3(c) will succeed in finding a cell \u03b3\u0302 \u2208 G3 that intersects wjwj+1. So either step 3(a) or 3(b) is applicable for \u03b3\u0302, and the query procedure will return a cell. J\nICALP 2023"
        }
    ],
    "title": "Approximate Nearest Neighbor for Polygonal Curves under Fre\u0301chet Distance",
    "year": 2023
}