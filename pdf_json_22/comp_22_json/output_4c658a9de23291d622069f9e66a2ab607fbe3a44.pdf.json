{
    "abstractText": "The complexity class NP of decision problems that can be solved nondeterministically in polynomial time is of great theoretical and practical importance where the notion of polynomial-time reductions between NP-problems is a key concept for the study of NP. As many typical NP-problems are naturally described as graph problems, they and their reductions are obvious candidates to be investigated by graph-transformational means. In this paper, we propose such a graph-transformational approach for proving the correctness of reductions between NP-problems.",
    "authors": [
        {
            "affiliations": [],
            "name": "A. Windhorst"
        },
        {
            "affiliations": [],
            "name": "Hans-J\u00f6rg Kreowski"
        },
        {
            "affiliations": [],
            "name": "Sabine Kuske"
        },
        {
            "affiliations": [],
            "name": "Aaron Lye"
        },
        {
            "affiliations": [],
            "name": "Aljoscha Windhorst"
        }
    ],
    "id": "SP:17bc06251c5cb2e6e2d1b0ea2eb1b3aaa0e3d5a4",
    "references": [
        {
            "authors": [
                "Andrea Corradini",
                "Hartmut Ehrig",
                "Reiko Heckel",
                "Michael L\u00f6we",
                "Ugo Montanari",
                "Francesca Rossi"
            ],
            "title": "Algebraic Approaches to Graph Transformation Part I: Basic Concepts and Double Pushout Approach",
            "venue": "In Grzegorz Rozenberg, editor: Handbook of Graph Grammars and Computing by Graph Transformation,",
            "year": 1997
        },
        {
            "authors": [
                "Hartmut Ehrig",
                "Hans-J\u00f6rg Kreowski"
            ],
            "title": "Parallelism of Manipulations in Multidimensional Information Structures",
            "venue": "Proc. Mathematical Foundations of Computer Science, Lecture Notes in Computer Science",
            "year": 1976
        },
        {
            "authors": [
                "Hartmut Ehrig",
                "Michael Pfender",
                "Hans-J\u00fcrgen Schneider"
            ],
            "title": "Graph Grammars: An Algebraic Approach",
            "venue": "IEEE Conf. on Automata and Switching Theory, Iowa City,",
            "year": 1973
        },
        {
            "authors": [
                "Michael R. Garey",
                "David S. Johnson"
            ],
            "title": "Computers and Intractability \u2013 A Guide to the Theory of NP-Completeness. W.A",
            "year": 1979
        },
        {
            "authors": [
                "Annegret Habel",
                "Reiko Heckel",
                "Gabriele Taentzer"
            ],
            "title": "Graph Grammars with Negative Application Conditions",
            "venue": "Fundamenta Informaticae",
            "year": 1996
        },
        {
            "authors": [
                "Richard M. Karp"
            ],
            "title": "Reducibility Among Combinatorial Problems",
            "venue": "editors: Proceedings of a Symposium on the Complexity of Computer Computations,",
            "year": 1972
        },
        {
            "authors": [
                "Hans-J\u00f6rg Kreowski"
            ],
            "title": "Transformations of Derivation Sequences in Graph Grammars",
            "venue": "Proc. Conference on Fundamentals of Computation Theory, Lecture Notes in Computer Science",
            "year": 1977
        },
        {
            "authors": [
                "Hans-J\u00f6rg Kreowski",
                "Sabine Kuske"
            ],
            "title": "Graph Transformation Units with Interleaving Semantics",
            "venue": "Formal Aspects of Computing",
            "year": 1999
        },
        {
            "authors": [
                "Hans-J\u00f6rg Kreowski",
                "Sabine Kuske"
            ],
            "title": "Graph Multiset Transformation \u2013 A New Framework for Massively Parallel Computation Inspired by DNA Computing",
            "venue": "Natural Computing",
            "year": 2011
        },
        {
            "authors": [
                "Hans-J\u00f6rg Kreowski",
                "Sabine Kuske"
            ],
            "title": "Polynomial Graph Transformability",
            "venue": "Theoretical Computer Science",
            "year": 2012
        },
        {
            "authors": [
                "Hans-J\u00f6rg Kreowski",
                "Sabine Kuske",
                "Grzegorz Rozenberg"
            ],
            "title": "Graph Transformation Units \u2013 An Overview",
            "venue": "editors: Concurrency, Graphs and Models, Lecture Notes in Computer Science",
            "year": 2008
        }
    ],
    "sections": [
        {
            "text": "R. Heckel and C.M. Poskitt (Eds.): 13th International Workshop on Graph Computation Models (GCM 2022) EPTCS 374, 2022, pp. 76\u201393, doi:10.4204/EPTCS.374.7\n\u00a9 H.-J. Kreowski, S. Kuske, A. Lye & A. Windhorst"
        },
        {
            "heading": "A Graph-Transformational Approach for Proving the",
            "text": "Correctness of Reductions between NP-Problems\nHans-Jo\u0308rg Kreowski, Sabine Kuske, Aaron Lye, Aljoscha Windhorst\nUniversity of Bremen, Department of Computer Science P.O.Box 33 04 40, 28334 Bremen, Germany\n{kreo,kuske,lye,windhorst}@uni-bremen.de\nThe complexity class NP of decision problems that can be solved nondeterministically in polynomial time is of great theoretical and practical importance where the notion of polynomial-time reductions between NP-problems is a key concept for the study of NP. As many typical NP-problems are naturally described as graph problems, they and their reductions are obvious candidates to be investigated by graph-transformational means. In this paper, we propose such a graph-transformational approach for proving the correctness of reductions between NP-problems."
        },
        {
            "heading": "1 Introduction",
            "text": "The complexity class NP of decision problems that can be solved nondeterministically in polynomial time is of great theoretical and practical importance, with the notion of polynomial-time reductions between NP-problems being a key concept for the study of NP and, in particular, of NP-completeness. Since the early analysis of the class NP it is known that many graph-theoretic problems are NP-complete (cf. e.g. [8, 6]). Examples include finding a clique, a Hamiltonian cycle, a vertex cover, an independent set, a vertex coloring, etc. Moreover, many typical NP-problems are naturally described as graph problems, such as routing and scheduling problems as well as various further optimization and planning problems. Usually the complexity class NP as well as the notion of complexity-theoretic reductions are defined by means of (polynomial-time) Turing machines. However, explicit problems and constructions are described on some higher level with much more abstraction. Polynomial graph transformation units [13, 12] may be helpful not only for specifying and understanding decision problems and reductions, but also for obtaining correctness proofs in a systematic way. In [11], it has been shown that polynomial graph transformation units are a formal computational model for decision problems in NP. In [5], the problems of finding a clique, an independent set, a vertex cover and a Hamiltonian cycle are modeled as graph transformation units, and reductions are characterized by deadlock-free and confluent polynomial graph transformation units. Moreover, a proof principle is proposed for proving the correctness of reductions. It is based on a certain interaction of the unit of an NP problem and the unit of a reduction requiring a family of auxiliary variants of the reduction unit. In this paper, we continue this research by proposing a novel graph-transformation-based framework for proving the correctness of reductions between NPproblems. As correctness requires to construct certain derivations of one kind from certain derivations of another kind the initial graphs of which are connected by a third kind of derivations, we provide a toolbox of operations on derivations that allows such constructions. In particular, we employ operations based on parallel and sequential independence of rule applications.\nThe paper is organized as follows. In Section 2 and 3, we recall the notions of graph transformation and graph transformation units. In Section 4, we present the notion of graph-transformational modeling of NP-problems. In Section 5, we introduce the notion of graph-transformational modeling of reductions. Section 6 discusses the correctness proofs of such reductions. Section 7 concludes the paper."
        },
        {
            "heading": "2 Preliminaries",
            "text": "In this section, we recall the basic notions and notations of graphs and rule-based graph transformation as far as needed in this paper.\nGraphs Let \u03a3 be a set of labels with \u2217 \u2208 \u03a3. A (directed edge-labeled) graph over \u03a3 is a system G = (V,E,s, t, l) where V is a finite set of vertices, E is a finite set of edges, s, t : E \u2192 V and l : E \u2192 \u03a3 are mappings assigning a source, a target and a label to every edge e \u2208 E . An edge e with s(e) = t(e) is called a loop. An edge with label \u2217 is called an unlabeled edge. In drawings, the label \u2217 is omitted. Undirected edges are pairs of edges between the same vertices in opposite directions. The components V , E , s, t, and l of G are also denoted by VG, EG, sG, tG, and lG, respectively. The empty graph is denoted by /0. The class of all directed edge-labeled graphs is denoted by G\u03a3.\nFor graphs G,H \u2208 G\u03a3, a graph morphism g : G \u2192 H is a pair of mappings gV : VG \u2192 VH and gE : EG \u2192 EH that are structure-preserving, i.e., gV (sG(e)) = sH(gE(e)), gV (tG(e)) = tH(gE(e)), and lG(e) = lH(gE(e)) for all e \u2208 EG. If the mappings gV and gE are bijective, then G and H are isomorphic, denoted by G \u223c= H . If they are inclusions, then G is called a subgraph of H, denoted by G \u2286 H . For a graph morphism g : G \u2192 H , the image of G in H is called a match of G in H , i.e., the match of G with respect to the morphism g is the subgraph g(G)\u2286 H .\nRules and rule application A rule r = (L \u2287 K \u2286 R) consists of three graphs L,K,R \u2208 G\u03a3 such that K is a subgraph of L and R. The components L, K, and R are called left-hand side, gluing graph, and right-hand side, respectively.\nThe application of r to a graph G consists of the following three steps. (1) Choose a match g(L) of L in G. (2) Remove the vertices of gV (VL) \\gV (VK) and the edges of gE(EL) \\gE (EK) yielding Z, i.e., Z = G\u2212 (g(L)\u2212 g(K)). (3) Add R to Z by gluing Z with R in g(K) (up to isomorphism) yielding H . The construction is subject to the dangling condition ensuring that Z becomes a subgraph of G so that H becomes a graph automatically. Moreover, we require the identification condition, i.e., if different items of L are mapped to the same item in g(L), then they are items of K. Sometimes any identification may be forbidden. Then we add the postfix (inj) to the rule. The construction produces a right match h(R) that extends g(K) by the identity on R\u2212K (up to isomorphism).\nThe application of r to G w.r.t. g is called direct derivation and is denoted by G=\u21d2 r H (where g is\nkept implicit). A derivation from G to H is a sequence of direct derivations G0=\u21d2 r1 G1=\u21d2 r2 \u00b7 \u00b7 \u00b7=\u21d2 rn Gn with G0 = G, Gn \u223c= H and n \u2265 0. r1 \u00b7 \u00b7 \u00b7rn is called application sequence. If r1, \u00b7 \u00b7 \u00b7 ,rn \u2208 P, then the derivation is also denoted by G n =\u21d2\nP H . If the length of the derivation does not matter, we write G\n\u2217 =\u21d2\nP H .\nA rule r = (L \u2287 K \u2286 R) may be equipped with a negative application condition (NAC) N with L \u2286 N. It prevents the application of r to a graph G if the match g(L) can be extended to a match g(N).\nLet |S| denote the cardinality of a finite set S and size(G) = |VG|+ |EG| the size of a graph G. It is worth noting that the application of a given (fixed) rule to G can be performed in polynomial time provided that the equality of labels can be checked in polynomial time. This is due to the fact that the number of graph morphisms from L to G is bounded by size(G)size(L) so that a match can be found in polynomial time. The further steps of the rule application can be done in linear time.\nIt may be noted that the chosen notion of rule application fits into the DPO framework as introduced\nin [3] (see, e.g., [1] for a comprehensive survey). For details on NACs, we refer to [7].\nExtension and independence Let d =(G \u2217\n=\u21d2H) be a derivation and G\u0302 be a graph with G\u2286 G\u0302 obtained by adding some vertices and some edges with new or old vertices as sources and targets. Then d can be extended to d\u0302 = (G\u0302 \u2217\n=\u21d2H\u0302) if none of the direct derivations of d removes a source or a target of a new edge. To construct d\u0302, one adds the new vertices and edges to each graph of d. As the chosen sources and targets of new edges are never removed within d, they can be used throughout d\u0302. By construction, each graph of d is subgraph of the corresponding extended graph so that the matches are kept intact and the rules can be applied as in d. The extension works also in case of negative context conditions if the new vertices and edges do not contradict them.\nLet ri = (Li \u2287 Ki \u2286 Ri) for i = 1,2 be rules. Two direct derivations G=\u21d2 ri Hi with matches gi(Li) are\nparallel independent if g1(L1)\u2229g2(L2)\u2286 g1(K1)\u2229g2(K2). Successive direct derivations G=\u21d2 r1 H1=\u21d2 r2 X with the right match h1(R1) and the (left) match g \u2032 2(L2) are sequentially independent if h1(R1)\u2229g \u2032 2(L2)\u2286 h1(K1)\u2229g \u2032 2(K2). It is well-known that parallel independence induces the direct derivations H1=\u21d2r2 X and H2=\u21d2 r1 X with matches g\u20322(L2) \u223c= g2(L2) and g \u2032 1(L1) \u223c= g1(L1) respectively and that sequential independence induces the derivation G=\u21d2 r2 H2=\u21d2 r1 X with matches g2(L2) \u223c= g \u2032 2(L2) and g \u2032 1(L1) \u223c= g1(L1) (cf., e.g., [1, 2, 4]).\nThe last two constructions can be extended to derivations by simple inductions. Sets of rules P1 and P2 are called independent if each two applications of a rule of P1 and a rule of P2 applied to the same graph are parallel independent and, applied one after the other, sequentially independent. In the special case of P = P1 = P2, we say that P is independent. Then the following hold: (1) G n\n=\u21d2 P1\nH1 and G m\n=\u21d2 P2 H2\ninduce H1 m\n=\u21d2 P2\nX and H2 n\n=\u21d2 P1\nX for some X , and (2) G n\n=\u21d2 P1\nH1 m\n=\u21d2 P2\nX induces G m\n=\u21d2 P2\nH2 n\n=\u21d2 P1 X for some H2.\nThe derivations are obtained by repeating the respective constructions for direct derivations of the given derivations as long as possible. One way to look at the situation is that the P2-derivation is moved either forward or backward along the P1-derivation. Therefore, we refer to the resulting P2-derivation as moved variant of the given P2-derivation."
        },
        {
            "heading": "3 Graph Transformation Units",
            "text": "In this section, the basic notions and notations of graph transformation units (see, e.g., [13, 10]) are recalled using graphs, rules and rule application as introduced in the previous section. Besides a set of rules, a graph transformation unit provides two graph class expressions to specify initial and terminal graphs and a control condition to regulate the derivation process.\nWe restrict the consideration to graph class expressions e that specify graph classes SEM(e) \u2286 G\u03a3 such that membership can be decided in polynomial time. In examples, we use (1) forbidden(F ) for some finite F \u2286 G\u03a3 with SEM(forbidden(F )) = {G | there is no match f : F \u2192 G for any F \u2208 F} and (2) some constant terms like undirected, unlabeled, simple, and loop-free referring to the class of undirected graphs, unlabeled graphs, simple graphs, i.e., graphs without parallel edges, and loop-free graphs respectively. The term standard specifies the intersection of these four graph classes. Moreover, we use the term bound(N) that specifies the set of all graphs with a single vertex, a single bound-loop and an arbitrary number of unlabeled loops. Another useful graph class expression is reduced(P) for some finite set of rules P that specifies the class of graphs to which none of the rules of P can be applied. Finally, we use the binary operator + for graph class expressions specifying the disjoint union of the graphs of the corresponding graph classes. The membership problems of all explicitly used graph class expressions can be checked in polynomial time. forbidden and reduced are variants of the matching\nproblem. The properties of the standard expressions follow from an inspection of the edges which applies also to bound(N). The disjoint union symbol is only used in standard + bound(N). Given a graph, one can identify the component bound(k) for some k by inspecting all edges. The rest of the graph must be checked with respect to standard.\nAs control conditions, we use extended regular expressions over sets of rules. Let C be a regular\nexpression over some set of rules P and d = (G \u2217\n=\u21d2 P H). Then d satisfies C if the application sequence of\nd is in L(C) where L(C) is the regular language specified by C. This is denoted by G \u2217\n=\u21d2 P,C H . Employing\na finite automaton corresponding to the regular expression, one can control such derivations stepwise, meaning that the allowed and applicable rules can be determined. In this way, satisfaction can be checked in polynomial time for derivations of polynomial lengths. In an extended regular expression, the Kleene star \u2217 behind a rule may be replaced by !, where r! requires that r be applied as long as possible (in contrast to r\u2217 that allows to apply r arbitrarily often). As the stepwise control provides all currently applicable rules, the applicability of r is included so that the control of r! does not require any extra time. In examples, the rules of graph transformation units are listed such that their position in the list (1,2,3, . . .) can be used to refer to them in control conditions.\nA graph transformation unit is a system gtu = (I,P,C,T ) where I is an initial graph class expression, P is a finite set of rules, C is an extended regular expression over P and T is a terminal graph class expression. The components I, P, C and T of gtu are also denoted by Igtu, Pgtu, Cgtu and Tgtu, respectively. The semantics of gtu is the binary relation SEM(gtu)= (SEM(I)\u00d7SEM(T ))\u2229 \u2217\n=\u21d2 P,C\n. A derivation G \u2217\n=\u21d2 P,C H\nwith G \u2208 SEM(I) and H \u2208 SEM(T ) is called successful, denoted by G \u2217\n=\u21d2 gtu H . As long as a derivation\nG \u2217\n=\u21d2 P H with G \u2208 SEM(I) follows the stepwise control of C, it is called permitted and denoted by\nG \u2217\n=\u21d2 P,C? H .\nIn examples, a graph transformation unit is presented schematically where the components I, P, C,\nand T are listed after respective keywords initial, rules, cond, and terminal.\nA graph transformation unit is polynomial if there is a polynomial p such that n \u2264 p(size(G)) for each permitted derivation G\nn =\u21d2 P,C? H . A polynomial graph transformation unit gtu is functional if, for ev-\nery initial graph G, the following holds: (1) There is a successful derivation G \u2217\n=\u21d2H for some graph H . (2) Every permitted derivation G \u2217 =\u21d2H can be prolonged into a successful derivation G \u2217 =\u21d2H \u2217 =\u21d2H . (3) If G \u2217 =\u21d2H and G \u2217\n=\u21d2H \u2032 are successful derivations, then H \u223c= H \u2032. In this case, the resulting graph is denoted by gtu(G). The first property guarantees that every initial graph gets a result. The second property may be seen as a kind of deadlock freeness. And the third property is equivalent to the confluence of permitted derivations whereas arbitrary derivations may not be confluent. The three properties of functional units allow for every initial graph G to derive the resulting graph gtu(G) in polynomial time by starting with the 0-derivation of G and adding derivation steps that keep the permission as long as possible.\nNote that we restrict ourselves to graph class expressions with polynomial membership problems for specifying initial and terminal graphs and to extended regular expressions as control conditions that can be checked stepwise in polynomial time. Therefore, our definition of polynomial graph transformation units is a special case of the one given in [5] where a more general kind of control conditions is allowed."
        },
        {
            "heading": "4 Graph-Transformational Modeling of NP-Problems",
            "text": "Based on its input-output semantics, a graph transformation unit can also be interpreted as a model of a decision problem. This problem belongs to the class NP if the length of each derivation of the unit is polynomially bounded and the proper nondeterminism is provided by the general functioning of units. This means that the usual technique to prove polynomial termination can be applied to show that the decision problem of a unit is in NP.\nDefinition 1. Let gtu = (I,P,C,T ) be a graph transformation unit. Then the decision problem of gtu, denoted by DEC(gtu) : SEM(I)\u2192 BOOL, yields TRUE for G \u2208 SEM(I) if (G,H) \u2208 SEM(gtu) for some H \u2208 SEM(T ) and FALSE otherwise.\nObservation 1. Let gtu be a graph transformation unit. Then DEC(gtu) \u2208 NP if gtu is polynomial.\nProof. By definition, the membership problems of the classes of initial and terminal graphs, and the stepwise control of rule application are polynomial and the lengths of permitted derivations are polynomially bounded. Moreover, the rule application needs polynomial time and its nondeterminism is polynomially bounded so that DEC(gtu) \u2208 NP.\nExample 1. The Hamiltonian path problem asks whether a graph contains a simple path that visits all vertices. The problem is modeled by the unit in Figure 1a. The length of each of its derivations is obviously bounded by twice the number of vertices of the initial graph such that DEC(hampath) \u2208 NP. A successful derivation for a concrete instance is depicted in Figure 1c.\nExample 2. The k-bounded spanning tree problem asks whether, for a given bound k \u2208 N, a graph contains a spanning tree with a vertex degree not greater than k. The problem is modeled by the unit in Figure 1b. The length of each of its derivations is obviously bounded by twice the number of vertices of the initial graph such that DEC(k-bounded-spantree) \u2208 NP. A successful derivation for a concrete instance for the case k = 2 is depicted in Figure 1d. We use lists of labels for loops as a abreviation to clarify the drawings. E.g., a loop with labels \u2217,\u2217, t represents two unlabeled loops and one t-labeled loop.\nAn often easy way to show the polynomiality of a unit gtu and as a consequence that DEC(gtu) \u2208 NP is by finding a natural number variable the value of which is polynomially bounded and decreases whenever a rule of gtu is applied. This is a well-known fact.\nFact 1 (Polynomial Termination). Let gtu = (I,P,C,T ) be a graph transformation unit, f : G\u03a3 \u2192 N be a function and p a polynomial such that f (x) \u2264 (p\u25e6 size)(x) for each x \u2208 G\u03a3 and f (G) > f (H) for each\ndirect derivation G=\u21d2 P\nH . Then the length k of every successful derivation G k\n=\u21d2 P H is polynomially\nbounded in the size of the input graph G such that DEC(gtu) \u2208 NP.\nExample 3. The polynomial termination of hampath may be shown using Fact 1 by separating the unit into two units. The first one with rule 1 as its only rule terminates in a linear number of steps as the number of vertices without \u03b1-loop decreases if a rule is applied. The second unit with rules 2 and 3 terminates in a linear number of steps as the number of vertices with \u03b1-loops decreases if a rule is applied. The polynomial termination of k-bounded-spantree can be shown analogously.\nExample 4. The independent set problem asks whether a graph contains a set of k vertices, no two of which are connected by an edge. The problem is modeled by the unit in Figure 2a. As the number of loops decreases whenever the rule is applied, one gets DEC(independent-set) \u2208 NP. A successful derivation for a concrete instance is depicted in Figure 2c.\nhampath\ninitial: standard\nrules:\n\u03b1\n\u2287 NAC\n\u2287 \u2286 \u03b1\n\u03b1 \u2287 \u2286 run\n1\nrun\n2\n\u03b1\n\u2287 1 2 \u2286 1 2\nrunp\ncond: 1!; 2; 3\u2217\nterminal: forbidden( \u03b1 )\n(a) Graph transformation unit hampath\nk-bounded-spantree\ninitial: standard\nrules:\n\u03b2\n\u2287 NAC\n\u2287 \u2286 \u03b2\n. . . k loops\n\u03b2 \u2287 \u2286 t\nt \u03b2 \u2287 t\n\u2286 t t t\ncond: 1!; 2; 3\u2217\nterminal: forbidden( \u03b2 )\n(b) Graph transformation unit k-bounded-spantree\nExample 5. The clique problem asks whether a graph contains a set of k vertices every two of which are connected by an edge, constituting a complete subgraph. The problem is modeled by the unit in Figure 2b. As the number of unlabeled loops decreases whenever the first rule is applied and the number of \u03b1-loops decreases whenever the second rule is applied, one gets DEC(clique) \u2208 NP. A successful derivation for a concrete instance is depicted in Figure 2d. The application of the second rule as long as possible is omitted because the number of applications is 0 if the derivation is successful."
        },
        {
            "heading": "5 Graph-Transformational Modeling of Reductions",
            "text": "Reductions between NP-problems are a key concept for the study of the class NP. Given two NPproblems DEC and DEC\u2032, a reduction RED is a function from the inputs of DEC to the inputs of DEC\u2032 that can be computed in polynomial time and is subject to the following correctness condition for each input x of DEC: DEC(x) = TRUE if and only if DEC\u2032(RED(x)) = TRUE. If the NP-problems are given by polynomial graph transformation units, then a reduction can be modeled as a functional and polynomial graph transformation unit.\nDefinition 2 (Reduction). Let gtu and gtu\u2032 be polynomial graph transformation units. Let red = (Igtu, Pred,Cred, Igtu\u2032) be a functional and polynomial graph transformation unit. Then red is a reduction of gtu to gtu\u2032 if the following holds for all G \u2208 SEM(Igtu): (G,H) \u2208 SEM(gtu) for some H \u2208 SEM(Tgtu) if and only if (red(G),H \u2032) \u2208 SEM(gtu\u2032) for some H \u2032 \u2208 SEM(Tgtu\u2032).\nObservation 2. Let red be a reduction of gtu to gtu\u2032. Then the function RED= SEM(red) : SEM(Igtu)\u2192 SEM(Igtu\u2032), defined by RED(G)= red(G), is a reduction of DEC(gtu) to DEC(gtu\n\u2032), denoted by DEC(gtu) \u2264 DEC(gtu\u2032).\nProof. As red is functional and polynomial, RED is a function that is computed in polynomial time. Its correctness can be shown as follows: Let G \u2208 SEM(Igtu) with DEC(gtu)(G) = TRUE meaning that there is an H \u2208 SEM(Tgtu) with (G,H) \u2208 SEM(gtu). As red is a reduction of gtu to gtu \u2032, this is equivalent to (red(G),H \u2032) \u2208 SEM(gtu\u2032) for some H \u2032 \u2208 SEM(Tgtu\u2032), i.e., DEC(gtu \u2032)(red(G)) = TRUE. As red(G) = RED(G), RED turns out to be a reduction of DEC(gtu) to DEC(gtu\u2032).\nThe observation means that DEC(gtu) \u2264 DEC(gtu\u2032) can be established by means of a reduction of gtu to gtu\u2032. The polynomiality of such a reduction can be shown by using Fact 1. The functionality can be shown using the following well-known fact.\nFact 2. Let gtu = (I,P,C,T ) be a polynomial graph transformation unit. Then gtu is functional if the following hold:\n1. P is independent,\n2. (G,H) \u2208 SEM(gtu) implies H \u2208 reduced(P), and 3. G \u2217\n=\u21d2 P,C H for G \u2208 SEM(I) and H \u2208 reduced(P) implies (G,H) \u2208 SEM(gtu).\nProof. As gtu is polynomial, the lengths of its permitted derivations are finitely bounded. The required independence implies the confluence of P-derivations. Both together means that for each G \u2208 SEM(I), there is \u2013 up to isomorphism \u2013 exactly one H \u2208 reduced(P) with G \u2217\n=\u21d2 P H . Properties 2 and 3 make sure\nthat this functionality holds for SEM(gtu), too.\nExample 6. According to the considerations in Examples 1 and 2, we have DEC(hampath)(G) = TRUE if and only if G has a Hamiltonian path, and we have DEC(k-bounded-spantree)(G) = TRUE if and only if G has a spanning tree with a vertex degree not greater than k. A Hamiltonian path is connected and cycle-free and visits all vertices such that it is a spanning tree with vertex degree 2. Conversely, a spanning tree with vertex degree 2 or smaller must be a simple path and, as it covers all vertices, therefore, a Hamiltonian path. In other words, the identity on the initial graphs of hampath and 2-bounded-spantree is a reduction of hampath to 2-bounded-spantree, as specified in the unit in Figure 3a.\nAs there are no rules to be applied and as the regular expression \u03b5 specifies the language with the empty string as its sole element allowing derivations of length 0 only, each initial graph derives itself exclusively, which is terminal at the same time because the initial graphs of hampath and 2-bounded-spantree coincide. The unit is obviously polynomial and functional.\nExample 7. The reduction from clique to independent-set is modeled by the unit in Figure 3b. Each initial graph has the form G+ bound(k) for some k \u2208 N. The first rule can be applied to two vertices of G that are not connected by a \u03b3-edge and neither of them has a bound-loop, connecting them by a \u03b3-edge. Hence the rule can be applied |VG| \u00b7 (|VG|\u2212 1)/2 times and must be applied as often due to the control condition. Then, any two vertices of G are connected by \u03b3-edges. The second rule can be applied to an unlabeled edge of G with a parallel \u03b3-edge, removing both. Due to the control condition, this must be done for all such pairs of edges in G. The number of steps is |EG|, and \u03b3-edges remain between all pairs of vertices of G that are not connected in G. By applying the third rule as long as possible, all \u03b3-edges are replaced by (unlabeled) edges such that the resulting graph is isomorphic to the dual one of the initial graph. In particular, the unit turns out to be functional and polynomial. The overall lengths of derivations is |VG| \u00b7 (|VG|\u22121) for G \u2208 SEM(I). The rule i for i = 1,2,3 is independent of itself, so that its application as long as possible is confluent in every case. And as all intermediate graphs of derivations contain \u03b3-edges, the terminal graphs are only reached at the end. Finally, the unit has the correctness property of a reduction. If two vertices in a graph G are connected, then they are not connected in the dual graph and the other way round. Consequently, a clique in G becomes an independent set in the dual graph and the other way round. A derivation for the initial graph of Figure 2d is depicted in Figure 3c.\nThe correctness proof in Example 7 can be found in Karp [8] and in Garey and Johnson [6]. Whenever a graph-transformational reduction and the two involed NP problems modeled by graph transformation units are characterized in graph-theoretic terms, one can try to prove the correctness of the reduction in the traditional graph-theoretic way as in the Examples 6 and 7.\nIn the next section, we investigate an alternative graph-transformational way of proving the correct-\nness of reductions."
        },
        {
            "heading": "6 Proving the Correctness of Reductions",
            "text": "In this section, we investigate possibilities to prove the correctness of reductions by graph-transformational means.\nLet gtu and gtu\u2032 be two polynomial graph transformation units and red = (Igtu,Pred,Cred, Igtu\u2032) be a polynomial and functional graph transformation unit. Then red is a reduction of DEC(gtu) to DEC(gtu\u2032) if the following correctness conditions hold:\nForward If G \u2217\n=\u21d2 gtu\nH is a successful derivation of gtu, then there is a successful derivation red(G) \u2217\n=\u21d2 gtu\u2032\nH \u2032\nfor some H \u2032 \u2208 SEM(Tgtu\u2032).\nBackward If red(G) \u2217\n=\u21d2 gtu\u2032\nH \u2032 is a successful derivation of gtu\u2032, then there is a successful derivation\nG \u2217\n=\u21d2 gtu H for some H \u2208 SEM(Tgtu).\nThe diagram in Figure 4a illustrates the task. Given a gtu- and a red-derivation, one must find an appropriate gtu\u2032-derivation, and conversely given a gtu\u2032-derivation and the same red-derivation, one must find an appropriate gtu-derivation. To achieve this, we propose a kind of toolbox that provides operations on derivation structures where the latter are defined in Definition 3 and the operations on them in Definition 4.\nA derivation structure is a finite directed graph, the vertices of which are graphs and the edges are\ndirect derivations.\nDefinition 3. A derivation structure is a finite unlabeled directed graph DS, such that VDS \u2286 G\u03a3 and every edge e \u2208 EDS is a direct derivation e = (G=\u21d2\nr H) with sDS(e) = G and tDS(e) = H. The class of\nall derivation structures is denoted by DS .\nThe operations add derivations to given derivation structures so that the results are derivation structures. The idea is (1) to start with the derivation structure in Figure 4b and to apply operations until the derivation red(G) \u2217\n=\u21d2 gtu\u2032\nH \u2032 appears as a substructure and (2) to start conversely with the derivation\nstructure in Figure 4c and apply operations until the derivation G \u2217\n=\u21d2 gtu H appears as a substructure.\nWe provide five operations which are defined as binary relations on derivation structures. (1) conflux of two parallel independent rule applications adding two corresponding rule applications (cf. Section 2) to the derivation structure; (2) interchange of two sequential independent rule applications adding one corresponding derivation consisting of the interchanged rule applications (cf. Section 2) to the derivation structure; (3) sprout with a functional graph transformation unit as parameter attaching a successful derivation of the parameter starting in a graph of the given derivation structure; (4) couple with a span of parallel independent rule applications as parameter adding a corresponding extended right part of the span to the derivation structure if an extension of the left part of the span is present; and (5) associate with a pair of particular derivations with the same first graph and the same last graph as parameter adding an extension of the second derivation to the derivation structure if a corresponding extension of the first one is present. All these enlargements of the derivation structures are formally defined by unions of derivation structures. Concerning conflux and interchange, the rule applications corresponding to the given independent ones are unique up to isomorphism. One of the choices is taken. Concerning sprout, there are many derivations G \u2217\n=\u21d2 funct(G) with a result unique up to isomorphism. Again one of them is chosen. Concerning couple and associate, the extensions are unique up to isomorphism provided they exist at all. Then one of the extensions is added. The extensions may not exist because the right component of the span or the pair may remove vertices that are needed for the extensions. In such a case, the respective operation is undefined.\nDefinition 4. 1. conflux: Let DS\u2208DS with two parallel independent direct derivations G=\u21d2 ri Hi for\ni = 1,2 as substructure. Let DS\u2032 be the enlargement of DS by two corresponding direct derivations d1 = (H1=\u21d2\nr2 X) and d2 = (H2=\u21d2 r1 X) provided by the parallel independence, i.e., DS\u2032 = DS\u222ad1\u222a\nd2. Then (DS,DS \u2032) \u2208 conflux.\n2. interchange: Let DS \u2208 DS with two sequential independent direct derivations G=\u21d2 r1 H1=\u21d2 r2 X as\nsubstructure. Let DS\u2032 be the enlargement of DS by the corresponding derivation d =\n(G=\u21d2 r2 H2=\u21d2 r1\nX) provided by the sequential independence, i.e., DS\u2032 = DS\u222a d. Then (DS,DS\u2032) \u2208\ninterchange.\n3. sprout(funct): Let funct be a functional graph transformation unit, DS \u2208 DS and G \u2208 VDS. Let\nDS\u2032 be the enlargement of DS by attaching one of the derivations d = (G \u2217\n=\u21d2 funct(G)) at G, i.e., DS\u2032 = DS\u222ad. Then (DS,DS\u2032) \u2208 sprout(funct).\n4. couple(span): Let span be a pair of parallel independent direct derivations di = (G=\u21d2 ri Hi) for\ni= 1,2, DS\u2208DS , and G\u0302=\u21d2 H\u03021 be a substructure of DS extending d1. Let DS \u2032 be the enlargement of DS by adding one corresponding extension d\u03022 = (G\u0302=\u21d2 r2 H\u03022) of d2, i.e., DS \u2032 = DS\u222a d\u03022, provided it exists. Then (DS,DS\u2032) \u2208 couple(span).\n5. associate(pair): Let pair be a pair of derivations di = (G \u2217 =\u21d2H) for i = 1,2, DS \u2208 DS , d\u03021 =\n(G\u0302 \u2217 =\u21d2H\u0302) be a substructure of DS extending d1. Let DS \u2032 be the enlargement of DS by adding one extension d\u03022 of d2 from G\u0302 to H\u0302, i.e., DS \u2032 = DS\u222a d\u03022, provided it exists. Then (DS,DS\n\u2032) \u2208 associate(pair).\nFigure 5 depicts schematic drawings of the operations. In the following examples, we demonstrate how the operations may be employed to prove the cor-\nrectness of reductions.\nExample 8. Using the operations conflux, interchange and sprout, the correctness of clique-to-independent-set can be shown as follows. Let G !\n=\u21d2 1\nG1 !\n=\u21d2 2 G2 be a successful derivation in\nclique. As G2 is terminal, it has no \u03b2 -edges so that G1 !\n=\u21d2 2 G2 has length 0 and can be omitted. Let\nG !\n=\u21d2 1\nG1 !\n=\u21d2 2\nG2 !\n=\u21d2 3 G3 be a successful derivation of clique-to-independent-set reducing G where the\nnumbers of rules are overlined to distinguish them from the rules 1 and 2 of clique. Each rule application of rule 1 is parallel independent of each rule application of rule i for i = 1,2,3. Therefore, the application of conflux as long as possible to the rule applications of the two given derivations yields - among others - a derivation G3 !\n=\u21d2 1\nG\u20321 being a moved variant of G !\n=\u21d2 1 G1 as defined at the end of Section 2. Figure 6a\ndepicts the derivation structure.\nThe involved rule applications keep the set of vertices invariant. Moreover, the independence of all rule applications makes sure that the sets of vertices with \u03b1-loops in G1 and G \u2032 1 are equal. Let v and v\u2032 be two such vertices which are connected by an edge e in G according to the choice of G !\n=\u21d2 1 G1.\nConsequently, e gets a parallel \u03b3-edge in G1, both are removed between G1 and G2, and v and v \u2032 are not connected in G3. This means that G \u2032 1 is a terminal graph of independent-set. Altogether, the reduction is forward correct. The backwards correctness follows analogously, starting from the derivation reducing G and a successful derivation G3 !\n=\u21d2 1\nG\u20321 in independent-set and applying interchange (instead of conflux)\nto the sequential independent rule applications of rule i for i = 1,2,3, followed by one application of rule 1. This yields a derivation G !\n=\u21d2 1\nG1 as a moved variant of G3 !\n=\u21d2 1\nG\u20321. As each two vertices with\n\u03b1-loops in G\u20321 are not connected, the definition of the reduction implies that they are connected in G1. In particular, rule 2 of clique cannot be applied and the derivation G1 !\n=\u21d2 2 G2 has length 0. Adding it with\nsprout at G1, one gets a successful derivation in clique. This completes the proof.\nFigure 6b depicts the derivation structure in Example 8 using the concrete examples used before.\nExample 9. In proving the correctness of hampath-to-2-bounded-spantree, all five operations are used. Let G !\n=\u21d2 1 G1=\u21d2 2\nG2 \u2217\n=\u21d2 3 G3 be a successful derivation of hampath. This is a start structure as the re-\nduction is the identity and one can begin to construct the corresponding derivation immediately. Its first section is G !\n=\u21d2 1\u2032\nG\u20321 necessarily which can be added with sprout at G using the functional unit with the\nrule 1\u2032 and 1\u2032! as control condition. The rules of 2-bounded-spantree are primed to distinguish them from the rules of hampath. The rule sets {1,2,3} and {1\u2032,2\u2032,3\u2032} are independent. Therefore, conflux applied as long as possible yields the subderivation G !\n=\u21d2 1\u2032\nG\u20321 !\n=\u21d2 1 H1=\u21d2 2\nH2 \u2217\n=\u21d2 3 H3 where the last three\nsections are a moved variant of the given derivation so that H1 contains G and an \u03b1-loop, a \u03b2 -loop and two \u2217-loops at each vertex and H3 contains G3 and a \u03b2 -loop and two \u2217-loops at each vertex. In particu-\nlar, H1=\u21d2 2 H2 is an extension of the left part of the span\nrun \u03b2\n\u21d0= 2\n\u03b1 \u03b2\n=\u21d2 2\u2032\n\u03b1 t\n. Therefore, couple\ncan be applied adding the direct derivation H1=\u21d2 2\u2032\nH \u20321. Using the known independence, the latter can be\ninterchanged with the rule applications of G\u20321 !\n=\u21d2 1\nH1 yielding, in particular, G \u2032 1=\u21d2 2\u2032 G\u20322 and G \u2032 2 ! =\u21d2 1 H \u20321.\nMoreover, conflux can be applied to H1=\u21d2 2\u2032 H \u20321 and the rule applications of H1=\u21d2 2 H2 \u2217 =\u21d2 3 H3 yielding the moved variant H \u20321=\u21d2 2 H \u20322 \u2217 =\u21d2 3 H \u20323. Figure 7a shows the main parts of the derivation structure that is constructed so far. If H \u20322 \u2217\n=\u21d2 3\nH \u20323 has length 0, then we are done. The uppermost horizontal derivation is\nthe result we are looking for. Otherwise, one must repeat the construction done for H1=\u21d2 2 H2, i.e. couple, interchange, and then conflux as long as possible, for each of the applications of rule 3 in H \u20322 \u2217\n=\u21d2 3\nH \u20323\none after the other using the span\nt run \u03b2\np\n\u21d0= 3\nrun t \u03b1 \u03b2\n=\u21d2 3\u2032\nrun t \u03b1 t\nt . In the end, this yields a\nderivation G\u20322 \u2217\n=\u21d2 3\u2032\nG\u20323 with the same length as G2 \u2217\n=\u21d2 3 G3, i.e., n\u2212 1 if G has n vertices. Summarizing,\nthe resulting derivation G !\n=\u21d2 1\u2032 G\u20321=\u21d2 2\u2032 G\u20322 \u2217 =\u21d2 3\u2032 G\u20323 is successful as the derivation picks n\u2212 1 edges which\nalways is a spanning tree, therefore, the reduction turns out to be forward correct.\nConversely, let G !\n=\u21d2 1\u2032 G\u20321=\u21d2 2\u2032 G\u20322 \u2217 =\u21d2 3\u2032 G\u20323 be a successful derivation of 2-bounded-spantree. Let v0 be\nthe vertex matched by rule 2\u2032 and e1, . . . ,en\u22121 be the edges matched by the following applications of rule 3\u2032 in this order, where e1 is attached to v0. If none of the further edges is attached to v0, then the arguments proving forward correctness can be converted so that one gets backwards correctness, too. Otherwise, let ei with i \u2265 2 be attached to v0. Without loss of generality, one can assume i = 2 because this case can always be obtained by interchanges. Then the derivation G\u20321=\u21d2 2\u2032 G\u20322=\u21d2 3\u2032 G=\u21d2 3\u2032 G is an extension of the upper derivation in the pair\n\u03b2 \u03b2 \u03b2 =\u21d22\u2032\n\u03b2 t \u03b2\n=\u21d2 3\u2032\n\u03b2 t t t\n=\u21d2 3 \u2032 t t\nt\nt\nt\n=\u21d2 2 \u2032\nt \u03b2 \u03b2\n=\u21d2 3\u2032\nt t\nt\n\u03b2\n=\u21d23\u2032\nso that associate can be applied. This means that each successful derivation can be rearranged by repeated interchanges and associations in such a way that the conversion of the forward correctness proof works.\nFigure 7b depicts the derivation structure in Example 9 using the concrete examples used before.\nThere are several further reductions the correctness of which can be shown in a similar line of consideration, but their documentation here is beyond the space limit of the paper. Examples are independent-set \u2264 clique, k-bounded-spantree \u2264 l-bounded-spantree for 2 \u2264 k < l and hampath \u2264 hamcycle \u2264 TSP where TSP is the famous traveling salesperson problem. The latter example works very similar to clique \u2264 independent-set with the exception that the successful derivations of hamcycle are not moved to the end of the reduction derivation, but only to some intermediate graph where the corresponding TSP-derivation is constructed, which is further moved along the reduction. The examples indicate that the following proof procedure is quite promising to result in the correctness of reductions between NP-problems. Proof procedure. Let gtu and gtu\u2032 be two polynomial graph transformation units and red = (Igtu,P1 \u222a P2,C, Igtu\u2032) with P1 \u2229P2 = /0 be a functional graph transformation unit such that each of its successful\nderivations has the form G \u2217\n=\u21d2 P1\nG \u2217\n=\u21d2 P2 red(G). Let Pgtu and P1, P2 and Pgtu\u2032 , as well as Pgtu and Pgtu\u2032 be\ndisjoint and independent. Then the correctness of red may be proved as follows:\nForward Consider the start structure of Figure 4b.\n(f1) Apply conflux as long as possible using the independence of Pgtu and P1. The moved variant of the\ngiven gtu-derivation starting at G is called guide and G = AS active spot being the start graph of a permitted gtu\u2032-derivation that is built further on.\n(f2) Repeat the following operations as long as possible depending on the next rule application permitted\nby the stepwise control condition Cgtu\u2032 .\n(f21) If the next rule to be applied is the first one of a functional section of a permitted derivation\ngiven by funct, then apply sprout(funct) to AS where the graph funct(AS) is the new AS. Then apply conflux as long as possible using the independence of Pgtu and Pgtu\u2032 . The moved variant of the guide is the new guide.\n(f22) Otherwise, apply couple(span) for some given span to the first direct derivation of the guide where this is possible, provided that the prolongation yields a permitted derivation. Then\napply conflux and interchange as long as possible. In particular, the added direct derivation is moved to AS prolonging the permitted gtu\u2032-derivation. The result graph is the new AS and the following gtu-derivation is the new guide.\n(f3) Afterwards, apply conflux as long as possible using the independence of P2 and Pgtu\u2032 moving the\nconstructed permitted gtu\u2032-derivation to red(G). Then continue the derivation if Cgtu\u2032 requires further rule application.\n(f4) Check whether the derived graph is in SEM(Tgtu\u2032).\nBackward Reverse the procedure of the forward proof by starting with the structure of Figure 4c and changing the roles of gtu and gtu\u2032.\n(b1) Apply interchange instead of conflux as long as possible using the independence of P2 and Pgtu\u2032 .\n(b2) Repeat the operation as in (f2), but now using the spans conversely.\n(b3) Afterwards, apply interchange as long as possible using the independence of Pgtu and P1.\n(b4) Check whether the derived graph is in SEM(Tgtu).\nFigure 8 depicts the derivations for proving correctness.\nPreprocessing As the backward proof of hampath-to-2-bounded-spantree shows, a preprocessing may be necessary before the backward part of the proof procedure can work. The reason is that a graph may have several successful derivations, but only some of them may be suitable for forward and backward processing. In such a case, one may apply associate(pair) for appropriate pairs of derivations together with interchange.\nIt may be noted that our proof for clique \u2264 independent-set in Example 8 must be modified to be covered by the proof procedure in the following way: \u03b1 is replaced by \u03b1 \u2032 in independent-set and the corresponding derivation is constructed by applying couple for each rule application where the span \u03b1\n\u21d0= 1 =\u21d2 1\u2032\n\u03b1 \u2032\nis used.\nThe proof procedure works very well for several examples, but is far from perfect. For instance, we have failed to prove the correctness of the reduction from independent set to vertex cover and from vertex cover to Hamiltonian cycles. The reason seems to be that one needs further operations. But there are various further reasons why the proof procedure may fail: (1) The chosen units for the involved NP problems and the reduction may not be suitable. (2) The preprocessing may not yield a successful derivation for further processing. (3) The processing may get stuck because the proper spans are missing. (4) The processing may result in a permitted derivation that is not successful. Such problems are not unusual if the employed proof technique is not complete as it is often the case. Fortunately, each of the problems indicate how one may find a way out: Try further operations, other modeling units, other spans for coupling, other pairs for association, new ideas for preprocessing. See the conclusion where some of these points are a bit more elaborated."
        },
        {
            "heading": "7 Conclusion",
            "text": "We have made a proposal on how the correctness of reductions between NP problems may be proved by graph-transformational means. For this purpose, we have provided a toolbox that allows to construct successful derivations of one graph transformation unit from successful derivations of another graph transformation unit that represent positive decisions and are connected by a reduction derivation in their initial graphs. The approach is an attempt in the early stage of development and needs further investigation, to shed more light on its usefulness.\n1. The proof procedure has turned out to be suitable in several cases, but it seems to fail in other cases\nlike, for example, for the sophisticated reduction from the vertex cover problem to the Hamiltonian cycle problem (cf. [8, 6]).\n2. To cover more cases or to simplify proofs, one may look for further operations. Candidates are\noperations like conflux and interchange that are based on independence including parallelization, sequentialization, and shift (cf. [9]).\n3. Another possibility is to generalize the coupling by considering spans that consist of derivations\nrather than direct derivations.\n4. The preprocessing needs more attention. An initial graph may have a large class of successful\nderivations of which only a few particular ones may be suitable for the further proof procedure. Therefore, operations that preserve successfulness are of interest in addition to the association.\n5. The toolbox relies heavily on independence. Can this be always achieved by respective units? Can\nit be relaxed?\n6. Is there any chance of tool support for such correctness proofs? For particular initial graphs, the\nproof procedure is of an algorithmic nature. But what about arbitrary successful derivations and reduction derivations?\n7. A reduction between NP problems is a kind of model transformation. Do results of the theory\nof model transformations and their correctness proofs like triple graph grammars (cf., e.g., [14]) apply to reductions?\nAcknowledgment. We are grateful to the anonymous reviewers for their valuable comments."
        }
    ],
    "title": "A Graph-Transformational Approach for Proving the Correctness of Reductions between NP-Problems",
    "year": 2022
}