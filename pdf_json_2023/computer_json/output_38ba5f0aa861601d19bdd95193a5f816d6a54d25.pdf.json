{
    "abstractText": "Scalable and secure implementation of central bank digital currencies (CBDC) has been a challenge. Blockchains provide high operator-independent security and enable central banks to outsource CBDC operations while retaining control over the amount of circulating money. Scalability of blockchain depends on the possibility of decomposing the blockchain. We study how the choice of money scheme: accounts, bills, or unspent transaction outputs (UTXOs) influences the existence of secure and decomposable blockchain implementations of CBDC. We give formal definitions to money schemes, their decompositions, atomic decompositions inspired from the properties of blockchain implementations. For our formalism, we use tools from universal algebra and category theory. We present a general decomposition theory and conditions under which money schemes have atomic decompositions. Bill money schemes meet these conditions but account and UTXO schemes do not. Bill schemes enable scalable and secure implementations of CBDC while the more traditional schemes have some issues.",
    "authors": [
        {
            "affiliations": [],
            "name": "Ahto Buldas"
        },
        {
            "affiliations": [],
            "name": "Dirk Draheim"
        }
    ],
    "id": "SP:7176babe6e4a5e9a4302c20f444e34013d022a90",
    "references": [
        {
            "authors": [
                "A Buldas",
                "D Draheim",
                "M Gault",
                "R Laanoja",
                "T Nagumo",
                "M Saarepera",
                "SA Shah",
                "J Simm",
                "J Steiner",
                "T Tammet",
                "A. Truu"
            ],
            "title": "An ultra-scalable blockchain platform for universal asset tokenization: design and implementation",
            "venue": "IEEE Access",
            "year": 1928
        },
        {
            "authors": [
                "G Danezis",
                "S. Meiklejohn"
            ],
            "title": "Centrally banked cryptocurrencies",
            "venue": "Proceedings of NDSS\u201916\u2014the 23rd annual symposium on network and distributed system security. Reston: The Internet Society;",
            "year": 2016
        },
        {
            "authors": [
                "Federal Reserve Bank of Boston",
                "Massachusetts Institute of Technology Digital Currency Initiative"
            ],
            "title": "Project Hamilton Phase 1\u2014A High Performance Payment Processing System Designed for Central Bank Digital Currencies",
            "venue": "Federal Reserve Bank of Boston, Boston (3 February 2022). https:// www. bosto nfed. org/-/ media/ Docum ents/ Proje ct- Hamil ton/ Proje ct- Hamil ton- Phase-1White paper. pdf. Accessed 26 Mar 2022. SN Computer Science",
            "year": 2023
        },
        {
            "authors": [
                "Giesecke+Devrient"
            ],
            "title": "G+D Filia\u2014A Digital Complement to Cash",
            "venue": "Giesecke+Devrient, Munich, Germany",
            "year": 2021
        },
        {
            "authors": [
                "G Yu",
                "X Wang",
                "K Yu",
                "W Ni",
                "JA Zhang",
                "RP. Liu"
            ],
            "title": "Survey: sharding in blockchains",
            "venue": "IEEE Access",
            "year": 2020
        },
        {
            "authors": [
                "A Hafid",
                "AS Hafid",
                "M. Samih"
            ],
            "title": "Scaling blockchains: a comprehensive survey",
            "venue": "IEEE Access",
            "year": 2020
        },
        {
            "authors": [
                "L Luu",
                "V Narayanan",
                "C Zheng",
                "K Baweja",
                "S Gilbert",
                "P. Saxena"
            ],
            "title": "A secure sharding protocol for open blockchains",
            "venue": "Proceedings of CCS\u201916\u2014the 23rd ACM SIGSAC conference on computer and communications security. New York: 2016; ACM. p. 17\u201330. https:// doi",
            "year": 2016
        },
        {
            "authors": [
                "H Chen",
                "Y. Wang"
            ],
            "title": "SSChain: a full sharding protocol for public blockchain without data migration overhead",
            "venue": "Pervasive Mob Comput",
            "year": 2019
        },
        {
            "authors": [
                "E Kokoris-Kogias",
                "P Jovanovic",
                "L Gasser",
                "N Gailly",
                "E Syta",
                "B. Ford"
            ],
            "title": "OmniLedger: a secure, scale-out, decentralized ledger via sharding",
            "year": 2017
        },
        {
            "authors": [
                "E Kokoris-Kogias",
                "P Jovanovic",
                "L Gasser",
                "N Gailly",
                "E Syta",
                "B. Ford"
            ],
            "title": "OmniLedger: a secure, scale-out, decentralized ledger via sharding",
            "venue": "Proceedings of S ",
            "year": 2018
        },
        {
            "authors": [
                "M Zamani",
                "M Movahedi",
                "M. Raykova"
            ],
            "title": "RapidChain: scaling blockchain via full sharding",
            "venue": "Proceedings of CCS\u201918\u2014the 25th ACM SIGSAC conference on computer and communications security. New York: ACM;",
            "year": 2018
        },
        {
            "authors": [
                "H Dang",
                "TTA Dinh",
                "D Loghin",
                "E-C Chang",
                "Q Lin",
                "BC. Ooi"
            ],
            "title": "Towards scaling blockchain systems via sharding",
            "venue": "Proceedings of SIGMOD\u201919: the 2019 international conference on management of data. New York: ACM;",
            "year": 2019
        },
        {
            "authors": [
                "A Manuskin",
                "M Mirkin",
                "I. Eyal"
            ],
            "title": "Ostraka: secure blockchain scaling by node sharding",
            "venue": "Proceedings of Euro S ",
            "year": 2020
        },
        {
            "authors": [
                "Stegos AG"
            ],
            "title": "A Platform for Privacy Applications, version 1.0. 2019",
            "venue": "https:// stegos. com/ docs/ stegos- white paper. pdf. Accessed",
            "year": 2022
        },
        {
            "authors": [
                "V. Buterin"
            ],
            "title": "A next generation smart contract and decentralized application platform\u2014Ethereum",
            "venue": "White Paper",
            "year": 2015
        },
        {
            "authors": [
                "J. Drake"
            ],
            "title": "Ethereum Sharding. 2018",
            "venue": "https:// youtu. be/ J4ryl D6w2S4. Accessed",
            "year": 2022
        },
        {
            "authors": [
                "J Wang",
                "H. Wang"
            ],
            "title": "Monoxide: scale out blockchains with asynchronous consensus zones",
            "venue": "Proceedings of NSDI\u201919\u201416th USENIX symposium on networked systems design and implementation. USENIX Association,",
            "year": 2019
        },
        {
            "authors": [
                "A. Hafid"
            ],
            "title": "Probabilistic models to analyze the security of sharding-based blockchain protocols",
            "venue": "PhD thesis,",
            "year": 2021
        },
        {
            "authors": [
                "M Al-Bassam",
                "A Sonnino",
                "S Bano",
                "D Hrycyszyn",
                "G. Danezis"
            ],
            "title": "Chainspace: a sharded smart contracts platform. In: Proceedings of NDSS\u201918\u2014the 25th annual network and distributed system security symposium",
            "year": 2018
        },
        {
            "authors": [
                "N Sohrabi",
                "Z. Tari"
            ],
            "title": "ZyConChain: a scalable blockchain for general applications",
            "venue": "IEEE Access",
            "year": 2020
        },
        {
            "authors": [
                "M Du",
                "Q Chen",
                "X. Ma"
            ],
            "title": "MBFT: a new consensus algorithm for consortium blockchain",
            "venue": "IEEE Access",
            "year": 2020
        },
        {
            "authors": [
                "Chan WK",
                "Chin J-J",
                "Goh VT"
            ],
            "title": "Simple and scalable blockchain with privacy",
            "venue": "J Inf Secur Appl",
            "year": 2021
        },
        {
            "authors": [
                "A Singh",
                "K Click",
                "RM Parizi",
                "Q Zhang",
                "A Dehghantanha",
                "K-KR. Choo"
            ],
            "title": "Sidechain technologies in blockchain networks: an examination and state-of-the-art review",
            "venue": "J Netw Comput Appl",
            "year": 2020
        },
        {
            "authors": [
                "S Meiklejohn",
                "C. Orlandi"
            ],
            "title": "Privacy-enhancing overlays in Bitcoin",
            "venue": "Proceedings of FC\u20192015\u2014the 19th international conference on financial cryptography and data security. Lecture notes in computer science,",
            "year": 2015
        },
        {
            "authors": [
                "MMT Chakravarty",
                "J Chapman",
                "K MacKenzie",
                "O Melkonian",
                "M Peyton Jones",
                "P. Wadler"
            ],
            "title": "The extended UTXO model. In: Financial cryptography and data security",
            "venue": "Lecture Notes in Computer Science,",
            "year": 2020
        },
        {
            "authors": [
                "Gabbay MJ"
            ],
            "title": "Algebras of UTxO blockchains",
            "venue": "Math Struct Comput Sci",
            "year": 2021
        },
        {
            "authors": [
                "Br\u00fcnjes L",
                "Gabbay MJ"
            ],
            "title": "UTxO- vs account-based smart contract blockchain programming paradigms. In: Proceeding of ISOLA\u20192020\u2014the 9th international symposium on leveraging applications of formal methods, verification and validation",
            "venue": "Lecture Notes in Computer Science,",
            "year": 2020
        },
        {
            "authors": [
                "Reynolds JC"
            ],
            "title": "Separation logic: a logic for shared mutable data structures",
            "venue": "Proceedings of LICS\u20192002\u2014the 17th IEEE symposium on logic in computer science",
            "year": 2002
        },
        {
            "authors": [
                "R. Milner"
            ],
            "title": "Communicating and mobile systems: the -calculus",
            "year": 1999
        },
        {
            "authors": [
                "Gabbay MJ"
            ],
            "title": "A theory of inductive definitions with -equivalence\u2014semantics, implementation, programming language",
            "venue": "PhD thesis, DPMMS and Trinity College, Cambridge University",
            "year": 2000
        },
        {
            "authors": [
                "Gabbay MJ",
                "Pitts AM"
            ],
            "title": "A new approach to abstract syntax with variable binding",
            "venue": "Formal Aspects Comput",
            "year": 2001
        },
        {
            "authors": [
                "MJ Gabbay",
                "DR Ghica",
                "D. Petrisan"
            ],
            "title": "Leaving the nest: nominal techniques for variables with interleaving scopes",
            "venue": "Proceeeding of CSL\u20192015\u2014the 4th EACSL annual conference on computer science logic. Leibniz International Proceedings in Informatics,",
            "year": 2015
        },
        {
            "authors": [
                "Gabbay MJ"
            ],
            "title": "Equivariant ZFA and the foundations of nominal techniques",
            "venue": "J Log Comput",
            "year": 2020
        },
        {
            "authors": [
                "C. Nester"
            ],
            "title": "A foundation for ledger structures. In: Proceedings of Tokenomics 2020\u2014the 2nd international conference on blockchain economics, security and protocols",
            "venue": "Open Access Series in Informatics,",
            "year": 2021
        },
        {
            "authors": [
                "B Coecke",
                "T Fritz",
                "RW. Spekkens"
            ],
            "title": "A mathematical theory of resources",
            "venue": "Inf Comput",
            "year": 2016
        },
        {
            "authors": [
                "McCurdy MB"
            ],
            "title": "Graphical methods for Tannaka duality of weak bialgebras and weak Hopf algebras",
            "venue": "Theory Appl Categ",
            "year": 2012
        },
        {
            "authors": [
                "P. Selinger"
            ],
            "title": "A survey of graphical languages for monoidal categories. In: New structures for physics",
            "venue": "Lecture notes in physics,",
            "year": 2010
        },
        {
            "authors": [
                "N Valliappan",
                "S Mirliaz",
                "E Lobo Vesga",
                "In Russo A. Towards adding variety to simplicity."
            ],
            "title": "Proceedings of ISoLA\u20192018\u2014the 8th international symposium on leveraging applications of formal methods, verification and validation",
            "venue": "Lecture notes in SN Computer Science",
            "year": 2023
        },
        {
            "authors": [
                "A Buldas",
                "M Saarepera",
                "J Steiner",
                "D. Draheim"
            ],
            "title": "A unifying theory of electronic money and payment systems",
            "venue": "TechRxiv. 2021. https:// doi. org/",
            "year": 2021
        },
        {
            "authors": [
                "A Buldas",
                "D Draheim",
                "M. Saarepera"
            ],
            "title": "Secure and efficient implementation of electronic money. In: Proceedings Fof FDSE\u20192022\u2014the 9th international conference future data and security engineering. communications in computer and information science, vol 1688",
            "year": 2022
        },
        {
            "authors": [
                "Y Aumann",
                "Y. Lindell"
            ],
            "title": "Security against covert adversaries: efficient protocols for realistic adversaries",
            "venue": "Vadhan SP, editor. Proceedings of TCC\u20192007\u2014the 4th theory of cryptography conference. Lecture notes in computer science,",
            "year": 2007
        },
        {
            "authors": [
                "Y Aumann",
                "Y. Lindell"
            ],
            "title": "Security against covert adversaries: efficient protocols for realistic adversaries",
            "venue": "J Cryptol",
            "year": 2007
        },
        {
            "authors": [
                "A Buldas",
                "M. Niitsoo"
            ],
            "title": "Optimally tight security proofs for hashthen-publish time-stamping",
            "venue": "Information security and privacy\u2014ACISP",
            "year": 2010
        },
        {
            "authors": [
                "R Olt",
                "T Meidla",
                "L Ilves",
                "J. Steiner"
            ],
            "title": "Summary report: results of the Eesti Pank\u2014Guardtime CBDC Research. Eesti Pank, Guardtime, Tallinn",
            "venue": "EP- Guard time_ CBDC_ Resea rch_",
            "year": 2021
        },
        {
            "authors": [
                "A Buldas",
                "M Saarepera",
                "J Steiner",
                "L Ilves",
                "R Olt",
                "T. Meidla"
            ],
            "title": "Formal model of money schemes and their implications for central bank digital currency",
            "venue": "Eesti Pank, Guardtime, Tallinn",
            "year": 2021
        },
        {
            "authors": [
                "Eesti Pank"
            ],
            "title": "Eesti Pank Ran an Experiment to Investigate the Technological Possibilities of a Central Bank Digital Currency Based on Blockchain, Eesti Pank",
            "year": 2021
        },
        {
            "authors": [
                "P Sandner",
                "C Lichti",
                "C Heidt",
                "R Richter",
                "B. Schaub"
            ],
            "title": "The carbon emissions of bitcoin from an investor perspective",
            "venue": "Frankfurt: Frankfurt School Blockchain",
            "year": 2021
        },
        {
            "authors": [
                "JP Trespalacios",
                "J. Dijk"
            ],
            "title": "The Carbon Footprint of Bitcoin",
            "venue": "De Nederlandsche Bank, Amsterdam",
            "year": 2021
        },
        {
            "authors": [
                "A Buldas",
                "S. Laur"
            ],
            "title": "Knowledge-binding commitments with applications in time-stamping",
            "venue": "Lecture notes in computer science,",
            "year": 2007
        }
    ],
    "sections": [
        {
            "text": "Vol.:(0123456789)\nSN Computer Science\nKeywords Blockchain\u00a0\u00b7 Central bank digital currency\u00a0\u00b7 Digital cash\u00a0\u00b7 Sharding\nDirk Draheim and M\u00e4rt Saarepera have contributed equally to this work.\nThis article is part of the topical collection \u201cFuture Data and Security Engineering 2022\u201d guest edited by Tran Khanh Dang.\n* Ahto Buldas ahto.buldas@taltech.ee\nDirk Draheim dirk.draheim@taltech.ee\nM\u00e4rt Saarepera mart.saarepera@guardtime.com\n1 Centre for\u00a0Digital Forensics and\u00a0Cyber Security, Tallinn University of\u00a0Technology, Akadeemia tee 15a, 12618\u00a0Tallinn, Estonia\n2 Information Systems Group, Tallinn University of\u00a0Technology, Akadeemia tee 15a, 12618\u00a0Tallinn, Estonia\n3 Guardtime, A. H. Tammsaare tee 60, 11316\u00a0Tallinn, Estonia"
        },
        {
            "heading": "Introduction",
            "text": "During the last years, central banks have discussed possible use of central bank digital currencies (CBDC)\u2014electronic cash. Besides the financial and economic factors also the scalability and security of technical implementations of CBDC have been studied. Blockchain technology provides a high level of security independent of the technical\ninfrastructure and enables central banks to outsource most of the CBDC operations to the private sector while still having full control over the total amount of CBDC in circulation. The security measures may depend on whether the blockchain solution is public (permissionless) or private (permissioned). Private blockchains are less costly but their security needs somewhat more care as some type of insider attacks have to be considered.\nScalability has been the biggest technical concern of using blockchain-based CBDC. Nation-wide deployment of electronic cash requires service rates of ten to hundred thousands transactions per second while blockchain money solutions like Bitcoin only offer the rate of few dozen transactions per second. The key of filling the scalability gap is the possibility of decomposing (sharding) the blockchain. The efficiency of decomposition highly depends on the need for inter-component communication. For example, whenever two accounts are in different components, paying from one account to another requires two simultaneous operations in both components: debiting one account and crediting the other. This is technically challenging as it requires solving the atomic commit problem (often called \u201ctwo generals problem\"), which has no deterministic time solutions if possible message loss is considered. On the other hand, if we imagine a single coin or bill given by one person to another, the only parameter that changes is the ownership of the coin/bill. Such operation is\nSN Computer Science\natomic by definition. Hence, if an electronic money solution uses coins and bills to represent money and is sharded so that some coins and bills belong to one shard and others to another shard, then every single coin payment is uni shard and does not require inter shard communication.\nIn this paper, we present a general decomposition theory of money schemes and its implications about how the possibility of efficient sharding depends on the choice of the money scheme (accounts, coins, etc.). The theory explains why blockchain-based implementations of account-based and UTXO-based money schemes cannot be efficiently sharded, while bill based money schemes have efficient and secure sharding mechanisms. For our formalism, we use universal algebra and category theory as essential tools, because this provides us with the appropriate level of abstraction to find, prove and apply results on decomposability and indecomposability of e-money and payment systems.\nThis work also focuses on the security of sharded blockchain implementations of the bill money scheme considering that the blockchain is used in a permissioned and controlled scenario by the central bank. However, we consider the possibility that the central bank can outsource most of the service machinery to the private sector. The security of the solution is based on special types of lightweight userinitiated audit protocols that are executed during every payment. The goal of the audit procedure is to verify that each particular bill is properly used, i.e., all the ledger rules are fulfilled. We study two types of audit protocols:\n1. Full audit\u2014if successful, guarantees that the ledger rules are followed 2. Probabilistic audit\u2014guarantees that any deviation from ledger rules will be detected very soon. The motivation behind probabilistic audit is that the communication complexity of the audit protocol is reduced.\nThe existence of communication-efficient probabilistic protocols seems to depend on the chosen money scheme and the blockchain certification scheme. We show that such protocols exist in the KSI-Cash CBDC solution [1] that is based on the bill money scheme, i.e. simulates the use of physical cash. It remains an open question if efficient probabilistic audit protocols exist for other money schemes.\nIn \u201cRelated work\u201d, we provide a discussion of related work. In \u201cMoney schemes\u201d and \u201cDescriptional complexity of payments\u201d, we explain money schemes and the decomposability of payments. We formalize the implementation and decomposition of money schemes and investigate their blockchain implementations in \u201cImplementations of money schemes and Blockchain implementations\u201d. In \u201cAtomic decomposition of money schemes\u201d, we formalize atomic decompositions\u2014a class of decompositions that takes into account the aspects of blockchain implementations. We show that the bill scheme has\natomic decompositions and the account and UTXO schemes do not. In \u201cUnitwise decompositions of money schemes\u201d, we study a special kind of decompositions called unitwise decompositions and give necessary and sufficient conditions for money schemes that guarantee the existence of atomic unitwise decompositions. In \u201cSecurity of blockchain implementations, Rules of a bill ledger and User side full audit\u201d, we discuss diverse security aspects of blockchain implementations. In \u201cKSI-cash bill ledger and User side probabilistic audit in KSI-cash\u201d, we describe KSI-Cash and its user side probabilistic audit. We finish the paper with a discussion in \u201cDiscussion\u201d and a conclusion in \u201cConclusions\u201d."
        },
        {
            "heading": "Related Work",
            "text": ""
        },
        {
            "heading": "Central Bank Digital Currencies",
            "text": "RSCoin [2] is an example of a sharded central bank digital currency. RSCoin is based on a blockchain as ledger and its architecture is centered around so called mintettes (which are shards in usual database terminology) and a trusted central component. Each mintette is responsible for a range of public client addresses. Together, the mintettes create consensus on valid blocks, which are then certified by the central component. The necessary communication between the mintettes is achieved indirectly via the wallets running a two-phase-commit protocol. Here, each wallet decides individually based on incoming majority votes.\nThe Hamilton Project [3] by the Federal Reserve Bank of Boston and the Massachusetts Institute of Technology Digital Currency Initiative is a concept study on the implementation of central bank digital currency. The study investigates two architectures. The first is the so called atomizer architecture, which is a blockchain solution that relies on sharded transaction verification. The architecture is based on the UTXO scheme. The central component of the architecture is called atomizer. The atomizer collects verified payments from the shards and creates the blocks, which introduces a significant bottleneck to the system. Next, the study compares the atomizer solution with the so-called 2PC architecture (2-phase-commit architecture), which represents established (i.e., non-blockchain) transaction system technologies found in today\u2019s banking.\nThe crucial difference between RSCoin and the Hamilton project on the one hand and KSI Cash on the other hand is in the utilized money schemes. Both RSCoin and the Hamilton are based on the UTXO scheme, whereas KSI Cash is based on the bill money scheme. RSCoin and the Hamilton project need to deal with the severe issue of crossshard transactions, whereas KSI Cash can instead deal with the comparatively moderate issue of increasing amounts of smaller money denominations [1].\nSN Computer Science\nAn industrial-proven CDBC solution that is based on the bill scheme is G+D Filia provided by [4]. G+D Filia allows for offline consecutive payments and comes with a concept of money distribution as public-private partnership between central banks and commercial banks as intermediaries. In the context of this paper, G+D Filia is relevant because it is based on a bill money scheme, called value-based approach by [4]: \u201cG+D Filia takes a value-based approach. Accordingly, monetary value is represented by a piece of data, a so-called value note. Payment is done by transferring this piece of data from one person to another, mirroring cash payments, which are carried out by transferring physical banknotes or coins from person A to person B \" [4].\nNone of the related studies discussed in \u201cCentral bank digital currencies\u201d aims at contributing to the theoretical understanding (and analysis) of payment systems as our paper."
        },
        {
            "heading": "Relevant Blockchain Technologies",
            "text": "Two recent surveys on sharding in blockchains are provided by [5] and [6]. Together, [5] and [6] investigate a total of 15 technologies, which are based on established e-money schemes (or do not specify an e-money scheme) as follows:\n\u2022 UTXO model: Elastico [7], SSChain [8], OmniLedger [9, 10], RapidChain [11, 12], Ostraka [13], and Stegos [14] \u2022 account model: Ethereum blockchains (including Ethereum [15], Ethereum 2.0 [16], and Ethereum upgrades1), Monoxide [17], ZILLIQA [18], Harmony [19], and Logos (Table\u00a02.2. in [20]) \u2022 object-based money scheme: Chainspace [21] \u2022 money scheme not specified: ZyConChain [22], and [23]\nNone of the sharded blockchain technologies surveyed by [5] and [6] are based on a bill scheme. We have found one blockchain technology in the literature, i.e., CoinCash [24], however, CoinCash is not a sharded blockchain technology, instead, it is a Bitcoin sidechain [25] that aims at enhancing privacy by adding an overlay of transaction anonymization [26].\nNone of the related studies discussed in \u201cRelevant blockchain technologies\u201d aims at contributing to the theoretical understanding (and analysis) of payment systems as our paper."
        },
        {
            "heading": "The Extended UTXO Model",
            "text": "In [27], the Extended UTXO (EUTXO) model has been suggested that aims at allowing for a more expressive smart contract language (similar to Ethereum, which is based on an\naccount money scheme) while keeping the semantic model as close as possible to the UTXO model and, therefore, as simple as possible (as compared to the semantic model of the account money scheme, which is considered more complex by [27]). \u201cTo maintain the machine state [the EUTXO model extends] UTXO outputs from being a pair of a validator and a cryptocurrency value to being a triple ( ,value, ) of validator, value, and a datum , where contains arbitrary contract-specific data\u201d [27]. Then, [27] formally describes the EUTXO model in \u201ca straightforward set-theoretic form, which (1) admits an almost direct translation into languages like Haskell for implementation, and (2) is easily amenable to mechanical formalisation\u201d [27]. The work [27] results in a powerful semantic model, that is fully formalised with the Agda2 proof assistant. The objective of [27] (increasing smart contract expressiveness plus achieving semantic simplicity) is different from the objective of this paper (theoretical foundation of payment systems to enable the analysis of payment system decomposition)."
        },
        {
            "heading": "Formal Models of\u00a0Blockchain Technology",
            "text": "In [28], the EUTXO model [27] (see \u201cThe extended UTXO model\u201d) is made subject of further investigation. On the basis of this, [28] provides a set of recursive type equations specifying an Idealized EUTXO [28, 29] money scheme. The model of these type equations form a category IETUxO. Furthermore, [28] provides a novel perspective on blockchains in terms of partitions called chunks which \u201cdisplay resource separation properties reminiscent of known systems such as separation logic [30]\u201d [28] and \u201ccommunicate across channels (much like the -calculus [31])\u201d [28]. Reference [28] formalizes the concept of chunks as abstract chunk systems in terms of a set of testable algebraic properties. Again, abstract chunk systems form a category ACS. Finally, [28] is able to construct functors between the categories IETUxO and ACS that \u201cexhibit a cycle of categorical embeddings between them\u201d [28]. This way, [28] achieves a rich collection of algebraic properties [32\u201335] of UTXO-based blockchains that can be exploited in future formal reasoning about blockchain systems.\nIn [36], the theory of resources of [37] is utilized to achieve a basic category-theoretical model of cryptocurrency systems. First, [36] gives a precise semantics of a version of string diagrams that have been augmented by concepts for modeling resource ownership (compare with [38]). Then, they show the applicability of these augmented string diagrams to ledger structures. With his work, [36] is able to show \u201chow the resource theoretic interpretation of monoidal categories, and in particular their string diagrams [39],\n1 https:// ether eum. org/ en/ upgra des/. 2 https:// wiki. portal. chalm ers. se/ agda/.\nSN Computer Science\ncaptures the sort of material history that concerns ledger structures for blockchain systems\u201d [36].\nThe work presented in this paper is different from [28, 36] in regard of the following aspects: We formalize not only one of the established e-money schemes (UTXO scheme, account scheme), but incorporate the novel bill scheme into our theory; and we utilize our formalization to yield a series of results on the decomposability of the several e-money schemes, that are needed in informed design decisions in designing sharded blockchain technology. The bill scheme is particularly important, as our investigation shows that the bill scheme allows for the design of an ultra-scalable blockchain technology via sharding.\nIn [40], category theory is utilized to improve the language design and implementation of the blockchain smart contract language Simplicity. While [40] provides another useful example of leveraging category theory to advance the practice of information systems, and blockchain technology in particular, their objective (semantics and pragmatics of a smart contract language) is different from the objective of this paper (theoretical foundation of payment systems to enable the analysis of payment system decomposition)."
        },
        {
            "heading": "Money Schemes",
            "text": "A money scheme [41, 42] describes the representational aspects of money and payments. There are different money schemes in practical use\u2014account schemes, bill schemes, UTXO schemes, etc. In this section, we present a formal approach to characterize different money schemes."
        },
        {
            "heading": "Money Distributions",
            "text": "Money can be represented as a set U of units and a value function \u2236 U \u2192 \u2115 that defines for each unit u \u2208 U its value (u) \u2208 \u2115 , where N is the set of natural numbers. The units may be accounts, bills, UTXOs, etc. We assume that there exists an infinite set U of all potential units, i.e. U \u2282 U . For describing the ownership of money, a second function \u2236 U \u2192 B is introduced that assigns for each unit u \u2208 U its owner (bearer) (u) \u2208 B , where B is the set of all potential bearers.\nA triple M = (U, , ) is called a money distribution because it describes the units with their values and ownership. We denote by M the set of all possible money distributions, i.e. M consists of all triples (U, , ) , where U is a finite subset of U and \u2236 U \u2192 \u2115 and \u2236 U \u2192 B are any functions.\nIn such a model, we define the total amount of money in a money distribution M = (U, , ) as (M) = \u2211 u\u2208U (u) , and a\nmoney owned by a bearer b \u2208 B by (M, b) = \u2211\nu\u2208 \u22121(b) (u) . The ownership function (M, \u22c5) \u2236 B \u2192 \u2115 represents the\naccount view of the money distribution M. A money distribution M can be represented as a pair (B, (M, \u22c5)) . This is equivalent of hiding the units of the money distribution M from an owner b and showing only the account balance (M, b).\nMoney distribution is only a static picture of money and does not distinguish different money schemes. What makes the most important technical difference between money schemes are the payments."
        },
        {
            "heading": "Money Transformations and\u00a0Payments",
            "text": "Payments are certain type of transformations that change the money distribution, but preserve the total amount (M) of money. Before defining payments, we define money transformations that do not necessarily preserve (M).\nDefinition 1 (Money transformation) A money transformation P is a function P \u2236 M \u2192 M defined as a rule on a finite subset UP of units such that for every u \u2208 Up , it is described how the unit itself and its parameters (u) and (u) are changed by P. For every money distribution M = (U, , ) , a money transformation P may:\n\u2022 Delete u, if u \u2208 U . If u \u2209 U , then P cannot be applied to M. \u2022 Create u and define (u) and (u) , if u \u2209 U . If u \u2208 U , then P cannot be applied to M. \u2022 Reduce or rise the value of u by a certain way and/or change the bearer of u, assuming that the value of u cannot become negative. If this would happen or if u \u2209 U , then P cannot be applied to M.\nWe assume that if P cannot be applied to M, then P(M) = M . Note that P(M) does not depend on units outside UP nor their parameters.\nA money transformation P with UP = \ufffd is called the identity transformation and is denoted by 1M or simply 1. The following lemmas (Lemmas\u00a01, 2, 3) are direct corollaries from Definition\u00a01.\nLemma 1 Let P be a money transformation and M = (U, , ) be any money distribution such that M \u2260 P(M) . Let M\ufffd = (U\ufffd, \ufffd, \ufffd) be a money distribution such that U \u2229 UP = U\ufffd \u2229 UP , (u) = \ufffd(u) , (u) = \ufffd(u) for all u \u2208 U \u2229 UP , i.e. M\u2032 differs from M only by the units u \u2209 UP and possibly by their values (u) and (u) . Then also M\ufffd \u2260 P(M\ufffd).\nProof As the status of the units of UP in M\u2032 is the same as in M, and the rules of P can be applied to M, then P can be applied to M\u2032 . \u25fb\nSN Computer Science\nLemma 2 If P,P\u2032 are money transformations and M \u2260 P(M) = P\ufffd(M) for M \u2208 M , then P = P\ufffd , i .e . P(M\ufffd) = P\ufffd(M\ufffd) for every M\ufffd \u2208 M .\nProof The assumption M \u2260 P(M) = P\ufffd(M) implies that the rules of both P and P\u2032 can be applied to M and they change M in the same way.\n\u2022 If a unit u was deleted in M, then the rules of both P and P\u2032 contain the instruction to delete u. \u2022 If a unit u was created in M, then the rules of both P and P\u2032 contain an instruction to create u with exact same parameters. \u2022 If the parameters of a unit u were changed in M, then the rules of both P and P\u2032 contain the instruction to change the parameters of u in exact same way.\nThe rules of P and P\u2032 cannot contain more instructions than such changes indicate. Therefore, P and P\u2032 are defined by the same rules and hence, they act on every M\u2032 in exact same way. \u25fb Lemma 3 For every money transformation P \u2260 1 , there is a money distribution M where P(M) \u2260 M.\nProof For every u \u2208 UP , if P creates u, choose M = (U, , in a way that u \u2209 U ; if P deletes u, make sure that u \u2208 U . If P reduces (u) by d, make sure that (u) \u2265 d . It is easy to see that a finite U exists that satisfies all these requirements, because UP is finite. \u25fb\nNote that the composition P1\u25e6P2 of two money transformations P1 and P2 is not always a money transformation. For example, if P2 reduces the value of u by 10, and P1 rises the value of u by 20, then in a money distribution M1 = (U1, 1, 1) where u \u2208 U1 and 1(u) = 5 , and in another money distribution M2 = (U2, 2, 2) where u \u2208 U2 and 2(u) = 10 , the unit u is changed differently by P1\u25e6P2 . Indeed, in (P1\u25e6P2)(M1) the value of u will be 25 (i.e. raised by 20), but in (P1\u25e6P2)(M2) the value of u will be 15 (i.e. raised by 10). Therefore, to describe the action of compositions P1\u25e6P2 one may need different unit-based rules in money distributions M1 and M2.\nDefinition 2 (Non-redundant composition) A composition Pm\u25e6\u22ef\u25e6P1 of money transformations Pi is non-redundant at a money distribution M if Mi\u22121 \u2260 Pi(Mi\u22121) for every i \u2208 {1,\u2026 ,m} , where M0,M1,\u2026 ,Mm are money distributions such that M0 = M and Mj = Pj(Mj\u22121) for every j \u2208 {1,\u2026 ,m}.\nDefinition 3 (Co-product) The co-product P1 \u2295 P2 of money transformations P1,P2 with UP1 \u2229 UP2 = \ufffd is a money transformation P with UP = UP1 \u222a UP2 and with the rule that if\nu \u2208 UP1 , then the rule of P1 is applied, and if u \u2208 UP2 , then the rule of P2 is applied. If any of the rules cannot be applied to a money distribution M, then (P1 \u2295 P2)(M) = M.\nHence , i t might be tha t (P1 \u2295 P2)(M) = M , but P1(M) \u2260 M or P2(M) \u2260 M . Note also that, if M \u2260 (P1 \u2295 P2)(M) , then (P1 \u2295 P2)(M) = P2(P1(M)) , but in general, this is not true.\nDefinition 4 (Payment) A payment is a money transformation P that does not change the total amount of money, i.e. (P(M)) = (M) for every M \u2208 M .\nSome examples of payments that act on a money distribution M = (U, , ):\n\u2022 Identity transformation 1M changes no units. \u2022 Account payments change the values (u) and (v) of two\nunits (accounts) u, v \u2208 U . The resulting money distribution is (U\ufffd, \ufffd, \ufffd) , where U\ufffd = U , \ufffd = (no accounts are deleted/created and their owners stay the same), and \ufffd(u) + \ufffd(v) = (u) + (v) , i.e. total amount of money does not change. \u2022 Bill payments change only the owner (u) of a unit (bill) u. The resulting money distribution is (U\ufffd, \ufffd, \ufffd) , where U\ufffd = U , \ufffd = (no units are created/deleted and their values stay the same), but possibly \ufffd(u) \u2260 (u). \u2022 UTXO payments delete a set {u1,\u2026 , um} of units (UTXOs) and create a set {v1,\u2026 , vk} of units so that (u1) +\u2026 + (um) = \ufffd(v1) +\u2026 + \ufffd(vk) in the result-\ning money distribution (U\ufffd, \ufffd, \ufffd)."
        },
        {
            "heading": "Money Schemes",
            "text": "A money scheme describes which money distributions and which payments are allowed in an application of money.\nDefinition 5 (Money scheme) A money scheme is a pair (M,P) , where M is a set of money distributions and P is a set of payments, such that the next properties hold:\n\u2022 Identity: 1M \u2208 P. \u2022 Accessibility of money: For every M \u2208 M and b \u2208 B ,\nthere is P \u2208 P such that (P(M), b) = 0 , i.e. bearers can always spend all their money. Here, P denotes the set of all finite compositions P = P1\u25e6\u22ef\u25e6Pm of Pi \u2208 P.\nIn this work, we assume for simplicity that M is always the set of all money distributions as defined in \u201cMoney Distributions\u201d. This simplification is justified because only the payments make difference between money schemes.\nA composition P = P1\u25e6P2 of payments P1,P2 \u2208 P is not necessarily a payment. From practical implementation\nSN Computer Science\nview-point, payments represent transactions that are initiated by payment orders sent to the money and payment system by its users. If two users send their payment orders P1,P2 to the system, then the money and payment system does not necessarily accept \u201ccomposite\" payment orders the execution of which is equivalent to applying P1\u25e6P2 to the current money distribution. For every P \u2208 P , we define a function \u0394P \u2236 M \u00d7B \u2192 \u2124 , so that\nwhich shows how the account balance of b is changed by P. If \u0394P(M, b) > 0 , then b pays money to other bearers, and if \u0394P(M, b) < 0 , then b receives money via P.\nLemma 4 (Uniformity of amount) If (M,P) is a money scheme with the bearer set B , P \u2208 P , M,M\ufffd \u2208 M , b \u2208 B , P(M) \u2260 M , and P(M\ufffd) \u2260 M\ufffd , then\nProof Direct implication from the description of payments via actions on all potential units u \u2208 U (Definition\u00a01, Definition\u00a04). If P can be applied to both money distributions M and M\u2032 , then P changes them in exactly the same way. \u25fb\nDefinition 6 (Subscheme) A money scheme (M,P) is a subscheme of a money scheme (M,P\ufffd) , if P \u2286 P\u2032."
        },
        {
            "heading": "Categorization of\u00a0Money Schemes by\u00a0Invariance",
            "text": "In this subsection, we present a full list of types of money schemes (M,P) , based on the invariance of components U, , and of money distributions under the payments P \u2208 P of the money scheme. From a purely combinatorial viewpoint, there are eight classes of schemes as presented in Table\u00a01:\n\u0394P(M, b) = (M, b) \u2212 (P(M), b),\n\u0394P(M \ufffd, b) = \u0394P(M, b).\n1. If all three parameters U, , and are invariant, then the payments do not change the money distribution, which means that money does not flow, and hence, this class of schemes is not interesting. 2. There exist no schemes, in which only U changes, because, by changing the domain of functions and also means changing and as functions.\nSo, only five of these eight types are of practical interest:\n1. Schemes in which only the bearer function changes, i.e., bill schemes. 2. Schemes in which only the value function changes, i.e., account schemes. 3. Schemes in which only and change, one example of which is the extended account scheme, where in addition to ordinary account transfers, the owners of accounts may also change. 4. Schemes in which all parameters may change, i.e., the hybrid schemes, an example of which is the UTXO scheme.\nFor having a closer view on how money schemes can be constructed, especially the hybrid schemes, we will study in \u201cDescriptional complexity of payments\u201d the algebraic structure of payments, i.e. how more complex payments can be constructed from simpler ones."
        },
        {
            "heading": "Descriptional Complexity of\u00a0Payments",
            "text": "In this section, we describe and categorise all possible types of payments and show how payments can be algebraically decomposed to irreducible payments.\nAs every payment P is a money transformation, it is represented as a rule on a finite subset UP \u2282 U of units, that is a non-intersecting union UP = U\u2212P \u222a U + P \u222a U0 P of the next subsets:\nSN Computer Science\n\u2022 U\u2212 P : the set of units that P deletes. \u2022 U+ P : the set of units that P creates. \u2022 U0 P : the set of units u the parameters (u), (u) of which\nare changed by P.\nThe descriptional complexity \u2016P\u2016 of P is the sum of the sizes of U\u2212\nP ,U+ P ,U0 P , i.e. \u2016P\u2016 = \u2016U\u2212 P \u2016 + \u2016U+ P \u2016 + \u2016U0 P \u2016 .\nThe input complexity \u2016P\u2016 of P is the sum of the sizes of U\u2212 P ,U0 P , i.e. \u2016P\u2016 = \u2016U\u2212 P \u2016 + \u2016U0 P \u2016 . For P = 1M , we have \u2016P\u2016 = \u2016P\u2016 = 0 , and vice versa, if \u2016P\u2016 = 0 for a payment P, then U\u2212 P = U+ P = U0 P = \ufffd , which means that P does not create/delete units nor changes the parameters of any units which means that P = 1M . In the following, we present three more examples of the complexities of payments:\n\u2022 Single bill transfer: A payment P that changes the bearer of a single unit u and does nothing else. In this case, \u2016P\u2016 = \u2016P\u2016 = 1. \u2022 Account payment: A payment P that changes the values n1, n2 of two units u1 and u2 to n\u20321, n \u2032 2 so that\nn\ufffd 1 + n\ufffd 2 = n1 + n2 . In this case, \u2016P\u2016 = \u2016P\u2016 = 2.\n\u2022 UTXO payment: A payment P that deletes units u1,\u2026 , uk with values n1,\u2026 , nk and creates units u\ufffd\n1 ,\u2026 , u\ufffd with values n\ufffd 1 ,\u2026 , n\ufffd so that\nn\ufffd 1 +\u22ef + n\ufffd \ud835\udcc1 = n1 +\u22ef + nk . In this case, \u2016P\u2016 = k + and \u2016P\u2016 = k.\nDefinition 7 (Composition-irreducible payments) A payment P is reducible at a money distribution M \u2208 M if M \u2260 P(M) and there exists a non-redundant at M composition Pm\u25e6\u22ef\u25e6P1 of payments with \u2016Pi\u2016 < \u2016P\u2016 for all i \u2208 {1,\u2026 ,m} such that\nA payment P is composition-irreducible if no such composition exists for P at any money distribution M.\nTheorem\u00a0 1 The next payments P with \u2016P\u2016 \u2264 2 are composition-irreducible:\n\u2022 Zero creation\u2014creates a unit with value 0, i.e. \u2016P\u2016 = 1 and \u2016P\u2016 = 0. \u2022 Zero deletion\u2014deletes a unit with value 0, i.e. \u2016P\u2016 = 1 and \u2016P\u2016 = 1. \u2022 Single unit transfer\u2014changes the bearer of one unit, i.e. \u2016P\u2016 = \u2016P\u2016 = 1. \u2022 Transfer with recreation\u2014deletes a unit u (with a nonzero value) and creates a new unit v with the same value, i.e. \u2016P\u2016 = 2 and \u2016P\u2016 = 1.\nP(M) = (Pm\u25e6\u22ef\u25e6P1)(M).\n\u2022 Two unit split\u2014creates a new unit v (with non-zero value) and changes the parameters of another unit u (reduces the value by (v) , and possibly, changes the bearer), i.e. \u2016P\u2016 = 2 and \u2016P\u2016 = 1. \u2022 Two unit join\u2014deletes a unit u (with non-zero value) and changes the parameters of another unit v (raises the value (v) by (u) , and possibly, changes the bearer (v) ), i.e. \u2016P\u2016 = \u2016P\u2016 = 2. \u2022 Two-unit swap\u2014changes the values and possibly bearers of two units u, v, i.e. \u2016P\u2016 = \u2016P\u2016 = 2.\nProof First, we categorize all payments P with \u2016P\u2016 = 1 . They are all composition-irreducible as the only payment with complexity 0 is the identity transformation 1. Let M \u2208 M be a money distribution such that M \u2260 P(M) , which exists due to Lemma\u00a03. There are three possibilities:\n\u2022 \u2016U\u2212 P \u2016 = 1 , \u2016U+ P \u2016 = \u2016U0 P \u2016 = 0 : This means that P just\ndeletes a unit u and does nothing else. As P preserves total money, the value of u must be zero. Hence, P is a zero-deletion.\n\u2022 \u2016U+ P \u2016 = 1 , \u2016U\u2212 P \u2016 = \u2016U0 P \u2016 = 0 : This means that P just\ncreates a unit u and does nothing else. As P preserves total money, the value of u must be zero. Hence, P is a zero-creation.\n\u2022 \u2016U0 P \u2016 = 1 , \u2016U+ P \u2016 = \u2016U\u2212 P \u2016 = 0 : This means that P does\nnot create/delete units but changes the parameters of a single unit u. As P preserves total money, it cannot change the value of u. Hence, P is a single-unit transfer.\nSecondly, we categorize all payments P with \u2016P\u2016 = 2 . There are the following possibilities:\n\u2022 \u2016U0 P \u2016 = 0 , \u2016U\u2212 P \u2016 = \u2016U+ P \u2016 = 1 : This means that P deletes\na unit u and creates another unit v. As P preserves total money, u and v have the same value. The value must be non-zero, because otherwise P acts on M as a composition of a zero-deletion and a zero-creation. Hence, P is a transfer with recreation. Obviously, P is compositionirreducible, because the creation and deletion operations are not payments.\n\u2022 \u2016U\u2212 P \u2016 = 0 , \u2016U+ P \u2016 = \u2016U0 P \u2016 = 1 : This means that P creates\na unit and changes the parameters of another unit. The created unit must have non-zero value, because otherwise P acts on M as a composition of a zero creation and a single unit transfer. Hence, P is a two unit split and is composition-irreducible because the creation of a unit and changing the value of a unit are not payments.\n\u2022 \u2016U+ P \u2016 = 0 , \u2016U\u2212 P \u2016 = \u2016U0 P \u2016 = 1 : This means that P deletes\na unit and changes the parameters of another unit. The deleted unit must have non-zero value, because otherwise\nSN Computer Science\nP acts as a composition of a zero deletion and a single unit transfer. Hence, P is a two unit join.\n\u2022 \u2016U0 P \u2016 = 2 , \u2016U\u2212 P \u2016 = \u2016U+ P \u2016 = 0 : This means that P changes\nthe parameters of two units. We have two sub-cases:\n\u2013 If P changes the values of the units, then P is a two-unit swap. \u2013 If P does not change the values of the units but only their bearers, then P acts on M as a composition of two single-unit transfers and is not compositionirreducible.\n\u2022 \u2016U\u2212 P \u2016 = 2 , \u2016U0 P \u2016 = \u2016U+ P \u2016 = 0 : This means that P deletes\ntwo units and does nothing else. In this case, P acts on M as a composition of two zero-deletions and is not composition-irreducible.\n\u2022 \u2016U+ P \u2016 = 2 , \u2016U0 P \u2016 = \u2016U\u2212 P \u2016 = 0 : This means that P creates\ntwo units and does nothing else. In this case, P acts on M as a composition of two zero-creations and is not composition-irreducible.\n\u25fb Corollary 2 Every payment P with \u2016Pi\u2016 \u2264 2 acts on any money distribution M either as 1, a composition-irreducible payment, or a composition P2\u25e6P1 of two composition-irreducible payments P1,P2 with \u2016P1\u2016 = \u2016P2\u2016 = 1.\nWe will show next that every payment P acts on every money distribution M as a non-redundant at M composition of payments Pi with \u2016Pi\u2016 \u2264 2 , and hence, these seven payment types listed by Theorem\u00a01 are the only existing composition-irreducible payments.\nDefinition 8 (Value-invariant compositions) A finite composition P of payments is value-invariant at a money distribution M if when applied to M it does not create or delete units u with the value \ud835\udf08(u) > 0 , neither it changes the value of any unit.\nIt is easy to see that for every composition of payments P that is value-invariant at M, there are payments P1,\u2026 ,Pm all being either zero-creations, zero-deletions, or single-unit transfers, such that P(M) = (Pm\u25e6\u22ef\u25e6P1)(M) is a composition that is non-redundant at M.\nTheorem\u00a03 For every finite composition P of payments and for every money distribution M such that M \u2260 P(M) there exists a composition Pm\u25e6\u22ef\u25e6P1 of payments Pi with \u2016Pi\u2016 \u2264 2 that is non-redundant at M such that P(M) = (Pm\u25e6\u22ef\u25e6P1)(M).\nProof Let P be any composition of payments and M be a money distribution such that M \u2260 P(M) . We use induction\non the number n of units the value of which is changed by P. If n = 0 , then P is value-invariant at M and the statement of the theorem follows from the observation that P is a nonredundant composition of zero-creations, zero-deletions, and single-unit transfers, and the descriptional complexity of all these three types of payments is 1.\nAssume that n > 0 and the statement of the theorem holds for smaller values of n. Hence, P is not value-invariant at M, and u is a unit the value of which is changed by the amount d > 0 . We also take into account the cases where u is created or deleted by P. We choose u in a way that d is minimal. Because of the money invariant and the minimality of d, there must be a unit v the value of which is changed (by P) by the amount of d\u2032 \u2265 d but to the opposite direction compared to u.\nLet P1 be a payment that only changes the values of u and v by d and to the same direction as P. For example, if P creates u and reduces the value of v by d\u2032 , then P1 also creates u but reduces the value of v only by d. The descriptional complexity of P1 is \u2016P1\u2016 \u2264 2 . Note also that the composition P\u25e6P\u22121\n1 of payments changes the value of a less number\nof units in M\ufffd = P1(M) compared to how many values P changes on M as P\u25e6P\u22121\n1 does not change the value of u. If\nP1(M) = (P\u25e6P \u22121 1 )(P1(M)) , then\nand the statement holds. If P1(M) \u2260 (P\u25e6P\u221211 )(P1(M)) then we can apply the induction step, i.e. there is a non-redundant (at P1(M) ) composition Pm\u25e6\u22ef\u25e6P2 of payments with descriptional complexity \u2016Pi\u2016 \u2264 2 , such that\nand as M \u2260 P1(M) , the composition Pm\u25e6\u22ef\u25e6P1 is nonredundant at M. \u25fb\nCorollary 4 For every payment P and for every M \u2208 M there exist composition-irreducible payments P1,\u2026 ,Pm such that\nProof Direct implication from Theorem\u00a01, Corollary\u00a02, and Theorem\u00a03. \u25fb"
        },
        {
            "heading": "Implementations of\u00a0Money Schemes",
            "text": "Money schemes are special cases of transition systems. Every transition system is a pair (S,\u00a0T), where S is the set of states and T is a set of state transitions (functions of type S \u2192 S ) that contains the identity transition 1S (sometimes denoted simply by 1) defined by 1S(s) = s for every s \u2208 S . Transition systems are equivalent to state machines and\nP(M) = (P\u25e6P\u22121 1 \u25e6P1)(M) = (P\u25e6P \u22121 1 )(P1(M)) = P1(M),\n(Pm\u25e6\u22ef\u25e6P2)(P1(M)) = (Pm\u25e6\u22ef\u25e6P1)(M)\nP(M) = (Pm\u25e6\u22ef\u25e6P1)(M).\nSN Computer Science\nin this paper we refer to them simply as machines. This is motivated by modelling machine-implementations of money schemes. For any transition system (S,\u00a0T), we denote by T the set of all finite compositions t1\u25e6\u22ef\u25e6tm , where ti \u2208 T .\nDefinition 9 (Implementation) A transition system (S,\u00a0T) implements a money scheme (M,P) if (Fig.\u00a01):\n1. There is a surjective interpretation map \u2236 S \u2192 M , i.e. every state s of the machine is interpreted as a money distribution M = (s) (Fig.\u00a01, left). 2. For every payment P \u2208 P and every state s \u2208 S interpreted as a money distribution M \u2208 M (i.e. (s) = M ) there is a transition t \u2208 T such that the state s\ufffd = t(s) is interpreted as the money distribution P(M), i.e. (s\ufffd) = (t(s)) = P( (s)) = P(M) (Fig.\u00a01, right).\nA decomposition of a money scheme is an implementation of the money scheme with two machines, formally defined as follows:\nDefinition 10 (Decomposition) Transition systems (S1, T1), (S2, T2) decompose a money scheme (M,P) if (Fig.\u00a02):\n1. There i s a sur jec t ive in ter preta t ion map \u2236 S1 \u00d7 S2 \u2192 M , i . e . ever y pai r of s t a tes s1 \u2208 S1, s2 \u2208 S2 of the machines is interpreted as a money distribution M = (s1, s2) (Fig.\u00a02, left). 2. For every P \u2208 P and every pair of states s1 \u2208 S1, s2 \u2208 S2 interpreted as a money distribution (s1, s2) = M \u2208 M\nthere exist t1 \u2208 T1, t2 \u2208 T2 such that the pair of states s\ufffd 1 = t1(s1), s \ufffd 2 = t2(s2) is interpreted as the money distribution P(M), i.e. (Fig.\u00a02, right)\nDecomposition of a money scheme can also be defined as an implementation of the money scheme by the direct product of the machines (S1, T1), (S2, T2) , which is defined as a machine (S,\u00a0T), where S = S1 \u00d7 S2 and T = T1 \u00d7 T2 and for every t = (t1, t2) \u2208 T1 \u00d7 T2 and s = (s1, s2) the new state s\ufffd = t(s) is defined by t(s) = (t1(s1), t2(s2)).\nFrom a more general viewpoint, all transition systems with identity transformations (machines) are objects of a category, in which the morphisms are defined as partial implementations (Definition\u00a011).\nDefinition 11 (Partial implementation) A partial implementation of a machine M2 = (S2, T2) by a machine M1 = (S1, T1) is a function f \u2236 S1 \u2192 S2 such that for every s1 \u2208 S1 and every t2 \u2208 T2 , there is t1 \u2208 T1 such that f (t1(s1)) = t2(f (s1)).\nAs the identity map 1S \u2236 S \u2192 S is a partial implementation of M = (S, T) by itself and the composition of two partial implementations is a partial implementation, we have a category structure. One can also show that the epimorphisms of this category are exactly the surjective partial implementations and the monomorphisms are exactly the injective partial implementations. The implementations in terms of Definition\u00a09 (i.e. the interpretation maps ) are exactly the epimorphisms from machines to money\n(s\ufffd 1 , s\ufffd 2 ) = (t1(s1), t2(s2)) = P( (s1, s2)) = P(M).\nFig. 1 Implementation of a money scheme by a transition system (machine)\nSN Computer Science\nschemes. However, the direct product of two machines is not always a product in terms of the category (see Appendix\u00a0B for details).\nBlockchain Implementations\nBy an evolution of a transition system (S,\u00a0T) is a sequence\nwhere s0 \u2208 S is the initial state, t1, t2,\u2026 , tm \u2208 T are transitions, and \ud835\udf0f0 < \ud835\udf0f1 < \ud835\udf0f2 < \u22ef < \ud835\udf0fm are real numbers interpreted as timestamps. The final state s\u2032 of the evolution is defined by s\ufffd = tm(tm\u22121(\u2026 t1(s0)\u2026)) . Intuitively, evolution is a description of the execution of the transition system in time.\nFor security-critical transition systems such as money schemes it is vital to store the evolution and protect its integrity with cryptography. Therefore, certificates C0,C1,C2,\u2026 ,Cm to the evolution, so that the certified evolution\ncannot be maliciously modified without making it cryptographically inconsistent. The certificates also prove the uniqueness of the certified evolution, i.e. it must convince the verifiers that there exist no alternative versions of the evolution.\nWhat is also important for the verifiers is whether they see the whole evolution that includes all transition that have been executed so far, i.e. if verification happens at time , then also the fact that no transitions happened in between m and . This suggests a certification scheme, where transitions of the evolution are certified in batches (blocks) in a pre-determined time schedule and the certified evolution being in the form:\n(s0, 0;(t1, 1), (t2, 2),\u2026 , (tm, m)),\n(s0, 0,C0; (t1, 1,C1), (t2, 2,C2),\u2026 , (tm, m,Cm))\nwhere every block Bi represents a composition t1i \u25e6\u22ef\u25e6t mi i of transitions. Note that some blocks Bi may be empty and in this case, they represent the identity transition 1S . Certified data structures in the form of (1) are called blockchains.\nBlockchain implementation of a transition system (S,\u00a0T) is a network of machines called a blockchain node that consists of three machines (Fig.\u00a03):\n\u2022 File repository\u2014stores certified blocks and, on request, provides applications with blockchain data. \u2022 Certifier\u2014regularly (based on clock) creates block certificates based on a cryptographic hash of the block. \u2022 Transaction validator\u2014receives transition orders from applications, verifies them using the current state s \u2208 S , combines transactions to blocks, obtains certificates from the certifier, and sends certified blocks to the file repository.\nA blockchain implementation of a composed money scheme with two transition systems (S1, T1) and (S2, T2) is a network of machines called a sharded blockchain node (Fig.\u00a04). It has two independent transaction validators that implement (S1, T1) and (S2, T2) and produce sub-blocks B1 and B2 , respectively. It also has two file repositories, and a common certifier for both blocks. The blockchain produced by the first transaction validator is in the form:\nwhere \u03a01 i denotes additional information (usually in the form of a hash chain) that helps to verify the blockchain against the certificate Ci . Analogously, the blockchain produced by the second transaction validator is in the form:\n(1)(s0, 0,C0;(B1, 1,C1), (B2, 2,C2),\u2026 , (Bm, m,Cm))\n(s1 0 , 0,\u03a0 1 0 ,C0;(B 1 1 , 1,\u03a0 1 1 ,C1), (B 1 2 , 2,\u03a0 1 2 ,C2),\u2026 , (B 1 m , m,\u03a0 1 m ,Cm)),\nSN Computer Science\nFor executing a payment P, two transaction orders t1, t2 has to be sent to the two transaction validators (Fig.\u00a04) and the validators include these transactions to the blocks B1 and B2 , respectively."
        },
        {
            "heading": "Atomic Decomposition of\u00a0Money Schemes",
            "text": "As the blocks have to be produced based on a fixed time schedule, there is a limited time for the validators to decide whether to include t1 and t2 to the blocks B1 and B2 . Considering possible message loss and network delays between the transaction validators and applications, it is always possible that only one of the transactions t1, t2 is received in time (considering the block creation schedule).\nIt is known that there exist no deterministic time protocols (executed between transaction validators) which ensure that either t1 \u2208 B1 and t2 \u2208 B2 , or t1 \u2209 B1 and t2 \u2209 B\n2 . Such a communication problem is often called the two generals problem. Therefore, it is possible that t1 \u2208 B\n1 but t2 \u2209 B2 and vice versa. In transition system terms, instead of executing (t1, t2) , either (t1, 1) or (1, t2) is executed in the implementing machines.\nIf (S1, T1), (S2, T2) represent a decomposition of a money scheme (M,P) and such errors cannot in principle be avoided, we can only ask how the partial transactions (t1, 1), (1, t2) are interpreted in the money scheme as changes of the money distribution. Do they preserve total money? Are they payments? If yes, are they in P ? If the current states are s1 \u2208 S1 and s2 \u2208 S2 and money distribution is M = (s1, s2) , then P(M) = (t1(s1), t2(s2)) . The money distribution after applying the erroneous pair (t1, 1) is M1 = (t1(s1), s2) and after applying (1, t2) , the resulting money distribution is M2 = (s1, t2(s2)).\nThe following definition of atomic decomposition (Definition\u00a012, item\u00a01) requires that there are at least payments P1,P2 \u2208 P such that P1(M) = M1 and P2(M) = M2 . In practical implementations, one may require some more. For example, that P1,P2 represent partial payments, i.e. if a bearer b pays or receives money via P, then the same happens via P1 and P2 but possibly, the received/paid amount is smaller. We also require that independently acting on (S1, T1), (S2, T2) with any pair of t1 \u2208 T1 , t2 \u2208 T2 is always interpreted as a payment. Item\u00a02 and item\u00a03 of Definition\u00a012 require that if we apply a transition t in just one component and this is interpreted as change the money distribution, then t also will change the money distribution independent of the state of the other component.\n(s2 0 , 0,\u03a0 2 0 ,C0;(B 2 1 , 1,\u03a0 2 1 ,C1), (B 2 2 , 2,\u03a0 2 2 ,C2),\u2026 , (B 2 m , m,\u03a0 2 m ,Cm)).\nDefinition 12 (Atomic decomposition) Transition systems (S1, T1), (S2, T2) together with the interpretation map represent an atomic decomposition of a money scheme (M,P) iff for every s1 \u2208 S1 , s2 \u2208 S2 , M = (s1, s2) , and t1 \u2208 T1 , t2 \u2208 T2 , there exists P \u2208 P , such that P(M) = (t1(s1), t2(s2)) , and for every such P, there exist P1,P2 \u2208 P so that:\n1. P1(M) = (t1(s1), s2) and P2(M) = (s1, t2(s2)). 2. If P\ufffd\n1 \u2208 P and M \u2260 P\ufffd 1 (M) = (t1(s1), s2) , then for every\ns\ufffd\ufffd 2 \u2208 S2 :\n3. If P\ufffd 2 \u2208 P and M \u2260 P\ufffd 2 (M) = (s1, t2(s2)) , then for every\ns\ufffd\ufffd 1 \u2208 S1 :\nIf a money scheme (M,P) is decomposed by transition systems (S1, T1), (S2, T2) and an interpretation map \u2236 S1 \u00d7 S2 \u2192 M , then in general, (S1, T1) and (S2, T2) do not necessarily represent money schemes. However, if such a decomposition is atomic, we can show that in some sense this is the case. We will show that it is possible to define two functions 1 \u2236 S1 \u00d7B \u2192 \u2115 and 2 \u2236 S2 \u00d7B \u2192 \u2115 so that given a bearer b \u2208 B and states s1 \u2208 S1 , s2 \u2208 S2 , the values 1(s1, b) and 2(s2, b) will show how much money b has in S1 and S2 , respectively. We also show that for M = (s1, s2)\ni.e. the total money b owns in the money scheme is the sum of money b holds in s1 and the money b holds in s2 . Moreover, we show that the values 1(s1) = \u2211 b\u2208B 1(s1, b) and\n1(s2) = \u2211\nb\u2208B 2(s2, b) are invariant under the payments of the money scheme and (M) = 1(s1) + 2(s2) . This implies, that in an atomically decomposed money scheme there is no transfer of value from one component to another.\nWe define the money 1(s1, b) the bearer b owns in the first system as the largest amount of money b can pay using a sequence of transitions of type (t1, 1) , and analogously, the money 2(s2, b) the bearer b has in the second system as the largest amount of money b can pay using a sequence of transitions of type (1, t2).\nDefinition 13 (Functions 1 , 2 ) For any states s1 \u2208 S1 , s2 \u2208 S2 , and a bearer b \u2208 B:\n\u2022 1(s1, b) is the largest number n1 \u2208 \u2115 such that there is t1 \u2208 T1 such that ( (s1, s2), b) \u2212 ( (t1(s1), s2), b) = n1.\n(s1, s \ufffd\ufffd 2 ) \u2260 P\ufffd 1 ( (s1, s \ufffd\ufffd 2 )) = (t1(s1), s \ufffd\ufffd 2 ).\n(s\ufffd\ufffd 1 , s2) \u2260 P \ufffd 2 ( (s\ufffd\ufffd 1 , s2)) = (s \ufffd\ufffd 1 , t2(s2)).\n(M, b) = 1(s1, b) + 2(s2, b),\nSN Computer Science\n\u2022 2(s2, b) is the largest number n2 \u2208 \u2115 such that there is t2 \u2208 T2 such that ( (s1, s2), b) \u2212 ( (s1, t2(s2)), b) = n2.\n\u2022 1(s1) is the sum \u2211\nb\u2208B 1(s1, b). \u2022 2(s2) is the sum \u2211 b\u2208B 2(s2, b).\nLemma 5 The value of 1(s1, b) does not depend on s2 neither 2(s2, b) on s1.\nProof If 1(s1, b) = 0 for every state s2 , then the statement is trivially true. Let t1 = tm1 \u25e6\u22ef\u25e6t 1 1 \u2208 T1 and s2 be a state such that\nLet s0 1 , s1 1 ,\u2026 , sm 1 \u2208 S1 be a sequence of states such that s0 1 = s1 and si1 = t i 1 (si\u22121 1 ) for every i \u2208 {1,\u2026 ,m} . Hence, by applying telescoping to (2):\nWe can assume without loss of generality that (ti\n1 (si\u22121 1 ), s2) \u2260 (s i\u22121 1 , s2) , because otherwise we can just omit such ti\n1 from t1 . Let Mi\u22121 = (si\u221211 , s2) . By atomicity\n(Definition\u00a0 12, item\u00a0 1), there exists Pi 1 \u2208 P such that Mi\u22121 \u2260 P i 1 (Mi\u22121) = (t i 1 (si\u22121 1 ), s2) , a n d t h e r e f o r e ,\n( (si\u22121 1 , s2), b) \u2212 ( (t i 1 (si\u22121 1 ), s2), b) = \u0394Pi 1 (Mi\u22121, b) . Let\ns\ufffd 2 \u2208 S2 be any state and let M\ufffdi\u22121 = (s i\u22121 1 , s\ufffd 2 ) . By atomicity (Definition\u00a012, item\u00a02), M\ufffd i\u22121 \u2260 Pi 1 (M\ufffd i\u22121 ) = (ti 1 (si\u22121 1 ), s\ufffd 2 ) and hence, by the uniformity of amount (Lemma\u00a0 4), \u0394\nP i\n1\n(M i\u22121, b) = \u0394Pi\n1\n(M\ufffd i\u22121 , b) = ( (si\u22121 1 , s\ufffd 2 ), b)\u2212\n( (ti 1 (si\u22121 1 ), s\ufffd 2 ), b) . Therefore:\nThe proof for 2(s2, b) is similar, by using atomicity (Definition\u00a012, item\u00a03). \u25fb\nTheorem\u00a0 5 If (S1, T1) and (S2, T2) with interpretation map atomically decompose a money scheme (M,P) with the bearer set B , then for every s1 \u2208 S1, s2 \u2208 S2 , M = (s1, s2) \u2208 M and b \u2208 B:\nProof Due to the accessibility of money (Definition\u00a05), there is P = Pm\u25e6\u22ef\u25e6P1 \u2208 P such that (P(M), b) = 0 . Let M0,M1,\u2026 ,Mm \u2208 M be a sequence of money distributions such that M0 = M , and Mi = Pi(Mi\u22121) for every i \u2208 {1,\u2026 ,m} . Let s0\n1 , s1 1 ,\u2026 , sm 1 \u2208 S1 and s02, s 1 2 ,\u2026 , sm 2 \u2208 S2\nbe sequences of states such that Mi = (si1, s i 2 ) for every\n(2) 1(s1, b) = ( (s1, s2), b) \u2212 ( (t1(s1), s2), b) \u2260 0\n1(s1, b) =\nm\u2211\ni=1\n( ( (si\u22121 1 , s2), b) \u2212 ( (t i 1 (si\u22121 1 ), s2), b)).\n1(s1, b) =\nm\u2211\ni=1\n( ( (si\u22121 1 , s\ufffd 2 ), b) \u2212 ( (ti 1 (si\u22121 1 ), s\ufffd 2 ), b))\n= ( (s1, s \ufffd 2 ), b) \u2212 ( (t1(s1), s \ufffd 2 ), b).\n(M, b) = 1(s1, b) + 2(s2, b).\ni \u2208 {1,\u2026 ,m} . Due to decomposition, there exist ti 1 \u2208 T1 and ti 2 \u2208 T2 such that si1 = t i 1 (si\u22121 2 ) and si 2 = ti 2 (si\u22121 2 ) . Let t1 = t m 1 \u25e6\u2026 \u25e6t1 1 \u2208 T1 and t2 = tm2 \u25e6\u2026 \u25e6t 1 2 \u2208 T2 . Therefore, P(M) = P( (s1, s2)) = (t1(s1), t2(s2)) . Hence, by Lemma\u00a05:\nTo prove the dual inequality, choose t1 = t m1 1 \u25e6\u2026 \u25e6t1 1 \u2208 T1 and t2 = t m2 2 \u25e6\u2026 \u25e6t1 2 \u2208 T2 so that\nwhere in the second equation, we use Lemma\u00a0 5. Let s0 1 , s1 1 ,\u2026 , s m1 1\n\u2208 S1 be a sequence of states such that s0 1 = s1 and si1 = t i 1 (si\u22121 1 ) , for every i \u2208 {1,\u2026 ,m1} ; and let s0 2 , s1 2 ,\u2026 , s m2 2\n\u2208 S2 be a sequence of states such that s02 = s2 and sj\n2 = t\nj 2 (s j\u22121 2 ) , for every j \u2208 {1,\u2026 ,m2} . Due to ato-\nmicity (Definition\u00a012, item\u00a01), for every i \u2208 {1,\u2026 ,m1} , there exists Pi\n1 \u2208 P such that Pi 1 ( (si\u22121 1 , s2)) = (s i 1 , s2) ;\nand for every j \u2208 {1,\u2026 ,m2} , there exists P j 2 \u2208 P such t ha t Pj 2 ( (t1(s1), s j\u22121 2 )) = (t1(s1), s j 2 ) . Hence , P = Pm2\u25e6\u2026 \u25e6P1 2 \u25e6P m1 1 \u25e6\u2026 \u25e6P1 1 \u2208 P s a t i s f i e s P(M) = P( (s1, s2)) = (t1(s1), t2(s2)) . Therefore:\n\u25fb\nTheorem\u00a06 If (S1, T1) , (S2, T2) with interpretation map atomically decompose a money scheme (M,P) with the bearer set B , then (M) = 1(s1) + 2(s2) for M = (s1, s2) , and 1(s1) and 1(s2) are invariant under any P \u2208 P.\nProof The first claim directly follows from Theorem\u00a05:\nLet s1 \u2208 S1 , s2 \u2208 S2 , t1 \u2208 T1 and t2 \u2208 T2 . By atomicity (Definition\u00a012, item\u00a01), there exists P1 \u2208 P such that P1(M) = (t1(s1), s2) . Hence,\n(M, b) = (M, b) \u2212 (P(M), b)\n= ( (s1, s2), b) \u2212 ( (t1(s1), t2(s2)), b)\n= ( (s1, s2), b) \u2212 ( (t1(s1), s2), b)+\n+ ( (t1(s1), s2), b) \u2212 ( (t1(s1), t2(s2)), b)\n\u2264 1(s1, b) + 2(s2, b).\n1(s1, t) = ( (s1, s2), b) \u2212 ( (t1(s1), s2), b)\n2(s2, t) = ( (t1(s1), s2), b) \u2212 ( (t1(s1), t2(s2)), b),\n1(s1, b) + 2(s2, b) = ( (s1, s2), b) \u2212 ( (t1(s1), t2(s2)), b)\n= (M, b) \u2212 (P(M), b) = \u0394P(M, b)\n\u2264 (M, b).\n(3)\n(M) = \u2211\nb\u2208B\n(M, b) = \u2211\nb\u2208B\n( 1(s1, b) + 2(s2, b))\n= \u2211\nb\u2208B\n1(s1, b) + \u2211\nb\u2208B\n2(s2, b).\n(4) (P1(M)) = \u2211\nb\u2208B\n1(t1(s1), b) + \u2211\nb\u2208B\n2(s2, b)\nSN Computer Science\nand as (P1(M)) = (M) , we conclude by combining (3) and (4) that\nIf P \u2208 P is any payment, then by atomicity (Definition\u00a0 12), there exist t1 \u2208 T1 and t2 \u2208 T2 such that P(M) = (t1(s1), t2(s2)) . Hence, in the pair (t1(s1), t2(s2)) of states interpreted as P(M), the value of 1 is 1(t1(s1)) = \u2211 b\u2208B 1(t1(s1), b) = \u2211 b\u2208B 1(s1, b) = 1(s1) . The invariance of 2(s2) is proved analogously. \u25fb\nFor example, Theorem\u00a0 6 implies that there exist no atomic decompositions of the full account scheme that allows payments between any two accounts such that (S1, T1) handles one subset of accounts and (S2, T2) handles other accounts, because there is no possibility to pay from an account handled by (S1, T1) to an account handled by (S2, T2) . Otherwise, the values 1(s1) and 2(s2) would change. In \u201cUnitwise Decompositions of Money Schemes\u201d, we take a more general approach to such unitwise decompositions of any money scheme."
        },
        {
            "heading": "Unitwise Decompositions of\u00a0Money Schemes",
            "text": "In this section, we study a special type of decompositions of money schemes, where the unit set is divided into two subsets that are handled by two separate machines. In \u201cNotations and definition, we give a formal definition for such decompositions, derive some theoretical results in \u201cTheoretical results about unitwise decompositions\u201d, and draw some conclusions in \u201cTheoretical results about unitwise decompositions\u201d."
        },
        {
            "heading": "Notations and\u00a0Definition",
            "text": "Let the universe U of potential units be split into two nonintersecting subsets U1 and U2 . We assume that U1 , U2 are infinite. For a money distribution M = (U, , ) let M|U1 and M|U2 be money distributions such that:\nwhere by |U1 is the restriction of to U1 , i.e. a function |U1 \u2236 U \u2229U1 \u2192 \u2115 so that |U1 (u) = (u) for every u \u2208 U \u2229U1 . For any money distributions M1 = {U1, 1, 1} with U1 \u2282 U1 and M2 = {U2, 2, 2} with U2 \u2282 U2 we define a money distribution M1 \u2295M2 as follows:\n(5) \u2211 b\u2208B 1(t1(s1), b) = \u2211 b\u2208B 1(s1, b).\nM|U1 = (U \u2229U1, |U1 , |U1 ) M|U2 = (U \u2229U2, |U2 , |U2 ),\nM1 \u2295M2 = (U1 \u222a U2, \ud835\udf081 \u222a \ud835\udf082, \ud835\udefd1 \u222a \ud835\udefd2),\nwhere = 1 \u222a 2 is a function such that (u) = 1(u) if u \u2208 U1 and (u) = 2(u) otherwise. The function = 1 \u222a 2 is defined similarly. Note that\nfor any money distributions M,M1,M2 . For any set M of money distributions, we define subsets M|U1 and M|U2 as follows:\nFor every money transformation P on M , we define money transformations P|U1 on M|U1 and P|U2 on M|U2 as follows:\n\u2022 P|U1 acts on the units of U1 in the same way as P, except that it does nothing with the units of U2. \u2022 P|U2 acts on the units of U2 in the same way as P, except that it does nothing with the units of U1.\nIt is easy to see that for every money distribution M and for every money transformation P such that M \u2260 P(M):\nNote that P = P|U1 \u2295 P|U2 for every money transformation P.\nDefinition 14 If transition systems (S1, T1), (S2, T2) with interpretation map decompose a money scheme (M,P) , then we say that such a decomposition is unitwise decomposition relative to U1 and U2 if\n\u2022 Every s1 = (U1, 1, 1) \u2208 S1 is a money distribution, where U1 \u2282 U1 and every t1 \u2208 T1 is a money transformation on S1. \u2022 Every s2 = (U2, 2, 2) \u2208 S2 is a money distribution, where U2 \u2282 U2 and every t2 \u2208 T2 is a money transformation on S2. \u2022 \ud835\udf0b(s1, s2) = s1 \u2295 s1 = (U1 \u222a U2, \ud835\udf081 \u222a \ud835\udf082, \ud835\udefd1 \u222a \ud835\udefd2) for every s1 = (U1, 1, 1) \u2208 S1 and s2 = (U2, 2, 2) \u2208 S2 . The map is surjective because of (6)."
        },
        {
            "heading": "Theoretical Results about\u00a0Unitwise Decompositions",
            "text": "First, it turns out (Theorem\u00a07) that every money scheme has a canonical unitwise decomposition relative to any U1,U2 . We call such a decomposition the natural decomposition. Therefore, the existence of decompositions tells nothing special about a money scheme. A more interesting question is\n(6)M = M|U1 \u2295 M|U2\n(7)M1 = (M1 \u2295M2)|U1 , M2 = (M1 \u2295M2)|U2\nM|U1 ={M|U1 \u2236 M \u2208 M} M|U2 ={M|U2 \u2236 M \u2208 M}\n(8)P(M) = P|U1(M|U1)\u2295 P|U2 (M|U2)\nSN Computer Science\nwhen the natural decomposition is atomic in terms of Definition\u00a012. Theorem\u00a08 gives necessary and sufficient conditions for that in terms of the structure of the money scheme.\nSometimes in practical implementations it might be sufficient that a money scheme (M,P) is just a sub-scheme of a money scheme (M,P\ufffd) the natural decomposition of which is atomic. Theorem\u00a09 gives necessary and sufficient conditions for that in terms of the algebraic structure of the payments P \u2208 P\u2014their representations via compositionirreducible payments.\nTheorem\u00a07 For every money scheme (M,P) , there exists a unitwise decomposition (called the natural decomposition) relative to U1 and U2.\nProof Let S1 = M|U1 , S2 = M|U2 , T1 = {P|U1 \u2236 P \u2208 P} , T2 = {P|U2 \u2236 P \u2208 P} , and be defined as in Definition\u00a014. Note that if P \u2208 P , then P|U1 and P|U2 are money transformations, but not necessarily payments. This is indeed a decomposition in terms of Definition\u00a010, because:\n1. If s1 = M|U1 \u2208 S1 and s2 = M \ufffd|U2 \u2208 S2 with M,M \ufffd \u2208 M , then \ud835\udf0b(s1, s2) = s1 \u2295 s2 is a money distribution, and hence, item 1 of Definition\u00a010 is satisfied. 2. Let P \u2208 P , s1 = (U1, 1, 1) \u2208 S1 , s2 = (U2, 2, 2) \u2208 S2 , and M = (s1, s2) . If M \u2260 P(M) , then let t1 = P|U1 and t2 = P|U2 . Therefore, by applying (8) and (7):\nIf M = P(M) , then for t1 = t2 = 1 :\nand hence, item 2 of Definition\u00a010 is satisfied. \u25fb Theorem\u00a08 The natural decomposition of a money scheme (M,P) relative to U1 and U2 is atomic, if and only if P\ufffd|U1 \u2295 P \ufffd\ufffd|U2 \u2208 P for every P \ufffd,P\ufffd\ufffd \u2208 P.\nProof First, we show the if-part, i.e. assume that P\ufffd|U1 \u2295 P \ufffd\ufffd|U2 \u2208 P for every P \ufffd,P\ufffd\ufffd \u2208 P , and prove that the natural decomposition is atomic in terms of Definition\u00a012.\n\u2022 Let s1 = M\ufffd|U1 \u2208 S1 = M|U1 , s2 = M \ufffd\ufffd|U2 \u2208 S2 = M|U2\nwith M\ufffd,M\ufffd\ufffd \u2208 M , be any states, M = \ud835\udf0b(s1, s2) = s1 \u2295 s2 , and t1 = P\ufffd|U1 \u2208 T1 , t2 = P\n\ufffd\ufffd|U2 \u2208 T2 be any transitions. Then P = P\ufffd|U1 \u2295 P \ufffd\ufffd|U2 \u2208 P.\n\u2013 If M \u2260 P(M) , then:\nP(M) =P|U1 (M|U1)\u2295 P|U2 (M|U2) =P|U1 ((s1 \u2295 s2)|U1)\u2295 P|U2 ((s1 \u2295 s2)|U2 ) =\ud835\udf0b(t1(s1), t2(s2))\nP(M) = M = (s1, s2) = (t1(s1), t2(s2)),\n\u2013 If M = P(M) , then also t1(s1) = P\ufffd|U1 (M \ufffd|U1 ) =\nM \ufffd|U1 = s1 , and t2(s2) = P \ufffd\ufffd|U2 (M \ufffd\ufffd|U2 ) = M \ufffd\ufffd|U2 = s2 . Therefore\n\u2022 I f P \u2208 P i s a p a y m e n t s u c h t h a t P(M) = (t1(s1), t2(s2)) , t h e n by a s s u m p t i o n P1 = P \ufffd|U1 \u2295 1,P2 = 1\u2295 P \ufffd\ufffd|U2 \u2208 P.\n\u2013 If M \u2260 P1(M) , then:\n\u2013 If M = P1(M) , then also t1(s1) = P\ufffd|U1 (M \ufffd|U1 ) =\nM \ufffd|U1 = s1 , and hence, P1(M) = M = (s1, s2) = (t1(s1), s2).\n\u2013 If M \u2260 P2(M) , then:\n\u2013 I f M = P2(M) , t h e n a l s o t2(s2) = P \ufffd\ufffd|U2(M \ufffd\ufffd|U2 ) = M\n\ufffd\ufffd|U2 = s2 , and hence, P2(M) = M = (s1, s2) = (s1, t2(s2)).\nHence, the item\u00a01 of Definition\u00a012 holds. Let P\ufffd\n1 \u2208 P and M \u2260 P\ufffd 1 (M) = (t1(s1), s2) for a t1 = P|U1\nfor some P \u2208 P . Hence, P\ufffd 1 (M) = P|U1 (M|U1)\u2295M|U2 = (P|U1 \u2295 1)(M) = t1(s1)\u2295 1 . As t1 \u2295 1 = P|U1 \u2295 1 \u2208 P is also a money transformation, it implies by Lemma\u00a02 that P\ufffd 1 = t1 \u2295 1 . As for every s\ufffd\ufffd2 \u2208 S2 the money distribution M\ufffd = s1 \u2295 s \ufffd\ufffd 2 differs from M = s1 \u2295 s2 only by the elements outs ide UP\u2032 1 , i t fol lows from Lemma\u00a0 1 that M\ufffd \u2260 P\ufffd 1 (M\ufffd) = t1(s1)\u2295 s \ufffd\ufffd 2 . Hence, the item\u00a02 of Definition\u00a0 12 holds. The item 3 of Definition\u00a0 12 is proved similarly.\nTo prove the only if part, assume that the natural decomposition is atomic. Let P\ufffd,P\ufffd\ufffd \u2208 P . If P\ufffd|U1 \u2295 P\n\ufffd|U1 = 1 , then it is an element of P by definition (Definition\u00a05). If P\u2032|U1 \u2295 P\n\u2032|U1 \u2260 1 , and s1 \u2208 S1, s2 \u2208 S2 are states such that s1 \u2295 s2 \u2260 P\ufffd|U1 \u2295 P\n\ufffd\ufffd|U2(s1 \u2295 s2) , then by taking t1 = P \ufffd|U1 \u2208 T1 and t2 = P \ufffd\ufffd|U2 \u2208 T2 , it follows from the atomicity (Definition\u00a012) that there exists P \u2208 P such that P(s1 \u2295 s2) = t1(s1)\u2295 t2(s2) . Hence,\nP(M) =P|U1(M|U1 )\u2295 P|U2(M|U2) =P|U1 (M \ufffd|U1 )\u2295 P|U2 (M \ufffd\ufffd|U2)\n=\ud835\udf0b(t1(s1), t2(s2)).\nP(M) = M = (s1, s2) = (t1(s1), t2(s2)).\nP1(M) =P1|U1 (M|U1 )\u2295 P1|U2(M|U2) =\ud835\udf0b(P\ufffd|U1 (M \ufffd|U1 ),M \ufffd\ufffd|U2 )\n=\ud835\udf0b(t1(s1), s2)\nP2(M) =P2|U1 (M|U1 )\u2295 P2|U2(M|U2) =\ud835\udf0b(M\ufffd\ufffd|U1 ,P \ufffd\ufffd|U2 (M \ufffd\ufffd|U2 ))\n=\ud835\udf0b(s1, t2(s2))\nSN Computer Science\nwhich by Lemma\u00a02 implies P\ufffd|U1 \u2295 P \ufffd\ufffd|U2 = P \u2208 P .\n\u25fb\nDefinition 15 (Sub-decomposable money scheme) A money scheme (M,P) is sub-decomposable relative to U1 and U2 if P \u2286 P\u2032 for a money scheme (M,P\ufffd) the natural decomposition of which is atomic relative to U1 and U2.\nTheorem\u00a09 A money scheme (M,P) is sub-decomposable relative to U1 and U2 if and only if for every P \u2208 P and every M \u2208 M with M \u2260 P(M) there is a composition P1\u25e6\u22ef\u25e6Pm (non-redundant at M) of composition-irreducible payments Pi such that Pi|U1 ,Pi|U2 \u2208 {1,Pi} for every i \u2208 {1,\u2026 ,m} and P(M) = (P1\u25e6\u22ef\u25e6Pm)(M).\nProof Assume that for every P \u2208 P and M \u2208 M wi th M \u2260 P(M) there i s such a composi t ion P(M) = (P1\u25e6\u22ef\u25e6Pm)(M) . Note that for every i \u2208 {1,\u2026 ,m} , either\n\u2022 Pi|U1 = Pi and Pi|U2 = 1 , and these Pi are called payments of the first type, or \u2022 Pi|U2 = Pi and Pi|U1 = 1 , and these Pi are called payments of the second type.\nAs Pi\u25e6Pj = Pj\u25e6Pi for every Pi of the first type and Pj of the second type, we can assume without loss of generality that P1,\u2026 ,Pk are of first type and Pk+1,\u2026 ,Pm are of second type. It is easy to see that\nTherefore, P|U1 and P|U2 act on any M as compositions of payments and hence, preserve (M) . Moreover, as P is a money transformation, also P|U1 and P|U2 are money transformations, and as they preserve (M) they are payments.\nLet P U1,U2 \u2287 P be the set of all payments that have such compositions at every money distribution. We proved that, for every P \u2208 P\nU1,U2 , also P|U1 ,P|U2 \u2208 P U1,U2 Moreover,\nthe payments in the composition of P|U1 can be chosen to be of the first type, for P|U2 , of the second type.\nL e t P\ufffd,P\ufffd\ufffd \u2208 P U1,U2 , M \u2208 M s u c h t h a t M \u2260 (P\ufffd|U1 \u2295 P \ufffd\ufffd|U2 )(M) , and M \ufffd = P\ufffd|U1 (M) . As also P\ufffd|U1 ,P \ufffd\ufffd|U2 \u2208 P \ufffd , there are compositions\nP(s1 \u2295 s2) =P \ufffd|U1(s1)\u2295 P \ufffd\ufffd|U2 (s2) =(P\ufffd|U1 \u2295 P \ufffd\ufffd|U2 )(s1 \u2295 s2)\nP|U1 (M) = (P1\u25e6\u22ef\u25e6Pk)(M) P|U2 (M) = (Pk+1\u25e6\u22ef\u25e6Pm)(M)\nP\ufffd|U1 (M) = (Pk\u25e6\u22ef\u25e6P1)(M) P\ufffd\ufffd|U2(M \ufffd) = (Pm\u25e6\u22ef\u25e6Pk+1)(M \ufffd)."
        },
        {
            "heading": "As P\u2032|U1 and P",
            "text": "\u2032\u2032|U2 are payments, also P \u2032|U1 \u2295 P \u2032\u2032|U2 is a payment. Moreover\nand therefore P\ufffd|U1 \u2295 P \ufffd\ufffd|U2 \u2208 P U1,U2 . Hence, (M,P U1,U2 ) is a money scheme the natural decomposition of which is atomic by Theorem\u00a08.\nAssume now that there is a money scheme (M,P\ufffd) with P \u2286 P\n\u2032 the natural decomposition of which is atomic. Let P \u2208 P and M \u2260 P(M) for an M \u2208 M . From Theorem\u00a08 it follows that P|U1 = P|U1 \u2295 1 and P|U2 = 1\u2295 P|U2 are payments in P\u2032 , and also P(M) = (P|U1 \u2295 P|U2 )(M) = (P|U1\u25e6P|U2)(M) because of M \u2260 P(M) . Let\nbe any compositions of P|U1 on M \ufffd = (P|U2 )(M) and of P|U2 on M into composition-irreducible payments Pi j that exist due to Corollary\u00a04. It is easy to see that these compositions can be chosen in a way that Pi\n1 do nothing with the units of\nU2 and Pi2 do nothing with the units of U1 . Hence, Pi 1 |U1 = P i 1 and Pi 2 |U2 = P i 2 . Therefore, P(M) = (Pm1 1 \u25e6 \u22ef\u25e6P 1\n1 \u25e6P\nm2 2 \u25e6\u22ef\u25e6P 1 2 )(M) is a composition with the required\nproperties. \u25fb\nCorollary 10 Every money scheme is sub-decomposable relative to U1,U2 if and only if it is a sub-scheme of (M,P\nU1,U2 )."
        },
        {
            "heading": "Implications",
            "text": "If a composition-irreducible payment P is a zero-creation, a zero-deletion, or a single unit transfer, then P|U1 ,P|U2 \u2208 {1,P} , because these payments only involve a single unit.\nIn practical implementations of money schemes, transfers with recreation and two-unit splits can be organized in a way that the newly created units are always chosen in the same Ui , which guarantees that the condition P|U1 ,P|U2 \u2208 {1,P} holds.\nThe critical composition-irreducible payments for atomic decomposability are two-unit joins and two-unit swaps (the only composition-irreducible payments with input complexity \u2016P\u2016\n= 2 ), where the condition P|U1 ,P|U2 \u2208 {1,P} does\nnot hold if the two involved units are in different Ui . Therefore, the input complexity \u2016P\u2016 (and not \u2016P\u2016 ) is critical for unitwise atomic decomposability. Some implications:\n(P\ufffd|U1 \u2295 P \ufffd\ufffd|U2 )(M) = P \ufffd\ufffd|U2 (P \ufffd|U1(M)) = (Pm\u25e6\u22ef\u25e6P1)(M)\nP|U1 ((P|U2 )(M)) = (P m1 1 \u25e6\u22ef\u25e6P1 1 )((P|U2)(M))\nP|U2 (M) = (P m2 2 \u25e6\u22ef\u25e6P1 2 )(M)\nSN Computer Science\n\u2022 The complete account money scheme, where payments can be done between any two accounts are not subschemes of money schemes the natural decomposition of which is atomic, because the complete account scheme implements two-unit swaps that involve any pair u,\u00a0v of units. \u2022 The same is true for the complete UTXO money scheme, because it implements two-unit joins that involve any pair u,\u00a0v of UTXOs. \u2022 The bill money scheme itself has unitwise atomic decompositions, as single bill payments have complexity \u2016P\u2016 = 1.\nMoreover, the bill money scheme enables total unitwise atomic decomposability where every bill u is maintained in a separate machine and in the blockchain setting in a separate transaction validator that produces the blockchain (ledger) of the bill u in the form:\nwhere Bu i is either empty or contains a single payment Pu i , and \u03a0u i denotes additional information (usually in the form of a hash chain) that helps to verify the blockchain against the certificate Ci."
        },
        {
            "heading": "Security of\u00a0Blockchain Implementations",
            "text": "In the so called permissionless blockchain systems new blocks are verified by thousands of nodes and erroneous blocks in the certified blockchain can be considered as almost impossible. However, permissionless systems tend to be more costly to manage and to have larger CO2 traces compared to permissioned blockchain systems where the number of redundant nodes is much smaller.\nHence, it is probably more efficient to implement Central Bank Digital Currency (CBDC) as a permissioned blockchain system, where new blocks are verified by just a few nodes. However, in this case, due to potential insider threats, erroneous blocks in the blockchain should be considered a possibility.\nIn the blockchain node (Fig.\u00a03), the transaction validator together with the file repository are modelled as an adversarial entity that may deviate from ledger rules. Misbehavior of a node may be caused by internal attacks by malicious employees of system operators who may also be owners of money.\nThe practical goal of an attacker is to buy some goods by using falsified electronic cash, so that such a deception remains undetected for certain time sufficient for the attacker\n(su 0 , 0,\u03a0 u 0 ,C0;(B u 1 , 1,\u03a0 u 1 ,C1), (B u 2 , 2,\u03a0 u 2 ,C2),\u2026 , (B u m , m,\u03a0 u m ,Cm)),\nto escape. We assume covert adversaries [43, 44] that are considered successful only if their malicious behaviour remains undetected at least for some time. The Certifier (Fig.\u00a03) is guaranteed to create a unique block certificate Cn for every block number n. Adversary has no control over the Certifier that is assumed to be controlled by the central bank.\nWe assume that a bill payment scheme is used in the CBDC blockchain solution, where every bill u has a bill ledger. At every payment with u, an audit protocol is executed to verify that the bill is properly used, i.e. all the ledger rules are fulfilled. In the sequel, we study two types of audit protocols:\n1. Full audit\u2014guarantees that the ledger rules are followed. 2. Probabilistic audit\u2014guarantees that any deviation from ledger rules will be detected very soon with high probability."
        },
        {
            "heading": "Rules of\u00a0a\u00a0Bill Ledger",
            "text": "Let U be the set of all bills and 0 \u2236 U \u2192 B be a function that defines the initial owner 0(u) of every bill u \u2208 U . We assume that both U and 0 are verifiably certified by Central Bank and cannot be altered by other parties. Every payment order is in the form Pu = \u27e8 , b, , s\u27e9 , where is a unique identifier of u, b \u2208 B is the payee identifier, is a unique identifier of the payment order, and s is a signature of the payer. Every block Bu\nn of the bill ledger\nis either empty, or contains a payment order Pu n = \u27e8 , b, , s\u27e9 , where:\n1. = H( , 0(u)) and s is the signature of 0(u) if Pun is the first payment with u, where H \u2236 {0, 1}\u2217 \u2192 {0, 1}k is a cryptographic hash function. 2. = H(Pu n\ufffd ) and s is the signature of b\u2032 if Pu n\ufffd = \u27e8 , b\ufffd, \ufffd, s\ufffd\u27e9\nis the payment order contained in the last non-empty block Bu\nn\u2032 in the sequence Bu 1 ,\u2026 ,Bu n\u22121 .\nHence, the blocks Bu n\ufffd+1 ,Bu n\ufffd+2 ,\u2026 ,Bu n\u22122 ,Bu n\u22121 must be empty. The collision-resistance of H guarantees that is unique for every payment order.\nThe certificate Cn contains the block hash rn and there is a function FH that uses H as an oracle such that FH(u;Bu\nn ,\u03a0u n ) = rn , and If Ru \u2260 Ru and\nFH(u;Bu,\u03a0u) = FH(u;Bu,\u03a0u) , then the computations of FH contain either an H-collision, or an H-pre-image of 0k \u2013 a\n(su 0 , 0,\u03a0 u 0 ,C0;(B u 1 , 1,\u03a0 u 1 ,C1), (B u 2 , 2,\u03a0 u 2 ,C2),\u2026 , (B u m , m,\u03a0 u m ,Cm)),\nSN Computer Science\nbitstring X such that H(X) = 0k . Both are assumed to be infeasible to find for practical hash functions."
        },
        {
            "heading": "User Side Full Audit",
            "text": "The main idea behind the full audit is that every user who has received u with a payment Pu\nn\u2032 and later, at block\nn > n\u2032 , uses u in a payment Pu n , verifies that the blocks Bu n\ufffd+1 ,Bu n\ufffd+2 ,\u2026 ,Bu n\u22121 are empty (Fig.\u00a05)."
        },
        {
            "heading": "Full Audit Protocol",
            "text": "Assume that a user has a bill u paid to her with a payment order Pu\nn\u2032 at block n\u2032 , and that the user\u2019s wallet already con-\ntains the certificates C0,\u2026 ,Cn\ufffd that were already verified, the block Bu\nn\u2032 , and the proof \u03a0u n\ufffd which also has been verified.\nIn a block n > n\u2032 , the user creates a block Bu n with a new\npayment order Pu n = \u27e8 , b, , s\u27e9 , where = H(Pu n\ufffd ) and sends it to the transaction validator. User then executes the following full audit protocol:\n1. User requests Cn\ufffd+1,\u2026 ,Cn and \u03a0un\ufffd+1,\u2026 ,\u03a0 u n from the\nfile repository. 2. User verifies Cn\ufffd+1,\u2026 ,Cn. 3. User verifies \u03a0u\nn\ufffd+1 ,\u2026 ,\u03a0u n , assuming that Bu n\ufffd+1 ,\u2026 ,Bu n\u22121\nare empty, i.e. for every i \u2208 {n\ufffd + 1,\u2026 , n \u2212 1} the user extracts the block hashes xi from Ci and checks that FH(u;\ufffd,\u03a0u\ni ) = rn."
        },
        {
            "heading": "Security of\u00a0the\u00a0Full Audit",
            "text": "Ledger rules violation means inserting a block B u\ni = {Pu i }\nto the ledger, where Pu i does not properly follow Pu n\u2032 , e.g. is not signed by Pu n\u2032 .b . If the full audit at n also verifies, then FH(u;Bu i ,\u03a0u i ) = rn = F H(u;Bu i ,\u03a0u i ) and there is a collision for H or an X such that H(X) = 0k (Fig.\u00a06)."
        },
        {
            "heading": "Communication Complexity of\u00a0the\u00a0Full Audit",
            "text": "Let N be the total number of bills. The size of a proof is k \u22c5 log2 N bits. As we need n \u2212 n\ufffd proofs during the audit, the total number of bits communicated is (n \u2212 n\ufffd) \u22c5 k \u22c5 log2 N which may be impractical if n \u226b n\u2032 . Using the probabilistic audit enables to reduce the communication complexity. The idea is that we check a random d-element subset of Bu\nn\ufffd+1 ,Bu n\ufffd+2 ,\u2026 ,Bu n\u22121 . In the general case, with the bill ledger certification scheme that we described, such an audit is inefficient because the detection probability of one single illegal block is about d\nn\u2212n\ufffd which means that for a high\nthe number d of detected blocks must be close to n \u2212 n\ufffd . We show that proper ledger certification schemes enable to keep d small."
        },
        {
            "heading": "KSI\u2011Cash Bill Ledger",
            "text": "In this section, we describe the bill ledger certification scheme of the KSI-Cash CBDC solution [1] enables efficient probabilistic audit protocols with d being a fixed constant that only depends on the required detection probability and not on the length n \u2212 n\ufffd of the auditing interval."
        },
        {
            "heading": "Hash Chains",
            "text": "By a hash chain c we mean a (possibly empty) list \u27e8(b1, y1), (b2, y2),\u2026 , (b , y )\u27e9 , where bi \u2208 {0, 1} and yi \u2208 {0, 1}\nk for every i \u2208 {1,\u2026 , } . The bitstring b1b2 \u2026 b is called the shape of c. Every hash chain can be viewed as a function c \u2236 {0, 1}k \u2192 {0, 1}k defined as follows:\n1. \u27e8\u27e9(x) = x for every x \u2208 {0, 1}k , where \u27e8\u27e9 is the empty list 2. \u27e8c\u2016(b, y)\u27e9(x) = \ufffd H(c(x), y) if b = 0\nH(y, c(x)) if b = 1 , where \u27e8c\u2016(b, y)\u27e9\ndenotes the list obtained from c by adding (b,\u00a0y) as the last element.\nSN Computer Science\nThe Idea of\u00a0Probabilistic Audit\nFor every block Bu n , we define the ledger hash xn that is a function of the previous ledger hash xn\u22121 and the block Bun . If Bu n = \ufffd , then xn+1 = xn . Hence, if Bun\ufffd = {P u n\ufffd } is the last nonempty block of u, and the current block number is n \u2212 1 , then xn\u22121 = xn\u22122 = \u2026 = xn\ufffd if ledger is correctly formed. We say that the empty blocks n\ufffd + 1,\u2026 , n \u2212 1 are consistent with Bu n\u2032\n. Assume now that an illegal block Bu\ni = {Pu i } with\nn\ufffd < i < n \u2212 1 is added to the ledger (Fig.\u00a0 7) with Pu i . \u2260 H(Pu n\ufffd ) , i.e. Pu i \u201cdouble-spends\" the bill u. Then xi \u2260 xn\u2032 and hence, each of the empty blocks Bu i+1 ,Bu i+2 ,\u2026 ,Bu n\u22121\nis either consistent with Bu\nn\u2032 or with Bu i , but not with both.\nThe empty blocks that are consistent with Bu n\u2032 are called black blocks, and the empty blocks that are consistent with Bu\ni are called white blocks. Hence, each of the blocks\nBu i+1 ,Bu i+2 ,\u2026 ,Bu n\u22121 is either black or white (Fig.\u00a07). The next payment Pu\nn with u in the block Bu n = {Pu n } may\neither refer back to Bu n\u2032 (i.e. Pu n . = H(Pu n\ufffd ) ) or to Bu i (i.e. Pu n . = H(Pu i ) ). In the former case, during the audit protocol the blocks Bu i+1 ,Bu i+2 ,\u2026 ,Bu n\u22121\nmust be shown to be black, and in the latter case these blocks must be shown to be white. For randomly chosen j \u2190 {i + 1,\u2026 , n \u2212 1} , either\n\u2022 The probability that Bu j is consistent with Bu i is \u2264 1\n2\n\u2022 The probability that Bu j is consistent with Bu n\u2032 is \u2264 1\n2\nand hence, an audit with one randomly selected block Bu j in at least one of the two cases succeeds with probability not larger than 1\n2 ."
        },
        {
            "heading": "Proofs and\u00a0Ledger Hashes in\u00a0KSI\u2011Cash",
            "text": "For every n > 0 , a proof \u03a0u n is a pair (xu n\u22121 , cu n ) , where xu i is a ledger hash computed by the rules:\n1. xu 0 = 0 2. xu i = h0(x u i\u22121 , hD(R u i )) , where:\n\u2022 hD(X) = H(X) if X \u2260 \u2205 , and hD(X) = 0 if X = \ufffd \u2022 h0(x, y) = H(x, y) if y \u2260 0 , and h0(x, y) = 0 if y = 0\nand cu n is a hash chain with the shape special to u from xn to the block hash rn in Cn , i.e. cun(xn) = rn . The function FH is defined as follows:\nLemma\u00a06 guarantees that two different non-empty blocks Bu n\u2032 and Bu n\u2032\u2032\nmust have different ledger hashes. If n\u2032 < n\u2032\u2032 < j , then the ledger hash xj cannot equal to both xn\u2032 and xn\u2032\u2032 and then by Lemma\u00a07 (proved in [45]), if the block Bu\nj is consist-\nent with both Bu n\u2032 and Bu n\u2032\u2032 , we have a collision for H.\nLemma 6 If \u2205 \u2260 Bu n\u2032 \u2260 Bu n\u2032\u2032 \u2260 \u2205 , then either xu n\u2032 \u2260 xu n\u2032\u2032 , or we have an explicit H-collision or a bitstring X such that H(X) = 0.\nProof If xu n\ufffd = xu n\ufffd\ufffd , then by definition h0(x\ufffd, hD(Bun\ufffd )) = h0(x \ufffd\ufffd, h D (Bu n\ufffd\ufffd )) for some x\ufffd, x\ufffd\ufffd \u2208 {0, 1}k , which by Bu n\u2032 \u2260 \u2205 and Bu n\u2032\u2032 \u2260 \u2205 implies h0(x\ufffd,H(Bun\ufffd )) = h0(x \ufffd\ufffd,H(Bu n\ufffd\ufffd )) . I f H(Bu n\ufffd ) = 0 or H(Bu n\ufffd\ufffd ) = 0 , then we can take X = Bu n\ufffd o r X = H(Bu n\ufffd\ufffd ) and have H(X) = 0 . I f H(Bu n\ufffd ) \u2260 0 \u2260 H(Bu n\ufffd\ufffd ) , then by definition of h0 , we have H(x\ufffd,H(Bu n\ufffd )) = H(x\ufffd\ufffd,H(Bu n\ufffd\ufffd )) and because of Bu n\u2032 \u2260 Bu n\u2032\u2032 , we have a collision for H. \u25fb\nLemma 7 If cu, cu are two hash chains with the same u-specific shape, and cu(xu\nn\ufffd ) = cu(xu n\ufffd\ufffd ) and xu n\u2032 \u2260 xu n\u2032\u2032 , then we have\nan explicit H-collision.\nP r o o f L e t cu = \u27e8(b1, y1),\u2026 , (b , y )\u27e9 a n d cu = \u27e8(b1, y\ufffd1),\u2026 , (b , y \ufffd )\u27e9 be two hash chains of the same shape. We use induction on . If = 0 , then cu = \u27e8\u27e9 = cu and for every xu\nn\u2032 \u2260 xu n\u2032\u2032 , we have cu(xu n\ufffd ) = xu n\ufffd \u2260 xu n\ufffd\ufffd = cu(xu n\ufffd\ufffd )\nand hence, the induction basis trivially holds. Assume now that the statement holds for the chains of length \u2212 1 , for example, for the chains c = \u27e8(b1, y1),\u2026 , (b \u22121, y \u22121) and c\ufffd = \u27e8(b1, y\ufffd1),\u2026 , (b \u22121, y \u22121) . Hence, c u = \u27e8c\u2016(b , y )\u27e9 and cu = \u27e8c\ufffd\u2016(b , y\ufffd )\u27e9 . If b = 1 , then it follows from cu(xu n\ufffd ) = cu(xu n\ufffd\ufffd ) that\nIf c(xu n\ufffd ) \u2260 c\ufffd(xu n\ufffd\ufffd ) , then (9) represents a collision for H. If c(xu n\ufffd ) = c\ufffd(xu n\ufffd\ufffd ) , we apply the induction hypothesis to imply that the computations c(xu n\ufffd ) , c\ufffd(xu n\ufffd\ufffd ) contain an H-collision. The proof for the case b = 0 is similar. \u25fb"
        },
        {
            "heading": "KSI Cash Bill Ledger Implementation Case Study",
            "text": "Together with the European Central Bank and a group of eight national central banks from the Eurosystem, KSI Cash [1, 46\u201349] has been implemented as a\nFH(u;B, (x, c)) = c(h0(x, hD(B))).\n(9)H(y , c(xun\ufffd )) = H(y \ufffd , c\ufffd(xu n\ufffd\ufffd )).\nSN Computer Science\nproof-of-concept to assess the technological feasibility of a digital euro.\nThe performance of the technology has been tested exhaustively. With these performance tests, we achieved:\n\u2022 15\u00a0thousand transactions per second, under simulation of realistic usage, with 100 million wallets, \u2022 up to 2 million payment orders per second, i.e., an equivalent of more than 300,000 transactions per second, in a laboratory setting with the central components of KSI Cash, \u2022 an estimated carbon footprint of 0.0001g CO2 per transaction (as compared to: Bitcoin = 100\u00a0kg and more [50\u201352]).\nFor an exhaustive report on the KSI Cash implementation, its data structures and performance test results, see [1]."
        },
        {
            "heading": "User Side Probabilistic Audit in\u00a0KSI\u2011Cash",
            "text": "User has a bill u paid to her with a payment order Pu n\u2032 at block n\u2032 . We assume that user wallet contains the certificates C0,\u2026 ,Cn\ufffd that were already verified, the block Bu n\u2032 , and the proof \u03a0u n\ufffd\n, that have also been verified. In a block n > n\u2032 , the user creates a block Bu\nn with a new pay-\nment order Pu n = \u27e8 , b, , s\u27e9 , where = H(Pu n\ufffd ) , sends it to the transaction validator, and initiates the next protocol:\nProbabilistic audit protocol:\n1. The user requests and verifies the certificates Cn\ufffd+1,\u2026 ,Cn. 2. The use r gene ra t e s d r andom number s n1,\u2026 , nd \u2208 {n\n\ufffd + 1,\u2026 , n \u2212 1}. 3. The user requests \u03a0u\nn1 = (x\ufffd n1 , cu n1 ),\u2026 ,\u03a0u nd = (x\ufffd nd , cu nd )\na n d c h e ck s t h a t x\ufffd n1 = \u2026 = x\ufffd nd = xu n\ufffd , a n d cu n1 (xu n\ufffd ) = rn1 ,\u2026 , c u nd (xu n\ufffd ) = rnd."
        },
        {
            "heading": "Simplistic Security Analysis",
            "text": "Let the ledger be inconsistent already at block Bu n\u2032 and there are black blocks and white blocks that are inconsistent with each other (Fig.\u00a08). Therefore:\n\u2022 If the fraction of white blocks between n\u2032 and n is \u2264 1 2 ,\nand the payment Pu n is \u201cwhite\" ( Pu n . = H(Pu i ) ), then the\naudit succeeds with probability \u2264 2\u2212d. \u2022 If the fraction of black blocks between n\u2032 and n is \u2264 1\n2 ,\nand Pu n is \u201cblack\" ( Pu n . = H(Pu n\ufffd ) ), then the audit succeeds with probability \u2264 2\u2212d.\nThis analysis is precise only if the two blocks Bu n\u2032 ,Bu n\u2032\u2032 are very close, i.e. n\ufffd \u2248 n\ufffd\ufffd . In a more realistic scenario, adversary may choose suitable block numbers, for example, by delaying the execution of transactions, to make the success probability of probabilistic audit as high as possible. In the next section, we analyze such a possibility and show that such manipulation is not possible considering the properties of practical money systems."
        },
        {
            "heading": "Security: Alternating Payments Case",
            "text": "First, consider a scenario, where the adversary has to execute black payments and white payments alternatively as shown in Fig.\u00a09. Assume that the bill u have paid to two different honest users b and b\u2032 at block n0 and n1 , respectively. We assume that the payment to b is already an\nFig. 9 Alternating attack and general attack\nSN Computer Science\nillegal transaction, i.e. from the block n0 and further, the later blocks (and their certificates) may be consistent with only one branch of the bill ledger. The blocks consistent with the payment to b are said to be black, and the blocks consistent with the payment to b\u2032 are said to be white.\nLater at block n2 , the user b pays u to another user, at block n3 the user b\u2032 pays u to another user, and at block n4 the bill u is being paid again. We assume that the adversary can choose the blocks n1, n2, n3, n4 in an appropriate way to hide the inconsistency of the ledger from probabilistic audit.\nWe assume that there are N0 = n1 \u2212 n0 \u2212 1 between the payments to b and b\u2032 . Analogously, let N1 = n2 \u2212 n1 \u2212 1 , N2 = n3 \u2212 n2 \u2212 1 , and N3 = n4 \u2212 n3 \u2212 1 (Fig.\u00a09, upper). Note that all these blocks depicted as grey are either black or white. The color of these blocks can be chosen by the adversary. When the payment is made at the block n2 , the adversary is interested that most of the N0 + N1 grey blocks are black, because the payment at n2 is checked to be consistent with the black branch. When the payment is made at n3 , the adversary is interested that most of the N1 + N2 blocks are white, and for the payment at n4 , most of the N2 + N3 should be black again.\nIn the general case, the adversary has to execute black and white payments in arbitrary order (Fig.\u00a09, lower), that before the payment that continues the black block at n0 is made at the block n2 , some payments continue the white block at n1 and the last such payment happens at the block n\u2032\n1 . We assume that the\nnumber of blocks between n1 and n\u20321 is N \u2032 0 . It may be that none of such payments happen and then n\ufffd 1 = n1 and N\ufffd0 = 0 , and hence, we have the alternating attack. Analogously, we assume that some payments may continue the black block at n2 and the last such payment happens at the block n\u2032\n2 , etc.\nSay the adversary wants that any of the probabilistic test with d samples should succeed with probability 1 \u2212 . This means that every single-sample test must succeed with probability 1 \u2212 , where (1 \u2212 )d = (1 \u2212 ) . For small values of and they are related linearly: \u2248\nd . We prove in Appendix\u00a0A\nthat in the general case, the following theorem holds.\nTheorem\u00a011 The block numbers ni chosen by the adversary satisfy the equality\nHence, the required delays between payments must grow exponentially, that is clearly not realistic to enforce by adversaries in practice.\nn k+1 \u2212 n0 >\n( 1 \u2212 \ud835\udf16\n\ud835\udf16\n)k\u22121 (N1 + N \ufffd 1 )\n\u2212\n[ 1 \u2212 \ud835\udf16\n\ud835\udf16 +\u2026+\n( 1 \u2212 \ud835\udf16\n\ud835\udf16\n)k\u22122] (N0 + N \ufffd 0 )."
        },
        {
            "heading": "Discussion",
            "text": "It is not clear how to use client-side audit in case of account money schemes. We cannot just copy the idea of probabilistic audit of bill ledgers, because of very different ledger rules. Even if the total amount of money is controlled by the Central Bank (via count-certified trees [53], etc.), there is always \u201cmoney on the fly\"\u2014payer account debited but payee account not yet credited. The amount of \u201cmoney on the fly\" gives attackers room for illegal transactions that are hard to detect \u201con-line\". It would be an interesting research question whether there exist efficient probabilistic audit protocols for account money schemes\nScalability is one of the most important design goals not only for CBDCs but for blockchain technology in general. Hence, it would be interesting to study if the algebraic decomposition theory presented in this paper can be generalized to address wider design issues of blockchains."
        },
        {
            "heading": "Conclusions",
            "text": "We showed that efficient decomposability (shardability) of blockchain implementations of electronic money depends on the choice of money scheme and how it is associated with the algebraic structure of the payments. It turned out that the natural decomposition of the money scheme is atomic only if the payments can be represented as compositions of irreducible payments without two-unit swaps and two-unit joins. Bill payments have such representations and therefore, the bill money scheme is atomically decomposable. For account and UTXO payments such representations do not exist and therefore, the natural decompositions of the account and the UTXO money schemes are not atomic. Moreover, these schemes have no atomic decompositions of any kind.\nThe bill money scheme turns out to be the most natural choice also from the viewpoint of security, because it enables efficient and scalable client-side probabilistic audit of the blockchain."
        },
        {
            "heading": "Appendix A: Proof of\u00a0Theorem\u00a011",
            "text": "To prove the statement of Theorem\u00a011, we first go through the cases with small k and then prove Lemma\u00a08 that generalizes the argumentation to arbitrary k.\nFor the probabilistic audit at n2 to succeed with probability 1 \u2212 , at least (1 \u2212 )(N0 + N\ufffd0 + N1) grey blocks between n0 and n2 must be black, hence there must be no more than (N0 + N \ufffd 0 + N1) white blocks between n0 and n2 (excluding the blocks at n1 and n\u20321). For the probabilistic audit at n3 to succeed with probability 1 \u2212 , at least (1 \u2212 )(N1 + N\ufffd1 + N2) grey blocks between\nSN Computer Science\nn\u2032 1 and n3 must be white. As between n\u20321 and n2 the number of white blocks does not exceed (N0 + N\ufffd0 + N1) , and the\nnumber of white blocks between n2 and n\u20322 does not exceed N\u2032\n1 , there has to be at least\nwhite blocks between n\u2032 2 and n3 . This number cannot exceed N2 . Therefore N2 \u2265 (1 \u2212 )(N1 + N\ufffd1 + N2) \u2212 (N0 +N\ufffd\n0 + N1 + N \ufffd 1 ) and hence\nFor the probabilistic audit at n4 to succeed with probability 1 \u2212 , at least (1 \u2212 )(N2 + N\ufffd2 + N3) grey blocks between n\u2032\n2 and n4 must be black. As there are at least\n(1 \u2212 )(N1 + N \ufffd 1 + N2) \u2212 (N0 + N \ufffd 0 + N1 + N \ufffd 1 ) white blocks between n\u2032 2 and n3 , the number of black blocks between n\u20322 and n3 cannot exceed\nand the number of black blocks between n3 and n\u20323 does not exceed N\u2032\n2 , there have to be at least\nb l a ck b l o ck s b e t w e e n n\u2032 3 a n d n4 . T h i s n u m b e r c a n n o t e x c e e d N3 a n d h e n c e\n(1 \u2212 )(N1 + N \ufffd 1 + N2) \u2212 (N0 + N \ufffd 0 + N1 + N \ufffd 1 )\n(10)N1 + N\ufffd1 + N2 \u2265 1 \u2212 (N1 + N \ufffd 1 ) \u2212 (N0 + N \ufffd 0 ).\nN2 \u2212 (1 \u2212 )(N1 + N \ufffd 1 + N2) + (N0 + N \ufffd 0 + N1 + N \ufffd 1 )\n= (N0 + N \ufffd 0 + N1 + N \ufffd 1 + N2) \u2212 (1 \u2212 )(N1 + N \ufffd 1 ),\nR3 = (1 \u2212 )(N2 + N \ufffd 2 + N3)\n\u2212 (N0 + N \ufffd 0 + N1 + N \ufffd 1 + N2 + N \ufffd 2 ) + (1 \u2212 )(N1 + N \ufffd 1 )\n= (1 \u2212 )(N1 + N \ufffd 1 + N2 + N \ufffd 2 + N3)\n\u2212 (N0 + N \ufffd 0 + N1 + N \ufffd 1 + N2 + N \ufffd 2 )\nN3 \u2265 (1 \u2212 )(N2 + N \ufffd 2 + N3) \u2212 (N0 + N \ufffd 0 + N1 + N \ufffd 1 + N2 +N\ufffd 2 ) + (1 \u2212 )(N1 + N \ufffd 1 ) . Therefore:\nLemma 8 For every k \u2265 2 , the number of right color blocks (for the audit at nk+1 ) between n\u2032k and nk+1 must be at least\nand\nProof We use induction on k. The case k = 2 follows from equation (10). Assume that k \u2265 3 the statement holds for k \u2212 1 , i.e. the number of right color blocks (for the audit at nk ) between n\ufffdk\u22121 and nk must be at least\nand\nFor the audit at nk+1 to succeed with probability 1 \u2212 , at least (1 \u2212 )(Nk\u22121 + N\ufffdk\u22121 + Nk) grey blocks between n \u2032 k and nk+1 must be of the right color. As there are at least Rk\u22121 wrong color blocks between n\ufffd\nk\u22121 and nk , the number of right\ncolor blocks between n\ufffd k\u22121 and nk cannot exceed\nN1 + N \ufffd 1 + N2 + N \ufffd 2 + N3 \u2265\n1 \u2212\n(N1 + N \ufffd 1 + N2 + N \ufffd 2 ) \u2212 (N0 + N \ufffd 0 )\n\u2265 1 \u2212\n(N1 + N \ufffd 1 + N2) \u2212 (N0 + N \ufffd 0 )\n= ( 1 \u2212 )2 (N1 + N \ufffd 1 ) \u2212 [ 1 + 1 \u2212 ] (N0 + N \ufffd 0 ).\nR k =(1 \u2212 )(N1 + N \ufffd 1 +\u2026+ N k\u22121 + N \ufffd k\u22121 + N k )\n\u2212 (N0 + N \ufffd 0 +\u2026+ N k\u22121 + N \ufffd k\u22121 )\nN1 + N \ufffd 1 +\u2026+ N k\u22121 + N \ufffd k\u22121 + N k\n\u2265\n( 1 \u2212 )k\u22121 (N1 + N \ufffd 1 )\n\u2212 [ 1 + 1 \u2212 +\u2026+ ( 1 \u2212 )k\u22122] (N0 + N \ufffd 0 ).\nR k\u22121 =(1 \u2212 )(N1 + N \ufffd 1 +\u2026+ N k\u22122 + N \ufffd k\u22122 + N k\u22121)\n\u2212 (N0 + N \ufffd 0 +\u2026+ N k\u22122 + N \ufffd k\u22122 )\nN1 + N \ufffd 1 +\u2026+ N k\u22122 + N \ufffd k\u22122 + N k\u22121 \u2265\n\u2265\n( 1 \u2212 )k\u22122 (N1 + N \ufffd 1 )\n\u2212 [ 1 + 1 \u2212 +\u2026+ ( 1 \u2212 )k\u22123] (N0 + N \ufffd 0 ).\nNk\u22121 \u2212 Rk\u22121 = Nk\u22121 \u2212 (1 \u2212 )(N1 + N \ufffd 1 +\u2026+ Nk\u22122 + N \ufffd k\u22122 + Nk\u22121)\n+ (N0 + N \ufffd 0 +\u2026+ Nk\u22122 + N \ufffd k\u22122 )\n= (N0 + N \ufffd 0 +\u2026+ Nk\u22122 + N \ufffd k\u22122 + Nk\u22121)\n\u2212 (1 \u2212 )(N1 + N \ufffd 1 +\u2026+ Nk\u22122 + N \ufffd k\u22122 ),\nSN Computer Science\nand the number of right color blocks between nk and n\u2032k does not exceed N\ufffd\nk\u22121 , there has to be at least\nr i g h t c o l o r b l o ck s b e t we e n n\u2032 k a n d nk+1 . This number cannot exceed Nk and hence , N k \u2265 (1 \u2212 )(N1 + N \ufffd 1 +\u2026+ N k\u22121 + N \ufffd k\u22121 + N k )\u2212\n(N0 + N \ufffd 0 +\u2026+ N k\u22121 + N \ufffd k\u22121 ) . Therefore\nThis completes the induction. \u25fb\nHence, from Lemma\u00a08, the statement of Theorem\u00a011 follows:"
        },
        {
            "heading": "Appendix B: The Category of\u00a0Partial Implementations",
            "text": "Objects of the category are transition systems M = (S, T) with units 1 = 1S \u2208 T , i.e. machines. The morphisms from M1 = (S1, T1) to M2 = (S2, T2) are partial implementations, i.e. functions f \u2236 S1 \u2192 S2 such that for every s1 \u2208 S1 and t2 \u2208 T2 , there exists t1 \u2208 T1 such that f (t1(s1)) = t2(f (s1)) . The composition gf of two morphisms is their composition g\u25e6f as functions.\nLemma 9 The composition gf of morphisms g and f is a morphism.\nProof Let M1 = (T1, S1) , M2 = (T2, S2) , and M3 = (S3, T3) be machines, and let f \u2236 S1 \u2192 S2 , g \u2236 S2 \u2192 S3 be morphisms.\nRk = (1 \u2212 )(Nk\u22121 + N \ufffd k\u22121 + Nk) \u2212 (Nk\u22121 \u2212 Rk\u22121) \u2212 N \ufffd k\u22121\n= (1 \u2212 )(Nk\u22121 + N \ufffd k\u22121 + Nk) \u2212 (N0 + N \ufffd 0 +\u2026+ Nk\u22122 + N \ufffd k\u22122 + Nk\u22121)+\n+ (1 \u2212 )(N1 + N \ufffd 1 +\u2026+ Nk\u22122 + N \ufffd k\u22122 ) \u2212 N\ufffd k\u22121\n= (1 \u2212 )(N1 + N \ufffd 1 +\u2026+ Nk\u22121 + N \ufffd k\u22121 + Nk)\u2212\n\u2212 (N0 + N \ufffd 0 +\u2026+ Nk\u22121 + N \ufffd k\u22121 )\nN1 + N \ufffd 1 +\u2026+ Nk\u22121 + N \ufffd k\u22121 + Nk\n\u2265, 1 \u2212\n(N1 + N \ufffd 1 +\u2026+ Nk\u22122 + N \ufffd k\u22122 + Nk\u22121 + N \ufffd k\u22121 ) \u2212 (N0 + N \ufffd 0 )\n\u2265 1 \u2212\n(N1 + N \ufffd 1 +\u2026+ Nk\u22122 + N \ufffd k\u22122 + Nk\u22121) \u2212 (N0 + N \ufffd 0 )\n= ( 1 \u2212 )k\u22121 (N1 + N \ufffd 1 ) \u2212 [ 1 + 1 \u2212 +\u2026+ ( 1 \u2212 )k\u22122] (N0 + N \ufffd 0 ).\nnk+1 \u2212 n0 >N0 + N \ufffd 0 + N1 + N \ufffd 1 +\u2026+ Nk\u22121 + N \ufffd k\u22121 + Nk\n\u2265\n( 1 \u2212 \ud835\udf16\n\ud835\udf16\n)k\u22121 (N1 + N \ufffd 1 ) \u2212 [ 1 \u2212 \ud835\udf16\n\ud835\udf16 +\u2026+\n( 1 \u2212 \ud835\udf16\n\ud835\udf16\n)k\u22122] (N0 + N \ufffd 0 ).\nLet t3 \u2208 T3 , s1 \u2208 S1 , and s2 = f (s1) . As g is a morphism, there exists t2 \u2208 T2 such that g(t2(s2)) = t3(g(s2)) , and as f is a morphism, there exists t1 \u2208 T1 such that f (t1(s1)) = t2(f (s1)) .\nTherefore,\nand hence gf is a morphism. \u25fb\nAn object (S,\u00a0T) is called trivial if T = {1} , and full if T = SS , where SS is the set of all functions S \u2192 S.\nLemma 10 If M1 = (S1, T1) , M2 = (S2, T2) are machines, and\nM2 is trivial, then every function f \u2236 S1 \u2192 S2 is a morphism.\nProof L e t s1 \u2208 S1 a n d t2 \u2208 T2 . H e n c e , t2 = 1 by the t r iv ia l i ty of M2 . I f t1 = 1 \u2208 T1 , then f (t1(s1)) = f (s1) = 1(f (s1)) = t2(f (s1)) and hence, f is a morphism. \u25fb\nLemma 11 If M1 = (S1, T1) , M2 = (S2, T2) are machines, and M1 is full, then every bijective function f \u2236 S1 \u2192 S2 is a morphism.\nProof Let s1 \u2208 S1 and t2 \u2208 T2 . As f is bijective, t1 = f \u22121 \u25e6t2\u25e6f \u2208 S S1 1 = T1 . Hence, f (t1(s1)) = f ((f \u22121\u25e6t2\u25e6f )(s1)) = t2(f (s1)) and f is thereby a morphism. \u25fb\n(gf )(t1(s1)) = g(t2(f (s1))) = t3(g(f (s1))) = t3((gf )(s1))\nSN Computer Science\nLemma 12 A morphism f is an epimorphism iff f is surjective.\nProof Let M1 = (S1, T1) , M2 = (S2, T2) and f be a morphism from M1 to M2 . If f is surjective then for every s2 \u2208 S2 , there is s1 \u2208 S1 such that s2 = f (s1) . Hence, if gf = g\ufffdf for morphisms g, g\u2032 , then g(s2) = g(f (s1)) = g\ufffd(f (s1)) = g\ufffd(s2) and therefore g = g\ufffd and f is an epimorphism.\nLet f be an epimorphism that is not surjective and s \u2208 S2\ufffd f (S1) . We choose M3 = (S3, T3) to be a trivial object with \u2016S3\u2016 \u2265 2 and g, g\u2032 be functions from S2 to S3 the values of which only differ at s, i.e. g(s) \u2260 g\ufffd(s) but g(s\ufffd) = g\ufffd(s\ufffd) for every s \u2260 s\ufffd \u2208 S2 . Then gf = g\ufffdf , g \u2260 g\u2032 , and g, g\u2032 are morphisms by Lemma\u00a010. A contradiction. \u25fb\nLemma 13 A morphism f is a monomorphism iff f is injective.\nProof Let M2 = (S2, T2) , M3 = (S3, T3) and f be a morphism from M2 to M3 . If f is injective and g is a morphism such that fg = fg\ufffd , then f (g(s)) = f (g\ufffd(s)) and hence g(s) = g\ufffd(s) for every s which means that g = g\ufffd.\nIf f is a monomorphism that is not injective, i.e. there exist s, s\ufffd \u2208 S2 such that s \u2260 s\u2032 and f (s) = f (s\ufffd) . Choose S1 = S2 and T1 = S S2 2\n, i.e. M1 = (S1, T1) is a full object. Let g = 1S2 and g\n\ufffd = (ss\ufffd) be a transposition that swaps s and s\u2032 . Then g, g\u2032 are bijective, fg = fg\ufffd , g \u2260 g\u2032 , and g, g\u2032 are morphisms by Lemma\u00a011. A contradiction. \u25fb\nIn category theory, an object D is said to be a product of objects M1,M2 , if there exist two morphisms D 1 \u2212\u2192M1 and D 2 \u2212\u2192M2 such that for every object M and every two morphisms M f1 \u2212\u2192M1 and M f2 \u2212\u2192M2 there exists a unique morphism M f \u2212\u2192D such that f1 = 1f and f2 = 2f .\nIn the category of sets and functions, the product is the direct (Cartesian) product, i.e. if S1, S2 are sets then D = S1 \u00d7 S2 = {(s1, s2) \u2236 s1 \u2208 S1, s2 \u2208 S2} . The maps 1 \u2236 S1 \u00d7 S2 \u2192 S1 and 2 \u2236 S1 \u00d7 S2 \u2192 S2 are defined so that 1(s1, s2) = s1 and 2(s1, s2) = s2 . The unique function f \u2236 S \u2192 D is defined by f (s) = (f1(s), f2(s)).\nThe direct product construction can be generalized to the category of machines and partial implementations, so that the direct product of M1 = (S1, T1) and M2 = (S2, T2) is D = (S1 \u00d7 S2, T1 \u00d7 T2) , and the functions 1, 2 are the same as in the category of sets and functions and it is easy to see that they are morphisms of the category of machines and partial implementations.\nPartial implementations are also functions, and hence for every machine M = (S, T) and two morphisms M f1 \u2212\u2192M1 , M f2 \u2212\u2192M2 there is a unique function f \u2236 S \u2192 S1 \u00d7 S2 such that f1 = 1f and f2 = 2f , where f (s) = (f1(s), f2(s)) for every s \u2208 S . However, the function f is not always a morphism in the category of machines and partial implementations. Let:\n\u2022 M = (S, T) , where S = {s, s\ufffd, s\ufffd\ufffd} and T = {1, t\ufffd 1 , t\ufffd 2 } \u2022 M1 = (S1, T1) , where S1 = {s1, s\ufffd1, s \ufffd\ufffd 1 } and T1 = {1, t1}, \u2022 M2 = (S2, T2) , where S2 = {s2, s\ufffd2, s \ufffd\ufffd 2 } and T2 = {1, t2} \u2022 t1 = {(s1, s\ufffd1), (s \ufffd 1 , s\ufffd 1 ), (s\ufffd\ufffd 1 , s\ufffd\ufffd 1 )} , t2 = {(s2, s\ufffd2), (s \ufffd 2 , s\ufffd 2 ), (s\ufffd\ufffd 2 , s\ufffd\ufffd 2 )} \u2022 t\ufffd 1 = {(s, s\ufffd), (s\ufffd, s\ufffd), (s\ufffd\ufffd, s\ufffd\ufffd)} , t\ufffd 2 = {(s, s\ufffd\ufffd), (s\ufffd, s\ufffd), (s\ufffd\ufffd, s\ufffd\ufffd)}, \u2022 f1 = {(s, s1), (s\ufffd, s\ufffd1), (s \ufffd\ufffd, s\ufffd\ufffd 1 )} , and f2 = {(s, s2), (s\ufffd, s\ufffd2), (s\ufffd\ufffd, s\ufffd\ufffd2 )}\n.\nIt is easy to see that f1, f2 are morphisms, but the function f \u2236 S \u2192 S1 \u00d7 S2 defined by f (s) = (f1(s), f2(s)) is not a morphism, because for a transition (t1, t2) \u2208 T1 \u00d7 T2 there is no t \u2208 T such that f (t(s)) = (t1, t2)(f (s)) . Indeed:\n\u2022 f (t\ufffd 1 (s)) = (s\ufffd 1 , s\ufffd\ufffd 2 ) \u2260 (s\ufffd 1 , s\ufffd 2 ) = (t1(f1(s)), t2(f2(s))) =\n(t1, t2)(f (s))\n\u2022 f (t\ufffd 2 (s)) = (s\ufffd\ufffd 1 , s\ufffd 2 ) \u2260 (s\ufffd 1 , s\ufffd 2 ) \u2022 f (1(s)) = (s1, s2) \u2260 (s\ufffd1, s \ufffd 2 )\nThis means that in the category of machines and partial implementations, not every two objects have a product."
        },
        {
            "heading": "Declarations",
            "text": "Conflict of interest On behalf of all authors, the corresponding author states that there is no conflict of interest.\nOpen Access This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article\u2019s Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article\u2019s Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit http://creativecommons.org/licenses/by/4.0/."
        }
    ],
    "title": "A Theory of Secure and Efficient Implementation of Electronic Money",
    "year": 2023
}