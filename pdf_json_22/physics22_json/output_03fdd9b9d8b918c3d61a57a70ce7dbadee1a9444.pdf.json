{
    "abstractText": "In this article, we discuss the question of whether P equals NP, we do not follow the line of research of many researchers, which is to try to find such a problem Q, and the problem Q belongs to the class of NP-complete, if the problem Q is proved to belong to P , then P and NP are the same, if the problem Q is proved not to belong to P , then P and NP are separated. Our research strategy in this article: Select a problem S of EXP -complete and reduce it to a problem of NP in polynomial time, then S belongs to NP , so EXP = NP , and then from the well-known P 6= EXP , derive P 6 = NP . For this purpose, first, we examine many logical formula classes in first-order logic, including the four main classes of unary predicate calculus (first-order logic) considered by Lewis, from which we find a satisfiability problem LSBS of Schonfinkel-Bernays expression segments, which belongs to EXP-complete. Secondly, on the basis of Henkin\u2019s theory in first-order logic, we get the decomposition theorem of SchonfinkelBernays expression segments, and prove that every Schonfinkel-Bernays expression segments can be decomposed into a set of finite propositional formulas in propositional logic, which can also be called the Herbrand extension theorem of Schonfinkel-Bernays expression segments. Third, we demonstrate a key conclusion: using the \u201dexponentially padded version\u201d technique of encoding, we prove that the satisfiability problem LSBS of Schonfinkel-Bernays expression segments can be reduced in polynomial time to the satisfiability problem LFPF of a set of finite propositional formulas in propositional logic, and the satisfiability problem LFPF of a set of finite propositional formulas in propositional logic is an NP problem (also an NP-complete problem), so, we prove that the satisfiability problem LSBS of Schonfinkel-Bernays expression segments belongs to NP , so we prove that there exists an instance of EXP-complete which belongs to NP , so EXP = NP , since P 6 = EXP and NP 6 = NEXP are a well-known results, so P 6 = NP and EXP 6= NEXP . These results give answers to three open questions in the computational complexity theory.",
    "authors": [
        {
            "affiliations": [],
            "name": "Jian-Gang Tang"
        }
    ],
    "id": "SP:71f95155331c86f3a2087ebd306260e633984f99",
    "references": [
        {
            "authors": [
                "Michael Sipser"
            ],
            "title": "The history and status of the P versus NP question",
            "year": 1992
        },
        {
            "authors": [
                "Jack Edmonds"
            ],
            "title": "Minimum partition of a matroid into independents subsets",
            "venue": "Journal of Research of the National Bureau of Standards,",
            "year": 1965
        },
        {
            "authors": [
                "Stephen Cook"
            ],
            "title": "The complexity of theorem-proving procedures",
            "venue": "Proceedings of the third annual ACM symposium on Theory of computing,",
            "year": 1971
        },
        {
            "authors": [
                "Leonid A. Levin"
            ],
            "title": "Universal sequential search problems",
            "venue": "Problems of Information Transmission,",
            "year": 1973
        },
        {
            "authors": [
                "R.M. Karp"
            ],
            "title": "Reducibility among combinatorial problems",
            "venue": "R. E. Miller and J. W. Thatcher, editors, Complexity of Computer Computations, pages 85-103. Plenum Press",
            "year": 1972
        },
        {
            "authors": [
                "Michael R. Garey",
                "David S. Johnson"
            ],
            "title": "Computers and intractability",
            "year": 1979
        },
        {
            "authors": [
                "Theodore Baker",
                "John Gill",
                "Robert Solovay"
            ],
            "title": "Relativizations of the P =? NP question",
            "venue": "SIAM J. Comput.,",
            "year": 1975
        },
        {
            "authors": [
                "Stephen Cook"
            ],
            "title": "The P versus NP problem. In The millennium prize problems, pages 87-104",
            "venue": "Clay Math. Inst.,",
            "year": 2006
        },
        {
            "authors": [
                "Avi Wigderson"
            ],
            "title": "P, NP, and Mathematics a computational complexity perspective",
            "venue": "Proceedings of the ICM 2006,",
            "year": 2007
        },
        {
            "authors": [
                "Michael Sipser"
            ],
            "title": "Introduction to the Theory of Computation",
            "venue": "Course Technology,",
            "year": 1996
        },
        {
            "authors": [
                "Jos\u00e9 Luis Balc\u00e1zar",
                "Josep D\u00edaz",
                "Joaquim Gabarr\u00f3"
            ],
            "title": "Structural complexity. I",
            "venue": "Texts in Theoretical Computer Science. An EATCS Series. Springer-Verlag, Berlin, second edition,",
            "year": 1995
        },
        {
            "authors": [
                "C.H. Papadimitriou"
            ],
            "title": "Computational Complexity",
            "venue": "Addison-Wesley",
            "year": 1984
        },
        {
            "authors": [
                "H.R. Lewis"
            ],
            "title": "Complexity Results for Classes of Quantificational Formulas",
            "venue": "Journal of Computer and System Sciences,",
            "year": 1980
        },
        {
            "authors": [
                "Michael Sipser"
            ],
            "title": "Introduction to the Theory of Computation",
            "venue": "PWS Publishing Company,",
            "year": 1997
        },
        {
            "authors": [
                "H.-D. Ebbinghaus",
                "J. Flum",
                "W. Thomas"
            ],
            "title": "Mathematical Logic(Third Edition)",
            "venue": "Springer",
            "year": 2021
        },
        {
            "authors": [
                "H.R. Lewis",
                "C.H. Papadimitriou"
            ],
            "title": "Elements of the Theory of Computation, 2nd ed",
            "year": 1998
        },
        {
            "authors": [
                "L. Berman"
            ],
            "title": "Precise bounds for Presberger arithmetic and the reals with addition",
            "venue": "\u201dProceedings, 18th Annual Symposium on Foundations of Computer Science",
            "year": 1977
        },
        {
            "authors": [
                "M.J. Fischer",
                "M.O. Rabin"
            ],
            "title": "Super-exponential complexity of Presberger arithmetic",
            "venue": "\u201dComplexity of Computation,\u201d Vol. VII, \u201dSIAM-AMS Proceedings,\u201d Amer. Math. Sot., Providence, R. I.",
            "year": 1974
        },
        {
            "authors": [
                "D. Oppen"
            ],
            "title": "A upper bound on the complexity of Presburger arithmetic",
            "venue": "J. Comput. Systems Sci. 16",
            "year": 1978
        },
        {
            "authors": [
                "A.R. Meyer"
            ],
            "title": "Weak monadic second-order theory of successor is not elementary-recursive",
            "venue": "MAC Technical Memo No. 38, M.I.T.",
            "year": 1973
        },
        {
            "authors": [
                "L.J. Stockmeyer"
            ],
            "title": "The Complexity of Decision Procedures in Automata Theory and Logic,",
            "venue": "Ph.D. Thesis, M.I.T.,",
            "year": 1974
        },
        {
            "authors": [
                "W. Ackermann"
            ],
            "title": "Uber die Erfiillbarkeit gewisser Zahlausdriicke",
            "venue": "Math. Ann. 100 ",
            "year": 1928
        },
        {
            "authors": [
                "K. G\u00f6del"
            ],
            "title": "Ein Spezialfall des Entscheidungsproblems der theoretischen Logik",
            "venue": "Ergebnisse eines mathematischen Kolloquiums 2, pp. 27-28",
            "year": 1932
        },
        {
            "authors": [
                "P. Bernays",
                "M. Sch\u00f6nfinkelz"
            ],
            "title": "um Entscheidungsproblem der mathematischen Logik",
            "venue": "Math. Ann. 99 ",
            "year": 1928
        },
        {
            "authors": [
                "Stephen Cook"
            ],
            "title": "A hierarchy for nondeterministic time complexity",
            "venue": "J. Comput. Systems Sci",
            "year": 1973
        },
        {
            "authors": [
                "H.R. Lewis"
            ],
            "title": "Description of restricted automata by first-order formulae",
            "venue": "Math. Systems Theory 9",
            "year": 1975
        },
        {
            "authors": [
                "H.R. Lewis"
            ],
            "title": "Complexity of solvable cases of the decision probem for the predicate calculus",
            "venue": "\u201dProceedings, 19th Annual Symposium on the Foundations of Computer Science",
            "year": 1978
        },
        {
            "authors": [
                "H.R. Lewis"
            ],
            "title": "Unsolvable Classes of Quantiticational Formulas",
            "venue": "Addison-Wesley, Reading, Mass.",
            "year": 1979
        },
        {
            "authors": [
                "H.R. Lewis"
            ],
            "title": "Satisliability problems for propositional calculi",
            "venue": "Math. Systems Theory 13 ",
            "year": 1979
        },
        {
            "authors": [
                "C. Rackoff"
            ],
            "title": "The Complexity of Theories of the Monadic Predicate Calculus",
            "venue": "Technical Report, IRIA",
            "year": 1975
        },
        {
            "authors": [
                "K. Sch\u00fctte"
            ],
            "title": "Untersuchungen zum Entscheidungsproblem der mathematischen Logik",
            "venue": "Math. Ann. 109 ",
            "year": 1934
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n20 9.\n15 41\n0v 5\n[ cs\n.C C\n] 4\nS ep\nthe line of research of many researchers, which is to try to find such a problem Q, and the problem Q belongs to the class of NP-complete, if the problem Q is proved to belong to P , then P and NP are the same, if the problem Q is proved not to belong to P , then P and NP are separated. Our research strategy in this article: Select a problem S of EXP -complete and reduce it to a problem of NP in polynomial time, then S belongs to NP , so EXP = NP , and then from the well-known P 6= EXP , derive P 6= NP . For this purpose, first, we examine many logical formula classes in first-order logic, including the four main classes of unary predicate calculus (first-order logic) considered by Lewis, from which we find a satisfiability problem LSBS of Schonfinkel-Bernays expression segments, which belongs to EXP-complete. Secondly, on the basis of Henkin\u2019s theory in first-order logic, we get the decomposition theorem of SchonfinkelBernays expression segments, and prove that every Schonfinkel-Bernays expression segments can be decomposed into a set of finite propositional formulas in propositional logic, which can also be called the Herbrand extension theorem of Schonfinkel-Bernays expression segments. Third, we demonstrate a key conclusion: using the \u201dexponentially padded version\u201d technique of encoding, we prove that the satisfiability problem LSBS of Schonfinkel-Bernays expression segments can be reduced in polynomial time to the satisfiability problem LFPF of a set of finite propositional formulas in propositional logic, and the satisfiability problem LFPF of a set of finite propositional formulas in propositional logic is an NP problem (also an NP-complete problem), so, we prove that the satisfiability problem LSBS of Schonfinkel-Bernays expression segments belongs to NP , so we prove that there exists an instance of EXP-complete which belongs to NP , so EXP = NP , since P 6= EXP and NP 6= NEXP are a well-known results, so P 6= NP and EXP 6= NEXP . These results give answers to three open questions in the computational complexity theory. Key Words: P , NP , EXP , NEXP\n2020 Mathematics Subject Classifications: 03D15, 68Q15, 03C13, 03B10, 03B05. \u2217A \u2020Corresponding author: Jian-Gang Tang, Male, (1959.08-), E-mail: jg-tang@163.com, Tel: (86)13579701677, Prof., D.Sci.(Polish Academy of Sciences) and Ph.D.(Sichuan University), Research Direction: Computational complexity, Theory of computation, Categorical logic, Topology and order structures, Algebra and order structures \u2021Note: Both attribution units of the author are the first unit."
        },
        {
            "heading": "1 Introduction",
            "text": "The question of whether P equals NP is widely regarded as being one of the most significant and influential inquiries in modern mathematics and computer science. The origins of the question seem to go back to the letter Go\u0308del wrote to Von Neumann in 1956[1]. The formal definition of class NP is attributed to the work of Edmonds[2], Cook[3], and Levin[4]. The Cook-Levin theorem proves the existence of complete problems for the class of NP , it is also proved that SAT, which is the problem of determining whether a set of clauses composed of a set of Boolean literals has a satisfiable assignment, is such a NP-complete problem. Later, Karp[5] proved that 21 well-known combinatorial problems, including the vertex cover problem, the clique cover problem, the exact cover problem, the chromatic number problem, the Hamilton circuit, the traveling salesman and the partition problems and the clique problem are also NP-complete. In subsequent years, many core problems involving different fields of application were shown to be NP-complete(see[6] for a list). What if P 6= NP , we will never find an efficient general method for solving NP problems. On the other hand, if P = NP , the result will be even more striking, because every problem in NP will have an efficient polynomial-time solution, which would lead to the collapse of systems such as cryptography. The implications for applications such as cryptography and the general philosophical question of whether human creativity can be automated will be profound.\nThe P 6= NP question is also singular in the number of approaches that researchers have brought to bear upon it over the years. From the initial question in logic, the focus moved to complexity theory where early work used diagonalization and relativization techniques. However, [7] showed that these methods were perhaps inadequate to resolve P 6= NP by demonstrating relativized worlds in which P = NP and others in which P 6= NP (both relations for the appropriately relativized classes). This shifted the focus to methods using circuit complexity and for a while this approach was deemed the one most likely to resolve the question. Once again, a negative result in [8] showed that a class of techniques known as \u00a1\u00b0Natural Proofs\u00a1\u00b1 that subsumed the above could not separate the classes NP and P , provided one-way functions exist.\nThe computational complexity for classes of quantificational formulas is closely related to this paper. Most work on computational complexity in logical decision problems has focused either on propositional calculus ([3],[27], [28], [29], [30] and [31]), on decidability theory such as Presburger\u2019s algorithm[19], [20] and [21], or on successor and ordering theories [22] and [23]. Harry Lewis[14] considered instead some subclasses of the classical predicate calculus that are defined by purely syntactic restrictions on the formation of formulas. These are formulas without the function signs or the identity sign, and they are all closed, that is, contain no free variable. The four main classes Harry Lewis considered are the monadic predicate calculus, of which the decidability dates back to 1915[32], and three classes determined by the form of the prefix, which are named in honor of individuals who proved their decidability: Ackermann class(\u2203 \u00b7 \u00b7 \u00b7 \u2203\u2200\u2203 \u00b7 \u00b7 \u00b7 \u2203)[24], Go\u0308del class(\u2203 \u00b7 \u00b7 \u00b7 \u2203\u2200\u2200\u2203 \u00b7 \u00b7 \u00b7 \u2203\u2200)[25], Scho\u0308nfinkel-Bernays class(\u2203 \u00b7 \u00b7 \u00b7 \u2203\u2200 \u00b7 \u00b7 \u00b7 \u2200)[26], a class of formulas with prefixes of the form \u2203 \u00b7 \u00b7 \u00b7 \u2203\u2200\u2203 \u00b7 \u00b7 \u00b7 \u2203\u2200. Moreover, the upper and lower bounds of the time complexity for determining the satisfiability of these four classes of first-order logical formulas constrained by quantifiers are given respectively.\nDue to the importance of NP problems, a large number of literatures on NP problems have been\nproduced. The document [9] presents the official problem description of the Clay Millennium Prize. An earlier excellent comment on the NP problem is [1]. See [10] for more recent research on NP problems. In general, most books on theoretical computer science, especially computational complexity, contain descriptions of and attempts to solve NP problems; see [11], [12], [13] and [15] for standard references.\nIn order to make this paper self-contained, when the results in the references are cited in this paper, only the source is given, and no proof is given. Detailed proof can be found in the marked references. The organizational structure of this paper is as follows:\nIn Section 1, this section is the introduction, we briefly review the history of research on the NP problems. This section introduces some of the outstanding achievements of some of the great mathematicians and computer scientists. Further, this section introduces the structure of this paper and the content summary of each section\nIn Section 2, the Henkin\u2019s theory (including Herbrand\u2019s theory) plays a key role in this paper, a very important and standard reference is [16]. Using these theories, we give the decomposition theorems of Scho\u0308nfinkel-Bernays expression and Scho\u0308nfinkel-Bernays expression fragments respectively, the decomposition theorem expresses that each Scho\u0308nfinkel-Bernays expression and Scho\u0308nfinkel-Bernays expression segment can be decomposed into a finite set of propositional formulas, the decomposition theorem may also be called the Herbrand extension theorem for Scho\u0308nfinkel-Bernays expressions and the Herbrand extension theorem for Scho\u0308nfinkel-Bernays expression segments, the relationship between this kind of formula in first-order logic and the logical formula set in propositional logic is established. The relations between the syntactic form of a quantificational formula and structural properties of its expansions are very important for our researches.\nIn Section 3, we discuss the question of whether P equals NP , we do not follow the line of research of many researchers, which is to try to find such a problem Q, and the problem Q belongs to the class of NP-complete, if the problem Q is proved to belong to P , then P and NP are the same, if the problem Q is proved not to belong to P , then P and NP are separated. Our research strategy in this article: Select a problem S of EXP-complete and reduce it to a problem of NP in polynomial time, then S belongs to NP , so EXP = NP , and then from the well-known P 6= EXP , derive P 6= NP . For this purpose, first, we examine many logical formula classes in first-order logic, including the four main classes of unary predicate calculus (first-order logic) considered by Lewis, from which we find a satisfiability problem LSBS of Schonfinkel-Bernays expression segments, which belongs to EXP-complete. Secondly, on the basis of Henkin\u2019s theory in first-order logic, we get the decomposition theorem of SchonfinkelBernays expression segments, and prove that every Schonfinkel-Bernays expression segments can be decomposed into a set of finite propositional formulas in propositional logic, which can also be called the Herbrand extension theorem of Schonfinkel-Bernays expression segments. Third, we demonstrate a key conclusion: using the \u201dexponentially padded version\u201d technique of encoding, we prove that the satisfiability problem LSBS of Schonfinkel-Bernays expression segments can be reduced in polynomial time to the satisfiability problem LFPF of a set of finite propositional formulas in propositional logic, and the satisfiability problem LFPF of a set of finite propositional formulas in propositional logic is an NP problem (also an NP-complete problem), so, we prove that the satisfiability problem LSBS of Schonfinkel-Bernays expression segments belongs to NP , so we prove that there exists an instance of EXP-complete which belongs to NP , so EXP = NP , since P 6= EXP and NP 6= NEXP are a\nwell-known results, so P 6= NP and EXP 6= NEXP . These results give answers to three open questions in the computational complexity theory.\nIn Appendix A, we mainly states the terms, symbols and some results of the first-order logic related to this paper, it deals with the syntax and semantics of first-order logic language, and some important contents, such as the Henkin\u2019s theory and the Herbrand\u2019s theory, etc.\nIn Appendix B, we mainly state the syntax and semantics of propositional logic, the relationship between formulas in first-order predicate logic and propositional logic is discussed by using the Henkin\u2019s theory.\nIn Appendix C, we shall recall the well-known the complexity class of languages, such as P , NP ,\nEXP , NEXP , and the corresponding completeness for complexity classes."
        },
        {
            "heading": "2 Decomposition theorem",
            "text": "In this section, we discuss the decomposition theorem about the Schonfinkel-Bernays expressions in\nfirst order logic, important and standard references in this section are [16], [17].\nDefinition 2.1. An alphabet A is a nonempty set of symbols.\nDefinition 2.2. The alphabet of a first-order language L contains the following symbols:\n(1) v0,v1,v2,. . . (variables); (2) \u00ac,\u2227,\u2228,\u2192,\u2194(not, and, or, if-then, if and only if);\n(3) \u2200,\u2203(for all, there exists);\n(4) \u2261(equality symbol);\n(5) ),( (parentheses);\n(6) (a) for every n>1 a (possibly empty) set of n-ary relation symbols;\n(b) for every n>1 a (possibly empty) set of n-ary function symbols;\n(c) a (possibly empty) set of constants.\nRemark 2.3. (1) By A we denote the set of symbols listed in (1) through (5).Let S be the (possibly empty) set of symbols from (6).The symbols listed under (6) must, of course, be distinct from each other and from the symbols in A.\n(2) The set S determines a first-order language. We call AS := A \u22c3 S the alphabet of this language\nand S its symbol set.\n(3) Henceforth we shall use the letters P,Q,R,... for relation symbols, f, g, h,... for function symbols,\nc, c0, c1,... for constants, and x, y, z,... for variables.\nDefinition 2.4. S -terms are precisely those strings in A\u2217S which can be defined inductively as\nfollows:\n(T1) Every variable is an S -term.\n(T2) Every constant in S is an S-term.\n(T3) If the strings t1,...,tn are S -terms and f is an n-ary function symbol in S, then ft1 ...tn is also\nan S -term.\nWe denote the set of S -terms by T S. Definition 2.5. S -formulas are precisely those strings of A\u2217S which can be defined inductively as\nfollows:\n(F1) If t1 and t2 are S -terms, then t1 \u2261 t2 is an S -formula. (F2) If t1,...,tn are S -terms and R is an n-ary relation symbol in S, then Rt1 ...tn is an S -formula. (F3) If \u03d5 is an S -formula, then \u00ac\u03d5 is also an S -formula.\n(F4) If \u03d5 and \u03c8 are S -formulas, then (\u03d5\u2227\u03c8), (\u03d5\u2228\u03c8) , (\u03d5\u2192\u03c8) , and (\u03d5\u2194\u03c8) are also S -formulas.\n(F5) If \u03d5 is an S -formula and x is a variable, then \u2200x\u03d5 and \u2203x\u03d5 are also S -formulas. S -formulas derived using (F1) and (F2) are called atomic formulas because they are not formed by combining other S -formulas. The formula \u00ac\u03d5 is called the negation of \u03d5 ,and (\u03d5\u2227\u03c8), (\u03d5\u2228\u03c8) ,and (\u03d5\u2192\u03c8) are called, respectively, the conjunction,disjunction, implication, and bi-implication of \u03d5 and \u03c8.\nDefinition 2.6. By LS we denote the set of S -formulas. This set is called the first-order language\nassociated with the symbol set S.\nNotation 2.7. Instead of S -terms and S -formulas, we often speak simply of terms and formulas when the reference to S is either clear or unimportant. For terms we use the letters t, t0, t1,..., and for formulas the letters \u03d5, \u03c8,... .\nLemma 2.8. Let \u03d5 := \u2203x\u03c8(x) \u2208 LS be a first-order language expression with x \u2208 free(\u03c8). The\nfollowing are equivalent:\n(1) Sat \u2203x\u03c8(x); (2) There is a constant c \u2208 T S0 such that Sat \u03c8( c x ). Proof: (2)\u2192(1). If there is a constant c \u2208 T S0 such that Sat \u03c8( c x ), then there is a interpretation M such that M is a model of \u03c8( c x ), so M \u03c8( c x ), according to Lemma A.22, M(M(c) x ) \u03c8(x), by Definition A.12, there is a = M(c) \u2208 D(domain of M) such that M(a x ) \u03c8(x), by Definition A.17, M \u2203x\u03c8(x), and so M is a model of \u2203x\u03c8(x).\nHence, Sat \u2203x\u03c8(x).\n(1)\u2192(2). If Sat \u2203x\u03c8(x), then, there is an interpretation M that is a model of \u2203x\u03c8(x), so\nM \u2203x\u03c8(x).\nBy definition A.17, there is an a \u2208 A such that M(a x ) \u03c8(x). Substituting c \u2208 T S0 for x, we have M( a c ) \u03d5( c x ). And so, M(a c ) is a model of \u03c8( c x ). Hence, Sat \u03c8( c x ). Theorem 2.9. Let \u03d5 = \u2203x1 . . . \u2203xs\u03c8 \u2208 LS be a first-order language expression with {x1, . . . , xs} \u2286\nfree(\u03c8), The following are equivalent:\n(1) Sat \u2203x1 . . .\u2203xs\u03c8; (2) There is a set of constants {c1, . . . , cs} \u2286 T S 0 such that Sat \u03c8( c1...cs x1...xs ). Proof: According to Lemma 2.8, the conclusion can be obtained by mathematical induction.\nDefinition 2.10.[33] A formula \u03d5 whose expression has the following form is called an Schonfinkel-\nBernays expression:\n\u03d5 := \u2203x1 . . .\u2203xs\u2200y1 . . . \u2200yt\u03c8\nwith the following properties:\n(1) \u03c8 contains only variables {x1, . . . , xs, yt, . . . , yt}; (1) \u03c8 is quantifier-free;\n(2) \u03c8 equality-free;\n(3) \u03c8 function-free.\nIt is not hard to see that the following conclusion is true.\nTheorem 2.11. Let \u03d5 := \u2203x1 . . .\u2203xs\u2200y1 . . . \u2200yt\u03c8 be an Schonfinkel-Bernays expression, then, (1) it is in prenex form with a sequence of existential quantifiers followed by a sequence of universal\nones,\n(2) free(\u03c8)={x1, . . . , xs, y1, . . . , yt}, In conjunction with condition (1), the condition ensures that\nthe variables in \u03c6 are not redundant.\n(3) con(\u03c8)= {a0, a1, . . . , am\u22121}. Because \u03d5 is of finite length, it can be assumed that \u03d5 contains a finite number of constant symbols, on account of con(\u03d5)=con(\u03c8), so that condition 5 is reasonable. If \u03d5 does not contain any constant symbols, then the constant symbol a0 is added.\n(4) For a Schonfinkel-Bernays expression \u03d5 = \u2203x1 . . . \u2203xs\u2200y1 . . .\u2200yt\u03c8, when k > 1, TSk = {x1, . . . , xs, y1, . . . , xt, a0, . . . , am\u22121}, when k = 0, T S 0 = con(\u03c8) = {a0, . . . , am\u22121}. (5) More precisely, \u03c8 := \u03c8(x1, . . . , xs, y1, . . . , xt, a0, . . . , am\u22121). Definition 2.12. A language is said to be Schonfinkel-Bernays language if all its fornulas are of\nthe form of Schonfinkel-Bernays expressions, denoted FSB.\nTheorem 2.13. Let \u03d5 = \u2203x1 . . .\u2203xs\u2200y1 . . . \u2200yt\u03c8 be an Schonfinkel-Bernays expression with |con(\u03d5)| =\nm, The following are equivalent:\n(1) Sat \u03d5; (2) There exists an finite interpretation M\u2032 such that M\u2032 \u03d5 with |M\u2032| \u2264 m+s.\nProof: The proof of (1) by (2) is obvious. Now, the proof goes from (1) to (2).\nIf \u03d5 is satisfiable, there exist an interpretationM = (S, \u03b2),S = (D,m) such thatM |= \u2203x1 . . . \u2203xs\u2200y1 . . .\u2200yt\u03c8. By Definition A.17, there exists b1 . . . bs \u2208 D such that M( b1\u00b7\u00b7\u00b7bs x1\u00b7\u00b7\u00b7xs ) |= \u2200y1 . . .\u2200yt\u03c8 of which bi =\n\u03b2(xi), (1 \u2264 i \u2264 s).\nLet D \u2032 = \u03b2( s x) \u222a \u03b2(con(\u03c8)) = {\u03b2(x1), \u00b7 \u00b7 \u00b7 , \u03b2(xs), \u03b2(a1), \u00b7 \u00b7 \u00b7 , \u03b2(am)}\n= {b1, \u00b7 \u00b7 \u00b7 , bs, \u03b2(a1), \u00b7 \u00b7 \u00b7 , \u03b2(am)}, then D \u2032 \u2286 D and |D \u2032 | \u2264 m+s.\nWe take S\u2032 = S|D, so, (1) D\u2032 \u2286 D; (2) for any n-ary R \u2208 S, RS \u2032 = RS|Dn , then, for all\na1, \u00b7 \u00b7 \u00b7 , an \u2208 D, R S\n\u2032\na1, \u00b7 \u00b7 \u00b7 , an iff R Sa1, \u00b7 \u00b7 \u00b7 , an; (3) \u03d5 is function-free; (4) for any c \u2208 S, c\nS \u2032\n= c.\nTo make M\u2032 = (S\u2032, \u03b2). It is easy to verify: if M( b1\u00b7\u00b7\u00b7bs x1\u00b7\u00b7\u00b7xs ) |= \u2200y1 . . . \u2200yt\u03c8, then M\u2032( b1\u00b7\u00b7\u00b7bs x1\u00b7\u00b7\u00b7xs ) |=\n\u2200y1 . . . \u2200yt\u03c8, so M\u2032 |= \u03d5.\nThus M\u2032 |= \u03d5 with |D\u2019| \u2264 m+s.\nLemma 2.14 For an Schonfinkel-Bernays expression:\n\u03d5 := \u2203x1 . . . \u2203xs\u2200y1 . . . \u2200yt\u03c8(x1 . . . xs, y1 . . . yt, a0 . . . am\u22121),\nthe following are equivalent:\n(1) Sat \u2203x1 . . .\u2203xs\u2200y1 . . . \u2200yt\u03c8(x1 . . . xs, y1 . . . yt, a0 . . . am\u22121). (2) There are constants c1, . . . , cs \u2208 T S0 , such that\nSat \u2200y1 . . .\u2200yt\u03c8( c1\u00b7\u00b7\u00b7cs x1\u00b7\u00b7\u00b7xs , y1 . . . yt, a0 . . . am\u22121).\nProof. This is a corollary of Theorem 2.9.\nLemma 2.15. For an Schonfinkel-Bernays expression:\n\u03d5 := \u2203x1 . . . \u2203xs\u2200y1 . . . \u2200yt\u03c8(x1 . . . xs, y1 . . . yt, a0 . . . am\u22121).\nThe following are equivalent:\n(1) Sat \u2203x1 . . .\u2203xs\u2200y1 . . . \u2200yt\u03c8(x1 . . . xs, y1 . . . yt, a0 . . . am\u22121). (2) There are constants c1, . . . , cs \u2208 T S 0 , such that\nSat \u03c0(GI(\u03d5)) := {\u03c0(\u03c8( c1\u00b7\u00b7\u00b7cs x1\u00b7\u00b7\u00b7xs , u1\u00b7\u00b7\u00b7ut y1\u00b7\u00b7\u00b7yt , a0 . . . am\u22121))|u1, . . . , ut \u2208 T S0 }.\nProof. Because \u2200y1 . . .\u2200yt\u03c8( c1\u00b7\u00b7\u00b7cs x1\u00b7\u00b7\u00b7xs , y1 . . . yt, a0 . . . am\u22121) is quantifier-free, according to Theorem\n2.14 and Corollary A.28, the conclusion is obtained.\nTheorem 2.16. For an Schonfinkel-Bernays expression:\n\u03d5 := \u2203x1 . . . \u2203xs\u2200y1 . . . \u2200yt\u03c8(x1 . . . xs, y1 . . . yt, a0 . . . am\u22121).\nThe following are equivalent:\n(1) Sat \u2203x1 . . .\u2203xs\u2200y1 . . . \u2200yt\u03c8(x1 . . . xs, y1 . . . yt, a0 . . . am\u22121); (2) There are constants c1, . . . , cs \u2208 T S0 , such that\nSat \u2200y1 . . .\u2200yt\u03c8( c1\u00b7\u00b7\u00b7cs x1\u00b7\u00b7\u00b7xs , y1 . . . yt, a0 . . . am\u22121);\n(3) There are constants c1, . . . , cs \u2208 T S 0 , such that\nSat \u03c0(GI(\u03d5)) := {\u03c0(\u03c8( c1 \u00b7 \u00b7 \u00b7 cs x1 \u00b7 \u00b7 \u00b7xs , u1 \u00b7 \u00b7 \u00b7ut y1 \u00b7 \u00b7 \u00b7 yt , a1 . . . am))|u1, . . . , ut \u2208 T S 0 }.\nTheorem 2.17. For an Schonfinkel-Bernays expression:\n\u03d5 := \u2203x1 . . . \u2203xs\u2200y1 . . . \u2200yt\u03c8(x1 . . . xs, y1 . . . yt, a0 . . . am\u22121).\nThe following are equivalent:\n(1) \u2203x1 . . . \u2203xs\u2200y1 . . .\u2200yt\u03c8(x1 . . . xs, y1 . . . yt, a0 . . . am\u22121) is satisfiable in the first-order logic.\n(2) There are constants c1, . . . , cs \u2208 T S0 , such that\n\u2200y1 . . . \u2200yt\u03c8( c1 \u00b7 \u00b7 \u00b7 cs x1 \u00b7 \u00b7 \u00b7xs , y1 . . . yt, a0 . . . am\u22121).\nis satisfiable in the first-order logic. (3) There are constants c1, . . . , cs \u2208 T S0 , such that\n\u03c0(GI(\u03d5)) := {\u03c0(\u03c8( c1 \u00b7 \u00b7 \u00b7 cs x1 \u00b7 \u00b7 \u00b7xs , u1 \u00b7 \u00b7 \u00b7ut y1 \u00b7 \u00b7 \u00b7 yt , a1 . . . am))|u1, . . . , ut \u2208 T S 0 }\nis satisfiable in the propositional logic.\nRemark 2.18. Theorem 2.16 and 2.17 may also be called the decomposition theorem, this theorem transforms the satisfiability problem of an Schonfinkel-Bernays-expression in the first-order logic into the satisfiable problem of a collection of propositional formulas in the propositional logic. We verify that an Schonfinkel-Bernays-expression is satisfiable if and only if we verify that there exist constants c1, . . . , cs \u2208 T S 0 such that every propositional formula in the set \u03c0(GI(\u03d5)) is satisfiable.\nDefinition 2.19. LSB is used to express the satisfiability problem for Schonfinkel-Bernays expres-\nsion.\nLemma 2.20. LSB \u2208 NEXP -complete. The conclusion of lemma 2.20 can be referred to Theorem 20.3 in reference [13] and Theorem 8.1 in\n[14].\nDefinition 2.21. A formula \u03d5 whose expression has the following form is called an segment of\nSchonfinkel-Bernays expression:\n\u03d5 := \u2200y1 . . . \u2200yt\u03c8\nwith the following properties:\n(1) \u03c8 contains only the variables {y1, y2, . . . yt}; (2) \u03c8 is quantifier-free,\n(3) \u03c8 equality-free,\n(4) \u03c8 function-free,\nDefinition 2.22. A language is said to be segments of Schonfinkel-Bernays language if all its\nformulas are of the form of segment of Schonfinkel-Bernays expressions, denoted FSSB.\nTheorem 2.23. Let \u03d5 = \u2200y1 . . . \u2200yt\u03c8 be an segment of Schonfinkel-Bernays expression with\n|con(\u03d5)| = m, The following are equivalent:\n(1) Sat \u03d5; (2) There exists an finite interpretation M\u2032 such that M\u2032 \u03d5 with |M\u2032| \u2264 m.\nProof: The proof is similar to Theorem 2.13.\nTheorem 2.24. For an segment of Schonfinkel-Bernays expression:\n\u03d5 := \u2200y1 . . . \u2200yt\u03c8(y1 . . . yt, a0 . . . am\u22121).\nThe following are equivalent:\n(1) \u2200y1 . . . \u2200yt\u03c8(. . . yt, a0 . . . am\u22121) is satisfiable in the first-order logic. (2) The set of propositional logical formulas\n\u03c0(GI(\u03d5)) := {\u03c0(\u03c8( u1 \u00b7 \u00b7 \u00b7ut y1 \u00b7 \u00b7 \u00b7 yt , a1 . . . am))|u1, . . . , ut \u2208 T S 0 }\nis satisfiable in the propositional logic.\nRemark 2.25. Theorem 2.24 may also be called the decomposition theorem, this theorem transforms the satisfiability problem of an segment of Schonfinkel-Bernays-expression in the first-order logic into the satisfiable problem of a collection of propositional formulas in the propositional logic. We verify that an segment of Schonfinkel-Bernays-expression is satisfiable if and only if we verify that every propositional formula in the set \u03c0(GI(\u03d5)) is satisfiable.\nDefinition 2.26. LSSB is used to express the satisfiability problem for segments of Schonfinkel-\nBernays expression.\nLemma 2.27. LSSB \u2208 EXP -complete. The proof of Lemma 2.27 is similar to the proof of Theorem 20.3 in reference [13]."
        },
        {
            "heading": "3 Main conclusion",
            "text": "Definition 3.1 LFP is used to express the satisfiability problem of a set of finite propositional\nformulas.\nLemma 3.2. LFP \u2208 NP-complete. Proof: Given a set of propositional formulas, the satisfiability problem asks whether there exists\nan assignment of truth values to the propositional variables such that all formulas in the set are true.\nFirst, this problem is an NP problem because if given a candidate solution, it can be verified in\npolynomial time whether the solution is a satisfiable solution of the given set of formulas.\nSecond, this problem has also been shown to be NP-complete because it is possible to reduce the polynomial time of the 3SAT problem to this problem. Given a 3SAT problem, we can convert it to an equivalent set of formulas, where each formula is made up of three characters. Thus, the problem is NP-hard and belongs to NP and is therefore NP-complete.\nDefinition 3.3. A formula \u03d5 whose expression has the following form is called an segments of\nSchonfinkel-Bernays expression:\n\u03d5 := \u2200y1 . . . \u2200yt\u03c8\nwith the following properties:\n(1) \u03c8 contains only the variables {y1, y2, . . . yt}; (2) \u03c8 is quantifier-free;\n(3) \u03c8 equality-free;\n(4) \u03c8 function-free.\nDefinition 3.4. LSSB is used to express the satisfiability problem for an segments of Schonfinkel-\nBernays expression.\nLemma 3.5. LSSB \u2208 EXP-complete. The proof is similar to the proof of Theorem 20.3 in reference [13].\nTheorem 3.6. For an segment of Schonfinkel-Bernays expression:\n\u03d5 := \u2200y1 . . . \u2200yt\u03c8(y1 . . . yt, a0 . . . am\u22121).\nThe following are equivalent:\n(1) \u03d5 := \u2200y1 . . . \u2200yt\u03c8(y1 . . . yt, a0 . . . am\u22121) is satisfiable in the first-order logic; (2) \u03c0(GI(\u03d5)) := {\u03c0(\u03c8(u1\u00b7\u00b7\u00b7ut y1\u00b7\u00b7\u00b7yt , a1 . . . am))|u1, . . . , ut \u2208 T S 0 } is propositionally satisfiable in the propo-\nsitional logic.\nTheorem 3.6 is theorem 2.24\nTheorem 3.7. Let LSSB be used to express the satisfiability problem for an segments of SchonfinkelBernays expression, and LFP be used to express the satisfiability problem of a set of finite propositional formulas. Then, there exists a reduction f from LSSB to LFP running time not exceeding exponential time O(2n k ).\nProof. Let\u2019s use FSSB to denote the class of all segments of Schonfinkel-Bernays expressions, FFP\ndenote the class of all set of finite propositional formulas.\nAccording to theorem 3.6, define f = \u03c0 \u25e6GI : FSSB \u2192 FFP as follows: For \u03d5 := \u2200y1 . . . \u2200yt\u03c8(y1 . . . yt, a0 . . . am\u22121) \u2208 FSSB, define\nf(\u03d5) := \u03c0(GI(\u03d5)) = {\u03c0(\u03c8( u1 \u00b7 \u00b7 \u00b7ut y1 \u00b7 \u00b7 \u00b7 yt , a1 . . . am))|u1, . . . , ut \u2208 T S 0 },\nthen f(\u03d5) \u2208 FFP , so f is a mapping from FSSB to FFP .\nWe define a reduction f from LSSB to LFP as follows. For \u03d5 := \u2200y1 . . . \u2200yt\u03c8(y1 . . . yt, a0 . . . am\u22121) \u2208 FFSB, and < \u03d5 > is an encoding of \u03d5. Construct a deterministic three-tapes Turing machine M1 as follows: M1 = \u201dOn input < \u03d5 > on the first-tape, it\u2019s an encoding of \u03d5, and assuming | < \u03d5 > | = n, n is a\nnatural number:\n1. Scan the input from left to right on the first tape to be sure that the input has form \u03d5 := \u2200y1 . . . \u2200yt\u03c8 with < \u03c8 > contains only t variables {y1, y2, . . . , yt}, < \u03c8 > is quantifier-free, < \u03c8 > equality-free and < \u03c8 > function-free, reject if it isn\u2019t.\n2. Return the head to the left-hand end of the tape.\n3. Scan the input from left to right, search for all constant symbols, if all constant symbols are {a0, a1, . . . , am\u22121}(if no constant symbols exist, add a constant symbol a0), and print all constant symbols on the second tape.\n4. In accordance with the sequence of constant symbols on the second tape, the constant symbols are arranged in lexicographical order in a sequence of length t, where repetition is allowed, there are a total of mt sequences, the ith sequence is represented by (ai,1ai,2 . . . ai,t), where i = 1, . . . ,m t, and all the sequences are written on the third tape in lexicographical order, separated by the symbol \u266f.\n5. Delete all constant symbols from the second tape.\n6. First write the symbol \u266f on the leftmost end of the second tape. Execute the following subalgo-\nrithms:\n(1) Copy the < \u03d5 > on the first tape after the \u266f symbol. The following sub-algorithms are performed:\n1) Read the 1st constant symbol a1,1 of the 1st sequence (a1,1a1,2 . . . a1,t) from the third tape, delete the first universal quantifier \u2200 and the first variable y1 in < \u03d5 >, replace all y1 in < \u03d5 > with a1,1, and replace a1,1 on the third tape with \u02d9a1,1.\n2) Read the 2nd constant symbol a1,2 of the first sequence (a1,1a1,2 . . . a1,t) from the third tape, delete the 2nd universal quantifier \u2200 and the 2nd variable y2 in < \u03d5 >, replace all y2 in < \u03d5 > with a1,2, and replace a1,2 on the third tape with \u02d9a1,2.\nBy the same token, delete t prefix universal quantifiers of < \u03d5 > and t prefix variables y1, y2,, and\nreplace all occurrences of yi in < \u03d5 > with a1,i, i = 1, . . . , t.\nt+1) Followed by the symbol \u266f.\n(2) Copy the < \u03d5 > on the first tape after the new \u266f symbol on the second tape. The following\nsub-algorithms are performed:\n1) Read the 1st constant symbol a2,1 of the 2nd sequence (a2,1a2,2 . . . a2,t) from the third tape, delete the first universal quantifier \u2200 and the first variable y1 in < \u03d5 >, replace all y1 in < \u03d5 > with a2,1, followed by the symbol \u266f, and replace a2,1 on the third tape with \u02d9a2,1.\n2) Read the 2nd constant symbol a2,2 of the first sequence (a2,1a2,2 . . . a2,t) from the third tape, delete the 2nd universal quantifier \u2200 and the 2nd variable y2 in < \u03d5 >, replace all y2 in < \u03d5 > with a2,2, followed by the symbol \u266f, and replace a2,2 on the third tape with \u02d9a2,2.\nBy the same token, delete t prefix universal quantifiers of < \u03d5 > and t prefix variables y1, y2, . . . yt,\nand replace all occurrences of yi in < \u03d5 > with a2,i, i = 1, . . . , t.\nt+1) Followed by the symbol \u266f. (mt) Copy the < \u03d5 > on the first tape after the new \u266f symbol on the second tape. By the same token, delete t prefix universal quantifiers of < \u03d5 > and t prefix variables y1, y2, . . . yt, and replace all occurrences of yi in < \u03d5 > with amt,i, i = 1, . . . , t. Followed by the symbol \u266f.\n7. Scan the second tape and replace all relational symbols Raj1aj2 . . . ajn with propositional (Boolean) variables that contain constant symbols. The same relation symbol with the same constant symbol is represented by the same propositional variable.\n8. Delete all symbols from the first tape and the third tape.\n9. Copy all symbols from the second tape to the first tape.\nAnalyze the running time of M1: Steps 1,2,3,5,6 and 8 require polynomial time O(n), steps 4, 7 and 9 require exponent timeO(2n k ). The total required exponential time O(2n k ).\nDuring the calculation, it can be seen that: On every input an encoding < \u03d5 > of \u03d5 \u2208 FSSB on the\nfirst tape, halts with just an encoding< f(\u03d5) >= f(< \u03d5 >) of f(\u03d5) := {\u03c0(\u03c8(u1\u00b7\u00b7\u00b7ut y1\u00b7\u00b7\u00b7yt , a1 . . . am))|u1, . . . , ut \u2208 T S0 } \u2208 FFP on the first tape. According to theorem 3.6, we have\n< \u03d5 >\u2208 LSSB \u21d4 f(< \u03d5 >) \u2208 LFP .\nBecause every t(n) time a deterministic multitapes Turing machine has an equivalent O(t2(n)) time a deterministic single-tape Turing machine, so there exists a deterministic single tape Turing machine M2 reduction f from LSSB to LFP , running time not exceeding exponential time O(2n k ), and\n< \u03d5 >\u2208 LSSB \u21d4 f(< \u03d5 >) \u2208 LFP .\nTheorem 3.8. If LSSB is used to express the satisfiability problem for segments of SchonfinkelBernays expression, and LFP is used to express the satisfiability problem of a set of finite propositional formulas. Then, there exist a polynomial time O(poly(n)) reduction f from LSSB to LFP .\nProof. According to theorem 3.7, there exist f = \u03c0 \u25e6GI : LSSB \u2192 LFP is a reduction of LSSB to\nLFP , running time not exceeding exponential time O(2n k ), so, there exists a deterministic single tape Turing machine M2 that can compute the function f , running time not exceeding exponential time O(2n k ), and\n< \u03d5 >\u2208 LSSB \u21d4 f(< \u03d5 >) \u2208 LFP .\nThe following proof is based on two things: First, the encoding of an instance of any problem is not unique. The second is, the proof refers to the \u201dexponentially padded version\u201d of theorem 20.1 in reference [13].\nConsider the encoding of the \u201dexponentially padded version\u201d of LSSB:\nL = {< \u03d5 > \u22942 n\u2212|<\u03d5>| | \u03d5 \u2208 LSSB},\nhere \u201d\u2294\u201d is the \u201dpseudo-blank symbol\u201d, and < \u03d5 > \u22942 n\u2212|<\u03d5>| is the re-encoding of \u03d5 \u2208 LSSB, which is the new encoding of \u03d5 by adding 2n \u2212 | < \u03d5 > | \u201dpseudo-blank symbols\u201d after the original encoding < \u03d5 > of \u03d5 (since the encoding of \u03d5 is not unique) to bring the total length of the string to 2n.\nConstruct a deterministic single-tape Turing machine M as follows:\n1. First check whether its input string ends with exponentially many pseudo-blank symbols. If not,\nhalts and output blanks. Otherwise go to step 2.\n2. M simulates the running of M2 on input < \u03d5 >. 3. If M2 halts, then M halts and outputs < f(\u03d5) > \u2294O(2 n) on the tape, which is the new encode of\nf(\u03d5).\nAnalyze the running time of M : It can be seen that M simulating the running of M2 on < \u03d5 >\n\u22942 n\u2212|<\u03d5>| takes at most exponential time O(2n k ), and the running time of M is polynomial time O(poly(n)) relative to the length 2n of input < \u03d5 > \u22942 n\u2212|<\u03d5>|.\nTheorem 3.9. NP = EXP .\nProof. According to theorem 3.8, LSSB can be reduced to LFP in polynomial time O(poly(n)), because LFP belongs to NP(LFP \u2208 NP), so LSSB also belongs to NP(LSSB \u2208 NP), Because LSSB belongs to EXP -complete(LSSB \u2208 EXP -complete), so EXP is included in NP , that is, EXP \u2286 NP . Because NP \u2286 EXP , so NP = EXP .\nTheorem 3.10. P 6= NP .\nProof. Since P 6= EXP , and NP = EXP , so P 6= NP .\nTheorem 3.11. EXP 6= NEXP .\nProof. Since NP 6= NEXP , and NP = EXP , so EXP 6= NEXP .\nFinally, we get the main conclusion:\nTheorem 3.12.\n1. P 6= NP ;"
        },
        {
            "heading": "2. NP = EXP ;",
            "text": ""
        },
        {
            "heading": "3. EXP 6= NEXP .",
            "text": "Remark 3.13. The three conclusions of Theorem 3.12 are three open problems in mathematics\nand computer science.\nAppendix A. First-Order Languages This section mainly states the terms, symbols and results\nof first-order logic related to this paper, the important references are [16], [17], etc."
        },
        {
            "heading": "A.1. Syntax of First-Order Languages",
            "text": "Definition A.1. An alphabet A is a nonempty set of symbols.\nDefinition A.2. The alphabet of a first-order language L contains the following symbols:\n(1) v0,v1,v2,. . . (variables); (2) \u00ac,\u2227,\u2228,\u2192,\u2194(not, and, or, if-then, if and only if);\n(3) \u2200,\u2203(for all, there exists);\n(4) \u2261(equality symbol);\n(5) ),( (parentheses);\n(6) (a) for every n>1 a (possibly empty) set of n-ary relation symbols;\n(b) for every n>1 a (possibly empty) set of n-ary function symbols;\n(c) a (possibly empty) set of constants.\nRemark. (1) By A we denote the set of symbols listed in (1) through (5).Let S be the (possibly empty) set of symbols from (6).The symbols listed under (6) must, of course, be distinct from each other and from the symbols in A.\n(2) The set S determines a first-order language. We call AS := A \u22c3 S the alphabet of this language\nand S its symbol set.\n(3) Henceforth we shall use the letters P,Q,R,... for relation symbols, f, g, h,... for function symbols,\nc, c0, c1,... for constants, and x, y, z,... for variables.\nDefinition A.3. S -terms are precisely those strings in A\u2217S which can be defined inductively as\nfollows:\n(T1) Every variable is an S -term.\n(T2) Every constant in S is an S-term.\n(T3) If the strings t1,...,tn are S -terms and f is an n-ary function symbol in S, then ft1 ...tn is also\nan S -term.\nWe denote the set of S -terms by T S. Definition A.4. S -formulas are precisely those strings of A\u2217S which can be defined inductively as\nfollows:\n(F1) If t1 and t2 are S -terms, then t1 \u2261 t2 is an S -formula. (F2) If t1,...,tn are S -terms and R is an n-ary relation symbol in S, then Rt1 ...tn is an S -formula. (F3) If \u03d5 is an S -formula, then \u00ac\u03d5 is also an S -formula.\n(F4) If \u03d5 and \u03c8 are S -formulas, then (\u03d5\u2227\u03c8), (\u03d5\u2228\u03c8) , (\u03d5\u2192\u03c8) , and (\u03d5\u2194\u03c8) are also S -formulas.\n(F5) If \u03d5 is an S -formula and x is a variable, then \u2200x\u03d5 and \u2203x\u03d5 are also S -formulas. S -formulas derived using (F1) and (F2) are called atomic formulas because they are not formed by combining other S -formulas. The formula \u00ac\u03d5 is called the negation of \u03d5 ,and (\u03d5\u2227\u03c8), (\u03d5\u2228\u03c8) ,and (\u03d5\u2192\u03c8) are called, respectively, the conjunction,disjunction, implication, and bi-implication of \u03d5 and \u03c8.\nDefinition A.5. By LS we denote the set of S -formulas. This set is called the first-order language\nassociated with the symbol set S.\nNotation. Instead of S -terms and S -formulas, we often speak simply of terms and formulas when the reference to S is either clear or unimportant. For terms we use the letters t, t0, t1,..., and for formulas the letters \u03d5, \u03c8,... .\nDefinition A.6. The function var(more precisely, varS : T S \u2192 S) is defined inductively as follows:\nvar(x) := x\nvar(c) := \u2205\nvar(ft1 ...tn) := var(t1)\u222a...\u222avar(tn).\nWe give a definition by induction on formulas of the set of free variables in a formula \u03d5; we denote\nthis set by free(\u03d5). Again, we fix a symbol set S.\nDefinition A.7. The function free(more precisely, freeS : L S \u2192 S) is defined inductively as\nfollows:\nfree(t1 \u2261 t2) := var(t1) \u222a var(t2)\nfree(Rt1 ...tn) := var(t1) \u222a . . . \u222a var(tn)\nfree(\u00ac\u03d5) := free(\u03d5)\nfree((\u03d5 \u2217 \u03c8)) := free(\u03d5)\u222a free(\u03c8) for \u2217 = \u2227,\u2228,\u2192,\u2194\nfree(\u2200x\u03d5) := free(\u03d5) \\ {x}\nfree(\u2203x\u03d5) := free(\u03d5) \\ {x}.\nDefinition A.8. The function con(more precisely, conTS : T S \u2192 S) is defined inductively as\nfollows:\ncon(x) := \u2205\ncon(c) := c\ncon(ft1 ...tn) := con(t1)\u222a...\u222a con(tn).\nDefinition A.9. The function con(more precisely, conLS : L S \u2192 S) is defined inductively as\nfollows:\ncon(t1 \u2261 t2) := con(t1) \u222a con(t2)\ncon(Rt1 ...tn) := con(t1) \u222a . . . \u222a con(tn)\ncon(\u00ac\u03d5) := con(\u03d5)\ncon((\u03d5 \u2217 \u03c8)) := con(\u03d5)\u222a con(\u03c8) for \u2217 = \u2227,\u2228,\u2192,\u2194\ncon(\u2200x\u03d5) := con(\u03d5)\ncon(\u2203x\u03d5) := con(\u03d5)\nNotation. In a first-order language L, We denote by LSn the set of S -formulas in which the variables\noccurring free are among v0,. . .,vn\u22121:\nLSn := {\u03d5 | \u03d5 is an S -formula and free(\u03d5) \u2286 {v0,. . .,vn\u22121}}.\nIn particular LS0 is the set of S -sentences. Notation. In analogy to LSk , for k \u2208 N , we define the set\nTSk := {t \u2208 T S |var(t) \u2286 {v0, \u00b7 \u00b7 \u00b7 , vk\u22121}} .\nDefinition A.10. A formula \u03d5 whose expression has the following form is called an Schonfinkel-\nBernays expression:\n\u03d5 := \u2203x1 . . .\u2203xs\u2200y1 . . . \u2200yt\u03c8\nwith the following properties:\n(1) \u03c8 contains only variables {x1, . . . , xs, yt, . . . , yt}; (1) \u03c8 is quantifier-free;\n(2) \u03c8 equality-free;\n(3) \u03c8 function-free.\nIt is not hard to see that the following conclusion is true.\nRemark.(1) it is in prenex form with a sequence of existential quantifiers followed by a sequence of\nuniversal ones,\n(2) free(\u03c8)={x1, . . . , xs, y1, . . . , yt}, In conjunction with condition (1), the condition ensures that\nthe variables in \u03c6 are not redundant.\n(3) con(\u03c8)= {a0, a1, . . . , am\u22121}. Because \u03d5 is of finite length, it can be assumed that \u03d5 contains a finite number of constant symbols, on account of con(\u03d5)=con(\u03c8), so that condition 5 is reasonable. If \u03d5 does not contain any constant symbols, then the constant symbol a0 is added.\n(4) For a Schonfinkel-Bernays expression \u03d5 = \u2203x1 . . .\u2203xs\u2200y1 . . . \u2200yt\u03c8, when k > 1, T S k = {x1, . . . , xs, y1, . . . , xt, a0, . . . , am\u2212\nwhen k = 0, TS0 = {a0, . . . , am\u22121}.\n(5) More precisely, \u03c8 := \u03c8(x1, . . . , xs, y1, . . . , xt, a0, . . . , am\u22121). Definition A.11. A language is said to be Schonfinkel-Bernays language if all its fornulas are of\nthe form of Schonfinkel-Bernays expressions, denoted FSB.\nA.2. Semantics of First-Order Languages\nDefinition A.12. An S -structure is a pair S = (D,m) with the following properties:\n(1) D is a nonempty set, the domain or universe of S.\n(2) m is a map defined on S satisfying:\n(a) for every n-ary relation symbol R \u2208 S, m(R) is an n-ary relation on D,\n(b) for every n-ary function symbol f \u2208 S, m(f ) is an n-ary function on D,\n(c) for every constant c in S, m(c) is an element of D.\nRemark. Instead of m(R), m(f), and m(c), we shall frequently write RS, fS,and cS. For structures M,U,B,... we shall use D,A,B,... to denote their domains. Instead of writing an S -structure in the form S = (D,m), we shall often replace a by a list of its values. For example, we write an {R, f, g}-structure as S = (D,RS, f S, gS).\nDefinition A.13. An assignment in an S -structure S is a map \u03b2 : {vn|n \u2208 N \u2192 D} from the set\nof variables into the domain D.\nNow we can give a precise definition of the notion of interpretation:\nDefinition A.14. An S -interpretation M is a pair (S,\u03b2) consisting of an S -structure S and an\nassignment \u03b2 in S.\nRemark. When the particular symbol set S in question is either clear or unimportant, we shall\nsimply speak of structures and interpretations instead of S -structures and S -interpretations.\nNotation. If \u03b2 is an assignment in S, a \u2208D, and x is a variable, then let \u03b2(a x ) be the assignment\nin S which maps x to a and agrees with \u03b2 on all variables distinct from x :\n\u03b2( a\nx )(y) :=\n \n\n\u03b2(y) ify 6= x\na ify = x.\nFor M = (S,\u03b2), let M(a x ):= (S, \u03b2(a x ))."
        },
        {
            "heading": "A.3. The Satisfaction Relation",
            "text": "The satisfaction relation makes precise the notion of a formula being true under an interpretation. Again we fix a symbol set S. By \u201cterm\u201d \u201cformula\u201d, or \u201cinterpretation\u201d we always mean \u201cS -term\u201d, \u201cS -formula\u201d, or \u201cS -interpretation\u201d. As a preliminary step we associate with every interpretation M = (S,\u03b2) and every term t an element M(t) from the domain D. We define M(t) by induction on terms.\nDefinition A.15.(1) For a variable x let M(x ) := \u03b2(x ). (2) For a constant c\u2208S let M(c) := cS.\n(3) For an n-ary function symbol f \u2208 S and terms t1,...,tn let\nM(f t1...tn ):=f S(M(t1),...,M(tn)).\nDefinition A.16. Using induction on formulas \u03d5, we give a definition of the relation M is a model of \u03d5, where M is an arbitrary interpretation. If M is a model of \u03d5, we also say that M satisfies \u03d5 or that \u03d5 holds in M, and we write M |=\u03d5.\nDefinition A.17. For all interpretations M = (S,\u03b2) we inductively define\nM |= t1\u2261t2 :iff M (t1)=M(t2)\nM |= Rt1...tn :iff R S M(t1)...M(tn)(i.e.,R S holds for M(t1),...,M(tn)) M |=\u00ac\u03d5 :iff not M |=\u03d5\nM |=(\u03d5\u2227\u03c8) :iff M |=\u03d5 and M|=\u03c8\nM |=(\u03d5\u2228\u03c8) :iff M |=\u03d5 or M |=\u03c8\nM |=(\u03d5\u2192\u03c8) :iff if M |=\u03d5 , then M |=\u03c8\nM |=(\u03d5\u2194\u03c8) :iff M |=\u03d5 if and only if M |=\u03c8 M |=\u2200x\u03d5 :iff for alla \u2208D,M(a x )|=\u03d5 M |=\u2203x\u03d5 :iff there is an a \u2208D such that M(a x )|=\u03d5. Definition A.18.Given a set \u03a6 of S -formulas, we say that M is a model of \u03a6 and write M |=\u03a6 if\nM |=\u03d5 for all \u03d5 \u2208 \u03a6."
        },
        {
            "heading": "A.4. The Consequence Relation",
            "text": "Definition A.19. Let \u03a6 be a set of formulas and \u03d5 a formula. We say that \u03d5 is a consequence of \u03a6 (written: \u03a6|= \u03d5) iff every interpretation which is a model of \u03a6 is also a model of \u03a6. Instead of \u201c{\u03c8} |= \u03d5\u201d, we shall also write \u201c\u03c8 |= \u03d5\u201d.\nDefinition A.20. The formulas which are derivable by means of the following calculus are called\nuniversal formulas:\n(1) \u03d5 if \u03d5 is quantifier-free; (2) \u03d5,\u03c8(\u03d5\u2217\u03c8) for \u2217 = \u2227, \u2228; (3) \u03d5\u2200x\u03d5 . Remark. Every universal formula is logically equivalent to a formula of the form \u2200x1...\u2200xn\u03c8 with\n\u03c8 quantifier-free.\nLet S be a fixed symbol set.\nDefinition A.21A. (1)\nx( t0...tr\nx0...xr ) :=\n \n\nx if x 6= x0, ..., x 6= xr ti if x = xi.\n(2) c( t0...tr x0...xr ) := c (3) [f t \u2032\n1...t \u2032 n]( t0...tr x0...xr ) := f t \u2032 1( t0...tr x0...xr )...t \u2032 n( t0...tr x0...xr ).\nDefinition A.21B. (a)[t \u2032\n1 \u2261 t \u2032 2] t0...tr x0...xr := t \u2032 1 t0...tr x0...xr \u2261 t \u2032 2 t0...tr x0...xr\n(b)[Rt \u2032 1 \u00b7 \u00b7 \u00b7 t \u2032 n] t0...tr x0...xr := Rt \u2032 1 t0...tr x0...xr \u00b7 \u00b7 \u00b7 t \u2032 n t0...tr x0...xr (c)[\u00ac\u03d5] t0...tr x0...xr := \u00ac[\u03d5 t0...tr x0...xr ] (d)(\u03d5 \u2228\u03a8) t0...tr x0...xr := (\u03d5 t0...tr x0...xr \u2228\u03a8 t0...tr x0...xr ) (e)Suppose xi1 , \u00b7 \u00b7 \u00b7 , xis (i1 < \u00b7 \u00b7 \u00b7 < is) are exactly the variables xi among the x0, ..., xr , such that\nxi \u2208 free(\u2203x\u03d5) and xi 6= ti.\nIn particular, x 6= xi1 , \u00b7 \u00b7 \u00b7 , x 6= xis . Then set\n[\u2203x\u03d5] t0...tr x0...xr := \u2203u[\u03d5 ti1 ...tisu xi1 ...xisx ],\nwhere u is the variable x if x does not occur in ti1 , ..., tis ; otherwise u is the first variable in the list\nv0, v1, v2, ... which does not occur in \u03d5, ti1 , ..., tis .\nBy introducing the variable u we ensure that no variable occurring in ti1 , ..., tis falls within the scope of a quantifier. In case there is no xi such that xi \u2208 free(\u2203x\u03d5) and xi 6= ti, we have s = 0, and from (e) we obtain\n[\u2203x\u03d5] t0...tr x0...xr = \u2203x[\u03d5x x ],\nwhich is \u2203x\u03d5.\nLet x0, ..., xr be pairwise distinct and suppose M = (S,\u03b2) is an interpretation, and a0, ..., ar \u2208 D ;\nthen let \u03b2( a0...ar x0...xr ) be the assignment in S with\n\u03b2( a0...ar x0...xr )(y):=\nand\nM( a0...ar x0...xr ) := (S, \u03b2( a0...ar x0...xr )).\nLemma A.22. (1) For every term t,\nM(t( t0...tr x0...xr )) = M(M(t0)...M(tr) x0...xr )(t)\n(b) For every formula \u03d5,\nM |=\u03d5( t0...tr x0...xr ) iff M (M(t0)...M(tr) x0...xr ) |= \u03d5."
        },
        {
            "heading": "A.5. Henkin\u2019s Theorem",
            "text": "Let \u03a6 be a set of formulas. We define an interpretation J\u03a6 = (T\u03a6,\u03b2\u03a6). For this purpose we first\nintroduce a binary relation \u223c on the set T s of S -terms by\nt1 \u223c t2 :iff \u03a6 \u22a2 t1 \u2261 t2. Lemma A.23. (1) \u223c is an equivalence relation.\n(2) \u223c is compatible with the symbols in S in the following sense: If t1 \u223c t \u2032 1,...,tn \u223c t \u2032 n, then for n-ary f \u2208 S\nft1...tn \u223c ft \u2032 1,...,t \u2032 n\nand for n-ary R \u2208 S\n\u03a6 \u22a2 Rt1...tn iff \u03a6 \u22a2 Rt \u2032 1, ..., t \u2032 n.\nThe proof uses the rule (\u2261).\nLet t be the equivalence class of t :\nt := { t \u2032 \u2208 TS | t \u223c t \u2032 }\nand let T\u03a6 (more precisely: T\u03a6,s ) be the set of equivalence classes:\nT\u03a6 := { t | t \u2208 Ts } .\nThe set T\u03a6 is not empty. We define the S -structure T\u03a6 over T\u03a6 , the so-called term structure\ncorresponding to \u03a6, by the following clauses:\n(1) For n-ary R \u2208 S,\nRT \u03a6\nt1...tn :iff \u03a6 \u22a2 Rt1...tn.\n(2) For n-ary f \u2208 S,\nf T \u03a6\n(t1, ..., tn) :=ft1...tn.\n(3) For c \u2208 S , cT \u03a6 := c .\nBy Lemma 3.23(2) the conditions in (1) and (2) are independent of the choice of the representatives\nt1, \u00b7 \u00b7 \u00b7 , tn of t1, \u00b7 \u00b7 \u00b7 , tn ,hence RT \u03a6 and f T \u03a6 are well-defined.\nFinally, we fix an assignment \u03b2\u03a6 by (4) \u03b2\u03a6(x) : x. We call J\u03a6 := (T\u03a6, \u03b2\u03a6) the term interpretation associated with \u03a6 . Lemma A.24. (1) For all t, J\u03a6(t) = t .\n(2) For every atomic formula \u03d5 ,\nJ\u03c6 |= \u03d5 iff \u03c6 \u22a2 \u03d5.\n(3) For every formula \u03d5 and pairwise distinct variables x1, \u00b7 \u00b7 \u00b7 , xn,\n(a) J\u03a6 |= \u2203x1 \u00b7 \u00b7 \u00b7 \u2203xn\u03d5 iff there are t1, \u00b7 \u00b7 \u00b7 , tn \u2208 TS with J\u03a6 |= \u03d5( t1\u00b7\u00b7\u00b7tn x1\u00b7\u00b7\u00b7xn )\n(b) J\u03a6 |= \u2200x1 \u00b7 \u00b7 \u00b7 \u2200xn\u03d5 iff for all terms t1, \u00b7 \u00b7 \u00b7 , tn \u2208 TS , J\u03a6 |= \u03d5( t1\u00b7\u00b7\u00b7tn x1\u00b7\u00b7\u00b7xn )."
        },
        {
            "heading": "A.6. Herbrand\u2019s Theorem",
            "text": "In analogy to LSk , for k \u2208 N , we define the set\nTSk := {t \u2208 T S |var(t) \u2286 {v0, \u00b7 \u00b7 \u00b7 , vk\u22121}} .\nWe consider the subset T\u03a6k of T \u03a6 ,\nT\u03a6k := {t|t \u2208 T S k } ,\nthat consists of the term classes t with t \u2208 TSk . To ensure in case k = 0 the existence of such a\nterm, i.e., that TSk is nonempty, we assume from now on:\nIf k = 0 , then S contains at least one constant. We can get a substructure J\u03a6k = (T \u03a6 k ,\u03b2 \u03a6 k ) of J \u03a6 = (T\u03a6,\u03b2\u03a6), and, the following results hold: Lemma A.25. For a set \u03a6 \u2286 LSk of universal formulas in prenex normal form, the following are\nequivalent:\n(1) \u03a6 is satisfiable.\n(2) The set \u03a60 is satisfiable where \u03a60 := {\u03d5( m x | m t )|\u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm\u03d5 \u2208 \u03a6, \u03d5 quantifier-free and t1, \u00b7 \u00b7 \u00b7 , tm \u2208 TSk }. In particular, let \u2200x1 . . . \u2200xn\u03d5 \u2208 LSk with \u03d5 quantifier-free, the following are equivalent: (1) Sat \u2200x1 . . .\u2200xn\u03d5. (2) Sat { \u03d5( n x | n\nt) | t1, . . . , tn \u2208 T Sk\n}\n.\nRemark. Writing \u03d5( n x |\nn t) instead of \u03d5( t1\u00b7\u00b7\u00b7tnx1\u00b7\u00b7\u00b7xn ).\nDefinition 3.26. An S-structure H is called Herbrand structure if (1) A = T S0 . (2) For n-ary f \u2208 S and t1, . . . , tn \u2208 T S, fH (t1, . . . , tn) = ft1 . . . tn. (3) For c \u2208 S, cH = c. Remark. For a consistent set \u03a6 of equality-free sentences, T\u03a60 is a Herbrand structure. Remark. For a Herbrand structure H and t \u2208 T S0 we have t H = t. Theorem A.27. Let \u03a6 be a satisfiable set of universal and equality-free sentences. Then \u03a6 has a\nHerbrand model, i.e., a model which is a Herbrand structure.\nCorollary A.28. Let \u03c8 := \u2200x1 . . . \u2200xn\u03d5 \u2208 LS0 with \u03d5 quantifier-free, the following are equivalent: (1) Sat \u2200x1 . . .\u2200xn\u03d5. (2) Sat { \u03d5( n x | n\nt) | t1, . . . , tn \u2208 T S0\n}\n.\nCorollary A.29. Let \u03c8 := \u2200x1 . . . \u2200xn\u03d5 \u2208 LS0 with \u03d5 quantifier-free, if (S, \u03b2) is a model of \u03c8, i.e.,\n(S, \u03b2) |= \u03c8, take J\u03c80 = (T \u03c8 0 , \u03b2) with \u03b2 \u2032(x) = x for all variables x, then (T\u03c80 , \u03b2) |= \u03c8.\nAppendix B. Propositional Logic\nThis section mainly states the terms, symbols and results of propositional Logic related to this\npaper, the important references are [16], [17], etc.\nDefinition B.1. Let Aa be the alphabet{\u00ac,\u2228, ), (} \u222a {p0, p1, p2, . . .} . We define the formulas of the language of propositional logic (the propositional formulas) to be the strings over Aa which are obtained by means of the following rules:\npi (i \u2208 N),\n\u03b1\n\u00ac\u03b1 ,\n\u03b1, \u03b2\n(\u03b1 \u2228 \u03b2) .\nRemark. Again, (\u03b1 \u2227 \u03b2), (\u03b1 \u2192 \u03b2), and (\u03b1 \u2194 \u03b2) are abbreviations for \u00ac(\u00ac\u03b1 \u2228 \u00ac\u03b2), (\u00ac\u03b1 \u2228 \u03b2), and (\u00ac(\u03b1\u2228\u03b2)\u2228\u00ac(\u00ac\u03b1\u2228\u00ac\u03b2)), respectively. For propositional variables we often use the letters p, q, r, . . ., for\npropositional formulas the letters \u03b1, \u03b2, . . ..\nRemark. By PF we denote the set of propositional formulas.\nRemark. For \u03b1 \u2208 PF let pvar (\u03b1) be the set of propositional variables occurring in \u03b1.\npvar(\u03b1) := {p | p occurs in \u03b1} .\nFurthermore, forn \u2265 1 we set\nPFn := {\u03b1 \u2208 PF | pvar(\u03b1) \u2286 {p0, . . . , pn\u22121}} .\nDefinition B.2. A (propositional) assignment is a map b : {pi | i \u2208 N} \u2192 {T, F}. The other\nsemantic notions are defined as in the first-order case:\nThe truth-value \u03b1[b] of a propositional formula \u03b1 under the assignment b is defined inductively by\npi[b] := b (pi)\n\u00ac\u03b1[b] := \u00ac\u0307(\u03b1[b])\n(\u03b1 \u2228 \u03b2)[b] := \u2228\u0307(\u03b1[b], \u03b2[b])\nWe use two functions to define \u201dor\u201d and \u201dnot\u201d respectively as follows:\n\u2228\u0307 : {T, F} \u00d7 {T, F} \u2192 {T, F}.\nThe truth-tables for the functions \u2228\u0307 and \u00ac\u0307 respectively are:\n\u2228\u0307\nT T T T F T F T T F F F\n\u00ac\u0307 T F F T\nDefinition B.3. If \u03b1[b] = T we say that b is a model of \u03b1 or satisfies \u03b1. The assignment b is a\nmodel of the set of formulas \u2206 \u2286 PF if b is a model of each formula in \u2206.\nLemma B.4. Let \u03b1 be a propositional formula and let b and b\u2032 be assignments with b(p) = b\u2032(p)\nfor all p \u2208 pvar(\u03b1). Then \u03b1[b] = \u03b1 [b\u2032].\nRemark. By this lemma, for \u03b1 \u2208 PFn+1 and b0, . . . , bn \u2208 {T, F} it makes sense to write\n\u03b1 [b0, . . . , bn]\nfor the truth-value \u03b1[b] where b is any assignment for which b (pi) = bi for i \u2264 n. If \u03b1 [b0, . . . , bn] = T ,\nwe say that \u201c b satisfies \u03b1\u201d.\nDefinition B.5. We define:\n\u03b1 is a consequence of \u2206 (written: \u2206 |= \u03b1 ) :iff every model of \u2206 is a model of \u03b1;\n\u03b1 is valid (written: |= \u03b1 ) :iff \u03b1 holds under all assignments;\n\u2206 is satisfiable (written: Sat \u2206) :iff there is an assignment which is a model of \u2206;\n\u03b1 is satisfiable (written: Sat \u03b1) :iff Sat{\u03b1};\n\u03b1 and \u03b2 are logically equivalent :iff |= (\u03b1 \u2194 \u03b2).\nLet S be an at most countable symbol set containing at least one relation symbol.\nThen the set\nAS := {Rt1 . . . tn|R \u2208 S n\u2212 ary, t1, . . . , tn \u2208 T S}\nof equality-free atomic S-formulas is countable. Furthermore let\n\u03c00 : A S \u2192 {pi|i \u2208 N}\nbe a bijection. We extend \u03c00 to a map \u03c0 which is defined on the set of S-formulas which are both equality-free and quantifier-free, by setting:\n\u03c0(\u03d5) := \u03c00(\u03d5) for \u03d5 \u2208 AS\n\u03c0(\u00ac\u03d5) := \u00ac\u03c0(\u03d5)\n\u03c0(\u03d5 \u2228 \u03c8) := (\u03c0(\u03d5) \u2228 \u03c0(\u03c8)).\nThen the following holds:\nLemma B.6. The map \u03d5 7\u2192 \u03c0(\u03d5) is a bijection from the set of equality-free and quantifier-free\nS -formulas onto PF .\nProof. We define a map \u03c1 : PF \u2192 LS by\n\u03c1(p) := \u03c0\u221210 (p)\n\u03c1(\u00ac\u03b1) := \u00ac\u03c1(\u03b1)\n\u03c1(\u03b1 \u2228 \u03b2) := (\u03c1(\u03b1) \u2228 \u03c1(\u03b2)).\nBy induction on \u03d5 and \u03b1, respectively, one can easily show:\n\u03c1(\u03c0(\u03d5)) = \u03d5 for equality-free and quantifier-free \u03d5,\n\u03c0(\u03c1(\u03b1)) = \u03b1 for \u03b1 \u2208 PF .\nHence \u03c0 is a bijection and \u03c1 = \u03c0\u22121.\nLemma B.7. If \u03a6\u222a{\u03d5,\u03a8} is a set of equality-free and quantifier-free S -formulas,then the following\nholds:\n(1) Sat \u03a6 iff Sat \u03c0(\u03a6).\n(2) \u03a6 |= \u03d5 iff \u03c0(\u03a6) |= \u03c0(\u03d5).\n(3) \u03d5 and \u03c8 are logically equivalent iff \u03c0(\u03d5) and \u03c0(\u03c8) are logically equivalent.\nDefinition B.8. (1) For a sentence \u03d5 := \u2200x1 . . . \u2200xm\u03c8 with quantifier-free \u03c8 and terms t1, . . . , tm \u2208\nT S0 the formula \u03c8( m x |\nm t ) is called a ground instance of \u03d5.\n(2) Let GI(\u03d5) be the set of ground instances of \u03d5 := \u2200x1 . . .\u2200xm\u03c8, i.e., GI(\u03d5) = {\u03c8( m x |\nm t\n) | t1, . . . , tm \u2208 T S0 }\n(3) For a set \u03a6 of formulas \u03d5 of the form above let GI(\u03a6) := \u222a\u03d5\u2208\u03a6GI(\u03d5). We choose a bijection \u03c00 : A S \u2192 {pi|i \u2208 N} from the set of (equality-free) atomic formulas onto the\nset of propositional variables. Let \u03c0 be the extension of \u03c00 to the set of quantifier-free formulas given\nDefinition B.9. A set \u03a6 of quantifier-free formulas is propositionally satisfiable if \u03c0(\u03a6) is satisfiable.\nLemma B.10. If \u03a6 is a set of quantifier-free formulas,then \u03a6 is satisfiable iff \u03a6 is propositionally\nsatisfiable.\nTheorem B.11. For a set \u03a6 of equality-free sentences of the form \u2200x1 . . . xm\u03c8 with quantifier-free \u03c8 the following are equivalent:\n(1) \u03a6 is satisfiable.\n(2) GI(\u03a6) is propositionally satisfiable."
        },
        {
            "heading": "Appendix C. Basic conclusions about the time complexity",
            "text": "We will introduce some of the terms, symbols, and conclusions needed in computational complexity theory, including well-known complexity class languages such as P , NP , EXP , NEXP . And the corresponding complexity class completeness. Standard references related to this section are (see [13], [14], [18] and [15]). We use the complexity classes P(the class of languages that is decided by a deterministic polynomial time O(poly(n)) Turing machine), NP(the class of languages that is decided by a nondeterministic polynomial time O(poly(n)) Turing machine), EXP(the class of languages that is decided by a deterministic exponential time O(2poly(n)) Turing machine), NEXP(the class of languages that is decided by a nondeterministic exponential time O(2poly(n)) Turing machine). And notions of completeness for complexity classes, such as NP-complete, EXP-complete, NEXP-complete, etc. In this paper, we only use polynomial time reductions."
        },
        {
            "heading": "C.1. The Class P",
            "text": "Definition C.1 P is the class of languages that are decidable in polynomial time on a deterministic\nsingle-tape Turing machine. In other words,\nP = \u22c3\nk\nTIME(nk).\nExample C.2. A directed graph G contains nodes s and t. The PATH problem is to determine\nwhether a directed path exists from s to t. Let\nPATH = {< (G, s, t) > | G 1s a directed graph that has a directed path from s to t }.\nThe PATH problem: Is there a path from s to t?"
        },
        {
            "heading": "Theorem C.3. PATH \u2208 P .",
            "text": ""
        },
        {
            "heading": "C.2. The Class NP",
            "text": "Definition C.4. NP is the class of languages that are decidable in polynomial time on a nonde-\nterministic single-tape Turing machine. In other words,\nNP = \u22c3\nk\nNTIME(nk).\nC.3. The Class EXP\nDefinition C.5. EXP is the class of languages that are decidable in exponential time on a deter-\nministic single-tape Turing machine. In other words,\nEXP = \u22c3\nk\nTIME((2n k ).\nC.4. The Class NEXP\nDefinition C.6. NEXP is the class of languages that are decidable in exponential time on a\nnondeterministic single-tape Turing machine. In other words,\nNEXP = \u22c3\nk\nNTIME(2n k )."
        },
        {
            "heading": "C.5. Computable function",
            "text": "Definition C.7. A function f : \u2211\u2217 \u2192 \u2211\u2217 is a computable function if some Turing machine M , on\nevery input w, halts with just f(w) on its tape."
        },
        {
            "heading": "C.6. Reduction",
            "text": "Definition C.8. Language A is mapping reducible to language B, Written A \u2264m B, if there is a\ncomputable function f :: \u2211\u2217 \u2192 \u2211\u2217 , where for every w,\nw \u2208 A\u21d4 f(w) \u2208 B.\nThe function f is called the reduction of A to B.\nC.7. Polynomial time computable function Definition C.9. A function f : \u2211\u2217 \u2192 \u2211\u2217 is a polynomial time computable function if some polynomial time Turing machine M exists that halts with just f(w) on its tape, when started on any input w,\nC.8. Polynomial time reduction\nDefinition C.10. LanguageA is polynomial time mapping reducible, or simply polynomial mapping reducible, to language B, Written A \u2264P B, if there is a polynomial time computable function f :: \u2211\u2217 \u2192 \u2211\u2217, where for every w,\nw \u2208 A\u21d4 f(w) \u2208 B.\nThe function f is called the polynomial time reduction of A to B.\nC.9. The Class NP-complete\nDefinition C.11. A language B is NP-complete is it satisfies two conditions:\n1. B is in NP , and\n2. every A in NP is polynomial time reducible to B.\nThe honor of being the \u201dfirst\u201d NP-complete problem goes to a decision problem from Boolean logic, which is usually referred to as the SATISFIABILITY problem (SAT, for short). The terms we shall use in describing it are defined as follows:\nLet U = {u1, u2, ..., um} be a set of Boolean variables. A truth assignment for U is a function t : U \u2192 {T, F}. If t(u) = T we say that u is \u201dtrue\u201d under t; if t(u) = F we say that u is \u201dfalse\u201d. If u is a variable in U , then u and u\u0304 are literals over U . The literal u is true under t if and only if the variable u is true under t; the literal u\u0304 is true if and only if the variable u is false.\nA clause over U is a set of literals over U , such as {u1, u\u03042, u3}. It represents the disjunction of those literals and is satisfied by a truth assignment if and only if at least one of its members is true under that assignment.The clause above will be satisfied by t unless t(u1) = F , t(u2) = T , and t(u3) = F . A collection C of clauses over U is satisfiable if and only if there exists some truth assignment for U that simultaneously satisfies all the clauses in C. Such a truth assignment is called a satisfying truth assignment for C."
        },
        {
            "heading": "C.9.1. The SATISFIABILITY(SAT) problem",
            "text": "INSTANCE: A set U of variables and a collection C of clauses over U .\nQUESTION: Is there a satisfying truth assignment for C?\nThe seminal theorem of Cook [1971][3] can now be stated:\nTheorem C.12. (Cook\u2019s Theorem) SAT is NP-complete."
        },
        {
            "heading": "C.9.2. The 3-SATISFIABILITY(3SAT) problem",
            "text": "INSTANCE: Collection C = {c1, c2, ...Cm} of clauses on a finite set U of variables such that |ci| = 3\nfor 1 6 i 6 m.\nQUESTION: Is there a truth assignment for U that satisfies all the clauses in C?\nTheorem C.13. 3SAT is NP-complete.\nC.9.3. The satisfiability problem for a set of finite propositional formulas\nDefinition C.14. LFP is used to express the satisfiability problem of a set of finite propositional\nformulas.\nLemma C.15. LFP \u2208 NP-complete. Proof: Given a set of propositional formulas, the satisfiability problem asks whether there exists\nan assignment of truth values to the propositional variables such that all formulas in the set are true.\nFirst, this problem is an NP problem because if given a candidate solution, it can be verified in\npolynomial time whether the solution is a satisfiable solution of the given set of formulas.\nSecond, this problem has also been shown to be NP-complete because it is possible to reduce the polynomial time of the 3SAT problem to this problem. Given a 3SAT problem, we can convert it to an equivalent set of formulas, where each formula is made up of three characters. Thus, the problem is NP-hard and belongs to NP and is therefore NP-complete.\nC.10. The Class EXP-complete\nDefinition C.16. A language B is EXP -complete is it satisfies two conditions:\n1. B is in EXP , and\n2. every A in EXP is polynomial time reducible to B.\nC.10.1. The satisfiability of a segments of Schonfinkel-Bernays expression\nDefinition C.17. A formula \u03d5 whose expression has the following form is called a segments of\nSchonfinkel-Bernays expression:\n\u03d5 := \u2200y1 . . . \u2200yt\u03c8\nwith the following properties:\n(1) \u03c8 contains only the variables {y1, y2, . . . yt}; (2) \u03c8 is quantifier-free,\n(3) \u03c8 equality-free,\n(4) \u03c8 function-free,\nDefinition C.18. LSSB is used to express the satisfiability problem for segments of Schonfinkel-\nBernays expression.\nLemma C.19. LSSB \u2208 EXP-complete. C.11. The Class NEXP-complete\nDefinition C.19. A language B is NEXP-complete is it satisfies two conditions:\n1. B is in NEXP , and\n2. every A in NEXP is polynomial time reducible to B.\nC.11.1. The satisfiability of Schonfinkel-Bernays expression\nDefinition C.20. A formula \u03d5 whose expression has the following form is called an Schonfinkel-\nBernays expression:\n\u03d5 := \u2203x1 . . .\u2203xs\u2200y1 . . . \u2200yt\u03c8\nwith the following properties:\n(1) \u03c8 contains only the variables {y1, y2, . . . yt}; (2) \u03c8 is quantifier-free,\n(3) \u03c8 equality-free,\n(4) \u03c8 function-free,\nIt is not hard to see that the following conclusion is true.\nRemark C.21.(1) it is in prenex form with a sequence of existential quantifiers followed by a\nsequence of universal ones,\n(2) free(\u03c8)={x1, . . . , xs, y1, . . . , yt}, In conjunction with condition (1), the condition ensures that\nthe variables in \u03c6 are not redundant.\n(3) con(\u03c8)= {a0, a1, . . . , am\u22121}. Because \u03d5 is of finite length, it can be assumed that \u03d5 contains a finite number of constant symbols, on account of con(\u03d5)=con(\u03c8), so that condition 5 is reasonable. If \u03d5 does not contain any constant symbols, then the constant symbol a0 is added.\n(4) For a Schonfinkel-Bernays expression \u03d5 = \u2203x1 . . .\u2203xs\u2200y1 . . . \u2200yt\u03c8, when k > 1, TSk = {x1, . . . , xs, y1, . . . , xt, a0, . . . , am\u2212\nwhen k = 0, TS0 = {a0, . . . , am\u22121}.\n(5) More precisely, \u03c8 := \u03c8(x1, . . . , xs, y1, . . . , xt, a0, . . . , am\u22121). Definition C.22. A language is said to be Schonfinkel-Bernays language if all its fornulas are of\nthe form of Schonfinkel-Bernays expressions, denoted FSB.\nDefinition C.23. LSB is used to express the satisfiability problem for Schonfinkel-Bernays expres-\nsion.\nLemma C.24. LSB \u2208 NEXP-complete. The well-known relationships between complexity classes are as follows:\nLemma C.25. P \u2286 NP \u2286 EXP \u2286 NEXP .\nLemma C.26. P ( EXP .\nLemma C.27. NP ( NEXP .\nLemma C.28. P ( NEXP .\nDeclaration of Competing Interest: The authors declare hat they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.\nData availability: No data was used for the research described in the article."
        }
    ],
    "year": 2023
}