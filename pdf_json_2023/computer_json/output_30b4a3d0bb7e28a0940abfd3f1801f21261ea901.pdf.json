{
    "abstractText": "Given an undirected graph G = (V,E) and vertices s, t, w1, w2 \u2208 V , we study finding whether there exists a simple path P from s to t such that w1, w2 \u2208 P . As a sub-problem, we study the question: given an undirected graph and three of its edges, does there exist a simple cycle containing all those edges? We provide necessary and sufficient conditions for the existence of such paths and cycles, and develop efficient algorithms to solve this and related problems.",
    "authors": [
        {
            "affiliations": [],
            "name": "Solomon Eyal Shimony"
        }
    ],
    "id": "SP:283bef3e16f96dbf1c88df376f7669876b02965c",
    "references": [
        {
            "authors": [
                "Giuseppe Di Battista",
                "Roberto Tamassia"
            ],
            "title": "On-line maintenance of triconnected components with SPQR-trees",
            "year": 1996
        },
        {
            "authors": [
                "Kristof Berczi",
                "Yusuke Kobayashi"
            ],
            "title": "The Directed Disjoint Shortest Paths Problem",
            "venue": "Annual European Symposium on Algorithms (ESA 2017),",
            "year": 2017
        },
        {
            "authors": [
                "Thomas H. Cormen",
                "Charles E. Leiserson",
                "Ronald L. Rivest",
                "Clifford Stein"
            ],
            "title": "Introduction to Algorithms, Third Edition",
            "year": 2009
        },
        {
            "authors": [
                "G. Dahan",
                "I. Tabib",
                "S.E. Shimony",
                "A. Felner"
            ],
            "title": "Generalized longest path problems",
            "venue": "Symposium on Combinatorial Search, pages 56\u201364",
            "year": 2022
        },
        {
            "authors": [
                "E. Dinic",
                "Alexander Karzanov",
                "M. Lomonosov"
            ],
            "title": "The system of minimum edge cuts in a graph",
            "venue": "In book: Issledovaniya po Diskretno\u0131\u030c Optimizatsii (Engl. title: Studies in Discrete Optimizations),",
            "year": 1976
        },
        {
            "authors": [
                "Gabriel Andrew"
            ],
            "title": "Dirac. In abstrakten graphen vorhandene vollst\u00e4ndige 4-graphen und ihre unterteilungen",
            "venue": "Mathematische Nachrichten,",
            "year": 1960
        },
        {
            "authors": [
                "Tali Eilam-Tzoreff"
            ],
            "title": "The disjoint shortest paths problem",
            "venue": "Discrete Applied Mathematics,",
            "year": 1998
        },
        {
            "authors": [
                "S. Even"
            ],
            "title": "Graph Algorithms",
            "venue": "Cambridge University Press",
            "year": 2011
        },
        {
            "authors": [
                "D.R. Ford",
                "D.R. Fulkerson"
            ],
            "title": "Flows in Networks",
            "venue": "Princeton University Press, USA",
            "year": 2010
        },
        {
            "authors": [
                "M.R. Garey",
                "D.S. Johnson"
            ],
            "title": "Computers and Intractability: A Guide to the Theory of NP-Completeness (Series of Books in the Mathematical Sciences)",
            "venue": "W. H. Freeman, first edition edition",
            "year": 1979
        },
        {
            "authors": [
                "Carsten Gutwenger",
                "Petra Mutzel"
            ],
            "title": "A linear time implementation of SPQRtrees",
            "venue": "In Proceedings of the 8th International Symposium on Graph Drawing,",
            "year": 2000
        },
        {
            "authors": [
                "F. Harary"
            ],
            "title": "Graph Theory",
            "venue": "Addison-Wesley, Reading, MA",
            "year": 1969
        },
        {
            "authors": [
                "J.E. Hopcroft",
                "R.E. Tarjan"
            ],
            "title": "Dividing a graph into triconnected components",
            "venue": "SIAM Journal on Computing, 2(3):135\u2013158",
            "year": 1973
        },
        {
            "authors": [
                "Saunders Mac Lane"
            ],
            "title": "A structural characterization of planar combinatorial graphs",
            "venue": "Duke Mathematical Journal,",
            "year": 1937
        },
        {
            "authors": [
                "Misha Lavrov"
            ],
            "title": "k-connected graph, there exists a cycle that contains any 2 edges and any k-2",
            "venue": "vertices. https://math.stackexchange.com/questions/3599622/kconnected-graph-there-exists-a-cycle-that-contains-any-2-edges-and-any-k-",
            "year": 2020
        },
        {
            "authors": [
                "James F. Lynch"
            ],
            "title": "The equivalence of theorem proving and the interconnection problem",
            "venue": "ACM Sigda Newsletter,",
            "year": 1975
        },
        {
            "authors": [
                "Nick Matteo"
            ],
            "title": "G a k-connected graph. show that a set of k-2 vertices and a set of two edges lie on a common cycle",
            "venue": "https://math.stackexchange.com/questions/ 3600673/g-a-k-connected-graph-show-that-a-set-of-k-2-vertices-and-a-set-oftwo-edges-li?rq=1,",
            "year": 2020
        },
        {
            "authors": [
                "Karl Menger"
            ],
            "title": "Zur allgemeinen kurventheorie",
            "venue": "Fundamenta Mathematicae,",
            "year": 1927
        },
        {
            "authors": [
                "Jean-Claude Picard",
                "Maurice Queyranne"
            ],
            "title": "On the structure of all minimum cuts in a network and applications",
            "venue": "Mathematical Programming,",
            "year": 1982
        },
        {
            "authors": [
                "B.A. Reed",
                "N. Robertson",
                "A. Schrijver",
                "P.D. Seymour"
            ],
            "title": "Finding disjoint trees in planar graphs in linear time",
            "venue": "Contemporary Mathematics, 14",
            "year": 1993
        },
        {
            "authors": [
                "Neil Robertson",
                "Paul D. Seymour"
            ],
            "title": "Graph minors .xiii. the disjoint paths problem",
            "venue": "J. Comb. Theory, Ser. B,",
            "year": 1995
        },
        {
            "authors": [
                "Hars Vardhan",
                "Shreejith Billenahalli",
                "Wanjun Huang",
                "Miguel Razo",
                "Arularasi Sivasankaran",
                "Limin Tang",
                "Paolo Monti",
                "Marco Tacca",
                "Andrea Fumagalli"
            ],
            "title": "Finding a simple path with multiple must-include nodes",
            "venue": "IEEE International Symposium on Modeling, Analysis & Simulation of Computer and Telecommunication Systems,",
            "year": 2009
        }
    ],
    "sections": [
        {
            "text": "Keywords: Biconnected graphs, triconnected graphs, SPQR trees, must-include simple paths and cycles"
        },
        {
            "heading": "1 Introduction",
            "text": "We define and examine the problem of determining whether a simple path from a source to a target through two other given vertices exists in an undirected graph. This problem, as well as its extension to finding all vertex pairs where such paths do not exist, arose from the need to quickly determine must-include vertex pairs in an admissible heuristic in a combinatorial search for longest constrained paths [4]. Finding simple paths that include a given set of vertices is also of interest in communication networks [24]. In addition, this problem, as well as the related question on a must-include simple cycle, are of theoretical interest."
        },
        {
            "heading": "1.1 Problem statements",
            "text": "Formally, we examine the following problems on simple paths and cycles in undirected graphs, starting with the main problem:\nDefinition 1 (Path Existence Problem (PEP)). Given an undirected graph G = (V,E) and vertices s, t, w1, w2 \u2208 V , does there exist a simple path P from s to t such that w1, w2 \u2208 P?\n*Manuscript submitted for publication in SICOMP\nar X\niv :2\n30 2.\n09 61\n4v 1\n[ m\nat h.\nC O\n] 1\nWe henceforth call a such a path a must-include {w1, w2}-path from s to t. In triconnected graphs, the PEP always has an affirmative answer [4]. A more challenging alternate of this problem that is also of interest is:\nDefinition 2 (Excluded Pairs Enumeration (EPE)). Given an undirected graph G = (V,E) and vertices s, t \u2208 V , find all pairs of vertices w1, w2 such that there is no simple path P from s to t such that {w1, w2} \u2208 P .\nFor conciseness, we call the vertices and edges of a graph its elements. Another problem similar to PEP is:\nDefinition 3 (Cycle Existence Problem (CEP)). Given an undirected graph and three of its elements, does there exist a simple cycle containing all these elements?\nGiven a graph G with distinguished vertices s and t (either with or without edge (s, t)), we denote G \u222a (s, t) by G+.1 Note that PEP(G, s, t, w1, w2) is equivalent to CEP(G+, (s, t), w1, w2): their solutions differ just by adding/removing edge (s, t). Due to this reduction, any result for the CEP straightforwardly implies a similar result for the PEP, including algorithms and their run-times. Hence, in what follows, we provide theoretical results and algorithmic solutions only for the CEP, thereby immediately covering the PEP as well.\nFor the CEP on a triconnected graph, the answer is known (as a folklore), except for the case when three edges are given: in all but the latter case, such a cycle always exists. Where all given elements are vertices, this is covered by Dirac\u2019s theorem [6], while the case where at most two elements are edges was proved in informal discussions [16, 18]."
        },
        {
            "heading": "1.2 Related work",
            "text": "Here we briefly discuss the work on on problems related to the PEP\u201d. and related problems. Issues directly related to our methods and used in developing our results are examined in more detail in the background section.\nMuch of the literature on existence of simple paths centers on disjoint paths with certain endpoint requirements [2, 7]. Out of these, the most relevant to the PEP is: given k pairs of vertices (vj1 , vj2), k \u2265 j \u2265 1, find k (edge-wise or vertex-wise) disjoint paths such that each path Pj connects the pairs vj1 , vj2 . These problems are NP-hard for general k [17], but for constant k, Robertson and Seymour [22] provide an O(|V |3) solution to the problem of k vertex-disjoint paths. However, as the authors admit, the algorithm stated therein is impractical. Given an algorithm for computing these k disjoint paths, one can solve the PEP by finding a path from s to w1, a path from w2 to t, and a path from a neighbor of w1 to a neighbor of w2, all disjoint. Merging these paths is a solution to the PEP. Making this scheme complete may require iterating over all pairs of neighbors, and also examining the case where the paths are s to w2 and t to w1. Still, the runtime is polynomial. Finding k disjoint trees can be done in linear time (for fixed k), in graphs restricted to be planar [21].\n1Henceforth, we omit the braces { } for singleton sets in expressions involving set operators such as \\ and \u222a, when unambiguous. Additionally, we apply set operators to a graph as shorthand for the operation applied to its vertex set or edge set, as appropriate from the context. E.g., for a graph G = (V,E), we denote by G \u222a (s, t) the graph (V,E \u222a {(s, t)}).\nThe direct generalization of the PEP, where the must-include set consists of more than two vertices, has also been examined. For unbounded k, it is easily shown that this problem is NP-hard, by reduction from Hamiltonian Cycle [10]. An algorithm using path splicing involving small k was shown in [24], but that work provides no explicit runtime guarantees and their algorithm does not guarantee finding a path if one exists.\nOur PEP falls under the conditions for existence of an integral multi-flow in a network with four terminals stated by Seymour [23]. However, it is not explicitly stated therein how that translates into an efficient algorithm for finding such paths or deciding their existence."
        },
        {
            "heading": "1.3 Structure and contributions of this paper",
            "text": "We begin with background on graph connectivity (Section 2): Menger\u2019s theorem and the decomposition of a graph into its 2- and 3-connected components and the respective properties of simple paths within them; in passing, we show a simple reduction of our problems to the case of a biconnected graph. In particular, we describe SPQR trees (Section 2.2), which are heavily used in this paper. For the reader\u2019s convenience, we provide an SPQR tree description not coinciding with any previously known one, though essentially equivalent to that of [11].\nFor CEP, we provide (Section 3, the first contribution of this paper) a structural solution to the case of three edges in triconnected graphs: simple necessary and sufficient conditions for cycle existence. (Note that Section 3 can be read before Section 2.2, as it does not require knowing SPQR trees.)\nWe then provide necessary and sufficient conditions for the existence of a cycle as in CEP (and thus of the path as in PEP) in general biconnected undirected graphs (Section 4, the second contribution of this paper). This is done by showing that the CEP reduces to cycle existence in an appropriately defined central component of the SPQR tree of the graph. The difficult subproblem here is in components of type R, where we use the above-stated conditions for CEP in triconnected graphs.\nFinally, we develop efficient algorithms for both CEP and EPE (Section 5). Our CEP (and thus PEP) algorithm has runtime O(|E|), assuming the input graph is connected. For the EPE in the case where implicit output of the enumerated pairs is allowed (for example, the admissible heuristic in [4] only needs access to various counts of such pairs, thus can use the implicit form directly), we provide an O(|E|) algorithm as well; it becomes O(|V |2) if explicit enumeration is required."
        },
        {
            "heading": "2 Background on Graph Connectivity",
            "text": "In this paper, we consider only connected undirected graphs G = (V,E). We begin with some background on vertex connectivity and the supporting flow algorithms; edge connectivity is also mentioned as needed. See, e.g., books [8, 12, 14] for details. A subset V \u2032 \u2286 V of vertices is called a (vertex) cut if the removal of the vertices in V \u2032 makes G not connected and if no subset of V \u2032 has this property. We call a cut V \u2032 a \u201ck-cut\u201d if |V \u2032| = k. A graph is (vertex) k-connected if either |V | \u2265 k+ 1 and no k\u2212 1 or fewer of its vertices form a cut, or if it is a complete graph on k vertices. We use\nthe terms biconnected and triconnected graphs meaning 2- and 3-connected graphs, respectively. Two or more paths are called internally vertex-disjoint if they are vertex disjoint except possibly for their end-vertices."
        },
        {
            "heading": "2.1 Basics of Connectivity",
            "text": "We begin with some properties and theorems in the graph connectivity theory and algorithms that are used in the rest of the paper. The main tool for exploring k-connected graphs is Menger\u2019s theorem:\nTheorem 2.1 (Menger [19]). In any k-connected graph G = (V,E), |V | \u2265 k + 1, for every two vertices s, t \u2208 V , there exist k simple, internally vertex-disjoint paths between s and t.\nAdditionally, for two sets of vertices Vs, Vt (\u201csides\u201d), each of cardinality at least k, there exist k simple, fully disjoint paths between Vs and Vt. (Note that the sides need not be disjoint.) Throughout this paper, we assume that no internal vertex of those paths is in Vs, Vt; indeed, in such a case, the extra paths\u2019 prefixes and/or suffixes can be safely truncated. For conciseness, we henceforth take paths between two objects (such as paths, cycles) to mean paths between the vertex sets of these objects.\nThe theorem also naturally generalizes to the case where either side is a singleton set, e.g., Vs = {s}: there exist k paths as above that are vertex-disjoint except at that singleton set. We refer to the above generalizations of Theorem 2.1 as the extension to Menger\u2019s theorem.\nWhen we need to actually find the set of vertex-disjoint paths between s and t as in Menger\u2019s theorem, the following efficient algorithms are used. To find a path from a given source vertex s to a target vertex t (the case k = 1 of Menger\u2019s theorem), efficient schemes execute a labeling algorithm (either BFS or DFS) scanning G from s up to labeling t, and then restore the path using the backward labels; this takes time O(|E|). (See any book in basic graph algorithms as a source, such as [3].)\nWhen we need to find the set of several vertex-disjoint paths between s and t as in Menger\u2019s theorem, network flow techniques are used. The given k-connected graph G = (V,E), |V | \u2265 k + 1, is turned into a (directed) flow network Nv = (~Gv, s, t, cv) with the flow source s and sink t. Every vertex v of G, except for s and t, is turned into two vertices v1 and v2 with a directed edge (v1, v2) of capacity cv(v1, v2) = 1 from v1 to v2 in ~Gv. Every (undirected) edge (u, v) of G is turned into two directed edges (u2, v1) and (v2, u1) of infinite capacity each in ~Gv. The following max-flow min-cut theorem [9] guarantees existence of a flow of size k in Nv.\nTheorem 2.2. In any flow network, the minimal capacity of an s, t-cut equals the maximal size of a flow from s to t.\nBy executing the Ford-Fulkerson algorithm [9], we find such a flow f in Nv; it is guaranteed to be integral, that is the flow f(e) in each edge e of Nv is either 0 or 1. The edges assigned with flow 1 constitute k vertex-disjoint paths from s and t in ~Gv, which naturally define k vertex-disjoint paths between s and t in G, as required. (Thus, Theorem 2.2 generalizes Menger\u2019s theorem.)\nThe Ford-Fulkerson algorithm (FF) works in iterations, beginning from the zero flow. Each iteration constructs a flow-augmenting path from s to t in the residual network Nvf w.r.t. the current flow f in N\nv, by executing a labeling algorithm (either DFS or BFS) in Nvf ; after finding such a path, it augments the current flow using that path and updates the residual network. Each iteration of FF increases the flow size in Nv by 1. The runtime of each iteration is O(|E|). That is, for any constant k, the time of finding a flow of size k in Nv, and thus of finding k vertex-disjoint paths between s and t in G, is also O(|E|).\nHandling the generalization of Menger\u2019s theorem is easy. If a set Vs is given instead of s, then, before constructing ~Gv, enhance G by adding an artificial source s\u0304 with edges to every vertex in Vs. Likewise, add edges from set Vt to new vertex t\u0304. After finding k vertex-disjoint paths between s\u0304 and t\u0304, we just truncate these paths by removing s\u0304 and t\u0304.\nFor any non-empty V \u2032 \u2286 V , we define the subgraph G(V \u2032) induced by V \u2032 as V \u2032 together with all edges of G between its vertices. Vertex a is called an articulation (or separator) vertex of G if {a} is a 1-cut. Removing an articulation vertex a from the graph results in two or more induced connected subgraphs G(Vi), 1 \u2264 i \u2264 r, r \u2265 2, \u222aiVi = V \\a. Continuing to recursively divide the induced connected subgraphs G(Vi \u222a a) by their separating vertices (each is a separating vertex of G as well), the final induced subgraphs are biconnected; they are called blocks of G. A block that consists of a single edge is called trivial. The set of blocks and the block tree structure of interleaved articulation vertices and blocks are unique (that is, they do not depend on the order of partitioning of G by the articulation vertices). See an example of a graph and its block tree in Figure 1.\nObserve that any simple cycle in G lies entirely in a single block. Indeed, if a simple path passes from one block to another, via a separator vertex, then it has no way to return. Therefore, the CEP has a sense only in the case when s and t are in the same block, B; in such a case, we can safely discard all other blocks of G, thus reducing the problem to the (biconnected) graph B. Due to the equivalence between the PEP and CEP as above, the PEP in a general graph can also be easily reduced to either a PEP or a CEP in a single block of G+ = G \u222a (s, t). Henceforth, we thus assume that\ngraphs G for the CEP and G+ for the PEP are biconnected. (Remark: Note that G+ is biconnected if and only if the block tree of G has a form of a chain of blocks such that s and t are in the blocks at the two ends of that chain.)\nA biconnected graph can contain vertex 2-cuts. Such a vertex pair {a, b} that separates G is henceforth called a separation pair of G. A similar, albeit more complex, sub-division of a biconnected graph G using separation pairs into triconnected components and auxiliary structural elements is possible [1]. This structure, named an SPQR tree, is described in Section 2.2 and used extensively in Section 4.\nIn this paper, we also use the concept of an edge cut, which is an inclusion-minimal set of edges E\u2032 of G such that removing the edges in E\u2032 disconnects G. Unlike vertex cuts, every edge cut divides G into exactly two connected induced subgraphs; thus, their vertex sets V \u2032, V \u2032\u2032 form a 2-partition of V . Note that the edges in E\u2032 and only these edges connect vertices from V \u2032 and V \u2032\u2032. Additionally, for any pair of edge cut E\u2032 and cycle L, the number of edges common to both is even; indeed, traversing L by each edge in E\u2032 switches between subgraph G(V \u2032) and subgraph G(V \u2032\u2032) or vice versa. An edge cut is called a k-edge cut if |E\u2032| = k. To distinguish such cuts from vertex cuts, we always say \u201cedge cut\u201d in full in this paper, leaving \u201ccut\u201d as a nickname for a vertex cut.\nAny edge cut of the minimal size (cardinality) is called a minimum edge cut of G. Two edge cuts of G are called crossing if the two corresponding 2-partitions of V subdivide V into four non-empty subsets (otherwise, they subdivide it into three non-empty subsets). The following theorem is proved in [5]:\nTheorem 2.3. No minimum edge cuts of odd cardinality cross.\nThe reader can easily check by hand the special case of this theorem that we use in this paper: if there are two crossing 3-edge cuts, then there exists a 1- or 2-edge cut in the graph. We also use the following known result on edge and vertex cuts. As we could not find a published proof, we also provide a proof.\nTheorem 2.4. If there is a k-edge cut in a graph G with at least k + 2 vertices, then there exists a vertex cut of cardinality at most k in G.\nProof. Let E\u2032, |E\u2032| = k, be an edge cut partitioning G into G(V1) and G(V2). Denote by V\u0303i, i = 1, 2, the set of end-vertices of edges in E\u2032 in Vi. Clearly, |V\u03031|, |V\u03032| \u2264 k. If for some i, the set Vi \\ V\u0303i is non-empty, then V\u0303i is a vertex cut separating Vi \\ V\u0303i from V3\u2212i, as required. Otherwise, Vi = V\u0303i, i = 1, 2; we assume so for the rest of the proof.\nSuppose that there exist vertices v1 \u2208 V1 and v2 \u2208 V2 such that (v1, v2) 6\u2208 E\u2032. Then, the following vertex set is a cut separating v1 from v2. For each edge in E\u2032 incident on vi, i = 1, 2, pick its other end-vertex. For any other edge in E\u2032, pick an arbitrary end-vertex thereof. Removing all those vertices implies removing all edges in E\u2032, thus separating v1 and v2. Overall, vertex picks occur |E\u2032| = k times; since some of the vertices may have been picked more than once, the total vertex cut size is at most k, as required.\nThe only remaining case is where E\u2032 = V1 \u00d7 V2. Then, |V1| \u00b7 |V2| = k; assume, w.l.o.g., that |V1| \u2264 |V2|, so that |V1| = q \u2264 \u221a k. Let us show that |V | = q + k/q \u2264 k + 1, contradicting the condition of the lemma. If q = |V1| = 1, then |V2| = k, thus\n|V | = k + 1. By the assumption q \u2264 \u221a k, the derivative of the function q + k/q is non-positive: 1\u2212 k/q2 \u2264 1\u2212 k/( \u221a k)2 = 0, which suffices."
        },
        {
            "heading": "2.2 Triconnected Components and SPQR trees",
            "text": "A neat representation of the sub-division of a biconnected graph G into triconnected components and auxiliary structural elements is called the SPQR tree of G [1]; such a tree can be constructed in a linear time O(|E|) [11]. The SPQR tree of G, T = T (G) consists of nodes, each being a graph called a \u201ctriconnected component\u201d2 of G (henceforth called simply a component) of one of 4 types: S (series), P (parallel), R (rigid), and Q (representing a single edge). Henceforth, we use \u201cX node/component\u201d as shorthand for \u201cnode/component of type X\u201d.\n2This is the standard historically used term, even though not all these components are triconnected graphs.\nEach component is a part of graph G augmented with auxiliary virtual edges. The components (nodes) are connected in tree T by structural edges. Figure 2 (bottom left) shows the gross structure of the SPQR tree of the example graph in Figure 2 (top left): rectangles represent components, with structural edges between them; the components are shown in Figure 2 (right). As we use SPQR trees extensively in this paper, we further delve into their details below. There exist different definitions of SPQR trees, which vary in details; we adopt the definition of [11] that omits the Q nodes. The main difference of our definition from that of [11] is that our SPQR tree is unrooted.3 As we are concerned here with intuitive understanding rather than with how to construct the SPQR tree, we provide a description that, unlike prior work, is not meant to lead to an efficient algorithm of creating the tree.\nConsider the graph shown in Figure 2 (top left). There is a must-include path from w4 to x via u1 and u6: (w4, t, u3, u2, u6, u5, u1, x), but must-include paths from w4 to x through u1 and w2 and from u2 to u4 through w4 and u6 do not exist. We show the reasons for these query answers in terms of the SPQR tree of the graph, at the end of Section 4.\nTo define the SPQR tree, we begin with auxiliary definitions. We assume that the given graph G is not a single edge. For every separator (2-cut) {a, b} of G, the graph G\\{a, b} consists of ra,b \u2265 2 maximal connected induced subgraphs, which we denote by G(V a,bi ), 1 \u2264 i \u2264 ra,b. The split subgraphs w.r.t. {a, b} are G(V a,b i \u222a{a, b})\\(a, b), 1 \u2264 i \u2264 ra,b. For example, in the graph of Figure 2 (top left), there are two split subgraphs w.r.t. 2-cuts {u1, u2}, {u2, u5}, and {x,w3} and three split subgraphs w.r.t. {x, t}.\nWe define the SPQR tree T (G) of any given biconnected graph G recursively, with the base cases as follows:\nCycle (S node): If G is a cycle, T (G) consists of a single S component G.\nTriconnected (R node): If there is no 2-cut in G, and G is not a triangle, then G is a triconnected graph on at least four vertices. T (G) consists of a single R component G.\nOtherwise, if G has 2-cuts and is not a cycle, then T (G) is defined by the following recursion. See illustration in Figure 3 (left and middle).\nParallel case If {a, b} is a 2-cut with either ra,b \u2265 3 or with (a, b) \u2208 E (or both), we create new virtual edges ea,bi = (a, b), 1 \u2264 i \u2264 ra,b. We also create a P component CP as the multi-graph on two vertices a, b with (at least three) edges between them: all virtual edges ea,bi as well as edge (a, b), if (a, b) \u2208 E. The tree T (G) consists of node CP and ra,b trees T (G(V a,bi ) \u222a e a,b i ), each connected to\nCP by a structural edge from the component in T (G) that contains ea,bi .\nBinary case Otherwise, if {a, b} is a 2-cut with exactly two split subgraphs w.r.t. {a, b} and at least one of them is biconnected, then we create a new virtual\n3After [1, 11] were published, R. Tamassia agreed that the unrooted form is preferable for SPQR trees (a personal communication to the first author).\nedge ea,b = (a, b). The tree T (G) consists of trees T (G(V a,b1 ) \u222a ea,b) and T (G(V a,b2 ) \u222a ea,b) connected by a structural edge between the components in those trees containing ea,b.\nFor example, consider a recursive composition of the SPQR tree of the graph G in Figure 2 (top left). For illustration, follow the other parts of the figure. Henceforth, we call edges of G in components \u201creal edges\u201d. By splitting G w.r.t. {u1, u2}, we get two split subgraphs (above and below {u1, u2} in the figure). Since the top subgraph is biconnected, we are in the binary case of the recursion. We create a new virtual edge (u1, u2) (denoted V ir6 in the figure) and continue to construct the SPQR trees of the top and bottom split subgraphs with virtual edge (u1, u2) added to each (henceforth, the \u201ctop\u201d and \u201cbottom\u201d graphs, resp.).\nBy splitting the top graph by {u2, u5} (parallel case), we get two split subgraphs: the \u201cleft\u201d and \u201cright\u201d ones. The arising P component P (u2, u5) consists of three edges (u2, u5): the left virtual (denoted V ir5), the real, and the right virtual (denoted V ir4) ones. The SPQR trees of the left and right graphs with added virtual edges are of a single node each (base cases of the recursion): R component R(u1, u2, u4, u5) (a complete graph on four vertices) and S component S(u2, u5, u6) (a cycle on three vertices), respectively. These nodes are connected to P (u2, u5) each by the structural edges eu2,u51 and e u2,u5 2 corresponding to the left and right virtual edges (u2, u5), resp., thus forming the entire SPQR tree of the top graph. By splitting the bottom graph w.r.t. {x, t} (parallel case), we get P component P (x, t) with three virtual edges (denoted V ir3, V ir2, and V ir1), and three split subgraphs. These three subgraphs with added respective virtual edges (x, t) have a singlenode SPQR tree each: S components S(x, u1, u2, u3, t), S(x,w1, w2, w3, t), and S(x,w4, t). Each of these S nodes is connected to P (x, t) by the structural edges ex,t3 , e x,t 2 , and e x,t 1 corresponding to the virtual edges V ir3, V ir2, and V ir1, resp., thus forming the SPQR tree of the bottom graph. Finally, the SPQR trees of the top and bottom graphs are connected by the structural edge eu1,u2 between their components R(u1, u2, u4, u5) and S(x, u1, u2, u3, t) containing virtual edge (u1, u2) (denoted V ir6 in the figure), thus arriving at the entire SPQR tree T (G).\nWe now show that our definition of the SPQR tree is essentially the same as in [11], with only technical differences. The classic papers of McLane [15] and Hopcroft and Tarjan [13] subdivided the given biconnected graph into its triconnected components via small steps, splitting by 2-cuts into two in all cases. Moreover, some of the splits made are canceled in a post-processing phase. The founders of SPQR trees [1, 11] introduced the tree structure on the components, while making the construction steps bigger. Each step adds a new component in its final form, thus eliminating the need for post-processing. The entire construction propagates from the (arbitrarily chosen) root to the leaves of the SPQR tree. We essentially retained their definition, with two technical changes (partially \u201creviving\u201d the approach of [15, 13]). First, we canceled rooting and propagation, replacing it by a recursion with an arbitrary order of splitting by (carefully chosen) 2-cuts. Second, we replaced their one-step constructions of S and R components by smaller steps, so that such components get their final form as the base cases of the recursion.\nLet us compare our approaches using the example in Figure 3 (right). When the algorithm of [11] arrives at 2-cut {a, b} when propagating from the grey area with a and b at its boundary, it reveals the entire chain of blocks between a and b in the rest of the graph. Then, it creates the S component along the circular chain of blocks, replacing each one of the non-trivial blocks therein (the grey areas) by a virtual edge. The further propagation is to those blocks, except for that between a and b, with the respective virtual edge added to each. We do the same by separating these blocks one by one, using the 2-cuts on their boundaries, so that the S component as above is finally revealed as a base case of the recursion. Thus, we arrive at the same SPQR tree structure. A similar technical difference occurs for R components.\nAs our definition and that of [11] are equivalent, we can use the known properties of SPQR trees, listed in what follows. For any biconnected graph G = (V,E), the tree T (G) defined as above is unique (independent of choosing its recursive composition) and coincides with that defined in [11]. The total number of elements in T (G), including all structural edges, components, and all the elements within components: vertices, edges of G, and virtual edges, is O(|E|) [11]. By construction, SPQR trees have no adjacent pairs of S nodes and no adjacent pairs of P nodes. Note that any component that is a triangle (such as that on u2, u5, u6 in our example) is an S-node, rather than an R-node (which should contain at least four vertices, by definition).\nRecall that each element of any component either is real (taken from G) or is a virtual edge. Any element of G is an element of at least one component. Every edge of G is always a real edge of exactly one component, while any vertex of G is a vertex of more than one component if and only if it is a member of a separation pair of G. By construction, any virtual edge has exactly two copies, in the components connected by the structural edge corresponding to that virtual edge.\nLet e = (a, b) be a virtual edge in a component C and (C,C \u2032) be the structural edge in T corresponding to e. We denote by B(C, e) the sub-tree of T hanging on (C,C \u2032) from C. Let G(C, e) be the subgraph of G consisting of all vertices and edges of G appearing in the nodes (components) of B(C, e) as their real elements. By construction, SPQR trees have the following property.\nProperty 2.1. For any virtual edge e = (a, b) and the structural edge (C,C \u2032) corre-\nsponding to it, the subgraphs G(C, e) and G(C \u2032, e) cover together the entire G and have only vertices a, b and no edges in common.\nTree T = T (G) models all 2-cuts of G in the following way. Consider any P node CP , which is a bond on vertices a, b. The pair {a, b} is a 2-cut of G, so that the ra,b maximal connected induced subgraphs G(V a,bi ) are the graphs G(C\nP , ea,bi ) for all virtual edges ea,bi in C\nP . Consider any structural edge (C,C \u2032), corresponding to virtual edge e = (a, b), such that neither C nor C \u2032 is a P node. The pair {a, b} is a 2-cut of G, so that there are exactly two split graphs G(C, e) and G(C \u2032, e) w.r.t. it. Consider any two non-adjacent vertices a, b of an S component CS . Let a and b break cycle CS into paths P1 and P2. The pair {a, b} is a 2-cut of G, so that the two split graphs w.r.t. it are the graphs \u222ae\u2208PiG(CS , e) \u222a (Pi \u2229G), i = 1, 2. There are no other 2-cuts in G.\nProperty 2.2. G(C, (a, b)) \u222a (a, b) is biconnected.\nHence, there exists a simple path between a and b in G(C, (a, b)).\nProperty 2.3. Given any element x \u2208 G(C, e), there exists a simple path P between a and b in G(C, e) such that x \u2208 P .\nThe latter property follows from Property 2.2 due to the extension of Menger\u2019s theorem applied to {a, b} and either x, if x is a vertex, or {u, v}, if x is an edge (u, v), in G(C, (a, b)) \u222a (a, b). Note that by Property 2.1, the paths between a and b as above do not use any elements of C other than a and b.\nIn this paper, we use the following notion of representation of elements of G in components. Let C be an arbitrary component of T . We say that any real element x of C represents itself in C. For any virtual edge e = (a, b) \u2208 C, all elements of G(C, e) except for a and b are represented in C by e. Thus, every element x of G is represented exactly once in C; we denote the unique object representing it\u2014either x itself or a virtual edge\u2014by rC(x)."
        },
        {
            "heading": "2.3 PEP and CEP: Known Properties",
            "text": "If the graph happens to be triconnected, the answer to the PEP is always positive. That is due to the following theorem from [4]:\nTheorem 2.5. Let G be a triconnected graph. Then, for every s, w1, w2, t \u2208 V , there exists a simple path in G from s to t that includes w1 and w2.\nFor the CEP, observe that by Dirac\u2019s theorem [6], in every k-connected graph, k \u2265 2, given any set of k vertices, there exists a simple cycle containing these vertices. This theorem can be extended to m \u2208 {1, 2} edges and k \u2212 m vertices. This extension is known as \u201dfolklore\u201d of internet discussions [18, 16], and as we could not find it formally published, we state a proof outline, as follows. For k = 2, given edges (u, u\u2032) and (v, v\u2032), existence of a cycle follows immediately from the extension to Menger\u2019s theorem. Indeed, since there exist two vertex-disjoint paths from u, u\u2032 to v, v\u2032, they can be spliced with the given edges, resulting with the cycle as required. The case where an edge and a vertex are given is similar. For k > 2, this is proved by induction: there\nexists a cycle L with the first k \u2212 1 elements, including the one or two given edges. If the last vertex w is not already on L, there are k vertex-disjoint (other than at w) simple paths Pi from w to vertices in L. Since L has only k\u22121 path segments between its given k \u2212 1 elements, at least two of the Pi, w.l.o.g. P1, P2, end at some vertices w1, w2 lying at one of these segments, P . Then, the required cycle is the same as L where path P is spliced to include the detour P1, w, P2. Therefore, as mentioned in the introduction, in a triconnected graph, the answer to the CEP is positive for any set of three elements in which at most two are edges. Formally:\nTheorem 2.6. In a triconnected graph G, given a set S of three elements of G where"
        },
        {
            "heading": "S contains at most two edges, there exists a simple cycle in G that traverses all the elements of S.",
            "text": ""
        },
        {
            "heading": "3 Cycle Existence Problem in Triconnected Graphs",
            "text": "We have seen that the only nontrivial case for the CEP in triconnected graphs is when the three given elements are edges. In this section, we prove the following main theorem, thus completing the solution to the CEP in triconnected graphs:\nTheorem 3.1. Let G = (V,E) be a triconnected graph, and e1, e2, e3 \u2208 E. Then, there exists a simple cycle L such that e1, e2, e3 \u2208 L if and only if neither of the following conditions occur:\n1. e1, e2, e3 all share a common end-vertex.\n2. {e1, e2, e3} is an edge cut of G.\nNote that the only if part of the theorem statement is straightforward: exception 1 trivially implies that the edges cannot be on a simple cycle; for exception 2, this is due to every edge cut intersecting any cycle by an even number of edges (see Section 2.1). The rest of this section proves the if part. Since the latter is rather complex, we begin with proving some auxiliary statements. First, we consider the main case where all six end-vertices of the given edges are distinct, postponing the other cases to the very end. Henceforth, we denote the end-vertices of e3 by s and t.\nLet us introduce some notation. For any path P , we denote by b(P ) its starting vertex, by f(P ) its ending vertex, and by P\u0304 the path reverse to P . We denote by Pxy the path from a given collection with b(P ) = x and f(P ) = y, if this does not lead to ambiguity, and the reverse path P\u0304xy byPyx. For two vertices x\u2032 and y\u2032 lying on path P in that order, we denote by P [x\u2032..y\u2032] the sub-path of P from x\u2032 to y\u2032.\nLemma 3.1. Let G = (V,E) be a graph, s, t \u2208 V and e1 = (u, u\u2032), e2 = (v, v\u2032) edges in E, where all above vertices are distinct in G. If there are a simple cycle L = ((u, u\u2032), Pu\u2032v\u2032 , (v\n\u2032, v), Pvu) in G, such that s, t 6\u2208 L, and mutually vertex-disjoint paths P1 from s to L and P2 from t to L, either both ending at Pvu or both ending at Pu\u2032v\u2032 , then there exists a simple path from s to t containing e1 and e2.\nProof. Assume w.l.o.g. that f(P1), f(P2) \u2208 Pvu and that f(P1) is on the part of Pvu between v and f(P2). Then, the required s, t-path is:\n(P1, Puv[f(P1)..v], (v, v \u2032), Pv\u2032u\u2032 , (u \u2032, u), Puv[u..f(P2)], P\u03042).\nWe now prove the main case of Theorem 3.1 (e1, e2, e3 do not have a common end-vertex) for a certain special case, thus providing a template for the general case. We now assume that G\u2212 = G \\ (s, t) is still triconnected.\nProposition 3.2. Let G\u2212 = (V,E\u2212) be a triconnected graph, s, t vertices and e1 = (u, u\u2032), e2 = (v, v\u2032) edges in G\u2212 (all above vertices distinct in G\u2212), such that (s, t) 6\u2208 E\u2212. Then, there exists a simple cycle containing e1, e2, (s, t) in G = G\u2212 \u222a (s, t).\nProof. By the extension to Menger\u2019s theorem, there exist three vertex-disjoint paths from {s, u, u\u2032} to {t, v, v\u2032}. Fix such a set of paths P . Since both above vertex sets have cardinality 3, let M be the symmetric mapping between these vertex sets, with M(x) = y just when the path (x...y) \u2208 P . There are two possible cases, and in both cases below we construct a simple path from s to t through e1, e2 in G\u2212, to which we then can add (s, t) to complete the required cycle in G.\nCase 1: If M(t) = u or M(t) = u\u2032, then M(s) = v or M(s) = v\u2032. Assume the former in each case, w.l.o.g. (due to symmetry). Therefore, we have vertex-disjoint paths Ptu, Psv, Pv\u2032u\u2032 \u2208 P with names denoting their respective endpoints. Then, P = (Psv, (v, v \u2032), Pv\u2032u\u2032 , (u \u2032, u), Put) is a simple path from s to t as required.\nCase 2: If M(t) = s, then, w.l.o.g., M(v) = u and M(v\u2032) = u\u2032. Thus, we have Pst, Pvu, Pv\u2032u\u2032 \u2208 P , all vertex-disjoint. Therefore, (Pvu, (u, u\u2032), Pu\u2032v\u2032 , (v\u2032, v)) is a simple cycle, which we denote by L. Since (s, t) 6\u2208 E, path Pst must have at least three vertices. Since L has at least four vertices, by the extension of Menger\u2019s theorem, there exist three vertex-disjoint paths P1, P2, P3 from some vertices in Pst to L.\nThen, at least two of f(P1), f(P2), f(P3) must be on either Pvu or Pv\u2032u\u2032 . Assume, w.l.o.g., (the other cases are symmetrical) that f(P1), f(P2) \u2208 Pvu and that b(P1) is on the part of Pst between s and b(P2). Then, P \u20321 = (Pst[s..b(P1)] \u00b7 P1) and P \u20322 = (Pts[t..b(P2)]\u00b7P2) are vertex-disjoint paths from s and t to Pvu. Note that L is a simple cycle intersecting vertex-disjoint paths P \u20321 and P \u2032 2 only at f(P \u2032 1) and f(P \u2032 2). Now, we have the required simple path from s to t due to Lemma 3.1.\nWe now move back to the general case, where G is triconnected but G \\ (s, t) may be not triconnected. We use the same proof outline as in Proposition 3.2. That is, there exist three vertex-disjoint paths from {s, u, u\u2032} to {t, v, v\u2032}. We have the same two cases w.r.t. mapping M . The construction in case 1 does not require edge (s, t), so edge (s, t) can be added to P to complete the required cycle as before, and we are done. In case 2, if Pst consists only of edge (s, t) then the proof fails, because the cardinality of the vertex set of Pst is only 2. Note, however, that if there exists any path in G from s to t other than (s, t) that is vertex-disjoint with cycle L = ((v, v\u2032), Pv\u2032u\u2032 , (u\u2032, u), Puv), we can still apply the method of case 2. So, we need to prove the remaining case, stated as the following Lemma, in which the only s, t-path that is vertex-disjoint from L is (s, t). Note that in this case, L contains neither s nor t, since by the construction, the paths Puv , Pu\u2032v\u2032 , Pst = (s, t) are all mutually vertex-disjoint.\nLemma 3.2. Let G = (V,E) be a triconnected graph, e1 = (u, u\u2032), e2 = (v, v\u2032), (s, t) edges in G (all above vertices distinct in G). Let L be a cycle in G such that e1, e2 \u2208 L, s, t 6\u2208 L, and there is no path from s to t in G \\ L \\ (s, t). Then, there exists a simple cycle in G containing e1, e2, (s, t) unless e1, e2, (s, t) form an edge cut of G.\nProof. W.l.o.g. let L = (e1, Puv, e2, Pv\u2032u\u2032). We call a simple path with end-vertices in L\u222a{s, t} but no other vertices in this set a connecting path, or a connector for short. We call a connector from s or t to L an external connector, and specifically an s-connector or t-connector, respectively. A connector from Puv to Pu\u2032v\u2032 that is not either e1 or e2 we call a bridge, and one either from Puv to Puv or from Pu\u2032v\u2032 to Pu\u2032v\u2032 a bypass.\nAs G is triconnected, there exist three vertex-disjoint (other than at s) paths from s to distinct vertices on L. Since at most one of such three paths can be through t, then at least two of them are s-connectors, and if t is on the third path, then its suffix from t is a t-connector. We call such three connectors an s-triple. Symmetrically, there exist three vertex-disjoint (other than at t) paths from t to distinct vertices on L, so that at least two of them are t-connectors, and if s is on the third path, then its suffix from s is an s-connector; we call them a t-triple. Note that s-connectors are always internally vertex-disjoint from t-connectors, as otherwise we would have a path from s to t in G \\ L \\ (s, t).\nWe call Puv and Pu\u2032v\u2032 the left and right sides of L, respectively. There are several cases w.r.t. the sides of L where external connectors end, which we examine below. In all these cases, we show a simple path from s to t containing e1 and e2 (except for when {e1, e2, (s, t)} is a 3-edge cut), from which we can construct the required cycle by adding (s, t).\nCase 1: There exist both s- and t-connectors to both sides of L. Assume, w.l.o.g., that two of the (vertex-disjoint other than at s) connectors in the s-triple, P1 and P2, end on Puv . Then, the requisite s to t path exists due to Lemma 3.1, as follows. If P1 and P2 are s- and t-connectors, then P1, P2 constitute the Lemma conditions. Otherwise, P1, P2 are both s-connectors. Since some t-connector, P , ending at Puv exists, and it is internally vertex-disjoint from P1 and P2, either P and P1 or P and P2 are vertexdisjoint, which also suffices.\nCase 2: All the t-connectors end at Pu\u2032v\u2032 , and there is at least one s-connector, Ps, ending there. (The other variants are either s/t or left/right symmetric or both, and thus can be treated similarly.) Then, since there are at least two vertex-disjoint (other than at t) t-connectors, P1, P2, we have: f(P1), f(P2) \u2208 Pu\u2032v\u2032 and f(P1) 6= f(P2). The ending vertex of Ps must thus be distinct from either f(P1), or f(P2), or both. Therefore, Ps is vertex-disjoint from either P1 or P2 (or both). Thus, the required simple path from s to t exists due to Lemma 3.1.\nCase 3: (Neither case 1 nor case 2 occur, that is) w.l.o.g., every s-connector ends at Puv and every t-connector ends at Pu\u2032v\u2032 . Thus, Puv and (s, t) separate s from Pu\u2032v\u2032 and t, and likewise Pu\u2032v\u2032 and (s, t) separate t from Puv and s. Therefore, every sconnector is disjoint from every t-connector, and both are internally vertex-disjoint from every bridge. Here too there are 2 sub-cases:\nCase 3a: No bridge exists. Then, e1, e2, (s, t) form an edge cut of G, separating G into its s-side and t-side, which is exclusion 2 of the theorem. In this case, starting at s, we need to cross each of e1, e2, (s, t) exactly once, so after any three crossings we end\nup on the t-side of G with no way back. Case 3b: At least one bridge exists. Let us show that here, the desired simple path from s to t can be constructed. Since G is triconnected, every vertex w \u2208 L must have an incident edge e not on L, as otherwise its two neighbors on L form a 2-vertex cut. We categorize such edges e into:\n1. e is on some external connector, thus called an external edge.\n2. e is on some bridge, thus called a bridge edge.\n3. None of the above, in which case e is called a bypass edge.\nWe likewise call a vertex w external, bridge, or bypass, respectively, when w has an incident edge of the respective type. Note that all vertices w on L must be of at least one such type, but the types are non-exclusive: it is possible for w to be bypass, and external, and bridge. Recall that at least two vertices on each path Puv and Pu\u2032v\u2032 must be external. Every external vertex w on Puv , resp., Pu\u2032v\u2032 , is an end-vertex of some (not necessarily unique) external s-, resp., t-connector; for each external vertex, we fix one such connector, denoting it by Psw, resp., Pwt. For a bridge B, we denote by vB its end-vertex on Puv and by v\u2032B its end-vertex on Pu\u2032v\u2032 .\nNow examine bridge end locations w.r.t. external vertex locations. For clarity, we call the direction that is towards the (v, v\u2032) edge on paths Puv, Pu\u2032v\u2032 the north direction, and that towards (u, u\u2032) south. Let vN , vS be the most northern (resp, most southern) external vertex on Puv , and likewise v\u2032N , v \u2032 S for vertices on Pu\u2032v\u2032 . Since there are at least two external vertices in each part of L, these vertices are all distinct. For convenience, we will use > to denote \u201dmore northern than\u201d, which is defined only between vertices on the same path Puv or Pu\u2032v\u2032 . There are now several cases, illustrated in Figure 4.\nCase 3b1: There is a bridge, B, such that vN > vB and v\u2032B > v\u2032S (Figure 4 (left)). Then, the desired s, t-path is:\n(PsvN , Puv[vN ..v], (v, v \u2032), Pv\u2032u\u2032 [v \u2032..v\u2032B ], B, Pvu[vB ..u], (u, u \u2032), Pu\u2032v\u2032 [u \u2032..v\u2032S ], Pv\u2032St).\nCase 3b2: Symmetrically, there is a bridge, B, such that v\u2032N > v\u2032B and vB > vS (Figure 4 (center)). Then, the desired s, t-path is:\n(PsvS , Puv[vS ..u], (u, u \u2032), Pu\u2032v\u2032 [u \u2032..v\u2032B ], B, Pvu[vB ..v], (v, v \u2032), Pv\u2032u\u2032 [v \u2032...v\u2032N ], Pv\u2032N t).\nNote that cases 3b1 and 3b2 are not necessarily mutually exclusive. Case 3b3: Neither of the above two cases hold (Figure 4 (right)). This implies that for every bridge B, either (vB \u2265 vN ) \u2227 (v\u2032B \u2265 v\u2032N ) (\u201cnorthern bridge\u201d), or (vS \u2265 vB) \u2227 (v\u2032S \u2265 v\u2032B) (\u201csouthern bridge\u201d). Since at least one bridge must exist, w.l.o.g., assume that a northern bridge exists (the other case is symmetric). Let B be a northern bridge with southernmost vB \u2265 vN , and B\u2032 a northern bridge (possibly the same as B) with southernmost v\u2032B\u2032 \u2265 v\u2032N .\nNecessity of bypasses We show below that without appropriate bypasses, G would have a 2-vertex separator, such as {vN , v\u2032N} shown in Figure 4 (right). Let us define notation for bypasses. For a bypass I , we denote by N(I) and S(I) its north and south end-vertices, respectively. We say that I is a bypass of vertex x if N(I) > x > S(I). A bypass is called pure if it has no internal elements in common with any bridge or external connector.\nLet us show that either there exists a bypass of every z with vB \u2265 z \u2265 vN , or there exists a bypass of every z\u2032 with v\u2032B\u2032 \u2265 z \u2265 v\u2032N , or both. Assume the contrary. Then, there exists a pair of vertices z, vB \u2265 z \u2265 vN , and z\u2032, v\u2032B\u2032 \u2265 z\u2032 \u2265 v\u2032N , with no bypass of either z or z\u2032. Let us choose a vertex w as follows. If z = v and z\u2032 = v\u2032, then the endvertices of B are v, v\u2032; since (v, v\u2032) by definition is not a bridge, B contains an internal vertex, which we denote by w. Otherwise, let w be v if z 6= v, else w = v\u2032 6= z\u2032. We show now that {z, z\u2032} separates w from {s, t}, in contradiction to the triconnectivity of G, thus invalidating our assumption.\nAssume, to the contrary, that P is a simple path from s to w that includes neither t, nor z, nor z\u2032. Note that if w 6\u2208 L, then P could be extended along the right part of B to Pu\u2032v\u2032 . Since L can only be reached from s through a vertex on [vN ..vS ] and z \u2265 vN , P must have at least one vertex x on Puv such that z > x (we ruled out z = x as z 6\u2208 P ). Let x\u2217 be the last vertex on P such that either z > x\u2217 or z\u2032 > x\u2217 and y be the first vertex after x\u2217 on P that is either on L or on a northern bridge; let P \u2217 = P [x\u2217..y]. Assume that x\u2217 \u2208 Puv . If y \u2208 Puv , then P \u2217 is a bypass of z, a contradiction. If y is on a northern bridge, then the concatenation of P \u2217 with the part of that bridge from y to Pu\u2032v\u2032 is a northern bridge from x\u2217 with vB > z > x\u2217. a contradiction to the definition of B. The case x\u2217 \u2208 Pu\u2032v\u2032 is symmetric.\nFor similar reasons, a simple path from t to w not including s, z, z\u2032 is also impossible, thereby completing the proof of our statement. Thus, in the rest of our analysis of Case 3b3, we assume, w.l.o.g., that there exists a bypass for every z with vB \u2265 z \u2265 vN .\nPurity of bypasses Let I be the set of bypasses for all z such that vB \u2265 z \u2265 vN . Let us show that all bypasses in I are pure. Otherwise, let I \u2208 I be impure. Suppose that I has an internal element in common with bridge B\u0303. If B\u0303 is a northern bridge, I can be spliced with B\u0303 creating a bridge B\u2032\u2032 with vB\u2032\u2032 = S(I) < vB . Note that since v\u2032B\u2032\u2032 = v \u2032 B\u0303 \u2265 v\u2032N , B\u2032\u2032 is also a northern bridge. This contradicts vB being the\nsouthernmost end-vertex at Puv of a northern bridge. Otherwise, B\u0303 is a southern bridge. Then, I can be spliced with B\u0303 creating a bridge B\u2032\u2032 with (vB\u2032\u2032 = N(I) > vN > vS)\u2227 (v\u2032N > v\u2032S \u2265 v\u2032B\u0303 = v \u2032 B\u2032\u2032). This accords with the definition of Case 3b2, not Case 3b3, a contradiction. Suppose now that I has an internal element in common with either s- or t-connector P . In the former case, I can be spliced with P creating an s-connector PsN(I). But N(I) > vN , so vN is not the northernmost external vertex on Puv , a contradiction. In the latter case, I can be spliced with P creating a t-connector with an end-vertex on Puv , contradicting the definition of Case 3.\nBypass graphs Let vNo > vB be the northernmost vertex on Puv in any bypass in I, and likewise vSo < vN be the southernmost such vertex. Now, define graph GBP as follows: GBP consists of all vertices and edges in all bypasses in I, and all vertices and edges in Puv between vNo and vSo. By construction, GBP is (vertex) 2-connected. Thus, there exist two vertex-disjoint paths between any two sets of vertices in GBP of cardinality at least 2. Let us fix a pair of such paths for the sets {vNo, vB} and {vN , vSo}. We denote them by Pxy with xy indicating the respective subscripts of v.\nWe consider the two cases for the pair of paths as above. In both, the desired simple path begins with PsvN and ends with (Pvu[vSo...u], (u, u \u2032), Pu\u2032v\u2032 [u \u2032..v\u2032S ], Pv\u2032St). Let us describe the middle part of the desired path. Case 3b3.I: There are vertex-disjoint paths PNNo and PBSo, see Figure 5 (left).\nIntuitively, here we have interleaved bypasses. So, the required middle part bypasses the end-vertex vB of bridge B, goes to (v, v\u2032) first, then crosses bridge B from the right to the left, and then bypasses the external vertex vN :\n(PNNo, Puv[vNo..v], (v, v \u2032), Pv\u2032u\u2032 [v \u2032..v\u2032B ], B, PBSo).\nCase 3b3. II: There are vertex-disjoint paths PNoSo and PNB , see Figure 5 (right). Intuitively, this means we have an overall bypass over the region between external vertex vN and bridge vertex vB . So, the middle part crosses B from the left to the right first, then takes (v,\u2032 v), and bypasses the bridge and external vertices:\n(PNB , B, Pu\u2032v\u2032 [v \u2032 B ..v \u2032], (v\u2032, v), Pvu[v..vNo], PNoSo).\nIn both cases 3b3.I and 3b3.II, the constructed path is simple, since the bypasses we used are pure, and thus cannot (internal-vertex) intersect either PsvN or B, and are completely disjoint from Pv\u2032St. Note that Figure 5 depicting case 3b3 (I and II) is a simplification with the bypass paths shown as just one or two edges. In fact, these bypass paths can be quite convoluted, using edges of multiple bypasses interleaved with sections of Puv .\nAs we have shown the desired s, t-path in all required cases, this concludes the proof of the lemma.\nDue to Lemma 3.2, the only remaining case of the if part of the proof of Theorem 3.1 that we have not considered is where some end-vertices of e1, e2, e3 are not distinct. Let us analyze the possible alternatives, thereby concluding the proof of Theorem 3.1:\n1. e1, e2, e3 form a cycle: trivial.\n2. e1, e2, e3 form a chain. W.l.o.g. let e1 = (v1, v2), e2 = (v2, v3), e3 = (v3, v4). Let G\u2032 = G\\{v2, v3}, which is a connected graph since G is 3-connected. Then, there is a path P from v4 to v1 in G\u2032, so (e1, e2, e3, P ) is a simple cycle in G.\n3. Two edges have a common vertex, and one is disjoint. W.l.o.g., let e1 = (v1, v2), e2 = (v2, v3), e3 = (v4, v5), and G\u2032 = G \\ v2. Since G is 3-connected, then G\u2032 is 2-connected, and there exist vertex-disjoint paths P1, P2 from {v4, v5} to {v1, v3} in G\u2032. W.l.o.g., P1 ends at v1. Then, (P1, e1, e2, P2, e3) is a simple cycle in G.\n4. All edges share a common end-vertex. This case is excluded by exception 1 in the theorem statement."
        },
        {
            "heading": "4 CEP on Biconnected Graphs",
            "text": "In Section 2.1, we argued that in general undirected graphs, the CEP (and thus the PEP) can be easily reduced to biconnected graphs. Above, we have determined necessary and sufficient conditions for the CEP in triconnected graphs. In this section, we analyze the CEP on an arbitrary biconnected graph G = (V,E), using its partition into\ntriconnected components provided by the SPQR tree T = T (G). For notation, definitions and properties of SPQR trees, refer to Section 2.2. We begin with defining the crucial concept of the component central w.r.t. a given set of elements.\nDefinition 4 (Central Component). For any subset S of elements of G, we call component C of T central w.r.t. S, if all elements rC(s), s \u2208 S, are distinct (that is, if \u2200s1, s2 \u2208 S : s1 6= s2 \u21d2 rC(s1) 6= rC(s2)).\nA central component does not necessarily exist in general; and if it exists, is not necessarily unique. But for our purposes, it is sufficient that a central component always exists for sets of size 3.\nLemma 4.1 (Central Component Lemma). For every set S of three elements of G, there exists a component of T central w.r.t. S.\nProof. Denote the three given elements of G by x1, x2, x3. Let us choose three components Ci, 1 \u2264 i \u2264 3, such that rCi(xi) = xi, i.e. such that each xi is a real element in Ci. If at least two of these components coincide, w.l.o.g., C1 = C2 = C, then C is central w.r.t. S. Indeed, by our assumption, x1 = rC(x1) and x2 = rC(x2) are distinct non-virtual elements. Additionally, either rC(x3) = x3 or rC(x3) is a virtual edge, which must in both cases be distinct from rC(x1) and rC(x2).\nOtherwise, all three chosen components are distinct. If some Ci lies on the path in T between the two other components, then the two elements rCi(xj), j 6= i, must be distinct: this is trivial if at least one of them is real, and due to Ci being on the path as above if both are represented by virtual edges. Thus, Ci is central w.r.t. S here too.\nOtherwise, there exists a unique component, C, in tree T such that all C1, C2, C3 are in distinct sub-trees hanging from C in T . Let these sub-trees hang on structural edges eT (ei), respectively, where ei are distinct virtual edges of C. Then, C is central w.r.t. S since each of the three xi is represented by ei in C, unless xi is a real element of C.\nWe now state and prove a crucial proposition on central components and mustinclude cycles.\nProposition 4.1. Let S = {x1, x2, x3} be a set of three elements of G, and C be any component central w.r.t. S. Then, there exists a simple cycle containing all elements of"
        },
        {
            "heading": "S in G if and only if there exists a simple cycle containing all three elements representing them in C.",
            "text": "Proof. (If) Let L\u2032 be a simple cycle in C containing all rC(x1), rC(x2), rC(x3). If L\u2032 contains no virtual edges, we are done since L\u2032 is a cycle in G. Otherwise, replace every virtual edge e \u2208 L\u2032 by a path P (e) as follows, to create the simple cycle L in G as required. Let virtual edge e = (a, b) \u2208 L\u2032. If e represents no element of S, then by Property 2.2, there exists a simple path P (e) from a to b in G(C, e). (As a special case, path P (e) may be the single edge (a, b).) Likewise, let e represent element xi \u2208 S; then, e represents no other element of S, since C is a central component w.r.t. S. By Property 2.3, there exists a simple path from a to b containing xi in G(C, e). By replacing every virtual edge e in L\u2032 by simple path P (e), we obtain a cycle, L, in\nG containing all elements of S. Cycle L is simple since graphs G(C, e) as above are disjoint, except possibly for end-vertices of edges e, by Property 2.1; this exception cannot spoil simplicity of L, since L\u2032 is simple.\n(Only if) Let L be a simple cycle in G containing all three elements of S. If L consists only of elements of C, it is a cycle in C, as required. Otherwise, cycle L is sub-divided into the inclusion-maximal sub-paths whose edges are either all in C or all in the same subgraph G(C, (a, b)), where (a, b) is a virtual edge of C. By Property 2.1, the end-vertices of each such sub-path in G(C, (a, b)) are a and b. Therefore, replacing each such sub-path by virtual edge (a, b) in C results in a cycle, L\u2032, in C. Cycle L\u2032 is as required, since if xi was an element of G(C, (a, b)), then rC(xi) = (a, b) is an edge of L\u2032.\nRemark: The reader may be curious about the relation of multiple central components to Proposition 4.1. In fact, absence of a cycle as required in a component, C, is a quite special situation. This is impossible if C is an S-node and happens in a P-node only if all all three its must-include elements are edges. Since any R-node is triconnected, by Theorem 2.6, such a cycle can be absent in an R-node also only if all three must-include elements are edges. By the following lemma, in the latter case, the central component should be unique.\nLemma 4.2. If all three elements of S are represented by edges in a component C central w.r.t. S, then C is a unique central component w.r.t. S.\nProof. Let distinct edges e1, e2, e3 represent the elements x1, x2, x3 \u2208 S, respectively, in component C central w.r.t. S. Consider another arbitrary component C \u2032; necessarily, C \u2032 \u2208 B(C, e) for some virtual edge e \u2208 C. Since e1, e2, e3 are distinct edges, then only one of them can be the same as e, so suppose w.l.o.g. that e 6= e1 and e 6= e2. This implies that neither x1 nor x2 are in B(C, e), and therefore both elements x1, x2 are represented in C \u2032 by the same virtual edge e\u2032 (such that C is in the sub-tree B(C \u2032, e\u2032)). This implies that C \u2032 is not central w.r.t. S, as required.\nWe conclude this section by summarizing the results on must-include cycles from the last two sections as one theorem.\nTheorem 4.2. Let G be a biconnected graph, and x1, x2, x3 be three distinct elements of G. Let C be any central component of T (G) w.r.t. x1, x2, x3. Then, a simple cycle in G including x1, x2, x3 exists if and only if either at least one of rC(x1), rC(x2), rC(x3) is a vertex in C, or neither of the following conditions holds:\n1. Edges rC(x1), rC(x2), rC(x3) all have a common end-vertex in C.\n2. C is an R-node and edges rC(x1), rC(x2), rC(x3) form a 3-edge cut of C.\nProof. The theorem statement is consistent, since Lemma 4.1 guarantees existence of a central component C w.r.t. x1, x2, x3 in T (G). Additionally, if C is not unique, then by Lemma 4.2, rC(xi) is a vertex for some 3 \u2265 i \u2265 1, in which case the cycle in C always exists. Due to Proposition 4.1, it is sufficient to prove that the conditions of the theorem are necessary and sufficient for existence of a simple cycle in C that includes\nrC(x1), rC(x2), rC(x3); observe that these three elements of C are distinct since C is central w.r.t. x1, x2, x3.\nConsider now all possible types of node C. If C is an S-node, the cycle as required trivially always exists. Accordingly, no three edges of an S-node (which is a cycle) share a common end-vertex, while exception 2 is not relevant. If C is a P -node, the cycle never exists if all three elements are represented by edges in C, which is covered by exception 1, and always exists otherwise, which also accords with the theorem statement. In the case where C is an R-node (which is a triconnected graph), the theorem follows immediately from Theorem 2.6 (such a cycle always exists in a triconnected graph if not all elements are edges) and Theorem 3.1 (the conditions for existence of a cycle with three must-include edges in triconnected graphs).\nTo illustrate the usage of Theorem 4.2, consider the graph shown in Figure 2 (top left). In what follows, we use the reduction of the PEP to the CEP, the other parts of Figure 2 for illustration, and the proof of Proposition 4.1 to find the required mustinclude path, if it exists. For simplicity, we choose must-include path query examples where the source and destination vertices are already connected by an edge in the graph, so that we can use the SPQR tree already shown in Figure 2 (recall that the PEP query answer does not depend on presence/absence of such an edge).\nConsider querying for a simple path from w4 to x that must include u1 and u6. Here, the equivalent CEP is for elements (w4, x), u1, u6, for which the central component is C = R(u1, u2, u4, u5). Cycle L\u2032 = (u1, u2, u5) in C includes vertex u1 and virtual edges rC((u6)) = (u2, u5) = e u2,u5 1 = V ir5 and rC((w4, x)) = (u1, u2) = e\nu1,u2 = V ir6. By substituting edge (u1, u2) with path (u1, x, w4, t, u3, u2) and edge (u2, u5) with path (u2, u6, u5), we get cycle L = (u1, x, w4, t, u3, u2, u6, u5). By removing edge (x,w4) from L, we get simple path (w4, t, u3, u2, u6, u5, u1, x), as required.\nIf queried for a must-include path from w4 to x through u1 and w2, the equivalent CEP query elements are (w4, x), u1, w2 and the central component is C = P (x, t). The representatives of (w4, x), u1, w2 are three distinct virtual edges e x,t i , 1 \u2264 i \u2264 3. Since all these edges share both end-vertices, no simple cycle including (w4, x), u1, w2 exists, due to exclusion 1 of Theorem 4.2. Thus, the required must-include path also does not exist.\nIf queried for a must-include path from u2 to u4 via w4 and u6, the equivalent CEP elements are (u2, u4), w4, u6 and the central component is C = R(u1, u2, u4, u5). The triple of representatives (u2, u4), (u2, u1), (u2, u5) of the must-include CEP elements in C is covered by both exclusions 1 and 2 of Theorem 4.2, which implies that the answer to the query is negative."
        },
        {
            "heading": "5 Algorithms for PEP/CEP and EPE",
            "text": "We now turn to the algorithms for solving the CEP and EPE. Though both algorithms are stated to work for biconnected graphs, the reductions provided in Section 2.1 imply similar results for general graphs. To solve the PEP, we use the CEP algorithm and the reduction from PEP to CEP in Section 1.1."
        },
        {
            "heading": "5.1 Determining Must-Include Paths and Cycles",
            "text": "We can now state Algorithm 1 for the CEP. Although an algorithm follows from the proofs of Proposition 4.1 and Lemma 4.1, here we state the algorithm explicitly and analyze its complexity.\nAlgorithm 1: Determining Must-Include Cycle Existence (CEP) Input: a biconnected graph G and three of its elements x1, x2, x3\n1: Compute T , the SPQR tree of G 2: Compute representatives rC(x1), rC(x2), rC(x3) for all components C \u2208 T 3: Find a component C central w.r.t. x1, x2, x3 4: if C is an S node or rC(xi) is a vertex for at least one 3 \u2265 i \u2265 1 then 5: return true 6: else if C is a P node then 7: return false 8: end if 9: /* Assert: C is an R node and all rC(xi) are edges */\n10: if rC(x1), rC(x2), rC(x3) form an edge cut of C 11: or rC(x1), rC(x2), rC(x3) all have a common end-vertex then 12: return false 13: else 14: return true 15: end if\nTheorem 5.1. Given any biconnected graph G = (V,E), Algorithm 1 always answers the CEP correctly, and has time complexity O(|E|).\nProof. Correctness of Algorithm 1 follows from Theorem 4.2. The complexity of this algorithm is dominated by computing the SPQR tree of G, which is O(|E|). Computing the representatives can be done by traversing T from any of its vertices in O(|E|) time as well. It is clear from examining the rest of the steps of Algorithm 1 that they all take time O(|E|), with some of the steps in fact only requiring constant time.\nDue to the equivalence between PEP and CEP stated in Section 2.1, PEP(G, s, t, w1, w2) can be solved by executing Algorithm 1 for CEP(G \u222a (s, t), (s, t), w1, w2), with the same time bound."
        },
        {
            "heading": "5.1.1 Finding the Cycle",
            "text": "It may be of interest to actually find a simple cycle that includes the given elements x1, x2, x3 when it exists. Naturally, we begin by constructing T (G) and finding the representatives of x1, x2, x3 and a central component C, as in Algorithm 1. Then, consider any element xi that is not a real element in C. Finding the portion of the required cycle outside C that contains xi entails finding a path between the ends of the virtual edge rC(xi) outside C that contains xi. This can be done in linear time using the FordFulkerson algorithm by finding two vertex-disjoint (except at xi, if xi is a vertex) paths between xi and the ends of rC(xi) in the subgraph G(C, rC(xi)) (see Section 2.1).\nFinding the part of the cycle in C that includes all the rC(xi) (to be spliced with the paths as above) is trivial for S-nodes and P-nodes. If C is an R-node and at least one of xi is a real vertex of C, this can be done as described in Section 2.3. The nontrivial task is finding the portion of the cycle as above in the central component when C is an R-node and all rC(xi) are edges. Here, there are many cases to handle, so we specify this part of the algorithm only implicitly. Observe that the proof of Theorem 3.1, including its required lemmas, specifies the required cycle in a constructive way, except for finding paths as in Menger\u2019s theorem; the latter is covered by Section 2.1. Thus, by following the cases of the proof, we (implicitly) get an O(|E|) algorithm for finding a simple x1, x2, x3-cycle. By the reduction in Section 2.1, this also implies an O(|E|) algorithm for finding a simple s, {w1, w2}, t-path."
        },
        {
            "heading": "5.2 Enumerating Exclusion Pairs",
            "text": "Consider now the EPE problem. Recall the notation G+ = G \u222a (s, t). The idea here is to visit every component C \u2032 that could potentially be central in T (G+) w.r.t. (s, t) and some two vertices not in C \u2032, and for each such component emit all possible vertex pairs excluded from being on a simple s, t-path by Theorem 4.2.\nAlgorithm 2 for the EPE starts with the component C which has (s, t) as a real edge, assigning C to be the root of T (G+), and visits components C \u2032 recursively using procedure TRAVERSE. In each such C \u2032, we consider all virtual edges other than rC\u2032((s, t)) as potentially generating exclusions; we use Evirt(C\u2212) to denote the set of virtual edges in C\u2212 = C \u2032 \\ rC\u2032((s, t)). Recall that rC\u2032\u2032(C \u2032), the representation of C \u2032 in its child C \u2032\u2032 is the virtual edge in C \u2032\u2032 corresponding to the structural edge between C \u2032 and C \u2032\u2032. This allows us to cheaply supply rC\u2032\u2032((s, t)) = rC\u2032\u2032(C \u2032) as an additional argument in the recursive call at the end of procedure TRAVERSE. For convenience, we use s\u2032, t\u2032 to denote the ends of rC\u2032((s, t)) in C \u2032.\nIn each component C \u2032, given some set E\u2032 of virtual edges in C \u2032, we use function EMITPAIRS(C \u2032, E\u2032) to emit exclusion pairs of vertices from G, as follows. For a virtual edge e in C \u2032, denote by V (C \u2032, e) the set of vertices (from G) in G(C \u2032, e) excluding the end-vertices of e. Then, for every pair of distinct virtual edges {e1, e2} \u2286 E\u2032, the exclusion vertex pair {v1, v2} is emitted for every pair of vertices v1 \u2208 V (C \u2032, e1) and v2 \u2208 V (C \u2032, e2). EMITPAIRS(C \u2032, E\u2032) can work either implicitly, i.e., just output pointers to C \u2032 and to the set of virtual edges E\u2032, or explicitly, i.e., output each exclusion vertex pair {v1, v2} explicitly.\nEMITPAIRS is called exactly as indicated by Theorem 4.2. The S-nodes do not cause exclusion pairs, because they are cycles and thus there always trivially exists a cycle containing any set of elements therein, so the algorithm does not call EMITPAIRS for S-nodes. If C \u2032 is a P-node, all pairs of virtual edges in C\u2212 cause exclusions, which are emitted.\nIf C \u2032 is an R-node, exclusions are emitted (in line 16) for every set of cardinality at least 2 of virtual edges of C\u2212 incident on either end of rC\u2032((s, t)), as well as (in line 22) for every pair of virtual edges forming a 3-edge cut of C \u2032 together with edge (s\u2032, t\u2032), unless these edges are both incident on either s\u2032 or on t\u2032, in which case we do not need to emit them again (already emitted in line 16). Note that E\u0303 is a 2-edge\nAlgorithm 2: Exclusion-Pairs Enumeration (EPE) Input: a biconnected graph G and two of its vertices s, t\n1: Let G+ = G \u222a (s, t) 2: Compute T = T (G+), the SPQR tree of G+ 3: Root T at C, the unique component of T where rC((s, t)) = (s, t) is a real edge 4: Call TRAVERSE(C, (s, t)) 5: exit 6: procedure TRAVERSE(C \u2032, (s\u2032, t\u2032)) 7: Let C\u2212 = C \u2032 \\ (s\u2032, t\u2032) 8: if C \u2032 is a P node then 9: if |Evirt(C\u2212)| \u2265 2 then\n10: EMITPAIRS(C \u2032, Evirt(C\u2212)) 11: end if 12: else if C \u2032 is a non-leaf R node then 13: for u \u2208 {s\u2032, t\u2032} do 14: Let EEX = {(u, v)|(u, v) \u2208 Evirt(C\u2212)} 15: if |EEX | \u2265 2 then 16: EMITPAIRS(C \u2032, EEX ) 17: end if 18: end for 19: Let Cuts = FIND2EDGECUTS(C\u2212, (s\u2032, t\u2032)) 20: for all EEX \u2208 Cuts s.t. EEX \u2286 Evirt(C\u2212) 21: and the edges in EEX are not both incident on either s\u2032 or t\u2032 do 22: EMITPAIRS(C \u2032, EEX ) 23: end for 24: end if 25: for all C \u2032\u2032 \u2208 children(C \u2032) do 26: Call TRAVERSE(C \u2032\u2032, rC\u2032\u2032(C \u2032)) 27: end for 28: end procedure\ncut separating s\u2032 and t\u2032 in C\u2212 = C \u2032 \\ (s\u2032, t\u2032) if and only if E\u0303 \u222a (s\u2032, t\u2032) is a 3-edge cut separating s\u2032 and t\u2032 in C \u2032. We show how to find all such 2-edge cuts effectively in Section 5.3, thereby describing function FIND2EDGECUTS.\nTheorem 5.2. Given any graph G = (V,E) with vertices s, t such that G+ = G\u222a(s, t) is biconnected, Algorithm 2 always emits the correct exclusion pairs. The algorithm has time complexity O(|E|) for implicit output and O(max{|E|, N}) = O(|V |2) for explicit output, where N is the number of emitted exclusion pairs.\nProof. (outline) Correctness of Algorithm 2 is shown as follows. First, we claim that whenever TRAVERSE(C \u2032, (s\u2032, t\u2032)) is called, we have (s\u2032, t\u2032) = rC\u2032((s, t)), which is shown by trivial induction. Next, let w1, w2 be an exclusion pair w.r.t. s, t. Then, by Theorem 4.2, there exists a component C of type P or type R central w.r.t. w1, w2, (s, t). In the former case (type P), rC(w1), rC(w2), rC((s, t)) are distinct virtual edges (ex-\ncept for rC((s, t)), which may be a real edge) in C. All P nodes are visited and all exclusion pairs w.r.t. such edge sets are emitted. In the latter case (type R), rC(w1), rC(w2), rC((s, t)) are all virtual edges (except for rC((s, t)), which may be a real edge), such that either they all meet at one end of rC((s, t)), or they form a 3-edge cut. Since TRAVERSE explicitly emits exclusions in all these cases, the algorithm emits all exclusion pairs. The converse follows since the above are the only exclusions emitted by the algorithm.\nThe total time for all FIND2EDGECUTS calls is O(|E|) (see Section 5.3). By examination of the pre-order traversal of the components of T , the O(|E|) complexity for implicit output follows from each edge in components of T being examined at most a constant number of times and the O(|E|) size of the entire SPQR tree data structure [11] (see Section 2.2).\nFor explicit output, the required list of vertex pairs can be generated in O(max{|E|, N}) using the following lemma:\nLemma 5.1. The number of nodes in the sub-tree of T hanging on any virtual edge e in any component C0 is at most twice the number of internal (that is, excluding the end-vertices of e) vertices of G in V (C0, e).\nProof. Consider the scan in T starting from virtual edge e in C0. Each descendant component C \u2032 contains at least one vertex of G not counted before visiting C \u2032, except for P-nodes. Observe that any P-node C \u2032 has least one child and has no children of type P. Hence, we can choose anyone of its children and charge it for C \u2032. The lemma follows.\nDue to the lemma, assuming the list of vertices of G in each component C \u2032 is explicitly stored, the complexity of creating any list LC\u2032e = V (C \u2032, e) via the subtree scan is thus linear in the list size, O(|V (C \u2032, e)|). Therefore, even using the straightforward scheme of creating the lists of vertices LC\u2032e for all e \u2208 E\u2032 whenever EMITPAIRS(C \u2032, E\u2032) is called, and then simply iterating over the pairs of lists to produce the output, takes time linear in the number of vertex pairs emitted.\nRemark: Note that Algorithm 2 can easily be modified to emit all excluded pairs of edges, rather than vertices. Simply omit the conditions checking whether the edges in EEX are virtual, allowing real edges to be emitted as well. The semantics of EMITPAIRS is then changed to emit the element pairs using the set of edges in each G(C \u2032, e) instead of the set of vertices therein. Additionally, when computing the set of edges for the 2nd argument (EEX ) of EMITPAIRS, real edges are also added: whenever Algorithm 2 indicates Evirt(C\u2212) this is replaced by all edges of C\u2212. Then, EMITPAIRS interprets a real edge e in its EEX argument as an exclusion involving e itself, rather than the reference to the edges in G(C \u2032, e). Generalizing to all excluded pairs of elements (vertices and edges) can be done similarly."
        },
        {
            "heading": "5.3 Finding the 2-Edge Cuts",
            "text": "We now turn to the only remaining part of our solution to EPE: finding all 2-edge cuts between s\u2032 and t\u2032 in C\u2212 = C \\ (s\u2032, t\u2032), where C is a central component in T of\ntype R found by Algorithm 2 (see the call to procedure FIND2EDGECUTS therein). In a general graph, it is not so trivial to list all s, t-mincuts, and there might be exponentially many of them. However, our case is quite specific, allowing \u201dleaving behind\u201d both edges of the last found 2-edge cut before continuing the search for the next 2-edge cut, as discussed below; this allows for a simple and efficient algorithm. In what follows, we use the notation and knowledge on basics of graph connectivity and related algorithms presented in Section 2.1.\nLet us analyze the structure of 3-edge s, t-cuts in an arbitrary triconnected graph G = (V,E), |V | \u2265 4, such that (s, t) \u2208 E. Recall that any (minimal) edge cut divides G into exactly two connected induced subgraphs, whose vertex sets form a 2- partition of V . For any s, t-cut E\u2032, we denote the corresponding 2-partition of V by (V s(E\u2032), V t(E\u2032)), s \u2208 V s(E\u2032), t \u2208 V t(E\u2032).\nBy Theorem 2.4, there is no 1- or 2-edge cut in G. Henceforth in our analysis, we assume that there exist 3-edge s, t-cuts in G; hence, those cuts are minimum s, t-cuts in G. By Theorem 2.3, these edge cuts do not cross each other. This means that for any two such edge cuts E\u2032 and E\u2032\u2032, either V s(E\u2032) \u2229 V t(E\u2032\u2032) or V s(E\u2032\u2032) \u2229 V t(E\u2032) is empty; equivalently, either V s(E\u2032) \u2282 V s(E\u2032\u2032) or V s(E\u2032\u2032) \u2282 V s(E\u2032). Therefore, if there are q 3-edge s, t-cuts in G, then we can order them as Ei, 1 \u2264 i \u2264 q, so that for any 1 \u2264 i < j \u2264 q, V s(Ei) \u2282 V s(Ej) (a nested sequence of 2-partitions). We denote: V0 = V\ns(E1), Vq = V t(Eq), and, for any 1 \u2264 i \u2264 q\u22121, Vi = V s(Ei+1)\\V s(Ei) 6= \u2205. Denote G\u2212 = (V,E \\ (s, t)). Obviously, each 3-edge s, t-cut E\u2032 in G contains edge (s, t) and, thus, naturally defines the 2-edge s, t-cut E\u2032 \\ (s, t) of G\u2212 dividing V in the same way. That is, for every i, there are exactly two edges between V s(Ei) and V t(Ei) in G\u2212. Let us show that both those edges are between Vi\u22121 and Vi, for all i. Assume, to the contrary, that there is an edge between V s(Ei) and V t(Ei+1), \u201cjumping over\u201d Vi and thus common to Ei and Ei+1 (as well as, possibly, to other Ej). A simple count shows that there is at most one edge between V s(Ei) and Vi and at most one edge between Vi and V t(Ei+1). That is, there are overall at most two edges connecting Vi to the rest of G, a contradiction to the absence of 1- and 2-edge cuts in G. For illustration, see Figure 6 (right). Summarizing, graph G\u2212 has a very special structure: a sequence of q + 1 induced subgraphs G(Vi) with exactly two edges between any two subsequent subgraphs, and no other edges between these subgraphs. See Figure 6 (left) for an example.\nWe now use the flow techniques: construct flow network N from graph G\u2212 by replacing each edge (u, v) therein by two directed edges (u, v) and (v, u) of capacity 1 each and by assigning s as its source and t as its sink. Recall that by Theorem 2.2, the size of any maximum flow in N equals the size of any minimum (edge) s, t-cut. Thus, there is no 3-edge s, t-cut in G if and only if there is no 2-edge s, t-cut in G\u2212 and if and only if the max-flow size in N is at least 3.\nWe consider the case where the max-flow size in N is 2 and the q cuts Ei \\ (s, t) are the minimum 2-edge s, t-cuts (\u201cmin-cuts\u201d) in N . Let f be any maximal flow of size 2 in N , and Nf be the residual network w.r.t. f . Any edge (u, v) in N is absent in Nf if and only if it is saturated: f(u, v) = 1. Note that both edges of any cut Ei \\ (s, t) are saturated by flow f in the direction from Vi\u22121 to Vi in N , so that their two inverse edges (directed from Vi to Vi\u22121) are the only edges connecting Vi\u22121 and Vi in Nf . Picard and Queyranne [20] proved that all min-cuts together divide the vertices of Nf\ninto the vertex sets of its strongly connected components. That is, in our case, the strongly connected components of Nf are the induced graphs G(Vi).\nRecall that each iteration of the Ford-Fulkerson algorithm executes the vertex scan (say, BFS, to be specific) from s in the current residual network. If t is labeled, then the flow is incremented. In our case, the flow size increases by exactly one at each iteration, so if t is labeled by the third BFS, then the max-flow size is at least 3, and thus, there is no 2-egde s, t-cut in G\u2212. Otherwise, the flow f constructed after the first two iterations is maximum. Thus, the BFS scan executed in Nf labels exactly the vertices of V0 and then stops, since the orientation of the edges of E1, the only edges connecting V0 to its outside in Nf , prevents BFS from advancing. We thus are able to detect the edge cut E1 as the two edges whose one end-vertex is labeled and the other is not. If after that we label artificially the end-vertices of edges in E1 external to V0, i.e. those in V1, and let BFS continue, then the BFS would label exactly the vertices of V1, stopping similarly. Then, we can find the edge cut E2, and so on up to finding Eq; thereafter, BFS labels all vertices of Vq , including t.\nSee procedure FIND2EDGECUTS (Algorithm 3) implementing this scheme, where the notation is changed to that compatible with the main algorithm solving EPE: G\u2212 \u2192 C\u2212, s\u2192 s\u2032, t\u2192 t\u2032. Some technical trick is added to the usual BFS scan for detecting the edges of each next min-cut. Instead of scanning only the edges of Nf out-going from the currently labeled vertex v, we scan all the edges of C\u2212 (equivalently, the edges of N ) incident on v. Such an edge (v, v\u2032) can only be in the next min-cut if it has flow 1 assigned (and thus is absent in Nf ) and if v\u2032 is currently unlabeled. In each such case, we include that edge in the temporary list Cut. In the post-processing after the labeling process stops, we exclude from Cut all edges with both end-vertices labeled, thus retaining only the two edges going from the current (labeled) strongly connected component to the next (unlabeled) one.\nThe linear time bound O(|E|) of Algorithm 3 running on G follows from the O(|E|) time of each iteration of the Ford-Fulkerson algorithm and of BFS. All operations deviating from the standard BFS are either constant-time or done at most twice per edge. That is, the runtime of procedure FIND2EDGECUTS on C\u2212 is proportional to the number edges therein, which is O(|E|) total in all components (see Section 2.2). Hence, the total time of all runs of FIND2EDGECUTS in Algorithm 2 on G is O(|E|).\nAlgorithm 3: Finding 2-Edge Cuts between s\u2032 and t\u2032\nInput: graph C\u2212, such that C\u2212 \u222a (s\u2032, t\u2032) is 3-connected Output: list of edge pairs Cuts\n1: function FIND2EDGECUTS(C\u2212, (s\u2032, t\u2032)) 2: Construct flow network N from C\u2212: each edge of C\u2212 3: generates two anti-parallel edges in N of capacity 1 each, 4: source=s\u2032, target=t\u2032 5: Execute two iterations of the Ford-Fulkerson algorithm on N 6: Cuts\u2190 \u2205, QUEUE\u2190 \u2205, Cut\u2190 \u2205 7: Unlabel all vertices in C\u2212 8: Label s\u2032 and Enqueue(QUEUE,{s\u2032}) 9: while vertex t\u2032 is not labeled do\n10: if Empty(QUEUE) then 11: Remove from Cut all (u, v) where u, v are both labeled 12: Add Cut to Cuts 13: Let (u\u2032, u\u2032\u2032), (v\u2032, v\u2032\u2032) be the edges in Cut s.t. u\u2032, v\u2032 are labeled 14: Label u\u2032\u2032 and v\u2032\u2032 and Enqueue(QUEUE,{u\u2032\u2032, v\u2032\u2032}) 15: Cut\u2190 \u2205 16: else 17: v \u2190 Dequeue(QUEUE) 18: for all (v, v\u2032) \u2208 C\u2212 s.t. v\u2032 is not labeled do 19: if (v, v\u2032) has flow=1 assigned then 20: Add (v, v\u2032) to Cut 21: else 22: Label v\u2032 and Enqueue(QUEUE,{v\u2032}) 23: end if 24: end for 25: end if 26: end while 27: return Cuts 28: end function"
        }
    ],
    "title": "On Existence of Must-Include Paths and Cycles in Undirected Graphs",
    "year": 2023
}