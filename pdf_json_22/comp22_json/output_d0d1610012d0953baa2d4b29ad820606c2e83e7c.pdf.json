{
    "abstractText": "The min-wait foremost, min-hop foremost and min-cost foremost paths and walks problems in interval temporal graphs are considered. We prove that finding min-wait foremost and min-cost foremost walks and paths in interval temporal graphs is NP-hard. We develop a polynomial time algorithm for the single-source all-destinations min-hop foremost paths problem and a pseudopolynomial time algorithm for the single-source all-destinations min-wait foremost walks problem in interval temporal graphs. We benchmark our algorithms against algorithms presented by Bentert et al. for contact sequence graphs and show, experimentally, that our algorithms perform up to 207.5 times faster for finding min-hop foremost paths and up to 23.3 times faster for finding min-wait foremost walks.",
    "authors": [
        {
            "affiliations": [],
            "name": "Anuj Jain"
        },
        {
            "affiliations": [],
            "name": "Sartaj Sahni"
        }
    ],
    "id": "SP:a1dde53477d48a6b1c2adb0b1998d1e32006aad4",
    "references": [
        {
            "authors": [
                "C. Scheideler"
            ],
            "title": "Models and Techniques for Communication in Dynamic Networks",
            "venue": "In Proceedings of the STACS19th Annual Symposium on Theoretical Aspects of Computer Science, Antibes, Juan les Pins, France,",
            "year": 2002
        },
        {
            "authors": [
                "I. Stojmenovi\u0107"
            ],
            "title": "Location Updates for Efficient Routing in Ad Hoc Networks. In Handbook of Wireless Networks and Mobile Computing",
            "year": 2002
        },
        {
            "authors": [
                "O. Michail"
            ],
            "title": "An Introduction to Temporal Graphs: An Algorithmic Perspective",
            "venue": "arXiv 2015,",
            "year": 2015
        },
        {
            "authors": [
                "N. Santoro",
                "W. Quattrociocchi",
                "P. Flocchini",
                "A. Casteigts",
                "F. Amblard"
            ],
            "title": "Time-Varying Graphs and Social Network Analysis: Temporal Indicators and Metrics",
            "year": 2011
        },
        {
            "authors": [
                "F. Kuhn",
                "R. Oshman"
            ],
            "title": "Dynamic Networks: Models and Algorithms",
            "venue": "SIGACT News",
            "year": 2011
        },
        {
            "authors": [
                "S. Bhadra",
                "A. Ferreira"
            ],
            "title": "Computing multicast trees in dynamic networks and the complexity of connected components in evolving graphs",
            "venue": "J. Internet Serv. Appl. 2012,",
            "year": 2012
        },
        {
            "authors": [
                "H. Wu",
                "J. Cheng",
                "Y. Ke",
                "S. Huang",
                "Y. Huang"
            ],
            "title": "Efficient Algorithms for Temporal Path Computation",
            "venue": "IEEE Trans. Knowl. Data Eng",
            "year": 2016
        },
        {
            "authors": [
                "B.M. Bui-Xuan",
                "A. Ferreira",
                "A. Jarry"
            ],
            "title": "Evolving graphs and least cost journeys in dynamic networks. In Proceedings of the WiOpt\u201903: Modeling and Optimization in Mobile, Ad Hoc and Wireless Networks",
            "venue": "Sophia Antipolis, France,",
            "year": 2003
        },
        {
            "authors": [
                "M. Bentert",
                "A.S. Himmel",
                "A. Nichterlein",
                "R. Niedermeier"
            ],
            "title": "Efficient computation of optimal temporal walks under waiting-time constraints",
            "venue": "Appl. Netw. Sci. 2020,",
            "year": 2020
        },
        {
            "authors": [
                "F. Guo",
                "D. Zhang",
                "Y. Dong",
                "Z. Guo"
            ],
            "title": "Urban link travel speed dataset from a megacity road network",
            "venue": "Sci. Data 2019,",
            "year": 2019
        },
        {
            "authors": [
                "S. Gheibi",
                "T. Banerjee",
                "S. Ranka",
                "S. Sahni"
            ],
            "title": "An Effective Data Structure for Contact Sequence Temporal Graphs",
            "venue": "In Proceedings of the 2021 IEEE Symposium on Computers and Communications (ISCC), Athens, Greece,",
            "year": 2021
        },
        {
            "authors": [
                "S. Bhadra",
                "A. Ferreira"
            ],
            "title": "Complexity of Connected Components in Evolving Graphs and the Computation of Multicast Trees in Dynamic Networks. In Proceedings of the Ad-Hoc, Mobile, and Wireless Networks, Montreal",
            "venue": "QC, Canada,",
            "year": 2003
        },
        {
            "authors": [
                "A. Casteigts",
                "A. Himmel",
                "H. Molter",
                "P. Zschoche"
            ],
            "title": "The Computational Complexity of Finding Temporal Paths under Waiting Time Constraints",
            "venue": "arXiv 2019,",
            "year": 2019
        },
        {
            "authors": [
                "P. Zschoche",
                "T. Fluschnik",
                "H. Molter",
                "R. Niedermeier"
            ],
            "title": "The Complexity of Finding Small Separators in Temporal Graphs",
            "venue": "arXiv 2018,",
            "year": 2018
        },
        {
            "authors": [
                "A. Mislove",
                "M. Marcon",
                "K.P. Gummadi",
                "P. Druschel",
                "B. Bhattacharjee"
            ],
            "title": "Measurement and Analysis of Online Social Networks",
            "venue": "In Proceedings of the 5th ACM/Usenix Internet Measurement Conference (IMC\u201907),",
            "year": 2007
        },
        {
            "authors": [
                "J. Kunegis"
            ],
            "title": "KONECT: The Koblenz Network Collection",
            "venue": "In Proceedings of the 22nd International Conference on World Wide Web, WWW \u201913 Companion, Rio de Janeiro, Brazil,",
            "year": 2013
        }
    ],
    "sections": [
        {
            "text": "Citation: Jain, A.; Sahni, S. Foremost\nWalks and Paths in Interval Temporal\nGraphs. Algorithms 2022, 15, 361.\nhttps://doi.org/10.3390/a15100361\nAcademic Editor: Roberto\nMontemanni\nReceived: 16 August 2022\nAccepted: 22 September 2022\nPublished: 29 September 2022\nPublisher\u2019s Note: MDPI stays neutral\nwith regard to jurisdictional claims in\npublished maps and institutional affil-\niations.\nCopyright: \u00a9 2022 by the authors.\nLicensee MDPI, Basel, Switzerland.\nThis article is an open access article\ndistributed under the terms and\nconditions of the Creative Commons\nAttribution (CC BY) license (https://\ncreativecommons.org/licenses/by/\n4.0/).\nKeywords: interval temporal graphs; contact sequence temporal graphs; foremost walks; min-hop foremost walks; min-wait foremost walks; min-cost foremost walks; NP-hard"
        },
        {
            "heading": "1. Introduction",
            "text": "Temporal graphs are graphs in which the edges connecting vertices or the characteristics of these edges may change with time. The applications of temporal graphs include the spread of viral diseases, information dissemination by means of physical/virtual contact between people, understanding behavior in online social networks, modeling data transmission in phone networks, modeling traffic flow in road networks, and studying biological networks at the molecular level [1\u20137]. Two popular categories of temporal or dynamic graphs are contact-sequence (temporal) graphs and interval-temporal graphs. In a contact-sequence graph, each directed edge (u, v) has the label (departure_time, travel_duration), where departure_time is the time at which one can leave vertex u along edge (u, v) and travel_duration is the time it takes to traverse the edge. Therefore, vertex v is reached at time departure_time + travel_time. Note that a contact-sequence graph may have many edges from vertex u to vertex v; each edge has a different departure_time. In an interval-temporal graph, each directed edge (u, v) has a label that is comprised of one or more tuples of the form (start_time, end_time, travel_duration), where start_time \u2264 end_time defines an interval of times at which one can depart vertex u. If one departs u at time t, start_time \u2264 t \u2264 end_time, one reaches v at time t + travel_duration. The intervals associated with the possibly many tuples that comprise the label of an edge (u, v) must be disjoint. Figures 1 and 2 are examples of contact-sequence and interval-temporal graphs, respectively. A (time-respecting) walk in a temporal graph is a sequence of edges with the property that the end vertex of one edge is the start vertex of the next edge (if any) on the walk, each edge is labeled by the departure time from the start vertex of the edge, and the departure time label on each edge is a valid departure time for that edge and is greater than or equal to the arrival time (if any) at the edge\u2019s start vertex (A more formal definition is provided in\nAlgorithms 2022, 15, 361. https://doi.org/10.3390/a15100361 https://www.mdpi.com/journal/algorithms\nSection 2). A (time-respecting) path is a walk in which no vertex is repeated (i.e., there is no cycle). < S, 1, A, 2, B > and < S, 0, B, 5, C > are example walks in the temporal graphs of Figures 1 and 2, respectively. Both walks are also paths.\nAn application that can be modeled with a contact-sequence graph is a flight network. Each flight has a departure time at which it leaves the originating airport and a certain travel duration before it can reach the destination airport. On the other hand, if we consider the example of a road network, there is no single instance of time when one needs to depart on a given street. There may be different time windows (or time intervals) during which a street may be open for travel. Further, we may define time windows based on travel duration needed to reach from point A to point B on a given street due to different traffic\nconditions during different times of the day (such as office hours). Such networks cannot be modeled using contact-sequence graphs, as a given time window represents infinitely many possible departure times and, hence, infinitely many contact sequence edges. It is easy to see that every contact-sequence graph can be modeled as an interval-temporal graph. Further, when time can be discretized, every interval-temporal graph can be modeled as a contact-sequence graph (with potentially an explosion in the number of edges). The authors of [8\u201311] focus on finding optimal paths and walks. Optimization criteria such as f oremost (arrive at the destination at the earliest possible time), minhop (use the fewest number of hops when going from the source to the destination vertex), shortest (the time taken to go from the source to the destination is minimized), and so on, are considered. Gheibi et al. [12] present a new data structure for contact-sequence graphs that results in faster algorithms for many of the path problems studied in [8]. While [9] focuses on intervaltemporal graphs, refs. [8,10] use the contact-sequence model. Ref. [10] presents an algorithm for finding walks that optimize any linear combination of eight different optimization criteria ( f oremost, reverse_ f oremost, f astest, shortest, cheapest, most_likely, min_hop, min_wait). In our earlier paper [13], we developed algorithms to find optimal foremost and min-hop paths in interval-temporal graphs. These algorithms were demonstrated experimentally to run faster than earlier algorithms for these problems. A temporal graph may have many walks/paths that optimize a criterion such as foremost. In some applications, it is required to find a walk/path that optimizes a secondary criterion from among all walks/paths that optimize a primary criterion. For example, we may desire a min-wait foremost path (i.e., a foremost path in which the sum of the wait times at intermediate vertices is minimized) or a min-hop foremost path (a foremost path that goes through the fewest number of edges). For example, when selecting flights to go from A to B one may wish to use a min-wait foremost path (a route that minimizes the total wait time at intermediate airports while getting to the destination at the earliest possible time) or a min-hop foremost path (a route that involves the fewest number of connections while guaranteeing the earliest possible arrival time). In this paper, we examine the min-wait, min-hop, and min-cost (each edge or edge interval has an additional attribute, its cost), foremost walks/paths problems. As discussed in Section 6, the algorithm by Bentert et al. can be tuned by carefully choosing the coefficients for different optimization criteria to find min-hop foremost paths and min-wait foremost walks in contact-sequence temporal graphs. We use this method to benchmark our algorithms against the algorithm by Bentert et al. and show that we perform about 207.5 times faster for finding min-hop foremost paths and up to 23.3 times faster for finding min-wait foremost walks. Further, we solve these problems on the intervaltemporal graphs that can represent a wider problem space for temporal graphs, as opposed to the contact-sequence temporal graphs.\nOur main contributions in this paper are:\n1. We show that the problems for finding min-cost foremost and min-wait foremost paths and walks in interval temporal graphs are NP-hard. 2. We develop a polynomial time algorithm for the single-source all-destinations minhop foremost paths problem in interval-temporal graphs. 3. We develop a pseudopolynomial time algorithm for the single-source all-destinations min-wait foremost walks problem in interval-temporal graphs. 4. We show that the problem of finding min-hop foremost paths and min-wait foremost walks can be modeled using the linear combination formulation employed in Section 6 when the optimization criteria are discrete (e.g., time is discrete). Our modeling methodology readily extends to other primary and secondary criteria as well as to multiple levels of secondary criteria (e.g., shortest min-hop foremost path). 5. We benchmark our algorithms against the algorithm of Bentert et al. [10] using datasets for which the preceding modeling can be used. On these datasets, our algorithm is up to 207.5 times faster for finding min-hop foremost paths and up to 23.3 faster for finding min-wait foremost walks.\nThe roadmap of this paper is as follows. In Section 2, we describe the problems of finding min-hop foremost paths (mh f paths), min-wait foremost walks (mw f walks), and min-cost foremost paths (mc f paths). In Section 3, we show that the problems of finding mw f paths and walks and the problem for finding mc f paths in interval temporal graphs are NP-hard. In Section 4, we present theorems that describe the properties of min-hop foremost paths in temporal graphs. We review the data structures used to represent interval-temporal graphs along with some fundamental functions necessary for the algorithm for finding mh f paths. Finally, we present the algorithm for finding mh f paths in interval-temporal graphs along with the proof of its correctness and its computational complexity. In Section 5, we present theorems that describe the properties of mw f walks in interval-temporal graphs. We introduce additional data structures required by the algorithm we propose for finding mw f walks in interval-temporal graphs. Finally, we present the algorithm for finding the mw f walks in interval-temporal graphs along with proof of its correctness and complexity analysis. In Section 6, we show how the problems for finding foremost paths and walks with a secondary optimization criteria can be modeled as optimal walks with linear combination of multiple optimization criteria. We use this modeling to find mh f paths and mw f walks in contact sequence graphs using the algorithm of Bentert et al. [10], which optimizes a linear combination of criteria. In Section 7, we compare our algorithms for finding mh f paths and mw f walks with the algorithm by Bentert et al. [10] by transforming contact-sequence graphs to interval-temporal graphs and vice versa. Finally, we conclude in Section 8."
        },
        {
            "heading": "2. Foremost Walks and Paths",
            "text": "A walk (equivalently, valid walk, temporal walk or time-respecting walk) in a temporal graph is an alternating sequence of vertices and departure times ut0, t0, ut1, t1, . . . , utk where (a) ti is a permissible departure time from uti to uti+1 and (b) for 0 \u2264 i < k\u2212 1, ti +\u03bbi) \u2264 ti+1. Here, \u03bbi is the travel duration when departing uti at ti using the edge (uti, uti+1) (i.e., ti + \u03bbi is the arrival time at uti+1 ). For this walk, ut0 is the source vertex and utk the destination. Note that every walk in which a vertex is repeated contains one or more cycles. A walk that has no cycle (equivalently, no vertex repeats) is a path. W1 = S, 0, B, 5, C is a walk from S to C in the temporal graph of Figure 2. W2 = S, 0, A, 1, B, 3, C, 5, A is another walk in the temporal graph of Figure 2. W1 does not contain any cycles as none of the vertices are repeated from source to destination. Hence, W1 is also a path. However, W2 has vertex A that repeats. Therefore, it is not a path. We are interested in f oremost paths and walks in a temporal graph that start at a vertex s at a time \u2265 tstart and end at another vertex v. As defined in [8\u201310], a f oremost walk is a walk from a source vertex s to a destination vertex v that starts at or after a given time tstart and has the arrival time t f , which is the earliest possible arrival time at the destination v among all possible walks from s to v.\n2.1. Min-Hop Foremost\nA min-Hop foremost (mh f ) walk is a foremost walk from a source vertex s to another vertex v that goes through the fewest number of intermediate vertices. We observe that every mh f walk is an mh f path, as cycles may be removed from any s to v walk to obtain a path with a fewer number of hops and the same arrival time at v. For this reason, we refer to mh f walks as mh f paths in the rest of this paper. As an example, consider the interval-temporal graph of Figure 3. Every walk in this graph is also a path. The paths P1 =< a, 0, b, 1, c, 7, d > and P2 =< a, 0, c, 7, d > arrive at d at time 8 and are foremost paths from a to d. P2 is a 2-hop foremost path while P1 is a 3-hop foremost path. P2 is the only min-hop foremost path or mh f path from a to d in Figure 3.\n2.2. Min-Wait Foremost\nA min-wait foremost or mw f walk is a f oremost walk from a source vertex s to any other vertex v that accumulates minimum total wait time at the vertices visited by the walk. The wait time at each vertex u is departure_time(u)\u2212 arrival_time(u). The total wait time accumulated by the walk is the sum of the wait times at each vertex u. Therefore, mw f walk is a foremost walk from s to v that minimizes (\u2211uti departure_time(uti)\u2212 arrival_time(uti)) where uti \u2208 vertices(mw f (s, v)) and uti 6= s; uti 6= v, as there is no wait time accumulated at the source vertex and the destination vertex. mw f walks can have cycles, as is evident from the example of Figure 4. The mw f walk from source vertex s to destination vertex b is mw f (s, b) = s, 0, a, 2, c, 4, d, 5, a, 7, b, arriving at b at time 8 with total wait time of 1 accumulated at vertex a. Alternate f oremost paths from s to b are P1 = s, 0, a, 4, b, arriving at time 8 with a wait time of 3, and P2 = s, 0, a, 7, b, also arriving at 8 with a wait time of 6. Therefore, to reduce the total wait time along the walk, we may need to go through cycles instead of waiting for a long time at a given vertex.\n2.3. Min-Cost Foremost\nFor this problem, we assume there is a non-negative cost associated with every edge traveled along the walk from source vertex s to a destination vertex v. The cost of an edge may depend on the departure time from the edge\u2019s start vertex. The min-cost foremost or mc f walk is a foremost walk from source vertex s to any other vertex v that incurs minimum cost along the walk. The cost incurred on a time arc from a vertex uti to uti+1 departing at time ti is denoted by a function c(uti, uti+1). Therefore, the objective for the min-cost foremost or mc f walk problem is to find a walk from a given source vertex s to a destination vertex v with the arrival time t f , such that among all the walks from s to v starting at or after tstart and arriving at t f , we choose a walk that accumulates minimum cost along the way or minimizes (\u2211uti c(uti, uti+1). If there are cycles in a walk from s to v, we could eliminate those cycles and arrive at the destination at the same time, or sooner, at a cost that is the same, or less. Therefore, every mc f path is also an mc f walk. For this reason, we refer to mc f walks as mc f paths in the rest of this paper."
        },
        {
            "heading": "3. NP-Hard Foremost Path and Walk Problems in Interval Temporal Graphs",
            "text": "Several problems are known to be NP-hard for contact-sequence temporal graphs. For example, Bhadra et al. [14] show that computing several types of strongly connected components is NP-hard; Casteigts et al. [15] show that determining the existence of a nowait path (In a no-wait path, the arrival and departure times at each intermediate vertex are the same.) between two vertices is NP-hard; and Zschoche et al. [16] show that computing several types of separators is NP-hard. Additional complexity results for contact-sequence temporal graphs appear in [15]. Since contact-sequence temporal graphs are a special case of interval-temporal graph, as discussed in Section 1, every problem that is NP-hard for the contact-sequence model remains NP-hard in the interval model. However, the reverse may not be true, as the transformation from the interval model to the contact-sequence model entails a possible explosion in the instance size. In this section, we demonstrate that mw f and mc f path and walk problems are NP-hard in the interval model but polynomially solvable in the contact-sequence model. In fact, in [13], we show that finding a no-wait path from a given source vertex u to a destination vertex v in an interval-temporal graph whose underlying static graph (defined below) is acyclic is NP-hard and that this problem is polynomially solvable for contact-sequence graphs whose underlying static graph is acyclic. We remark in [13] that our proof of this is easily extended to show that finding foremost, fastest, min-hop, and shortest no-wait paths in interval-temporal graphs with an acyclic underlying static graph is NP-hard while these problems are polynomial for contact-sequence temporal graphs whose underlying static graph is acyclic. The underlying static graph for any contact-sequence temporal graph is the graph that results when each edge (u, v, t, \u03bb) is replaced by the edge (u, v) and then multiple occurrences of the same edge (u, v) are replaced by a single edge (u, v). For an interval temporal graph, its underlying static graph is obtained by replacing each edge (u, v, intvls) by the edge (u, v). Figure 5 shows the underlying static graphs for the temporal graphs of Figures 1 and 2. We show below that finding mw f paths and walks and mc f paths is NP-hard for the interval model but polynomially solvable for the contact-sequence model (for acyclic graphs).\nTheorem 1. The mw f path and walk problems are NP-hard for interval-temporal graphs.\nProof. For the NP-hard proof, we use the sum of subsets problem, which is known to be NP-hard. In this problem, we are given n non-negative integers S = {s1, s2, . . ., sn} and another non-negative integer M. We are to determine if there is a subset of S that sums to M. For any instance of the sum of subsets problem, we can construct, in polynomial time, the interval-temporal graph shown in Figure 6. For all edges other than (un, v), the permissible departure times are from 0 through M (i.e., their associated interval is [0\u2212M]) and the edge (un, v) has the single permissible departure time M (equivalently, its associated interval is\n[M\u2212M] or simply [M]). The travel time for edge (ui, ui+1) is si, that for (un, v) is 1, and that for the remaining edges is 0. For every subset of S, there is a no-wait path from u0 to un that arrives at un at a time equal to the sum of the sis in that subset. Further, every no-wait path from u0 to v must get to un at time M. Hence, there is a no-wait path from u0 to v if S has a subset whose sum is M. In addition, every time-respecting path from u0 to v in the temporal graph of Figure 6 is a foremost path, as there is no path from u0 to v that can arrive at v either before or after time M + 1. Hence, a min-wait foremost path from u0 to v has a total wait of 0 if there is a subset of S that sums to M; this path gets to v at time M + 1. Hence, the min-wait foremost path problem is NP-hard. The same construction shows that the min-wait foremost walk problem is also NP-hard for interval temporal graphs as every walk in the graph of Figure 6 is a path.\nWe note that the construction used in the above proof is easily modified, so that every edge has a travel time that is >0.\nTheorem 2. The mc f path problem is NP-hard for interval-temporal graphs.\nProof. For this proof, we use the partition problem: Given S = {s1, . . . , sn} with {s1 + s2 + . . . + sn = 2M}, we are to determine whether there is a subset whose sum is M; the sis and M are non-negative integers. We use the same graph as in Figure 6. Each edge (ui, xi) has the cost si; all other edges have a cost of 0. As in the proof of Theorem 1, every path from u0 to v corresponds to a subset of S; this subset consists of the sis on the included edges of the form (ui, ui+1). A path from u0 to v is feasible (time-respecting) if its length from u0 to un is P \u2264 M. Every feasible path from u0 to v gets to v at M + 1 and is a formost path. Feasible paths have the property that the sum, P, of the sis in the associated subset is \u2264M. Also, for every subset of S, there is a corresponding feasible path. The cost of such a path is\n2M\u2212 P \u2265 M (as P \u2264 M). This cost takes on the min value M if the sum of sis on it is also M; i.e., if S has a partition (i.e., a subset whose sum P is M). Hence, the mc f path problem is NP-hard for interval temporal graphs."
        },
        {
            "heading": "4. Min-Hop Foremost Paths",
            "text": "Before we develop the algorithm for finding mh f paths in interval-temporal graphs, we present the following theorems about mh f paths in temporal graphs.\nTheorem 3. There exist interval-temporal graphs in which every mh f path from a source vertex s to a destination vertex v has a prefix-path ending at a prefix vertex u and the prefix-path from s to u is not a min\u2212 hop path.\nProof. This can be seen from Figure 7. The only mh f path from a to d is < a, 0, b, 1, c, 2, d >. However, the prefix path < a, 0, b, 1, c > is not a min-hop path from a to c. The min-hop path from a to c is < a, 8, c > which is not a prefix path to the only mh f path from a to d, even though this mh f path goes via c.\nTheorem 4. There exist interval-temporal graphs in which every mh f path from a source vertex s to a destination vertex v has a prefix path ending at a prefix vertex u and the prefix path from s to u is not a foremost path.\nProof. This can also be seen from Figure 7. The only mh f path from a to f is< a, 0, b, 7, d, 8, f >. However the prefix path < a, 0, b, 7, d > is not a foremost path from a to d. There are two foremost paths from a to d in the interval-temporal graph of Figure 7, namely, < a, 0, b, 1, c, 2, d > and < a, 0, b, 1, c, 2, e, 3, d >. Neither of these foremost paths from a to d is a prefix path to the only mh f path from a to f , even though this mh f path goes via d.\nTheorem 5. There exist interval-temporal graphs in which every mh f path from a source vertex s to a destination vertex v has a prefix path ending at a prefix vertex u and the prefix path from s to u is not an mh f path.\nProof. This can also be seen from Figure 7. The mh f path from a to f is < a, 0, b, 7, d, 8, f >. However, the prefix path < a, 0, b, 7, d > is not an mh f path from a to d. Out of the two foremost paths from a to d in the interval-temporal graph of Figure 7, namely, < a, 0, b, 1, c, 2, d > and < a, 0, b, 1, c, 2, e, 3, d >, the former has a fewer number of hops. Therefore, it is the the mh f path from a to d. However, it is not a prefix path for the only mh f path from a to f , even though the only mh f path from a to f goes via d.\nTheorem 6. Consider an interval graph G that has a path from s to v. G has an mh f path P from s to v with the property that every prefix Q of P is an h hop foremost path to u, where h is the number of hops in Q and u is the last vertex of Q.\nProof. Since G has a path from s to v, it has a min-hop foremost path R from s to v. Let S be the longest prefix of R that is not an h-hop foremost path from s to u, where h is the number of hops in S and u is the last vertex in S. If there is no such S then the theorem is proved. Assume S exists. Replace S in R, by an h-hop foremost path from s to u, say S\u2032. The resulting path R\u2032 is an mh f path from s to v with a prefix S\u2032 from s to u with an earlier arrival time at u, but the same number of hops. Repeating this replacement strategy a finite number of times, we obtain a min-hop foremost path P from s to v that satisfies the theorem.\n4.1. Algorithm to Find mh f Paths in Interval-Temporal Graphs\nAs noted in [13], some intervals of departure times on an edge may be redundant for the purposes of finding optimal foremost, min-hop, shortest, and fastest paths, as these are dominated by other intervals of the edge. These intervals are also redundant from the perspective of mh f paths (Theorem 6) and we assume that these redundant intervals have been removed in a preprocessing step. Our algorithm employs the function f (u, v, t) [9,13], which determines the earliest possible departure time \u2265 t using the edge (u, v).\n4.1.1. Data Structures Used by mh f Algorithm 1\n1. We use the same data structure to represent the interval temporal graph as we used in our earlier paper [13]. The data structure comprises a (say) C++ vector with one slot for each vertex in the graph. The slot for any vertex u itself contains a vector of vertices adjacent from u. Associated with each adjacent vertex v from u, there is a vector of time-ordered tuples for the edge (u, v). 2. incSt is a structure that keeps track of vertices discovered in every hop. The fields in this structure are as follows:\n(a) curVtxId is the current vertex. (b) arrTm is the time of arrival at the current vertex. (c) re f PrvIncSt is reference to previous incSt that stores similar information about\nprevious vertex on this path.\n3. allHopPaths\u2014array of lists that stores a list of vertices discovered at every hop. This array has, at most, H lists, where H is the maximum number of hops in min-hop paths from source vertex, s, to any of the vertices v \u2208 V. Every element of the list is an instance of the structure incSt. 4. tEKA\u2014array that stores for each vertex v tuples of:\n(a) earliest known arrival time t f . (b) number of hops in which earliest time found h f . (c) index, indx, into allHopPaths to the structure incSt in the list at h.\n4.1.2. Algorithm Description\n\u2022 INPUT:\n1. Temporal graph represented by data structure described in Section 4.1.1, item 1 2. Source vertex s\n\u2022 OUTPUT:\n\u2013 Array tEKA as described in Section 4.1.1, item 4\nAs an example, consider the interval-temporal graph of Figure 8. Let the source vertex be S and tstart = 0. In the first round (hopCnt = 1), the neighbors A, B, and C are identified as one-hop neighbors of S with one-hop path arrival times of 1, 5, and 10, respectively. Therefore, the earliest known arrival time to these neighbors are updated with tEKA, with a hopCnt of 1. In the next round (hopCnt = 2), these one-hop paths are expanded to two-hop paths to vertices B (S, A, B ) and C (S, B, C). The arrival times of these paths are 2 and 6, which is earlier than their current arrival times. Therefore, their earliest known arrival times ( f oremost arrival times) are updated. In the third round (hopCnt = 3), the earlier arriving 2-hop paths to B and C are expanded. While the 2-hop path to C cannot be expanded any further, the 2-hop path to B is expanded to obtsin a 3-hop path to C that gets to C at 4, which is earlier than its current arrival time. Therefore, tEKA is again updated for this vertex. This path is expanded in the next round (hopCnt = 4) and the 4-hop path to D (S, A, B, C, D) is discovered, which is also the f oremost arrival time at D. This path arrives at D at 5. The algorithm now terminates as hopCnt = 4 = V \u2212 1.\nAlgorithm 1 Min-hop foremost path algorithm\n1: Create startSt\u2190 (s, tstart, null) as an instance of incSt. 2: Initialize tEKA[s] \u2190 tstart; \u2200v \u2208 V, v 6= s, tEKA[v] \u2190 \u221e; Initialize allHopPaths[0] \u2190 {startSt} 3: hopCnt = 0; newVsInHop = 1; totVsRchd = 1 4: while (hopCnt < V \u2212 1) and (newVsInHop \u2265 0) do 5: hopCnt ++ 6: newVsInHop\u2190 0 7: for each (re f IncSt \u2208 alHopPths[hopCnt\u2212 1]) do 8: vert = re f IncSt.curVtxId 9: tvertArr = re f IncSt.arrTm 10: for each (nbr \u2208 V[vert].nbrs) do 11: (depTm, intvl Id) = f ((vert, nbr), tvertArr) 12: if depTm \u2265 \u221e then 13: continue . start next loop iteration 14: end if 15: newArrnbr = depTm + \u03bbintvl Id 16: if (newArrnbr < tEKA[nbr].t f ) then 17: if (hopCnt > tEKA[nbr].h f ) then 18: Create an instance of incStruct as nis 19: nis\u2190 (nbr, newArrnbr, re f IncSt) 20: tEKA[nbr].h f = hopCnt 21: alHopPths[hopCnt].append(nis) 22: tEKA[nbr].indx = newVsInHop ++ 23: else . arrival with an earlier time in same hop from a diferent prev node 24: Update 25: alHopPths[hopCnt][tEKA[nbr].indx] 26: end if 27: if tEKA[nbr].t f \u2265 \u221e then 28: totVsRchd ++ 29: end if 30: tEKA[nbr].t f = newArrnbr 31: end if 32: end for 33: end for 34: end while\nTheorem 7. Algorithm 1 finds mh f paths from the source vertex, s, to all reachable vertices v \u2208 V in the interval-temporal graph G = (V, E)\nProof. The proof follows from Theorem 6 and the observation that the algorithm constructs mh f paths first with 1 hop, then with 2 hops, and so on. Form Theorem 6, it follows that, on each round, it is sufficient to examine only 1-hop extensions of paths constructed in the previous round.\nThe asymptotic complexity of Algorithm 1 is O(NMitg log \u03b4), where N and Mitg are the number of vertices and edges, respectively, in the interval temporal graph and \u03b4 is the maximum number of departure intervals on an edge from the given Mitg edges. This is the same as that of the min-hop algorithm in our earlier paper [13]."
        },
        {
            "heading": "5. Min-Wait Foremost Walks in Interval Temporal Graphs",
            "text": "5.1. Properties of mwf Walks\nIn this section, we describe properties of mw f walks that are used later in the section for developing single-source all-destinations mw f walks algorithm and the correctness proof of our mw f algorithm. Some of the terminology we use is given below.\n1. For a walk X, tX denotes its arrival time at its terminating vertex v and wX denotes the total wait time accumulated by X along its way from s to v. 2. Comparing any two walks X and X\u2032 w.r.t mw f arrival at a vertex v, X is said to be the same or better than X\u2032 if tX \u2264 tX\u2032 and wX \u2264 wX\u2032 . 3. A walk from s to v via some vertex u is denoted as W(s, u, v). 4. A walk X from s to u that is extended further to obtain a walk W(s, u, v) is a prefix\nwalk denoted by X = Pre(W(s, u, v)).\nDefinition 1. Walk dominance\u2014for any two walks A and A\u2032 from s to u, A is said to dominate over A\u2032 if, for any walk W(s, u, v) where A\u2032 = Pre(W(s, u, v)), A\u2032 can always be replaced by A to produce a same-or-better walk W \u2032(s, u, v) w.r.t mw f arrival at v\nTheorem 8. If there are two walks, A(tA, wA) and A\u2032(tA\u2032 , wA\u2032), that arrive at a vertex u, such that tA \u2264 tA\u2032 , then if ((tA\u2032 \u2212 tA + wA) \u2264 wA\u2032) then A dominates A\u2032.\nProof. We have: (tA\u2032 \u2212 tA + wA) \u2264 wA\u2032 (1)\nLet the departure time of A\u2032 for any onward walk from u be tdep \u2265 tA\u2032 . Since tA \u2264 tA\u2032 , tdep \u2265 tA, therefore, A can also depart vertex u at tdep. If A\u2032 departs at tdep, the wait time accumulated by the time of departure is w\u2032 = wA\u2032 + tdep \u2212 tA\u2032 . If A departs at tdep, the wait time accumulated by the time of departure is w = wA + tdep \u2212 tA. Due to Equation (1) w\u2032 \u2265 w. Hence, if A\u2032 is replaced by A, then any possible extension of A\u2032 can still depart at the same time and would have accumulated an equal or less wait time by the time it departs from u. Therefore, A\u2032 can always be replaced by A in any possible extension of A\u2032 to obtain a same-or-better walk.\nTheorem 9. For identifying non-dominated walks among all the walks arriving at a vertex u, all walks may be arranged in an increasing order of arrival time at vertex u and only adjacent walks need be compared for dominance.\nProof. If there are three walks (A, B, C) terminating at u with arrival times (tA \u2264 tB \u2264 tC), we need to show that it is sufficient to compare only the adjacent walks to find and retain the dominant walks terminating at u. This follows from the following two conditions:\n1. If B survives A (is not dominated by A), then comparing C with B should have the same result as comparing C with A. In other words\n(a) If C survives B, it also survives A. (b) If C is dominated by B, it is also dominated by A.\n2. If A dominates B and B dominates C, then A also dominates C. Therefore, it does not matter in which order the walks are compared. Both B and C will be eliminated.\n1. We are given B is not dominated by A or survives A. Based on the dominance criteria of Equation (1) we obtain Equation (2) for B surviving A\n(tB \u2212 tA + wA) > wB (2)\n(a) When C survives B, we have\n(tC \u2212 tB + wB) > wC (3)\nWe are to prove that C also survives A\n(tC \u2212 tA + wA) > wC (4)\nAdding Equations (2) and (3) yields (4)\n(b) When C is dominated by B, Equation (1) gives\n(tC \u2212 tB + wB) \u2264 wC (5)\nReplacing wB from Equation (2) in Equation (5), we obtain\n(tC \u2212 tA + wA) \u2264 wC (6)\nTherefore, A also dominates C.\nThis proves that, when B is not dominated by A, then comparing C with B has the same result as comparing C with A.\n2. Here, we prove that if A dominates B and B dominates C, then A also dominates C. Since A dominates B we have\n(tB \u2212 tA + wA) \u2264 wB (7)\nFor B dominates C we have Equation (5). The two Equations (5) and (7), can be added together to obtain Equation (6), which states that A dominates C. Therefore, when A dominates B and B dominates C, regardless of the order in which the adjacent walks are compared, both B and C will be eliminated.\nHence, for any three walks A, B, and C with tA \u2264 tB \u2264 tC, only adjacent walks need to be compared to remove dominated walks and retain non-dominated walks. When applied transitively to all walks arriving at u, we see that if all the arriving walks are arranged in non-decreasing order of their arrival times, only adjacent walks need to be compared to eliminate the dominated walks and retain the non-dominated walks.\nTheorem 10. For any two walks A and B arriving at a vertex u, where tB > tA, if B is not dominated by A as per the dominance criteria (1), then for any departure time t available on an outgoing edge (u, v) such that t \u2265 tB, A need not be considered for expansion.\nProof. Let A\u2032 be the walk obtained by extending A from u to a neighbor v at time t \u2265 tB. Similarly, B\u2032 is obtained by extending B on (u, v) at t \u2265 tB. Assuming \u03bb as the travel time when departing at t on the edge (u, v), we have the following:\ntA\u2032 = t + \u03bb; wA\u2032 = wA + (t\u2212 tA) (8)\ntB\u2032 = t + \u03bb; wB\u2032 = wB + (t\u2212 tB) (9)\nTherefore, we have tA\u2032 = tB\u2032 . In addition, since B is not dominated by A, we have\ntB \u2212 tA + wA > wB (10)\nFrom Equations (8)\u2013(10), we have wB\u2032 < wA\u2032 . This means that extending A at t \u2265 tB is not beneficial, as it will be dominated by B\u2032.\nTheorem 11. In order to find mw f walks, if walk A arriving at u is extended from u to v using an edge (u, v) at time tdep \u2265 tA in a departure interval I(s, e, \u03bb), then there is no benefit to extending A using the same edge (u, v) in the same interval I(s, e, \u03bb) at a time t\u2032 where t\u2032 > tdep.\nProof. Let the extension of A from u to v by departing at tdep be A1. Let the extension to v obtained by departing at t\u2032 be A2. We have the following two equations for the arrival and wait times of A1 and A2, respectively.\ntA1 = tdep + \u03bb; wA1 = wA + (tdep \u2212 tA) (11)\ntA2 = t\u2032 + \u03bb; wA2 = wA + (t\u2032 \u2212 tA) (12)\nClearly, tA1 < tA2 as tdep < t\u2032. Further, substituting tA2, tA1, wA1 from Equations (11) and (12) in expression tA2 \u2212 tA1 + wA1, we obtain\ntA2 \u2212 tA1 + wA1 = wA2 (13)\nFrom the dominance criterion of Equation (1), we conclude that A1 dominates A2. This means that if we extend A at tdep and at t\u2032 > tdep in the departure interval I(s, e, \u03bb) using the edge (u, v) to obtain A1 and A2, respectively, A2 will be dominated at v by A1. Therefore, there is no benefit of extending A at t\u2032\nTheorem 12. If the walk A arriving at u is extended from u to v using the edge (u, v) at time tdep \u2265 tA in a departure interval I1(s1, e1, \u03bb1), then A may need to be extended again using the edge (u, v) in a subsequent interval I2(s2, e2, \u03bb2) where (s2 > e1) if one of the following is true\n1. s2 + \u03bb2 < tdep + \u03bb1 2. \u03bb2 > \u03bb1\nProof. tA \u2264 e1 as A can be extended in I1. Therefore, the earliest time at which A can be extended in I2 is s2. It need not be extended at any other time in I2 due to Theorem 11. Let the extension of A obtained by extending in I1 be A1 and that obtained by extending in I2 be A2.\n1. If s2 + \u03bb2 < tdep + \u03bb1, it means tA2 < tA1; therefore, A will need to be extended at s2 so we do not miss any opportunities of further expansion in intervals of departure available at v at a time t, such that s2 + \u03bb2 \u2264 t < tdep + \u03bb1. 2. We have the following two equations for the arrival and wait times of A1 and A2, respectively\ntA1 = tdep + \u03bb1; wA1 = wA + (tdep \u2212 tA) (14)\ntA2 = s2 + \u03bb2; wA2 = wA + (s2 \u2212 tA) (15)\nComparing A1 and A2 at v, we see that s2 + \u03bb2 \u2265 tdep + \u03bb1 as otherwise, condition 1 would be true. Therefore, we have:\ntA2 \u2212 tA1 = s2 + \u03bb2 \u2212 tdep \u2212 \u03bb1 (16)\nLet e = tA2 \u2212 tA1 + wA1. Evaluating e using Equation (16) and substituting for wA1 from Equation (14), we obtain\ne = wA + s2 \u2212 tA + (\u03bb2 \u2212 \u03bb1) (17)\nSubstituting wA2 from Equation (15) into Equation (17), we obtain:\ne = wA2 + (\u03bb2 \u2212 \u03bb1) (18)\nWe know that for A2 to survive being dominated by A1, we need Equation (19) to be true\ne > wA2 =\u21d2 wA2 + (\u03bb2 \u2212 \u03bb1) > wA2 (19)\nTherefore, for Equation (19) to be true, \u03bb2 > \u03bb1, otherwise A2 will be dominated by A1.\nTherefore, unless 1 or 2 is true, there is no benefit of extending in interval I2. This can also be seen from the example of Figure 9. There are two intervals on the\nedge (u, v) with I1(2, 6, 12) and I2(10, 20, 5). A departs at 2 and then does not need to depart in I2(10, 20, 5), as none of the conditions of Theorem 12 is satisfied. A\u2032 departs at 4 in I1(2, 6, 12) but needs to depart in I2(10, 20, 5) again as condition 1 is satisfied.\nTheorem 13. If walk A arriving at u is extended from u to v using the edge (u, v), it should always be extended at (tdep, intvl Id) = f (u, v, tA), where f (u, v, t) is the next function referred to in Section 4.1 and described in [9,13].\nProof. From Theorem 11, a given walk departing in a departure interval I on an edge (u, v) should always depart at the earliest possible departure time in I. Further, as per the conditions stated in Theorem 12, it is evident that, for any two available departure intervals I1(s1, e1, \u03bb1) and I2(s2, e2, \u03bb2) where e1 \u2264 s2 on an edge (u, v), a walk A terminating at u such that tA \u2264 e1 should always depart in I1 and whether or not it departs in I2 is determined by the conditions specified in the theorem.\n5.2. Departure from Source Vertex s\nAll walks that start from a source vertex s have a wait time of 0, as there is no wait accumulated at the source vertex. Therefore, for any available departure interval on an edge (s, x), we should be extending at every possible instance of time in this departure interval. Theorems 11 and 12 do not apply to walks departing from the source vertex s, as these theorems assume that there is an extra wait accumulated if a walk A is extended at a later time from the departing vertex u. However, this is not true when u = s as the wait time at s is always 0. This implies, we may assume that mw f walks do not have a cycle that involves s as such cycles can be removed from the walk without increasing either the total wait time or the arrival time at the destination. From the source vertex s, walks may depart at every departure instance available to find mw f walks. To account for this, we introduce the concept of a walk class.\nDefinition 2. A walk class (ws, we, u) is a set of walks that arrives at the vertex u with a wait time of 0. The first walk in this set arrives at ws and the last one arrives at we, where we > ws. There is a walk in the walk class at every instance of time in the range [ws, we] and each of these walks has the same total wait time, which is 0. This can be seen in Figure 10.\nFor every departure interval denoted by I(start, end, \u03bb) where end > start on an edge (s, x), we need to generate a walk class, ranging from the start to end, with travel time as \u03bb and a wait time of 0. Once the walks in the walk class arrive at the neighbor x, Theorems 11 and 12 apply to each walk in the class.\nTheorem 14. Each walk in a walk class survives the walk, if any, that arrives before it.\nProof. This is easy to see from Equation (1), as these walks have the same wait time but different arrival times.\nTheorem 15. If two walk classes WC1 and WC2 arrive at a vertex u, there is no dominance to be considered.\nProof. This follows from Equation (1), as the wait times of all walks is 0. When they overlap, one of them may be discarded. When they do not overlap, both can be retained.\nWhen a walk class, WC(ws, we), terminates at a vertex u, if some portion of it overlaps with a departure interval I(s, e, \u03bb) from u to a neighbor v, the set of walk instances x in the walk class WC such that s \u2264 tx \u2264 e can be immediately extended to the neighbor v without any additional wait at u into a new walk class arriving at v as WC\u2032(ws\u2032, we\u2032). Therefore, each walk in WC\u2032(ws\u2032, we\u2032) also has a wait time of 0. If there is no overlap with a departure interval from u to v, then only the walk instance at we needs to be extended to v due to Theorems 10 and 14. For the mw f problem, redundant intervals as described in [13] for the foremost, minhop, fastest problems are not redundant and need to be retained. Such intervals, however, are redundant for mh f problems, as noted in Section 4.1 This is illustrated with the example of Figure 11. The min-wait foremost mw f walk from s to c would benefit by departing from the vertex s at 0, instead of waiting for the next faster interval that becomes available for departure at 2 and reaches a at 4. Departing at 0 from s reaches a at 5. In this case, the mw f walk would be Wmw f = (s, 0, a, 7, b, 1, c) arriving at vertex c at time 9 with a wait time of 0.\n5.3. Additional Data Structures\nFor finding mw f walks, we introduce an additional data structure which is a sorted list of all departure intervals in the interval temporal graph, sorted by the arrival time when departure is at the start of the interval. Each interval in this list is represented as I(s, e, \u03bb) and the sort key for the list is s + \u03bb. This is demonstrated in Figure 12 for the interval temporal graph of Figure 11.\n5.4. Algorithm to Find mw f Walks 5.4.1. Data Structures Used by mw f Algorithm 2\n1. Input graph G as in our earlier paper [13] and briefly described in Section 4.1. 2. intvlsIn f o is a structure that describes a departure interval.\n(a) u is the start vertex. (b) v is the end vertex. (c) st\u2014start time of the interval (d) end\u2014end time of the interval. (e) \u03bb is the travel time on this intvl. (f) intvl Id is the Id of this intvl on connection (u, v) in the input graph\n3. intvlList\u2014array of intvl In f o that contains all the departure intervals from the input graph, as described in Section 5.3 4. PQ of ad-hoc intervals\u2014Priority queue of items of type intvlsIn f o. The priority key is (intvlStrt + \u03bb). 5. mw f WClass is a structure that describes a walk class\n(a) strtTm\u2014arrival time of first walk instance in this class (b) endTm\u2014arrival time of last walk instance (c) wtTm\u2014total wait time accumulated on the walk. (d) lastExpAt\u2014This is an array of \u03bbs of the departure interval in which this walk\nwas last expanded to each of the nbr of its terminating vertex. The number of items in this array is the number of nbrs of the vertex at which this walk terminates.\n6. listWClasses\u2014This is an array of lists of walk classes. The size of the array is the number of vertices in the graph. Each list in the array is the list of walk classes terminating at the vertex corresponding to the array index. This list is always sorted in the increasing order of arrvTmStrt of the walk classes. 7. mw f Walks\u2014An array of walk classes. Array has an item for each vertex in the graph. For each vertex, it has the mw f walk to that vertex.\n5.4.2. Algorithm Description\n\u2022 INPUT:\n1. Temporal graph represented by data structure described in Section 5.4.1, item 1 2. Source vertex s\n\u2022 OUTPUT:\n\u2013 Array mw f Walks as described in Section 5.4.1, item 7\nFor simplicity, we assume that all the edge travel times are >0. Our algorithm for solving the mw f problem (Algorithm 2) can easily be extended to the case when some travel times are\u22650. Later, we show how to carry out this extension. Algorithm 2 looks at all possible departure intervals in non-decreasing order of their arrival times when departing at the start of the interval (intvl.strtTm + intvl.\u03bb). In Step 8, it saves the arrival time of the latest interval being considered in the variable curTm. In the subsequent while loop, it keeps fetching new intervals as long as they have the same arrival time as curTm, when departing at the start of the interval. For each fetched interval newIntvl, at the originating vertex u of newIntvl, it finds a walk class prevW with latest arrival time of the start of the walk class prevW.strtTm such that prevW.strtTm \u2264 newIntvl.st. No other walk arriving at u needs to be considered for expansion on this interval due to Theorem 10. Using this previous walk at the originating vertex u, a new walk is created from u to v at the start of the newIntvl using the function createNewW. This function creates a new walk from the previous walk departing at start of newIntvl only if the second part of Theorem 12 is satisfied. The first part of Theorem 12 is already taken care of because the intervals are examined only in non-decreasing order of intvl.st + intvl.\u03bb.\nAlgorithm 2 Min-wait foremost walks algorithm\n1: Create a new newWClass\u2190 (tstart, \u221e, 0, nbrs_s[0]) as an instance of mw f WClass. Values are assigned to fields arrivTmStrt, arrivTmEnd, wtTm, lastExpAt, respectively. Last field is an array of size out degree of vertex s. 2: Initialize mw f Walks[s] \u2190 newWClass; initialize listWClasses[s].pushback(newWClass); \u2200v \u2208 V, v 6= s, mw f Walks[v]\u2190 null 3: nodesRchd\u2190 1; staticIntvls\u2190 intvlList.size; indxStaticIntvls\u2190 0 4: setupNewWClass(s, newWClass.arrivTmStrt) 5: reachableNodes\u2190 getReachableNodes(G, s) 6: newIntvl \u2190 removeMinIntvl() 7: while ((indxStaticIntvls < staticIntvls) or !PQ.empty()) and (nodesRchd <\nreachableNodes) do 8: curTm\u2190 newIntvl.st + newIntvl.\u03bb 9: u = newIntvl.u; v = newIntvl.v\n10: newVs\u2190 0 11: while (curTm == newIntvl.st + newIntvl.\u03bb) do 12: if (newIntvl.v 6= s) then 13: prevWIndx \u2190 getPrveW(newIntvl) 14: if prevWIndx 6= \u22121 then 15: newW \u2190 createNewW(listWClasses[u][prevWIndx], newIntvl) 16: if newW then 17: ins\u2190 insNewW(newW, v) . Inserts newW in list of walks at v. If\nnewW is best mw f walk it is recorded in mw f Walks[v] 18: if ins == NEW then 19: newVs ++ 20: end if 21: if ins 6= 0 then 22: setupNewWClass(v, newW.strtTm) 23: end if 24: end if 25: end if 26: end if 27: newIntvl \u2190 removeMinIntvl() 28: end while 29: nodesRchd+ = newVs 30: end while\nAfter the new walk is created on an edge (u, v), it is appended to the list of walks at v. To qualify as a valid walk to be appended to the list of walks at v, it needs to be compared for dominance with only the last walk in the list at v due to Theorem 9. This walk is appended to the list at v only if it is not dominated. The insert function also checks if this is the first walk arriving at v. If so, it updates the mw f Walks for vertex v and increments the count of newVs. If this is not the first walk to arrive at v, but if it is better w.r.t mw f arrival than the best known walk at v, mw f Walks is updated for vertex v. Note that the new walk cannot have an earlier arrival time than the best known walk at v as the intervals are examined in non-decreasing order of arrival times, but it may have a lesser wait time. After a walk has been appended to the list of walks at v, the function setupNewWClass examines all the neighbors of v. If the start time of the last arriving walk class is in the middle of an available departure interval, intvl given, in the input graph G on an edge (v, w), a new departure sub-interval of intvl, say subIntvl, is created. The start time of subIntvl is the arrival time of the walk and travel time same as that of the intvl (intvl.\u03bb). This way, every walk originates at the start of an interval given in graph G or at start of a subIntvl that is a sub-interval of one of the intervals given in the input graph G. This new subIntvl is inserted into the priority queue PQ. In the removeMinIntvl function, the\ninterval with minimum arrival time (when departing at the start of the interval) from intvlList and the top of PQ is returned.\nTheorem 16. Algorithm 2 finds mw f walks from s to all other vertices in an interval temporal graph when all edge travel times are >0.\nProof. The algorithm examines all the departure intervals in non-decreasing order of arrival time, when departing at the start of the interval. For every interval, newIntvl in that order, it considers the best walk eligible for extension in this interval, as per Theorem 10, by obtaining the index for the previous walk (prevWIndex) in the list of walks at the departure vertex u, in Step 13. It extends the prevWalk with departure in newIntvl only if this extension is beneficial as per Theorem 12. Once the walk is extended, it updates the lastExpAt for prevWalk for the edge (u, v), so that subsequent departure intervals on (u, v) are used for expanding prevWalk only if the resultant walks may be beneficial, as per Theorem 12. The extended walk is appended to the list of walks at v only if it is not dominated as per the dominance criterion of Equation (1). In addition, mw f walks at v are updated if the arriving walk is better than the previous mw f walk, w.r.t mw f arrival at v or if it is the first walk to arrive at v. Finally, the arriving walk at v, newW, is examined w.r.t all outgoing edges (v, w). If for a departure interval I(s, e, \u03bb) to any neighbor w we have Is < newW.strtTm \u2264 Ie, a new sub-interval, subIntvl, is created that has a start time of newW.strtTm and inserted into PQ. When such a subIntvl is the minimum interval among all the intervals from the input graph G and the subIntvls created during the course of Algorithm 2, the newW gets the opportunity to expand at the start time of subIntvl. Therefore, this algorithm starts at the start vertex and generates walks at all feasible departure instances w.r.t mw f walks criteria. Feasible departure intervals are examined in non-decreasing order of arrival times; therefore, every new walk generated has an arrival time \u2265 arrival time of any previously generated walk. No feasible non-dominated walk is missed due to Theorems 8\u201313. Every non-dominated walk generated is preserved and expanded as per Theorems 11\u201313. When a walk terminating at a vertex v is discovered that is the best among the walks arriving at v w.r.t mw f arrival, it is recorded as the mw f walk at v. The algorithm terminates only when one of the following is true\n1. All intervals including the sub\u2212 intervals created during the course of Algorithm 2 have been examined. 2. mw f walks to all reachable vertices have been found and the arrival time when departing at the start of next interval being examined is bigger than the max arrival time of the mw f walks found. Therefore, examining any more intervals cannot give a better mw f walk.\nTherefore, when the algorithm terminates, mw f walks to all reachable vertices have been found.\nFor handling the case when some travel times are 0, in the while loop of line 11, we need to first obtain all the edges with 0 travel times arriving at currTm and form their transitive closure. Then, we can process every edge arriving at the same currTm over this transitive closure.\nTheorem 17. When time is an integer, Algorithm 2 has pesudopolynomial complexity.\nProof. Let T be the maximum possible arrival time at any vertex. Since curTm is an integer that increases in each iteration of the outer while loop, this outer loop is iterated O(T) times. For each value of curTm, the while loop of line 11 is iterated O(MitgT) times, where Mitg is number of edges in the input interval temporal graph, as the number of walks that\ncan arrive at a vertex v at time curTm is O(indegree(v) \u2217 T). The components of the time required for each iteration of the while loop of line 11 are\n1. log(walks(v)) in step 13 to find the previous walk that can be extended at the current departure instance(tarr). walks(v), which is the number of walks at v at time tarr, can be at most tarr as each preserved walk at a given vertex v has a unique arrival time. Therefore, time taken by this step is log(tarr) or at most log(T). 2. Constant time for creating a new walk newW in step 15. 3. Constant time for inserting newW, in the list of walks l at v in step 17. l at every vertex\nv maintains a list of walks that has arrived at v in non-decreasing order of their arrival times. newW only needs to be compared with the last walk in l.\n4. At most d log(\u03b4) in step 22, d is the out-degree of the vertex v at which newW terminates and \u03b4 is the number of departure intervals on an outgoing edge (v, w) that has maximum departure intervals among all the outgoing edges from v. Each of the departure intervals on outgoing edges from v may need to be added to PQ. Size of PQ can be, at most, the maximum number of departure instances in the graph G, which is MitgT. Therefore, the maximum time taken in this step is d log(\u03b4) log(MitgT). 5. Finally, in step 27, departure instance with minimum arrival time is retrieved. Maximum size of PQ can be MitgT. Therefore, maximum time taken by this step is log(MitgT)\nTherefore, the complexity of the algorithm is O(T(MitgT(log(T) + d log(\u03b4) log(MitgT) + log(MitgT)))), which is O(MitgT2 log(T)). Hence, the time complexity of Algorithm 2 is pseudopolynomial."
        },
        {
            "heading": "6. Linear Combination of Optimization Criteria",
            "text": "Bentert et al. [10] present a polynomial time algorithm that optimizes any linear combination of the eight optimization criteria f oremost, reverse_ f oremost, f astest, shortest, min_hop, cheapest, most_likely, and min_wait in a contact-sequence temporal graph. In this section, we show that, when time is discrete, we can use the algorithm of Bentert et al. [10] to solve the mh f , mw f and mc f problems in polynomial time for contact-sequence graphs. This algorithm may also be used to find mh f , mw f , and mc f paths in interval temporal graphs by first transforming the interval-temporal graph into an equivalent contact sequence graph as described in Section 1. Since this transformation may increase the number of edges by an exponential amount, this approach does npt result in a polynomial time algorithm for interval-temporal graphs. However, it does result in a pseudopolynomial time algorithm as shown in Theorem 17.\nTo solve mh f , for example, for contact-sequence graphs, we perform the following:\n1. Set the coefficient for every criterion other than min_hop and f oremost to 0. 2. The coefficient for the foremost criterion may be set to any integer that is greater than or equal to the number of vertices, n, in the contact-sequence graph. 3. Set the coefficient for the min-hop criterion to 1.\nWith these settings, Bentert et al. [10] will find walks that minimize h(s, v) = c f \u2217 ta(v) + hops(v), where c f is the coefficient for the foremost criterion, ta(v) is the time at which the walk from s arrives at v, and hops(v) is the number of hops in the walk. Since a min-hop walk is necessarily a min-hop path, it has no more than n \u2212 1 hops. If we examine the digits of mh f (s, v), which is a non-negative integer, using the radix c f , the least significant digit is the number of hops and the remaining digits give ta. Hence, mh f (s, v) is minimized by min-hop foremost paths to v and not by any other path or walk. The strategy for mw f and mc f is similar. In the case of mw f , the function to optimize is mw f (s, v) = c f \u2217 ta(v) + wait(s, v) and for wc f , the optimization function is wc f (s, v) = c f \u2217 ta(v) + cost(s, v), where wait(s, v) is the total wait time on the walk from s to v and cost(s, v) is its cost. For mw f (s, v), c f must be larger than the maximum total wait time on an optimal foremost walk from s (a simple bound is the maximum arrival time of a foremost path to reachable vertices), and for mc f (s, v), c f must be larger than the maximum\ncost of an optimal foremost path (a simple bound to use is the sum of the maximum cost of each edge). For simplicity, we use c f = 232 in our experiments, as this is large enough for our data sets. It is easy to see how the above modeling strategy may be used to find, say, min-cost foremost paths with the fewest number of hops."
        },
        {
            "heading": "7. Experimental Results",
            "text": "In this section, we compare the performance of our mh f path and mw f walk algorithms to the algorithm of Bentert et al. [10]. Since the latter algorithm works only on contactsequence graphs, we first transform our interval-temporal graphs into equivalent contactsequence graphs (as noted in Section 1, this can be performed when time is discrete) and then we use the strategy discussed in Section 6 to formulate an appropriate optimization function for the algorithm of Bentert et al. [10]. Since the optimization function constructed in Section 6 has values larger than what can be handled by the datatype int, we modified the code of Bentert et al. [10] using the datatype long for relevant variables. Our experimental platform was an IntelCore, i9 \u2212 7900XCPU@3.30GHz processor with 64 GB RAM. The C++ codes for finding the optimal linear combination of multiple optimization criteria for contact-sequence temporal graph algorithms was obtained from the authors of [10]. All other algorithms were coded by us in C++. The codes were compiled using the g ++ver.7.5.0 compiler with option O2. For test data, we used the datasets used in [8,10], for the contact-sequence graphs. We transformed these contact-sequence graphs to interval-temporal graphs to run on our algorithms. We also generated some synthetic datasets as interval-temporal graphs that we transformed to contact-sequence models so the programs of Bentert et al. [10] could be run on them.\n7.1. Datasets\nWe used 13 of the 14 real-world contact-sequence graphs that were used in [8,10,12,13]. The 14th dataset, dblp, was not used as it had a few negative timestamps. The statistics for the remaining 13 real-world datasets are given in Table 1. In this table, |V| is the number of vertices, |Es| is the number of edges in the underlying static graph and cs\u2212 edges is the number of edges in the contact-sequence temporal graph. The ratio (cs\u2212 edges)/|Es| is the temporal activity of the graph. Note that the number of edges in the interval-temporal graph is also |Es|. The datasets have a wide range of sizes in terms of the number of vertices and edges. Consistent with [8,10,12,13], the travel time, \u03bb, on all edges was set to 1. The temporal activity on these datasets is low, ranging from 1 to 3.67.\nIn [13], we generated five synthetic datasets with higher activity and variable \u03bbs by starting with the social network graphs of youtube, flickr, livejournal shared by the authors\nof [17] at http://socialnetworks.mpi-sws.org/data-imc2007.html (accessed on 16 August 2022). These graphs represent user-to-user interactions.\nTable 2 shows the statistics for the five synthetic temporal graphs generated by us.\nTable 2. Synthetic graphs statistics.\nGraphs with \u00b5I = 4, \u00b5D = 5, \u00b5T = 3\nDataset |V| |Es| cs-edges Edge Activity youtube 1157.8 K 4945 K 105,039 K 21.2\nflickr 1861 K 22,613.9 K 480,172 K 21.24 livejournal 5284 K 77,402.6 K 1,643,438 K 21.3\nGraphs with \u00b5I = 4, \u00b5D = 8, \u00b5T = 3\nyoutube 1157.8 K 4945 K 159,103.7 K 32.1 flickr 1861 K 22,613.9 K 727,405.9 K 32.1\nTable 3 gives the time (in seconds) required to read each dataset from the disk as well as the disk memory required by each dataset. The columns labeled [10] are for the case when the dataset is stored in the input format used by the algorithm of Bentert et al. [10] and those labeled Ours are for the input format required by our algorithm. As can be seen, the disk reading time and disk space required by the interval-temporal graph representation are less than that required by the Bentert et al. [10]. Further, this difference increases as the temporal activity increases. In fact, for four of the instances, input creation code of [10] failed to create the required input format for lack of sufficient memory (out-of-mem).\nTable 3. Reading times and sizes.\nKoblenz Collection\nDataset Reading Time (in s) Sizes in MBs\n[10] Ours [10] Graph Ours\nepin 0.46 0.34 31.1 19.3 elec 0.13 0.07 4.5 3.3 fb 0.58 0.34 32.9 21.5\nflickr 19.3 14.2 1492.3 911 growth 27 19.9 2188.3 1485.4 youtube 6.1 4.2 456.1 300.8\ndigg 0.11 0.06 3.6 2.5 slash 0.14 0.07 7 5\nconflict 1.44 0.82 98.8 43.2 arxiv 2.5 1.4 193 104\nwiki-en-edit \u2013 227 out-of-mem 20,115 enron 0.74 0.36 55.9 29.3\ndelicious 209 78 16,249 7552\nSynthetic Datasets with \u00b5I = 4, \u00b5D = 5, \u00b5T = 3\nyoutube 67 4 4400 272.2 flickr \u2013 17.8787 out-of-mem 1248 livejournal \u2013 56.1638 out-of-mem 4411\nSynthetic Datasets with \u00b5I = 4, \u00b5D = 8, \u00b5T = 3\nyoutube 102 3 6775 272 flickr \u2013 18 out-of-mem 1249\nAs an example, for the large synthetic youtube graph with (\u00b5I = 4, \u00b5D = 8, \u00b5T = 3) which has an activity factor of 32.1, the reading time of the interval-temporal graph is 3.53\ns while the program by Bentert et al. [10] takes about 102.5 s to read the corresponding graph in Bentert\u2019s transformed format. The size of the interval temporal graph for the same dataset on disk is 272.3 MB as compared to 6.7 GB for the Bentert\u2019s transformed graph from the corresponding contact-sequence graph.\n7.2. Run Times\nAs in [8,10,12,13], we assume that the the graph is resident in memory (i.e., the read time from disk is not accounted for). This is a valid assumption in applications where the graph is input once and queried many times. To use the algorithm of Bentert et al. [10], we use the following steps:\n1. Transform the interval temporal graph to an equivalent contact sequence graph (csg) as described in Section 1. 2. Use Bentert\u2019s graph transformation program [10] to convert the csg to the input format used by Bentert\u2019s linear combination algorithm. 3. Run Bentert\u2019s linear combination program on the transformed graph from Step 2 using the coefficients given in Section 6.\nThe step 2 transformation was unsuccessful on the Koblenz dataset wiki\u2212 en\u2212 edit as well as on all our synthetic datasets other than youtube graph with (\u00b5I = 4, \u00b5D = 5, 8, \u00b5T = 3), as indicated in Table 3. The failure of this step resulted from the unavailability of sufficient memory to run the step 2 transformation code of [10] on these instances. We measured the average of the runtimes for 100 randomly selected source vertices for each dataset except the delicious from the Koblenz collection and the synthetic datasets, where we used only five randomly selected source vertices. This reduction in the number of source vertices was necessary because of the excessive runtime taken by the algorithm of [10] on these datasets. The average run-times (in seconds) for the Koblenz and synthetic datasets are given in Table 4. This time does not include the time required by steps 1 and 2. The speedups (time taken by the algorithm of [10]/time taken by our algorithm) are also shown visually in Figures 13\u201316. The speedups obtained by our mh f algorithm over [10] range from 3 to 207.5 for the Koblenz datasets and from 451.3 to 679.56 for the synthetic datasets. Our mh f algorithm outperforms that of [10] on all datasets. The speedups obtained by our mw f algorithm over [10] range from a low of 0.045 to a high of 23.3. The algorithm of [10] outperforms our mw f algorithm when the graph has very low connectivity. Their algorithm is able to quickly discover that no more vertices are reachable from the source vertex and, so, terminates sooner than our mw f algorithm. However, when there are many reachable vertices, our algorithm outperforms that of Bentert et al. [10]. We also note that our algorithm works on interval-temporal graphs where time intervals may be continuous or have large durations, while the algorithm of Bentert et al. [10] is only for contact-sequence graphs, which are a subset of interval temporal graphs. As noted earlier, the algorithm of [10] could not be run on some datasets because of the failure of step 2 as it ran out of memory. On the four datasets where the algorithm of [10] could not be run, the average runtime of our mh f algorithm was 1, 1.1, 1.3, and 22.2 s, respectively; the runtime for our mw f algorithm was 39.1, 368.4, 449 and 1317.6 s, respectively."
        },
        {
            "heading": "8. Conclusions",
            "text": "We have shown that finding mw f paths and walks as well as mc f paths in intervaltemporal graphs is NP-hard. For the mh f single-source all-destinations problem, a polynomial time algorithm was developed and for the mw f single-source all-destinations problem, a pseudopolynomial time algorithm was developed. We show also that the mh f and mw f problems for interval graphs can be solved using the linear combination algorithm of Bentert et al. [10] for those interval graphs that can be modeled as contact-sequence graphs. While the algorithm of [10] is polynomial in the size of the contact-sequence graph, the modeling of an interval-temporal graph by a contact-sequence graph, when possible, may increase the graph size by an exponential amount and, so, this approach does not result in a polynomial time algorithm for interval-temporal graphs. In fact, even though all of our datasets could be modeled as contact-sequence graphs, we were unable to use the algorithm of [10] on one of our Koblenz datasets and three of our synthetic datasets as the code of [10] that transform the contact-sequence graph into the required input format failed due to insufficient memory. Our mh f paths algorithm outperformed the linear combination algorithm of [10] on all datasets on which the algorithm of [10] could be run. A speedup of up to 69.9 was obtained on the Koblenz datasets and up to 679 on synthetic datasets. For the mw f single-source all-destinations problem, which is NP-hard, the linear combination algorithm of [10] outperformed our algorithm on three of the Koblenz data sets and tied on a fourth. On all remaining datasets, our algorithm outperformed that of [10]. The datasets on which the algorithm of [10] did well had the property that few vertices were reachable from the source vertex. This enabled the algorithm of [10] to terminate early. In these cases, the speedup obtained by our algorithm ranged from 0.045 to 0.56. On the remaining Koblenz datasets, our mw f algorithm obtained a speedup of up to 23.3. For both the synthetic datasets where it was possible to run the algorithm of [10], our algorithm was faster and delivered a speedup of up to 2.8. On the four datasets that the transformation to the input format required by the algorithm of [10] failed due to lack of memory, our mh f algorithm ran in 1, 1.1, 1.3, and 22.2 s, respectively and the runtime for our mw f algorithm was 39.1, 368.4, 449 and 1317.6 s, respectively.\nAuthor Contributions: Conceptualization, A.J. and S.S.; Data curation, A.J. and S.S.; Formal analysis, A.J. and S.S.; Investigation, A.J. and S.S.; Methodology, A.J. and S.S.; Project administration, S.S.; Resources, A.J. and S.S.; Software, A.J.; Supervision, S S.; Validation, A.J. and S.S.; Visualization, A.J. and S.S.; Writing\u2014original draft, A.J. and S.S.; Writing\u2014review & editing, A.J. and S.S. All authors have read and agreed to the published version of the manuscript.\nFunding: This research received no external fund.\nInstitutional Review Board Statement: Not applicable.\nInformed Consent Statement: Not applicable.\nData Availability Statement: The Koblenz datasets used for benchmarking are available in the KONECT graphs [18]. The social network graphs of youtube, flickr, livejournal are available at http://socialnetworks.mpi-sws.org/data-imc2007.html (accessed on 16 August 2022). This was shared by the authors of [17].\nAcknowledgments: We acknowledge Wu et al. [8] and Bentert et al. [10] for sharing their implementation with us to benchmark against.\nConflicts of Interest: The authors declare that they have no competing interests.\nAbbreviations The following abbreviations are used in this manuscript:\nNAPP No-wait acyclic path problem V Number of vertices in a graph N Used interchangeably with V Es Number of edges in underlying static graph mw f Min-wait foremost mh f Mih-hop foremost mc f Min-cost foremost Mitg Number of edges in interval-temporal graph (same as Es) Mcsg Number of contact-sequence edges \u03bb Travel duration on an edge at a given departure time \u03b4 Maximum number of departure intervals on an edge\nReferences 1. Scheideler, C. Models and Techniques for Communication in Dynamic Networks. In Proceedings of the STACS19th Annual\nSymposium on Theoretical Aspects of Computer Science, Antibes, Juan les Pins, France, 14\u201316 March 2002; Volume 2285, pp. 27\u201349.\n2. Stojmenovic\u0301, I., Location Updates for Efficient Routing in Ad Hoc Networks. In Handbook of Wireless Networks and Mobile Computing; John Wiley & Sons, Ltd.: Hoboken, NJ, USA, 2002; Chapter 21, pp. 451\u2013471. [CrossRef] 3. Holme, P.; Saram\u00e4ki, J. Temporal networks. Phys. Rep. 2012, 519, 97\u2013125. [CrossRef] 4. Michail, O. An Introduction to Temporal Graphs: An Algorithmic Perspective. arXiv 2015, arXiv:1503.00278. 5. Santoro, N.; Quattrociocchi, W.; Flocchini, P.; Casteigts, A.; Amblard, F. Time-Varying Graphs and Social Network Analysis: Temporal Indicators and Metrics. arXiv 2011, arXiv:1102.0629. 6. Kuhn, F.; Oshman, R. Dynamic Networks: Models and Algorithms. SIGACT News 2011, 42, 82\u201396. [CrossRef] 7. Bhadra, S.; Ferreira, A. Computing multicast trees in dynamic networks and the complexity of connected components in evolving graphs. J. Internet Serv. Appl. 2012, 3, 269\u2013275. [CrossRef] 8. Wu, H.; Cheng, J.; Ke, Y.; Huang, S.; Huang, Y.; Wu, H. Efficient Algorithms for Temporal Path Computation. IEEE Trans. Knowl. Data Eng. 2016, 28, 2927\u20132942. [CrossRef] 9. Bui-Xuan, B.M.; Ferreira, A.; Jarry, A. Evolving graphs and least cost journeys in dynamic networks. In Proceedings of the WiOpt\u201903: Modeling and Optimization in Mobile, Ad Hoc and Wireless Networks, Sophia Antipolis, France, 3\u20135 March 2003. 10. Bentert, M.; Himmel, A.S.; Nichterlein, A.; Niedermeier, R. Efficient computation of optimal temporal walks under waiting-time constraints. Appl. Netw. Sci. 2020, 5, 73. [CrossRef] 11. Guo, F.; Zhang, D.; Dong, Y.; Guo, Z. Urban link travel speed dataset from a megacity road network. Sci. Data 2019, 6, 61. [CrossRef] [PubMed] 12. Gheibi, S.; Banerjee, T.; Ranka, S.; Sahni, S. An Effective Data Structure for Contact Sequence Temporal Graphs. In Proceedings of\nthe 2021 IEEE Symposium on Computers and Communications (ISCC), Athens, Greece, 5\u20138 September 2021; pp. 1\u20138. [CrossRef]\n13. Jain, A.; Sahni, S. Min Hop and Foremost Paths in Interval Temporal Graphs. In Proceedings of the 2021 IEEE Symposium on Computers and Communications (ISCC), Athens, Greece, 5\u20138 September 2021; pp. 1\u20137. 14. Bhadra, S.; Ferreira, A. Complexity of Connected Components in Evolving Graphs and the Computation of Multicast Trees in Dynamic Networks. In Proceedings of the Ad-Hoc, Mobile, and Wireless Networks, Montreal, QC, Canada, 8\u201310 October 2003; Pierre, S., Barbeau, M., Kranakis, E., Eds.; Springer: Berlin/Heidelberg, Germany, 2003; pp. 259\u2013270. 15. Casteigts, A.; Himmel, A.; Molter, H.; Zschoche, P. The Computational Complexity of Finding Temporal Paths under Waiting Time Constraints. arXiv 2019, arXiv:1909.06437. 16. Zschoche, P.; Fluschnik, T.; Molter, H.; Niedermeier, R. The Complexity of Finding Small Separators in Temporal Graphs. arXiv 2018, arXiv:1711.00963. 17. Mislove, A.; Marcon, M.; Gummadi, K.P.; Druschel, P.; Bhattacharjee, B. Measurement and Analysis of Online Social Networks. In Proceedings of the 5th ACM/Usenix Internet Measurement Conference (IMC\u201907), San Diego, CA, USA, 24\u201326 October 2007. 18. Kunegis, J. KONECT: The Koblenz Network Collection. In Proceedings of the 22nd International Conference on World Wide Web, WWW \u201913 Companion, Rio de Janeiro, Brazil, 13\u201317 May 2013; Association for Computing Machinery: New York, NY, USA, 2013; pp. 1343\u20131350. [CrossRef]"
        }
    ],
    "title": "Foremost Walks and Paths in Interval Temporal Graphs ",
    "year": 2022
}