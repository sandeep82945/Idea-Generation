{
    "abstractText": "Recently, Conte et al. generalized the longest-common prefix (LCP) array from strings to Wheeler DFAs, and they showed that it can be used to efficiently determine matching statistics on a Wheeler DFA [DCC 2023]. However, storing the LCP array requires O(n log n) bits, n being the number of states, while the compact representation of Wheeler DFAs often requires much less space. In particular, the BOSS representation of a de Bruijn graph only requires a linear number of bits, if the size of alphabet is constant. In this paper, we propose a sampling technique that allows to access an entry of the LCP array in logarithmic time by only storing a linear number of bits. We use our technique to provide a space-time tradeoff to compute matching statistics on a Wheeler DFA. In addition, we show that by augmenting the BOSS representation of a k-th order de Bruijn graph with a linear number of bits we can navigate the underlying variable-order de Bruijn graph in time logarithmic in k, thus improving a previous bound by Boucher et al. which was linear in k [DCC 2015].",
    "authors": [
        {
            "affiliations": [],
            "name": "Nicola Cotumaccio"
        },
        {
            "affiliations": [],
            "name": "Travis Gagie"
        },
        {
            "affiliations": [],
            "name": "Dominik K\u00f6ppl"
        },
        {
            "affiliations": [],
            "name": "Nicola Prezza"
        }
    ],
    "id": "SP:10319b196d5dcd3bcb5c1d8bda6df0051551e0e1",
    "references": [
        {
            "authors": [
                "J. Alanko",
                "G. D\u2019Agostino",
                "A. Policriti",
                "N. Prezza"
            ],
            "title": "Regular languages meet prefix sorting",
            "venue": "Proc. of the 31st Symposium on Discrete Algorithms, (SODA\u201920). pp. 911\u2013930. SIAM",
            "year": 2020
        },
        {
            "authors": [
                "J. Alanko",
                "G. D\u2019Agostino",
                "A. Policriti",
                "N. Prezza"
            ],
            "title": "Wheeler languages",
            "venue": "Information and Computation 281, 104820",
            "year": 2021
        },
        {
            "authors": [
                "A. Bankevich",
                "S. Nurk",
                "D. Antipov",
                "A.A. Gurevich",
                "M. Dvorkin",
                "A.S. Kulikov",
                "V.M. Lesin",
                "S.I. Nikolenko",
                "S. Pham",
                "A.D. Prjibelski",
                "A.V. Pyshkin",
                "A.V. Sirotkin",
                "N. Vyahhi",
                "G. Tesler",
                "M.A. Alekseyev",
                "P.A. Pevzner"
            ],
            "title": "SPAdes: A new genome assembly algorithm and its applications to single-cell sequencing",
            "venue": "Journal of Computational Biology 19(5), 455\u2013477",
            "year": 2012
        },
        {
            "authors": [
                "C. Boucher",
                "A. Bowe",
                "T. Gagie",
                "S.J. Puglisi",
                "K. Sadakane"
            ],
            "title": "Variable-order de Bruijn graphs",
            "venue": "2015 Data Compression Conference. pp. 383\u2013392",
            "year": 2015
        },
        {
            "authors": [
                "A. Bowe",
                "T. Onodera",
                "K. Sadakane",
                "T. Shibuya"
            ],
            "title": "Succinct de Bruijn graphs",
            "venue": "Algorithms in Bioinformatics. pp. 225\u2013235. Springer Berlin Heidelberg, Berlin, Heidelberg",
            "year": 2012
        },
        {
            "authors": [
                "M. Burrows",
                "D.J. Wheeler"
            ],
            "title": "A block-sorting lossless data compression algorithm",
            "venue": "Tech. rep.",
            "year": 1994
        },
        {
            "authors": [
                "A. Conte",
                "N. Cotumaccio",
                "T. Gagie",
                "G. Manzini",
                "N. Prezza",
                "M. Sciortino"
            ],
            "title": "Computing matching statistics on Wheeler DFAs",
            "venue": "2023 Data Compression Conference (DCC). pp. 150\u2013159",
            "year": 2023
        },
        {
            "authors": [
                "N. Cotumaccio"
            ],
            "title": "Graphs can be succinctly indexed for pattern matching in O(|E|2+ |V |) time",
            "venue": "2022 Data Compression Conference (DCC). pp. 272\u2013281",
            "year": 2022
        },
        {
            "authors": [
                "N. Cotumaccio",
                "N. Prezza"
            ],
            "title": "On indexing and compressing finite automata",
            "venue": "Proc. of the 32nd Symposium on Discrete Algorithms, (SODA\u201921). pp. 2585\u20132599. SIAM",
            "year": 2021
        },
        {
            "authors": [
                "N. Cotumaccio",
                "G. D\u2019Agostino",
                "A. Policriti",
                "N. Prezza"
            ],
            "title": "Co-lexicographically ordering automata and regular languages",
            "year": 2023
        },
        {
            "authors": [
                "D. D\u0131\u0301az-Dom\u0131\u0301nguez",
                "T. Gagie",
                "G. Navarro"
            ],
            "title": "Simulating the DNA Overlap Graph in Succinct Space",
            "venue": "Pisanti, N., Pissis, S.P. (eds.) 30th Annual Symposium on Combinatorial Pattern Matching (CPM 2019). Leibniz International Proceedings in Informatics (LIPIcs), vol. 128, pp. 26:1\u201326:20. Schloss Dagstuhl\u2013Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany",
            "year": 2019
        },
        {
            "authors": [
                "P. Ferragina",
                "F. Luccio",
                "G. Manzini",
                "S. Muthukrishnan"
            ],
            "title": "Structuring labeled trees for optimal succinctness, and beyond",
            "venue": "proc. 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS\u201905). pp. 184\u2013193",
            "year": 2005
        },
        {
            "authors": [
                "P. Ferragina",
                "G. Manzini"
            ],
            "title": "Opportunistic data structures with applications",
            "venue": "Proc. 41st Annual Symposium on Foundations of Computer Science (FOCS\u201900). pp. 390\u2013398",
            "year": 2000
        },
        {
            "authors": [
                "P. Ferragina",
                "F. Luccio",
                "G. Manzini",
                "S. Muthukrishnan"
            ],
            "title": "Compressing and indexing labeled trees, with applications",
            "venue": "J. ACM 57(1)",
            "year": 2009
        },
        {
            "authors": [
                "J. Fischer"
            ],
            "title": "Optimal succinctness for range minimum queries",
            "venue": "L\u00f3pez-Ortiz, A. (ed.) LATIN 2010: Theoretical Informatics. pp. 158\u2013169. Springer Berlin Heidelberg, Berlin, Heidelberg",
            "year": 2010
        },
        {
            "authors": [
                "J. Fischer",
                "V. Heun"
            ],
            "title": "Space-efficient preprocessing schemes for range minimum queries on static arrays",
            "venue": "SIAM Journal on Computing 40(2), 465\u2013492",
            "year": 2011
        },
        {
            "authors": [
                "T. Gagie",
                "G. Manzini",
                "J. Sir\u00e9n"
            ],
            "title": "Wheeler graphs: A framework for BWT-based data structures",
            "venue": "Theoretical Computer Science 698, 67\u201378",
            "year": 2017
        },
        {
            "authors": [
                "R.M. Idury",
                "M.S. Waterman"
            ],
            "title": "A new algorithm for DNA sequence assembly",
            "venue": "Journal of computational biology : a journal of computational molecular cell biology 2 2, 291\u2013306",
            "year": 1995
        },
        {
            "authors": [
                "R. Li",
                "H. Zhu",
                "J. Ruan",
                "W. Qian",
                "X. Fang",
                "Z. Shi",
                "Y. Li",
                "S. Li",
                "G. Shan",
                "K. Kristiansen",
                "S. Li",
                "H. Yang",
                "J. Wang",
                "J. Wang"
            ],
            "title": "De novo assembly of human genomes with massively parallel short read sequencing",
            "venue": "Genome research 20, 265\u2013 72",
            "year": 2009
        },
        {
            "authors": [
                "M. Liu",
                "H. Yu"
            ],
            "title": "Lower bound for succinct range minimum query",
            "venue": "Proceedings of the 52nd Annual ACM SIGACT Symposium on Theory of Computing. p. 1402\u20131415. STOC 2020, Association for Computing Machinery, New York, NY, USA",
            "year": 2020
        },
        {
            "authors": [
                "U. Manber",
                "G. Myers"
            ],
            "title": "Suffix arrays: A new method for on-line string searches",
            "venue": "SIAM J. Comput. 22(5), 935\u2013948",
            "year": 1993
        },
        {
            "authors": [
                "G. Navarro"
            ],
            "title": "Spaces, trees, and colors: The algorithmic landscape of document retrieval on sequences",
            "venue": "ACM Comput. Surv. 46(4)",
            "year": 2014
        },
        {
            "authors": [
                "G. Navarro"
            ],
            "title": "Compact Data Structures - A Practical Approach",
            "year": 2016
        },
        {
            "authors": [
                "Y. Peng",
                "H.C.M. Leung",
                "S.M. Yiu",
                "F.Y.L. Chin"
            ],
            "title": "IDBA \u2013 a practical iterative de Bruijn graph de novo assembler",
            "venue": "Berger, B. (ed.) Research in Computational Molecular Biology. pp. 426\u2013440. Springer Berlin Heidelberg, Berlin, Heidelberg",
            "year": 2010
        },
        {
            "authors": [
                "P.A. Pevzner",
                "H. Tang",
                "M.S. Waterman"
            ],
            "title": "An Eulerian path approach to DNA fragment assembly",
            "venue": "Proceedings of the National Academy of Sciences 98(17), 9748\u20139753",
            "year": 2001
        },
        {
            "authors": [
                "K. Sadakane"
            ],
            "title": "Compressed suffix trees with full functionality",
            "venue": "Theor. Comp. Sys. 41(4), 589\u2013607",
            "year": 2007
        },
        {
            "authors": [
                "J. Simpson",
                "K. Wong",
                "S. Jackman",
                "J. Schein",
                "S. Jones",
                "I. Birol"
            ],
            "title": "ABySS: A parallel assembler for short read sequence data",
            "venue": "Genome research 19, 1117\u201323",
            "year": 2009
        },
        {
            "authors": [
                "P. Weiner"
            ],
            "title": "Linear pattern matching algorithms",
            "venue": "Proc. 14th IEEE Annual Symposium on Switching and Automata Theory. pp. 1\u201311",
            "year": 1973
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n30 6.\n05 68\n4v 1\n[ cs\n.D S]\n9 J\nKeywords: Wheeler graphs \u00b7 LCP array \u00b7 de Bruijn graphs \u00b7 Matching statistics \u00b7 Variable-order de Bruijn graphs."
        },
        {
            "heading": "1 Introduction",
            "text": "In 1973, Weiner invented the suffix tree of a string [28], a versatile data structure which allows to efficiently handle a variety of problems, including solving pattern matching queries, determining matching statistics, identifying combinatorial properties of the string and computing its Lempel-Ziv decomposition. However, the space consumption of a suffix tree can be too high for some applications (including bioinformatics), so over the past 30 years a number of compressed data structures simulating the behavior of a suffix tree have been designed, thus leading to compressed suffix trees [26]. In many applications, one does not need the full functionality of a suffix tree, so it may be sufficient to store only some of these data structures. Among the most popular data structures, we have the suffix array [21], the longest common prefix (LCP) array [21], the Burrows-Wheeler transform (BWT) [6] and the FM-index [13].\nIn the past 20 years, the ideas behind the suffix array, the BWT and the FMindex have been generalized to trees [12,14], de Bruijn graphs [5], Wheeler graphs [1, 17] and arbitrary graphs and automata [8, 9]. Broadly speaking, Wheeler graphs concisely capture the intuition behind these data structures in a graph setting; thus, they can be regarded as a benchmark for extending suffix tree functionality to graphs. In particular, the LCP array of a string remarkably extends the functionality of the suffix array, and a recent paper [7] shows that the LCP array can also be generalized to Wheeler DFAs, which represents a remarkable step toward fully simulating suffix-tree functionality in a graph setting. However, the solution in [7] is not space efficient: storing the LCP array of a Wheeler DFA requires O(n log n) bits, n being the number of states. If the size \u03c3 of the alphabet is small, this space can be considerably larger than the space required to store the Wheeler DFA itself. As we will see, if \u03c3 log \u03c3 = o(logn) , then the space required to store the Wheeler DFA is o(n log n), and if \u03c3 = O(1), then the space required to store the Wheeler DFA is O(n). The latter case is especially relevant in practice, because de Bruijn graphs are the prototypes of Wheeler graphs, and in bioinformatics de Bruijn graphs are defined over the constant-size alphabet \u03a3 = {A,C,G, T }.\nIn this paper, we show that we can sample entries of the LCP array in such a way that, by storing only a linear number of additional bits on top of the Wheeler graph, we can compute each entry of the LCP array in logarithmic time, thus providing a space-time trade-off. More precisely:\nTheorem 1. We can augment the compact representation of a Wheeler DFA A with O(n) bits (O(n log log \u03c3) bits, respectively), where n is the number of states and \u03c3 is the size of the alphabet, in such a way that we can compute each entry of the LCP array of A in O(log n log log \u03c3) time (O(log n) time, respectively).\nWe present two applications of our result: computing matching statistics on Wheeler DFAs and navigating varriable-order de Bruijn graphs.\nMatching Statistics on Wheeler DFAs The problem of computing matching statistics on a Wheeler DFA is defined as follows: given a pattern of length m and a Wheeler DFA with n states, determine the longest suffix of each prefix of m that occurs in the graph (that is, that can be read by following some edges on the graph and concatenating the labels). This problem is a natural generalization of the problem of computing matching statistics on strings. Conte et al. [7] proved the following result:\nTheorem 2. We can augment the compact representation of a Wheeler DFA A with O(n logn) bits, where n is the number of states and \u03c3 is the size of the alphabet, in such a way that we can compute the matching statistics of a pattern of length m w.r.t to the Wheeler DFA in O(m log n) time.\nWe will show that if we only want to use linear space, then we can use Theorem 1 to obtain the following trade-off.\nTheorem 3. We can augment the compact representation of a Wheeler DFA A with O(n log log \u03c3) bits, where n is the number of states and \u03c3 is the size of the alphabet, in such a way that we can compute the matching statistics of a pattern of length m w.r.t to the Wheeler DFA in O(m log2 n) time.\nVariable-order de Bruijn Graphs Wheeler graphs are a generalization of de Bruijn graphs; in particular, the compact representation of a Wheeler graph is a generalization of the BOSS representation of a de Bruijn graph [5], and our results on the LCP array also apply to a de Bruijn graph. Many assemblers [3, 19, 24, 27] consider all k-mers occurring in a set of reads and build a k-th order de Bruijn graph (on the alphabet \u03a3 = {A,C,G, T }) to perform Eulerian sequence assembly [18, 25]. However, the choice of the parameter k impacts the assembly quality, so some assemblers try several choices for k [3,24], which slows down the process because several de Bruijn graphs need to be built. In [4] it was shown that the k-order de Bruijn graph of S can be used to implicitly store the k\u2032-th order de Bruijn graph of S for every k\u2032 \u2264 k, thus leading to a variable-order de Bruijn graph. The challenge is to navigate this implicit representation (that is, how to follow edges in a forward or backward fashion). In [4], it was shown that the navigation is possible by storing or by simulating an array LCPG which can be seen as a simplification of the LCP array of the Wheeler graph G. More precisely, we have the following result (see [4]; we assume \u03c3 = O(1)).\nTheorem 4. 1. We can augment the BOSS representation of a k-th order de Bruijn graph with O(n log k) bits, where n is the number of nodes, so that the underlying variable-order de Bruijn graph can be navigated in O(log k) time per visited node.\n2. We can augment the BOSS representation of a k-th order de Bruijn graph with O(n) bits, where n is the number of nodes, so that the underlying variable-order de Bruijn graph can be navigated in O(k logn) time per visited node.\nEssentially, the first solution in Theorem 4 explicitly stores LCPG, while the second solution in Theorem 4 computes the entries of LCPG by exploiting the BOSS representation. In general, a big k (close to the size of the reads) allows to retrieve the expressive power on an overlap graph [11], so in Theorem 4 we cannot assume that k is small. On the one hand, the space required for the first solution can be too large, because a de Bruijn graph can be stored by using only O(n) bits. On the other hand, the time bound in the second solution increases substantially. We can now improve the second solution by providing a data structure that achieves the best of both worlds. As we did in Theorem 1, we can conveniently sample some entries of LCPG. We will prove the following result.\nTheorem 5. We can augment the BOSS representation of a k-th order de Bruijn graph with O(n) bits, where n is the number of nodes, so that the underlying variable-order de Bruijn graph can be navigated in O(log k logn) time per visited node."
        },
        {
            "heading": "2 Definitions",
            "text": "Sets and Relations Let V be a set. A total order on V is a binary relation \u2264 which is reflexive, antisymmetric and transitive. We say that U is a \u2264-interval (or simply an interval) if for all v1, v2, v3 \u2208 V , if v1, v3 \u2208 U and v1 < v2 < v3, then v2 \u2208 U . If u, v \u2208 V , with u \u2264 v, we denote by [u, v] the smallest interval containing u and v, that is [u, v] = {z \u2208 V | u \u2264 z \u2264 v }. In particular, if V is the set of integers, then we assume that \u2264 is the standard total order, hence [u, v] = {u, u+ 1, . . . , v \u2212 1, v}.\nStrings Let \u03a3 be a finite alphabet, with \u03c3 = |\u03a3|. Let \u03a3\u2217 be the set of all finite strings on \u03a3 and let \u03a3\u03c9 be the set of all (countably) infinite strings on \u03a3. If \u03b1 \u2208 \u03a3\u2217, then \u03b1R is the reverse string of \u03b1. If \u03b1, \u03b2 \u2208 \u03a3\u2217 \u222a \u03a3\u03c9, we denote by lcp(\u03b1, \u03b2) the length of longest common prefix between \u03b1 and \u03b2. In particular, if \u03b1 \u2208 \u03a3\u2217, then lcp(\u03b1, \u03b2) \u2264 |\u03b1| and if \u03b1, \u03b2 \u2208 \u03a3\u03c9 with \u03b1 = \u03b2, then lcp(\u03b1, \u03b2) = \u221e. Let be a fixed total order on \u03a3. We extend the total order from \u03a3 to \u03a3\u2217 \u222a\u03a3\u03c9 lexicographically.\nDFAs Throughout the paper, let A = (Q,E, s0, F ) be a deterministic finite automaton (DFA), where Q is the set of states, E \u2286 Q \u00d7 Q \u00d7 \u03a3 is the set of labeled edges, s0 \u2208 Q is the initial state and F \u2286 Q is the set of final states. The alphabet \u03a3 is effective, that is, every c \u2208 \u03a3 labels some edge. Since A is deterministic, for every u \u2208 Q and for every a \u2208 \u03a3 there exists at most one edge labeled a leaving u. Following [1], we assume that (i) s0 has no incoming edges, (ii) every state is reachable from the initial state and (iii) all edges entering the same state have the same label (input-consistency). For every u \u2208 Q \\ {s0}, let \u03bb(u) \u2208 \u03a3 be the label of all edges entering u. We define \u03bb(s0) = #, where # 6\u2208 \u03a3 is a special character such that # \u227a a for every a \u2208 \u03a3 (the character # plays the same role as the termination character $ in suffix arrays, suffix trees and Burrows-Wheeler transforms). As a consequence, an edge (u\u2032, u, a) can be simply written as (u\u2032, u), because it must be a = \u03bb(u).\nCompact Data Structures Let A be an array of length n containing elements from a finite totally-ordered set. A range minimum query on A is defined as follows: given 1 \u2264 i \u2264 j \u2264 n, return one of the indices k with 1 \u2264 k \u2264 n such that (i) i \u2264 k \u2264 j and A[k] = min{A[i], A[i + 1], . . . , A[j \u2212 1], A[j]}. We write k = RMQA(i, j). Then, there exists a data structure of 2n+ o(n) such that in O(1) time we can compute RMQA(i, j) for every 1 \u2264 i \u2264 n, without the need to access A [15,16]. This result is essentially optimal, because every data structure solving range minimum queries on A requires at least 2n\u2212\u0398(log n) bits [16,20].\nLet A be a bitvector of length n. Let rank(A, i) = |{j \u2208 {1, 2, . . . , i \u2212 1, i} | A[j] = 1}| be the number of 1\u2019s among the first i bits of A. Then, there exists a data structure of n+ o(n) bits such that in O(1) time we can compute rank(A, i) for 1 \u2264 i \u2264 n [23]."
        },
        {
            "heading": "3 Wheeler DFAs",
            "text": "Let us recall the definition of Wheeler DFA [7].\nDefinition 1. Let A = (Q,E, s0, F ) be a DFA. A Wheeler order on A is a total order \u2264 on Q such that s0 \u2264 u for every u \u2208 Q and:\n1. (Axiom 1) If u, v \u2208 Q and u < v, then \u03bb(u) \u03bb(v). 2. (Axiom 2) If (u\u2032, u), (v\u2032, v) \u2208 E, \u03bb(u) = \u03bb(v) and u < v, then u\u2032 < v\u2032.\nA DFA A is Wheeler if it admits a Wheeler order.\nEvery DFA admits at most one Wheeler order [1], so the total order \u2264 in Definition 1 is the Wheeler order on A. In the following, we fix a Wheeler DFA A = (Q,E, s0, F ), with n = |Q| and e = |E|, and we write Q = {u1, . . . , un}, with u1 < u2 < \u00b7 \u00b7 \u00b7 < un in the Wheeler order. In particular, u1 = s0. Following [7], we assume that s0 has a self-loop labeled #, which is consistent with Axiom 1, because # \u227a a for every a \u2208 \u03a3). This implies that every state has at least one incoming edge, so for every state ui there exists at least one infinite string \u03b1 \u2208 \u03a3\u03c9 that can be read starting from ui and following edges in a backward fashion. We denote by Iui the nonempty set of all such strings. Formally:\nDefinition 2. Let 1 \u2264 i \u2264 n. Define:\nIui = {\u03b1 \u2208 \u03a3 \u03c9 | there exist integers f1, f2, . . . in [1, n] such that (i) f1 = i,\n(ii) (ufk+1 , ufk) \u2208 E for every k \u2265 1 and (iii) \u03b1 = \u03bb(uf1)\u03bb(uf2) . . . }.\nFor every 1 \u2264 i \u2264 n, let pmin(i) be the smallest 1 \u2264 i \u2032 \u2264 n such that (ui\u2032 , ui) \u2208 E and let pmax(i) be the largest 1 \u2264 i \u2032\u2032 \u2264 n such that (ui\u2032\u2032 , ui) \u2208 E. Both pmin(i) and pmax(i) are well-defined because every state has at least one incoming edge. For every 1 \u2264 i \u2264 n, define p1min(i) = pmin(i) and recursively, for j \u2265 2, let pjmin(i) = pmin(p j\u22121 min(i)). Then, \u03bb(ui)\u03bb(pmin(i))\u03bb(p 2 min(i))\u03bb(p 3 min(i)) . . . is the lexicographically smallest string in Iui , which we denote by mini [7]. Analogously, one can define the lexicographically largest string in Iui by using pmax. Moreover, in [7] it was shown that:\nmin1 max1 min2 max2 \u00b7 \u00b7 \u00b7 maxn\u22121 minn maxn.\nIntuitively, the previous equation shows that the permutation of the set of all states of A induced by the Wheeler order can be seen as a generalization of the permutation of positions induced by the prefix array of a string \u03b1 (or equivalently, the suffix array of the reverse string of \u03b1R). Indeed, a string \u03b1 can also be seen as a DFA A\u2032 = (Q\u2032, E\u2032, s\u20320, F \u2032), where Q\u2032 = {q\u20320, q \u2032 1 . . . , q \u2032 |\u03b1|}, s \u2032 0 = q \u2032 0, F \u2032 = {q\u2032|\u03b1|} (the set F plays no role here), \u03bb(q \u2032 i) is the i-th character of \u03b1 for 1 \u2264 i \u2264 n and E\u2032 = {(q\u2032i\u22121, q \u2032 i) | 1 \u2264 i \u2264 n} (every state is reached by exactly one string so the minimum and the maximum string reaching each state are equal). Let 1 \u2264 r \u2264 s \u2264 n and let c \u2208 \u03a3. Let Er,s,c be the set of all states that can be reached from a state in [r, s] by following edges labeled c; formally, Er,s,c = {1 \u2264\nj \u2264 n | \u03bb(uj) = c and (ui, uj) \u2208 E for some i \u2208 [r, s] }. Then, Er,s,c is again an interval, that is, there exist 1 \u2264 r\u2032 \u2264 s\u2032 \u2264 n such that Er,s,c = [r\n\u2032, s\u2032] [17]. This property enables a compression mechanism that generalizes the BurrowsWheeler transform [6] and the FM-index [13] to Wheeler DFAs. The Wheeler DFA A can be stored by using only 2e+ 4n+ e log\u03c3 + \u03c3 log e bits (up to lower order terms), including n bits to mark the set F of final states and n bits to mark all 1 \u2264 i \u2264 n such that \u03bb(ui) 6= \u03bb(ui\u22121), which allows us to retrieve each \u03bb(ui) in O(1) time by using a rank query [17] (recall that n is the number of states and e is the number of edges). Since A is a DFA, we have e \u2264 n\u03c3, so the required space is O(n\u03c3 log \u03c3). If the alphabet is small \u2014 that is, if \u03c3 log \u03c3 = o(log n) \u2014 then the number of required bits is o(n logn); if \u03c3 = O(1), then the number of required bits is O(n). This compact representation supports efficient navigation of the graph and it allows to solve pattern matching queries. More precisely, by resorting to state-of-the art select queries [23] in O(log log \u03c3) time (i) for 1 \u2264 i \u2264 n, we can compute pmin(i) and pmax(i) and (ii) given 1 \u2264 r \u2264 s \u2264 n and c \u2208 \u03a3, we can compute [r\u2032, s\u2032] = Er,s,c [17]. In particular, query (ii) is the so-called forward-search, which generalizes the analogous mechanism of the FM-index, thus allowing to solve pattern matching queries on the graph.\nThe Wheeler order generalizes the notion of suffix array from strings to DFA. It is also possible to generalize LCP-arrays from strings to graph [7].\nDefinition 3. The LCP-array of the Wheeler DFA A is the array LCPA = LCPA[2, 2n] which contains the following 2n \u2212 1 values in the following order: lcp(min1,max1), lcp(max1,min2), lcp(min2,max2), . . . , lcp(maxn\u22121,minn), lcp(minn,maxn). In other words, LCP[2i] = lcp(mini,maxi) for 1 \u2264 i \u2264 n and LCPA[2i\u2212 1] = lcp(maxi\u22121,mini) for 2 \u2264 i \u2264 n.\nIt can be proved that for every 2 \u2264 i \u2264 n, if LCPA[i] is finite, then LCPA[i] < 3n [7]. As a consequence, LCPA can be stored by using O(n logn) bits."
        },
        {
            "heading": "4 A Space-time Trade-off for the LCP Array",
            "text": "By storing an LCP array on top of the compact representation of a Wheeler graph, we have additional information that we can use to efficiently solve problems such as computing the matching statistics; however, we need to store O(n log n) bits. As we have seen, O(n log n) dominates the number of bits required to store A itself, if the alphabet is small. In this section, we show that we can store a data structure of only O(n log log \u03c3) bits which allows to compute every entry LCPA[i] in O(log n) time, thus proving Theorem 1. This will be possible by sampling some entries of LCPA. The sampling mechanism is obtained by conveniently defining an auxiliary graph from the entries of the LCP array. We will immediately describe our technique, our sampling mechanism being general-purpose.\nSampling Let G = (V,H) be a finite (unlabeled) directed graph such that every node has at most one incoming edge. For every v \u2208 V and for every i \u2265 0,\nAlgorithm 1 Building V (h)\nV (h)\u2190 \u2205 U \u2190 \u2205 while there exists v \u2208 V such that (a) v(i) is defined for 0 \u2264 i \u2264 h \u2212 1, (b) v(i) 6= v(j) for 0 \u2264 j < i \u2264 h\u2212 1, (c) v(i) 6\u2208 U for 0 \u2264 i \u2264 h\u2212 1 do\nPick such a v, add v(h \u2212 1) to V (h) and add v(i) to U for every 0 \u2264 i \u2264 h\u2212 1 end while\nAlgorithm 2 Input: h \u2208 [2, 2n]. Output: LCPA[h].\nprocedure main function(h) Initialize a global bit array D[2, 2n] to zero \u22b2 D[2, 2n] marks the entries already considered return lcp(h) end procedure\nprocedure lcp(h) D[h]\u2190 1 if C[h] = 1 then \u22b2 The desired value has been sampled\nreturn LCP\u2217 A [rank(C, h)]\nelse if h is odd then i\u2190 \u2308h/2\u2309 if \u03bb(ui\u22121) 6= \u03bb(ui) then\nreturn 0 else\nk \u2190 pmax(i\u2212 1) k\u2032 \u2190 pmin(i) j \u2190 RMQLCPA (2k + 1, 2k\n\u2032 \u2212 1) if D[j] = 1 then \u22b2 We have already considered this entry before, so there is a cycle\nreturn \u221e else\nreturn 1 + lcp(j) end if\nend if\nelse\ni\u2190 h/2 k\u2190 pmin(i) k\u2032 \u2190 pmax(i) j \u2190 RMQLCPA (2k, 2k \u2032) if D[j] = 1 then \u22b2 We have already considered this entry before, so there is a cycle return \u221e else\nreturn 1 + lcp(j) end if\nend if\nend procedure\nthere exists at most one node v\u2032 \u2208 V such that there exists a directed path from v\u2032 to v having i edges; if v\u2032 exists, we denote it by v(i). Fix a parameter h \u2265 1. Let us prove that there exists V (h) \u2286 V such that (i) |V (h)| \u2264 |V |h and (ii) for every v \u2208 V there exists 0 \u2264 i \u2264 2h \u2212 2 such that v(i) is defined and either v(i) \u2208 V (h) or v(i) has no incoming edges or v(i) = v(j) for some 0 \u2264 j < i. We build V (h) incrementally following Algorithm 1. Let us prove that, at the end of the algorithm, properties (i) and (ii) are true. For every v \u2208 V (h), define Sv = {v, v(1), v(2) . . . , v(h \u2212 1)}, which is possible because by construction if v \u2208 V (h), then v(i) is defined for every 0 \u2264 i \u2264 h\u2212 1. It must be v(i) 6= v(j) for 0 \u2264 i < j \u2264 h\u22121, so |Sv| = h. If v, v\n\u2032 \u2208 V (h) and v 6= v\u2032, then by construction Sv and Sv\u2032 are disjoint. As a consequence, |V | \u2265 \u2211 v\u2208V (h) |Sv| = \u2211 v\u2208V (h) h = h|Vh|\nand so |Vh| \u2264 |V | h , which proves property (i). Let us prove property (ii). Pick v \u2208 V ; we must prove that there exists 0 \u2264 i \u2264 2h\u2212 2 such that v(i) is defined and either v(i) \u2208 V (h) or v(i) has no incoming edges or v(i) = v(j) for some 0 \u2264 j < i. We distinguish three cases:\n1. there exists i with 1 \u2264 i \u2264 h\u2212 1 such that v(i\u2212 1) is defined but v(i) is not defined. Then, v(i \u2212 1) has no incoming edges. 2. there exist i, j with 0 \u2264 j < i \u2264 h \u2212 1 such that v(j) and v(i) are defined and v(i) = v(j). In this case, the conclusion is immediate. 3. v(i) is defined for every 0 \u2264 i \u2264 h and v(i) 6= v(j) for 0 \u2264 j < i \u2264 h \u2212 1. Since Algorithm 1 has terminated, then there exists 0 \u2264 j \u2264 h \u2212 1 such that v(j) \u2208 U . The construction of U implies that there exists v\u2032 \u2208 V and 0 \u2264 j \u2264 h\u22121 such that v(j) = v\u2032(j\u2032) and v\u2032(h\u22121) \u2208 V (h). As a consequence v(h\u2212 1+ j \u2212 j\u2032) = v(j)(h\u2212 1\u2212 j\u2032) = (v\u2032(j\u2032))(h\u2212 1\u2212 j\u2032) = v\u2032(h\u2212 1) \u2208 V (h). Since j \u2264 h\u2212 1 and j\u2032 \u2265 0, we conclude h\u2212 1 + j \u2212 j\u2032 \u2264 2h\u2212 2 and we are done.\nComputing the LCP Array Using a Linear Number of Bits First, let us store a data structure of O(n) bits which in O(1) time determines RMQLCPA(i, j) for every 2 \u2264 i \u2264 j \u2264 2n.\nNotice that LCPA[2i] \u2265 1 for 1 \u2264 i \u2264 n because the first character of mini and the first character of maxi are equal to \u03bb(ui). Moreover, we have LCPA[2i\u22121] \u2265 1 if and only if \u03bb(ui\u22121) = \u03bb(ui), for 2 \u2264 i \u2264 n.\nConsider the entry LCPA[2i\u2212 1] = lcp(maxi\u22121,mini), for 2 \u2264 i \u2264 n, and assume that LCPA[2i\u22121] \u2265 1. Let k = pmax(i\u22121) and k\n\u2032 = pmin(i). Since LCPA[2i\u2212 1] \u2265 1, then there exists a \u2208 \u03a3 such that maxi\u22121 = amaxk and mini\u22121 = amink\u2032 . In particular, (uk, ui\u22121, a) \u2208 E and (uk\u2032 , ui, a) \u2208 E, so from Axiom 2 we obtain k < k\u2032. Moreover, we have LCPA[2i \u2212 1] = lcp(maxi\u22121,mini) = lcp(amaxk, amink\u2032) = 1 + lcp(maxk,mink\u2032). Notice that:\nlcp(maxk,mink\u2032 ) = min{lcp(maxk,mink+1), lcp(mink+1,maxk+1), . . . ,\n= lcp(mink\u2032\u22121,maxk\u2032\u22121), lcp(maxk\u2032\u22121,mink\u2032)} = = min{LCPA[2k + 1], LCPA[2k + 2], . . . , LCPA[2k \u2032 \u2212 2], LCPA[2k \u2032 \u2212 1]}.\nLet j = RMQLCPA(2k + 1, 2k \u2032 \u2212 1). Then, LCPA[j] = min{LCPA[2k +\n1], LCPA[2k+2], . . . , LCPA[2k \u2032\u22122], LCPA[2k \u2032\u22121]}, so LCPA[2i\u22121] = 1+LCPA[j] (we assume t + \u221e = \u221e for every t \u2265 0), and we have reduced the problem of computing LCPA[2i\u2212 1] to the problem of computing LCPA[j]. In the following, let R(2i\u22121) = j. Given 2 \u2264 i \u2264 n, we can compute j = R(2i\u22121) in O(log log \u03c3) time, because we can compute k = pmax(i \u2212 1) and k\n\u2032 = pmin(i) in O(log log \u03c3) time and we can compute j in O(1) time by means of a range minimum query.\nWe proceed analogously with the entries LCPA[2i] = lcp(mini,maxi), for 1 \u2264 i \u2264 n (it must necessarily be LCPA[2i] \u2265 1). Let k = pmin(i) and k\n\u2032 = pmax(i); by the definitions of pmin and pmax it must be k \u2264 k\n\u2032. Hence, LCPA[2i] = 1+ lcp(mink,maxk\u2032) and similarly lcp(mink,maxk\u2032) = min{LCPA[2k], LCPA[2k+\n1], . . . , LCPA[2k \u2032 \u2212 1], LCPA[2k \u2032]}. Let j = RMQLCPA(2k, 2k \u2032). In the following, let R(2i) = j. Given 1 \u2264 i \u2264 n, we can compute j = R(2i) in O(log log \u03c3) time. See Figure 1 for an example.\nNow, consider the (unlabeled) directed graph G = (V,H) defined as follows. Let V be a set of 2n\u22121 nodes v2, v3, . . . , v2n. Moreover, vi \u2208 V has no incoming edge in G if R(i) is not defined, which happens if LCPA[i] = 0 (and so i is odd and \u03bb(ui\u22121) 6= \u03bb(ui)); vi \u2208 V has exactly one incoming edge if R(i) is defined, namely, (vR(i), vi). Note that v2i has an incoming edge for every 1 \u2264 i \u2264 n. Let h \u2265 1 be a parameter. We know that there exists V (h) \u2286 V such that (i) |V (h)| \u2264 |V |h and (ii) for every vi \u2208 V there exists 0 \u2264 k \u2264 2h \u2212 2 such that vi(k) is defined and either vi(h) \u2208 V (h) or vi(h) has no incoming edges or vi(h) = vi(l) for some 0 \u2264 l < h. Notice that if vi(h) = vi(l) for some 0 \u2264 l < h, then LCPA[i] = \u221e (because there is a cycle and so vi(h\n\u2032) is defined for every h\u2032 \u2265 0). Let n\u2032 = |V (h)|, and let LCP\u2217A[1, n \u2032] an array storing the value LCPA[i] for each vi \u2208 V (h), sorted by increasing i. Since n \u2032 \u2264 |V |h = 2n\u22121 h , storing LCP\u2217A[1, n \u2032] takes n\u2032O(log n) = O(n log nh ) bits. We store a bitvector C[2, 2n] such that C[i] = 1 if and only if vi \u2208 V (h) for every 2 \u2264 i \u2264 2n; we augment C with o(n) bits so that it supports rank queries in O(1) time. For every 2 \u2264 i \u2264 2n, in O(1) time we can check whether LCPA[i] has been stored in LCP \u2217 A by checking whether C[i] = 1, and if C[i] = 1 it must be LCPA[i] = LCP \u2217 A[rank(C, i)].\nFrom our discussion, it follows that Algorithm 2 correctly computes LCPA[i] for every 2 \u2264 i \u2264 n. Property (ii) ensures that the function lcp is called at most h times. Every call requires O(log log \u03c3) time, so the running time of our algorithm is O(h log log \u03c3) (the initialization of D[2, 2n] in Algorithm 2 can be simulated in O(1) time [22]). We conclude that we store O(n+ n lognh ) bits, and in O(h log log \u03c3) time we can compute LCPA[i] for every 2 \u2264 i \u2264 n.\nBy choosing h = \u2308 lognlog log \u03c3 \u2309, we conclude that our data structure can be stored using O(n log log \u03c3) bits and it allows to compute LCPA[i] for every 2 \u2264 i \u2264 n in O(log n) time. By choosing h = \u2308logn\u2309 we conclude that our data structure can be stored using O(n) bits and it allows to compute LCPA[i] for every 2 \u2264 i \u2264 n in O(log n log log \u03c3) time."
        },
        {
            "heading": "5 Applications",
            "text": "Matching Statistics Let us recall how the bounds in Theorem 2 are obtained. The space bound is O(n log n) bits because we need to store LCPA. We also store a data structure to solve range minimum queries on LCPA, which only takes O(n) bits. The time bound O(m logn) follows from performing O(m) steps to compute all matching statistics. In each of these O(m) steps, we may need to perform a binary search on LCPA. In each step of the binary search, we need to solve a range minimum query once and we need to access LCPA once, so the binary search takes O(log n) time per step. By Theorem 1, if we store only O(n log log \u03c3) bits, we can access LCPA in O(log n) time, so the time for the binary search becomes O(log2 n) per step and Theorem 3 follows.\nVariable-order de Bruijn Graphs Let k \u2265 0 be a parameter, and let S be a set of strings on the alphabet \u03a3 = {A,C,G, T } (in this application we always assume \u03c3 = O(1)).\nThe k-th order de Bruijn graph of S is defined as follows. The set of nodes is the set of all strings of \u03a3 of length k that occur as a substring of some string in S. There is an edge from node \u03b1 to node \u03b2 labeled c \u2208 \u03a3 if and only if (i) the suffix of \u03b1 of length k \u2212 1 is equal to the prefix of \u03b2 of length k \u2212 1 and (ii) the last character of \u03b2 is c. If some node \u03b1 has no incoming edges, then we add nodes $i\u03b1k\u2212i for 1 \u2264 i \u2264 k, where \u03b1j is the prefix of \u03b1 of length j and $ is a special character, and we add edges as above; see Figure 2 for an example. Wheeler DFAs are a generalization of de Bruijn graphs (we do not need to define an initial state and a set of final states, because here we are not interested in studying the applications of de Bruijn graphs and Wheeler automata to automata theory [2, 10]); the Wheeler order is the one such that node \u03b1 comes before node \u03b2 if and only if the string \u03b1R is lexicographically smaller than the string \u03b2R [17].\nNotice that, in a k-th order de Bruijn graph G, all strings that can be read from node \u03b1 by following edges in a backward fashion start with \u03b1R (as usual,\nwe assume that node $$$ has a self-loop labeled $). As a consequence, it holds LCPG[2i] \u2265 k for every 1 \u2264 i \u2264 n and LCPG[2i\u2212 1] \u2264 k \u2212 1 for every 2 \u2264 i \u2264 n (so any value in an odd entry is smaller than any value in an even entry).\nAs we saw in the introduction, in [4] it was shown that the k-order de Bruijn graph of S can be used to implicitly store the k\u2032-th order de Bruijn graph of S for every k\u2032 \u2264 k, thus leading to a variable-order de Bruijn graph. The navigation of a variable-order de Bruijn graph is possible by storing or by simulating the values in the odd entries of the LCP array. Formally, in order to avoid confusion, we define LCPG[i] = LCPG[2i \u2212 1] for every 2 \u2264 i \u2264 n; see Figure 2. Note that LCPG[i] \u2264 k \u2212 1 for every 2 \u2264 i \u2264 n, so LCPG can be stored by using O(n log k) bits. Notice that Theorem 1 also applies to LCPG[i] (we do not need to store values in the even entries because a value in an odd entry is smaller than a value in an even entry, so even entries are never selected in the sampling process when answering a range minimum query on LCPG). However, we can now choose a better parameter h \u2265 1 in our sampling process. Indeed, each entry of LCPG can be stored by using O(log k) bits (not O(log n) bits), so if we choose h = \u2308log k\u2309, we conclude that we can augment the BOSS representation of a de Bruijn graph with O(n) bits such that for every 2 \u2264 i \u2264 n we can compute LCPG[i] in O(log k) time.\nThe first solution in Theorem 4 consists in storing a wavelet tree on LCPG, which requires O(n log k) bits and allows to navigate the graph in O(log k) time per visited node. The second solution in Theorem 4 does not store LCPG at all; whenever needed, an entry of LCPG is computed in O(k) time by exploiting the BOSS representation of the de Bruijn graph. The second solution only stores a data structures of O(n) bits to solve range minimum queries. The details can be found in [4]. Essentially, the time bound O(k log n) comes from performing binary searches on LCPG while explicitly computing an entry of LCPG at each step in O(k) time. However, we have seen that, while staying within the O(n) space bound, we can augment the BOSS representation so that we can compute the entries of LCPG in O(log k) time, so the time bound O(k logn) becomes O(log k logn), which implies Theorem 5."
        }
    ],
    "title": "Space-time Trade-offs for the LCP Array of Wheeler DFAs",
    "year": 2023
}