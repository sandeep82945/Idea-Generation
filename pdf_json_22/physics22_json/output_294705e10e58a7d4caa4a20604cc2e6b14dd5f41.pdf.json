{
    "abstractText": "Edges are image locations where the gray value intensity changes suddenly. They are among the most important features to understand and segment an image. Edge detection is a standard task in digital image processing, solved, for example, using filtering techniques. However, the amount of data to be processed grows rapidly and pushes even supercomputers to their limits. Quantum computing promises exponentially lower memory usage in terms of the number of qubits compared to the number of classical bits. In this paper, we propose a hybrid method for quantum edge detection based on the idea of a quantum artificial neuron. Our method can be practically implemented on quantum computers, especially on those of the current noisy intermediate-scale quantum era. We compare six variants of the method to reduce the number of circuits and thus the time required for the quantum edge detection. Taking advantage of the scalability of our method, we can practically detect edges in images considerably larger than reached before.",
    "authors": [],
    "id": "SP:06733aa4e4121b77859e693e623eb1c5f98e0f21",
    "references": [
        {
            "authors": [
                "H Abraham"
            ],
            "title": "Qiskit: An Open-source Framework for Quantum Computing",
            "venue": "https:// doi. org/",
            "year": 2019
        },
        {
            "authors": [
                "G Acampora",
                "F Di Martino",
                "R Schiattarella",
                "A Vitiello"
            ],
            "title": "Measuring distance between quantum states by fuzzy similarity operators",
            "venue": "IEEE International Conference on Fuzzy Systems (FUZZ-IEEE),",
            "year": 2021
        },
        {
            "authors": [
                "A Asfaw"
            ],
            "title": "Learn quantum computation using Qiskit, http:// commu nity",
            "venue": "qiskit. org/ textb ook. Accessed December",
            "year": 2021
        },
        {
            "authors": [
                "M Born"
            ],
            "title": "Quantenmechanik der Sto\u00dfvorg\u00e4nge. Zeitschrift f\u00fcr Physik 38(11):803\u2013827, https:// doi",
            "venue": "org/ 10. 1007/",
            "year": 1926
        },
        {
            "authors": [
                "P Fan",
                "RG Zhou",
                "WW Hu",
                "N Jing"
            ],
            "title": "Quantum image edge extraction based on laplacian operator and zero-cross method. Quantum Information Processing 18(1):1\u201323, https:// doi",
            "venue": "org/ 10",
            "year": 2019
        },
        {
            "authors": [
                "A Geng",
                "A Moghiseh",
                "C Redenbach",
                "K Schladitz"
            ],
            "title": "Improved FRQI on superconducting processors and its restrictions in the nisq era",
            "venue": "Preprint at https:// arxiv. org/ abs/",
            "year": 2021
        },
        {
            "authors": [
                "AL Gibbs",
                "FE Su"
            ],
            "title": "On choosing and bounding probability metrics. International statistical review",
            "venue": "https:// doi. org/",
            "year": 2002
        },
        {
            "authors": [
                "I Goodfellow",
                "Y Bengio"
            ],
            "title": "Courville A (2016",
            "venue": "Deep learning. MIT press,",
            "year": 2016
        },
        {
            "authors": [
                "E Hellinger"
            ],
            "title": "Neue Begr\u00fcndung der Theorie quadratischer Formen von unendlich vielen Ver\u00e4nderlichen",
            "venue": "Journal fu\u0308r die reine und angewandte Mathematik",
            "year": 1909
        },
        {
            "authors": [
                "R LaRose"
            ],
            "title": "Mitiq: A software package for error mitiga",
            "year": 2020
        },
        {
            "authors": [
                "H Ma",
                "P Chu"
            ],
            "title": "Demonstration of quantum image edge",
            "venue": "abs/",
            "year": 2009
        },
        {
            "authors": [
                "S Mangini",
                "F Tacchino",
                "D Gerace",
                "C Macchiavello",
                "D Bajoni"
            ],
            "title": "Quantum computing model of an artificial neuron with continuously valued input data. Machine Learning: Science and Technology 1(4):045008, https:// doi",
            "year": 2020
        },
        {
            "authors": [
                "M Mastriani"
            ],
            "title": "Quantum edge detection for image segmentation in optical environments",
            "venue": "Preprint at https:// arxiv. org/ abs/",
            "year": 2014
        },
        {
            "authors": [
                "MA Nielsen",
                "I Chuang"
            ],
            "title": "Quantum computation and quantum information",
            "year": 2000
        },
        {
            "authors": [
                "M Rossi",
                "M Huber",
                "D Bru\u00df",
                "C Macchiavello"
            ],
            "title": "Quantum hypergraph states",
            "venue": "New Journal of Physics",
            "year": 2013
        },
        {
            "authors": [
                "A Sawchuk"
            ],
            "title": "USC-SIPI image database, http:// sipi. usc. edu/ datab ase",
            "venue": "Accessed December",
            "year": 1973
        },
        {
            "authors": [
                "F Tacchino",
                "C Macchiavello",
                "D Gerace",
                "D Bajoni"
            ],
            "title": "An artificial neuron implemented on an actual quantum processor. npj Quantum Information 5(1):1\u20138, https:// doi",
            "year": 2019
        },
        {
            "authors": [
                "M Weigold",
                "J Barzen",
                "F Leymann",
                "M Salm"
            ],
            "title": "Expanding data encoding patterns for quantum algorithms",
            "venue": "IEEE 18th International Conference on Software Architecture Companion (ICSA-C),",
            "year": 2021
        },
        {
            "authors": [
                "S Widiyanto",
                "D Sundani",
                "Y Karyanti",
                "D Wardani"
            ],
            "title": "Edge detection based on quantum canny enhancement for medical imaging",
            "venue": "IOP Conference Series: Mater Sci Eng 536(1):012118,",
            "year": 2019
        },
        {
            "authors": [
                "Z Wang",
                "Z Luo"
            ],
            "title": "Quantum image processing and its",
            "year": 2017
        },
        {
            "authors": [
                "Y Zhang",
                "K Lu",
                "Y Gao"
            ],
            "title": "QSobel: A novel quantum image edge extraction algorithm",
            "venue": "Sci China Inf Sci 58(1):1\u201313,",
            "year": 2015
        }
    ],
    "sections": [
        {
            "text": "Vol.:(0123456789)\nKeywords Quantum image processing\u00a0\u00b7 Quantum edge detection\u00a0\u00b7 Quantum artificial neurons\u00a0\u00b7 IBM quantum experience\u00a0\u00b7 Real backend"
        },
        {
            "heading": "1 Introduction",
            "text": "Humans detect edges in 2D images routinely visually. In industrial applications, edge detection is used, e.g., for extracting the structure of objects, features, or regions within an image. Thereby, changes in material properties like surface defects can be detected.\nIn classical image processing, a standard way to highlight the edges is to compute the image gradient. It requires\nthe pixel-wise computation of the partial gray value derivatives which is achieved by convolving the image with a filter mask assigning suitable weights to pixels in a chosen discrete neighborhood. In the filtered image, high gray values indicate a gray value change in the original, whereas low gray values indicate homogeneous neighborhoods without changes and edges. Various methods for edge detection have been suggested, for instance, the Prewitt, Sobel, or Laplace filters or Canny\u2019s edge detector (Gonzalez and Woods 2018). The idea is to calculate pixel-wise approximations of the derivatives in vertical and horizontal direction. The filters mentioned above differ in the choice of the weights in a 3 \u00d7 3 filter mask. In the Canny edge detector, filtering is complemented by applying some threshold functions to suppress non-maxima and decide which components are really edges and which are rather due to noise.\nExploiting a real quantum computer, we can benefit from exponentially lower memory usage in terms of the number of qubits compared to the number of bits needed to represent an image classically. Several approaches for quantum edge detection have been proposed. However, most of them are only formulated in theory or for a quantum computer simulator (Mastriani 2014; Fan et\u00a0al. 2019; Widiyanto et\u00a0al. 2019; Ma et\u00a0al. 2020; Zhang et\u00a0al. 2015). When applied on real quantum computers,\nAli Moghiseh, Claudia Redenbach, and Katja Schladitz contributed equally to this work.\n* Alexander Geng alexander.geng@itwm.fraunhofer.de\nAli Moghiseh ali.moghiseh@itwm.fraunhofer.de\nClaudia Redenbach redenbach@mathematik.uni-kl.de\nKatja Schladitz katja.schladitz@itwm.fraunhofer.de\n1 Fraunhofer Institute for\u00a0Industrial Mathematics ITWM, Fraunhofer-Platz 1, Kaiserslautern\u00a067663, Rhineland-Palatinate, Germany\n2 University of\u00a0Kaiserslautern, Gottlieb-Daimler-Stra\u00dfe 47, Kaiserslautern\u00a067663, Rhineland-Palatinate, Germany\nQuantum Machine Intelligence (2022) 4:15\n1 3\nthey are limited by high error rates, the small number of qubits available, and low coherence times. This can lead to results too noisy to be interpretable.\nFor example, in QSobel (Zhang et\u00a0al. 2015) \u2014 a quantum version of the well-known classical Sobel filter \u2014 some steps like the COPY operation or the quantum black box for calculating the gradients of all pixels can currently not be implemented. To fill these gaps is a topic of current research. The Quantum Hadamard Edge Detection algorithm was suggested as a more efficient alternative (Yao et\u00a0al. 2017). Implementations for a state vector simulator for an 8 \u00d7 8 pixel gray value image and for a 2 \u00d7 2 pixel image on a real quantum computer are provided in the Qiskit textbook (Asfaw et\u00a0al. 2021). Larger image sizes are briefly discussed, too, but to our knowledge have not yet been tested in practice.\nHere, we introduce a hybrid method motivated by classical filtering and making use of Tacchino\u2019s quantum machine learning algorithm (Tacchino et\u00a0al. 2019) and its extension to gray value images (Mangini et\u00a0al. 2020). We use a quantum information-based cost function to compare an image patch of a test image with a binary filter mask. We perform this calculation for two filter masks highlighting vertical and horizontal edges and combine their results. With the filter mask size, we control the number of qubits and gates. For the edge detection task, we only need very few gates and by that keep the error in the current NISQ era low. In our method, the error of each circuit is independent of the image size. This way, we can push the size of images that can be processed on the current circuit-based superconducting quantum computers of IBM (2021) to a yet unreached limit.\nThis paper is organized as follows. In Section\u00a02, we roll out the strategy for solving the edge detection task by an artificial neuron and filtering in the purely classical setting. In Section\u00a02.2, we explain some preliminaries needed to replace the classical artificial neuron by its quantum version in Section\u00a02.3. In Section\u00a02.4, we present the idea of our quantum edge detector with 2D and 1D masks, and discuss the improvements of the version with the 1D mask in theory. We describe the experimental setup in Section\u00a03. Experimental results are shown and discussed in Section\u00a04. Section\u00a05 concludes the paper."
        },
        {
            "heading": "2 Method",
            "text": ""
        },
        {
            "heading": "2.1 Edge detection by\u00a0artificial neurons",
            "text": "In classical image processing, we find edges of objects in an image by filtering (Gonzalez and Woods 2018). Firstor second-order derivatives can be used to track gray value changes in the image and thereby to detect edges. Here, we opt for the first-order derivatives. We calculate digital approximations of the partial derivatives at every pixel location in the image. Let Iin be a gray value input image. Then, the partial derivatives in x- and y-direction are estimated by\nand\nThis can be implemented by convolving Iin(x, y) with the one-dimensional filters from Fig.\u00a01\u00a0a and b, respectively.\nSeveral approaches for avoiding edge effects are commonly used, e.g., zero padding, replicate padding, or mirroring, see Gonzalez and Woods (2018). We use mirroring to prevent generation of artificial edges. Two-dimensional discrete derivative filters can be defined analogously, as the examples in Fig.\u00a01 c and d. In general, there is no limit to the range of values of the weights or the size of the filter masks (Gonzalez and Woods 2018). However, we only cover these two filter masks for the two-dimensional case in this paper. Using the derivative filters for both directions, we create two output images Ih, Iv highlighting horizontal and vertical edges, respectively. We combine them by a pixel-wise maximum:\nA pixel in the image Iboth has a high gray value if it belongs to an edge in horizontal or vertical direction. If neither the horizontal nor the vertical filter detects an edge, then both Ih and Iv have low values which yields a small maximum in Iboth.\n(1) Iin(x, y)\nx \u2248 Iin(x + 1, y) \u2212 Iin(x, y)\n(2) Iin(x, y)\ny \u2248 Iin(x, y + 1) \u2212 Iin(x, y).\n(3)Iboth = max(Ih, Iv).\n15 Page 2 of 16\nQuantum Machine Intelligence (2022) 4:15\n1 3\nFinally, we segment the edge pixels by a binarization, for instance, a global gray value threshold chosen by Otsu\u2019s method (Gonzalez and Woods 2018). Postprocessing is performed by using Fraunhofer ITWM\u2019s image processing software ToolIP (Fraunhofer Institute for Industrial Mathematics 2021).\nA special case of classical filtering is also found in the basic element of a feed-forward network, a certain kind of an artificial neural network. The goal is to learn values of weights such that a function f mapping the inputs to some outputs y is well approximated. Let c , w be the real valued classical input and weight vectors, respectively. The basic element of an artificial neural network is an artificial neuron \u2014 a mathematical function, which first calculates the weighted sum of one or more inputs and then applies a nonlinear activation to yield the output. It is defined by\nwhere is the activation function and b an additional socalled bias shifting the activation function for more flexibility of the network. By connecting a large number of artificial neurons in layers and by ordering layers consecutively, we can construct a feed-forward neural network. For further details, we refer to Goodfellow et\u00a0al. (2016)."
        },
        {
            "heading": "2.2 Quantum image processing preliminaries",
            "text": "We summarize some quantum image processing preliminaries, before explaining our quantum version of the edge detector. We start at a classical image, want to find the edges in the image using a quantum computer, and finally get back a classical image in which the edges are highlighted. A key element to achieve this is encoding of the gray values of the classical image into quantum states. For encoding, unitary operations, also called gates, are applied to an initial state of the quantum computer. There are several encoding methods like basis, amplitude, or phase encoding (Weigold et\u00a0al. 2021).\nWe use phase encoding to keep the number of qubits low. That means, we first transform the 8-bit gray values of an image into angles = ( 0,\u2026 , N\u22121) with j \u2208 [0, ] , j \u2208 {0,\u2026 ,N \u2212 1} . Similar to Geng et\u00a0al. (2021), we use the linear transformation\ncalculated element-wise, for all j \u2208 {0,\u2026 ,N \u2212 1} . The transformed input vector is defined by\nThis way, we transform the gray values to angles, encode them as phases in the quantum computer, and measure the outcome. The measurement itself is probabilistic. That\n(4)y = f (c,w) = (wT c + b),\n(5) j = cj\u2215255 \u22c5 ,\n(6)c\u0303 = (ei\ud835\udf030 , ei\ud835\udf031 ,\u2026 , ei\ud835\udf03N\u22121).\nmeans, we run the same algorithm multiple times, count the frequencies of the possible states, and derive an empirical probability distribution. The number of executions is also called number of shots.\nTo compare the outcomes of the quantum computer, we use the Hellinger fidelity (Hellinger 1909) derived from the Hellinger distance. Let P,\u00a0Q be two discrete probability distributions with probability weights p = (p1,\u2026 , pn) , q = (q1,\u2026 , qn) . Then, the Hellinger distance is defined by\nsee Hellinger (1909). The Hellinger fidelity is defined by\nIt takes values in the interval [0,\u00a01] with higher values for more similar distributions.\nGibbs and Su (2002) compare a variety of distance metrics for probability distributions, including the popular discrepancy metric, Kullback-Leibler divergence, and total variation distance, and discuss their relation to the Hellinger distance. We follow the quantum computing community\u2019s mainstream in choosing the Hellinger fidelity because it matches the square of the absolute amplitude of a quantum state. Fuzzy similarity (Acampora et\u00a0al. 2021) has been suggested, too. Systematically comparing distance measures is however outside the scope of this paper.\nFor all quantum calculations, we use the open-source software development kit Qiskit (Abraham et\u00a0al. 2019). Besides the standard gates like NOT (X), controlled-NOT (CX), multi-controlled-NOT (CnX), or Hadamard (H) gates, we also use phase shift gates (P) in this paper to encode the classical information. They have the matrix form\nand represent a rotation around the Z-axis by an angle in the Bloch sphere. Ancilla qubits are also used, especially in conjunction with controlled operations such as the CX- or C nX-gates. These are additional qubits which can be used for storing states, since quantum computers implement only reversible logic. At the price of more CX- or C nX-gates, ancilla qubits can reduce the number of measurements. This is advantageous because we only need one measurement of the ancilla qubit. Thus, the structure is comparable to the classical artificial neuron with one outcome.\nFor the definitions and implementations of the standard gates and other basic concepts, we refer to Nielsen and Chuang (2000) and Asfaw et\u00a0al. (2021). Additionally,\n(7)HD(P,Q) = 1\u221a 2 \ufffd\ufffd\ufffd\ufffd n\ufffd j=1 \ufffd\u221a pj \u2212 \u221a qj \ufffd2 ,\n(8)F(P,Q) = \ufffd 1 \u2212 HD2(P,Q) \ufffd2 = \ufffd n\ufffd j=1 \u221a pjqj \ufffd2 .\n(9)P( ) = ( 1 0\n0 ei\n) ,\nPage 3 of 16 15\n1 3\nTable\u00a01 provides some standard quantum mechanical notions from linear algebra used in this paper."
        },
        {
            "heading": "2.3 Quantum artificial neuron",
            "text": "Our quantum edge detector is motivated by Tacchino\u2019s (Tacchino et\u00a0al. 2019) quantum algorithm for an artificial neuron. We will use the extension from Mangini et\u00a0al. (2020) which\nalso allows for treating gray value images. Our method is sketched in Fig.\u00a02. In the following, we explain each step, from left to right.\nLet \ufffdk \u27e9 be the 2n-dimensional computational basis states indexed by the decimal number k corresponding to the vector of zeros and ones as binary number. We write the corresponding quantum state for the input vector c\u0303 , see (6), using n = log2 N qubits\nNotion Description\nz\u2217 Complex conjugate of a complex number z = a + bi. z\u2217 = (a + bi)\u2217 = a \u2212 bi , where a, b \u2208 \u211d.\nA\u2217 Complex conjugate of a matrix A, element-wise. AT Transpose of a matrix A. A\u2020 Hermitian conjugate or adjoint of a matrix A, A\u2020 = (AT )\u2217.\n( c d\nf g\n)\u2020 = ( c\u2217 f \u2217\nd\u2217 g\u2217\n)\n\ufffd \u27e9 Encoded vector, also called ket. \u27e8 \ufffd Dual vector, also called bra. Transposed, conjugated version of \ufffd \u27e9.\n\u27e8 \ufffd = \ufffd \u2217 0 , \u2217 1 ,\u2026 , \u2217 n \ufffd .\n\u27e8 \ufffd \u27e9 Inner product of \ufffd \u27e9 and \ufffd \u27e9. \ufffd\ud835\udf19 \u27e9\u2297 \ufffd\ud835\udf12 \u27e9 Tensor product of \ufffd \u27e9 and \ufffd \u27e9.(\nc0 c1\n) \u2297 ( d0 d1 ) = ( c0d0, c0d1, c1d0, c1d1 )T .\nQuantum Machine Intelligence (2022) 4:15\n1 3\nand encode the weight vector analogously as\nfor weights = ( 0,\u2026 , N\u22121) with j \u2208 [0, ] and corresponding vector\nThe inner product of the encoded input \u0398 and weight quantum states \u0393 is then\nwhere the second equality follows from the orthonormality of \ufffdk \u27e9 and \ufffdl \u27e9 . Thus, the calculation corresponds to the scalar product of the input vector from (6) and the conjugated weight vector from (12), analogously to the classical artificial neuron. We set b = 0 in (4) and (\u22c5) = | \u22c5 |2 is the activation function of the quantum neuron.\nTo encode the inner product, unitary operations/gates have to be applied. In quantum computing, the qubits are usually initialized in well-prepared states. First, we transform this initial state into the input quantum state by the unitary operation UI . The following operation UW yields the inner product of input and weight quantum state. Via a multi-controlled-NOT (Cn X) gate targeting an ancilla qubit and controlled by n qubits, we extract the result by measuring the ancilla qubit.\nIn Qiskit (Abraham et\u00a0al. 2019), the state \ufffd0\u27e9 is the initial state for all qubits. Thus, the n-qubit state at the beginning is \ufffd00\u2026 0\u27e9 = \ufffd0\u27e9\u2297n , where \u2297 stands for the tensor product. The operation UI creates the input quantum state\nas given in (10). It can be built in two steps. First, we apply Hadamard gates H\u2297n to the qubits, to create a balanced superposition state \ufffd+\u27e9\u2297n with \ufffd+\u27e9 = (\ufffd0\u27e9 + \ufffd1\u27e9)\u2215 \u221a 2.\nSecond, the appropriate phase has to be added to the equally weighted superposition of all the states in the n qubits computational basis, in order to obtain \ufffd\u0398\u27e9 . This corresponds to the diagonal unitary operation\n(10)\ufffd\u0398\u27e9 = 1 2n\u22152 2n\u22121\ufffd k=0 c\u0303k\ufffdk \u27e9.\n(11)\ufffd\u0393\u27e9 = 1 2n\u22152 2n\u22121\ufffd k=0 w\u0303k\ufffdk \u27e9.\n(12)w\u0303 = (ei\ud835\udefe0 , ei\ud835\udefe1 ,\u2026 , ei\ud835\udefeN\u22121 ).\n(13)\n\u27e8\u0393\ufffd\u0398\u27e9 = 1 2n \u22112n\u22121 k,l=0 c\u0303 k w\u0303 l\n\u2217\u27e8l\ufffdk\u27e9 = 1\n2n c\u0303 T w\u0303\n\u2217 = 1\n2n\n\ufffd e i( 0\u2212 0) +\u22ef + ei( 2n\u22121\u2212 2n\u22121) \ufffd ,\n(14)UI\ufffd0\u27e9\u2297n = \ufffd\u0398\u27e9\nInstead of calculating the complete unitary matrix U( ) , we decompose it into\nwith U( j)\ufffdj \u27e9 = ei j \ufffdj \u27e9 . With one U( j) , we apply a phase shift to one computational basis state and leave all the other states unchanged. Practically, this is realized by a combination of X-gates (to which state we want to apply a phase shift) and a multi-controlled phase shift gate C n\u22121P( ) as defined in (9) for n = 1 . In total, we have\nThe unitary UW is encoded similarly, just conjugated, see Mangini et\u00a0al. (2020). Consequently, the actual prepared quantum state is\nTo extract the results, we apply X-gates X \u2297n to the qubits, such that the desired coefficient is the one of the state \ufffd1\u27e9\u2297n . This step completes the unitary operator\nFinally, we use an ancilla qubit as in Mangini et\u00a0al. (2020) and map the result to it by a multi-controlled-NOT gate (Cn X) with n control qubits\nwhere r2n\u22121 = \u27e8\u0393\ufffd\u0398\u27e9. Probabilities in quantum mechanics are represented by the squared modulus of wave function amplitudes (Born rule (Born 1926)). This fact, combined with the global phase invariance, yields the activation function\nwhere \ud835\udf03j = \ud835\udf03j \u2212 \ud835\udf030 and ?\u0303?j = \ud835\udefej \u2212 \ud835\udefe0 for j \u2208 {1,\u2026 , 2n \u2212 1} . Figure\u00a03 shows the circuit for n = 2 qubits.\n(15)U( ) = \u239b\u239c\u239c\u239c\u239d ei 0 0 \u22ef 0 0 ei 1 \u22ef 0 \u22ee \u22ee \u22f1 \u22ee 0 0 \u22ef ei 2n\u22121 \u239e\u239f\u239f\u239f\u23a0 .\n(16)U( ) = 2n\u22121\u220f j=0 U( i)\n(17)UI\ufffd0\u27e9\u2297n = U(\ud835\udf03)H\u2297n\ufffd0\u27e9\u2297n = \ufffd\u0398\u27e9.\n(18)\ufffd\ud835\udf19\u27e9 = (U(\ud835\udefe)H\u2297n)\u2020\ufffd\u0398\u27e9.\n(19)UW = X\u2297nH\u2297nU(\ud835\udefe)\u2020.\n(20)\nCnX(X\u2297n\ufffd\ud835\udf19\u27e9\ufffd0\u27e9a) = 2n\u22122\ufffd j=0 rj\ufffdj\u27e9\ufffd0\u27e9a + r2n\u22121\ufffd11\u22ef 1 \u27e9\ufffd1\u27e9a,\n(21)\ufffd\u27e8\u0393\ufffd\u0398\u27e9\ufffd2 = 1 22n \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd 2n\u22121 j=0 ei(\ud835\udf03j\u2212\ud835\udefej) \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd 2 = 1 22n \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd 1 + 2n\u22121\ufffd j=1 ei(\ud835\udf03j\u2212?\u0303?j) \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd 2 ,\nPage 5 of 16 15\nQuantum Machine Intelligence (2022) 4:15\n1 3"
        },
        {
            "heading": "2.4 Quantum edge detection",
            "text": ""
        },
        {
            "heading": "2.4.1 Quantum edge detection with\u00a02D mask",
            "text": "In order to use the idea of the quantum artificial neuron of the previous section for quantum edge detection, we have to split the input image into 2 \u00d7 2 patches. The vectorized version of this patch serves as input vector c and the vectorized version of the 2D mask as weight vector w. The main idea of our quantum edge detection is to replace the classical calculation of the inner product by the quantum artificial neuron. All the other classical steps from Section\u00a02.1, like selecting vertical and horizontal directions, combining them, and applying a threshold, remain the same and are calculated on a classical computer."
        },
        {
            "heading": "2.4.2 Quantum edge detection with\u00a01D mask",
            "text": "For the sake of generality, we chose an approach motivated by classical 2D filtering. However, if we are interested in edges only, then we can also use one-dimensional filter masks as in Fig.\u00a01 a and b. This is advantageous since we only have to encode two classical pixel values into a quantum state. We only need one qubit for that and fewer gates compared to the two-dimensional filtering described above. That way, the algorithm is much less error-prone. A circuit for the one-dimensional case is shown in Fig.\u00a04.\nOnly two Hadamard gates (H), four Phase gates (P), and two NOT gates (X) are required. Analytically, we describe the circuit by\nwhere j = j \u2212 j and j+1 = j+1 \u2212 j+1 . Note, that the angles for the filter mask weights in UW are the negative of the original one and the order of the gates in UW is completely opposite to UI (see (13) and Mangini et\u00a0al. 2020). At the end, we get the probability of measuring the qubit in state \ufffd0\u27e9 as\nwhere = ( j, j+1) and = ( j, j+1) . t is estimated by counting the frequencies of the \ufffd0\u27e9 state of multiple runs and coincides with the absolute square of the amplitude in front of the \ufffd0\u27e9 state of (22).\nOn a real backend, all unitary gates of the circuits are transformed to the basis gates. Here, this results in a decomposition into three R z - and two SX-gates and a circuit depth of six. Other gates, in particular the errorprone CX-gates are not required. For the two-dimensional case shown in Fig.\u00a03, we need around 31 R z -, 22 CX-, 6 SX-, 5 NOT gates, and have approximately a\n(22)\nU( , )\ufffd0\u27e9 = UWUI\ufffd0\u27e9 = HP(\u2212 j)XP(\u2212 j+1)P( j+1)XP( j)H\ufffd0\u27e9 = 0.5 \ufffd ei j+1 + ei j \ufffd\ufffd0\u27e9 + 0.5\ufffdei j+1 \u2212 ei j\ufffd\ufffd1\u27e9,\n(23)\ufffd\u27e80\ufffdU( , )\ufffd0\u27e9\ufffd2 = 1 4 \ufffdei j+1 + ei j \ufffd2,\n15 Page 6 of 16\nQuantum Machine Intelligence (2022) 4:15\n1 3\ncircuit depth of 49 depending on the coupling map and the configuration of the chosen backend.\nA drawback of the quantum edge detection with 1D mask are some missing elements in the image, as visible in Fig.\u00a014 in Section\u00a04.2. To circumvent this problem, an additional direction is required. We add input image patches for the diagonal direction Iin(x, y) , Iin(x + 1, y + 1) of the input image. The outcome Id is combined with those for the vertical and horizontal directions by the pixel-wise maximum yielding"
        },
        {
            "heading": "2.4.3 Improved quantum edge detection with\u00a01D mask",
            "text": "Using the 1D masks, we need fewer gates, and therefore also observe less noise. Now we modify this solution in several ways to further reduce the numbers of circuits and jobs and to shorten the execution time. We compare six variants of the implementation in the following. The first one, denoted by Std32T, is the one-dimensional variant with 32,000 shots from above. In the second one, Std50, we decrease the number of shots to 50 while the method and the circuit remain the same.\n(24)Itotal = maxm\u2208{h,v,d} Im.\nThe remaining four variants of the one-dimensional quantum edge detector involve mid-circuit measurement, parallelism, and also 50 measurements, and are dedicated to detecting edges in larger images using less circuits to be applicable on the current quantum computers. So far, we have to execute each of the three directions (horizontal, vertical, and diagonal) separately. In the third variant, Seq50, we combine all three directions in one circuit sequentially by using mid-circuit measurements allowing qubits to be individually measured at any point in the circuit. IBM launched this feature of their backends in the beginning of 2021 (IBM 2021). We use it to measure the required qubit three times, once for each direction. Note, that we reset the qubit to its initial state \ufffd0\u27e9 after the first and second measurement. Figure\u00a05 shows this variant.\nWith this improvement, we decrease the number of circuits by a factor of 3. To retrieve the results for the three directions, we marginalize the counts from the experiment over the three indices (0 for diagonal, 1 for horizontal, and 2 for vertical). For that, we use Qiskit\u2019s utility function marginal_counts (Abraham et\u00a0al. 2019).\nIn the fourth variant, Para50, we combine the three directions in parallel instead of sequentially as before and marginalize the counts as in the third variant. Figure\u00a06 yields the circuit for this variant.\nPage 7 of 16 15\nQuantum Machine Intelligence (2022) 4:15\n1 3\nThanks to the parallel execution, we need less time to apply all gates than in Seq50. However, we need three qubits instead of one. The fifth variant, Para50_3pix, extends Para50\u2019s main idea to more pixels. Instead of encoding only one pixel per circuit we parallelize the scheme for three pixels in one circuit as shown in Fig.\u00a07.\nWith this adaption, we triple the number of required qubits but simultaneously divide the number of required circuits by three. Clearly, this idea can be extended to more qubits, but we refrain from exemplifying this here.\nFinally, a mixture of Seq50\u00a0 and Para50\u00a0 leads to the sixth and last variant, that we cover in this paper, SeqPara50. We\ntake the mid-circuit measurement from Seq50, but encode four pixel values in the three directions, instead of only one. That is, we extend Seq50\u00a0 by two pixels per qubit and parallelize this scheme on two qubits. If we apply operations to a qubit after a mid-circuit measurement, we reset the qubit to the initial state \ufffd0\u27e9 . The circuit for SeqPara50\u00a0 is shown in Fig.\u00a08.\nThis way we divide the number of required circuits by 12 compared to Std32T\u00a0and Std50. We need 12 measurements per circuit for the four pixels. Clearly, the idea of this method can be extended for more pixels, both by more qubits and by more operations per qubit.\nTo compare the outcomes of the six variants, we use the Hellinger fidelity, which is defined in (8).\nAs reference image, we calculate the pixel-wise maximum of the horizontal, vertical, and diagonal direction of the corresponding analytical descriptions (23). Note, that we use the state \ufffd0\u27e9 there. The state \ufffd1\u27e9 could also be used but would return the inverse image, with black edges and white background. For the three directions m \u2208 {h, v, d} , we have the analytical description\nwhere j,m = j,m \u2212 j and j+1,m = j+1,m \u2212 j+1. The pixel-wise maximum of the three resulting images is the reference image. The gray value frequencies of this image enter the Hellinger fidelity as entries qj . The frequencies of the outcome of the real backends are plugged into (8) as pj."
        },
        {
            "heading": "3 Near\u2011term quantum computers setting",
            "text": "Here, we describe our setting for evaluating our method from the previous section. It includes software, a classical computer, and quantum computers.\n(25)\ufffd\u27e80\ufffdU( m, m)\ufffd0\u27e9\ufffd2 = 14 \ufffde i j+1,m + ei j,m \ufffd2.\nFig. 8 Circuit scheme for SeqPara50. We apply Seq50\u00a0 two times sequentially and two times in parallel. The first index of the angle is the actual position {0, 1, 2, 3} of the input image patch modulo 4. That means, the first input image patch for all three directions is encoded in the top left Seq block, the second in the top right, the third in bottom left, and the forth in the bottom right block. The second\nindex describes the direction m \u2208 {h, v, d} . We have m = (0, ) , for all m \u2208 {h, v, d} , since in all cases the first pixel of the filter mask is black and the second white (see Fig.\u00a01 a and b). In total, 24 SX- and 36 R\nz -gates are needed for this circuit, if we decompose the Had-\namard and Phase gates into basis gates\n15 Page 8 of 16\n1 3\nWe use the open-source software development kit Qiskit (Abraham et\u00a0al. 2019) for working with IBM\u2019s circuitbased superconducting quantum computers (IBM 2021). They provide a variety of systems, also known as backends, which differ in the type of the processor, the number of qubits, and their connectivity. Access is provided via a cloud. In this paper, we use the backends \u2018ibm_auckland\u2019, \u2018ibm_washington\u2019, \u2018ibmq_guadalupe\u2019, \u2018ibmq_mumbai\u2019, \u2018ibmq_sydney\u2019, and \u2018ibmq_ehningen\u2019. The corresponding coupling maps are shown in Fig.\u00a09.\nAdditionally, the processor types and the performance values of the respective backend in terms of scale (number of qubits), quality (quantum volume), and speed (circuit layer operations per second [CLOPS]) are given in Table\u00a02.\nBesides the various coupling maps and performance values, the backends underlie external influences. Characteristics of the backends, like CX error, readout error, or decoherence times, can change hourly. Calibration should diminish this effect, errors are however averaged over 24 h. Typical average values for CX error, readout error,\ndecoherence times T1, T2, and frequency are shown in Table\u00a03.\nIn addition to quantum computers, a classical computer is needed for preparing data and generating and storing the circuits before sending them to the quantum computer. We use a computer with an Intel Xeon E5-2670 processor running at 2.60 GHz, a total RAM of 64 GB, and Red Hat Enterprise Linux 7.9.\nTranspilation is needed for transferring a circuit designed on a classical computer to a quantum computer: First, to match the topology of a specific backend (see for example in Fig.\u00a09). Second, to transform all gates to basis gates. Third, to optimize the operations. We use the default transpiler of Qiskit (Abraham et\u00a0al. 2019; Asfaw et\u00a0al. 2021).\nQuantum Machine Intelligence (2022) 4:15\n1 3"
        },
        {
            "heading": "4 Experimental results",
            "text": "In this section, we show examples of what can be expected with current hardware for a classical edge detection task."
        },
        {
            "heading": "4.1 Quantum edge detection with\u00a02D mask",
            "text": ""
        },
        {
            "heading": "4.1.1 Binary image",
            "text": "Starting with the experiment from Fig.\u00a0 2, we use a 30 \u00d7 30 binary sample image and two binary filter masks in horizontal and vertical direction (see Fig.\u00a01 c and d). Black pixels are interpreted as an angle 0 and white pixels as \u03c0. For each combination of input image patch and filter mask, we create one circuit. Thus, the 30 \u00d7 30 sample image requires 900 circuits for each direction. The results are interpretable and correct (see Fig.\u00a02 on the right side) even without error correction or mitigation techniques to reduce noise.\nIf we plot the histogram of the pixel-wise maximum of both directions Iboth (see Fig.\u00a010), the various types of pixels (edges, background, diagonals or endpoints of lines)\nare clearly distinguishable in three areas. Consequently, it is easy to choose a suitable threshold value.\nFor binary images, it is in theory also possible to use an approach based on the generation of hypergraph states similar to Tacchino et\u00a0al. (2019) instead of the circuit given in Fig.\u00a03. This is due to the fact that the prepared real equally weighted states like in (10) and (11) ( c\u0303k, w\u0303k \u2208 {\u22121, 1} ) coincide with the quantum hypergraph states (Rossi et\u00a0al. 2013). By that, we can decrease the number of gates, especially the number of controlled gates. Since we deal with a quite small circuit, using the hypergraph states only yields a small improvement. For larger circuits, especially with multiple qubits that have to be entangled, the difference will be more pronounced."
        },
        {
            "heading": "4.1.2 Gray value image",
            "text": "As a toy example for a gray value image, we created a 30 \u00d7 30 image (see Fig.\u00a011a) with sharp edges. The quantum algorithm and the method are the same as above since the algorithm is already adapted to gray value images. We insert the angles (converted gray values as shown in Section\u00a02.3) into the quantum algorithm, get the results, and post-process as in the binary case. The outcomes are shown in Fig.\u00a011.\nFig. 11 Results for a 30 \u00d7 30 gray value image, created for test purposes. Only small deviation between the Iboth of the \u2019qasm_simulator\u2019 (sim) and backend \u2018ibmq_ehningen\u2019 (back). All edges are detected in both cases\n15 Page 10 of 16\nQuantum Machine Intelligence (2022) 4:15\n1 3\nOf course, the gray values affect the values of the outcome. Compared to Fig.\u00a02, the Iboth image in Fig.\u00a011 b and c also shows lower values for the foreground and higher values for the background, which makes the threshold choice more difficult (see Fig.\u00a012). The three areas shown in Fig.\u00a010 are partly no longer distinguishable for all single pixels. However, it is still possible to detect all of the edges.\nFigure\u00a013 shows the outcomes for a downscaled classical image processing test image. The main edges in the image are detected."
        },
        {
            "heading": "4.2 Quantum edge detection with\u00a01D mask",
            "text": "As in the two-dimensional case, we move the two-pixel sliding window through the whole image. For each step\nwe create one circuit as visualized in Fig.\u00a04. In total, we have the same amount of circuits needed to encode the image. That is, 900 circuits for a 30 \u00d7 30 gray value image. The outcome for the binary sample image (see Fig.\u00a02) with the one-dimensional quantum edge detector is shown in Fig.\u00a014.\nThe method is well suited to detect vertical and horizontal edges in the image. However, some connections between the detected edges are missing like that in the top left corner of the objects.\nThis effect also holds for the diagonal edges of the house roof or the tree and explains the differences between the outcomes from Fig.\u00a02 and Fig.\u00a014. With the adaption of (24), the missing edge pixels in Fig.\u00a014 are detected as shown in Fig.\u00a015.\nFig. 13 Results for the downscaled 30 \u00d7 30 House image of the USC-SIPI image database (Sawchuk et\u00a0al. 1973). Only small deviation between the Iboth of the \u2019qasm_simulator\u2019 (sim) and backend \u2018ibmq_ehningen\u2019 (back)\nFig. 14 Results for our 30 \u00d7 30 binary test image with one-dimensional filtering. Only small deviation between the Iboth of the \u2019qasm_ simulator\u2019 (sim) and backend \u2018ibmq_ehningen\u2019 (back) with 32,000 shots. Due to the one-dimensional filtering, pixels at the top left corner of the objects are not detected as edges\nPage 11 of 16 15\n1 3"
        },
        {
            "heading": "4.3 Comparison of\u00a0quantum edge detection with\u00a01D and\u00a02D mask",
            "text": "The main difference between the two variants is the size and depth of the quantum circuits. In the one-dimensional case, only one qubit and five gates are needed. In the two-dimensional case, we need three qubits, more gates, and especially the error-prone CX-gates. If there is no connection between required qubits, additional SWAP-gates (three CX-gates per SWAP-gate) are inserted in the transpilation step. Therefore the depth of the circuit on the real backend becomes larger.\nSince in the quantum edge detection with 1D filters we need fewer gates and no CX-gates, it is also more robust to noise than that with 2D filters. The various combinations, which can occur, are a further reason. We calculate the inner product of the encoded input and weight quantum states. In the one-dimensional case, these are the two angles from the input image patch.\nIn the two-dimensional case, we have three angles for the input image patch and three angles for the weights. By that, we have more classes (see, for example, Fig.\u00a010). Not all of them can be distinguished from each other with a simple\nthreshold value. Especially for gray value images, the values for edges can be indistinguishable from those of the background with noise. This effect is visualized in Fig.\u00a016, especially with a lower number of shots (1000 shot).\nFor the one-dimensional quantum edge detector, there are only small visual differences between the results with 1000 shots and those with the maximum number of 32,000 using for example the backend \u2018ibmq_ehningen\u2019. The edges are visible and not strongly influenced by noise. This is not true for the two-dimensional variant. The more gates and the resulting errors make edge detection difficult, especially for the 30 \u00d7 30 House image (see the bottom row in Fig.\u00a016). The number of shots there is not sufficient to handle these errors. With a higher number of shots, like the 32,000, it is possible.\nThe execution time depends linearly on the number of shots. Thus, reducing the number of shots is a good way to reduce execution times. For example, the quantum edge detection with 32,000 shots nearly takes 43 min per job (assuming that 300 circuits can be processed per job), where 1000 shots only require 90 s when using the backend \u2018ibmq_ehningen\u2019. Consequently, with the one-dimensional\nQuantum Machine Intelligence (2022) 4:15\n1 3\nquantum edge detector, more jobs can be executed in the same time interval with usually better results as shown for example in Fig.\u00a016."
        },
        {
            "heading": "4.4 Improved quantum edge detection with\u00a01D mask",
            "text": "Table\u00a04 summarizes the six variants of the one-dimensional quantum edge detector. For the comparison, we take a 30 \u00d7 30 gray value image as reference and assume that 300 circuits can be executed per job on the real backends. This was the case for IBM\u2019s advanced backends in December 2021.\nThe six methods differ in the number of shots, in the number of qubits, the number of circuits, and therefore also in the number of jobs, which have to be submitted to IBM. As a consequence, the execution time on the real backends varies for the six variants, too. We see a slightly bigger reduction of the execution time when using only 50 shots instead of 32,000 due to the linear correlation of the number of shots and the execution time (Asfaw et\u00a0al. 2021). Using Seq50\u00a0 or Para50, we decrease the number of jobs by a factor of three so also the execution time approximately decreases by\nthat factor. Furthermore, the fewer circuits/jobs explain why Para50_3pix\u00a0 and SeqPara50\u00a0 need even less time.\nTo compare the results of the six variant qualitatively, we use the Hellinger fidelity as defined in Section\u00a02.4.3. Figure\u00a017 contains boxplots of the fidelities for five backends.\nThe backends used in our study have more qubits than required for the six variants (see Fig.\u00a09 and Table\u00a04). There are several strategies to select the qubits, such as the qubits with the lowest CX\u00a0errors or the qubits with a large connectivity to other qubits, to avoid additional SWAP-gates. Since we apply only one qubit operations, we select the qubits with the lowest readout error.\nNote that measurement error mitigation or alternatives like zero noise extrapolation (LaRose et\u00a0al. 2020) are often used to reduce the errors of qubits and gates. In contrast to our previous work (Geng et\u00a0al. 2021), the exact probability of measuring a particular state is not required here. We apply a threshold to the resulting probabilities such that we can handle some noise in the calculations. Therefore we refrained from applying error mitigation.\nAll of the backends perform quite similarly, except for the newly released backend \u2018ibm_washington\u2019. One reason for this could be the release date right before the executions. For older backends, possible bugs have been discovered, whereas this may not yet be the case for \u2018ibm_washington\u2019. However, the improvement of the systems and especially of the newer systems is an ongoing process. Quantum computers get more stable and less error-prone with calibrations and adjustments. So, better results can be expected now already.\nThanks to our method\u2019s robustness with respect to noise, even the low fidelity results from \u2018ibm_washington\u2019 are completely interpretable. See Fig.\u00a018 for the outcomes of SeqPara50\u00a0 before and after applying a threshold. Some noise effects are visible for example in the background in Fig.\u00a018a with slightly higher gray values than expected. However, the foreground and background still differ sufficiently. Figure\u00a018c shows the detected edges by using the worst case of SeqPara50\u00a0 and \u2018ibm_washington\u2019 backend,\nPage 13 of 16 15\n1 3\nafter applying an Otsu threshold. All edge pixels are detected even with the worst result of all experiments.\nAs expected, Std32T\u00a0 features the highest fidelity due to the high number of shots decreasing the effect of the finitesampling shot noise.\nFor the last five variants, we observe only slightly worse results and more variation in the results for Para50_3pix\u00a0 and SeqPara50. A reason for that is the higher amount of measurements per circuit. We need 9 and 12 measurements per circuit for Para50_3pix\u00a0 and SeqPara50, respectively. This increases the error per circuit and decreases the fidelity at the end."
        },
        {
            "heading": "4.5 Larger images",
            "text": "The advantage of our hybrid method is that for larger images the method itself and thus the basic errors remain the same. We create more circuits while keeping the size of the circuits the same. Therefore, our method is beneficial for practical usage in the current NISQ era. The House image with its original size of 256 \u00d7 256 and the corresponding results are shown in Fig.\u00a019. Due to the findings from Section\u00a04.3, we exemplary use the one-dimensional variant Seq50.\nThe simulator and the backend outcomes differ only minimally, and the edges of the house are recognizable. This low noise error is mainly due to the very short quantum circuits. Thus, we can detect edges in arbitrarily large images with the current backends in today\u2019s NISQ era.\nDue to the limitations in the maximal number of circuits (exploratory and advanced 300, core 900, and open backends 100 circuits per job at IBM as of November 8, 2021 (IBM 2021)), we split the circuits into several jobs and execute them sequentially. The jobs for the input image patches should be executed as directly consecutively as possible or at least with relatively equal calibrations. Otherwise, calibration variations show in the images, especially for larger quantum circuits with a lot of gates. All six one-dimensional variants turned out to produce similar results. Hence, we only show the outcome of Std50\u00a0 here.\nTheoretically, it is also possible to process the entire 256 \u00d7 256 image in one circuit, e.g., with an extension of SeqPara50. However, the number of measurements per job is currently limited. The exact number is not publicly available, but some own experiments have shown that about 16,000 measurements per job are possible. For 2a \u00d7 2a images, where a \u2208 \u2115 , this means a maximum image size of 64 \u00d7 64 with SeqPara50\u00a0 in one job. For larger images, we split the\nQuantum Machine Intelligence (2022) 4:15\n1 3\nimage into several parts and combine the results of multiple jobs classically afterwards."
        },
        {
            "heading": "5 Conclusion and\u00a0discussion",
            "text": "In this paper, we practically implement a hybrid quantum edge detector in the current NISQ era. Starting from the quantum algorithm for an artificial neuron, we first develop a method that allows us to find edges in a gray value image using two-dimensional filter masks and replace these later by one-dimensional ones. This allows us to significantly reduce the circuit depth, the number of gates, and therefore also the influence of noise. Especially, we do not need any error-prone CX-gates. Due to this improvement, our method detects edges with a number of shots as low as 50. This reduces execution time significantly.\nWe develop four additional variants of the one-dimensional quantum edge detection algorithm to adapt the method for larger images. In these, we consider several directions or pixels sequentially and/or in parallel, which leads to a reduction in the number of circuits. That way, we have to submit fewer jobs and can reduce the execution times further.\nAll the methods discussed in this paper aim at minimizing the error that currently occurs in the context of quantum computing. This allows for very good results with current hardware at the price of a high number of circuits. To reduce it, larger filter masks or a larger step size of the filter masks could be applied. Even padding could be omitted. However, this would deteriorate the results and impede detection of individual edges.\nOf course, we are not limited to the presented variants. For example, we can encode in Seq50\u00a0 more pixels sequentially or extend the idea of Para50_3pix\u00a0 further. Especially, SeqPara50\u00a0 leaves space for customization. There, we use a 2 \u00d7 2 pattern, where two pixels are encoded sequentially and repeat this for a second qubit. Instead of that, we can encode more pixels in one circuit. For example, we can implement a 16 \u00d7 16 pattern. Thus, in each circuit 256 pixels are encoded for all three directions. With that, we only need 256 circuits to encode a 256 \u00d7 256 image like the one in Fig.\u00a019a. The number of circuits is in the range of allowed circuits per job. Thus, we theoretically need only one job on an IBM backend.\nNote that currently the total number of measurements per job is limited. This, for example, restricts the flexibility of SeqPara50\u00a0 as not all pixels of a large image can be encoded in one job. Instead, the results of multiple jobs have to be combined classically afterwards.\nEach of the presented methods solves the quantum edge detection task. Other filtering tasks can be solved, too, by simply adapting the weights of the filter mask. For example,\nwe can adapt the algorithm to enhance, denoise, or blur an image.\nTo summarize, we implement a hybrid edge detector for larger images on a real quantum computer. To our knowledge, this has not been done before. The algorithmic idea based on quantum machine learning can be adapted flexibly to other tasks. This is a clear advantage compared to pure edge detection methods.\nFunding Open Access funding enabled and organized by Projekt DEAL. This work was supported by the project AnQuC-3 of the Competence Center Quantum Computing Rhineland-Palatinate (Germany).\nData availability All the data and simulations that support the findings are available from the corresponding author on request.\nCode availability The jupyter notebooks used in this study are available from the corresponding author on request.\nDeclarations\nCompeting interests The authors declare no competing interests.\nOpen Access This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article's Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article's Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit http:// creat iveco mmons. org/ licen ses/ by/4. 0/."
        }
    ],
    "title": "A hybrid quantum image edge detector for the NISQ era",
    "year": 2022
}