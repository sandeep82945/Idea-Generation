{
    "abstractText": "Optimizing quantum circuits is a key challenge for quantum computing. The PyZX compiler broke new ground by optimizing circuits via the ZX calculus, a powerful graphical alternative to the quantum circuit model. Still, it carries no guarantee of its correctness. To address this, we developed VyZX, a verified ZX-calculus in the Coq proof assistant. VyZX provides two distinct representations of ZX diagrams for ease of programming and proof: A graph-based representation for writing high-level functions on diagrams and a block-based representation for proving ZX diagrams equivalent. Through these two different views, VyZX provides the tools necessary to verify properties and transformations of ZX diagrams. This paper explores the proofs and design choices underlying VyZX and its application and the challenges of verifying a graphical programming language.",
    "authors": [
        {
            "affiliations": [],
            "name": "Adrian Lehmann"
        },
        {
            "affiliations": [],
            "name": "Ben Caldwell"
        },
        {
            "affiliations": [],
            "name": "Robert Rand"
        }
    ],
    "id": "SP:10e93a5eb0c965860dddc3900d03c72c5ba3a74c",
    "references": [
        {
            "authors": [
                "Matthew Amy"
            ],
            "title": "Towards Large-scale Functional Verification of Universal Quantum Circuits",
            "venue": "Electronic Proceedings in Theoretical Computer Science 287,",
            "year": 2019
        },
        {
            "authors": [
                "Miriam Backens",
                "Aleks Kissinger"
            ],
            "title": "ZH: A Complete Graphical Calculus for Quantum Computations Involving Classical Non-linearity",
            "venue": "Electronic Proceedings in Theoretical Computer Science 287,",
            "year": 2019
        },
        {
            "authors": [
                "Miriam Backens",
                "Hector Miller-Bakewell",
                "Giovanni de Felice",
                "Leo Lobski",
                "John van de Wetering"
            ],
            "title": "There and back again: A circuit extraction tale",
            "venue": "Quantum 5,",
            "year": 2021
        },
        {
            "authors": [
                "Niel de Beaudrap",
                "Dominic Horsman"
            ],
            "title": "The ZX calculus is a language for surface code lattice surgery",
            "venue": "Quantum 4,",
            "year": 2020
        },
        {
            "authors": [
                "Bob Coecke",
                "Ross Duncan"
            ],
            "title": "Interacting Quantum Observables",
            "venue": "editors: Automata, Languages and Programming,",
            "year": 2008
        },
        {
            "authors": [
                "Bob Coecke",
                "Ross Duncan"
            ],
            "title": "Interacting quantum observables: categorical algebra and diagrammatics",
            "venue": "New Journal of Physics 13(4),",
            "year": 2011
        },
        {
            "authors": [
                "Bob Coecke",
                "Giovanni de Felice",
                "Konstantinos Meichanetzidis",
                "Alexis Toumi"
            ],
            "title": "Foundations for Near-Term Quantum Natural Language Processing, doi:10.48550/ARXIV.2012.03755",
            "year": 2020
        },
        {
            "authors": [
                "Bob Coecke",
                "Aleks Kissinger"
            ],
            "title": "Picturing Quantum Processes: A First Course in Quantum Theory and Diagrammatic Reasoning",
            "year": 2017
        },
        {
            "authors": [
                "Ross Duncan",
                "Aleks Kissinger",
                "Simon Perdrix",
                "John van de Wetering"
            ],
            "title": "Graph-theoretic Simplification of Quantum Circuits with the ZX-calculus",
            "venue": "Quantum 4,",
            "year": 2020
        },
        {
            "authors": [
                "Kesha Hietala",
                "Robert Rand",
                "Shih-Han Hung",
                "Liyi Li",
                "Michael Hicks"
            ],
            "title": "Proving Quantum Programs Correct",
            "venue": "editors: 12th International Conference on Interactive Theorem Proving (ITP",
            "year": 2021
        },
        {
            "authors": [
                "Kesha Hietala",
                "Robert Rand",
                "Shih-Han Hung",
                "Xiaodi Wu",
                "Michael Hicks"
            ],
            "title": "A Verified Optimizer for Quantum Circuits",
            "venue": "Proc. ACM Program. Lang. 5(POPL),",
            "year": 2021
        },
        {
            "authors": [
                "Dominik Janzing",
                "Pawel Wocjan",
                "Thomas Beth"
            ],
            "title": "Identity check is QMA-complete, doi:10.48550/ARXIV.QUANT-PH/0305050",
            "year": 2003
        },
        {
            "authors": [
                "Aleks Kissinger",
                "John van de Wetering"
            ],
            "title": "PyZX: Large Scale Automated Diagrammatic Reasoning",
            "venue": "In Bob Coecke & Matthew Leifer, editors: Proceedings 16th International Conference on Quantum Physics and Logic,",
            "year": 2020
        },
        {
            "authors": [
                "Aleks Kissinger",
                "John van de Wetering"
            ],
            "title": "Reducing the number of non-Clifford gates in quantum circuits",
            "venue": "Physical Review A 102(2),",
            "year": 2020
        },
        {
            "authors": [
                "Aleks Kissinger",
                "John van de Wetering"
            ],
            "title": "Simulating quantum circuits with ZX-calculus reduced stabiliser decompositions, doi:10.48550/ARXIV.2109.01076",
            "year": 2021
        },
        {
            "authors": [
                "Xavier Leroy"
            ],
            "title": "Formal Verification of a Realistic Compiler",
            "venue": "Commun. ACM 52(7),",
            "year": 2009
        },
        {
            "authors": [
                "Dmitri Maslov"
            ],
            "title": "Reversible logic synthesis benchmarks page. Available at https://reversiblebenchmarks.github.io",
            "year": 2021
        },
        {
            "authors": [
                "Yunseong Nam",
                "Neil J Ross",
                "Yuan Su",
                "Andrew M Childs",
                "Dmitri Maslov"
            ],
            "title": "Automated optimization of large quantum circuits with continuous parameters",
            "venue": "npj Quantum Information",
            "year": 2018
        },
        {
            "authors": [
                "P. Selinger"
            ],
            "title": "A Survey of Graphical Languages for Monoidal Categories. In: New Structures for Physics",
            "year": 2010
        },
        {
            "authors": [
                "Yunong Shi",
                "Runzhou Tao",
                "Xupeng Li",
                "Ali Javadi-Abhari",
                "Andrew W. Cross",
                "Frederic T. Chong",
                "Ronghui Gu"
            ],
            "title": "CertiQ: A Mostly-automated Verification of a Realistic Quantum Compiler, doi:10.48550/ARXIV.1908.08963",
            "year": 2019
        },
        {
            "authors": [
                "Seyon Sivarajah",
                "Silas Dilkes",
                "Alexander Cowtan",
                "Will Simmons",
                "Alec Edgington",
                "Ross Duncan"
            ],
            "title": "t|ket\u3009: a retargetable compiler for NISQ devices",
            "venue": "Quantum Science and Technology",
            "year": 2020
        },
        {
            "authors": [
                "Kaitlin N. Smith",
                "Mitchell A. Thornton"
            ],
            "title": "A Quantum Computational Compiler and Design Tool for Technology-Specific Targets",
            "venue": "Proceedings of the 46th International Symposium on Computer Architecture,",
            "year": 2019
        },
        {
            "authors": [
                "John van de Wetering"
            ],
            "title": "ZX-calculus for the working quantum computer scientist",
            "year": 2020
        },
        {
            "authors": [
                "Mingkuan Xu",
                "Zikun Li",
                "Oded Padon",
                "Sina Lin",
                "Jessica Pointing",
                "Auguste Hirth",
                "Henry Ma",
                "Jens Palsberg",
                "Alex Aiken",
                "Umut A. Acar",
                "Zhihao Jia"
            ],
            "title": "Quartz: Superoptimization of Quantum Circuits (Extended Version), doi:10.48550/ARXIV.2204.09033. Available at https://arxiv.org/abs/2204.09033",
            "year": 2022
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n20 5.\n05 78\n1v 2\n[ qu\nan t-\nph ]\n1 8\nM ay\n2 02\n2\n\u00a9 A. Lehmann, B. Caldwell & R. Rand This work is licensed under the Creative Commons Attribution License.\nVyZX: A Vision for Verifying the ZX Calculus\nAdrian Lehmann* University of Chicago\nadrianlehmann@uchicago.edu\nBen Caldwell* University of Chicago\ncaldwellb@uchicago.edu\nRobert Rand University of Chicago\nrand@uchicago.edu\nOptimizing quantum circuits is a key challenge for quantum computing. The PyZX compiler broke new ground by optimizing circuits via the ZX calculus, a powerful graphical alternative to the quantum circuit model. Still, it carries no guarantee of its correctness. To address this, we developed VyZX, a verified ZX-calculus in the Coq proof assistant. VyZX provides two distinct representations of ZX diagrams for ease of programming and proof: A graph-based representation for writing high-level functions on diagrams and a block-based representation for proving ZX diagrams equivalent. Through these two different views, VyZX provides the tools necessary to verify properties and transformations of ZX diagrams. This paper explores the proofs and design choices underlying VyZX and its application and the challenges of verifying a graphical programming language."
        },
        {
            "heading": "1 Introduction",
            "text": "As quantum computers transition from fiction to a feature of our daily lives, there has been a surge of interest in quantum optimizers [21, 23, 25, 16, 1, 29]. The goal of a quantum optimizer is to reduce the number of bottlenecks in a quantum circuit, whether those be two-qubit gates in the near term or T gates in the longer term. Many of these optimizers do some form of model checking [23, 29] or translation validation [25, 16] to gain confidence that their optimizations are correct, out of awareness that bugs in quantum optimizers are both common and costly [16]. Of particular note, the VOQC compiler [14] is fully verified in the Coq proof assistant, guaranteeing that its optimizations preserve the semantics of the original quantum circuit.\nUnfortunately, the quantum circuit model has many weaknesses, particularly from an optimization perspective. Quantum circuits come equipped with a variety of different gate sets: A good optimizer for the Clifford+T gate set is not guaranteed to perform well on IBM\u2019s gates or Google\u2019s. They are also rigid: They consist of a large sequence of vertically and horizontally ordered gates, whereas an optimizer only cares about the connections between gates. In this spirit, Kissinger and van de Wetering developed PyZX [16], an optimizer for the ZX calculus [5], a graphical language for quantum computing in which only connectivity matters [8]. Like prior tools PyZX checks for correctness by translation validation, either converting diagrams to their underlying linear maps in NumPy and checking if all elements of the linear map are equal up to a global nonzero scalar, or \u201coptimizing\u201d a circuit concatenated with its adjoint, and checking to see if it returns the identity. Unfortunately, these methods are slow and are not guaranteed to succeed as showing circuit equivalence is known to be QMA-complete in the general case [15].\nDrawing inspiration from VOQC and PyZX and the verified classical compiler CompCert [19], we present VyZX, a formalization of the ZX calculus in the Coq [9] proof assistant. VyZX is intended to be a fully verified implementation of the PyZX compiler and a platform for mechanized reasoning about the ZX calculus and related graphical calculi. Given the versatility of the ZX-calculus, VyZX should allow\n* Equal contribution\nus to tackle correctness issues in a range of domains, including lattice surgery [4], circuit simulation [18], and natural language processing [7].\nUnfortunately, while \u201conly connectivity matters\u201d is an excellent slogan for a graphical language, it poses significant challenges for formal verification. Computers do not talk in pictures: Internally, they impose a rigidity akin to that of the circuit model. Even the standard representations of graphs, like adjacency lists and adjacency matrices, are ill-suited to inductive reasoning of the sort Coq excels in. To address this, we formalize two views of ZX diagrams: block representation, in which wires and nodes are composed horizontally and vertically, and graph representation, which is more faithful to the standard representation of ZX diagrams.\nWe explore the motivation for creating VyZX in Section 2. We layout the design decisions underlying VyZX and discuss their potential in Section 3. There we also cover the inductive definition for ZX diagrams, how we apply semantics to them, and how we prove equivalence of two diagrams. We discuss how to convert from standard quantum circuits to our inductive diagrams (Section 3.5) and how we can view our inductive diagrams as graphs (Section 4). We sketch out a path from our current formalization of the ZX calculus to a full-fledged quantum optimizer that is integrated with the VOQC compiler and conclude with the many potential use-cases for VyZX in Section 5. All code referenced in this paper can be found at https://github.com/inQWIRE/VyZX."
        },
        {
            "heading": "2 Verified Optimization and the ZX-Calculus",
            "text": ""
        },
        {
            "heading": "2.1 Verified Optimization",
            "text": "Quantum circuit optimizers take varied approaches to verify that their optimizations are well behaved. Some compilers, such as the one created by Nam et al. [21], solely rely on unit testing to ensure correctness, though unit testing can only show the presence \u2013 not absence \u2013 of bugs. Quantinuum\u2019s t|ket\u3009 [24] goes a step further and uses a Hoare logic system to check that certain postconditions, such as \u201cthe circuit contains no wire swaps\u201d, hold for various optimization passes. This is a useful system for a quantum optimizer to have, but checking that the postcondition holds does not guarantee that the optimization has returned an equivalent circuit to the input circuit. This gap in how we can verify quantum circuit optimizations has been filled by a few other compilers.\nThe quantum compilers CertiQ [23] and Quartz [29] attempt to alleviate this concern by adding systems to check for circuit equivalence. They use these systems throughout their development process to check optimizations. To check equivalence, they generate some proof obligations as SMT formulas and pass them along to Z3. This steps beyond compilers like t|ket\u3009 as it actually attempts to validate the optimization. The key feature of compilers like Quartz and CertiQ is that they automate this validation of optimization passes. While this is a valuable way to make it easy to engineer new optimization passes, it is incomplete. Not every optimization can be verified by an SMT solver, and compilers using such solvers hence include certain optimization without validation. This undermines the validation itself if the entire thing is not validated. If we want to verify the optimizer completely, we need a stronger system that allows us to prove the correctness, not just pass it to an SMT solver.\nThe flaws of existing compilers inspired the development of the VOQC verified compiler [14]. VOQC uses SQIR [13] and QuantumLib [26] to provide a full-stack verification pipeline. All three libraries above are written in the Coq proofs assistant, providing them with strong correctness guarantees. VOQC ingests SQIR circuits from QASM [10], then applies optimization passes that are proven correct at compile time in Coq, and hence do not require any automation as we have seen with CertiQ. Upon completion\nSQIR circuits are converted back into QASM. SQIR can also handle multiple different gate sets, which are related to a base gate set that is used for proof."
        },
        {
            "heading": "2.2 ZX calculus",
            "text": "In contrast to the circuit model used by VOQC and other optimizers, ZX diagrams are a graphical representation of quantum operations. The ZX calculus [6] uses such diagrams together with a set of rewrite rules to manipulate quantum operations. Fundamentally, ZX diagrams are graphs with green and red nodes1, called Z and X spiders, with in inputs and out outputs, along with a rotation angle \u03b1 \u2208 [0,2\u03c0). If the rotation angle is 0 it can be omitted. The semantics of Z spiders and X spiders are shown in Figure 1.\nThese spiders are connected through edges. Edges can either be regular edges or Hadamard edges, which are represented as dotted lines in diagrams and implicitly add a Hadamard gate on their path. These Hadamard edges can be treated as syntax for regular edges with three nodes, see Figure 5. For more on the ZX-calculus, we recommend John van de Wetering\u2019s excellent survey of the topic [27]."
        },
        {
            "heading": "2.3 ZX Calculus Optimization",
            "text": "Our work is inspired by PyZX optimizations, which is based on work by Duncan et al. [11] and Kissinger and van de Wetering [17]. Duncan et al.\u2019s describe how to optimize ZX diagrams with graph-theoretic rules. They begin by outlining a restriction on ZX diagrams, called graph-like form. Such diagrams are restricted to having only one kind of node (the Z spider), one kind of edge (Hadamard edge), no selfloops, and the condition that each node has a unique parent (i.e., either only one input or output). They show that one can freely convert between unrestricted ZX diagrams and graph-like ZX diagrams with equivalent semantics. Using graph-like form, they use graph operations, such as local complementation and pivoting, to reduce the number of Clifford gates (corresponding to nodes containing multiples of \u03c0/2) in their circuits by combining nodes.\nSince the algorithm above does not reduce the number of non-Clifford gates in a circuit, Kissinger and van de Wetering [17] devised an optimization strategy for ZX calculus to reduce the T-gate count, T gates beings the most expensive operations for error-corrected quantum computers. To achieve this, they remove any non-Clifford angles from spiders by splitting them into so-called phase gadgets, as shown in Figure 2. Then, the resulting\nClifford gates are optimized as previously described. Finally, phase gadgets are fused back into the diagram resulting in an optimized diagram. In merging multiple phase gadgets spiders, the phase gadgets themselves can be merged, creating angles that are multiples of \u03c0 2 that can be fused into the Clifford\n1We chose accessible shades of green and red for this paper (see https://zxcalculus.com/accessibility.html)\npart of the diagram, reducing the number of non-Clifford gates. With these optimizations, the ZX-based optimizer PyZX achieves state-of-the-art performance [16] on Maslov\u2019s reversible benchmark suite [20].\nVOQC and PyZX both stand out as significant quantum optimizers for their use of formal verification and the ZX-calculus, respectively. With VyZX, we set out to combine these two ideas into one quantum circuit optimizer."
        },
        {
            "heading": "3 VyZX",
            "text": "In designing VyZX, we wanted to make it easy to write recursive or inductive functions over diagrams. In a proof assistant like Coq, inductive structures allow for inductive proofs. Having the ability to use inductive proofs was a core goal for our definition as it would greatly simplify proofs. For inspiration, we looked at diagrams for symmetric monoidal categories as described by Selinger [22].We reduced the basic requirements for our string diagrams to:\n1. The unit object, which is the empty diagram,\n2. The single wire,\n3. Morphisms, which take n inputs to m outputs,\n4. Braids, which swap two wires,\n5. Sequential composition, which composes two diagrams in sequence , and\n6. Tensor products, which arrange two diagrams in parallel.\nThese core objects give us our base language, consisting of a set of base morphisms, an empty diagram, a way to swap wires around, and the ability to compose diagrams in sequence and parallel. When we wish to apply this to the ZX calculus, we must decide what our language\u2019s signature will be. This signature constitutes the morphisms of our string diagram. For the ZX calculus, a simple signature could include just the Z and X spiders. We also include caps and cups in our signature to make diagrams easier to write, which are standard morphisms for string diagrams. The building blocks for creating string diagrams inductively are given in Figure 3, which we expand upon to build different representations for ZX diagrams."
        },
        {
            "heading": "3.1 Block Representation ZX Diagrams",
            "text": "Our first goal with VyZX is to create diagrams that can be used for proof in Coq. We accomplish this by giving an inductive definition for ZX diagrams. We refer to this representation as block representation ZX diagrams in reference to how they may be stacked together and how stacks can line up with one another. Each ZX diagram holds information about how many inputs and outputs it has, allowing us to define composition in a way that matches the outputs and inputs of two diagrams through a Compose constructor. We also have a Stack operation that places one diagram on top of another. Our base constructors are\nthe Z_Spider, X_Spider, Cap, Cup, Swap, and Empty diagrams. The type of a ZX diagram is given by ZX : N\u2192 N\u2192 Type and the constructors are given by Figure 4 These eight constructors allow us to write simple recursive functions and inductive proofs over ZX diagrams while allowing us to describe arbitrary diagrams. Graphically these constructors correspond to the diagrams seen in Figure 3 with the addition of the Z and X spiders shown in Figure 1.\nWe can view the same ZX diagrams that we describe using block representation not based on their building blocks but instead on nodes\u2019 adjacency. We refer to this view as the graph representation. In the following, we will see how graph representation can be useful for optimization and for proving certain rules. In Section 4 we will discuss how we can convert block representation to graph representation."
        },
        {
            "heading": "3.2 Semantics of diagrams",
            "text": "Given our inductive definition for ZX diagrams, we can write a simple function (Algorithm 1) for computing the semantics of a given ZX diagram. We use the matrix definition given in QuantumLib [26] to compute the semantics. In QuantumLib a matrix is simply a function with type N\u2192 N\u2192 C that takes in a row and column index and returns the associated complex number. First, we define the Z and X spider semantics, as stated in Section 2.2, letting \u00d7 be matrix multiplication2 , Im\u00d7n be the m by n identity matrix, H be the Hadamard matrix, \u2297 the Kronecker product, and H\u2297n be the nth power of H with the Kronecker product. With spider semantics complete, we define our other base constructors, stacks and composes using the Kronecker and matrix products."
        },
        {
            "heading": "3.3 Proportionality of diagrams",
            "text": "Trivially two syntactically equal diagrams are to be considered equal. For making useful statements, however, we require a notion of semantic equivalence. Intuitively, one might define that as equivalence of matrices produced by ZX_semantics (as shown in Algorithm 1). In the ZX calculus, though, we only care about equivalence up to multiplication by a constant factor, as rules will introduce constant factors and we are able to rebuild any constant factor if necessary using ZX constructions [27].\nWithin VyZX we define a relation called proportional and give it the notation \u221d. We say zx1 \u221d zx2 if there is a non-zero complex number c such that ZX_semantics zx1 = c\u2217 ZX_semantics zx2. We prove that \u221d is an equivalence relation as we might expect. We then prove that our composition operators respect proportionality: That is, if zx1 \u221d zx \u2032 1 and zx2 \u221d zx \u2032 2 then Compose zx1 zx2 \u221d Compose zx \u2032 1 zx \u2032 2 and Stack zx1 zx2 \u221d Stack zx \u2032 1 zx \u2032 2. We add this fact to Coq as a parametric morphism, allowing us to rewrite using our equivalences even inside a broader diagram. With proportionality defined, we proceed to verify different rewrite rules within the ZX calculus by proving their diagrams to be proportional.\n2We chose to align our notation with QuantumLib rather than mathematical convention\nAlgorithm 1 ZX Diagram Semantics\nfunction Z_SPIDER_SEMANTICS(in, out, \u03b1)\nreturn\n\n     \n1 0 \u00b7 \u00b7 \u00b7 0 0 0 0 \u00b7 \u00b7 \u00b7 0 0 . . . . . . . . . 0 0 \u00b7 \u00b7 \u00b7 0 0 0 0 \u00b7 \u00b7 \u00b7 0 ei\u03b1\n\n     \n\u22b2 Equivalent to |0\u3009 \u00b7 \u00b7 \u00b7 |0\u3009 \ufe38 \ufe37\ufe37 \ufe38\nout\n\u30080| \u00b7 \u00b7 \u00b7 \u30080| \ufe38 \ufe37\ufe37 \ufe38\nin\n+ei\u03b1 |1\u3009 \u00b7 \u00b7 \u00b7 |1\u3009 \ufe38 \ufe37\ufe37 \ufe38\nout\n\u30081| \u00b7 \u00b7 \u00b7 \u30081| \ufe38 \ufe37\ufe37 \ufe38\nin\nfunction X_SPIDER_SEMANTICS(in, out, \u03b1) return H\u2297out \u00d7 Z_SPIDER_SEMANTICS(in, out, \u03b1) \u00d7 H\u2297in \u22b2 Equivalent to |+\u3009 \u00b7 \u00b7 \u00b7 |+\u3009\n\ufe38 \ufe37\ufe37 \ufe38 out\n\u3008+| \u00b7 \u00b7 \u00b7 \u3008+| \ufe38 \ufe37\ufe37 \ufe38\nin\n+ei\u03b1 |\u2212\u3009\u00b7 \u00b7 \u00b7 |\u2212\u3009 \ufe38 \ufe37\ufe37 \ufe38\nout\n\u3008\u2212| \u00b7 \u00b7 \u00b7 \u3008\u2212| \ufe38 \ufe37\ufe37 \ufe38\nin\nfunction ZX_SEMANTICS(zx : ZX in out) : Cin\u00d7out\nswitch zx do\ncase Empty\nreturn I1\u00d71\ncase Swap\nreturn\n\n   1,0,0,0 0,0,1,0 0,1,0,0 0,0,0,1\n\n  \ncase Cap\nreturn [ 1,0,0,1 ]T\ncase Cup\nreturn [ 1,0,0,1 ]\ncase Z_Spider in out \u03b1 return Z_SPIDER_SEMANTICS(in, out, \u03b1) case X_Spider in, out \u03b1 return X_SPIDER_SEMANTICS(in, out, \u03b1) case Stack zx1 zx2\nreturn ZX_SEMANTICS(zx1)\u2297 ZX_SEMANTICS(zx2)\ncase Compose zx1 zx2\nreturn ZX_SEMANTICS(zx2)\u00d7 ZX_SEMANTICS(zx1)"
        },
        {
            "heading": "3.4 Proving the Correctness of the ZX-Calculus",
            "text": "We can now show the rules to manipulate and simplify VyZX diagrams. For readability, we show most rules in graph representation.\nCommon gates We translated common gates from the circuit model to the ZX-calculus and proved their semantic correctness, shown in Figure 5.\nStack & Compose distribute Sequential composition and stacking distribute as long as the individual diagrams have compatible dimensions by the rules stated in Section 3.1. Figure 6 shows this property visually. This fact is central to proving statements in block representation as it enables the diagram\u2019s structure to be changed while keeping the components the same.\nBi-Hadamard color changing We define a colorswapped ZX diagram as a ZX diagram with the same structure but with all Z spiders being replaced by X spiders (while keeping the angle) and vice versa; all other constructions such as Cap, Cup, and Swap do not change [8]. Henceforth, we denote the color-swapped version of a ZX diagram zx as \u2299zx. For a given spider, one can swap the spider\u2019s color while keeping the angle by composing a stack of Hadamards to the in and outputs. This \u201cbi-Hadamard\u201d construction is shown in Figure 7a. Further, we see this holds for all other noncompositional ZX diagram components (SWAPs, Caps, and Cups) since they do not have color and do not cause\nroration.We go on to show that, in fact, the bi-Hadamard rule is true for all color swapped ZX diagrams, as shown in Figure 7b.\nColor swapping Using the previous fact about bi-Hadamard constructions, we prove that if a rule can be applied to a ZX diagram zx1 transforming it into zx2, then it can be applied to the color swapped diagram of zx1 transforming it into the color swapped diagram of zx2. With this fact in mind, we only show one color configuration for any rule, understanding that it applies to the color-swapped version. In practice, this allows us to prove any rule only for one color configuration and get the color-swapped lemma for free. Since many proofs are computationally expensive, this greatly speeds up verification.\n\u221d\nBi-algebra rule The bialgebra rule, while not intuitive, is crucial for many ZX proofs as it allows for the rearranging of edges between nodes [27]. Unlike the rules we have so far, it requires proof at matrix level and hence has a computationally expensive proof. Though, once proven, it can be repeatedly applied, and given it rearranges edges can be used to prove many future facts.\n\u221d Hopf rule The Hopf rule, like the bialgebra rule, deals with the interaction between Z and X spiders. It says that two edges between an X and a Z spider can be removed. Intuitively, this tells us that no matter how much \u201cinformation\u201d we know about the X basis, given by our input, we do not get any information about the orthogonal Z basis [27]. In practice, the Hopf rule allows us to disconnect specific nodes in the diagram instead of changing their connection. As with the bi-algebra rule, this rule is proven directly on\nmatrices and requires computation, though since the intermediate matrices are smaller this proof is less computationally expensive.\n\u2212\u03b1 ..... .\n\u03c0\n\u03c0\n\u03c0\u03c0\n\u03c0\n\u03c0\n\u03b1 .....\n. \u221d\nBi-\u03c0 rule Any X spider is equal to itself, surrounded by Z rotations by \u03c0 . Intuitively this rule is true due to the orthogonal nature of the X and Z basis and the fact that we are performing in total a full rotation. A corollary of this rule is the \u03c0-copy rule [27] as shown and derived in the figure on the right. The \u03c0-copy rule is not yet implemented, given it semantically builds on adjacency rather than a block like construction, since any input or output could be the one with the \u03c0 spider on it. Generally speaking, rules that modify an arbitrary subset of the inputs and outputs are hard to represent in block representation and are left to be proven in for graph representation. Since the \u03c0-copy rule is what is usually presented in the literature, the bi-\u03c0 is an interesting case study of a rule tailored to block representation that is equivalent to a more traditional rule.\nSpider fusion/splitting One of the most important rules is that spiders connected by an arbitrary (nonzero) number of edges can be fused into a single node with the angles added [27]. This rule is shown in Figure 9a. Further, the reverse is true: any spider can be split such that the two new spiders add to the original angle. A corollary of this is that we can split phasegadgets (as discussed in Section 2.3) off nodes.\nSince this rule fundamentally works based on adjacency rather than block representation construction, we have not fully implemented it at the time of writing. We plan to follow with the general fusion rule, using the graph representation described in Section 4. We do, however, have a restricted version proven where two nodes are just connected to each other by a single wire,\nwhich will form the basis of the general spider fusion proof. Figure 9b shows this restricted version. We implemented this by using the bra-ket semantics of spiders, as shown in Figure 1, instead of the direct matrix semantics shown in Algorithm 1. This allows us to use QuantumLib\u2019s algebraic rewrites of complex matrices to combine the angles easily and shows why having both versions of our semantics is valuable for proof. Given the algebraic rewrite this rule is computationally very efficient."
        },
        {
            "heading": "3.5 SQIR Ingestion",
            "text": "We want VyZX to be able to ingest arbitrary circuits. To achieve this, VyZX reads in circuits written in SQIR, an intermediate representation for the VOQC compiler embedded in Coq. By choosing SQIR\nwe maintain interoperability with another verified compiler. SQIR represents circuits with q qubits as compositions of arbitrary x,y,z rotations acting on qubit n and CNOTs between arbitrary qubits n,m, so this transformation and its verification is not trivial.\nCircuit ingestion works by using arbitrary swaps, meaning instead of only having swap gates that swap two adjacent qubits, we have swap gates able to swap arbitrary two qubits3. To construct an arbitrary swap, we first build a construction to shift qubit 1 to n, whereby all other qubits are shifted up. We also build the inverse (i.e., shifting qubit n to 1). Figure 10a shows this construction. With this we can easily construct our arbitrary SWAP gate (shift 1 to n, then n\u2212 1 to 1). The discussion below will be in block representation that has defined swaps (see sec Section 3.1) of two adjacent qubits as the composition of 3 CNOTs.\nUsing arbitrary swaps and shifts, we can now interpret any wire crossing. Hence, in block representation we can construct a CNOT acting on two qubits n,c by swapping one qubit next to the other qubit, applying the CNOT, and swapping back, as shown in Figure 10c. To then convert such a circuit, VyZX converts rotations x,y,z into the con-\nstruction shown in Figure 10b. Composition of SQIR terms is also represented by composition in our block representation IR."
        },
        {
            "heading": "4 Graph Representation",
            "text": "As discussed in Section 3.1, we can view diagrams in both block representation and graph representation. In graph representation, we construct ZX diagrams solely based on node adjacency. This representation brings some interesting properties that will allow us to optimize diagrams or prove further rules (as\n3For the implementation we chose to have an IR with first-class arbitrary swaps that will then be translated into our base\nblock representation IR (preserving semantics) using the following constructions.\nmentioned in Section 3.4). We can see that any graph representation diagram can be deformed arbitrarily, as long as inputs and outputs are kept in order. Figure 11 illustrates this: Here, we see two ZX diagrams equal up to deformation.\nOne of our future goals is to add a graph representation for ZX diagrams, allowing us to act on diagrams.Creating a verified semantics for graph representation remains a work-in-progress since, fundamentally, this requires topologicallysorted graph traversal, which is a hard problem to implement in proof assistants. Further, converting graph representation diagrams into block representation is also challenging; if overcome, we could provide semantics to graph representation in terms of the corresponding block representation diagrams. We devised a method to convert to graph representation, which is a central problem. In the following, we shall outline this conversion.\nBefore converting into graph representation, we convert ZX diagrams into a restricted yet just as universal form; this form is similar to Duncan et al\u2019s [11] graph-like form (as described in Section 2.3), differing only in the existence of selfloops and two or more possible links between spiders. The restrictions are as follows:\n1. Only Hadamard edges 2. Only one type of spider (Z spiders) 3. Every spider has one input and zero to two\noutputs or vice-versa\nRestrictions 1 & 2 are in place to make our graph more conventional (and akin to graph-like diagrams) by having nodes and edges. Restriction 3, however, is in place for ease of proving. To divide up the proofs into logical steps, there are separate intermediate representations that build up all three restrictions. These IRs exist to divide proofs into logical components and are mostly transparent. Developers, however, can choose to use less restricted forms.\nGiven our restricted form, our algorithm proceeds as follows: A procedure numbers all ZX diagram components (i.e. the constructors) with a unique integer. Then it proceeds to number edges of components as follows: Each component with\nn inputs and m outputs will produce a pair of lists sized n and m, where every position in the list indicates the closest fundamental component (spider or cap/cup). A non stacking/composing component with n inputs, m outputs, and node number x will return lists of size n and m, each with all entries being x.\nAlgorithm 2 block representation to graph representation conversion\nfunction NUMBERNODES(zx)\nassignFreshNumber(zx) if zx = Stack zx1 zx2 OR zx = Compose zx1 zx2 then\nNumberInnerNodes(zx1) NumberInnerNodes(zx2)\nfunction NUMBEREDGES(zx)\nif zx = Stack zx1 zx2 then\n(in1, out1) = NumberEdges(zx1) (in2, out2) = NumberEdges(zx2) return (in1 ++ in2), (out1 ++ out2)\nelse if zx = Compose zx1 zx2 then\n(in1, _) = NumberEdges(zx1) (_, out2) = NumberEdges(zx2) return in1, out2\nelse\nreturn NodeNumber(zx), NodeNumber(zx)\nfunction CREATEEDGES(zx)\nif zx = Compose zx1 zx2 then\n(_, out1) = GetEdgeNumbers(zx1) (in2, _) = GetEdgeNumbers(zx2) for ((in, out) \u2208 (out1, in2)) do \u22b2 Note that out1 and in2 have the same length by construction AddEdge(in, out)\nif zx = Compose zx1 zx2 OR Stack zx1 zx2 then\nCreateEdges(zx1) CreateEdges(zx2)\nWhen stacking two diagrams, the procedure concatenates respective lists, and when sequencing di-\nagrams, it carries forward the outer lists. Figure 12 shows an example of this process. It is important to note that we treat caps and cups like spiders at this stage. Once the edge numbering is complete, we will traverse the diagram once more, and at every Compose, we will match the output edge numbers of the left diagram with the input edge numbers of the right diagram and mark each of those as an edge. Looking at our example in Figure 12, we see wires labeled (1,2), (3,2), and (3,4) bridging the main composition. We use the information from the algorithm to infer which inputs/outputs of the diagram are connected to which node by looking at the outermost annotation. So in our example, we see by looking at the outermost labels that input 1 is connected to node 1, input 2 to node 3, output 1 to node 2, and output 2 to node 4. We can then annotate the entire diagram\u2019s inputs and outputs by looking at the outermost labels. Algorithm 2 shows a pseudocode description of these processes."
        },
        {
            "heading": "5 Future Directions",
            "text": ""
        },
        {
            "heading": "5.1 Circuit extraction",
            "text": "Once we have converted our block representation diagrams to graph representation diagrams, we will extract these graph representation diagrams to SQIR circuits. To accomplish this, we plan to follow Backens extraction work [3]. Our systems should allow us to define a notion of gflow. This graphtheoretical property is sufficient for extracting ZX diagrams into circuits, which will be a valuable tool to verify that optimizations do not break extractability. Circuit extraction will complete the core of VyZX as now we will be able to ingest circuits, write functions over them, and extract the circuits back to SQIR.\nOnce we have verified optimizations and extractions, we are able to pursue a couple of interesting projects, including optimization and simulation. As we are sharing base libraries with VOQC, the natural next idea is to integrate VyZX with VOQC properly."
        },
        {
            "heading": "5.2 VOQC integration",
            "text": "Once we complete graph representation conversion and circuit extraction, we plan to build an optimization pass using PyZX-like optimizations, as described in Section 2.3. Instead of building a standalone optimizer, we plan on integrating our work into VOQC. Since we can ingest from (and later extract to) SQIR, we have a common IR that will allow us to have a wholly verified pipeline and interoperate with ease. It will be interesting to see whether non-ZX optimizations combined with ZX optimizations yield a benefit. VOQC has the advantage of a complete interface that allows for pass selection, allowing us to expose the ZX-based optimizations to users. Furthermore, integration into VOQC will allow us to benchmark our optimizer against other state-of-the-art optimizers like PyZX [16] and Quartz [28]."
        },
        {
            "heading": "5.3 The ZH and the ZW Calculi",
            "text": "VyZX\u2019s design is focused exclusively on the ZX calculus, but the principles described here could easily be applied to other similar calculi such as the ZW calculus [12] or ZH calculus [2], which have broad applications to quantum communication the description of quantum oracles, respectively. In fact, block construct diagrams let us easily translate between various graphical calculi. The translation can be verified by Coq by a simple inductive proof over the signature for the calculus and our shared string diagram constructions. It may be of interest to develop additional optimizations based on these different calculi, and a small extension to VyZX could allow such optimizations to be verified. With the different IRs we have right now, we are confident that extensions of the calculus are easy to integrate."
        },
        {
            "heading": "6 Conclusion",
            "text": "VyZX is a formal verification framework for the ZX-calculus. Creating VyZX came with several challenges that are unique to verifying a graphical language. Finding a way to easily assign semantics to a graph is inherently difficult due to traditional graph structures not being idiomatic in proof assistants. Block representation provides an inductive description of a graph that allows for easy proof while preserving the expressiveness that graphs provide. As block representation made it challenging to write diagrams, we developed a graph representation that can act as a way to implement programs over ZX diagrams. With these two views in place, we proved several core ZX diagram equivalences and added circuit ingestion from SQIR. With all these tools in place, we believe VyZX has a future as a basis for writing programs over ZX diagrams. In particular, our next step is to build a verified circuit optimizer in the style of PyZX. The core of VyZX will continue to be improved as we approach new problems in implementing programs such as a verified circuit simulator. We are confident that with VyZX\u2019s evolution, it will provide a robust foundation for future work on the verification of graphical quantum calculi and their applications."
        },
        {
            "heading": "Acknowledgements",
            "text": "This material is based upon work supported by EPiQC, an NSF Expedition in Computing, under Grant No. CCF-1730449 and the Air Force Office of Scientific Research under Grant No. FA95502110051."
        }
    ],
    "title": "VyZX: A Vision for Verifying the ZX Calculus",
    "year": 2022
}