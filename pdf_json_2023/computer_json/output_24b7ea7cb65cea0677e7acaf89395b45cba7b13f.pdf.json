{
    "abstractText": "Programming languages are incredibly versatile, enabling developers to create applications and programs that suit their individual requirements. This article introduces a new language called Cesno, designed from the ground up to offer an advanced, user-friendly, and easy-touse programming environment. Cesno's syntax is similar to other popular languages, making it simple to learn and work with. It incorporates features from other languages, such as syntactic sugar, a built-in library, support for functional programming, object-oriented programming, dynamic typing, a type system, and a variety of function parameters and restrictions. This article will explore the design of Cesno's grammar, provide a brief overview of how Cesno processes and compiles code, and provide examples of what Cesno's code looks like and how it can aid in development. Key Words\u2014Programming Languages, Language Constructs and Features, Multiparadigm languages",
    "authors": [
        {
            "affiliations": [],
            "name": "Ozelot Vanilla"
        },
        {
            "affiliations": [],
            "name": "Jingxiang Yu"
        },
        {
            "affiliations": [],
            "name": "Hemn Barzan Abdalla"
        },
        {
            "affiliations": [],
            "name": "Haozhe Cui"
        }
    ],
    "id": "SP:8b2086ad5412a48e30b131b469f0a3ec52d08cb0",
    "references": [
        {
            "authors": [
                "S.K. Misra",
                "P.J. Jalics"
            ],
            "title": "Third-generation versus fourth-generation software development",
            "venue": "IEEE Softw.,",
            "year": 1988
        },
        {
            "authors": [
                "A. Kumar",
                "Supriya. P. Panda"
            ],
            "title": "A Survey: How Python Pitches in IT-World",
            "year": 2019
        },
        {
            "authors": [
                "W. Bugden",
                "A. Alahmar"
            ],
            "title": "Rust: The Programming Language for Safety and Performance",
            "venue": "arXiv, Jun. 11",
            "year": 2022
        },
        {
            "authors": [
                "M. Raghavender Sharma"
            ],
            "title": "A Short Communication on Computer Programming Languages in Modern Era",
            "venue": "Int. J. Comput. Sci. Mob. Comput.,",
            "year": 2020
        },
        {
            "authors": [
                "S. Farshidi",
                "S. Jansen",
                "M. Deldar"
            ],
            "title": "A decision model for programming language ecosystem selection: Seven industry case studies",
            "venue": "Inf. Softw. Technol.,",
            "year": 2021
        },
        {
            "authors": [
                "S. Ortiz"
            ],
            "title": "Computing Trends Lead to New Programming Languages",
            "venue": "Computer, vol. 45,",
            "year": 2012
        },
        {
            "authors": [
                "P. Chakraborty",
                "R. Shahriyar",
                "A. Iqbal"
            ],
            "title": "Empirical Analysis of the Growth and Challenges of New Programming Languages",
            "venue": "IEEE 43rd Annual Computer Software and Applications Conference (COMPSAC), Jul. 2019,",
            "year": 2019
        },
        {
            "authors": [
                "S. Hanenberg",
                "S. Kleinschmager",
                "R. Robbes",
                "\u00c9. Tanter",
                "A. Stefik"
            ],
            "title": "An empirical study on the impact of static typing on software maintainability",
            "venue": "Empir. Softw. Eng.,",
            "year": 2014
        },
        {
            "authors": [
                "X. Jia",
                "H. Dittmer"
            ],
            "title": "Anomaly detection in dynamic programming languages through heuristics based type inference",
            "venue": "Computing Conference,",
            "year": 2017
        },
        {
            "authors": [
                "X. Lu",
                "S.T. Aung",
                "H.H. Sandi Kyaw",
                "N. Funabiki",
                "S.L. Aung",
                "T.T. Soe"
            ],
            "title": "A Study of Grammar-Concept Understanding Problem for C Programming Learning",
            "venue": "IEEE 3rd Global Conference on Life Sciences and Technologies (LifeTech),",
            "year": 2021
        },
        {
            "authors": [
                "J. Bergin",
                "A. Agarwal",
                "K. Agarwal"
            ],
            "title": "Some deficiencies of C++ in teaching CS1 and CS2",
            "venue": "ACM SIGPLAN Not.,",
            "year": 2003
        },
        {
            "authors": [
                "D. Saito",
                "T. Yamaura"
            ],
            "title": "A new approach to Programming Language education for beginners with top-down learning",
            "venue": "Proceedings of 2013 IEEE International Conference on Teaching, Assessment and Learning for Engineering (TALE),",
            "year": 2013
        },
        {
            "authors": [
                "H. Thimbleby"
            ],
            "title": "A critique of Java",
            "venue": "Softw. Pract. Exp., vol. 29, no. 5, pp. 457\u2013 478, Apr. 1999, doi: 10.1002/(SICI)1097-024X",
            "year": 1999
        },
        {
            "authors": [
                "I. Joyner"
            ],
            "title": "C++?? A Critique of C++",
            "year": 1992
        },
        {
            "authors": [
                "A.M. Fard",
                "A. Mesbah"
            ],
            "title": "JSNOSE: Detecting JavaScript Code Smells",
            "venue": "IEEE 13th International Working Conference on Source Code Analysis and Manipulation (SCAM),",
            "year": 2013
        },
        {
            "authors": [
                "P.A. Gardner",
                "S. Maffeis",
                "G.D. Smith"
            ],
            "title": "Towards a program logic for JavaScript",
            "venue": "Proceedings of the 39th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages,",
            "year": 2012
        },
        {
            "authors": [
                "CPP Reference"
            ],
            "title": "Initialization",
            "venue": "CPP Reference. https://en.cppreference.com/w/cpp/language/initialization ",
            "year": 2023
        },
        {
            "authors": [
                "G. Shu-yu"
            ],
            "title": "Michael Ficarra",
            "venue": "and Kevin Gibbons, \u2018Automatic Semicolon Insertion\u2019, ECMAScript\u00ae 2023 Language Specification. https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-automatic-semicolon-insertion ",
            "year": 2022
        },
        {
            "authors": [
                "T. Gamblin"
            ],
            "title": "std::string length() and size() member functions",
            "venue": "May 25",
            "year": 2009
        },
        {
            "authors": [
                "N. Ogura",
                "S. Matsumoto",
                "H. Hata",
                "S. Kusumoto"
            ],
            "title": "Bring your own coding style",
            "venue": "IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER),",
            "year": 2018
        },
        {
            "authors": [
                "I. Moreira Medeiros Gomes",
                "D. Coutinho",
                "M. Schots"
            ],
            "title": "No Accounting for Taste: Supporting Developers",
            "venue": "Individual Choices of Coding Styles\u2019, in 2019 19th International Working Conference on Source Code Analysis and Manipulation (SCAM),",
            "year": 2019
        },
        {
            "authors": [
                "D. Spinellis"
            ],
            "title": "Choosing a programming language",
            "venue": "IEEE Softw.,",
            "year": 2006
        },
        {
            "authors": [
                "D. Naiditch"
            ],
            "title": "Selecting a programming language for your project\u2019, in 17th DASC. AIAA/IEEE/SAE",
            "venue": "Digital Avionics Systems Conference. Proceedings (Cat. No.98CH36267),",
            "year": 1998
        }
    ],
    "sections": [
        {
            "text": "tile, enabling developers to create applications and programs that suit their individual requirements. This article introduces a new language called Cesno, designed from the ground up to offer an advanced, user-friendly, and easy-touse programming environment. Cesno's syntax is similar to other popular languages, making it simple to learn and work with. It incorporates features from other languages, such as syntactic sugar, a built-in library, support for functional programming, object-oriented programming, dynamic typing, a type system, and a variety of function parameters and restrictions. This article will explore the design of Cesno's grammar, provide a brief overview of how Cesno processes and compiles code, and provide examples of what Cesno's code looks like and how it can aid in development.\nKey Words\u2014Programming Languages, Language Con-\nstructs and Features, Multiparadigm languages"
        },
        {
            "heading": "1 INTRODUCTION",
            "text": "Programming is the process of utilizing logic to execute specific tasks and functions on computers. These logical operations are implemented by means of specific programming languages, which comprise a set of instructions and commands written in a distinct manner to create a unique program and direct the computer to execute it. Programming languages also regulate the way electronic devices communicate with each other, such as robots and peripheral devices like printers and other smart devices, as well as permitting humans to communicate with machines. Even though various programming languages share many similarities, each language has its own distinct structure and a specific set of keywords to develop a certain program.\nAlso, a programming language is a set of commands written according to a set of rules determined by the language itself. These commands go through several stages before being executed on a computer. Programming languages are divided based on their proximity to human language into high-level languages (closer to the language humans understand) such as C and Java, and low-level languages (closer to machine language, such as Assembly language). Some languages are designed to work on specific devices, such as a computer or a central processor\n(CPU). In these cases, the company that produces the device provides a user manual that includes the commands that can be executed on it. Other more general languages, such as Java, work independently of the type of machine, working within a virtual machine.\nDrafting, Syntax in programming languages are rules that define the correct way of writing symbols and vocabulary within a program based on the language used. There are specific symbols and reserved words for each language, such as the word \u201cIF\u201d, which is used in a specific way. Some languages consider the use of lowercase letters similar to the use of uppercase letters, while other languages are the opposite. Semantics refers to the correct usage of symbols and vocabulary to form a code sentence in accordance with the Syntax rules. Usually, these sentences are executed sequentially, and the sentence being performed at the moment is valid. Types are data that have specific properties that are checked by the compiler, and an error is shown if a form of data is assigned to an incorrect type. Static type checking and dynamic type checking are two methods of examining types. Libraries are collections of utilities and properties provided in a language for program development. Previously, libraries weren't seen as an essential part of languages, but with their tremendous development, using these helpful tools for writing more efficient programs has become a necessity."
        },
        {
            "heading": "1.1 Programming Languages Features",
            "text": "A programming language is a means of facilitating a programmer to write their program in a form of instructions and commands that a computer can understand in order to carry out a task. It is known that the computer translates the programming language into bits of 0 and 1, and then proceeds with its work. To compose commands, the selected programming language provides a set of basic building blocks for creating a program, as well as a set of rules for handling and organizing data to execute the desired task."
        },
        {
            "heading": "1.1.1 Information and Storage",
            "text": "Today's digital devices store information in the form of numbers according to the binary number system (i.e. based on 0 and 1). Generally, modern processors do not deal with a single bit, but rather with groups of bits, such as 8 bits (1 byte, the smallest unit of information in modern computers), 16, 32, 64, 128, 256, or 512 bits. For instance, 8 bits can form 256 different values, which can range from 0 to 255. The purpose of programming languages is to use a unit or group of units (symbols) to encode real-world\nar X\niv :2\n3 0\n3 .1\n5 7 5 0\nv 1 [\ncs .S\ninformation, such as names, measurements, or bank account numbers."
        },
        {
            "heading": "1.1.2 Commands and the Organization of their Functioning",
            "text": "The programmer performs operations on information units such as storing, reading, and comparing them. Furthermore, arithmetic operations can be performed on them, as dictated by the rules of the language. This language also enables the process of selection and branching, based on a logical condition, which the computer uses to choose the direction of the work. For example, if a program is written to divide two numbers chosen by the user, and display the result on the screen, a condition must be added that does not allow for division by zero. If the denominator is zero, the program should not perform the operation, but rather alert the user that they have attempted to divide by zero. Additionally, the language is capable of organizing orders in a way that allows for repetitions of a single operation or a group of operations in a loop. This is done in order to divide the work into parts that are easy to work on independently."
        },
        {
            "heading": "1.1.3 Special Design",
            "text": "Each language has its own specific design for handling data and the methods and tools that it offers to tackle a particular problem. Programming languages can be categorized according to the way programs are structured: procedural languages (e.g. Basic, Fortran) are sequential languages, where the basis of their structure is the process required to operate on data and variables. On the other hand, object languages (such as C, Java, Delphi) are non-sequential and depend on the elements and variables within the program to be transformed by applying certain procedures to them."
        },
        {
            "heading": "1.2 Programming Languages Common Feature",
            "text": ""
        },
        {
            "heading": "1.2.1 Elements of Programming Languages",
            "text": "The syntax of a programming language is defined as the set of rules that determine how to correctly write vocabulary and symbols according to the language used. Each programming language has its own set of reserved words and symbols, such as the word IF, which must be used in a specific way. It is also important to note that different programming languages may treat the use of uppercase and lowercase letters differently while writing code.\nSemantics, on the other hand, refer to how symbols and vocabulary are correctly used to form a valid programming statement according to the syntax rules of the language. These programming statements are usually executed sequentially, meaning that the next statement is not executed unless the current statement is evaluated to be true.\nTypes are also an important aspect of programming languages,\nas they define the data that should be used in a certain way by the programmer. Any type used in a program has specific properties that are checked by the compiler, and an error is raised if a type of data is assigned to a type that does not match it. This process of data type checking is done using two methods: static type checking and dynamic type checking. Furthermore, libraries are now seen as an important part of programming languages, as they enable developers to write better programs."
        },
        {
            "heading": "1.2.2 Types of Programming Languages",
            "text": "Machine language is the most basic level of programming languages, dealing directly with the machine through a binary data system of 0s and 1s. This type of language is difficult for humans to understand and work with directly, thus requiring special programs to be included in different operating systems which convert programs written by humans into machine language.\nHigh-level languages are designed for humans to interact with,\nas they contain commands consisting of symbols and text that are intuitive to the user. These symbols and vocabulary are typically written in a style that is close to English. High-level languages vary greatly according to the purpose for which they are intended.\nAssembly language is used to translate high-level programming languages, written by programmers, into lower-level languages that are understandable by the machine. Assembly language is very similar to machine language and can be read by humans, though it is still dependent on the machine for execution."
        },
        {
            "heading": "1.2.3 Characteristics of Programming Languages",
            "text": "Simplicity: Programming languages must enjoy simplicity and smoothness that enables user to deal with them efficiently.\nEfficiency: Programming languages must have the ability to work very efficiently on devices; This is when the programming language does not require much time to run and does not require a lot of storage space on the devices.\nStructure: Programming languages must allow user to write their programs according to well-known and structured programming concepts.\nEase of detecting errors: Programming languages must have a way to check the errors that the programmer may encounter when writing a specific program using that language.\nPortability: The programming language must be portable; In the sense that the program that is written with it can be transferred from one computer to another."
        },
        {
            "heading": "1.2.4 Examples of Programming Languages",
            "text": "C++: This language is a development of the language (C), and features have been added to it that made it an object-oriented language. This language is used in the development of various software and games.\nJava: It is an object-oriented language that relies on templates (English: Classes). The Java language appeared in the nineties of the last century, and it is one of the most requested languages. It can be used in software development, web content, games, as well as mobile applications.\nC#: It is a multi-use language developed by Microsoft, which integrates the features of C and C++, and can be used to develop Windows operating system software.\nJavaScript: is a language supported by many web browsers that enable a programmer to add animations and interactive media to web content.\nPython: is a high-level language used to develop server-side scripting via websites or mobile applications and is characterized by simplicity and ease of reading."
        },
        {
            "heading": "2 RELATED WORKS",
            "text": ""
        },
        {
            "heading": "2.1 Development of Programming Languages",
            "text": "The development of programming languages has been ongoing since the first computer programming language was developed\nin the 1950s. Since then, numerous programming languages have been created, improved and adopted for various purposes. Early programming languages such as FORTRAN and COBOL were developed to facilitate scientific computing and business applications; compared to assembly language, they get rid of the limitation of different architecture (become architecture independent) and have a more human-readable syntax design [1]. Later, more complex languages such as Pascal, C++ and Java were created to provide more powerful programmability and provide support for object-oriented programming. In recent years, numerous new programming languages have emerged, such as Python, Ruby, Rust, and Go. These languages have been designed to enable developers to create robust applications while also making development faster and easier [2], [3]. The development of programming languages continues to evolve with the emergence of new technologies and trends. For example, popular languages such as JavaScript are being used to create web applications, while languages such as Swift are being used to develop mobile applications. Furthermore, the development of programming languages has been greatly aided by the availability of powerful tools and libraries. These tools and libraries make it easier to develop applications in a variety of languages, while also providing support for popular frameworks such as React and Angular. The trend of programming languages is to make it easy to learn [4], develop and maintain, and let the people not in IT have a chance to program [1].\nAlthough there are many programming languages, not all of them can be well known over decades [5]. New programming languages emerge to meet the new requirements and platform [6], [7], but new languages may lack features which are available in the previous programming languages, and people need time to get familiar with new languages [7].\nMost programming languages can be divided into static and dynamic type systems. For example, Rust or C++ use static type, while Python or TypeScript use dynamic one. Software developers may choose static typing because of its reliability of higher maintainability [8]. However, there are also arguments that declaring static type may be time consuming and hard to change return type [8]. In contrast, with easy but clear syntax, dynamic typing can also help developers to write less and have higher productivity [9]. To combine the advantages of both, some programming languages like Groovy provide both of them [9].\nProgramming language design should also focus on the educational aspect, such as the cost of learning, and friendliness to non-programmer . A paper which introduced a graphical language [10] suggested that programming should be interesting, and be able to let people get some skills of programming even if they may not be programmers."
        },
        {
            "heading": "2.2 Some Drawbacks of Existing Programming Languages",
            "text": "People may be confused by the formality of writing code in some programming language [11]. Java is an object-oriented programming language, and it forces to write content like \u201cpublic class\u201d and \u201cpublic static void main\u201d for every program, even though the program might only print \u201cHello World\u201d in the console, with no argument received and used. C and C++ also need to include header files even for standard input and output [12], or perform the power function.\nWhen it comes to learning, current programming languages\nmay not be easy for first-time learners \u2013 some people might misunderstand some concepts if they learn by \u201clooking at sample code\u201d and then \u201ctry to find rules and combine the function\u201d mode (top-down approach) [13]. But for the bottom-up approach (first learn grammar, then apply), a C program includes too many concepts such as usage of \u201c&\u201d and \u201c%d\u201d for getting standard input. Also, C or C++ may discourage first time by implicit type convention, different behaviour on different compilers, or out-ofbound array indexes [12], and it is designed to be fit for experienced programmers, but not guaranteed to be simple and reliable [14].\nProgramming languages may offer some features with confusing form. For example, the operator \u201csizeof\u201d in C++. Although it looks like a function call, the compiler will substitute it while compiling. For example, \u201csizeof(i++)\u201d equals to 4 if \u201ci\u201d is an integer. However, calculation \u201ci++\u201d isn\u2019t executed. Because the compiler just simply checks the variable\u2019s type and puts a number on there. The directive \u201c#include\u201d in C++ can be also a burden for programmers. To make a class usable in one file, user must use \u201c#include\u201d to import them. While other programming languages had already moved to the module system, C++ maintained this 30 years old technique for importing [15]. Also, \u201c#include\u201d is malfunctioning when there are two files including each other, or one header file being included twice or more. To overcome these problems, user have to write code such as \u201c#ifdef ANIMAL_CLASS_HEADER\u201d [15] or \u201c#pragma once\u201d, which is not related to the logic and target of programming tasks (that means, these code segments are not ought to exist).\nIn addition, programming languages may offer too many restrictions on expressing, which may cause negative effects, it might be inconsistencies in expressing the same thing under different context, while according to daily logic, it should work. For example, Java only allows the array initialised by literal like \u201c{1, 2, 3}\u201d, and does not allow any other usage of that literal [14]. Also, Java forces users to write import statements on the top of the file, but this restriction may reduce the freedom of importing names only inside one function, which affects the expressiveness [14].\nAlso, Programming languages may lack features to let users write understandable or maintainable code, like JavaScript is based on the dynamic and weakly-typed type system, and it uses prototype as a way of inheritance; these features may confuse programmers and they must learn a lot of features of JavaScript to make the code maintainable [16], or to say, the language itself is too flexible to write or use programs easily in a big project [6], [17]. In JavaScript, the implicit convention of type is common when the operand is not the same type, which may be hard to understand. For example, both \u201c\"3\" == 3\u201d and \u201c3 == \"3\"\u201d returns true; but both \u201c\"true\" == true\u201d and \u201c\"false\" == false\u201d returns false. \u201c\"1n\"\u201d could be parsed to integer using \u201cparseInt\u201d, but \u201c\"1n\"\u201d is neither equal to \u201c1\u201d or \u201c1n\u201d; however, \u201c\"1\" == 1n\u201d is true."
        },
        {
            "heading": "2.3 Goal of Cesno",
            "text": "To solve these problems described in the previous section, the proposed language should have these characteristics: not so heavy to learn to write simple programs, keep consistency and coherency on the design of syntax, allow to code more freely by less restriction and formality, offer proper grammar sugar to make the code efficient and understandable, be able to be non-\ndomain-specified and offer enough features for who need to write high performance and optimised program.\nThe proposed language, Cesno, is aimed to combine the advantages of different programming languages together, while the grammar is not messed-up. Cesno is a C-style programming language, and it borrows a lot of ideas from languages like Python (e.g. handful builtin functions, positional-only and keywordonly-argument), TypeScript (e.g. type manipulation, arrow function, function declaration), and Rust (e.g. evaluate value of structures like match statement, enum member that carries more information). The expected outcome of Cesno will be:\n1. Precise grammar with unified specification. 2. Supporting different paradigms like Object-Oriented and\nFunctional style.\n3. Easy to learn, with convenient feature, without being\nlimited by stereotype.\n4. Ability to adapt for simple or complex usage. 5. Zero cost abstractions. 6. Pay for more memory and speed cost if using extra fea-\ntures.\n7. Open to customization. 8. Not being limited by specific domain, architecture, or\nplatform.\n9. Up-to-date features, learn from others, learn from , learn\nfrom suggestions. Precise grammar with unified specification: means, there is consistency on the symbol, words, or structures in the design of language and its grammar; the grammar does not have ambiguity, and to complete one task, unless the user customised it, there is grammar that has the same style. For example, for initialising instances in C++, excluding the copy initialisation, there are at least three approaches [18]: can use parentheses without equal sign, brace without equal sign (value initialisation or list initialisation), or constructor with equal sign\u2026 To keep the coherence, Cesno suggests using the structure like \u201clet name = RIGHT_VALUE\u201d to initialise, which lower down the cognitive load of remembering different ways of initialising. For similar tasks (e.g. defining function, class, or enum), the grammar will be similar. For one symbol, there is fixed meaning (e.g. \u201c&\u201d is always operator related to combination of something like type or restriction; for bitwise and, there is \u201cbitand\u201d; for logic operation between bools, there is \u201cand\u201d). For one word, it will be allowed to have multiple meaning only if it is natural in human language (e.g. \u201cin\u201d would be used as both operator checking whether something is contained in another thing like \u201c0 in [0, 1, 2, 3]\u201d, or a expected token when doing iteration like \u201cfor n in [0, 1, 2, 3]\u201d), otherwise, a word should only possesses one specified meaning.\nSupporting different paradigms like Object-Oriented and Functional style: means, can utilise different paradigms together, and the popular paradigms are supported in the abstract layer. Those who find inheritance using a prototype is easy to use may also use this paradigm in their program, although the most common practice is using object-oriented paradigm. Functional programming style is also supported by enabling functions to be \u201cfirst-class\u201d in Cesno. This characteristic could be helpful for users to learn and adapt to Cesno if they are used to one paradigm before.\nEasy to learn, with convenient features, without being limited by stereotype: means, Cesno is not necessarily similar or\nsame to existing programming languages, and it has some features to help write code easier. For example, to keep the coherency of variable initialisation, the array-like variable is defined like \u201cint[] a\u201d or \u201cint[3] a\u201d, but not \u201cint a[]\u201d as C++ does. Another example could be to use the structure \u201cfor-thenelse\u201d or \u201cwhile-then-else\u201d. In Python, \u201celse\u201d after \u201cfor\u201d means \u201cdo this code if the for-loop ends normally\u201d. In Cesno, \u201cthen\u201d takes that job, and \u201celse\u201d means \u201cdo this code if the for-loop is interrupted by break\u201d, since \u201celse\u201d gives out a feeling of \u201cprevious part is not done due to some reason\u201d (since there is \u201cif-else\u201d), so Cesno does not follow Python\u2019s design here.\nAbility to adapt for simple or complex usage: means, if users only need the program to perform simple tasks, then learn less; if users need to write complex projects, then users will use some features that help to write high-performance code. For example, if the user only wants to calculate the total lines of files inside one folder, the user can write a script-like program as the example in section \u201cExample of Code\u201d. Users do not need to learn a topic like reference, memory management, or concurrent programming for performing simple tasks, as long as the program does not need high performance and low resource usage.\nZero cost abstractions: means, if some features are only an abstraction of some code that is near to the low-level of the machine, will not suffer from run-time RAM or CPU cost. For example, the \u201cfor-in\u201d loop on an array is an abstraction of the \u201cfori\u201d loop, which would be translated into \u201cfor-i\u201d loop during compilation. \u201cFor-in\u201d loop makes the code easier to read, but does not take extra cost. Also, as what Rust Embedded Book describes, for types that only acts as a marker, it will not exist in run-time [19], Cesno will support it as well. For example, types that contain no member will be zero-width as \u201cvoid\u201d. Pay for more memory and speed cost if using extra features: means, if some features are not only an abstraction, users need to accept the cost of using this. For example, Cesno is based on static type, but it will also provide dynamic type. When users use dynamic type, Cesno will provide it, which is implemented based on static type. It may lead to more memory cost as long as users use dynamic type variables.\nOpen to customization: means, if users do not like the way of writing code, they have a chance to design their own feature, grammar rule or structure. Users can change the code style when writing (this feature needs IDE\u2019s support, proceed by command line tool), create new operator, create new structure (e.g. creating a new keyword \u201cloop\u201d that runs code until breaked), or add function or method to builtin class.\nNot being limited by specific domain, architecture, or platform: means, the language is general purpose, it focuses on (how to represent their logic flow in the code), but not (how to adapt to the current context of programming, and making them think as the machine thinks). If a user writes in C language, the user would consider an array-typed is the pointer pointed to the first element, which is not what people might think in the real world (an array is a list of elements). This kind of thought may also become invalid when moving to a new architecture.\nUp-to-date features, learn from others, learn from , learn from suggestions: means, Cesno will be improved by offering new features, libraries, or functions to keep up to date. Also, Cesno will adapt the feature from other languages, or accept issues provided by (from Cesno\u2019s repository).\nThe code below is an example using Cesno code to perform a\nDec to Hex conversion (not using builtin hex function).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Get the number let num = int( input( // Input prompt, show user what to do \"Please input an integer value in decimal: \", // Check if the input matches the // check condition. // By default, isInteger ratio set to dec, 10 check=s -> s.isInteger(), // If not number, print redo prompt, // then re-run on_fail=#redo( \"This is not a valid integer \" + \"decimal number\\n\" ) ) ) // Build the number // Init the size, and put the add position to end let buf = StringBuffer( init_size=int(log(16, num) + 3), position=#end ) let is_less_than_zero = num < 0 while (num != 0) { buf.appendHead( // The result for this if-else statement // will be char|int // Both are acceptable for this function, // so it works here (let digit = num % 16) > 9 ? 'A'.charAfter(digit - 10) // char type : digit // int type ) num /= 16 } buf.appendHead(\"0x\") // Add minus sign if needed is_less_than_zero ? buf.appendHead(\"-\") : void // Print the result print(\"The result is\", buf)\nThe above code shows what Cesno code looks like. Though it is not the most effective or fastest way of converting (a builtin function hex will do the same job), it shows the basic idea of Cesno code. Below are some descriptions about some features of the above codes.\nFirst, it does not force the user to add a \u201csemicolon\u201d to the end of each line, it will detect the end of the statement like Groovy\u2019s idea \u201cparse how I mean\u201d (that is, if commonly speaking, the user seems to end the statement here, then parse until here). JavaScript uses Automatic Semicolon Insertion [20] to decide whether to insert a semicolon before executing, and sometimes, it is problematic, for example, writing a return statement into two lines. Since Cesno parses code as (expecting needed token until found), this will merely happen in Cesno (like return statement will expect another token after it), and Cesno never forces the user to add semicolons until customize the configuration file for each Cesno project. If users want to end the parsing of the current statement, they can use a semicolon to show the compiler should stop here.\nSecond, useful builtin functions. For example, input checking is required for many situations. Cesno\u2019s input function\u2019s idea comes from Python\u2019s input, showing prompt, and it can also do checking on the input string by providing checking functions or\nregular expressions, with on fail option to handle input\u2019s mismatch. By doing this can reduce the code, and make it easier to read.\nThird, use in-function enumeration but not string as a parameter, which tells the function to finish some tasks using a numberlimited approach. Sometimes, it may be done by letting users use a string to provide the approach, like Python\u2019s Literal type [21]. In Cesno, users do not need to mention the enumerate outside of function. If an enumeration is only used once, it can be \u201cin-line\u201d, which means inside the function, giving the name the same to the parameter like \u201cenum position {start, end, at(int)}\u201d. Users can also define parameters like \u201cposition: enum {start, end, at(int)}\u201d to create it. To assign the parameter with enumeration member, add a hash sign before the member name like \u201c#end\u201d \u2013 it represents the in-line enumeration. Fourth, not being strict on how user should write statements. Unlike some programming languages like Java, which have strict restrictions on the operand of \u201cConditional Operator (\u201c? :\u201d)\u201d. Although it said that conditional operator is shorthand for if statements [22]. In Cesno, there is no such restriction, for example, there is no type restriction for conditional operators, if the type of operand is different, the evaluated type of this statement will be a union type (like which in TypeScript, it is not the union in C language). One reason for having this feature of Cesno is that Cesno\u2019s \u201cusing evaluate to understand the statements\u201d. For example, the \u201clast evaluated value of the last executed statements in control statements\u201d can be the \u201cevaluated value of the whole control statements\u201d, which enables user to make the whole of the control statements as the right value of variable assignment."
        },
        {
            "heading": "3 IMPLEMENTATION MODEL",
            "text": "This part, demonstrate the basic grammar model of Cesno, in addition, an implementation of MCU for the brief basic grammar model will be given."
        },
        {
            "heading": "3.1 Basic Grammar",
            "text": "This part describes the basic design of syntax and components in Cesno. The sections below are categories of statements in Cesno with syntax design and examples for each part."
        },
        {
            "heading": "3.1.1 Components of Cesno Code",
            "text": "This part demonstrates the construction of Cesno code. The code in Cesno is built with the language gadget. Everything in the code can be seen as a language gadget. The smallest language gadget includes the literal, identifier, or punctuation, while the more significant language gadget includes a function or class definition.\nStatement is the grammatically correct combination of several language gadgets, which is one important structure of language gadget. There are mainly three types of statement:\n1. Identifier declaration, assignment, and management. 2. Function or method call. 3. Structure (like if-else in most languages) A statement is also a language gadget, so it can include one or more statements, also. Additionally, a statement may not be functional (that means it can do nothing) \u2013 as long as its grammar is correct, the statement is established. Many language gadgets have expected tokens defined before, and it waits for these tokens to finish the statement.\nThe keywords in Cesno are mostly defined as a language\ngadget, it expects tokens, and become available as a keyword when the expected token is fulfilled. Therefore, function can use the keyword\u2019s name as its name, since the language gadget \u201cfunction\u201d is expecting a name before the parameter\u2019s tuple, and the keyword is not effective in the expectation of \u201cidentifier\u201d.\nIdentifier declaration and assignment: Identifier declaration has type name and identifier only, while assignment has an assignment operator and right value. The following rules of identifier declaration and assignment are as follows. This will make the identifier declared.\n1. MODIFIER TYPE_NAME IDENTIFIER ; 2. IDENTIFIER: MODIFIER TYPE_NAME ; 3. MODIFIER TYPE_NAME IDENTIFIER =\nDEFINITION_WORD EXPECTED_TOKEN ; 4. MODIFIER TYPE_NAME IDENTIFIER\nASSIGNMENT_OPERATOR RIGHT_VALUE ; 5. MODIFIER TYPE_NAME IDENTIFIER\nDEFINITION_BODY ; 6. Shorthand notation, starting with \u201clet\u201d, \u201cconst\u201d, or\n\u201cauto\u201d. For the third rule above, the \u201cDEFINITION_WORD \u201d (which will be talked about later) should be corresponding to the declaring identifier\u2019s type. For the fourth rule, the \u201cASSIGNMENT_OPERATOR\u201d can be \u201c=\u201d (assign), \u201c+=\u201d (plus-assign) or something familiar.\nExample 1: declare variable \u201ca\u201d as a \u201cint\u201d, declare and assign \u201cb\u201d as a \u201cint\u201d with value 10. After that, assign \u201cb\u201d with its value plus 20, and give that value also to \u201ca\u201d.\n1 2 3 int a ; int b = 10 ; a = b += 20 ;\nExample 2: define a function with overload, first one can add an int type variable with 1, second one can add a float type variable with 5. Let the return type be inferred by the return statement.\n1 2 3 4 5 6 7 8 9 function addNumberBasedOnType(int integer_num) { return integer_num + 1 ; } function addNumberBasedOnType(float float_num) { return float_num + 5 ; }\nFunction or method call: It has either function or method (with instance it belongs to) name and a tuple of arguments. This type of statement is usually nested in other statements.\n1. FUNCTION_NAME(ARGUMENTS) ; 2. function(PARAMETERS){ FUNCTION_BODY }\n(ARGUMENTS) ; 3. VARIABLE_OR_TYPE\n.METHOD_OR_FUNCTION_NAME(ARGUMENTS) ; Example: define a function which receives two numbers, and print the sum value. Define a partial function which will print the received value plus one, call it with \u201c1\u201d (partially applied function).\n1 2 3 function addThenShow(int a, int b) { print(a + b) ;\n4 5 6 7 } let printValueAddOne = addThenShow with b = 1 ; printValueAddOne(1) ;\nStructure: It starts with a word which is registered into the compiler (including macro), then it will follow the defined rule to receive the following tokens. It contains two parts \u2013 definition and flow control.\nDefinition comes with a definition word, an identifier\u2019s name and definition body. The definition word is one word that indicates what will be defined (for example, whether you are going to define a class, or an enum). The identifier should be written for the receiving of the definition body. The definition body (which is EXPECTED_TOKEN below), which is the concrete definition offered to the identifier, varies according to the definition word (for example, the definition body of class and function are different). At the end of structure, users can append names for instances, if the previously defined structure can be a type, and users want to create instances with that type immediately.\n1. DEFINITION_WORD IDENTIFIER EXPECTED_TOKEN ; 2. DEFINITION_WORD IDENTIFIER EXPECTED_TOKEN INSTANCE ; 3. DEFINITION_WORD EXPECTED_TOKEN ; Example: define a class \u201cBook\u201d with string member \u201ctitle\u201d and string array member \u201cauthor\u201d, all members are read only. One two parameters constructor for the class.\n1 2 3 4 5 6 7 class Book { readonly string title ; readonly string[] author ; constructor(string title, string[] author) }\nFlow control comes with a flow control keyword (including keyword provided by macro), which changes the running order of code, letting them may not be run from top to bottom. The EXPECTED_TOKEN is the code controlled by the flow control keyword.\n1. FLOW_CONTROL_KEYWORD EXPECTED_TOKEN ; Example: if the code received a value bigger than 10, print a sentence \u201cbigger than 10\u201d; if not, print \u201csmaller or equal to 10\u201d.\n1 2 3 4 5 6 7 8 if (int(input()) > 10) { print(\"bigger than 10\") ; } else { print(\"smaller or equal to 10\") ; }\nIdentifier management: It is the operation that affects the behaviour of the identifier or the functionality behind, including memory management and concurrent processes. For example, import statements define names that refer to the imported package or function, and that defined name (identifier) is not able to be used in the same scope (otherwise there would be name conflict). Another example can be the deletion of the variable, after delete one variable, the memory is freed, as well as the identifier (it can be used again after the deletion).\nExample: delete an int[] variable after definition.\n1 2 int[] a = [10, 20] ; delete a ;\nOther types of statements: It contains statements such as those that can be seen as grammar sugar, user-defined macro, or statements coming from another language. For example, Cesno allow user to create a code block that applied to some modifier as showing below:\n1 2 3 4 5 export { function somethingToExport1() { } ; const something_to_export_2 = 0 ; }\nAbove code, the function and the variable share the same modifier \u201cexport\u201d, so can move them in one code block after \u201cexport\u201d. This feature can also be used in class (e.g. access modifier \u201cpublic\u201d).\nLiterals: Literals are the smallest language gadget in the code, and it is the direct value for representing instance (since Cesno is Object-Oriented, so the int or float are also class).\nLiterals are able to be called methods or functions from, but themselves are constant. The pre-defined literals for Cesno code are in Table 1.\nTABLE 1 PREDEFINED LITERALS\nName Description Example\nNumber Can be used for numeric\ntypes like int or float. There are prefixes for radix, and suffixes for power and type specifiers. It is able to insert underscore (\u201c_\u201d) into numbers to raise the readability. To avoid ambiguity, insert two underscores before the suffix (like 0x1ab.cd_ef__f32). Decimal number 120: 120 Octal number 12 (decimal 10): 0o12 Heximal float (26.8125, 64 bit): 0x1a.d bigint: 12n\nText Characters that represent themselves, but not evaluated as identifiers or some-\nthing else. To represent some special character, escape sequences are used (able to be turned off with prefix). Encoded in UTF8.\nEscape sequence is strictly checked. If an escape sequence does not exist, there will be an error (unlike Python).\nSingle Unicode character: 'U' Another Unicode character: '\ud83d\ude00' Text with escape sequences: \"\\tNo file loaded.\\n\" Raw text: r\"D:\\Windows Style\\Folder\\Path\\\" Template string: `result is ${x - 2}.`\nRegular Expression Cesno follows most of the PCRE style of regular expression (unfollowing PCRE\u2019s rules including\nleftmost rule, ignoring whitespace, match for dot). Contained in two slashes (\u201c/\u201d), cannot be empty. Search \"Hello\": /Hello/ Search \"world\" regardless of case: /world/i Search words means \"regex\" globally, noncapturing for parenthesis: /reg(ular\\s)?exp?(ression)?s?/gn\nTABLE 1 CONT. PREDEFINED LITERALS\nName Description Example\nContainers A basic structure aimed to contain the value in order\nto store/read/process it effectively. Tuple with 2 int and 1 string: (0, 0, \"str\") Array with int: [0, 1, 2, 3] Dict (element with colon separating key and value, each pair separated by comma): {0: \"zero\", 4: \"four\", 2: \"zwei!\"} Set (element with comma separated): {1, 4, 2, 8, 5, 7} {333.3334,} Code Block (semicolon or line break separating statements, last statements may without semicolon or line break): { print(\"some\") ; } { print(\"any\") } { let x = 0 ; print(`${x + 2}`) }\nDefined Symbol\nSymbol with specific meaning. It looks like the member of the enumerator \u2013 by default it is not a variable/constant/value, just a preserved symbol that differs from each other, and available globally. \"true\" value in \"bool\" type: true \"paradox\" value in \"logic\" type: paradox"
        },
        {
            "heading": "3.1.2 Control Statements",
            "text": "For the statement with loop feature, like \u201cfor\u201d, Cesno uses the iteration indicator to indicate the variable used in the loop. Users can use indicators like C style programming: initialise, run-condition, after-loop action ((int i = 0; i < 10; i++)). Also, users can use \u201cin-iterate\u201d to get an pre-defined iterator variable ((let c in \"Hello\") will go through the string character by character, not splitting the ascent). It is also possible to define a new iterator indicator, for example, can define an \u201cof-iterate\u201d like JavaScript.\nUnlike traditional C style programming language, Cesno allows users to define multiple different types of iterator variables at the same time. Each variable used in the loop will go \u201conestep-after\u201d after one iteration. When one of the variables runs out (end in its iteration), it will become undefined in the next iteration. When all variables run out, the iteration will come to an end.\nCesno also allows users to write \u201cbreak indicator\u201d or \u201ccontinue indicator\u201d to break, or continue outer-loop inside inner-loop, avoiding using tags. The indicator will be one of the variables inside of the outer-loop's iteration indicator.\nIt is possible to add \u201cthen\u201d and \u201celse\u201d clauses after a statement with a loop feature. The code in the \u201cthen\u201d clause will run if the loop is not ended by a \u201cbreak\u201d. If so, the code in the \u201celse\u201d clauses will run. The control statement has evaluated value as well, the evaluated value of the last run statement will be that value."
        },
        {
            "heading": "3.1.3 Basic Usage of Operators",
            "text": "This part introduces the basics of operators in Cesno. It is possible to define new operators in Cesno, as long as the new operators are not parenthesis, dot, comma, semicolon.\nElementary arithmetic operators and remainder: Addition (\u201c+\u201d), subtraction (\u201c-\u201d), multiplication (\u201c*\u201d) are working almost the same as mathematics (ignoring overflow, underflow, or precision), while division (\u201c/\u201d) depends on operands\u2019 type. The sign of the remainder's result follows the left operand. If users want to use the modulus operator, it is able to be imported. Increment (\u201c++\u201d) and decrement (\u201c--\u201d) operators are almost the same in other languages which support them (and by default, atomic in Cesno).\nLogical operators and bitwise operators: Unlike most Cstyle languages, Cesno uses \u201cand\u201d, \u201cor\u201d, \u201cnot\u201d, and \u201cxor\u201d for logical operators; also \u201cbitand\u201d, \u201cbitor\u201d, \u201cbitnot\u201d, and \u201cbitxor\u201d for bitwise operators. For bit shifting, Cesno uses \u201cbitshl\u201d and \u201cbitshr\u201d for signed bit shifting, \u201cbitushl\u201d and \u201cbitushr\u201d for unsigned bit shifting.\nValidation operators: This type of operators includes such as equality-checking operators, nullish-checking operators, and type-relation checking operators.\nEquality-checking operators works like most C-style languages, such as \u201c<\u201d, \u201c>\u201d, \u201c<=\u201d, \u201c>=\u201d. Operators \u201c==\u201d and \u201c!=\u201d (by default, it returns \u201cnot\u201d result of \u201c==\u201d) can be defined to test whether two variables are equal or not, while \u201c===\u201d compares if two variables are using the same address. Operator \u201c~=\u201d is only predefined for float numbers, to test the equality approximately (since it is harmful to test two float numbers with \u201c==\u201d, if users try to use \u201c==\u201d to compare the float number, there would be a warning).\nNullish-checking operators test if a variable is null, undefined, or even falsy. Operator \u201c??\u201d tests if the nullable variable before is not null or undefined, while operator \u201c???\u201d also checks if the variable is not falsy. can also define the rule of checking whether a variable is falsy. For example, user can implement trait \u201cHasFalsy\u201d, and define constants like the code below (ImplType refers to the implementer of the trait, can also be written as ImplementerType):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 trait HasFalsy { /** * If test value inside this * (use \"==\" to compare), * it become falsy */ static const $zeros_value: ImplType[] /** If one return true, consider falsy */ static const $zeros_validator: (ImplType -> bool)[] } class StringLike implements HasFalsy { // Just for example. // Suppose we have a constructor // and members already defined... static const HasFalsy::$zeros_value = [StringLike@{value: \"\"}] static const HasFalsy::$zeros_validator = // Arrow function [s -> s.trim().length == 0] } // These assertions should pass. // Check by zero value assert StringLike@{value: \"\"}??? == false // Check by validator assert StringLike@{value: \"\\n\"}??? == false // It is not defined in zero value, // and validator all fail, // So it is not falsy. assert StringLike@{value: \"Not falsy!\"}??? == true\nFrom the above example, it becomes clear that \u201c???\u201d looks like grammar sugar. It can be understood as:\n1 2 3 4 5 6 7 8 9 operator (???)(null|undefined) { return false ; } operator (???)(HasFalsy test) { return not (test in test.HasFalsy::$zeros_value or test.HasFalsy::$zeros_validator .map(f -> f(test)) .reduce(operator::or)) }\nSince some operators are able to be overloaded, operators that are the same in text may have different names and usage. For example, \u201c+\u201d sign can be \u201caddition\u201d or \u201cappend\u201d, depending on the type of the operand. If the operands can be inverted and not affect the final result (commutative), it is \u201caddition\u201d. If the order matters, it is \u201cappend\u201d. This design will be useful to tell the programmers which trait they are implementing, since the code and functionality will be different.\nFor the evaluation of operands and operators (in this case, ignoring operators that have three or more operands, currently,\noriginal Cesno only contains one ternary operator \u201c? :\u201d at now), Cesno will do these in order:\n1. Find if the type of operand (unary) / left operand (binary)\nhas a definition of that operator. For example, left-add\noperator for int: operator (+)(int right). 2. If binary operators, find if type of second operand has\ndefinition of that operator. For example, right-add operator for int: operator right (+)(int left). Cesno always first checks the left hand side, then the right hand side for the binary operator. 3. Find if there is an imported operator that fits the oper-\nand(s). These definitions are not defined inside the type, but defined globally. For example, there is no operator (+) for string and int, but if define that and let this definition available in some scope, it will be able to add\nan int to a string in those scope. 4. Find if the original Cesno has the definition of that oper-\nator. But in most conditions, Cesno already defines operators for the basic types."
        },
        {
            "heading": "3.1.4 Basic Containers",
            "text": "This part introduces the basic containers and its representation. Basic containers are not suggested to be re-defined by the user.\nTuple: Tuple saves one or more non-empty (but nullable) elements as constants. It has a type that combines each type of the element. For example, a tuple \u201c(int, 0, \"s\")\u201d has a \u201c(type, int, string)\u201d type, while a \u201c(0, 0)\u201d has a \u201c(int, int)\u201d type. Unlike a struct, the value in the tuple is not-named, and it is queried using index.\nIf it does not have any element, tuple will be seen as \u201cvoid\u201d typed, and it has only a zero-size \u201cempty\u201d element, which uses no space in the memory.\nArray: The array is a linear container that stores elements continuously, guaranteeing the constant time complexity for searching. It has a type of \u201cValueType[]\u201d (this is the shorthand notation for \u201carray<ValueType>\u201d), and its element must be \u201cValueType\u201d, or can be seen as it, or is one of the \u201cValueType\u201d if it is a union type. Arrays in Cesno are flexible to length, because users can push/pop elements from head to tail. However, it might be time consuming to perform these operations, since arrays need to save the elements sequentially inside the memory.\nList: The list works like an array, it looks like a linear container, but it may not have a constant time for searching the element. List can also push/pop elements from head to tail, but it can be done more efficiently since lists may not store elements in the memory sequentially.\nSequence (or Seq): The Sequence is the fixed-length array in Cesno. It works like an array because they are both linear containers. The sequence type not only contains types of internal elements, but also the length of itself (sequence<type EleType, usize SelfLength>, or EleType[SelfLength] like int[3] for shorthand notation). Hence, the sequence that has different length is not the same type.\nDict (or Dictionary): The Dict saves pairs of keys and values. Keys must be different in the dict, while the values are not. The keys of dict are not guaranteed to be ordered, but there is an ordered version of it. To read the value of dict, use key as the index.\nSet: The container which contains non-repetitive elements.\nSet is not guaranteed to be ordered, but there is an ordered version of set. Set is not indexable, to read every element of set, use iteration. Set has a type that can be seen as a void-typed value dict, with different functions and methods (\u201ctype set<type EleType> = dict<EleType, void>\u201d).\nTo avoid confusion, if a tuple, or a set, only contains one element, users may put a trailing comma like \u201c{0,}\u201d, or use the constructor instead."
        },
        {
            "heading": "3.1.5 Function and Method",
            "text": "Function is a process which accepts some arguments, does some action, and in the most time, gives back some results. Method is similar to function, but it is bound to an instance, able to read or write the instance\u2019s data. Function and method are objects in Cesno, they can be assigned to variables or passed as arguments.\nTo define a function, it needs to write \u201cfunction\u201d first, and write some identifiers\u2019 name for its return type and name, parameter\u2019s tuple, and definition body. It is not forced to write the return type explicitly, since there is type inference.\nFor function declarations, there can be an overload. Functions with different signatures will be seen as different definitions. To make different signatures, different parameter types or limitations for a function can be applied. Like Python [23], it is able to use \u201c/\u201d or \u201c*\u201d to make parameters passed positional-only or keyword-only. Users cannot use \u201ckey with value\u201d to pass value to a positional-only parameter, nor pass value to keyword-only parameter without its key.\nIt is also possible to use \u201cTypeName...\u201d as a variable length type to indicate that the function can receive 0 or more parameters passed as a tuple. Unlike Java, there can be multiple variable length types in one parameter list, as long as the compiler is able to distinguish which argument is passed to which parameter. For example, \u201c(string... texts, int... integers, string str)\u201d is acceptable, since there is an obvious difference of type between the first, second, and the third parameter. \u201c(string... texts, string word, string... strs)\u201d is not suggested because until user use \u201ckey and value\u201d to tell the compiler which value is passed to the second parameter word, the compiler cannot decide how to separate arguments that user has inputted into these parameter; If the parameter word is positional-only ((string... texts, string word, /, string... strs)), this parameter list will not be acceptable, since there is no way to tell the compiler how to separate arguments.\nUsers can also use a question mark like \u201cPARAM?\u201d to show that the parameter may not be passed with value from the user. However, if two functions\u2019 signatures are effectively equal, there would be an error. For example, function signature \u201c(int a, int b = 10)\u201d and \u201c(int a, int b?)\u201d are effectively equal (\u201cint b = 10\u201d is shorthand for \u201cint b? = 10\u201d, or \u201cint b?\u201d with in-function checking-and-assigning).\nThere is a feature called parameter constraint in Cesno, which can help narrowing the argument\u2019s type, check if arguments fulfill some prerequisites, or make the code more elegant. By adding a colon after the parameter name, and writing constrainters concatenated with \u201c&\u201d or \u201c|\u201d (which means \u201cand\u201d and \u201cor\u201d for condition), can narrow the acceptable argument, or check if the precondition is fulfilled. Constrainter is the condition to check with the argument. It can be a modifier check (like if the argument is a constant), a type check (like if the argument is a\nlinear container), or a bool check (like if the argument is bigger than 10). Constrainter helps the compiler check if the argument is problematic as soon as possible. Modifier check and type check can be done statically at the most time, while bool check may also be done before the runtime (given a const expression, constexpr). A mock example for each constraint looks like this:\n1 2 3 4 5 function (Container a: const & Lengthwise & (a.length > 2)) { }\nIn the above example, the argument passed should be a constant, lengthwise, and have a length bigger than 2. If any of them is violated, the compiler would not let it compile. Although the bool constraint may not be working at compile time if a variable is passed, it will be checked before the function runs, and give a ConstraintNotFulfilledError if the argument does not satisfy the constraint.\nIt is the same to write \u201c(int a)\u201d and \u201c(a: int)\u201d in Cesno, since the second representation means \u201can any typed a has an int type constraint\u201d, which is equivalent to the former which means \u201cint typed a\u201d. However, modifiers have different meanings before and after the semicolon. If you want to receive a value as a constant in the function body, you write \u201c(const a)\u201d (like defining variable); if you want the argument to be a constant when passed into the function, you write \u201c(a: const)\u201d to indicate that this function only allows constant to be passed (since there is a modifier constraint).\nThere might be ambiguity for understanding the identifiers between the \u201cfunction\u201d and the parameter\u2019s tuple. If there is no identifier, it is an anonymous function with type inference; if there is one identifier, Cesno will use this identifier as the function's name; if there are two, they should be the return type and function\u2019s name. When users want to create anonymous functions with checking on the return type, they might move the return type afterward, as a constraint for the function:\n1 2 3 4 function(a): returns int, a: int { return a + 1 }\nSince function is an object, it can also be passed as an argument. If a function is passed as argument, there will be an assignability check of functions. For example, an map method of array has a type constraint as follow (\u201c->\u201d is type annotation for function, the tuple before is parameter, and the type after is return type):\n1 2 3 4 5 6 7 method <type MappedType> map( mapper: (element: EleType, index?: int, this_arr?: EleType[]) -> MappedType )\nThis method requires the argument for mapper to be a function, which at least has one parameter element: EleType. If a function like int(value, *, int ratio = 10) constructor is passed, the parameter that is keyword-only will not be seen as the parameter of required mapper. Thus, problems like pass-\ning parseInt to map in JavaScript and getting unexpected results will not happen in Cesno \u2013 as long as the parameter is set to be keyword-only. If users want to change the default value of a keyword-only parameter, they can use \u201cwith\u201d to define a partial function. For example, if users want to map a string array to int, but using ratio equals to 16, users can write [\"0x1\", \"0xE\"].map(int with ratio=16). The statement with \u201cwith\u201d is a shorthand for defining:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // \"with\" works like defining a partial func-tion, // and use it immediately. // \"int with ratio=16\" can be seen as // this function: ( function intConstructorWithRatio(int ra-tio_value) { return function (value) { return int(value, ra-tio=ratio_value) } } )(16) // Which is finally equivalent to this: v -> int(v, ratio=16)\nTo make the user-defined function work with the original Cesno function/method well, parameters that are \u201cnot the most important part\u201d (and works more like a config to function) should better be set to keyword-only. For example, read text from a file. The file path is the most important part, while the encoding is a config that tells the function how the file would be read and understood."
        },
        {
            "heading": "3.1.6 Type and Type Manipulation",
            "text": "This section introduces the idea of type and the operation available on types (type manipulation). The idea of type manipulation borrows a lot from TypeScript or Haskell.\nCesno\u2019s type acts like most other programming languages, it offers the information on how a typed-variable can be used. Type can be seen as a set, or a rule of how data will be constructed. A variable with type A can only be either the member that A has, or the data that follows A\u2019s rule. For example, a variable with type int should follow the rules of int, it can only be an integer inside the int\u2019s range; it is also correct to say that a variable with type int should be one of the members in the set of int, but this way of understanding may be hard for the compiler, to define or understand types allow almost infinity members (e.g. such as real number, string, or complex data structured by class).\nFor the naming convention of types, Cesno uses all lowercase letters for the type that should not be considered a combination of other types. For example, a string type (depending on different implementations on different platforms) will probably be the combination of types that is more \u201cprimitive\u201d, but Cesno does not want users to consider that when coding. If a user wanted to design a \u201crune\u201d class that is the basic character of an artificial language in a game, that user would probably name it like rune. For the type that could be highly considered as a combination of data members, it names using the upper camel case like FireRod (which is probably a combination of value of attack, magic, runes possessed, and cool down time). For generics parameters, use descriptive names in upper camel case, no matter the actual type of\ngenerics, like KeyType (type generics) or ElementSize (integer generics, probably typed as usize).\nBecause type is not necessary to only be the rules, but can also be the set of possible values, a constant like \u201cfalse\u201d or \u201c\"off\"\u201d is also legal to be a type, called literal type \u2013 it describes a set that only contains one element.\nThere are some operators that produce new types from existing types. Operator \u201c|\u201d is used to combine the possible types together to make a new union type; for example, \u201c\"off\"|int|undefined\u201d is a type that allows a string with content \u201coff\u201d, int type, or let the variable to be undefined. Operator \u201c&\u201d is used to get the intersection of the types; if two operands have some same members (variable, function, method), they will be extracted. Operator \u201c+\u201d is used to create a new type that contains two operand types\u2019 members, while operator \u201c-\u201d deletes the member of the second operand, from the first operand. The operand may not strictly follow the name in mathematics, it works more like the operand of list.\nWhen a union type variable is passed to function, each type in the union type will be checked if it is able to be the acceptable type, and the return type will also be the union type of the return types. For example, the operator \u201c??\u201d returns true for type object, and false for null type or undefined type. If operator \u201c??\u201d checks variable with type int|string, it will always return true, since \u201c(returnof operator (??)(object)) | (returnof operator (??)(object))\u201d will be \u201ctrue | true\u201d, and result is \u201ctrue\u201d; if it checks variable with type int|null, it will return \u201c(returnof operator (??)(object)) | (returnof operator (??)(null))\u201d, which is equivalent to bool, \u201ctrue | false\u201d.\nCesno is null-safe (and also undefined-safe). Unless user declared a variable can be null or undefined (e.g. string|null), it is not allowed to assign null or undefined to that variable. Since nullable or undefinable variables are union type, its value cannot be directly used (must use \u201cmatch\u201d, null-undefined coalescing operator \u201c??:\u201d, or other ways to narrow the type).\nFor type conversion, Cesno will not do it implicitly. Statements like \u201cif (10) { }\u201d are illegal in Cesno, since \u201c10\u201d is by default an \u201cint\u201d type, while \u201cif\u201d is expecting a \u201cbool\u201d type after it. For assignment or passing arguments, until the overload of assignment operation is defined, there will also be no implicit conversion.\nUnlike TypeScript, Cesno also allows users to use some function to manipulate types, but not only utility types. Functions like \u201c(constexpr string s) -> s + \"!\"\u201d (append an exclamation mark after the given string), which is possible to get a value at compile time if the parameter is also constant, can be used in type manipulation. Therefore, users may reuse some functions, and avoid using utility types as a function (for example, a type that capitalises string may be found for a type that summons getters and setters method like \u201cgetUserList\u201d, actually it works like a function more. If using a function, some method like \u201ctoUpperCase\u201d can be called, avoiding repeating these methods and making types like Intrinsic String Manipulation Types in TypeScript [24])."
        },
        {
            "heading": "3.1.7 Class",
            "text": "This section introduces Cesno\u2019s design of object-oriented class. Cesno\u2019s class design is similar to most object-oriented languages, it also contains member (or \u201cfield\u201d, \u201cdata\u201d, \u201cattribute\u201d),\nfunction (\u201cstatic method\u201d in Java), and method (\u201cnon-static method\u201d in Java).\nTo define a class, at least a keyword \u201cclass\u201d and the definition body should be given. If the member, function, or method, without a modifier, it will be private by default. For example, to define a Staff class:\n1 2 3 4 5 class Staff { string name int id }\nTo inherit from an existing class, use \u201cinherits\u201d. Like the example below, class \u201cTeacher\u201d possesses three members: \u201cname\u201d, \u201cid\u201d, and \u201ccurrent_courses\u201d.\n1 2 3 4 class Teacher inherits Staff { Course[] current_courses }\nTo create a class, it should define a constructor, which contains the definition of the constructor's parameters, and how should those parameters build an instance. For example, a Teacher instance may be created using name, id, or current courses. Suppose the Staff class has a constructor. To call a constructor of inherited class, use super; to represent the instance itself, use self.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Teacher inherits Staff { Course[] current_courses public constructor( string name, string id, Course[] current_courses ) { super(name, id) self.current_courses = current_courses } }\nFor the programming language which only supports accessing instances\u2019 members or methods directly, there could be a lot of getter and setter, with methods to return a property of the instance, calculated by its members. This is not suggested in Cesno, because Cesno allows defining getter and setter \u201cintrinsically\u201d \u2013 when accessing or assigning members of instances, the getter and setter will work. For example, if there is a class store the name only with first name and last name:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class SimpleName { private tuple<string, string> name public string full_name { // Return type could be omitted // since it is obvious. // Properties can have // only one getter/setter, // no need for both string getter { return name[0] + name[1] ; } }\n17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public string first_name { getter { return self.name[0] ; } setter(string value) { self.name[0] = value ; } setter(SomeText value) { setter(value.text) ; } } public string last_name { getter { return self.name[1] ; } setter(string value) { self.name[1] = value ; } setter(SomeText value) { setter(value.text) ; } }\nFrom the above example, the members first_name and last_name get and set the value to the member name, but they are not stored in the instance nor the static part. In Cesno, method is suggested to be some action changing the instance. If some actions do not change instances, it is suggested to create properties with getter/setter, or \u201cpure function\u201d."
        },
        {
            "heading": "3.1.8 Generics",
            "text": "Generics, or generic grammar, is an important part of the type system of Cesno. When we say two objects x and y have the same type, we say that usually they have similar effects: if a parameter accepts x without exceptions, it should also accept y without exceptions. For example, x and y are two matrices, and they are both sized 25 times 25, they should be considered as the same data type. Because most operations of matrices require a specific sized matrix. However, if x is sized 25 times 25, but y is sized 24 times 26, their data types are considered to be different. Because those operations, such as addition or multiplication, accept a matrix depending on its size. For the value that does not determine whether the operation can be performed, it would be a member of that instance. For example, if a matrix has a name, the name does not affect whether the matrix can perform addition or multiplication, the name should be a member inside the instance. Generics in Cesno is based on the idea above. It could be helpful to type safety in compile time.\nTechnically, a type is made up of two parts, one is a class and the other is generic parameters which the class has. A class can have generic parameters. Generic parameters are const instance variables of an object. Two objects are considered as having the same type if and only if they have the same class and their generic parameters are equal. For example, DemoMatrix is a class, and DemoMatrix<Lines = 25, Columns = 15> is a type. While the parameters are Lines and Columns and their values are 25 and 15. DemoMatrix<Lines = 25, Columns = 15> equals\nto DemoMatrix<Lines = 25, Columns = 15> but doesn\u2019t equal to DemoMatrix<Lines = 24, Columns = 16>.\n1 2 3\nclass DemoMatrix <usize Lines, usize Columns, type EleType=float>;\nGeneric variables can be any type, including type (any concrete type\u2019s type) or nearly any other types. In this example, the generic variables\u2019 type is usize. A function or a method can also have generic parameters. The same method with different generic parameters should have a different type. They should have a different parameter type or return type.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class DemoMatrix <usize Lines, usize Columns> { // Multiply self to another DemoMatrix // (return = self * multiply_with). // The other DemoMatrix must have // a specific size, // whose Lines must be the same as // self's Columns. type MulOperandType<usize OperandColSize> = DemoMatrix<SelfType.Columns, OperandColSize> method multiply( MulOperandType<infer OperandColSize> by ): returns DemoMatrix<Lines, OperandColSize>; operator (*)( MulOperandType<infer OperandColSize> b ) { return self.multiply(by) } }\nIn the above example, the method multiply should have the generic parameter OperandColSize because with the different OperandColSize, its parameters by and return are different.\nThe other grammars of using generics are similar to other\ncommon programming languages such as TypeScript or Java.\nThe constructor of class DemoMatrix is:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class DemoMatrix <usize Lines, usize Columns> { // Initialise like this: // [[1, 2, 3], // [4, 5, 6], // [7, 8, 9]] // So the order of \"Column\" and \"Line\" // size, is reversed here. constructor( seq<seq<float, infer Columns>, infer Lines> data); } // Create an instance of DemoMatrix // and initialise its data. let x = DemoMatrix<Lines = 25, Columns = 15>( /* some data */ );\n23 24 25 26 27 // Create another instance. let y = DemoMatrix<15, 35>(/* some data */); // Multiply them together. let z = x.multiply(y); // or \"x * y\""
        },
        {
            "heading": "3.1.9 Module System",
            "text": "Many programming languages have a module system. In Java, each file can only contain one public class. Python, TypeScript, or Rust can create multiple classes or variables to export. In Cesno, each file is a namespace, it can contain multiple things (class, variable, function, other imported identifier) to be exported. By default, until declared permission of access, it is sealed inside the file, and cannot be imported or used by another file. To export these things, use a scope modifier with \u201cexport\u201d, like \u201cinpackage export\u201d means export this only inside the directory where the file is; default export (without scope modifiers) will be publically accessible.\nFor example, there is a Cesno code file called \u201cRegex-\nUtil.ces\u201d:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // At ~project/src/util/ // RegexUtil.ces (src.util.RegexUtil) const kean_email_checker = /[A-Za-z]+\\@kean\\.edu/ ; const wenzhou_kean_email_checker = /\\d{7}\\@wku\\.edu\\.cn/ ; export inline function validateKeanEmail(const string address) { return kean_email_checker .test(address) ; } export inline function validateWenzhouKeanEmail(const string address) { return wenzhou_kean_email_checker .test(address) ; }\nThere are two constants and two functions in this file. The two constants cannot be imported or used from another file, but the function is able to be imported.\nTo use exported things, users can import a package (directory) name, module (code file) name, or name of functions or variables. After import, the last item in the path of import will be able to be directly used in the code (e.g. import src.util means util can be directly written in the code, meaning the directory \u201csrc/util\u201d). The import statement will be effective inside the scope it appeared in, so it can be written anywhere, not only at the head of the file.\n1 2 3 4 5 6 7 8 9 10 11 12 // Import statement will not affect code here // Since all import are in the code block // Import namespace (here is a dir name) { import src.util ; util.RegexUtil.validateKeanEmail( \"someaddr@kean.edu\" ) ; } // Import a module with exported member(s)\n13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 { import src.util.RegexUtil ; RegexUtil.validateKeanEmail( \"someaddr@kean.edu\" ) ; } // Import a member from a module { import src.util.RegexUtil.validateKeanEmail ; validateKeanEmail(\"someaddr@kean.edu\") ; } // Import multiple member from a module { from src.util.RegexUtil import validateKeanEmail, validateWenzhouKeanEmail ; validateKeanEmail( \"someaddr@kean.edu\" ) ; validateWenzhouKeanEmail( \"1234567@wku.edu.cn\" ) ; } // Import member with alias { from src.util.RegexUtil import validateKeanEmail as validate, validateWenzhouKeanEmail as validate2 ; // This works as // \"let ref validate = validateKeanEmail\" // In a real project, // please use descriptive aliases. validate(\"someaddr@kean.edu\") ; validate2(\"1234567@wku.edu.cn\") ; }"
        },
        {
            "heading": "3.1.10 Evaluate the Code",
            "text": "In this part, we demonstrate how Cesno will explain each language gadget, and analyse the code to make it executable.\nThe identifier can be declared or defined. A declared identifier may be loaded at runtime, and it is able to be used while coding. If a user tries to define an identifier, but does not give explicit definition, or not give it afterward, the identifier will be undefined, and cannot be used until the explicit definition is given.\nEach statement has a value called evaluated value. For an identifier\u2019s assignment, the evaluate value is the right value; for function or method call, it is their return value; for definition structure, the evaluate value is itself (that means if you defined a class, and given it to an identifier, then that identifier holds the same value as defined class name); for flow control structure, it is the evaluate value of the last statement which is finally reached in this structure. Users can also use the keyword \u201ceval\u201d if they want to customise the evaluated value. For example, if you want to use a \u201cfor\u201d statement (flow control related) to assign a value, or if you need to break multiple nested \u201cfor\u201d statements, you can use \u201cbreak IDENTIFIER eval VALUE\u201d to pass the evaluated value, avoiding giving unexpected values. The evaluation enables Cesno to use almost any statements to be values. For example, users can use \u201cmatch\u201d statements to be the right value of assignment, which shortens the code only used for syntax (there is example of code before the conclusion section)."
        },
        {
            "heading": "3.2 Builtins and Language Library",
            "text": "For convenience, proper libraries should be offered Like Python\u2019s builtin or Rust\u2019s prelude, Cesno also has some functions, types, or constants be included in every Cesno code file, without declaring or including them manually (but it is includable). This is the builtin module in Cesno. For example, the function \u201cprint\u201d and \u201cinput\u201d, which is a common way to let the program interact within the console environment; the \u201cstring\u201d or \u201cint\u201d type which is also commonly used in other programming languages. The table of the builtins are attached at the end of this article.\nAlso, for builtin classes or functions, Cesno provides alternative names if necessary. Like C++\u2019s basic string has a synonym for method \u201csize\u201d and \u201clength\u201d [25], [26], Cesno also provides \u201creduce\u201d for \u201cfold\u201d, \u201creduceReverse\u201d for \u201cfoldr\u201d (linear container), \u201cbeginsWith\u201d for \u201cstartsWith\u201d (string), or \u201cendWith\u201d for \u201cendsWith\u201d (string). Types like \u201cint\u201d also have aliases (see table \u201cbuilt-in functions and types\u201d in Appendix). This can be a practice to adapt to different customs so they can use Cesno in the way that they want."
        },
        {
            "heading": "3.3 Check and Compilation",
            "text": "According to the reference [9], it is possible to check some errors out when using dynamic typing with static typing. Cesno will use static type and type inference for dynamic typed variables to check if type error. For dynamic typed variables, it will contain its data and type information. When it is used, its type information will be checked first. If the operation cannot be done, then an error would appear.\nTo solve the conflict of different code styles (e.g., in a public project or repository), Cesno will offer command line tools for bidirectional formatting like the tool described in [27], [28]. Users can specify their format preferences, and use this tool to format their code. When it comes to exchanging code files, they might use this tool to clear their preference and change the format back to a more universal one, the standard exchange format. This format will be used for the compiler as showed in figure 1."
        },
        {
            "heading": "4 EXAMPLE OF CODE",
            "text": "The benefit of the eval value helps programmers to write shorter assignment statements.\n1 2 3 4 5 6 7 8 string s = match (int(input(\"Input a number: \"))) { 4 => \"it is four\" ; 1, 3 => \"it is one or three\" ; otherwise => \"others\" ; } ; print(\"Result: \", s)\n9 10 11 12 13 14 15 // Run Test // Input a number: 3 // Result: it is one or three // Input a number: 10 // Result: others\nIn the above example, since all branches return a string, the match statement has a string type evaluated value. So, it is assignable to string s. The feature of evaluated value eliminates the code that is only used for assignment.\nBy using parameter restriction, programmers can add different limitations to the parameter. The example below shows the template type OperandType should have trait Addable, which has implemented operator plus. Also, since the parameter restriction can be more than one, there is no need to create a temporary type that implements the required traits.\n1 2 3 function <type OperandType: Addable> add(OperandType a, OperandType b) { return a + b ; }\nBy using then and else clause after a loop, programmers can focus more on the logic flow of code by setting fewer variables indicating whether the loop ends before expectation. The variable \u201cnumbers\u201d is an array of i32.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 for (let n in numbers) { if (n > 10) { break } } then { print(\"No value greater than 10.\") } else { print( \"First value greater than 10 is \", n ) }\nOpen a file as read-append mode (can), print all content, and append a line at the end of file. Suppose there would be no permission error here.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { // Suppose there is a scope here let file = open(\"~/test\", mode=#read_append) // \"foreach\" or \"forEach\", they are the same file.lines.foreach(print) file.append(\"Newly append line.\\n\") } // After leaving this scope, // instance in-scope calls destructor, // and the file's destructor will // close the file as well. // No need to worry about memory leaks here.\nSort input numbers (typed i32) using the quick sort algorithm, then print them. The input numbers will be separated by comma, read by format (formatted input). The \u201cformat\u201d argument indicates that this input is a formatted input; the input follows a pattern, and it will fail if input is not formatted correctly. It has only one catch group in the input, which captures an array\nof i32 following this pattern \u201c/\\d+(?:,\\s*\\d+)+/\u201d, catching every \u201c\\d+\u201d inside.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 print( \"The sorted array is: \", // The method sort changes array itself, // and returns self. input( \"Input i32 numbers \", \"separated by comma: \", format=\"${array; i32;\" + \"/\\d+(?:,\\s*\\d+)+/;\" + \"catch=/\\d+/}\", on_fail=#redo( \"The numbers inputted\" + \"should be all i32.\\n\") ).sort(algorithm=#quick), \", using quick sort.\" )\nThe below script is a program showing total lines of files inside a folder, only calculating files ending with \u201c.ces\u201d or \u201c.cesno\u201d. Suppose there is no restriction on file permissions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import os // Use bigint in case of overflow let total_lines = 0n for (const file in os.walk(\"~/project/\")) { if (file.name.endsWith(\".ces\", \".cesno\")) { total_lines += file.line_count } } print( `In \"~/project/\", there is ${total_lines} lines of Cesno code.` )\nImplement a method called \u201ccheckEqual\u201d for builtin dict containers. If a dict contains a key, and the corresponding value is equal to the given value, the method returns true; otherwise, it returns false. This method will be available inside one project. In the future, the rule for implementing methods outside the original class will be discussed (for example, borrowing from Rust\u2019s orphan rule in order to avoid problems like naming conflict).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // In file prelude.ces // (this file is designed to be the // auto import one for all code files in the // same or sub directory, // the name might change in // official version later) // Since the second generics is restricted // to type implemented Equal, // The method will be only available // if ValueType can call \"==\" implement dict<type KeyType, type ValueType: Equal> { method checkEqual( KeyType key, ValueType check ) { return self.has(key) and self[key] == check }\n23 }"
        },
        {
            "heading": "5 DRAWBACKS & FUTURE WORK",
            "text": ""
        },
        {
            "heading": "5.1 Current Drawbacks",
            "text": "This article describes the design of Cesno, and the possibility of having such a model of language. Yet, we have not completed all the design, and the basic structure of syntax may still change. Also, the infrastructure like compiler, language library, package manager are not implemented. Hence, there is a lack of data of speed/memory usage of Cesno.\nSome features are not discussed. Concurrent programming in Cesno is going to be implemented at a language primitive level, in order to make it able to fast-implement basic concurrent programs using structures like \u201cif\u201d statements. Also, how Cesno detects the end of a statement is not completely described."
        },
        {
            "heading": "5.2 Future Research Topics",
            "text": "In our future work, we will focus on several essential points.\nFirst: There would be more content on how the language builds itself \u2013 how each word and symbol is recognized, how high-level languages\u2019 features (like class) map into low-level languages and become machine-optimised. It is important to answer these questions to make the programming language customizable, extendable, and allow users to do meta programming based on that system. Also, the built-in function needs to be designed to be more powerful. For example, how to implement \u201cformat=\"${array; i32; /\\d+(?:,\\s*\\d+)+/; catch=/\\d+/}\"\u201d in the \u201cinput\u201d function mentioned above, letting the input to be checked, and giving back an array type instead of string. This requires the programming language to have a responsible meta-programming system.\nSecond: One selling point of Cesno will be the ability to customize the language easily, since the way the compiler compiles will also be represented as human-readable language, not hardcoded into the compiler. One approach is to use some keywordlike word to trigger the matching of pattern. For example, the \u201cfor-loop\u201d has a trigger of \u201cfor\u201d, waiting for at least one iteration indicator (like \u201c(int i = 0; i < 10; i++)\u201d or \u201c(const x in [1, 2]\u201d) and a code block. The trigger \u201cfor\u201d can only be available if it is allowed in the \u201cscope\u201d \u2013 whether the trigger word is supposed to be here. If a \u201cfor\u201d appears after \u201cmethod\u201d and before a pair of parentheses (method for()), it will be considered a name of the method, since \u201cfor-loop\u201d structure is not supposed to be at the position of name, so the \u201cfor\u201d is not considered as a trigger of \u201cfor-loop\u201d, but a identifier. However, since the code analysis mode is \u201cexpecting tokens\u201d, it is hard to write the compiler when the overall design is not finished. Design for how to implement functions that let the compiler read user-customised macro, literals, or statements also requires a strong will also have an impact on the compiler\u2019s time complexity.\nThird: Cesno also wants to implement a strong type system, which defines how types form themselves, and how they are translated into assembly language. The first part is how value is considered to be some types \u2013 is it a value that inside a countable set (like int range from -2^31 to 2^31-1, or literal types like \"off\" (the variable with this type can only have one possibility\nof value, which is \"off\")), or is it zero or more same-type elements\u2019 combination (like string (raw string is combination of char) or array), or is it combined with a finite number of members with some types (like builtin or user-defined class). These categories are useful in representing type\u2019s definition and value acceptable in a human-readable way inside the programming language. The second part is to disclose the function, method and its implementation detail of very basic and simple types such as bool. For example, some languages use \u201cprimitive type\u201d to describe them, and omit the language-level implementation (like Java\u2019s int type or double type); also, it is not possible to call function or method directly from those types, until they are boxed. However, Cesno will not use these boxed types, and offer a postimplement feature for the type defined as mentioning value acceptable. This is a simple illustration below, for every type in Cesno, it is possible to define methods directly to it, without using another class to box it. It also makes disclosing basic types\u2019 methods possible.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 type FanState = enum { on, off, maintaining( Date from_date, Date until_date ) } implement FanState { public { bool available { getter { return self != FanState.maintaining } } method tellOthersAvailability() { if (self.available) { /* do something */ } } } }\nAnother part to design is type compatibility. This is related to how Cesno checks the assignability and how the assigned variable works.\nThere is the difference of nominal type and structural type in programming languages, languages like Java or C# use nominal type, while TypeScript uses structural subtyping [29]. In this article, only nominal type (defined by class) is discussed. However, there could be structural types defined by \u201cstruct\u201d in the future. If the necessity of structural type is proved, this system will be implemented. For nominal types, the assignability depends on whether they are the same, or have an inheritance relationship, since for types possessing the same members, they might have different meanings. For structural types, as long as required members are given, the assignability establishes.\nFunction assignability is different from other variables\u2019 assignment. As the previous section \u201cFunction and Method\u201d describes, Cesno allows optional, positional and keyword arguments; when check the assignability, there will first be the check of arguments\u2019 number and name, whether they match the required function. After that it is the type check, the argument should be contravariant and the return type should be covariant to keep the assignability. Besides, Cesno has not discussed the strategy of picking appropriate function/method when there is overload of functions.\nFor generics, its design is not fully described in this article. Unlike some programming languages which only support classes (or types) as the generics type parameter [30], Cesno\u2019s generics will have less restrictions. For example, the basic container \u201csequence\u201d will have a length parameter which is typed usize (class sequence<type EleType, usize SelfLength>). The core idea of generics is: the value that makes one type a different type from others should be put into generics\u2019 parameters list (e.g. element type of array). In order to accomplish this goal, the generics should be able to accept type, enum, function, or value with concrete type. The implementation of generics is not decided in this language design proposal (use template like C++, or use monomorphization like Rust, or allow both of them), and for generic parameters that is known until runtime, there is not a proper solution for assignment, type checking and so on.\nFourth: ability to adapt language features that are considered as basic features of a programming language. The ownership system is a basic feature that cannot be violated in Rust (or the program will not compile) [31], which offers higher performance and safety, for example, avoiding the unexpected change of shared states [3]. Cesno is going to adapt this system, by using special modifiers like \u201cunique\u201d to declare this variable obeys to the rule of ownership system. The challenge found here is: how to solve the conflict while the adapted basic language features are half-provided in code. A realistic problem could be \u201cif a unique typed variable is assigned to a common variable, how should both variables act to keep the code understandable and reasonable\u201d. In Cesno, users have the right to write code as they want, they may not only require more code style while the CLI formatter transforms standard exchange format to what they like, they may also want some features provided by other languages. Besides the reason of language-requirement or server environment, these aspects could also make users struggling in picking languages: project targets, language features, language\u2019s strengths and weaknesses, availability of languages, whether the language is well-supported [32], [33]. Cesno does not want to be domain-specific that may cause users to learn another language when moving to a different problem, as a result, Cesno should find a proper solution of adapting those languages\u2019 features that users might want to use."
        },
        {
            "heading": "5.3 Other Framework Proposed",
            "text": "To translate Cesno code into machine-based assembly language, there could be another proposed general mode of assembly language called CesAsm, which will cover the most basic instructions. CesAsm could be seen as a middle layer between highly abstracted high level languages and low level languages. Some machines might implement effective instructions like MADD in the ARM instruction set. CesAsm uses these instructions, and polyfills on the machine which it does not have (like a function\nthat has different implementations on different machines). CesAsm will be helpful in analysing the convention between languages, since it will be designed to keep the balance between human-readable and easy to translate to machine. For the operation on basic types like bool or int, CesAsm will appear in the Cesno code to show how it converts most basic operations from high level to low level.\nTo make the code for design and logic cross-platform, Cesno is proposing abstract data type, which is the description of the action of the basic element. For example, a Button class will have different representation in HTML, Android Apps, or Qt Application; but the description about how the button looks like, how button response, or how this button is related to other elements, will be almost the same. By using these abstract types, programmers can focus on more about the design logic, let the implementation task move to the compiler, and the compiler can summon target code by their intrinsic features, or polyfilling the code.\nJSON (JavaScript Object Notation) is known as a common way of serialising, storing and exchanging data. However, there are some drawbacks of JSON such as no comment permitted, or no data type information for stored strings [34]. If someone converts a Date object into JSON, they will get a string, but not an object containing timestamp and type information. To keep the type information and still make the data type diverse and recordable, Cesno is going to have a new format called CESON (Cesno Object Notation), which will combine the way Cesno represents object literal and format of JSON. Also, there would be support for comment, data encryption, or data type information, which could solve currently discovered problems of JSON. To enable storing objects in CESON, there will also be object literal, which works like a constructor, but defines the member directly in the instance (like JavaScript object literal). In order to avoid manually calculation to unnecessary members (e.g., some members could derive from other members) or create conflict (e.g. members are having conflicting members, which are not supposed to appear at the same time), this feature needs further design."
        },
        {
            "heading": "6 CONCLUTION",
            "text": "This article explores the potential of a C-style Object-Oriented Programming Language called Cesno. The main improvement offered by Cesno is the combination of convenient features from other languages, making it easier to learn and understand, while also reducing restrictions. To accomplish this goal, Cesno takes\ndesign ideas or functions from other languages, allows multiple forms of writing without introducing ambiguity, simplifies complex language features, and permits users to write more freely (e.g. if the user does not wish to specify a return type, they may simply leave it blank). These characteristics help to facilitate quick learning and transition, as well as aid in the writing of code with ease."
        },
        {
            "heading": "APPENDIX A: RESERVED WORD LIST",
            "text": "Here are the reserved words used for keywords, builtin func-\ntions, builtin data types and so on. It is suggested that users should not modify the features (for example, re-define function \u201csorted\u201d) of these words to avoid getting unex-pected results.\nTABLE 3\nBUILT-IN FUNCTIONS AND TYPES\nName Usage\ninput Standard input print Standard output open Open a file sorted Sorted sortable data reversed Reversed data in linear container random Produce random float type number randint Produce random int type number exit End the program immediately. int (i32) Integer type with 32-bit long (i64) Integer type with 64-bit byte (i8) Integer type with 8-bit float (f64) Float point type with 64-bit floatsg (f32) Float point type with 32-bit bool True or False char One UTF-8 character type string Sequence of char with useful method object Base type of every type in Cesno, except for null and undefined. tuple For these containers, please refer to the section \u201cImplementation Model - Basic Grammar - Basic Containers\u201d. array list sequence (seq) dictionary (dict) set stdin Standard input stream stdout Standard output stream\nThere are the built-in functions, types, or constant. The name in the parenthesis is the alias."
        },
        {
            "heading": "APPENDIX B: TERMINOLOGY (WITH CHINESE AND JAPANESE TRANSLATION)",
            "text": "TABLE 4 TERMINOLOGY\nEnglish Chinese Japanese\nlanguage gadget \u8bed\u8a00\u90e8\u4ef6 \u8a00\u8a9e\u7d44\u6210\u5b50\ndefine word \u5b9a\u4e49\u5b57 \u5b9a\u7fa9\u5b57\nclosure (function) \u5e26\u73af\u5883\u51fd\u6570 \u6587\u8108\u4ed8\u95a2\u6570\nstandard exchange format \u6807\u51c6\u4ea4\u6362\u683c\u5f0f \u6a19\u6e96\u4ea4\u63db\u69d8\u5f0f\nevaluated value \u8bc4\u4ef7\u503c \u8a55\u4fa1\u5024\nThere are the terminologies used in Cesno (and currently discussed in this paper). To avoid confusion, each English terminology will have corresponding Chinese and Japanese translations. There are also pronunciations provided for Japanese translations."
        },
        {
            "heading": "ACKNOWLEDGMENT",
            "text": "The authors gratefully acknowledge the financial support from Wenzhou-Kean University. We have the pleasure to work with people who shared a lot of suggestions, and discuss with me about the details of the language design. The list below is the GitHub account name for people who participated in the discussion (Exclude authors for this article)."
        }
    ],
    "title": "Cesno: Possibility of Creating a New Programming Language",
    "year": 2023
}