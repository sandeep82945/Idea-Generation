{
    "abstractText": "The efficiency and the security of smart contracts are their two fundamental properties, but might come at odds: the use of optimizers to enhance efficiency may introduce bugs and compromise security. Our focus is on EVM (Ethereum Virtual Machine) block-optimizations, which enhance the efficiency of jump-free blocks of opcodes by eliminating, reordering and even changing the original opcodes. We reconcile efficiency and security by providing the verification technology to formally prove the correctness of EVM block-optimizations on smart contracts using the Coq proof assistant. This amounts to the challenging problem of proving semantic equivalence of two blocks of EVM instructions, which is realized by means of three novel Coq components: a symbolic execution engine which can execute an EVM block and produce a symbolic state; a number of simplification lemmas which transform a symbolic state into an equivalent one; and a checker of symbolic states to compare the symbolic states produced for the two EVM blocks under comparison. Artifact: https://doi.org/10.5281/zenodo.7863483",
    "authors": [
        {
            "affiliations": [],
            "name": "Elvira Albert"
        },
        {
            "affiliations": [],
            "name": "Samir Genaim"
        },
        {
            "affiliations": [],
            "name": "Daniel Kirchner"
        },
        {
            "affiliations": [],
            "name": "Enrique Martin-Martin1(B"
        }
    ],
    "id": "SP:963a0ff123ab767cbbd9cf4d535177bd7a6ab594",
    "references": [
        {
            "authors": [
                "E. Albert",
                "P. Gordillo",
                "A. Hern\u00e1ndez-Cerezo",
                "A. Rubio"
            ],
            "title": "A Max-SMT superoptimizer for EVM handling memory and storage",
            "venue": "TACAS 2022. LNCS, vol. 13243, pp. 201\u2013219. Springer, Cham",
            "year": 2022
        },
        {
            "authors": [
                "E. Albert",
                "P. Gordillo",
                "A. Rubio",
                "M.A. Schett"
            ],
            "title": "Synthesis of super-optimized smart contracts using max-SMT",
            "venue": "Lahiri, S.K., Wang, C. (eds.) CAV 2020. LNCS, vol. 12224, pp. 177\u2013200. Springer, Cham",
            "year": 2020
        },
        {
            "authors": [
                "A. Barri\u00e8re",
                "S. Blazy",
                "O. Fl\u00fcckiger",
                "D. Pichardie",
                "J. Vitek"
            ],
            "title": "Formally verified speculation and deoptimization in a JIT compiler",
            "venue": "Proc. ACM Program. Lang. 5(POPL), 1\u201326",
            "year": 2021
        },
        {
            "authors": [
                "T Bernardi"
            ],
            "title": "Preventing reentrancy bugs - another use case for formal verification (2020)",
            "year": 2020
        },
        {
            "authors": [
                "A. Bizga"
            ],
            "title": "A hackers\u2019 dream payday: Ledf.me and uniswap lose $25 million worth of cryptocurrency (2020)",
            "venue": "https://securityboulevard.com/2020/04/a-hackers-dreampayday-ledf-me-and-uniswap-lose-25-million-worth-of-cryptocurrency/. [Online; accessed 11-May-2020]",
            "year": 2020
        },
        {
            "authors": [
                "V. Buterin"
            ],
            "title": "CRITICAL UPDATE Re: DAO vulnerability (2016)",
            "venue": "https://blog. ethereum.org/2016/06/17/critical-update-re-dao-vulnerability/. Accessed 2-July2017",
            "year": 2017
        },
        {
            "authors": [
                "P. Daian"
            ],
            "title": "Analysis of the DAO exploit (2016)",
            "venue": "http://hackingdistributed.com/",
            "year": 2016
        },
        {
            "authors": [
                "D. Demange",
                "D. Pichardie",
                "L. Stefanesco"
            ],
            "title": "Verifying fast and sparse SSA-based optimizations in Coq",
            "venue": "Franke, B. (ed.) CC 2015. LNCS, vol. 9031, pp. 233\u2013252. Springer, Heidelberg",
            "year": 2015
        },
        {
            "authors": [
                "L. Gourdin",
                "S. Boulm\u00e9"
            ],
            "title": "Certifying assembly optimizations in Coq by symbolic execution with hash-consing, p",
            "venue": "2",
            "year": 2021
        },
        {
            "authors": [
                "E Hildenbrandt"
            ],
            "title": "KEVM: a complete formal semantics of the ethereum virtual machine",
            "venue": "31st IEEE Computer Security Foundations Symposium, CSF 2018, Oxford, United Kingdom, July 9\u201312, 2018, pp. 204\u2013217. IEEE Computer Society",
            "year": 2018
        },
        {
            "authors": [
                "Y. Hirai"
            ],
            "title": "Defining the ethereum virtual machine for interactive theorem provers",
            "venue": "Brenner, M., Rohloff, K., Bonneau, J., Miller, A., Ryan, P.Y.A., Teague, V., Bracciali, A., Sala, M., Pintore, F., Jakobsson, M. (eds.) FC 2017. LNCS, vol. 10323, pp. 520\u2013535. Springer, Cham",
            "year": 2017
        },
        {
            "authors": [
                "X. Leroy"
            ],
            "title": "Formal verification of a realistic compiler",
            "venue": "Commun. ACM 52(7), 107\u2013 115",
            "year": 2009
        },
        {
            "authors": [
                "N.P. Lopes",
                "D. Menendez",
                "S. Nagarakatte",
                "J. Regehr"
            ],
            "title": "Practical verification of peephole optimizations with alive",
            "venue": "Commun. ACM 61(2), 84\u201391",
            "year": 2018
        },
        {
            "authors": [
                "H. Massalin"
            ],
            "title": "Superoptimizer - a look at the smallest program",
            "venue": "Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS II), pp. 122\u2013126",
            "year": 1987
        },
        {
            "authors": [
                "D. Monniaux",
                "C. Six"
            ],
            "title": "Simple, light, yet formally verified, global common subexpression elimination and loop-invariant code motion",
            "venue": "Henkel, J., Liu, X. (eds.) LCTES \u201921: 22nd ACM SIGPLAN/SIGBED International Conference on Languages, Compilers, and Tools for Embedded Systems, Virtual Event, Canada, 22 June, 2021, pp. 85\u201396. ACM",
            "year": 2021
        },
        {
            "authors": [
                "D.P. Mulligan",
                "S. Owens",
                "K.E. Gray",
                "T. Ridge",
                "P. Sewell"
            ],
            "title": "Lem: reusable engineering of real-world semantics",
            "venue": "ACM SIGPLAN Notices 49(9), 175\u2013188",
            "year": 2014
        },
        {
            "authors": [
                "J. Nagele",
                "M.A. Schett"
            ],
            "title": "Blockchain superoptimizer",
            "venue": "Preproceedings of 29th International Symposium on Logic-based Program Synthesis and Transformation (LOPSTR 2019)",
            "year": 2019
        },
        {
            "authors": [
                "D. Palmer"
            ],
            "title": "Spankchain loses $40k in hack due to smart contract bug (2018)",
            "venue": "https://www.coindesk.com/spankchain-loses-40k-in-hack-due-to-smart-contractbug. Accessed",
            "year": 2020
        },
        {
            "authors": [
                "R Sasnauskas"
            ],
            "title": "Souper: A Synthesizing Superoptimizer",
            "venue": "[cs],",
            "year": 2017
        },
        {
            "authors": [
                "C. Six",
                "S. Boulm\u00e9",
                "D. Monniaux"
            ],
            "title": "Certified and efficient instruction scheduling: application to interlocked VLIW processors",
            "venue": "Proc. ACM Program. Lang. 4(OOPSLA), 129:1\u2013129:29",
            "year": 2020
        },
        {
            "authors": [
                "C. Six",
                "L. Gourdin",
                "S. Boulm\u00e9",
                "D. Monniaux",
                "J. Fasse",
                "N. Nardino"
            ],
            "title": "Formally verified superblock scheduling",
            "venue": "Popescu, A., Zdancewic, S. (eds.) CPP \u201922: 11th ACM SIGPLAN International Conference on Certified Programs and Proofs, Philadelphia, PA, USA, January 17\u201318, 2022, pp. 40\u201354. ACM",
            "year": 2022
        },
        {
            "authors": [
                "J. Tristan",
                "X. Leroy"
            ],
            "title": "Formal verification of translation validators: a case study on instruction scheduling optimizations",
            "venue": "Necula, G.C., Wadler, P. (eds.) Proceedings of the 35th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2008, San Francisco, California, USA, January 7\u201312, 2008, pp. 17\u201327. ACM",
            "year": 2008
        },
        {
            "authors": [
                "J. Tristan",
                "X. Leroy"
            ],
            "title": "Verified validation of lazy code motion",
            "venue": "Hind, M., Diwan, A. (eds.) Proceedings of the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2009, Dublin, Ireland, June 15\u201321, 2009, pp. 316\u2013326. ACM",
            "year": 2009
        },
        {
            "authors": [
                "J. Tristan",
                "X. Leroy"
            ],
            "title": "A simple, verified validator for software pipelining",
            "venue": "Hermenegildo, M.V., Palsberg, J. (eds.) Proceedings of the 37th ACM SIGPLANSIGACT Symposium on Principles of Programming Languages, POPL 2010, Madrid, Spain, January 17\u201323, 2010, pp. 83\u201392. ACM",
            "year": 2010
        },
        {
            "authors": [
                "C. Turley"
            ],
            "title": "imBTC uniswap pool drained for $300k in ETH (2020)",
            "venue": "https://defirate. com/imbtc-uniswap-hack/. Accessed",
            "year": 2020
        },
        {
            "authors": [
                "G. Wood"
            ],
            "title": "Ethereum: A secure decentralised generalised transaction ledger (Berlin version 8fea825",
            "year": 2022
        }
    ],
    "sections": [
        {
            "text": "Artifact: https://doi.org/10.5281/zenodo.7863483\nKeywords: Coq \u00b7 Ethereum Virtual Machine \u00b7 Smart Contracts \u00b7 Optimization \u00b7 Theorem Proving"
        },
        {
            "heading": "1 Introduction",
            "text": "In many contexts, security requirements are critical and formal verification today plays an essential role to verify/certify these requirements. One of such contexts is the blockchain, in which software bugs on smart contracts have already caused several high profile attacks (e.g., [14\u201317,30,37]). There is hence huge interest and investment in guaranteeing their correctness, e.g., Certora [1], Veridise [2], apriorit [3], Consensys [4], Dedaub [5] are companies that offer smart contract audits using formal methods\u2019 technology. In this context, efficiency is of high relevance as well, as deploying and executing smart contracts has a cost (in the corresponding cryptocurrency). Hence, optimization tools for smart contracts have\nThis work was funded partially by the Ethereum Foundation under Grant ID FY220698 and the Spanish MCI, AEI and FEDER (EU) project PID2021-122830OB-C41. c\u00a9 The Author(s) 2023 C. Enea and A. Lal (Eds.): CAV 2023, LNCS 13966, pp. 176\u2013189, 2023. https://doi.org/10.1007/978-3-031-37709-9_9\nemerged in the last few years (e.g., ebso [29], SYRUP [12], GASOL [11], the solc optimizer [9]). Unfortunately, there is a dichotomy of efficiency and correctness: as optimizers can be rather complex tools (not formally verified), they might introduce bugs and potential users might be reluctant of optimizing their code. This has a number of disruptive consequences: owners will pay more to deploy (non-optimized) smart contracts; clients will pay more to run transactions every time they are executed; the blockchain will accept less transactions as they are more costly. Rather than accepting such a dichotomy, our work tries to overturn it by developing a fully automated formal verification tool for proving the correctness of the optimized code.\nThe general problem addressed by the paper is formally verifying semantic equivalence of two bytecode programs, an initial code I and an optimization of it O \u2013what is considered a great challenge in formal verification. For our purpose, we will narrow down the problem by (1) considering fragments of code that are jump-free (i.e., they do not have loops nor branching), and by (2) considering only stack EVM operations (memory/storage opcodes and other blockchainspecific opcodes are not considered). These assumptions are realistic as working on jump-free blocks still allows proving correctness for optimizers that work at the level of the blocks of the CFG (e.g., super-optimizers [11,12,29] and many rule-based optimizations performed by the Solidity compiler [9]). Considering only stack optimizations, and leaving out memory and storage simplifications and blockchain-specific bytecodes, does not restrict the considered programs, as we work at the smaller block partitions induced by the not handled operations found in the block (splitting into the block before and after). Even in our narrowed setting, the problem is challenging as block-optimizations can include any elimination, reorder and even change of the original bytecodes.\nConsider the next block I, taken from a real smart contract [8]. The GASOL optimizer [11], relying on the commutativity of OR and AND, optimizes it to O:\nI: PUSH2 0x100 PUSH1 0x1 PUSH1 0xa8 SHL SUB NOT SWAP1 SWAP2 AND PUSH1 0x8 SWAP2 SWAP1 SWAP2 SHL PUSH2 0x100 PUSH1 0x1 PUSH1 0xa8 SHL SUB AND OR PUSH1 0x5 O: PUSH2 0x100 PUSH1 0x1 PUSH1 0xa8 SHL SUB DUP1 NOT SWAP2 PUSH1 0x8 SHL AND SWAP2 AND OR PUSH1 0x5\nThis saves 11 bytes because (1) the expression SUB(SHL(168,1),256) \u2013that corresponds to \u201cPUSH2 0x100 PUSH1 0x1 PUSH1 0xa8 SHL SUB\u201d \u2013 is computed twice; but it can be duplicated if the stack operations are properly made saving 8 bytes; and (2) two SWAPs are needed instead of 5, saving 3 more bytes.\nThis paper proposes a technique, and a corresponding tool, to automatically verify the correctness of EVM block-optimizations (as those above) on smart contracts using the Coq proof assistant. This amounts to the challenging problem of proving semantic equivalence of two blocks of EVM instructions, which is realized by means of three main components which constitute our main contributions (all formalized and proven correct in Coq): (1) a symbolic interpreter in Coq to symbolically execute the EVM blocks I and O and produce resulting symbolic states SI and SO, (2) a series of simplification rules, which transform SI and SO into\nequivalent ones S\u2032I and S\u2032O, (3) a checker of symbolic states in Coq to decide if two symbolic states S\u2032I and S\u2032O are semantically equivalent."
        },
        {
            "heading": "2 Background",
            "text": "The Ethereum VM (EVM) [38] is a stack-based VM with a word size of 256-bits that is used to run the smart contracts on the Ethereum blockchain. The EVM has the following categories of bytecodes: (1) Stack operations; (2) Arithmetic operations; (3) Comparison and bitwise logic operations;(4) Memory and storage manipulation;(5) Control flow operations; (6) Blockchain-specific opcodes, e.g., block and transaction environment information, compute hash, calls, etc. The first three types of opcodes are handled within our verifier, and handling optimizations on opcodes of types 4-6 is discussed in Sect. 6.\nThe focus of our work is on optimizers that perform optimizations only at the level of the blocks of the CFG (i.e., intra-block optimizations). A well-known example is the technique called super-optimization [26] which, given a loop-free sequence of instructions searches for the optimal sequence of instructions that is semantically equivalent to the original one and has optimal cost (for the considered criteria). This technique dates back to 1987 and has had a revival [25,31] thanks to the availability of SMT solvers that are able to do the search efficiently. We distinguish two types of possible intra-block optimizations: (i) Rule-based optimizations which consist in applying arithmetic/bitwise simplifications like ADD(X,0)=X or NOT(NOT(X))=X (see a complete list of these rules in App. A in [10]); and (ii) Stack-data optimizations which consist in searching for alternative stack operations that lead to an output stack with exactly the same data.\nExample 1 (Intra-block optimizations). The rule-based optimization (i) X+0 \u2192 X simplifies the block \u201cPUSH1 0x5, PUSH1 0x0, ADD\u201d to \u201cPUSH1 0x5\u201d. On the other hand, stack-data optimizations (ii) can optimize to \u201cADD, DUP1\u201d the block \u201cDUP2, DUP2, ADD, SWAP2, ADD\u201d, as duplicating the operands and repeating the ADD operation is the same as duplicating the result. Unlike rule-based optimization, stack-data optimizations cannot be expressed as simple patterns that can be easily recognized.\nThe first type of optimizations are applied by the optimizer integrated in the Solidity compiler [9] as rule transformations, and they are also applied by EVM optimizers in different ways. ebso [29] encodes the semantics of arithmetic and bitwise operations in the SMT encoding so that the SMT solver searches for these optimizations together with those of type (ii). Instead, SYRUP [12] and GASOL [11] apply rule-based optimizations in a pre-phase and leave to the SMT solver only the search for the second type of optimizations. This classification of optimizations is also relevant for our approach as (i) will require integrating and proving all simplification rules correct (Sect. 4.2) while (ii) are implicit within the symbolic execution (Sect. 4.1). A block of EVM code that has been subject to optimizations of the two types above is in principle \u201cprovable\u201d using our tool.\nThere is not much work yet on formalizing the EVM semantics in Coq. One of the most developed approaches is [22], which is a definition of the EVM semantics in the Lem [28] language that can be exported to interactive theorem provers like Isabelle/HOL or Coq. According to the comparison in [21], this implementation of EVM \u201cis executable and passes all of the VM tests except for those dealing with more complicated intercontract execution\u201d. However, we have decided not to use it for our checker due to three reasons: (a) the generated Coq code from Lem definitions is not \u201cnecessarily idiomatic\u201d and thus it would generate a very complex EVM formalization in Coq that would make theorems harder to state and prove; (b) the author of the Lem definition states that \u201cthe Coq version of the EVM definition is highly experimental\u201d; and (c) it is not kept up-to-date.\nThe other most developed implementation of the EVM semantics in Coq that we have found is [23]. It supports all the basic EVM bytecodes we consider in our checker, and looked promising as our departing point. The implementation uses Bedrock Bit Vectors (bbv) [7] for representing the EVM 256-bit values, as we use as well. It is not a full formalization of the EVM because it does not support calling or creation of smart contracts, but provides a function that simulates consequent application of opcodes to the given execution state, call info and Ethereum state mocks. The latter two pieces of information would add complexity and are not needed for our purpose. Therefore, we decided to develop our own EVM formalization in Coq (presented in Sect. 3) which builds upon some ideas of [23], but introduces only the minimal elements we need to handle the instructions supported by the checker. This way the proofs will be simpler and conciser."
        },
        {
            "heading": "3 EVM Semantics in Coq",
            "text": "Our EVM formalization is a concrete interpreter that executes a block of EVM instructions. For representing EVM words we use EVMWord that stands for the type \u201cword 256\u201d of the bbv library [7]. For representing instructions we use:\nInductive stack_op_instr := Inductive instr := | ADD | PUSH (size: nat) (w: EVMWord) | MUL | POP | SUB | DUP (pos: nat) | DIV | SWAP (pos: nat) | NOT. | StackInstr (label: stack_op_instr).\nType stack_oper_instr defines instructions that operate only on the stack, i.e., each pops a fixed number of elements and pushes a single value back (see App. B in [10] for the full list). Type instr encapsulates this category together with the stack manipulation instruction (PUSH, etc.). The type block stands for \u201clist instr\u201d.\nTo keep the framework general, and simplify the proofs, the actual implementation of instructions from stack_op_instr are provided to the interpreter as input. For this, we use a map that associates instructions to implementations:"
        },
        {
            "heading": "Inductive stack_operation :=",
            "text": "| StackOp (comm: bool) (n : nat) (f : list EVMWord \u2192 option EVMWord).\nDefinition stack_op_map := map stack_oper_instr stack_operation.\nThe type stack_operation defines an implementation for a given operation: comm indicates if the operation is commutative; n is the number of stack elements to be removed and passed to the operation; and f is the actual implementation. The type stack_op_map maps keys of type stack_oper_instr to values of type stack_operation. Suppose evm_add and evm_mul are implementations of ADD and MUL (see App. C in [10]), the actual stack operations map is constructed as:"
        },
        {
            "heading": "Definition evm_stack_opm : stack_op_map :=",
            "text": "ADD |\u2192i StackOp true 2 evm_add; MUL |\u2192i StackOp true 2 evm_mul; ...\nIn addition, we require the operations in the map to be valid with respect to the properties that they claim to satisfy (e.g., commutativity), and that when applied to the right number of arguments they should succeed (i.e., do not return None). We refer to this property as valid_stack_op_map.\nAn execution state (or simply state) includes only a stack (currently we support only stack operations) which is as a list of EVMWord, and the interpreter is a function that takes a block, an initial state, and a stack operations map, and iteratively executes each of the block\u2019s instructions:\nDefinition stack := list EVMWord. Inductive state :=\n| ExState (stk: stack). Fixpoint concr_int (p: block) (st: state) (ops: stack_op_map): option state := ...\nThe result can be either Some st or None in case of an error which are caused only due to stack overflow. In particular, we are currently not taking into account the amount of gas needed to execute the block. Our implementation follows the EVM semantics [38], considering the simplicity of the supported operations, the concrete interpreter is a minimal trusted computing base. In the future, we plan to test it using the EVM test suite.\n4 Formal Verification of EVM-Optimizations in Coq\nTwo jump-free blocks p1 and p2 are equivalent wrt. to an initial stack size k, if for any initial stack of size k, the executions of p1 and p2 succeed and lead to the same state. Formally:\nDefinition sem_eq_blocks: (p1 p2: block) (k: nat) (ops: stack_op_map) : Prop := \u2200 (in_st: state) (in_stk: stack), get_stack in_st = in_stk \u2192 length in_stk = k \u2192\n\u2203 (out_st : state), concr_int p1 in_st ops = Some out_st \u2227 concr_int p2 in_st ops = Some out_st\nNote that when concr_int returns None for both p1 and p2, they are not considered equivalent because in the general case they can fail due to different reasons. Note also that EVM operations are deterministic, so if concr_int evaluates to a sucessful final state out_st it will be unique.\nAn EVM block equivalence checker is a function that takes two blocks, the size of the initial stack, and returns true/false. Providing the size k of the initial\nstack is not a limitation of the checker, as this information is statically known in advance. Note that the maximum stack size in EVM is bounded by 1024, and that if the execution (of one or both blocks) wrt. to this concrete initial stack size leads to under/over stack overflow they cannot be reported equivalent. The soundness of the equivalence checker is stated as follows:\nDefinition eq_block_chkr_snd (chkr : block \u2192 block \u2192 nat \u2192 bool) : Prop := \u2200 (p1 p2: block) (k: nat),\nchkr p1 p2 k = true \u2192 sem_equiv_blocks p1 p2 k evm_stack_opm Given two blocks p1 and p2, checking their equivalence (in Coq) has the following components: (i) Symbolic Execution (Sect. 4.1): it is based on an interpreter that symbolically executes a block, wrt. an initial symbolic stack of size k, and generates a final symbolic stack. It is applied on both p1 and p2 to generate their corresponding symbolic output states S1 and S2. (ii) Rule optimizations (Sect. 4.2): it is based on simplification rules that are often applied by program optimizers, which rewrite symbolic states to equivalent \u201csimpler\u201d ones. This step simplifies S1 and S2 to S\u20321 and S\u20322. (iii) Equivalence Checker (Sect. 4.3): it receives the simplified symbolic states, and determines if they are equivalent for any concrete instantiation of the symbolic input stack. It takes into account, for example, the fact that some stack operations are commutative.\n4.1 EVM Symbolic Execution in Coq\nSymbolic execution takes an initial symbolic state (i.e., stack) [s0, . . . , sk], a block, and a map of stack operations, and generates a final symbolic state (i.e., stack) with symbolic expressions, e.g., [5+s0, s1, s2], representing the corresponding computations. In order to incorporate rule-based optimizations in a simple and efficient way, we want to avoid compound expressions such as 5 + (s0 \u2217 s1), and instead use temporal fresh variables together with a corresponding map that assigns them to simpler expressions. E.g, the stack [5 + (s0 \u2217 s1), s2] would be represented as a tuple ([e1, s2], {e1 \u2192 5 + e0, e0 \u2192 s0 \u2217 s1}) where ei are fresh variables. To achieve this, we define the symbolic stack as a list of elements that can be numeric constant values, initial stack variables or fresh variables:"
        },
        {
            "heading": "Inductive sstack_val : Type :=",
            "text": "| Val (val: EVMWord) | InStackVar (var: nat) | FreshVar (var: nat). Definition sstack := list sstack_val.\nand the map that assigns meaning to fresh variables is a list that maps each fresh variable to a sstack_val, or to a compound expression:"
        },
        {
            "heading": "Inductive smap_val : Type :=",
            "text": "| SymBasicVal (val: sstack_val) | SymOp (opcode : stack_op_instr) (args : list sstack_val). Definition smap := list (nat\u2217smap_val). Finally, a symbolic state is defined as a SymState term where k is the size of the initial stack, maxid is the maximum id used for fresh variables (kept for efficiency), sstk is a symbolic stack, and m is the map of fresh variables.\nInductive sstate : Type := | SymState (k maxid: nat) (sstk: sstack) (m: smap).\nExample 2 (Symbolic execution). Given p1 \u2261\u201cPUSH1 0x5 SWAP2 MUL ADD\u201d and p2 \u2261 \u201cPUSH1 0x0 ADD MUL PUSH1 0x5 ADD\u201d, symbolically executing them with k=3 we obtain the symbolic states represented by sst1 \u2261 ([e\u20321, s2], {e\u20321 \u2192 e\u20320 + 5, e\u20320 \u2192 s1 \u2217 s0}) and sst2 \u2261 ([e2, s2], {e2 \u2192 5 + e1, e1 \u2192 e0 \u2217 s1, e0 \u2192 0 + s0}).\nNote that we impose some requirements on symbolic states to be valid. E.g., for any element i \u2192 v of the fresh variables map, all fresh variables that appear in v have smaller indices than i. We refer to these requirements as valid_sstate.\nGiven a symbolic (final) state and a concrete initial state, we can convert the symbolic state into a concrete one by replacing each si by its corresponding value, and evaluating the corresponding expressions (following their definition in the stack operations map). We have a function to perform this evaluation that takes the stack operations map as input:\nDefinition eval_sstate (in_st: state) (sst: sstate) (ops : stack_op_map) : option state := ...\nOur symbolic execution engine is a function that takes the size of the initial stack, a block, a map of stack operations, and generates a symbolic final state:\nDefinition sym_exec (p: block) (k: nat) (ops: stack_op_map) : option sstate := ...\nNote that we do not pass an initial symbolic state, but rather we construct it inside using k. Also, the result can be None in case of failure (the causes are the same as those of conc_interpreter).\nSoundness of sym_exec means that whenever it generates a symbolic state as a result, then the concrete execution from any stack of size k will succeed and produce a final state that agrees with the generated symbolic state:\nTheorem sym_exec_snd: \u2200 (p: block) (k: nat) (ops: stack_op_map) (sst: sstate),\nvalid_stack_op_map ops \u2192 sym_exec p k ops = Some sst \u2192 valid_sstate sst \u2227 \u2200 (in_st : state) (in_stk : stack), get_stack in_st = in_stk \u2192 length in_stk = k \u2192\n\u2203 (out_st : state), concr_int p in_st ops = Some out_st \u2227 eval_sstate in_st sst ops = Some out_st"
        },
        {
            "heading": "4.2 Simplification Rules",
            "text": "To capture equivalence of programs that have been optimized according to \u201crule simplifications\u201d (type (i) in Sect. 2) we need to include the same type of simplifications (see App. A in [10]) in our framework. Without this, we will capture EVM-blocks equivalence only for \u201cdata-stack equivalence optimizations\u201d (type (ii) in Sect. 2).\nAn optimization function takes as input a symbolic state, and tries to simplify it to an equivalent state. E.g, if a symbolic state includes ei \u2192 s3 + 0, we can replace it by ei \u2192 s3. The following is the type used for optimization functions:"
        },
        {
            "heading": "Definition optim := sstate \u2192 sstate\u2217bool.",
            "text": "Optimization functions never fail, i.e., in the worst case they return the same symbolic state. This is why the returned value includes a Boolean to indicate if any optimization has been applied, which is useful when composing optimizations later. The soundness of an optimization function can be stated as follows:\nDefinition optim_snd (opt: optim) : Prop := forall (sst: sstate) (sst\u2019: sstate) (b: bool), valid_sstate sst \u2192 opt sst = (sst\u2019, b) \u2192\n(valid_sstate sst\u2019 \u2227 forall (st st\u2019: state), eval_sstate st sst evm_stack_opm = Some st\u2019 \u2192\neval_sstate st sst\u2019 evm_stack_opm = Some st\u2019).\nWe have implemented and proven correct the most-used simplification rules (see App. A in [10]). E.g., there is an optimization function optimize_add_zero that rewrites expressions of the form E + 0 or 0 + E to E, and its soundness theorem is:\nTheorem optimize_add_zero_snd: optim_snd optimize_add_zero.\nExample 3. Consider again the blocks of Example 2. Using optimize_add_zero we can rewrite sst2 to sst2\u2032 \u2261 ([e2, s2], {e2 \u2192 5 + e1, e1 \u2192 e0 \u2217 s1, e0 \u2192 s0}), by replacing e0 \u2192 0 + s0 by e0 \u2192 s0. Note that the checker can be easily extended with new optimization functions, simply by providing a corresponding implementation and a soundness proof. Optimization functions can be combined to define simplification strategies, which are also functions of type optim. E.g., assuming that we have basic optimization functions f1,...,fn: (1) Apply f1,...,fn iteratively such that in iteration i function fi is applied as many times as it can be applied. (2) Apply each fi once in some order and repeat the process as many times as it can be applied. (3) Use the simplifications that were used by the optimizer (it needs to pass these hints)."
        },
        {
            "heading": "4.3 Stacks Equivalence Modulo Commutativity",
            "text": "We say that two symbolic stacks sst1 and sst2 are equivalent if for every possible initial concrete state st they evaluate to the same state. Formally:\nDefinition eq_sstate (sst1 sst2: sstate) (ops : stack_op_map) : Prop := \u2200 (st: state), eval_sstate st sst1 ops = eval_sstate st sst2 ops.\nHowever, this notion of semantic equivalence is not computable in general, and thus we provide an effective procedure to determine such equivalence by checking that at every position of the stack both contain \u201csimilar\u201d expressions:\nDefinition eq_sstate_chkr (sst1 sst2: sstate) (ops : stack_op_map) : bool := ...\nTo determine if two stack elements are similar, we follow their definition in the map if needed until we obtain a value that is not a fresh variable, and then either (1) both are equal constant values; (2) both are equal initial stack variables; or (3) both correspond to the same instruction and their arguments are (recursively) equivalent (taking into account the commutativity of operations). E.g., the stack elements (viewed as terms) DIV(MUL(s0,ADD(s1,s2)),0x16) and DIV(MUL(ADD(s2,s1),s0),0x16) are considered equivalent because the operations ADD and MUL are commutative.\nExample 4. eq_sstate_chkr fails to prove equivalence of sst1 and sst2 of Example 2, because, when comparing e2 and e\u20321, it will eventually check if 0+s0 and s0 are equivalent. It fails because the comparison is rather \u201csyntactic\u201d. However, it succeeds when comparing sst1 and sst2\u2019 (Example 3), which is a simplification of sst2.\nThis procedure is an approximation of the semantic equivalence, and it can produce false negatives if two symbolic states are equivalent but are expressed with different syntactic constructions. However, it is sound:\nTheorem eq_sstate_chkr_snd: \u2200 (sst1 sst2: sstate) (ops : stack_op_map), valid_stack_op_map ops \u2192 valid_sstate sst1 \u2192 valid_sstate sst2 \u2192\neq_sstate_chkr sst1 sst2 ops = true \u2192 eq_sstate sst1 sst2 ops. Note that we require the stack operations map to be valid in order to guarantee that the operations declared commutative in ops are indeed commutative. In order to reduce the number of false negatives, the simplification rules presented in Sect. 4.2 are very important to rewrite symbolic states into closer syntactic shapes that can be detected by eq_sstate_chkr.\nFinally, given all the pieces developed above, we can now define the block equivalence checker as follows:\nDefinition evm_eq_block_chkr (opt: optim) (p1 p2: block) (k: nat) : bool := match sym_exec p1 k evm_stack_opm with | None \u21d2 false | Some sst1 \u21d2\nmatch sym_exec p2 k evm_stack_opm with | None \u21d2 false | Some sst2 \u21d2 let (sst2\u2019, _) := opt sst1 in\nlet (sst1\u2019, _) := opt sst2 in eq_sstate_chkr sst1\u2019 sst2\u2019 evm_stack_opm\nend end.\nIt symbolically executes p1 and p2, simplifies the resulting symbolic states by applying optimization opt, and finally calls eq_sstate_chkr to check if the states are equivalent. Note that it is important to apply the optimization rules to both blocks, as the checker might apply optimization rules that were not applied by the external optimizer. This would lead to equivalent symbolic states with different shapes that will not be detected by the symbolic state equivalence checker."
        },
        {
            "heading": "5 Implementation and Experimental Evaluation",
            "text": "The different components of the tool have been implemented in Coq v8.15.2, together with complete proofs of all the theoretical results (more than 180 proofs in \u223c7000 lines of Coq code). The source code, executables and benchmarks can be found at https://github.com/costa-group/forves/tree/stack-only and the artifact at https://doi.org/10.5281/zenodo.7863483. The tool currently includes 15 simplification rules (see App. A in [10]). We have tried our implementation on the outcome of two optimization tools: (1) the standalone GASOL optimizer and, (2) the optimizer integrated within the official Solidity compiler solc. For (1), we have already fully automated the communication among the optimizer and checker and have been able to perform a thorough experimental evaluation. While in (2), the communication is more difficult to automate because the CFG of the original program can change after optimization, i.e., it can make crossblock optimization. Hence, in this case, we have needed human intervention to disable intra-block optimizations and obtain the blocks for the comparison (we plan to automate this usage in the future). For evaluating (2) we have used as benchmarks 1, 280 blocks extracted from the smart contracts in the semantic test suite of the solc compiler [6], succeeding to prove equivalence on 1, 045 out of them. We have checked that the fails are due to the use of optimization rules not yet implemented by us. As these blocks are obtained from the test suite of the official solc Solidity compiler, optimized using the solc optimizer, the good results on this set suggest the validity can be generalized to other optimizers. Now we describe in detail the experimental evaluation on (1) for which we have used as benchmarks 147, 798 blocks belonging to 96 smart contracts (see App. D in [10]).\nGASOL allows enabling/disabling the application of simplification rules and choosing an optimization criteria: GAS consumption or bytes SIZE (of the code) [11]; combining these parameters we obtain 4 different sets of pairs-ofblocks to be verified by our tool. From these blocks, we consider only those that were actually optimized by GASOL, i.e., the optimized version is syntactically different from the original one. In all the cases, the average size of blocks is 8 instructions. Table 1 summarizes our results, where each row corresponds to one\nsetting out of the 4 mentioned above: Column 1 includes the optimization criteria; Column 2 indicates if rule simplifications were applied by GASOL; Column 3 indicates how many pairs-of-blocks were checked; Columns 4-7 report the results of applying 2 versions of the checker, namely CHKR corresponds to the checker that only compares symbolic states and CHKRs corresponds to the checker that also applies all the implemented rule optimizations iteratively as much as they can be applied (see Sect. 4.2). For each we report the number of instances it proved equivalent and the total runtime in seconds. The experiments have been performed on a machine with an Intel i7-4790 at 3.60 GHz and 16GB of RAM.\nFor sets in which GASOL does not apply simplification rules (marked with \u00d7), both CHKR and CHKRs succeed to prove equivalence of all blocks. When simplifications are applied (marked with ), CHKRs succeeds in 99% of the blocks while CHKR ranges from 63% for GAS to 99% for SIZE. This difference is due to the fact that GASOL requires the application of rules to optimize more blocks wrt. GAS (\u223c 37% of the total) than wrt. SIZE (\u223c 1%). Moreover, all the blocks that CHKRs cannot prove equivalent have been optimized by GASOL using rules which are not currently implemented in the checker, so we predict a success rate of 100% when all the rules in App. A in [10] are integrated. Regarding time, CHKRs is 3\u20135 times slower than CHKR because of the overhead of applying rule optimizations, but it is still very efficient (all 147.798 instances are checked in 50.61 seconds). As a final comment, thanks to the checker we found a bug in the parsing component of GASOL, that treated the SGT bytecode as GT. The bug was directly reported to the GASOL developers and is already fixed [19]."
        },
        {
            "heading": "6 Conclusions, Related and Future Work",
            "text": "Our work provides the first tool able to formally verify the equivalence of jumpfree EVM blocks and has required the development of all components within the verification framework. The implementation is not tied to any specific tool and could be easily integrated within any optimization tool. Ongoing work focuses on handling memory and storage optimizations. This extension needs to support the execution of memory/storage operations at the level of the concrete interpreter, and design an efficient data structure to represent symbolic memory/storage. Full handling of blockchain-specific opcodes is straightforward, it only requires adding the corresponding implementations to the stack operations map evm_stack_opm. A more ambitious direction for future work is to handle cross-block optimizations.\nThere are two approaches to verify program optimizations, (1) verify the correctness of the optimizations and develop a verified tool, e.g., this is the case of optimizations within the CompCert certified compiler [24] and a good number of optimizations that have been formally verified in Coq [13,18,27,32,33], (2) or use a translation validation approach [20,34\u201336] in which rather than verifying the tool, each of the compiled/optimized programs are formally checked to be correct using a verified checker.We argue that translation validation [34] is the most appropriate approach for verifying EVM optimizations because: (i) EVM compilers\n(together with their built-in optimizers) are continuously evolving to adjust to modifications in the rather new blockchain programming languages, (ii) existing EVM optimizers use external components such as SMT solvers to search for the optimized code and verifying an SMT solver would require a daunting effort, (iii) we aim at generality of our tool rather than restricting ourselves to a specific optimizer and, as already explained, the design of our checker has been done having generality and extensibility in mind, so that new optimizations can be easily incorporated. Finally, it is worth mentioning the KEVM framework [21], which in principle could be the basis for verifying optimizations as well. However, we have chosen to develop it in Coq due to its maturity.\nReferences\n1. https://www.certora.com/ 2. https://veridise.com/ 3. https://www.apriorit.com/ 4. https://consensys.net/ 5. https://www.dedaub.com/ 6. https://github.com/ethereum/solidity/tree/develop/test/libsolidity/\nsemanticTests/externalContracts 7. Bedrock Bit Vectors (bbv) (2018). https://github.com/mit-plv/bbv 8. PausableERC20 Contract (2020). https://etherscan.io/address/\n0x32E6C34Cd57087aBBD59B5A4AECC4cB495924356 9. The solc optimizer (2021). https://docs.soliditylang.org/en/v0.8.7/internals/\noptimizer.html 10. Albert, E., Genaim, S., Kirchner, D., Martin-Martin, E.: Formally Verified EVM\nBlock-Optimizations (Extended Version). https://costa.fdi.ucm.es/papers/costa/ AlbertGKMM23_extended.pdf 11. Albert, E., Gordillo, P., Hern\u00e1ndez-Cerezo, A., Rubio, A.: A Max-SMT superoptimizer for EVM handling memory and storage. In: TACAS 2022. LNCS, vol. 13243, pp. 201\u2013219. Springer, Cham (2022). https://doi.org/10.1007/978-3-03099524-9_11 12. Albert, E., Gordillo, P., Rubio, A., Schett, M.A.: Synthesis of super-optimized smart contracts using max-SMT. In: Lahiri, S.K., Wang, C. (eds.) CAV 2020. LNCS, vol. 12224, pp. 177\u2013200. Springer, Cham (2020). https://doi.org/10.1007/ 978-3-030-53288-8_10 13. Barri\u00e8re, A., Blazy, S., Fl\u00fcckiger, O., Pichardie, D., Vitek, J.: Formally verified speculation and deoptimization in a JIT compiler. Proc. ACM Program. Lang. 5(POPL), 1\u201326 (2021). https://doi.org/10.1145/3434327 14. Bernardi, T., et al.: Preventing reentrancy bugs - another use case for formal verification (2020). https://www.certora.com/blog/reentrancy.html 15. Bizga, A.: A hackers\u2019 dream payday: Ledf.me and uniswap lose $25 million worth of cryptocurrency (2020). https://securityboulevard.com/2020/04/a-hackers-dreampayday-ledf-me-and-uniswap-lose-25-million-worth-of-cryptocurrency/. [Online; accessed 11-May-2020] 16. Buterin, V.: CRITICAL UPDATE Re: DAO vulnerability (2016). https://blog. ethereum.org/2016/06/17/critical-update-re-dao-vulnerability/. Accessed 2-July2017\n17. Daian, P.: Analysis of the DAO exploit (2016). http://hackingdistributed.com/ 2016/06/18/analysis-of-the-dao-exploit/ 18. Demange, D., Pichardie, D., Stefanesco, L.: Verifying fast and sparse SSA-based optimizations in Coq. In: Franke, B. (ed.) CC 2015. LNCS, vol. 9031, pp. 233\u2013252. Springer, Heidelberg (2015). https://doi.org/10.1007/978-3-662-46663-6_12 19. elexcere: SGT and GT order when parsing. https://github.com/costa-group/gasoloptimizer/commit/fd78e126c23f192ed6c54aea713b5c94d3c943f5 20. Gourdin, L., Boulm\u00e9, S.: Certifying assembly optimizations in Coq by symbolic execution with hash-consing, p. 2 (2021) 21. Hildenbrandt, E., et al.: KEVM: a complete formal semantics of the ethereum virtual machine. In: 31st IEEE Computer Security Foundations Symposium, CSF 2018, Oxford, United Kingdom, July 9\u201312, 2018, pp. 204\u2013217. IEEE Computer Society (2018). https://doi.org/10.1109/CSF.2018.00022 22. Hirai, Y.: Defining the ethereum virtual machine for interactive theorem provers. In: Brenner, M., Rohloff, K., Bonneau, J., Miller, A., Ryan, P.Y.A., Teague, V., Bracciali, A., Sala, M., Pintore, F., Jakobsson, M. (eds.) FC 2017. LNCS, vol. 10323, pp. 520\u2013535. Springer, Cham (2017). https://doi.org/10.1007/978-3-31970278-0_33 23. ivan71kmayshan27: Coq formalisation of the Ethereum Virtual Machine (WIP) (2020). https://github.com/ivan71kmayshan27/coq-evm 24. Leroy, X.: Formal verification of a realistic compiler. Commun. ACM 52(7), 107\u2013 115 (2009). https://doi.org/10.1145/1538788.1538814 25. Lopes, N.P., Menendez, D., Nagarakatte, S., Regehr, J.: Practical verification of peephole optimizations with alive. Commun. ACM 61(2), 84\u201391 (2018). https:// doi.org/10.1145/3166064 26. Massalin, H.: Superoptimizer - a look at the smallest program. In: Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS II), pp. 122\u2013126 (1987). https://dl. acm.org/citation.cfm?id=36194 27. Monniaux, D., Six, C.: Simple, light, yet formally verified, global common subexpression elimination and loop-invariant code motion. In: Henkel, J., Liu, X. (eds.) LCTES \u201921: 22nd ACM SIGPLAN/SIGBED International Conference on Languages, Compilers, and Tools for Embedded Systems, Virtual Event, Canada, 22 June, 2021, pp. 85\u201396. ACM (2021). https://doi.org/10.1145/3461648.3463850 28. Mulligan, D.P., Owens, S., Gray, K.E., Ridge, T., Sewell, P.: Lem: reusable engineering of real-world semantics. ACM SIGPLAN Notices 49(9), 175\u2013188 (2014) 29. Nagele, J., Schett, M.A.: Blockchain superoptimizer. In: Preproceedings of 29th International Symposium on Logic-based Program Synthesis and Transformation (LOPSTR 2019) (2019). https://arxiv.org/abs/2005.05912 30. Palmer, D.: Spankchain loses $40k in hack due to smart contract bug (2018). https://www.coindesk.com/spankchain-loses-40k-in-hack-due-to-smart-contractbug. Accessed 11 May 2020 31. Sasnauskas, R., et al.: Souper: A Synthesizing Superoptimizer. arXiv:1711.04422 [cs], November 2017 32. Six, C., Boulm\u00e9, S., Monniaux, D.: Certified and efficient instruction scheduling: application to interlocked VLIW processors. Proc. ACM Program. Lang. 4(OOPSLA), 129:1\u2013129:29 (2020). https://doi.org/10.1145/3428197\n33. Six, C., Gourdin, L., Boulm\u00e9, S., Monniaux, D., Fasse, J., Nardino, N.: Formally verified superblock scheduling. In: Popescu, A., Zdancewic, S. (eds.) CPP \u201922: 11th ACM SIGPLAN International Conference on Certified Programs and Proofs, Philadelphia, PA, USA, January 17\u201318, 2022, pp. 40\u201354. ACM (2022). https://doi. org/10.1145/3497775.3503679 34. Tristan, J., Leroy, X.: Formal verification of translation validators: a case study on instruction scheduling optimizations. In: Necula, G.C., Wadler, P. (eds.) Proceedings of the 35th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2008, San Francisco, California, USA, January 7\u201312, 2008, pp. 17\u201327. ACM (2008). https://doi.org/10.1145/1328438.1328444 35. Tristan, J., Leroy, X.: Verified validation of lazy code motion. In: Hind, M., Diwan, A. (eds.) Proceedings of the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2009, Dublin, Ireland, June 15\u201321, 2009, pp. 316\u2013326. ACM (2009). https://doi.org/10.1145/1542476.1542512 36. Tristan, J., Leroy, X.: A simple, verified validator for software pipelining. In: Hermenegildo, M.V., Palsberg, J. (eds.) Proceedings of the 37th ACM SIGPLANSIGACT Symposium on Principles of Programming Languages, POPL 2010, Madrid, Spain, January 17\u201323, 2010, pp. 83\u201392. ACM (2010). https://doi.org/ 10.1145/1706299.1706311 37. Turley, C.: imBTC uniswap pool drained for $300k in ETH (2020). https://defirate. com/imbtc-uniswap-hack/. Accessed 11 May 2020 38. Wood, G.: Ethereum: A secure decentralised generalised transaction ledger (Berlin version 8fea825 - 2022\u201308-22) (2022)\nOpen Access This chapter is licensed under the terms of the Creative Commons Attribution 4.0 International License (http://creativecommons.org/licenses/by/4.0/), which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license and indicate if changes were made.\nThe images or other third party material in this chapter are included in the chapter\u2019s Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the chapter\u2019s Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder."
        }
    ],
    "title": "Formally Verified EVM Block-Optimizations",
    "year": 2023
}