{
    "abstractText": "The existence of universal quantum computers has been theoretically well established. However, building up a real quantum computer system not only relies on the theory of universality, but also needs methods to satisfy requirements on other features, such as programmability, modularity, scalability, etc. To this end, here we study the recently proposed model of quantum von Neumann architecture by putting it in a practical and broader setting, namely, the hierarchical design of a computer system. We analyze the structures of quantum CPU and quantum control units and draw their connections with computational advantages. We also point out that a recent demonstration of our model would require less than 20 qubits.",
    "authors": [
        {
            "affiliations": [],
            "name": "Yuan-Ting Liu"
        },
        {
            "affiliations": [],
            "name": "Kai Wang"
        },
        {
            "affiliations": [],
            "name": "Yuan-Dong Liu"
        },
        {
            "affiliations": [],
            "name": "Dong-Sheng Wang"
        }
    ],
    "id": "SP:49d35529bee7cd306a61736697279f73101caeae",
    "references": [
        {
            "authors": [
                "R.P. Feynman"
            ],
            "title": "Simulating physics with computers",
            "venue": "Int. J. Theor. Phys",
            "year": 1982
        },
        {
            "authors": [
                "L.V. Bertalanffy"
            ],
            "title": "The History and Status of General Systems Theory. In Trends in General Systems",
            "year": 1972
        },
        {
            "authors": [
                "N. Wiener"
            ],
            "title": "Cybernetics: Or, Control and Communication in the Animal and the Machine",
            "venue": "MIT Press: Paris, France,",
            "year": 1948
        },
        {
            "authors": [
                "S. Arora",
                "B. Barak"
            ],
            "title": "Computational Complexity: A Modern Approach",
            "year": 2009
        },
        {
            "authors": [
                "D. Deutsch"
            ],
            "title": "Quantum theory, the Church-Turing principle and the universal quantum computer",
            "venue": "In Proceedings of the Royal Society of London A: Mathematical, Physical and Engineering Sciences; The Royal Society: London,",
            "year": 1985
        },
        {
            "authors": [
                "S. Lloyd"
            ],
            "title": "Universal quantum simulators",
            "venue": "Science",
            "year": 1996
        },
        {
            "authors": [
                "M.A. Nielsen",
                "I.L. Chuang"
            ],
            "title": "Quantum Computation and Quantum Information",
            "venue": "Entropy 2023,",
            "year": 2000
        },
        {
            "authors": [
                "D.M. Harris",
                "S.L. Harris"
            ],
            "title": "Digital Design and Computer Architecture; Elsevier: Amsterdam",
            "venue": "The Netherlands,",
            "year": 2013
        },
        {
            "authors": [
                "K.M. Svore",
                "A.V. Aho",
                "A.W. Cross",
                "I. Chuang",
                "I.L. Markov"
            ],
            "title": "A layered software architecture for quantum computing design tools",
            "year": 2006
        },
        {
            "authors": [
                "T. H\u00e4ner",
                "D.S. Steiger",
                "K. Svore",
                "M. Troyer"
            ],
            "title": "A software methodology for compiling quantum programs",
            "venue": "Quantum Sci. Technol. 2018,",
            "year": 2050
        },
        {
            "authors": [
                "M. Mariantoni",
                "H. Wang",
                "T. Yamamoto",
                "M. Neeley",
                "R.C. Bialczak",
                "Y. Chen",
                "M. Lenander",
                "E. Lucero",
                "A.D. O\u2019Connell",
                "D Sank"
            ],
            "title": "Implementing the Quantum von Neumann Architecture with Superconducting Circuits",
            "venue": "Science",
            "year": 2011
        },
        {
            "authors": [
                "M.F. Brandl"
            ],
            "title": "A Quantum von Neumann Architecture for Large-Scale Quantum Computing",
            "venue": "arXiv 2017,",
            "year": 2017
        },
        {
            "authors": [
                "M. Kjaergaard",
                "M.E. Schwartz",
                "A. Greene"
            ],
            "title": "Programming a quantum computer with quantum instructions",
            "venue": "arXiv 2020,",
            "year": 2020
        },
        {
            "authors": [
                "M.D. Choi"
            ],
            "title": "Completely positive Linear Maps on Complex Matrices",
            "venue": "Linear Algebra Appl",
            "year": 1975
        },
        {
            "authors": [
                "D.S. Wang"
            ],
            "title": "Choi states, symmetry-based quantum gate teleportation, and stored-program quantum computing",
            "venue": "Phys. Rev. A",
            "year": 2020
        },
        {
            "authors": [
                "D.S. Wang"
            ],
            "title": "A prototype of quantum von Neumann architecture",
            "venue": "Commun. Theor. Phys. 2022,",
            "year": 2022
        },
        {
            "authors": [
                "D.S. Wang"
            ],
            "title": "Universal resources for quantum computing",
            "venue": "arXiv 2023,",
            "year": 2023
        },
        {
            "authors": [
                "D.S. Wang"
            ],
            "title": "A family of quantum von neumann architecture",
            "venue": "arXiv 2023,",
            "year": 2023
        },
        {
            "authors": [
                "J. von Neumann"
            ],
            "title": "First draft of a report on the EDVAC",
            "venue": "IEEE Ann. Hist. Comput",
            "year": 1993
        },
        {
            "authors": [
                "K. Kraus"
            ],
            "title": "States, Effects, and Operations: Fundamental Notions of Quantum Theory; Lecture Notes in Physics",
            "year": 1983
        },
        {
            "authors": [
                "A. Barenco",
                "C.H. Bennett",
                "R. Cleve",
                "D.P. DiVincenzo",
                "N. Margolus",
                "P. Shor",
                "T. Sleator",
                "J.A. Smolin",
                "H. Weinfurter"
            ],
            "title": "Elementary gates for quantum computation",
            "venue": "Phys. Rev. A",
            "year": 1995
        },
        {
            "authors": [
                "D. Gottesman",
                "I.L. Chuang"
            ],
            "title": "Demonstrating the viability of universal quantum computation using teleportation and single-qubit operations",
            "venue": "Nature",
            "year": 1999
        },
        {
            "authors": [
                "G. Brassard",
                "P. Hoyer",
                "M. Mosca",
                "A. Tapp"
            ],
            "title": "Quantum amplitude amplification and estimation",
            "venue": "Contem. Mathemat",
            "year": 2002
        },
        {
            "authors": [
                "Y. Yang",
                "R. Renner",
                "G. Chiribella"
            ],
            "title": "Optimal Universal Programming",
            "venue": "Unitary Gates. Phys. Rev. Lett",
            "year": 2020
        },
        {
            "authors": [
                "C.H. Bennett",
                "G. Brassard",
                "C. Cr\u00e9peau",
                "R. Jozsa",
                "A. Peres",
                "W.K. Wootters"
            ],
            "title": "Teleporting an unknown quantum state via dual classical and Einstein-Podolsky-Rosen channels",
            "venue": "Phys. Rev. Lett",
            "year": 1993
        },
        {
            "authors": [
                "S.L. Braunstein",
                "G.M. D\u2019Ariano",
                "G.J. Milburn",
                "M.F. Sacchi"
            ],
            "title": "Universal Teleportation with a Twist",
            "venue": "Phys. Rev. Lett",
            "year": 2000
        },
        {
            "authors": [
                "D.S. Wang"
            ],
            "title": "Quantum computation by teleportation and symmetry",
            "venue": "Int. J. Mod. Phys. B 2019,",
            "year": 1930
        },
        {
            "authors": [
                "G. Chiribella",
                "G.M. D\u2019Ariano",
                "P. Perinotti"
            ],
            "title": "Transforming quantum operations: Quantum supermaps",
            "venue": "Europhys. Lett",
            "year": 2008
        },
        {
            "authors": [
                "G. Chiribella",
                "G.M. D\u2019Ariano",
                "P. Perinotti"
            ],
            "title": "Theoretical framework for quantum networks",
            "venue": "Phys. Rev. A",
            "year": 2009
        },
        {
            "authors": [
                "K. Wang",
                "D.S. Wang"
            ],
            "title": "Quantum circuit simulation of superchannels",
            "venue": "New J. Phys. 2023,",
            "year": 2023
        },
        {
            "authors": [
                "A.M. Childs",
                "N. Wiebe"
            ],
            "title": "Hamiltonian Simulation Using Linear Combinations of Unitary Operations",
            "venue": "Quant. Inf. Comput",
            "year": 2012
        },
        {
            "authors": [
                "G.L. Long"
            ],
            "title": "Duality Quantum Computing and Duality Quantum Information Processing",
            "venue": "Int. J. Theor. Phys",
            "year": 2011
        },
        {
            "authors": [
                "M. Araujo",
                "A. Feix",
                "F. Costa",
                "C. Brukner"
            ],
            "title": "Quantum circuits cannot control unknown operations",
            "venue": "New J. Phys",
            "year": 2014
        },
        {
            "authors": [
                "E. Bernstein",
                "U. Vazirani"
            ],
            "title": "Quantum complexity theory",
            "venue": "SIAM J. Comput",
            "year": 1997
        },
        {
            "authors": [
                "J.M. Myers"
            ],
            "title": "Can a Universal Quantum Computer Be Fully Quantum",
            "venue": "Phys. Rev. Lett",
            "year": 1997
        },
        {
            "authors": [
                "Y. Shi"
            ],
            "title": "Remarks on universal quantum computer",
            "venue": "Phys. Lett. A",
            "year": 2002
        },
        {
            "authors": [
                "A. Molina",
                "J. Watrous"
            ],
            "title": "Revisiting the simulation of quantum Turing machines by quantum circuits",
            "venue": "Proc. R. Soc. A",
            "year": 2019
        },
        {
            "authors": [
                "D.S. Wang"
            ],
            "title": "A local model of quantum Turing machines",
            "venue": "Quant. Inf. Comput",
            "year": 2020
        },
        {
            "authors": [
                "C. Yuan",
                "A. Villanyi",
                "M. Carbin"
            ],
            "title": "Quantum control machine: The limits of quantum programs as data",
            "venue": "arXiv 2023,",
            "year": 2023
        },
        {
            "authors": [
                "R. Raussendorf",
                "H.J. Briegel"
            ],
            "title": "A One-Way Quantum Computer",
            "venue": "Phys. Rev. Lett",
            "year": 2001
        },
        {
            "authors": [
                "C.H. Bennett",
                "G. Brassard"
            ],
            "title": "Quantum cryptography: Public key distribution and coin tossing",
            "venue": "In Proceedings of the IEEE International Conference on Computers, Systems and Signal Processing, Bangalore, India,",
            "year": 1984
        },
        {
            "authors": [
                "A. Gheorghiu",
                "T. Vidick"
            ],
            "title": "Computationally-secure and composable remote state preparation",
            "venue": "arXiv 2019,",
            "year": 1904
        },
        {
            "authors": [
                "A. Gheorghiu",
                "T. Kapourniotis",
                "E. Kashefi"
            ],
            "title": "Verification of Quantum Computation: An Overview of Existing Approaches",
            "venue": "Theory Comput. Syst",
            "year": 2019
        },
        {
            "authors": [
                "J. Morris",
                "V. Saggio",
                "A. Gocanin",
                "B. Dakic"
            ],
            "title": "Quantum Verification and Estimation with Few Copies",
            "venue": "Adv. Quantum Technol. 2022,",
            "year": 2022
        },
        {
            "authors": [
                "G. Chiribella",
                "G.M. D\u2019Ariano",
                "P. Perinotti",
                "M.F. Sacchi"
            ],
            "title": "Efficient Use of Quantum Resources for the Transmission of a Reference Frame",
            "venue": "Phys. Rev. Lett",
            "year": 2004
        },
        {
            "authors": [
                "A. Broadbent",
                "J. Fitzsimons",
                "E. Kashefi"
            ],
            "title": "Universal blind quantum computation",
            "venue": "In Proceedings of the 50th Annual Symposium on Foundations of Computer Science IEEE Computer Society, Los Alamitos, CA, USA,",
            "year": 2009
        },
        {
            "authors": [
                "A.M. Childs",
                "D.W. Leung",
                "M.A. Nielsen"
            ],
            "title": "Unified derivations of measurement-based schemes for quantum computation",
            "venue": "Phys. Rev. A",
            "year": 2005
        },
        {
            "authors": [
                "D.S. Wang"
            ],
            "title": "A comparative study of universal quantum computing models: Towards a physical unification",
            "venue": "Quantum Eng. 2021,",
            "year": 2021
        },
        {
            "authors": [
                "C.M. Dawson",
                "M.A. Nielsen"
            ],
            "title": "The Solovay-Kitaev algorithm",
            "venue": "Quantum Inf. Comput",
            "year": 2006
        },
        {
            "authors": [
                "D.S. Wang",
                "B.C. Sanders"
            ],
            "title": "Quantum circuit design for accurate simulation of qudit channels",
            "venue": "New J. Phys. 2015,",
            "year": 2015
        },
        {
            "authors": [
                "E. Farhi",
                "J. Goldstone",
                "S. Gutmann"
            ],
            "title": "A quantum approximate optimization algorithm",
            "venue": "arXiv 2014,",
            "year": 2014
        },
        {
            "authors": [
                "P. Mehta",
                "M. Bukov",
                "C.H. Wang",
                "A.G.R. Day",
                "C. Richardson",
                "C.K. Fisher",
                "D.J. Schwab"
            ],
            "title": "A high-bias, low-variance introduction to Machine Learning for physicists",
            "venue": "Phys. Rep",
            "year": 2019
        },
        {
            "authors": [
                "G. Chiribella",
                "G.M. D\u2019Ariano",
                "P. Perinotti"
            ],
            "title": "Memory Effects in Quantum Channel Discrimination",
            "venue": "Phys. Rev. Lett",
            "year": 2008
        },
        {
            "authors": [
                "G. Gutoski",
                "J. Watrous"
            ],
            "title": "Toward a general theory of quantum games",
            "venue": "In Proceedings of the 39th ACM Symposium on Theory of Computing, San Diego, CA, USA,",
            "year": 2007
        },
        {
            "authors": [
                "D. Lim",
                "J.F. Doriguello",
                "P. Rebentrost"
            ],
            "title": "Quantum algorithm for robust optimization via stochastic-gradient online learning",
            "venue": "arXiv 2023,",
            "year": 2023
        },
        {
            "authors": [
                "V. Dunjko",
                "H.J. Briegel"
            ],
            "title": "Machine learning & artificial intelligence in the quantum domain: a review of recent progress",
            "venue": "Rep. Prog. Phys. 2018,",
            "year": 2018
        },
        {
            "authors": [
                "G. Verdon",
                "J. Pye",
                "M. Broughton"
            ],
            "title": "A Universal Training Algorithm for Quantum Deep Learning",
            "venue": "arXiv 2018,",
            "year": 2018
        },
        {
            "authors": [
                "M. Benedetti",
                "E. Lloyd",
                "S. Sack",
                "M. Fiorentini"
            ],
            "title": "Parameterized quantum circuits as machine learning models",
            "venue": "Quantum Sci. Technol. 2019,",
            "year": 2019
        },
        {
            "authors": [
                "H.Y. Huang",
                "R. Kueng",
                "J. Preskill"
            ],
            "title": "Information-Theoretic Bounds on Quantum Advantage in Machine Learning",
            "venue": "Phys. Rev. Lett. 2021,",
            "year": 1905
        },
        {
            "authors": [
                "J.M. Martyn",
                "Z.M. Rossi",
                "A.K. Tan",
                "I.L. Chuang"
            ],
            "title": "Grand Unification of Quantum Algorithms",
            "venue": "PRX Quantum 2021,",
            "year": 2021
        },
        {
            "authors": [
                "M.C. Caro"
            ],
            "title": "Learning Quantum Processes and Hamiltonians via the Pauli Transfer Matrix",
            "venue": "arXiv 2022,",
            "year": 2022
        },
        {
            "authors": [
                "G. T\u00f3th",
                "I. Apellaniz"
            ],
            "title": "Quantum metrology from a quantum information science perspective",
            "venue": "J. Phys. A Math. Theor",
            "year": 2014
        },
        {
            "authors": [
                "A.S. Holevo"
            ],
            "title": "Problems in the mathematical theory of quantum communication channels",
            "venue": "Rep. Math. Phys",
            "year": 1977
        },
        {
            "authors": [
                "V. Giovannetti",
                "L. Maccone",
                "T. Morimae",
                "T.G. Rudolph"
            ],
            "title": "Efficient Universal Blind Quantum Computation",
            "venue": "Phys. Rev. Lett. 2013,",
            "year": 2013
        },
        {
            "authors": [
                "C. Cr\u00e9peau",
                "D. Gottesman",
                "A. Smith"
            ],
            "title": "Secure multi-party quantum computation",
            "venue": "In Proceedings of the STOC\u201902: Proceedings 34rd Annual ACM Symposium Theory of Computing,",
            "year": 2002
        },
        {
            "authors": [
                "P. Benioff"
            ],
            "title": "The computer as a physical system: A microscopic quantum mechanical Hamiltonian model of computers as a represented by Turing machines",
            "venue": "J. Stat. Phys. 1980,",
            "year": 1980
        },
        {
            "authors": [
                "H. Tajima",
                "N. Shiraishi",
                "K. Saito"
            ],
            "title": "Uncertainty Relations in Implementation of Unitary Operations",
            "venue": "Phys. Rev. Lett. 2018,",
            "year": 2018
        },
        {
            "authors": [
                "H. Tajima",
                "N. Shiraishi",
                "K. Saito"
            ],
            "title": "Coherence cost for violating conservation laws",
            "venue": "Phys. Rev. Res. 2020,",
            "year": 2020
        },
        {
            "authors": [
                "G. Chiribella",
                "Y. Yang",
                "R. Renner"
            ],
            "title": "Fundamental Energy Requirement of Reversible Quantum Operations",
            "venue": "Phys. Rev. X 2021,",
            "year": 2021
        },
        {
            "authors": [
                "D.P. DiVincenzo"
            ],
            "title": "The Physical Implementation of Quantum Computation",
            "venue": "arXiv 2000,",
            "year": 2077
        },
        {
            "authors": [
                "H. Levine",
                "A. Keesling",
                "G. Semeghini",
                "A. Omran",
                "T.T. Wang",
                "S. Ebadi",
                "H. Bernien",
                "M. Greiner",
                "V. Vuleti\u0107",
                "H Pichler"
            ],
            "title": "Parallel Implementation of High-Fidelity Multiqubit Gates with Neutral Atoms",
            "venue": "Phys. Rev. Lett",
            "year": 2019
        },
        {
            "authors": [
                "M. Khazali",
                "K. M\u00f8lmer"
            ],
            "title": "Fast Multiqubit Gates by Adiabatic Evolution in Interacting Excited-State Manifolds of Rydberg Atoms and Superconducting Circuits",
            "venue": "Phys. Rev. X 2020,",
            "year": 2020
        },
        {
            "authors": [
                "Y. Kim",
                "A. Morvan",
                "L.B. Nguyen",
                "R.K. Naik",
                "C. J\u00fcnger",
                "L. Chen",
                "J.M. Kreikebaum",
                "D.I. Santiago",
                "I. Siddiqi"
            ],
            "title": "High-fidelity three-qubit iToffoli gate for fixed-frequency superconducting qubits",
            "venue": "Nat. Phys. 2022,",
            "year": 2022
        },
        {
            "authors": [
                "Q. Wang",
                "R. Li",
                "M. Ying"
            ],
            "title": "Equivalence checking of sequential quantum circuits",
            "venue": "IEEE Trans. Comput.-Aided Des. Integr. Circuits Syst. 2022,",
            "year": 2022
        },
        {
            "authors": [
                "D. Deutsch"
            ],
            "title": "Quantum mechanics near closed timelike lines",
            "venue": "Phys. Rev. D",
            "year": 1991
        }
    ],
    "sections": [
        {
            "text": "Citation: Liu, Y.-T.; Wang, K.; Liu,\nY.-D.; Wang, D.-S. A Survey of\nUniversal Quantum von Neumann\nArchitecture. Entropy 2023, 25, 1187.\nhttps://doi.org/10.3390/e25081187\nAcademic Editor: Rosario Lo Franco\nReceived: 5 July 2023\nRevised: 31 July 2023\nAccepted: 3 August 2023\nPublished: 9 August 2023\nCopyright: \u00a9 2023 by the authors.\nLicensee MDPI, Basel, Switzerland.\nThis article is an open access article\ndistributed under the terms and\nconditions of the Creative Commons\nAttribution (CC BY) license (https://\ncreativecommons.org/licenses/by/\n4.0/).\nKeywords: quantum computing; von Neumann architecture; quantum entanglement"
        },
        {
            "heading": "1. Introduction",
            "text": "At the origin of quantum computing, physicists such as R. Feynman and D. Deustch realized that universal quantum computing is possible [1]. It is important to note that, at that time, classical computers were only just being built. After decades of evolution, classical computers have become more and more advanced. In the meantime, the field of quantum information science grows, and nowadays physicists and engineers can control quantum processors of tens or even hundreds of qubits. As the foundation of computation, physics is not only crucial to guide the finding of elementary devices such as transistors, but also crucial to set the principles of computation regarding space, time, energy, efficiency, etc. However, physics itself is not enough. For the building of classical computers, some other disciplines of study also played essential roles, in particular, the theories of information, systems, and control. Information theory, established by C. Shannon [2], borrows ideas from thermodynamics but it reveals far more properties of information. The system theory, pioneered by von Bertalanffy [3], has more connections with many-body physics and it emphasizes more the structure, correlation, etc., rather than the individual participant. Control theory, from N. Wiener [4], studies the interplay between the controller and the target system to achieve a certain goal. These studies go beyond the traditional scope of physics. Together with computational complexity theory [5], they form the theoretical foundation to make classical computers real. Modern quantum physics, especially quantum information science, is not a traditional physics; instead, it shares features of engineering. It does not only study systems passively, namely, only studying those that exist naturally, but also actively studies specific systems, e.g., how to make an artificial system for a certain purpose. Therefore, it needs both physicists and engineers to make quantum computers real. The power of quantum computing is currently mainly demonstrated by quantum algorithms. Given a problem, a quantum algorithm is constructed in the framework of a universal quantum computing model, such as the circuit model [6], or a Hamiltonian-based model [1,7]. An algorithm is realized by a sequence of elementary operations available in a model, such as CNOT gates and qubit gates [8]. However, for the modern design of\nEntropy 2023, 25, 1187. https://doi.org/10.3390/e25081187 https://www.mdpi.com/journal/entropy\ncomputers [9], the above is not enough to guide the design of a real quantum computer. A computer system is far more complicated than a physical experimental device. From the hierarchy of the layers of abstraction, the physical devices and gates are at the bottom layer of the hierarchy, while algorithms and applications are at the top; see Figure 1. There is a gap between them. Some investigations on quantum high-level programming and layered design have been taken, e.g., Refs. [10,11]. Filling the gap, although it may take decades, is necessary to build real quantum computing systems.\nTo this end, we need to understand how to satisfy the requirements of programmability, modularity, automation, etc., as well as the basic requirement of universality. A computing device or system is programmable if it can realize a broad range of programs (or algorithms) without almost any change of its physical structure. That is, programs can be loaded as software. A system is modular if the connections between different parts of it, known as units, are device-independent, namely, a unit can be detached or replaced without affecting other units. A system is automate if it can realize hierarchical or concatenated tasks without actively interfering in the middle. Realizing these features has greatly benefited modern computers and also engineering. With the methodology above, in this work we present a survey of quantum von Neumann architecture. There is some exploration on this subject in the literature [12\u201314]; however, it did not present a universal model with explicit stored quantum programs. Based on channel-state duality [15], a universal model for quantum von Neumann architecture has recently been developed [16\u201319]. In this work, we further study it by focusing on a few subjects, especially the structure of the quantum CPU, also known as QPU, and the structure of the quantum control unit (QCU). We also survey the elementary requirements for a near-term demonstration of this architecture. Our study is purely theoretical without referring to any actual quantum computing platforms. With this survey, we hope to explain some details of the model and identify some research directions to investigate in the near future. This work contains the following parts. In Section 2, we first review the principle of classical computers. We then review the basics of quantum computing in Section 3. We then survey the basic operations in quantum von Neumann architecture (QvN) in Section 4. After this, in Section 5, we discuss the features of our model compared with other quantum computing models. In Section 6, we survey algorithm designs in QvN and their possible computational advantages. We then study the basic requirement for an NISQ implementation of QvN in Section 7. We then conclude in Section 8 with open questions and perspectives."
        },
        {
            "heading": "2. Classical Computers",
            "text": "It would be interesting to review how a classical computer is built, mainly regarding their underlying principles. This will help to understand the current situations for quantum\ncomputing. In this section, we start from a few universal computing models and then move on to the layers of structures for the design of a modern computer."
        },
        {
            "heading": "2.1. Computing Models",
            "text": "A universal computing model is a framework to design algorithms for solving problems. The most well-known model is the circuit model based on Boolean logic, while at the same time there are a few equivalent ones, including the Turing machine, cellular automata, etc. Their logic building blocks are different but can simulate each other efficiently [5]. We start from the circuit model. Information or data are represented as bit strings, and the basic Boolean gates on bits include NOT, AND, NAND, OR, etc. An important theorem is that there exist a universal set of gates so that any Boolean function, f : {0, 1}n 7\u2192 {0, 1}, can be expressed as a sequence of these gates, forming a circuit. Such circuits are not invertible as some bits are lost, but they can be made invertible by using the Toffoli gate to simulate them. The Toffoli gate is\nTof = P0 \u2297 1 + P1 \u2297CNOT, (1)\nfor the controlled-not gate\nCNOT = P0 \u2297 1 + P1 \u2297NOT, (2)\nwith P0 (P1) as a projection on bit-value 0 (1). Despite this, a circuit is often designed using the Boolean gates. The circuit model is fundamental for the characterization of universality and also the design of algorithms. However, it is still abstract without specifying components for building a real computer. The foundation for the design of modern computers is the so-called von Neumann architecture (vNA) [20], which contains a few modular parts, including the central processing unit (CPU), memory, control, internet, and in/out units. All these can be described by the circuit model, but it is crucial to separate them. In particular, the stored programs in the memory unit are essential for realizing universality and programmability. Namely, a stored program as bit strings can be read and then loaded to the programmable CPU without physically changing the structure of the CPU in order to run different algorithms (i.e., programs). Formally, this realizes\nG(~b\u00d7~bA) = A~b\u00d7~b\u2032A, (3)\nfor G as the CPU,~b as an input bit string, and~bA as the bit-string encoding of an algorithm A. The desired output is A~b. The final~b\u2032A is often ignored but can be used to recover~bA. The program also contains control signals for precise timing and the addressing of data and operations or commands. Although the internet was invented later than the vNA itself, and there are also many types of communication, the download and upload of data is an indispensable part of vNA. Although it seems vNA is a step closer to a real computer than the circuit model itself, vNA is still an abstract model. A modern computer is far more complicated than the abstraction of vNA. In particular, it follows a hierarchical design of layers of abstraction, with the physical logic devices at the bottom and algorithms and applications at the top. For instance, there are many types of memory, such as internal storage, hard disk (as external storage), and flash memory, etc., playing distinct roles in computers and also microchips."
        },
        {
            "heading": "2.2. Hierarchical Design",
            "text": "The hierarchical layers of abstraction for a computer architecture is a crucial step to build a real universal programmable computer [9]. Here we take a brief overview of it, mainly the physical aspects; see also Figure 1. It contains both hardware and software layers, with different programming languages associated with them.\n\u2022 The physical devices: a physical system used as the carrier of bits. For instance, they are the transistors as the basic element to construct logic gates, or the magnetic domain for storage. \u2022 The gates and circuits: used to design the elementary Boolean gates and also elementary circuits, such as the adder, multiplexer, decoder, and a few sequential circuits, such as Latch, Flip-Flop, and Register. This takes place on the level of machine language. \u2022 The micro-processor: based on vNA. It can realize instructions such as if, else, when, while, for, shift, branch, etc., for the purpose of programming. \u2022 The instruction-set architecture: to design instructions, operand locations, memory, control, etc., such as CISC and MIPS. This is on the level of assemble language. \u2022 The operating system: decides how people can use a computer, such as how to input/output and how to input commands. \u2022 The algorithm and software: programs for solving a certain class of problem. This is on the level of advanced language.\nFrom the hierarchy of the layers of abstraction, we can see that quantum computing is still at an early stage. Currently, what people mostly aim at is a quantum CPU that can run simple circuit-level quantum algorithms, while all other parts can be classical. Namely, it uses classical control, classical memory, and also classical operating systems. The quality of qubits and also circuits are getting better, but these are at the lower levels of the hierarchy. There is no real logical qubit yet, which shall be error-correcting, either self-correcting or actively. It is still at infancy to construct a quantum micro-processor and instruction-set architecture, and this requires a better understanding of the roles of quantum memory and quantum control, and the roles of being quantum in other devices."
        },
        {
            "heading": "3. Basics of Quantum Computing",
            "text": "In this section, we briefly review the basics of quantum computing [8] and set the stage for our study. We focus on finite-dimensional Hilbert spaces. For a Hilbert space, H, quantum states are known as density operators, \u03c1 \u2208 D(H), forming a convex set of non-negative semi-definite operators with trace 1. A state is pure if it is also a projector. Quantum evolution is in general described by completely positive, trace-preserving (CPTP) maps [21], known as quantum channels. A fundamental principle is the quantum channelstate duality, i.e., the Choi-Jamio\u0142kowski isomorphism [15,22], which maps a channel, E , into a quantum state:\n\u03c9E := E \u2297 1(|\u03c9\u3009\u3008\u03c9|), (4)\ncalled Choi state in this work, for\n|\u03c9\u3009 := 1\u221a d d\u22121 \u2211 i=0 |i, i\u3009 \u2208 H \u2297 H (5)\nas a Bell state, known as an ebit, with d = dim(H). A channel can also be written as a Kraus operator-sum representation\nE(\u03c1) = r\n\u2211 i=1 Ki\u03c1K\u2020i , (6)\nfor Ki as Kraus operators [21] with \u2211i K\u2020i Ki = 1. This can be found from the eigendecomposition of \u03c9E , and r is the rank of \u03c9E . Unitary evolution and quantum measurement can both be viewed as channels. A unitary U \u2208 SU(d) is rank 1, with U\u2020U = UU\u2020 = 1. Its dual state is a pure state, |\u03c9U\u3009 = (U \u2297 1)|\u03c9\u3009, and we will use the notation |U\u3009 for simplicity. A quantum measurement is a POVM (positive operator-valued measure), which is a set of positive operators, {Mi}, with \u2211i Mi = 1. It is clear to see each effect Mi can realize, such as Mi = K\u2020i Ki for a Kraus operator, Ki; therefore, the POVM is realized by a channel.\nA channel can be described as an isometry V with V = \u2211i |i\u3009Ki, so it can be realized by a unitary U with V = U|0\u3009 as the first block column of U, and |0\u3009 as the initial ancillary state. This is the Stinespring\u2019s dilation theorem, which guarantees that it is enough to consider unitary evolution on pure states, since non-unitary channels and mixed states can be realized by ignoring ancilla or subsystems. In quantum circuit models, we consider unitary evolution on multi-qubit states followed by measurement. Similar with the classical circuit model, there also exist universal gate sets to decompose arbitrary unitary operator [23]. Two well-known examples are the sets {H,T,CNOT} and {H,Tof}, for the Hadamard gate, H, and the T gate as the forth-root of the Pauli Z operator. The Toffoli gate is universal for classical computing, but with the H gate, they are universal for quantum computing. The H gate exchanges Pauli X and Z operators:\nHXH = Z, HZH = X, (7)\nwhile with T2, which is the phase gate S, and the CNOT, they form the Clifford group [24] that preserves the set of (tensor-product of) Pauli operators. It is known that Clifford circuits are not even universal for classical computing. Non-Clifford gates such as T and Tof are necessary to achieve quantum universality. We see that quantum measurement is needed to read the results, which can be viewed as the expectation value of observable on the final state. It is also possible to encode expectation values as bit strings and to require the final state of quantum algorithms to be bit strings, such as using the amplitude amplification algorithm [25], but this will cost more quantum resources. To estimate expectation values, we often run the same circuit multiple times to obtain the necessary probabilities. Namely, to measure tr(A\u03c1) for a hermitian observable A on the final state, \u03c1, the eigenspectrum of A = \u2211i ai|i\u3009\u3008i| is needed, and probabilities pi = \u3008i|\u03c1|i\u3009 are obtained by repeated measurments so that\ntr(A\u03c1) = \u2211 i piai. (8)\nThat is, there are two primary but fundamental differences between the classical and quantum cases: the quantum evolution is unitary but non-unitary measurement is needed for readout. It is more appropriate to treat quantum algorithms as extensions of probabilistic algorithms, which not only use Boolean circuits acting on bits but also random numbers, in the form of pbits. Qubits can be understood as a combination of bits and pbits in the sense that the basis for a Hilbert space are bits, while its ampitudes on this basis are the source of pbits."
        },
        {
            "heading": "4. Basics of Quantum von Neumann Architecture",
            "text": "In this section, we discuss the basic model of quantum von Neumann architecture (QvN) based on our recent work [16\u201319], and here we aim to explain the details of the elementary operations in our model. Note that we do not study how to physically construct or encode a logical qubit, or physically construct a unit, which are separate important subjects."
        },
        {
            "heading": "4.1. The Basic Model",
            "text": "We describe the basic model as shown in Figure 2. This is the analog of what exists nowadays for modern computer system. Of course, we only discuss the primary abstract process. A user aims to perform a quantum algorithm, while the algorithm or program is provided by the host through a quantum channel, which can be monitored by an eavesdropper, Eve, or suffers from noises. Quantum codes are needed to protect information against noises and Eve, and they are also needed for the computers.\nIn practice, a host or data center may have a different design from a desktop computer. However, for simplicity we assume a quantum host follows a similar design to a quantum computer. The program may come from a host or another user. Without digging into the structures of a user or host computer, below we explain the elementary operations that need to be performed."
        },
        {
            "heading": "4.2. Read and Write on Memory",
            "text": "Given a quantum program encoded in a quantum state, one has to execute it. Using Choi state, the underlying scheme is that the action of channel E on state \u03c1 is recovered as\nE(\u03c1) = d trB[\u03c9E (1\u2297 \u03c1t)] (9)\nfor \u03c1t as the transpose of state \u03c1. The partial trace, trB, is on the 2nd part of \u03c9E . Below and most of the time in this work, we only consider unitary programs. A program, U, is stored as its Choi state, |U\u3009 = U \u2297 1|\u03c9\u3009; see figure:\nThe curve is the Bell state, |\u03c9\u3009. Given |U\u3009, how to use it? The basic usage is how it acts on input. In our scheme, an input state is injected by a binary projective measurement, and the output is also obtained by a projective measurement (PVM).\nSuppose the initial state is |0\u3009, and we need to obtain\npi = |\u3008\u03c8i|U|0\u3009|2. (10)\nThe binary PVM for initial-state injection is {P0, P0\u0304} for P0\u0304 = 1\u2212 P0. The PVM for readout is {|\u03c8i\u3009\u3008\u03c8i|}. As measurement outcomes are random, the initial state is only realized with finite probability. However, this is not a problem. For the case of P0, we obtain pi. For the case of P0\u0304, we obtain p \u2032 i = 1\u2212 pi, so pi can also be obtained [16]. If the dimension of U is d, then we need a qubit-ancilla to realize the binary PVM. See the figure for n-qubit input:\nThe Toffoli-like gate (on the left) is needed to extract the parity to the ancilla. A PVM on the ancilla will realize the initial-state injection. For convenience, we often call the 2nd part of a Choi state the \u2018tail\u2019, which serves as the \u2018port\u2019 for the initial-state injection, a \u2018write\u2019 operation, and the 1st part as the \u2018head\u2019, which is the port for the \u2018read\u2019 operation.\nBesides the Choi-state form, there are also other ways to store a program. Note that a program, U, can be decomposed as a circuit of elementary gates U \u2248 \u220fi Ui, with a fixed accuracy, e. Here we discuss a few of them.\n\u2022 Quantum encoding: uses the Choi state |U\u3009. \u2022 Classical encoding: uses bits [U] to represent U as a matrix, or as a sequence of gates forming a circuit, with the location and type of each gate encoded by bits. \u2022 Hardware encoding: a gate is stored in a hardware device, just like the optical elements\nin photonic quantum computing [8].\nDifferent schemes can be applied in different settings. They will also affect the construction of the QPU. Note there are also other ways. There is a non-local Choi-state-like form, which allows a program to be executed blindly [26], but this requires significantly more resources; therefore, we do not study this form in this work. Classical encoding, [U], is the most popular nowadays. It can be used for classical control signals to guide the execution of gates. This applies to the current framework on circuit models, such as superconducting circuits. Below we will study how to use quantum encoding to construct QPU."
        },
        {
            "heading": "4.3. Teleportation",
            "text": "Teleportation has been used in many ways, e.g., in quantum communication, in faulttolerant scheme, and in measurement-based quantum computing. For QvN, teleportation is used for both communication and computation. In communication, it has been well established that teleportation can replace the transmission of qubits by bits given distributed ebits [27]. For computation, teleportation is employed to realize gate operations, similar to the measurement-based model. Here we recall its definition and motivate the covariant teleportation. One often starts from a bipartite non-local setting that Alice and Bob already share ebits, and Alice aims to send qubits (or qudits) to Bob without quantum communication. The scheme is shown in the figure:\nThe Pauli byproducts, \u03c3i \u2208 {I, X, Y, Z}, are corrected by sending the measurement outcomes, i, from the Bell measurement of Alice to Bob. There is an interesting symmetry to this scheme. Each Pauli byproduct is obtained with the same probability. The operators, \u03c3i, form a projective representation of the group Z2 \u00d7 Z2. Actually, this fact has been used to define group-based teleportation [28]. This can also be understood from the point of view of tensors. The set of Pauli byproducts form a three-leg tensor, and it has full symmetry, SU(2), if the identity operator is absent [29]. This also applies to any SU(d) and leads to covariant teleportation [16] by grouping the non-trivial Pauli byproducts together, namely, using a qubit ancilla to extract the binary distinction of byproducts."
        },
        {
            "heading": "4.4. Switchable Composition of Programs",
            "text": "Covariant teleportation, also called universal quantum teleportation (UQT), can be used to compose two programs together. Namely, two program states, |U\u3009 and |V\u3009, can be composed together deterministically to be |UV\u3009 or |VU\u3009, depending on the direction of information flow; see the figure:\nThe shaded region is for the UQT. It requires a qubit ancilla and Toffoli-like gate, and also the adjoint form T, also known as the affine form, of a gate [16]. For instance, a qubit gate U \u2208 SU(2) corresponds to an orthogonal rotation R \u2208 SO(3). A PVM on the qubit ancilla leads to either trivial or non-trivial Pauli byproducts, on which the correction T is applied. Note that in order to complete composition, the programs need to be known, i.e., as white boxes. This can be used to generate large programs from smaller ones. When only elementary programs are composed, such as |H\u3009, |T\u3009, |CZ\u3009 for the Hadamard gate, H, T gate, and CZ gate, only the adjoint form of H and T needs to be done. As H exchanges Pauli X and Z, while T can generate superposition of Pauli X and Y, it is easy to see that the affine form of H is a swap gate, while T is a Hadamard-like gate [16]. The ebits used in the composition have a unique feature. A state injected at its tail can propagate \u2018backward\u2019 to its head, following from the channel-state duality. This leads to a switchable construction of the composition. For instance, for a qubit program it attaches one ebit to it. It then applies a few CZ gates, as shown in the figure\nThe top panel shows the circuit, while the bottom panel shows the operations on the qubits explicitly. The blue lines are CZ gates. The box is the stored program. This forms a \u2018pre-compose\u2019 step between the previous program and the current one. There are then two possible paths for the information flow, one with the current program, 1\u21922\u21923\u21924\u21925, the other without it, 1\u21924\u21925. This serves as a switch for turning the gate on or off, depending on the control signal. To complete the composition, one path needs to be chosen while closing the other, and there will also be correctable Pauli byproducts after the composition. This will be used to construct the QPU."
        },
        {
            "heading": "4.5. Program Conversion",
            "text": "It is also useful if one program can be changed into another. This needs the operation of a quantum superchannel [30\u201332]. For notation, we use a hat on the symbols for superchannels. The circuit representation of a superchannel is\nS\u0302(E)(\u03c1) = traV E U (\u03c1\u2297 |0\u3009\u30080|), (11)\nfor \u03c1 \u2208 D(H), U and V are unitary, and a is an ancilla. The dimension of V can be larger than U [33], but we do not need the details here. This can also be represented as the action on Choi state with\nS\u0302(E)(\u03c1) = trA\u0304V \u2297 U\u0303 (\u03c9E \u2297\u03c9)(1\u2297 \u03c1t \u2297 |0\u3009\u30080|). (12)\nThe unitary U\u0303 is the transpose of U conjugated by a swap. The trace is over the subsystems, except for the top one, A. We see that ebits are needed in order to realize non-trivial superchannels; see the figure\nThe top wire carries the output. It has been shown that [17] a sequence of superchannels acting on Choi states can be composed together with the tool UQT. This realizes the so-called quantum comb, which is a composition of superchannels. This has found applications in quantum estimation, learning, optimization, etc., and we will study this further in the Section 6."
        },
        {
            "heading": "4.6. QCU",
            "text": "Control plays an essential role in classical computers. The simplest example is the CNOT gate, which uses a bit to control another bit. Clock is another notable example and is a building block in classical sequential circuits. There are also schemes that use electric circuits to achieve control of analog signals. Here we analyze the construction of a quantum control unit (QCU) for QvN. First, there are different layers of control tasks. The most familiar one is to use bits to control quantum gates. In the circuit model, each gate has a definite spacetime location, i.e., when and where it acts on qubits. Such classical information serves as bits to control the execution of quantum gates. There is no entanglement between the control bits and data qubits. One semi-classical scheme is to use lasers to interact with qubits, which is a seminal field of AMO physics and also the most familiar paradigm of quantum control. There is no entanglement between the qubits and the lasers. Dynamical decoupling [34] is a notable example. One can also use qubits to control quantum gates. This actually has been a quite common scheme for designing quantum algorithms, such as the swap test, DQC1, and also quantum phase estimation [18]. This can lead to interference of quantum gates, and this has been used in the linear combination of unitaries (LCU) algorithm [35,36] and also in a model of contextual quantum computing [18]. Using QCU also leads to certain issues. A first non-trivial issue arises if the target quantum gate is unknown, i.e., a black box. This applies to situations of modular design, for instance. It was proven that quantum control over an unknown gate is impossible [37]. This is because the operation U 7\u2192 \u039bU is not valid as it converts the unphysical global phase of U to a local phase of U in \u039bU. Here, \u039bU is the controlled-U gate. A solution for this is to know the eigenstate of U, which serves as a \u2018flag\u2019. The following circuit realizes the desired quantum control:\nThe top wire is the control register, the second wire is the data register, and the third one is the flag. Now the gate is \u2018gray\u2019 instead of black since the eigenstate and eigenvalue of it are known. This method can be used to run quantum control over unknown programs, and then realize LCU algorithms. We require that each program state, |U\u3009, is given with a flag, |\u03bbU\u3009. A flag state can be injected using our initialization method; see the figure for the linear combination of two unknown programs:\nThe control signal (c) itself is not pre-stored, although it can be quantum. That is, the control signal is taken as deterministic input and is not injected by measurement, which is random. Now the question is, can it also be pre-stored as quantum states? For comparison, random input data induced by PVM is acceptable since these input signals are orthogonal and their results are effectively equivalent. A random control signal induced by PVM will lead to uncertain operation, say U1 or U2, which are not orthogornal in general. It seems there is no easy solution to this. In order to make orthogonal control signals, the non-local scheme [26] can be used, which turns a set of {Ui} into approximate orthogonal states, but this requires significantly more quantum resources. Therefore, we do not require pre-stored quantum control signals. For all the above, the control unit is required to be separable from the data unit at the output. This is necessary since, by assumption, the control unit shall not carry the final results. They can become entangled during a computation, but at the end they will be disentangled. This issue has been analyzed in the setting of quantum Turing machines [38\u201342], and also in a recent study of quantum control machines [43]. For instance, in the model of a local quantum Turing machine [42], by expressing the final quantum state carrying the results as a matrix-product state,\n|\u03c8\u3009 = \u2211 i A(in) \u00b7 \u00b7 \u00b7 A(i2)A(i1)|`\u3009|in \u00b7 \u00b7 \u00b7 i2i1\u3009, (13)\nthe machine register, with an edge state, |`\u3009, serving as the control register, can be disentangled from the data register at the end. Another method is to use measurement feedback to disentangle the controller and data [18] used to define a contextual quantum computing model. These examples also show that, due to entanglement, the interplay between the control flow and data flow needs more study."
        },
        {
            "heading": "4.7. QPU",
            "text": "A CPU usually contains a control unit and an ALU (arithmic logic unit). For the classical case, to run a program, A, which is stored as bits, [A], in the hard disc, the [A] is firstly loaded as control and operations on a programmable circuit, aka., a chip. The internal storage is also used to store temporary data. In this section, we study the primary structure of the QPU in our model, and compare it with existing ones. For the quantum case, the starting point is the circuit model. However, there are different approaches. We find there are two dual ones:\n\u2022 Type-I: gates are stored as hardware while qubits are sort of \u2018not there\u2019; this applies to linear optics, which uses optical elements as gates and photons as qubits; \u2022 Type-II: qubits are stored as hardware while gates are sort of \u2018not there\u2019; this applies to SC, trapped ions, which uses laser pulses (interacting with matter particles) as gates and particles (e.g., electrons) as qubits.\nFor both of these, the program, [U], that is used as control signals is classical. We call this \u2018classical programmability\u2019. On the contrary, we will define a quantum programmability for our model of QPU. It relies on the quantum encoding of programs, or a semi-quantum one, namely, Choi states |H\u3009, |T\u3009, and |CX\u3009, to store the elementary gates, or other Choi states to store blocks of gates, and bits [U] to store their spacetime locations. Furthermore, we need the toolboxes of switchable composition, quantum superchannels, and also quantum control units.\nWe have seen that the control flow is distinct from the data flow. Actually, control sequences can also be stored as programs, but in order to compose them, another level of control is still needed as long as the QPU is not automatic. That is, all control signals are needed to monitor the evolution. As discussed in the former section, the input control signals need to be deterministic. That is, the [U] is used as the control signal to apply composition and other operations on primary Choi states. To run U, qubits in the QPU will be measured. After the run, qubits need to be refreshed to the right Choi states. For instance, consider the programmable realization of a sequence of H and T gates to approximate a qubit rotation; see the figure\nThe UQT serving as the switchable composition is under control. The elementary programs need to be refreshable in order to be multi-time programmable. Furthermore, the QPU can also perform superchannels on the programs. These can lead to quantum superalgorithms that prove to be powerful. We will discuss this more in Section 6. The \u2018programmability\u2019 in our model is not classical. There are a few aspects for our programmability, referring to the memory unit and control unit. First, our model allows programs to be stored as quantum states, i.e., Choi states. This means the algorithms in our model can use quantum program states. Second, a stored quantum program is switchable, on or off, depending on the control signal. Third, the control signal can also be quantum, so it forms an important part of a quantum algorithm. Our construction of the QPU lies somehow between type-I and type-II above. We have named this type-III; see Table 1. For type-I, gates are stored as hardware, so they exist in the space domain, while qubits such as photons are only generated on demand when an algorithm is to be run, so they exist in the time domain. It is the opposite for type-II. For type-III, qubits are not used to carry data but are used to encode programs. The actual data qubits are prepared by measurements when an algorithm is to be run, so they exist in both the space and the time domain. A gate also exists both in the form of a program and the operation in a composition, and so in the spacetime domain.\nWhat is the advantage of using type-III? At present, this is not fully clear. It apparently consumes significantly more qubits to realize an algorithm due to the usage of teleportation, as in the case of the measurement-based model [44]. That said, teleportation brings some advantages (see Section 4.3). For instance, for the architecture design, the physical qubits can tolerate more decoherence since they only carry the data for depth one before a composition occurs. In addition, only qubits need to be manufactured, and gates are applied to them. Finally, there is a clear resource-theoretic characterization of QvN, by treating quantum memory as a universal resource [18]. This can benefit the understanding of quantum superalgorithms, which rely on quantum memory."
        },
        {
            "heading": "4.8. Program Download/Upload",
            "text": "After a computation, the program state is consumed/destroyed. This is not a flaw, however. This is also present in the usual quantum circuit model: after the computation, the qubits need to be refreshed for the next task. This even exists in classical computers that use temporary data such as cache and buffer.\nFor QvN, the program states are likely stored in the memory unit. A computation would basically turn some of the states into garbage, and the user would have to restore the programs. This is achieved by downloading them through the internet from a software producer, or a host. In order to be secure, here we consider quantum internet via quantum communication. The usual carrier, although it does not have to be, is photons. Therefore, the user needs to have the ability to receive photons and to store and measure them. We find, as shown in Figure 3, there are four primary schemes:\n1. Use qubits to send bits: the host employs the bit-string description, [U], of a program, U, and then encrypt the bits, [[U]]. Quantum cryptography such as the BB84 scheme can be used to send the bits [45]. At the user side, a control device is needed to receive the bits and apply the gate sequence, without revealing the bits to the user. This is very much like a delegated computing or remote state preparation [46], but now the user is the remote site, and the host does not need to verify the user. 2. Use ebits to send bits: one can use ebit-based quantum cryptography to send bit-string descriptions of the gate sequence [U]. 3. Use qubits to send qubits: the host prepares photons at the state |U\u3009 directly, and sends them to the user, who then applies quantum teleportation between photons and the memory qubits to teleport/download the program from the photons to the memory qubits. 4. Use ebits to send qubits: the host and user first establish many pairs of ebits of photons, and then the user applies quantum teleportation between some photons and the memory qubits to teleport/download the program from the photons to the memory qubits. Namely, if |U\u3009 = V|0\u3009, the host applies Vt and then the projection |0\u3009\u30080| on his side, and that will prepare the photons at the user as |U\u3009. The host needs to use our initial-state injection technique, and the effect on the final readout at the user\u2019s side can be easily dealt with.\nOne may wonder which scheme is preferred. For the first two, the goal is to send bits, which need to encode both the space and time information of the gate sequence in a program. For the last two, the goal is to send qubits, which does not need to encode the time information, hence consuming fewer numbers of qubits than the number of bits. However, currently qubits are much more expensive than bits. The choice of a scheme would depend on many practical conditions."
        },
        {
            "heading": "4.9. Program Verification",
            "text": "When a user decides to download a program from a host, the user has to verify that the host indeed has the promised program. This is a quantum verification task [47,48], which has been widely studied in recent years. Here we discuss how the program-verification would work, but we do not specify all the details since there could be various schemes depending on practical settings. The verification can be interactive. In the framework of interactive-proof systems [47], the user serves as a verifier and the host serves as a prover. Usually, the verifier is required\nto be computationally in BPP, while the prover is in BQP. However, here in our setting the verifier is also in BQP, but they only have a limited number of copies of the unknown program |U\u3009. That is, the user, as the verifier, can only perform verification instead of a full tomography. It is not hard to determine the number of samples of |U\u3009 the user can download. From verification theory, which specifies an infidelity parameter, e, and confidence parameter, \u03b4, the number of samples scales as\nN \u2208 O (\n1 e log 1 \u03b4\n) , (14)\nignoring other factors that do not matter for our discussion here. Although the scaling with respect to e is not efficient, for the purpose of verification a moderate fidelity is acceptable, and the confidence is usually more important. Given a few samples of |U\u3009, the user can also perform quantum estimation or learning. It is also well established that the fidelity scales as N\u22122 for optimal joint global operations on them [49]. This is the so-called Heisenberg limit. For a full process tomography, the user has to use a number of measurement operations, hence a number of samples, that scale with the dimension of |U\u3009, which is exponential with the number of qubits it acts on. Therefore, we find that as long as the number of samples is much smaller than that for tomography, the verification can be carried out efficiently. In addition, there is also another level of sampling, which is to obtain the final expectation value of the observable. In modern terms, this is a special instance of shadow tomography, which can be performed with a small number of samples [48]. Verification is an important subject in the study of blind or delegated quantum computing. We will study its difference from QvN in Section 5.3."
        },
        {
            "heading": "5. Difference from Other Models",
            "text": "In this section, we analyze the primary differences between QvN and some other models."
        },
        {
            "heading": "5.1. Circuit Model",
            "text": "Here we compare QvN with the quantum circuit model (QCM), including the execution of an algorithm, security, verification, and other issues. We assume the usual scheme of QCM, which realizes a quantum algorithm as a three-stage process: initial state preparation, gate execution, and measurement. We already see their difference from our study of programmable QPU. Actually, it is also fine to treat QvN in the framework of QCM, as the primary operations are either unitary gates or measurements. However, it is necessary to make a distinction between them since conceptually QvN considers more requirements. This is similar for the classical case.\nThe scheme to realize a circuit can be seen from this figure:\nThe top register is classical, and [U] is the classical representation of the program U. The output from a quantum algorithm is assumed to be the expectation value of a hermitian operator, which reduces to the estimation of a set of probabilities, pi. The implementation of a quantum algorithm can be performed efficiently provided that:\n\u2022 the initial state can be prepared quantum efficiently; \u2022 the program U can be stored classically efficiently, as [U]; \u2022 the program U can be realized quantum efficiently; \u2022 the measurement for readout can be realized quantum efficiently;\n\u2022 the number of samples scales efficiently to estimate each pi.\nThe classical description, [U], is often a bit-string of the gate sequence in the circuit, if U = \u220fi Ui, while bits are used to encode the spacetime location and type of each primary gate, Ui, from a universal gate set, e.g., {H,T,CZ}. After the execution, all qubits are measured and need to be refreshed for further usage. The program is stored as bits, [U], so do not need refreshment. The composition of two programs, U1 and U2, is simple, namely, they are implemented sequentially. The initial state needs to be prepared before the application of gates, which is not the case for QvN. Another notable difference is that QvN requires the download of quantum programs, since they cannot be cloned if the bit-string descriptions of them are unavailable. The security of quantum communication, relying on the uncertainty principle, ensures the security of the quantum programs. For the circuit model, a circuit is often not secure, i.e., there is a classical circuit diagram, which can be easily seen and copied. However, there are also secure protocols relying on QCM. A notable example is blind or delegated quantum computing (DQC) [50], which was initially formulated via MBQC but can also be formulated via QCM. This leads to the discussion in the following two subsections."
        },
        {
            "heading": "5.2. MBQC",
            "text": "Besides the circuit model, QvN also has close connections with MBQC. In the standard MBQC, also known as the one-way model [44], a resource state such as the 2D cluster state is given, and then a sequence of local adaptive measurements is performed to execute the gates. The basic underlying mechanism is 1-bit teleportation [29], and a spatial direction is chosen as the \u2018teleported\u2019 evolution direction. Furthermore, it is equivalent to the model based on Bell measurements for standard teleportation, which is 2-bit [51]. Here we will denote this as the teleportation-based model (TBQC), although sometimes it is treated as a special case of MBQC. For clarity, we have summarized the comparison in Table 2. The TBQC is often used for the fault-tolerant execution of gates; hence, its byproduct is extended to Clifford operations, which still preserve Pauli gates. Due to the covariant teleportation used in QvN, the stored program can be fully quantum, namely, the whole group, SU(d), of gates. On the contrary, in MBQC qubit gates are induced by local measurements in rotated bases, while in TBQC the entangling of gates such as CZ or CNOT is performed by two parallel Bell measurements, consuming ebits. One should note that in MBQC the local measurements are relatively simple, compared with Bell measurements, and the resource state can be prepared offine.\nAnother important difference is that in QvN the information, injected at the \u2018tail\u2019, is always carried by the \u2018head\u2019 of a Choi state. There is no such explicit head\u2013tail structure for MBQC, or for TBQC. The information flow is shown in Figure 4. For QvN, the information never \u2018crosses\u2019 a composition \u2018box\u2019, but this is the opposite for MBQC. Treating a composition as a single depth, each physical qubit for a tail or head only has depth one. This leads to the switchability of the composition, also illustrated in the figure. As has been discussed, the switchability could be useful to construct the QPU."
        },
        {
            "heading": "5.3. Delegated Quantum Computing",
            "text": "An important model for secure computation is delegated quantum computing (DQC), which was earlier known as blind quantum computing [50]. In this model, a user, as a verifier, aims to delegate computation to a prover without revealing the computation to the prover, see the figure for QCM in Section 5.1, while the classical and quantum registers belongs to the verifier and prover, separately. The verifier is in BPP, while the prover is in BQP. Usually, the verifier knows what to compute but does not have the capability to do so. This model may apply to the recent era of quantum computing, where only a few labs or companies have powerful quantum computers, and customers can use them blindly and confidently. The input, output, and the computation itself can all be blind to the prover. This is different from the program-verification in QvN. For QvN, the host has both [U] and |U\u3009, while the user only has |U\u3009. The user will use the program blindly by making measurements. Given the limited samples of a program, the user can not perform tomography, i.e., cannot obtain its classical description, [U]. In DQC, the prover can do U, which is equivalent to the ability to prepare |U\u3009, while the verifier has [U]. In QvN, the user side is BQP and the host/prover is also BQP. The purpose of verification in DQC is to verify [U], while the purpose of verification in QvN is to verify |U\u3009. There is no apparent delegation in QvN; see Table 3."
        },
        {
            "heading": "6. Quantum Algorithms in QvN",
            "text": "In this section, we study the design of quantum algorithms in QvN. This has been analyzed in our previous work [17,52], while here our discussion will be more specific, drawing the connection with computational advantages."
        },
        {
            "heading": "6.1. Quantum Superalgorithm",
            "text": "A quantum algorithm is usually specified by a quantum circuit and a measurement procedure, as has been shown. On top of that, there is also a classical algorithm that designs the quantum algorithm; see the figure:\nHere, a triangle represents a measurement. This design can be iterative, with measurement outcomes fed forward to the classical algorithm, A, which then optimizes the parameterized quantum circuit, U. Some examples are the Solovay\u2013Kitaev algorithm for gate compiling [53], quantum channel simulation [33,54], and quantum approximate optimization [55]. This actually forms a classical comb of classical-quantum hybrid algorithms, using the terminology of quantum superchannel theory [30\u201332].\nOne can also pose the following question: can we use a quantum algorithm to design another quantum algorithm? Such a scheme works for the classical case; namely, there are classical algorithms that design classical algorithms. Such algorithms are often known as \u2018meta\u2019 algorithms or \u2018hyper\u2019 algorithms since they contain some meta or hyper variables that need to be optimized. This plays an essential role in machine learning [56]. For the quantum case, it has been confirmed that we can use a quantum algorithm to design another quantum algorithm. This follows from nothing but the quantum superchannel theory. The superchannel plays the role of the \u2018meta\u2019 algorithm, while the channels acted upon by the superchannel serve as the input to it. We will call these algorithms quantum superalgorithms to be consistent with the superchannel theory. It has the following structure:\nFor the composition technique, it can also be realized by a sequence of compositions [17]. This is what the QPU from Section 4.7 can do. Compared with the former scheme, it is clear to see here that quantum memory (the bottom register) is used as resources to realize superalgorithms [18]. Many quantum algorithms are of this form, although sometimes they are not under the name of \u2018superalgorithm\u2019. This includes quantum estimation and learning algorithms [56], quantum channel discrimination [57], schemes for quantum games [58], quantum optimization [59], and quantum machine learning [60\u201363]. The recent quantum singular-value transformation [64], which can unify some quantum algorithms, is also a special type of superalgorithm [52]. The theory of superchannels also allows the so-called higher-order operations [32], which are superchannels that act on superchannels, by using the channel-state duality iteratively. These higher-order superchannels can still be viewed as a superchannel but with a more complicated multipartite structure [17]. Furthermore, one may wonder that a \u2018mother\u2019 algorithm is still needed to design a quantum superalgorithm, and such a mother algorithm can be classical. This is indeed the case, but what matters is that quantum memory, and also control, are used as resources in addition to the current framework based on the circuit model. Recently, people have found that quantum memory can lead to exponential advantages for solving some problems [63,65]. Finally, the output for the final result often contains probabilities. This requires many runs of an algorithm to estimate them. However, there is a method to convert probabilities into amplitudes of quantum states and then use the quantum amplitude estimation algorithm to obtain them in the form of bit strings [25]. This is the analog of quantum phase estimation, which can be used to estimate unknown parameters by encoding them as phase factors. Such algorithms use quantum controlled operations. From matrix decomposition, a controlled operation can be decomposed as the product of a few operations without control and simple controlled operations, such as the controlled-not gates. This means that these estimation algorithms can also be put into the framework of quantum superalgorithms."
        },
        {
            "heading": "6.2. Computational Advantages",
            "text": "Finding computational advantages would depend on the structure of certain problems. If there is no structure, quantum computing can only provide quadratic advantages. For instance, Grover\u2019s algorithm shows that for a structure-less database of size N, a quantum computer will take time in order O( \u221a N) instead of log N [8]. The so-called Heisenberg\u2019s limit from the uncertainty principle sets the bound for the precision of estimating an unknown parameter, also with quadratic improvement of precision [66]. This relates to the fact that the square of amplitudes yields probabilities. In the model of QvN, we analyze the potential advantages by using a combination of quantum CPU, control, memory, and\ninternet, compared to the classical case and also other quantum computing models. Our analysis, however, is preliminary and we hope this can inspire more investigations.\n6.2.1. Storage\nIt seems the amplitudes of qubits can significantly increase the ability for storage. A pure state, |\u03c8\u3009 = \u2211i \u03c8i|i\u3009, already stores the amplitudes, \u03c8i, in it without encoding them as bit strings. However, this turns out not to be completely true, since quantum measurements are needed in order to know \u03c8i, and this requires a significant amount of copies of the qubit |\u03c8\u3009. The seminal result is the Holevo bound [67], which was established originally in the setting of quantum communication. It states that the quantum capacity of a channel is half of its classical capacity. Namely, a qubit can only be used to store or transmit two bits. This may not be hard to understand from the point of view of error correction, whereas correcting Pauli X and Z is enough to correct any linear combination of them. This is also demonstrated by the quantum teleportation and dense coding [27]. Using an ebit, a qubit can be used to transmit two bits, and two bits can be used to transmit a qubit. It also relates to the quadratic speedup of Grover\u2019s algorithm. An n-qubit state can be viewed as 2n bits, hence representing 22n different values forming a database whose size is the square of that from n bits. Quantum search, if treated as a state preparation, cannot be faster since otherwise a qubit would carry more than two bits. However, this does not mean there is no larger advantages for specific tasks. In the circuit model, a state, |\u03c8\u3009, can be represented by its preparation circuit, U. As has been discussed, there is an efficient bit-string encoding, [U], of the circuit, by only encoding the type of each gate and its spacetime location. However, using qubits to store quantum states can offer advantages, e.g., as we have mentioned for quantum learning [63,65]. For instance, it has been proven that, although learning the statistical average may not offer an advantage, accurately predicting the value of any observable can have an exponential advantage by using quantum memory [63]. Therefore, it is promising to explore more primacy of quantum memory.\n6.2.2. Speed\nQuantum advantage is often used the same as speedup. This is basically because, in principle, other resource costs can be treated as a cost of computing time, but we will distinguish them since this could inspire different intuitions for solving different problems. First, we need to distinguish an algorithmic speedup from the speed of a quantum computer. The former is on the software level, while the later also depends on the hardware. The same quantum algorithm would take a different amount of time on different quantum computers. The underlying mechanism for algorithmic speedup relates to interference. Compared to the classical case, quantum evolution is unitary, i.e., coherent, and there are significant amounts of interference between trajectories, given a fixed basis of the underlying Hilbert space. A speedup occurs if the interference can enhance the probability of the desired trajectory. Note that the pre-condition for a speedup is the accuracy of computing result. The more accurate the results, the more time is needed. To achieve a speedup is one of the central tasks of QPU, besides programmability. In the model of QvN, the interplay between QPU and other units will also affect the speedup. This is also the case for classical computers, and that is why cache is needed to replace the hard drive. If a truly quantum computer can be built in the future, following a certain QvN and the hierarchical design, there will certainly be various kinds of quantum memory, control, communication, and even input and output devices, etc. The speed of such a quantum computer would depend on many factors that are still hard to define at present.\n6.2.3. Security\nQuantum cryptography to realize security was one of the prompters of quantum information science, with the BB84 scheme of quantum key distribution as a notable example [45]. It is based on the no-cloning theorem, which is equivalent to the Heisenberg uncertainty principle. The program download/upload process can be seen as a special task in quantum communication, and it therefore shares features of standard quantum communication. Here, we should point out that it is secure in two senses. First, the program generated by the host is secure against the user. Second, the communication between the user and the host is secure against eavesdroppers. There are also other settings of secure quantum computing, such as delegated or blind quantum computing [50,68], as discussed in Section 5.3, and multi-party quantum computing [69]. For the later, neither one of the parties know the result. Instead, they must communicate to extract the result. Attacks in quantum cryptography have been well studied [70]. An attack can be detected but not prevented. In the model of QvN, data are stored as qubits instead of bits. One may then be curious if quantum data can be hacked. Although qubit encoding data such as passwords cannot be accurately cloned and hence leaked, they can be measured. A simple quantum virus can be an instruction to make the most trivial measurement, which will erase any data. Such a virus is actually classical since it can take the same form and can copy itself. Although there are costs to make an attack possibly at any time, it cannot be prevented in principle. We therefore suppose that this stands as a \u2018no-go\u2019 for a no-no-virus hope for quantum computers. Despite this, quantum computers have the potential for more applications in cryptography due to resources such as coherence and entanglement.\n6.2.4. Energy\nReducing energy consumption in computation was one of the original motivations for quantum computing. Landauer showed that erasing bits will cost energy, while with Toffoli gates, a classical computation can be made reversible [71]. At the same time, it was realized by Feynman and others that a quantum computer can be reversible since its evolution is unitary [1]. However, compared with other features, the study of energy consumption in quantum computing is rare [72\u201374]. In the circuit model, initialization and readout by measurement will cost energy. A recent pioneer studied the energy cost in unitary evolution using superchannel theory and resource theory [74], which showed that the energy cost relates to the accuracy of the computation. However, a systematic understanding of the thermodynamics of unitary evolution is lacking. This is not obvious as thermodynamics often deals with non-unitary dissipative evolution. Here, we should point out that the energy issue could be relevant for the design of quantum control schemes, compared with classical ones. However, it is not always straightforward to assess the amount of energy cost since some schemes are \u2018semi-classical.\u2019 For instance, cooling a qubit by a reservoir in order to suppress decoherence can be considered semi-classical. Using quantum error correction can also suppress decoherence, but it is not easy to compare the energy costs during the cooling and the error correction. In the model of QvN, a quantum control unit is used to enact quantum operations and also forms the ingredients of quantum algorithms. When the control signal is not a part of the final output, erasing or resetting it will cost energy. On the contrary, using classical control cannot generate entanglement between the controller and the target. At present, it is not clear how to find quantum advantages on energy costs over classical control schemes."
        },
        {
            "heading": "7. NISQ Implementation",
            "text": "In this section, we study how to implement a small-scale QvN on noisy intermediatescale quantum (NISQ) devices. This would not include massive quantum error correction and quantum verification, for instance, which require more quantum resources.\nWe can make comparisons with the basic requirements of the circuit model. This dates back to twenty years ago [75], with five requirements: a scalable system of qubits, initialization of qubits, sufficient coherence to carry out an algorithm, a universal set of unitary gates, and measurement for readout. These requirements are also strengthened or expanded for more purposes. They are also the basic requirements to realize a QvN. A few additional requirements are needed. (1) First, it requires the ability to execute multi-qubit controlled gates, such as the Toffoli gate. Such gates can be decomposed into elementary one- or two-qubit gates, but it would be better if they could be directly realized. These gates are needed for initialization, composition, and quantum control. (2) Second, it requires quantum communication. This was also an extra request when flying qubits such as photons are needed to connect a few separate quantum stations, such as in the trapped-ions setup [8]. The above two requirements can already be satisfied by some systems [76\u201378]. Therefore, it is possible to demonstrate prototypes of QvN. Here we describe almost the smallest system of QvN, with the process of read\u2013write, download, composition, control, and superchannels. They are listed as follows:\n\u2022 The read\u2013write program: It needs two qubits to store a qubit gate, and four to store a CZ gate. The initial-state injection (i.e., write) for a qubit program on a standard basis (|0\u3009 and |1\u3009) does not require ancilla, which is also the case for the read operation. For the CZ program, the write operation on a standard basis (|00\u3009, |01\u3009, |10\u3009, |11\u3009) does require a qubit ancilla and the Toffoli gate, but the read operation does not. \u2022 The download process: For the scheme using ebits to send qubits, the state-injection at the host side requires a Toffoli gate and an ancilla. For a qubit program, the teleportation at the user side is on 4 qubits. The download in total involves 9 qubits. It is easy to verify for a two-qubit program; the teleportation is on 8 qubits. The download in total involves 17 qubits. For other schemes of the download, it requires less qubits, hence also less gates. \u2022 The composition: To compose two qubit-program states deterministically, this needs 5 qubits with one as the ancilla. To compose a qubit program with the CZ program deterministically, it needs 6 qubits if the qubit program is applied earlier, and 7 if it is applied after the CZ. However, if the Pauli byproduct is not required to be corrected, less qubits are needed. This reduces to 4 and 6, respectively. In addition, to make the composition switchable, extra ebits are needed. \u2022 The quantum control: To realize a quantum control of an unknown qubit program, it requires 5 qubits, with one for a qubit control, two for the qubit program, and two for the data register. Recall that an eigenstate of the unknown qubit gate shall be known, and it will be injected by measurement. For the control of an unknown two-qubit program, it needs 9 qubits. \u2022 The quantum superchannel: To realize an arbitrary qubit superchannel, it needs 6 qubits, with two for the qubit program and 4 as ancilla. However, with a convex-sum decomposition algorithm [33], two ancillary qubits can be saved. \u2022 A quantum superalgorithm: For a simple quantum superalgorithm formed by a sequence of compositions, its cost is determined by the composition. It can also include superchannels within such a superalgorithm, then its cost will be higher. For a simple demonstration, however, the Pauli byproduct can be left uncorrected, and even the initialization can be probabilistic. This will realize a probabilistic or random superalgorithm.\nWe see that less than 20 qubits is enough to realize the primary operations in a QvN. Quantum systems nowadays already have far more qubits than this. Therefore, more complicated operations, such as control or superalgorithms, can also be realized."
        },
        {
            "heading": "8. Conclusions",
            "text": "To conclude, in this paper we presented a systematic survey of the recently introduced model of quantum von Neumann architecture. We placed it in the more complete picture\nof a hierarchical design principle of modern computers, which, given sufficient space and time, can not only realize universality, but also programmability, modularity, scalability, etc. We also briefly drew its connection with other quantum computing models and algorithmic advantages. On the theoretical side, there are also many interesting open questions. Here we list a few of them as our conclusion.\n\u2022 Types of quantum memory unit. A quantum RAM model of states was developed [79], which was faster at finding a specific state than classical ones. Such a scheme can be used for the storage of Choi program states. We mentioned that there are various types of classical memory, and also memory devices. This is not clear for the quantum case. Our scheme for the quantum programs is more like internal memory, rather than external memory, i.e., a hard disc. Although in the early days of computers, gates were indeed applied on hard memory, nowadays there is a clear distinction between internal and external memory. The role of external quantum memory still needs to be investigated. \u2022 The roles of quantum control. As we have shown, using a quantum instead of a classical control unit will cause issues such as the entanglement between the control flow and the data flow. We have also mentioned a few tools to deal with this. However, a general principle for the design of a quantum control unit is still needed. Meanwhile, specific examples and application settings are also needed to show the necessity of it over a classical one. We pointed out that energy consumption may relate to quantum control by studying the dynamics of work, heat, entropy, etc, i.e., the thermodynamics of quantum computing. \u2022 Quantum \u2018sequential\u2019 circuit. A large class of classical circuits are known as sequential circuits, which, roughly speaking, are circuits with memory or loop [9]. They are essential for electric circuit design. There is no apparent quantum analog as quantum circuits do not form loops, despite some explorations [80]. Specifically, an output from a quantum process cannot be an input again unless it is trivial, i.e., it is a fixed point of the process. This relates to the quantum closed timeline curve [81]. However, using Bell states and Bell measurements, loops can be formed [17]; as we have seen, a Bell state or ebit is expressed as half of a loop. The difficult aspect is that there are Pauli byproducts in Bell measurements. In addition, using measurements makes the process non-unitary. At present, it is unclear what could be the proper quantum notion of loop, leading to a quantum analog of classical sequential circuits.\nAuthor Contributions: This work was supervised by D.-S.W.; Formal analysis, Y.-T.L., K.W. and Y.-D.L. All authors have read and agreed to the published version of the manuscript.\nFunding: This work was funded by the National Natural Science Foundation of China under Grants 12047503 and 12105343.\nData Availability Statement: No new data were created or analyzed in this study. Data sharing is not applicable to this article.\nConflicts of Interest: The authors declare no conflict of interest."
        }
    ],
    "title": "A Survey of Universal Quantum von Neumann Architecture",
    "year": 2023
}