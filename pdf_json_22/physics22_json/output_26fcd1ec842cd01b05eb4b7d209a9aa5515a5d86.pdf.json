{
    "abstractText": "We propose a series of quantum algorithms for computing a wide range of quantum entropies and distances, including the von Neumann entropy, quantum R\u00e9nyi entropy, trace distance, and fidelity. The proposed algorithms significantly outperform the best known (and even quantum) ones in the low-rank case, some of which achieve exponential speedups. In particular, for N dimensional quantum states of rank r, our proposed quantum algorithms for computing the von Neumann entropy, trace distance and fidelity within additive error \u03b5 have time complexity of \u00d5 (",
    "authors": [
        {
            "affiliations": [],
            "name": "Qisheng Wang"
        },
        {
            "affiliations": [],
            "name": "Ji Guan"
        },
        {
            "affiliations": [],
            "name": "Junyi Liu"
        },
        {
            "affiliations": [],
            "name": "Zhicheng Zhang"
        },
        {
            "affiliations": [],
            "name": "Mingsheng Ying"
        }
    ],
    "id": "SP:460206b51138356097f246209568d357407b5dbc",
    "references": [
        {
            "authors": [
                "J. Acharya",
                "I. Issa",
                "N.V. Shende",
                "A.B. Wagne"
            ],
            "title": "Measuring quantum entropy",
            "venue": "IEEE International Symposium on Information Theory,",
            "year": 2019
        },
        {
            "authors": [
                "A. Anshu",
                "Z. Landau",
                "Y. Liu"
            ],
            "title": "Distributed quantum inner product estimation",
            "venue": "ArXiv e-prints,",
            "year": 2021
        },
        {
            "authors": [
                "A. Ambainis"
            ],
            "title": "Quantum walk algorithm for element distinctness",
            "venue": "In Proceedings of the 45th IEEE Symposium on Foundations of Computer Science,",
            "year": 2004
        },
        {
            "authors": [
                "R. Agarwal",
                "S. Rethinasamy",
                "K. Sharma",
                "M.M. Wilde"
            ],
            "title": "Estimating distinguishability measures on quantum computers",
            "venue": "ArXiv e-prints,",
            "year": 2021
        },
        {
            "authors": [
                "K.M.R. Audenaert"
            ],
            "title": "Subadditivity of q-entropies for q > 1",
            "venue": "Journal of Mathematical Physics,",
            "year": 2007
        },
        {
            "authors": [
                "D.W. Berry",
                "A.M. Childs",
                "R. Cleve",
                "R. Kothari",
                "R.D. Somma"
            ],
            "title": "Simulating Hamiltonian dynamics with a truncated Taylor series",
            "venue": "Physical Review Letters,",
            "year": 2015
        },
        {
            "authors": [
                "D.W. Berry",
                "A.M. Childs",
                "R. Kothari"
            ],
            "title": "Hamiltonian simulation with nearly optimal dependence on all parameters",
            "venue": "In Proceedings of the 56th Annual IEEE Symposium on Foundations of Computer Science,",
            "year": 2015
        },
        {
            "authors": [
                "H. Buhrman",
                "R. Cleve",
                "J. Watrous",
                "R. de Wolf"
            ],
            "title": "Quantum fingerprinting",
            "venue": "Physical Review Letters,",
            "year": 2001
        },
        {
            "authors": [
                "T. Batu",
                "S. Dasgupta",
                "R. Kumar",
                "R. Rubinfeld"
            ],
            "title": "The complexity of approximating the entropy",
            "venue": "SIAM Journal on Computing,",
            "year": 2005
        },
        {
            "authors": [
                "T. Batu",
                "E. Fischer",
                "L. Fortnow",
                "R. Kumar",
                "R. Rubinfeld",
                "P. White"
            ],
            "title": "Testing random variables for independence and identity",
            "venue": "In Proceedings of the 42nd IEEE Symposium on Foundations of Computer Science,",
            "year": 2001
        },
        {
            "authors": [
                "T. Batu",
                "L. Fortnow",
                "R. Rubinfeld",
                "W.D. Smith",
                "P. White"
            ],
            "title": "Testing that distributions are close",
            "venue": "In Proceedings of the 41st Annual Symposium on Foundations of Computer Science,",
            "year": 2000
        },
        {
            "authors": [
                "T. Batu",
                "L. Fortnow",
                "R. Rubinfeld",
                "W.D. Smith",
                "P. White"
            ],
            "title": "Testing closeness of discrete distributions",
            "venue": "Journal of the ACM,",
            "year": 2013
        },
        {
            "authors": [
                "C. Butucea",
                "M. Gu\u0163\u01ce",
                "T. Kypraios"
            ],
            "title": "Spectral thresholding quantum tomography for low rank states",
            "venue": "New Journal of Physics,",
            "year": 2015
        },
        {
            "authors": [
                "S. Bravyi",
                "A.W. Harrow",
                "A. Hassidim"
            ],
            "title": "Quantum algorithms for testing properties of distributions",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2011
        },
        {
            "authors": [
                "G. Brassard",
                "P H\u00f8yer",
                "M. Mosca",
                "A. Tapp"
            ],
            "title": "Quantum amplitude amplification and estimation",
            "venue": "Quantum Computation and Information,",
            "year": 2002
        },
        {
            "authors": [
                "F.G.S.L. Brand\u00e3o",
                "A. Kalev",
                "T. Li",
                "C.Y.-Y. Lin",
                "K.M. Svore",
                "X. Wu"
            ],
            "title": "Quantum SDP solvers: Large speed-ups, optimality, and applications to quantum learning",
            "venue": "In Proceedings of the 46th International Colloquium on Automata, Languages and Programming,",
            "year": 2019
        },
        {
            "authors": [
                "T. Batu",
                "R. Kumar",
                "R. Rubinfeld"
            ],
            "title": "Sublinear algorithms for testing monotone and unimodal distributions",
            "venue": "In Proceedings of the 36th Annual ACM Symposium on Theory of Computing,",
            "year": 2004
        },
        {
            "authors": [
                "M. Bun",
                "R. Kothari",
                "J. Thaler"
            ],
            "title": "The polynomial method strikes back: Tight quantum query bounds via dual polynomials",
            "venue": "Theory of Computing,",
            "year": 2020
        },
        {
            "authors": [
                "C. B\u01cedescu",
                "R. O\u2019Donnell",
                "J. Wright"
            ],
            "title": "Quantum state certification",
            "venue": "In Proceedings of the 51st ACM Symposium on Theory of Computing,",
            "year": 2019
        },
        {
            "authors": [
                "S. Chan",
                "I. Diakonikolas",
                "P. Valiant",
                "G. Valiant"
            ],
            "title": "Optimal algorithms for testing closeness of discrete distributions",
            "venue": "In Proceedings of the 2014 Annual ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2014
        },
        {
            "authors": [
                "S. Chakraborty",
                "E. Fischer",
                "A. Matsliah",
                "R. de Wolf"
            ],
            "title": "New results on quantum property testing",
            "venue": "In Proceedings of the 30th International Conference on Foundations of Software Technology and Theoretical Computer Science,",
            "year": 2010
        },
        {
            "authors": [
                "S. Chakraborty",
                "A. Gily\u00e9n",
                "S. Jeffery"
            ],
            "title": "The power of block-encoded matrix powers: improved regression techniques via faster hamiltonian simulation",
            "venue": "In Proceedings of the 46th International Colloquium on Automata, Languages, and Programming,",
            "year": 2019
        },
        {
            "authors": [
                "N. Chia",
                "A. Gily\u00e9n",
                "T. Li",
                "H. Lin",
                "E. Tang",
                "C. Wang"
            ],
            "title": "Sampling-based sublinear low-rank matrix arithmetic framework for dequantizing quantummachine learning",
            "venue": "In Proceedings of the 52nd Annual ACM SIGACT Symposium on Theory of Computing,",
            "year": 2020
        },
        {
            "authors": [
                "A.M. Childs",
                "R. Kothari",
                "R.D. Somma"
            ],
            "title": "Quantum algorithm for systems of linear equations with exponentially improved dependence on precision",
            "venue": "SIAM Journal on Computing,",
            "year": 2017
        },
        {
            "authors": [
                "M. Cerezo",
                "A. Poremba",
                "L. Cincio",
                "P.J. Coles"
            ],
            "title": "Variational quantum fidelity estimation",
            "year": 2020
        },
        {
            "authors": [
                "R. Chen",
                "Z. Song",
                "X. Zhao",
                "X. Wang"
            ],
            "title": "Variational quantum algorithms for trace distance and fidelity estimation",
            "venue": "ArXiv e-prints,",
            "year": 2020
        },
        {
            "authors": [
                "A.M. Childs",
                "N. Wiebe"
            ],
            "title": "Hamiltonian simulation using linear combinations of unitary operations",
            "venue": "Quantum Information & Computation,",
            "year": 2012
        },
        {
            "authors": [
                "N. Datta"
            ],
            "title": "Min- and max-relative entropies and a new entanglement monotone",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2009
        },
        {
            "authors": [
                "I. Diakonikolas",
                "D.M. Kane"
            ],
            "title": "A new approach for testing properties of discrete distributions",
            "venue": "In Proceedings of the 57nd IEEE Symposium on Foundations of Computer Science,",
            "year": 2016
        },
        {
            "authors": [
                "A.K. Ekert",
                "C.M. Alves",
                "D.K.L. Oi",
                "M. Horodecki",
                "P. Horodecki",
                "L.C. Kwek"
            ],
            "title": "Direct estimations of linear and nonlinear functionals of a quantum state",
            "venue": "Physical Review Letters,",
            "year": 2002
        },
        {
            "authors": [
                "N. Ezzell",
                "Z. Holmes",
                "P.J. Coles"
            ],
            "title": "The quantum low-rank approximation problem",
            "venue": "ArXiv e-prints,",
            "year": 2022
        },
        {
            "authors": [
                "K. Fujii",
                "H. Kobayashi",
                "T. Morimae",
                "H. Nishimura",
                "S. Tamate",
                "S. Tani"
            ],
            "title": "Impossibility of classically simulating one-clean-qubit model with multiplicative error",
            "venue": "Physical Review Letters,",
            "year": 2018
        },
        {
            "authors": [
                "T. Gur",
                "M. Hsieh",
                "S. Subramanian"
            ],
            "title": "Sublinear quantum algorithms for estimating von Neumann entropy",
            "venue": "ArXiv e-prints,",
            "year": 2021
        },
        {
            "authors": [
                "A. Gily\u00e9n"
            ],
            "title": "Quantum Singular Value Transformation & Its Algorithmic Applications",
            "year": 2019
        },
        {
            "authors": [
                "A. Gily\u00e9n",
                "T. Li"
            ],
            "title": "Distributional property testing in a quantum world",
            "venue": "In Proceedings of the 11th Innovations in Theoretical Computer Science Conference,",
            "year": 2020
        },
        {
            "authors": [
                "D. Gross",
                "Y.K. Liu",
                "S.T. Flammia",
                "S. Becker",
                "J. Eisert"
            ],
            "title": "Quantum state tomography via compressed sensing",
            "venue": "Physical Review Letters,",
            "year": 2010
        },
        {
            "authors": [
                "A. Gily\u00e9n",
                "S. Lloyd",
                "I. Marvian",
                "Y. Quek",
                "M.M. Wilde"
            ],
            "title": "Quantum algorithm for Petz recovery channels and pretty good measurement",
            "venue": "ArXiv e-prints,",
            "year": 2020
        },
        {
            "authors": [
                "A. Gily\u00e9n",
                "S. Lloyd",
                "E. Tang"
            ],
            "title": "Quantum-inspired low-rank stochastic regression with logarithmic dependence on the dimension",
            "venue": "ArXiv e-prints,",
            "year": 2018
        },
        {
            "authors": [
                "A. Gily\u00e9n",
                "A. Poremba"
            ],
            "title": "Improved quantum algorithms for fidelity estimation",
            "venue": "ArXiv e-prints,",
            "year": 2022
        },
        {
            "authors": [
                "L.K. Grover"
            ],
            "title": "A fast quantum mechanical algorithm for database search",
            "venue": "In Proceedings of the Twenty-eighth Annual ACM Symposium on Theory of Computing,",
            "year": 1996
        },
        {
            "authors": [
                "A. Gily\u00e9n",
                "Y. Su",
                "G.H. Low",
                "N. Wiebe"
            ],
            "title": "Quantum singular value transformation and beyond: exponential improvements for quantum matrix arithmetics",
            "venue": "In Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing,",
            "year": 2019
        },
        {
            "authors": [
                "J. Haah",
                "A.W. Harrow",
                "Z. Ji",
                "X. Wu",
                "N. Yu"
            ],
            "title": "Sample-optimal tomography of quantum states",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2017
        },
        {
            "authors": [
                "A.W. Harrow",
                "A. Hassidim",
                "S. Lloyd"
            ],
            "title": "Quantum algorithm for linear systems of equations",
            "venue": "Physical Review Letters,",
            "year": 2009
        },
        {
            "authors": [
                "X. Hu",
                "Z. Ye"
            ],
            "title": "Generalized quantum entropy",
            "venue": "Journal of mathematical physics,",
            "year": 2006
        },
        {
            "authors": [
                "R. Jozsa"
            ],
            "title": "Fidelity for mixed quantum states",
            "venue": "Journal of Modern Optics,",
            "year": 1994
        },
        {
            "authors": [
                "J. Jiao",
                "K. Venkat",
                "Y. Han",
                "T. Weissman"
            ],
            "title": "Minimax estimation of functionals of discrete distributions",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2015
        },
        {
            "authors": [
                "S. Kullback",
                "R.A. Leibler"
            ],
            "title": "On information and sufficiency",
            "venue": "Annals of Mathematical Statistics,",
            "year": 1951
        },
        {
            "authors": [
                "S. Kimmel",
                "C.Y. Lin",
                "G.H. Low",
                "M. Ozols",
                "T.J. Yoder"
            ],
            "title": "Hamiltonian simulation with optimal sample complexity",
            "venue": "npj Quantum Information,",
            "year": 2017
        },
        {
            "authors": [
                "M. Kieferov\u00e1",
                "C.O. Marrero",
                "N. Wiebe"
            ],
            "title": "Quantum generative training using R\u00e9nyi divergences",
            "venue": "ArXiv e-prints,",
            "year": 2021
        },
        {
            "authors": [
                "R. Kothari"
            ],
            "title": "Efficient algorithms in quantum query complexity",
            "venue": "PhD thesis, University of Waterloo,",
            "year": 2014
        },
        {
            "authors": [
                "R. K\u00f6nig",
                "R. Renner",
                "C. Schnaffer"
            ],
            "title": "The operational meaning of min- and maxentropy",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2009
        },
        {
            "authors": [
                "A.R. Kuzmak"
            ],
            "title": "Measuring distance between quantum states on a quantum computer",
            "venue": "Quantum Information Processing,",
            "year": 2021
        },
        {
            "authors": [
                "S. Lloyd",
                "S. Bosch",
                "G. De Palma",
                "B. Kiani",
                "Z.-W. Liu",
                "M. Marvian",
                "P. Rebentrost",
                "D.M. Arvidsson-Shukur"
            ],
            "title": "Quantum polar decomposition algorithm",
            "venue": "ArXiv e-prints,",
            "year": 2020
        },
        {
            "authors": [
                "G.H. Low",
                "I.L. Chuang"
            ],
            "title": "Optimal Hamiltonian simulation by quantum signal processing",
            "venue": "Physical Review Letters,",
            "year": 2017
        },
        {
            "authors": [
                "G.H. Low",
                "I.L. Chuang"
            ],
            "title": "Hamiltonian simulation by qubitization",
            "year": 2019
        },
        {
            "authors": [
                "S. Lloyd",
                "B.T. Kiani",
                "D.M. Arvidsson-Shukur",
                "S. Bosch",
                "G. De Palma",
                "W.M. Kaminsky",
                "Z.-W. Liu",
                "M. Marvian"
            ],
            "title": "Hamiltonian singular value transformation and inverse block encoding",
            "venue": "ArXiv e-prints,",
            "year": 2021
        },
        {
            "authors": [
                "S. Lloyd",
                "M. Mohseni",
                "P. Rebentrost"
            ],
            "title": "Quantum principal component analysis",
            "venue": "Nature Physics,",
            "year": 2014
        },
        {
            "authors": [
                "N. Linden",
                "M. Mosonyi",
                "A. Winter"
            ],
            "title": "The structure of R\u00e9nyi entropic inequalities",
            "venue": "Proceedings of the Royal Society A Mathematical,",
            "year": 2012
        },
        {
            "authors": [
                "T. Li",
                "X. Wu"
            ],
            "title": "Quantum query complexity of entropy estimation",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2019
        },
        {
            "authors": [
                "A. Montanaro",
                "R. de Wolf"
            ],
            "title": "A survey of quantum property testing",
            "venue": "Theory of Computing Library, Graduate Surveys,",
            "year": 2016
        },
        {
            "authors": [
                "M. M\u00fcller-Lennert",
                "F. Dupuis",
                "O. Szehr",
                "S. Fehr",
                "M. Tomamichel"
            ],
            "title": "On quantum R\u00e9nyi entropies: A new generalization and some properties",
            "venue": "Journal of Mathematical Physics,",
            "year": 2013
        },
        {
            "authors": [
                "A. Montanaro"
            ],
            "title": "Quantum speedup of Monte Carlo methods",
            "venue": "Proceedings of the Royal Society A,",
            "year": 2015
        },
        {
            "authors": [
                "M.A. Nielsen",
                "I.L. Chuang"
            ],
            "title": "Quantum Computation and Quantum Information",
            "year": 2010
        },
        {
            "authors": [
                "M. Ohya",
                "D. Petz"
            ],
            "title": "Quantum Entropy and Its Use",
            "venue": "Springer Science & Business Media,",
            "year": 2004
        },
        {
            "authors": [
                "R. O\u2019Donnell",
                "J. Wright"
            ],
            "title": "Quantum spectrum testing",
            "venue": "In Proceedings of the 47th ACM Symposium on Theory of Computing,",
            "year": 2015
        },
        {
            "authors": [
                "R. O\u2019Donnell",
                "J. Wright"
            ],
            "title": "Efficient quantum tomography",
            "venue": "In Proceedings of the 48th ACM Symposium on Theory of Computing,",
            "year": 2016
        },
        {
            "authors": [
                "R. O\u2019Donnell",
                "J. Wright"
            ],
            "title": "Efficient quantum tomography II",
            "venue": "In Proceedings of the 49th ACM Symposium on Theory of Computing,",
            "year": 2017
        },
        {
            "authors": [
                "L. Paninski"
            ],
            "title": "Estimation of entropy and mutual information",
            "venue": "Neural Computation,",
            "year": 2003
        },
        {
            "authors": [
                "L. Paninski"
            ],
            "title": "Estimating entropy on m bins given fewer than m samples",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2004
        },
        {
            "authors": [
                "L. Paninski"
            ],
            "title": "A coincidence-based test for uniformity given very sparsely sampled discrete data",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2008
        },
        {
            "authors": [
                "D. Petz",
                "D. Virosztek"
            ],
            "title": "Some inequalities for quantum tsallis entropy related to the strong subadditivity",
            "venue": "Mathematical Inequalities and Applications,",
            "year": 2015
        },
        {
            "authors": [
                "Y. Quek",
                "P. Rebentrost"
            ],
            "title": "Fast algorithm for quantum polar decomposition, pretty-good measurements, and the procrustes problem",
            "venue": "ArXiv e-prints,",
            "year": 2021
        },
        {
            "authors": [
                "A.E. Rastegin"
            ],
            "title": "Some general properties of unified entropies",
            "venue": "Journal of Statistical Physics,",
            "year": 2011
        },
        {
            "authors": [
                "A. R\u00e9nyi"
            ],
            "title": "On measures of entropy and information",
            "venue": "University of California Press, Berkeley, California,",
            "year": 1961
        },
        {
            "authors": [
                "P. Rebentrost",
                "A. Steffens",
                "I. Marvian",
                "S. Lloyd"
            ],
            "title": "Quantum singular-value decomposition of nonsparse low-rank matrices",
            "venue": "Physical Review A,",
            "year": 2018
        },
        {
            "authors": [
                "S. Subramanian",
                "M. Hsieh"
            ],
            "title": "Quantum algorithm for estimating \u03b1-Renyi entropies of quantum states",
            "venue": "Physical Review A,",
            "year": 2021
        },
        {
            "authors": [
                "C.E. Shannon"
            ],
            "title": "A mathematical theory of communication",
            "venue": "Bell System Technical Journal,",
            "year": 1948
        },
        {
            "authors": [
                "R.D. Somma",
                "G. Ortiz",
                "J.E. Gubernatis",
                "E. Knill",
                "R. Laflamme"
            ],
            "title": "Simulating physical phenomena by quantum networks",
            "venue": "Physical Review A,",
            "year": 2002
        },
        {
            "authors": [
                "M. Szegedy"
            ],
            "title": "Quantum speed-up of Markov chain based algorithms",
            "venue": "In Proceedings of the 45th IEEE Symposium on Foundations of Computer Science,",
            "year": 2004
        },
        {
            "authors": [
                "E. Tang"
            ],
            "title": "A quantum-inspired classical algorithm for recommendation systems",
            "venue": "In Proceedings of the 51st Annual Symposium on Theory of Computing,",
            "year": 2019
        },
        {
            "authors": [
                "C. Tsalli"
            ],
            "title": "Possible generalization of Boltzmann-Gibbs statistics",
            "venue": "Journal of Statistical Physics,",
            "year": 1988
        },
        {
            "authors": [
                "K.C. Tan",
                "T. Volkoff"
            ],
            "title": "Variational quantum algorithms to estimate rank, quantum entropies, fidelity, and fisher information via purity minimization",
            "venue": "Physical Review Research,",
            "year": 2021
        },
        {
            "authors": [
                "J. van Apeldoorn",
                "A. Gily\u00e9n"
            ],
            "title": "Improvements in quantum SDP-solving with applications",
            "venue": "In Proceedings of the 46th International Colloquium on Automata, Languages, and Programming,",
            "year": 2019
        },
        {
            "authors": [
                "W. van Dam",
                "P. Hayden"
            ],
            "title": "R\u00e9nyi-entropic bounds on quantum communication",
            "venue": "ArXiv e-prints,",
            "year": 2002
        },
        {
            "authors": [
                "J. von Neumann"
            ],
            "title": "Mathematische Grundlagen der Quantenmechanik (Mathematical Foundations of Quantum Mechanics)",
            "year": 1932
        },
        {
            "authors": [
                "G. Valiant",
                "P. Valiant"
            ],
            "title": "Estimating the unseen: an n/log(n)-sample estimator for entropy and support size, shown optimal via new CLTs",
            "venue": "In Proceedings of the 43rd Annual ACM Symposium on Theory of Computing,",
            "year": 2011
        },
        {
            "authors": [
                "G. Valiant",
                "P. Valiant"
            ],
            "title": "The power of linear estimators",
            "venue": "In Proceedings of the 52nd Annual Symposium on Foundations of Computer Science,",
            "year": 2011
        },
        {
            "authors": [
                "J. Watrous"
            ],
            "title": "Limits on the power of quantum statistical zero-knowledge",
            "venue": "In Proceedings of the 43rd Annual IEEE Symposium on Foundations of Computer Science,",
            "year": 2002
        },
        {
            "authors": [
                "M.M. Wilde",
                "A. Winter",
                "D. Yang"
            ],
            "title": "Strong converse for the classical capacity of entanglement-breaking and Hadamard channels via a sandwiched R\u00e9nyi relative entropy",
            "venue": "Communications in Mathematical Physics,",
            "year": 2014
        },
        {
            "authors": [
                "Y. Wu",
                "P. Yang"
            ],
            "title": "Minimax rates of entropy estimation on large alphabets via best polynomial approximation",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2016
        },
        {
            "authors": [
                "Q.S. Wang",
                "Z.C. Zhang",
                "K.A. Chen",
                "J. Guan",
                "W. Fang",
                "M.S. Ying"
            ],
            "title": "Quantum algorithm for fidelity estimation",
            "venue": "ArXiv e-prints,",
            "year": 2021
        },
        {
            "authors": [
                "Y. Wang",
                "B. Zhao",
                "X. Wang"
            ],
            "title": "Quantum algorithms for estimating quantum entropies",
            "venue": "ArXiv e-prints,",
            "year": 2022
        },
        {
            "authors": [
                "N.K. Yu"
            ],
            "title": "Sample efficient identity testing and independence testing of quantum states",
            "venue": "In 12th Innovations in Theoretical Computer Science Conference,",
            "year": 2021
        },
        {
            "authors": [
                "X. Zhang",
                "M. Luo",
                "Z. Wen",
                "Q. Feng",
                "S. Pang",
                "W. Luo",
                "X. Zhou"
            ],
            "title": "Direct fidelity estimation of quantum states using machine learning",
            "venue": "Physical Review Letters,",
            "year": 2021
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n20 3.\n13 52\n2v 2\n[ qu\nan t-\nph ]\n2 A\npr 2\n( r2/\u03b52 ) , O\u0303 ( r5/\u03b56 ) and O\u0303 ( r6.5/\u03b57.5 )\n1, respectively. In contrast, the known algorithms for the von Neumann entropy and trace distance require quantum time complexity of \u2126(N) [AISW19,GL20,GHS21], and the best known one for fidelity requires O\u0303 ( r21.5/\u03b523.5 )\n[WZC+21]. The key idea of our quantum algorithms is to extend block-encoding from unitary operators in previous work to quantum states (i.e., density operators). It is realized by developing several convenient techniques to manipulate quantum states and extract information from them. In particular, we introduce a novel technique for eigenvalue transformation of density operators and their (non-integer) positive powers, based on the powerful quantum singular value transformation (QSVT) [GSLW19]. The advantage of our techniques over the existing methods is that no restrictions on density operators are required; in sharp contrast, the previous methods usually require a lower bound of the minimal non-zero eigenvalue of density operators. In addition, we provide some techniques of independent interest for trace estimation, linear combinations, and eigenvalue threshold projectors of (subnormalized) density operators, which will be, we believe, useful in other quantum algorithms.\nKeywords: Quantum Computing, Quantum Algorithms, Quantum Entropy, Trace Distance, Quantum Fidelity.\n\u2217Department of Computer Science and Technology, Tsinghua University, China. Email: QishengWang1994@gmail.com\n\u2020State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, China. Email: guanji1992@gmail.com\n\u2021State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, China; University of Chinese Academy of Sciences, China. Email: liujy@ios.ac.cn\n\u00a7Centre for Quantum Software and Information, University of Technology Sydney, Australia. Email: iszczhang@gmail.com\n\u00b6State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, China; Department of Computer Science and Technology, Tsinghua University, China. Email: yingms@ios.ac.cn\n1O\u0303(\u00b7) suppresses polylogarithmic factors of r, \u03b5 and N ."
        },
        {
            "heading": "1 Introduction",
            "text": "Quantum entropies and distances are basic concepts [NC10] in quantum physics and quantum information. Quantum entropies characterize the randomness of a quantum system, while quantum distances measure the closeness of quantum systems. It is important to compute their values in many important applications, from the estimation of the capacity of quantum communication channels and verification of the outcomes of quantum computation to the characterization of quantum physical systems (see, e.g., [OP04,ZLW+21,Kuz21]). Several kinds of quantum algorithms for computing quantum entropies and distances have been proposed under different computational resources, e.g., quantum algorithms with access to copies of quantum states [BOW19,AISW19,WZW22], quantum algorithms with purified quantum query access [GL20, GHS21, SH21,WZC+21], and variational quantum algorithms [CPCC20,CSZW20,TV21].\nA main consideration of some quantum algorithms for computing quantum entropies and distances is the number of copies of quantum states used in the algorithms. For example, [BOW19] provided a method of testing the closeness of N -dimensional mixed quantum states with respect to trace distance and fidelity using O(N/\u03b52) and O(N/\u03b5) copies, respectively, based on quantum spectrum testing [OW15] and efficient quantum tomography [OW16,OW17,HHJ+17]. [AISW19] introduced a method of computing the von Neumann and quantum Re\u0301nyi entropies of an N -dimensional quantum state using O(N2/\u03b52) and O(N2/\u03b1/\u03b52/\u03b1) copies, respectively. Recently, a new method of computing the von Neumann and quantum Re\u0301nyi entropies was proposed in [WZW22] using O\u0303(\u03ba2/\u03b55) copies, where \u03ba > 0 is given such that \u03a0/\u03ba \u2264 \u03c1 \u2264 I for some projector \u03a0. A distributed quantum algorithm for computing tr(\u03c1\u03c3), i.e., the fidelity of pure quantum states, was proposed in [ALL21] using O(max{ \u221a N/\u03b5, 1/\u03b52}) copies.\nAnother class of quantum algorithms for computing quantum entropies and distances utilize the conventional \u201cpurified quantum query access\u201d model, where mixed quantum states are given by quantum oracles that prepare their purifications. [GL20] developed quantum algorithms for computing the von Neumann entropy and trace distance with query complexity O(N/\u03b51.5) and O(N/\u03b5), respectively, both of which have complexity exponential in the number of qubits. Recently, [GHS21] proposed a quantum algorithm for computing the von Neumann entropy within a multiplicative factor, which can reproduce the result of [GL20] within additive error. [SH21] found a method of computing the quantum \u03b1-Renyi entropy using O (\n\u03ba (x\u03b5)2 log ( N \u03b5 )\n)\nqueries to the oracle, where \u03ba > 0\nis given such that I/\u03ba \u2264 \u03c1 \u2264 I and x = tr(\u03c1\u03b1)/N . The quantum algorithms with purified quantum query access mentioned above are developed in the general framework of quantum singular value transformation (QSVT) [GSLW19]. The powerful technique of QSVT on unitary operators developed by [GSLW19] has been successfully applied in improving a wide range of quantum algorithms, including Grover\u2019s search algorithm [Gro96], the quantum walk algorithms [Amb04, Sze04], the HHL algorithm for solving systems of linear equations [HHL09], and Hamiltonian simulation [LC17]. The original QSVT deals with unitary operators, but a Hamiltonian variant of the QSVT was proposed in [LKAS+21], which is then used in quantum polar decomposition [LBDP+20,QR21].\nExcept for unitary operators and Hamiltonians, density operators (mixed quantum states) are another important class of objects we need to deal with in quantum computation. [LC19] developed a technique to implement a unitary operator that block-encodes a (purified) density operator. This technique has been employed in quantum algorithms for semidefinite programming [vAG19] and quantum fidelity estimation [WZC+21]. Conversely, however, it seems difficult to prepare a quantum state given as a density operator block-encoded in a unitary operator.\nA natural idea of extracting information from a density operator is to directly manipulate the\nquantum state itself rather than a unitary operator that encodes it. This leads us to extend the definition of block-encoding proposed originally for unitary operators [LC19,GSLW19,CGJ19] to that for general operators (see Definition 2.1), especially for quantum states (i.e., density operators). Regarding quantum states as block-encodings, we are able to design new quantum algorithms for computing a wide range of quantum entropies and distances, such as the von Neumann entropy, quantum Re\u0301nyi entropy, quantum Tsallis entropy, trace distance, and fidelity. These quantum algorithms significantly outperform the best known ones in the low-rank case, and some of them can even achieve exponential speedups. Here, the low-rank case means that the rank of N -dimensional quantum states is much smaller than N , e.g., r = polylog(N), which is of great interest in both theoretical (e.g., [GLF+10,EHC22]) and experimental (e.g., [BGK15]) physics.\nIn the remainder of this Introduction, we will first present our main results in Section 1.1. The new techniques that enable us to achieve our results will be outlined in Section 1.2. Then related works will be reviewed in Section 1.3, and a discussion will be given in Section 1.4."
        },
        {
            "heading": "1.1 Main Results",
            "text": "Let us first set the stage for presenting our main results. In order to manipulate quantum states, we extend the definition of block-encoding for unitary operators to that for general operators (see Definition 2.1), and use this extended definition of block-encoding to describe our quantum algorithms. In our quantum algorithms, a mixed quantum state is given by a quantum unitary operator (oracles) which prepares a purification of the state (see Definition 2.2). This conventional model is known as the \u201cpurified quantum query access\u201d model and has been widely used in developing quantum algorithms [BKL+19,vAG19,GL20,GLM+20,ARSW21,GHS21,SH21].\nThroughout this paper, the quantum query complexity of a quantum query algorithm means the number of queries to the given quantum oracles. The time complexity of a quantum query algorithm is the sum of its quantum query complexity and the number of elementary quantum gates used in it. When quantum algorithms are compared with classical algorithms, quantum oracles are given as classical descriptions of quantum circuits. The actual number of elementary quantum gates performed in the quantum algorithm only has a polynomial overhead compared to its \u201ctime complexity\u201d defined here. Then our main results can be summarized in the following:\nTheorem 1.1 (Informal). Given \u201cpurified quantum query access\u201d quantum oracles that prepare N -dimensional mixed quantum states of rank r, there are quantum query algorithms that compute\n\u2022 von Neumann entropy,\n\u2022 quantum \u03b1-Re\u0301nyi entropies for \u03b1 \u2208 (0, 1) \u222a (1,+\u221e),\n\u2022 quantum \u03b1-Tsallis entropies for \u03b1 \u2208 (0, 1) \u222a (1,+\u221e),\n\u2022 \u03b1-trace distance for \u03b1 > 0 (defined by Equation (1), including the trace distance), and\n\u2022 \u03b1-fidelity for 0 < \u03b1 < 1 (defined by Equation (2), including the fidelity)\nwithin additive error \u03b5 with time complexity poly(log(N), r, 1/\u03b5), where the time complexity hides a constant which depends only on \u03b1. 2\n2A few days after this paper was submitted to arXiv, the concurrent work of Gilye\u0301n and Poremba [GP22] appeared. They proposed a quantum algorithm for fidelity estimation using identical copies of quantum states based on density matrix exponentiation [LMR14,KLL+17]. We note that their techniques of converting identical copies to unitary block-encodings (Corollary 21 in [GP22]) can be applied to our quantum algorithms in Theorem 1.1. As a result, we can obtain quantum algorithms for computing these quantum entropies and distances using poly(r, 1/\u03b5) copies of quantum states, which only has a polynomial overhead compared to the query complexity of our algorithms.\nOur quantum algorithms are compared with the existing algorithms for the same problems in Table 1. In particular, our algorithms outperform the best known ones in the low-rank case, e.g., r = polylog(N). More precisely:\n\u2022 For the von Neumann entropy, quantum Re\u0301nyi entropy and trace distance, our quantum algorithms are exponentially faster than those given in [AISW19,BOW19,GL20,SH21] in the low-rank case (although they are designed for the general case).\n\u2022 For the quantum algorithms in [SH21] and [WZW22] that attempt to reduce the dependence on N , they introduce an extra dependence on \u03ba, where \u03ba is the reciprocal of the minimal non-zero eigenvalue of quantum states. Our quantum algorithms can be easily adapted to their settings by taking r = O(\u03ba), but the converse seems not applicable 3.\n\u2022 For the fidelity, our quantum algorithm achieves a polynomial speedup over the one given in [WZC+21].\nWe will further discuss about the above results for quantum entropies in Section 1.1.1 and those for closeness (i.e. trace distance and fidelity) of quantum states in Section 1.1.2."
        },
        {
            "heading": "1.1.1 Computing quantum entropies",
            "text": "In quantum information theory, the entropy of a (mixed) quantum state is a measure of its uncertainty, and computing its value is crucial when characterizing and verifying an unknown quantum system. After von Neumann [vN32] introduced the famous von Neumann entropy\nS(\u03c1) = \u2212 tr (\u03c1 ln (\u03c1)) , 3This is because \u03ba implies an upper bound r \u2264 \u03ba of rank, but r does not imply any upper bound of \u03ba. 4This is the sample complexity of testing the closeness of quantum states with respect to the trace distance (resp. fidelity). It is worth mentioning that testing the closeness can be solved by computing the closeness, but the converse seems difficult.\n5In the concurrent work of Gilye\u0301n and Poremba [GP22], they presented a different quantum algorithm for fidelity estimation with a better query complexity O\u0303 ( r2.5/\u03b55 ) .\nwhich is a natural generalization of the classical Shannon entropy [Sha48], several other entropies have been proposed, e.g., Re\u0301nyi entropy [Re\u0301n61, LMW13, MLDS+13, WWY14], Tsallis entropy [Tsa88,Aud07, PV15], Min and Max (Hartley) entropies [vDH02,Dat09,KRS09], and the unified entropy [HY06, Ras11]. The quantum \u03b1-Re\u0301nyi entropy and the quantum \u03b1-Tsallis entropy are defined by\nSR\u03b1 (\u03c1) = 1\n1\u2212 \u03b1 ln (tr (\u03c1 \u03b1)) , ST\u03b1 (\u03c1) =\n1\n1\u2212 \u03b1 (tr (\u03c1 \u03b1)\u2212 1)\nfor \u03b1 \u2208 (0, 1)\u222a (1,+\u221e), respectively. It is easy to see that the von Neumann entropy is a limit case of the Re\u0301nyi entropy [MLDS+13] and the Tsallis entropy [Tsa88]:\nS(\u03c1) = lim \u03b1\u21921 SR\u03b1 (\u03c1) = lim \u03b1\u21921 ST\u03b1 (\u03c1).\nFor \u03b1 = 0, the quantum Tsallis entropy degenerates to the rank of quantum states:\nST0 (\u03c1) = rank(\u03c1)\u2212 1\nand the quantum Re\u0301nyi entropy becomes the logarithm of the rank, i.e., the quantumMax (Hartley) entropy:\nSmax(\u03c1) = SR0 (\u03c1) = ln(rank(\u03c1)).\nOverview Given a quantum unitary oracle that prepares a mixed quantum state (see Definition 2.2). We develop quantum algorithms for computing several quantum entropies. Their quantum query complexities are collected in Table 2, which are also their quantum time complexities up to polylogarithmic factors. Most of our algorithms do not require any restrictions on the lower bound of the eigenvalues of quantum states except those for computing the quantum Max entropy and the rank of quantum states, where \u03a0/\u03ba \u2264 \u03c1 is required for some projector \u03a0 and \u03ba > 0.\nThe previous best known quantum algorithms for computing von Neumann entropy [AISW19, GL20,GHS21] and quantum Re\u0301nyi entropy [AISW19, SH21] have time complexity \u2126(N) even for rank r = 2. Compared to them, our quantum algorithms are exponentially faster in the low-rank case.\nIt is worth mentioning that for odd integer \u03b1 > 1, the query complexity of computing the quantum Tsallis entropy ST\u03b1 (\u03c1) does not depend on rank r. In this case, there is a simple SWAP testlike quantum algorithm that computes tr(\u03c1\u03b1) using O(1/\u03b52) copies [EAO+02,KLL+17]. Compared to it, our algorithm (Theorem 3.7) yields a quadratic speedup (see Section 3.3 for more discussions). For non-integer \u03b1, we are not aware of any approach for computing the quantum Tsallis entropy with complexity better than quantum state tomography.\nLower bounds We are able to give a lower bound \u2126\u0303(rc) for computing the quantum Re\u0301nyi entropy SR\u03b1 (\u03c1) including the von Neumann entropy S(\u03c1) in terms of rank r, where c \u2265 1/3 is a constant depending only on \u03b1 (see Theorem 3.11). This lower bound is simply derived from the quantum query complexity for computing the Re\u0301nyi (and Shannon) entropy of classical probability distributions [LW19,BKT20]."
        },
        {
            "heading": "1.1.2 Computing quantum distances",
            "text": "Distance measures of quantum states are basic quantities in quantum computation and quantum information. Two of the most important distance measures are the trace distance and fidelity. For each of them, we propose quantum algorithms that compute it and its extensions. Here, we assume that there are two quantum oracles U\u03c1 and U\u03c3 that prepare the density operators \u03c1 and \u03c3, respectively. The query complexity of a quantum algorithm means the total number of queries to both U\u03c1 and U\u03c3.\nTrace distance The \u03b1-trace distance of two quantum states \u03c1 and \u03c3 is defined by\nT\u03b1(\u03c1, \u03c3) = tr\n(\u2223\n\u2223 \u2223 \u2223 \u03c1\u2212 \u03c3 2\n\u2223 \u2223 \u2223 \u2223 \u03b1) = \u2225 \u2225 \u2225 \u2225 \u03c1\u2212 \u03c3 2 \u2225 \u2225 \u2225 \u2225 \u03b1\nS,\u03b1\n, (1)\nwhere \u2016A\u2016S,\u03b1 = (tr (|A| \u03b1))1/\u03b1 is the Schatten \u03b1-norm. Here, the 1-trace distance is the well-known trace distance T (\u03c1, \u03c3) = T1(\u03c1, \u03c3).\nWe develop quantum algorithms for computing \u03b1-trace distance for \u03b1 > 0, with their complexities shown in Table 3. As a special case, our quantum algorithm (Theorem 4.1) for computing the trace distance (i.e., the 1-trace distance) has time complexity of O\u0303 ( r5/\u03b56 )\n, which, in the low-rank case, is exponentially faster than the closeness-testing with respect to trace distance in [GL20] with query complexity O (N/\u03b5). Moreover, only the closeness testing of the \u03b1-trace distances of quantum states for integer \u03b1, e.g., the 1-, 2- and 3-trace distances, was studied in [GL20]. For other cases of \u03b1, we are not aware of any approaches to compute the \u03b1-trace distance with complexity better than quantum state tomography.\nFidelity The \u03b1-fidelity of two quantum states \u03c1 and \u03c3 is defined by\nF\u03b1(\u03c1, \u03c3) = exp ((\u03b1\u2212 1)D\u03b1(\u03c1\u2016\u03c3)) = tr (( \u03c3 1\u2212\u03b1 2\u03b1 \u03c1\u03c3 1\u2212\u03b1 2\u03b1 )\u03b1) , (2)\nwhere D\u03b1(\u03c1\u2016\u03c3) is the sandwiched quantum Re\u0301nyi relative entropy [WWY14,MLDS+13]. Here, the 1/2-fidelity is the well-known fidelity F (\u03c1, \u03c3) = F1/2(\u03c1, \u03c3) [Joz94].\nWe develop quantum algorithms for computing the \u03b1-fidelity for 0 < \u03b1 < 1, with their complexities shown in Table 4). As a special case, our quantum algorithm (Theorem 4.5) for computing the fidelity (i.e., the 1/2-fidelity) has a time complexity O\u0303 ( r6.5/\u03b57.5 ) , which is a polynomial speedup over the best known O\u0303 ( r21.5/\u03b523.5 )\nin [WZC+21]. For other cases of \u03b1, we do not know any approach to compute the \u03b1-fidelity with complexity better than quantum state tomography.\nLower bounds and hardness Our quantum algorithms for computing the fidelity and trace distance have a time complexity polynomial in the rank r. We show that there is no quantum algorithm that computes the fidelity or trace distance with time complexity poly(log(r), 1/\u03b5) unless BQP = QSZK (see Theorem 4.7), based on the result of [Wat02] that (\u03b1, \u03b2)-Quantum State Distinguishability is QSZK-complete for 0 \u2264 \u03b1 < \u03b22 \u2264 1.\nOur quantum algorithms for computing the fidelity and trace distance achieve a significant speedup under the low-rank assumption. One might wonder whether our algorithms can be \u201cdequantized\u201d through quantum-inspired low-rank techniques such as [Tan19,GLT18,CGL+20]. We argue that our algorithms are unlikely to be dequantized due to the DQC1-hardness of computing the fidelity and trace distance (see Theorem 4.8). It was shown in [FKM+18] that DQC1 is not (classically) weakly simulatable unless the polynomial hierarchy collapses to the second level, i.e., PH = AM."
        },
        {
            "heading": "1.2 Techniques",
            "text": "In this subsection, we give an overview of the techniques that enable us to achieve the results presented in the above subsection."
        },
        {
            "heading": "1.2.1 Quantum states as block-encodings",
            "text": "The key idea of our quantum algorithms is to regard quantum states as block-encodings. To this end, we extend the definition of block-encoding proposed for unitary operators to that for general ones (see Definition 2.1). Suppose that a unitary operator UA prepares a subnormalized density operator A (see Definition 2.2). In this framework, we provide a convenient way to manipulate the subnormalized density operator A and extract information from it as follows.\n\u2022 Evolution: If U is a unitary operator, which is a block-encoding of an operator B, we can prepare a subnormalized density operator BAB\u2020 (see Lemma 2.2). This evolution of the subnormalized density operator can be seen as a generalization of quantum unitary operation \u03c1 7\u2192 U\u03c1U \u2020 for (normalized) density operator \u03c1.\n\u2022 Trace Estimation: We provide an efficient method to estimate the trace of A based on quantum amplitude estimation [BHMT02] (see Lemma 2.15). As will be seen, trace estimation is an important subroutine in our quantum algorithms (see Section 1.1.1 and Section 1.1.2).\n\u2022 Linear Combinations: As an analog of Linear-Combination-of-Unitaries (LCU) algorithm through a series of work [SOG+02, CW12, Kot14, BCC+15, BCK15, CKS17, GSLW19], we also provide a technique to prepare a linear (convex) combination of subnormalized density operators (see Lemma 2.17). This technique will be used in computing the trace distance (see Section 1.1.2 and Theorem 4.1).\nThe technique of \u201ctrace estimation\u201d is the cornerstone in developing our quantum algorithms. To compute the values of quantum entropies and distances, the key part has the form tr(\u033a), where \u033a is a (subnormalized) density operator. Our strategy is to prepare a quantum state, which is a block-encoding of \u033a, through the technique of \u201cevolution\u201d. Roughly speaking, we prepare the subnormalized density operator \u033a up to a scaling factor; we will use the phrase \u201cprepare \u033a\u201d regardless of the scaling factor in the following discussion of this section. For example, we prepare \u2212\u03c1 ln(\u03c1) for the von Neumann entropy, and prepare \u03c1\u03b1 for the quantum \u03b1-Re\u0301nyi and Tsallis entropies. To achieve this, we develop techniques for eigenvalue transformation of density operators based on QSVT as follows.\n\u2022 Eigenvalue Transformation: Based on the evolution, if we can construct a unitary operator U , which is a block-encoding of P (A) for some polynomial P (\u00b7) as in QSVT [GSLW19], we can transform A to another subnormalized density operator A(P (A))2 (see Theorem 2.4).\n\u2022 Positive Powers: We develop a technique to prepare the subnormalized density operator Ac for 0 < c < 1 without any restrictions on A (see Lemma 2.8). Inspired by this, we can also obtain a unitary operator, which is a block-encoding of |A|c, using queries to a unitary operator U , which is a block-encoding of Hermitian operator A (see Lemma 2.13). In order to obtain block-encodings of powers of A, previously known methods [CGJ19,GSLW19,GLM+20] usually require a lower bound of the minimal non-zero eigenvalues of density operators; for example, I/\u03ba \u2264 A \u2264 I for some \u03ba > 0 in [CGJ19]. This technique for positive powers of subnormalized density operators will be frequently used in our quantum algorithms for computing quantum entropies, fidelity and trace distance (see Section 1.1.1 and Section 1.1.2), in order to avoid restrictions on density operators.\nWe also provide a method to block-encode the eigenvalue threshold projector \u03a0supp(A) of A in a quantum state, where supp(A) is the support of A, and \u03a0S is the projector onto subspace S.\n\u2022 Eigenvalue threshold projector: We propose a method to (approximately) block-encode the eigenvalue threshold projector \u03a0supp(A) of A in a subnormalized density operator (see Lemma 2.19). We note that [vAG19] also provided a technique for block-encoding eigenvalue threshold projectors, but they required that A \u2265 q\u03a0 for some projector \u03a0 and the value of q > 0 is known in advance. In contrast, our method does not impose any restriction on A. This method will be used in computing the trace distance (see Section 1.1.2 and Theorem 4.1).\nA comparison between density operators and unitary operators as block-encodings is given in Table 5.\nPositive Powers A\u2192 Ac(0 < c < 1) A\u2192 |A|c (0 < c < 1) Eigenvalue Threshold Projector A\u2192 (scaled) \u03a0supp(A) A\u2192 \u03a0supp(A) A is an Hermitian operator block-encoded in a density \u03c1 or a unitary operator U . B is block-encoded in a unitary operator. P (\u00b7) is a polynomial."
        },
        {
            "heading": "1.2.2 Example: computing trace distance",
            "text": "To give the reader a flavor, we take the quantum algorithm for computing the trace distance (see Theorem 4.1 for details) as an illustrative example. The key observation to compute the trace distance is that\nT (\u03c1, \u03c3) = tr ( |\u03bd|1/2 \u03a0supp(\u00b5) |\u03bd|1/2 ) ,\nwhere \u03bd = (\u03c1\u2212\u03c3)/2, \u00b5 = (\u03c1+\u03c3)/2. The idea is to prepare \u03b7 = |\u03bd|1/2 \u03a0supp(\u00b5) |\u03bd|1/2 (up to a scaling factor), and then estimate tr(\u03b7) through the technique of \u201ctrace estimation\u201d (Lemma 2.15). The computation process is shown in Figure 1.\nTo (approximately) prepare \u03b7, we first prepare \u03a0\u0302 \u2248 \u03a0supp(\u00b5) through the technique of \u201ceigenvalue threshold projector\u201d (Lemma 2.19). Here, \u00b5 = (\u03c1 + \u03c3)/2 can be prepared through the technique of \u201clinear combinations\u201d (Lemma 2.17). Then we only need to construct a unitary operator, which is a block-encoding of \u03bd\u0302 \u2248 |\u03bd|1/2. After that, by the technique of \u201cevolution\u201d (Lemma 2.2), we can prepare \u03bd\u0302\u03a0\u0302\u03bd\u0302\u2020 \u2248 |\u03bd|1/2 \u03a0\u0302 |\u03bd|1/2 \u2248 \u03b7.\nIn order to construct a unitary operator as a block-encoding of |\u03bd|1/2, we first use the LCU technique (Theorem 2.18) to block-encode \u03bd = (\u03c1\u2212 \u03c3)/2 in a unitary operator U\u03bd . Then applying the technique of \u201cpositive powers\u201d (Lemma 2.13) on U\u03bd , we can construct a unitary operator which is a block-encoding of \u03bd\u0302 \u2248 |\u03bd|1/2. 6Suppose A is an a-qubit Hermitian operator block-encoded in unitary operator U . Then tr(A)/2a = tr (\n(|0\u3009 \u30080| \u2297 Ia 2a )U ) can be computed through the Hadamard test [EAO+02].\nTo get an estimation of the trace distance between \u03c1 and \u03c3, we should just note that T (\u03c1, \u03c3) =\ntr(\u03b7) \u2248 tr ( \u03bd\u0302\u03a0\u0302\u03bd\u0302\u2020 ) , where we have already prepared \u03bd\u0302\u03a0\u0302\u03bd\u0302\u2020 through the above process. Strictly\nspeaking, we have prepared a mixed quantum state, whose density operator is a block-encoding of \u03bd\u0302\u03a0\u0302\u03bd\u0302\u2020 up to a scaling factor. After carefully selecting appropriate parameters that determine the errors in the above process, we obtain a quantum algorithm for computing the trace distance with query complexity O\u0303(r5/\u03b56), where r is (an upper bound of) the rank of quantum states \u03c1 and \u03c3, and \u03b5 is the desired additive error. Here, O\u0303(\u00b7) suppresses the polylogarithmic factor of N , where N is the dimension of the Hilbert space of \u03c1 and \u03c3."
        },
        {
            "heading": "1.3 Related Works",
            "text": "Classical property testing The problems considered in this paper can be thought of as a quantum analog of testing properties of probability distributions. Classical algorithms for testing properties of probability distributions have been widely studied since the beginning of this century. [BFR+00] first proposed an algorithm for the closeness testing of probability distributions in \u21131 distance using O\u0303(N2/3/\u03b54) samples, which was then improved to use O\u0303(N2/3/\u03b58/3) samples [BFR+13]. Later, [CDVV14] proved the optimal sample complexity \u0398 ( max{N2/3/\u03b54/3, N1/2/\u03b52} ) for this problem, and also the optimal sample complexity \u0398(1/\u03b52) for closeness testing in \u21132 distance. The identity testing is a special case of the closeness testing given that one of the distributions is known. [BFF+01] showed that O\u0303(N1/2/\u03b54) samples are sufficient for the identity testing in \u21131 distance, which was improved to optimal \u0398(N1/2/\u03b52) in [Pan08]. The independence testing, i.e., whether a distribution on [N ] \u00d7 [M ] (N \u2265 M) is or \u03b5-far from a product distribution in \u21131 distance, was shown to have sample complexity O\u0303(N2/3M1/3) \u00b7poly(1/\u03b5) [BFF+01]. Recently, [DK16] proposed a modular reduction-based approach that covers the closeness, identity and independence testing. They also gave a tight sample complexity \u0398 ( max{N2/3M1/3/\u03b54/3, (NM)1/2/\u03b52} ) for the independence testing. In addition, the monotonicity testing was also shown to have sample complexity O\u0303(N1/2/\u03b54) [BKR04].\nApart from property testing between distributions, properties of a single distribution are well studied in the literature, e.g., [BDKR05,Pan03,Pan04]. An algorithm that computes the Shannon entropy using O (\nN \u03b5 log(N)\n)\nsamples for \u03b5 = \u2126(N0.03) was proposed in [VV11a,VV11b]. After that,\n[JVHW15] and [WY16] gave the optimal estimator of Shannon entropy using \u0398 (\nN \u03b5 log(N) +\n(log(N))2\n\u03b52\n)\nsamples. Instead, [JVHW15] provided an estimator for exp ( (1\u2212 \u03b1)SR\u03b1 (p) ) , where SR\u03b1 (p) is the \u03b1Re\u0301nyi entropy of distribution p.\nQuantum property testing The emerging topic of quantum property testing (see [MdW16]) studies the quantum advantage in testing classical statistical and quantum information properties.\nQuantum advantages in testing classical statistical properties have been extensively studied. Quantum algorithms for testing properties of classical distributions was first studied in [BHH11], which gave quantum query complexity O(N1/2/\u03b56) for the closeness testing, and O(N1/3/\u03b54/3) for identity testing (to the uniform distribution) in \u21131 distance. Later, [CFMdW10] improved the quantum query complexity for the identity testing (to a known distribution) to O\u0303(N1/3/\u03b55), and [Mon15] improved that for the closeness testing in \u21131 distance to O\u0303(N1/2/\u03b52.5). Recently, [LW19] studied the quantum query complexity for computing the Shannon entropy and the Re\u0301nyi entropy; especially, an O\u0303(N1/2/\u03b52) quantum query complexity was shown for the Shannon entropy.\nThere are also some quantum algorithms for testing quantum information properties not mentioned above. [KLL+17] showed that testing orthogonality of pure quantum states needs \u0398(1/\u03b5)\ncopies, promised that either they are orthogonal or their fidelity \u2265 \u03b5. Recently, [Yu21] showed that quantum identity testing only requires O(N3/2/\u03b52) copies with the help of random choice of independent measurements."
        },
        {
            "heading": "1.4 Discussion",
            "text": "In this paper, we suggest a generalized definition of block-encoding, with which we can directly manipulate subnormalized density operators and extract information from them. Based on this, we develop new quantum algorithms that compute a large class of quantum entropies and distances, which achieve a significant speedup over the best known ones in the low-rank case. Several interesting problems remain open:\n\u2022 Our upper and lower bounds are far from being tight. Can we find more efficient algorithms or improve the lower bounds?\n\u2022 It would be interesting to study other distance measures of quantum states, e.g., the relative von Neumann entropy [NC10] (the quantum generalization of the Kullback\u2013Leibler divergence [KL51])\nS(\u03c1\u2016\u03c3) = tr (\u03c1 (ln(\u03c1)\u2212 ln(\u03c3))) .\n\u2022 Can we apply the idea of manipulating quantum states to problems other than computing quantum entropies and distances?"
        },
        {
            "heading": "1.5 Organization of This Paper",
            "text": "Section 2 introduces the idea that regards quantum states as block-encodings, and provides a series of basic techniques for manipulating them. Section 3 presents quantum algorithms that compute quantum entropies, including the von Neumann entropy, quantum Re\u0301nyi entropy and quantum Tsallis entropy. Section 4 presents quantum algorithms that compute the trace distance, fidelity and their extensions."
        },
        {
            "heading": "2 Quantum States as Block-Encodings",
            "text": "Since the introduction of qubitization in Hamiltonian simulation [LC19], block-encodings have been widely used as a basic notion in quantum algorithms, e.g., [CGJ19,GSLW19]. In the existing research, block-encodings are unitary operators that block-encode smaller ones.\nQuantum states (i.e., density operators) are often used to contain necessary information in quantum algorithms. For this purpose, [LC19] provided a technique to implement a unitary operator that block-encodes a mixed quantum state. However, to the best of our knowledge, there is no known method to do the inverse, that is, to prepare a mixed quantum state whose density operator is block-encoded in a unitary operator. As a result, it could be difficult to extract information from operators that are block-encoded in unitary operators. This motivate us to regard quantum states as block-encodings. As will be seen later in this section, it is convenient to extract information from the operators block-encoded in quantum states as well as to manipulate them.\nIn this section, we will extend the definition of block-encoding proposed for unitary operators as in [LC19,GSLW19,CGJ19] to that for general operators, especially for density operators (i.e., quantum states). Then we show the possibility that information can be stored in and extracted from quantum states as block-encodings. Also, we can manipulate the information block-encoded in quantum states. Here, the \u201cinformation\u201d block-encoded in quantum states (i.e., density operators) is essentially subnormalized density operators."
        },
        {
            "heading": "2.1 Subnormalized density operators",
            "text": "We will use the language of the conventional block-encoding. Here, we give the definition of blockencoding for ordinary quantum operators as follows.\nDefinition 2.1 (Block-encoding). Suppose A is an n-qubit operator, \u03b1, \u03b5 \u2265 0 and a \u2208 N. An (n+ a)-qubit operator B is said to be an (\u03b1, a, \u03b5)-block-encoding of A, if\n\u2016\u03b1 a\u30080|B |0\u3009a \u2212A\u2016 \u2264 \u03b5.\nIntuitively, A is represented by the matrix in the upper left corner of B, i.e.\nB \u2248 [ A/\u03b1 \u2217 \u2217 \u2217 ] .\nHere, we write |0\u3009a to denote |0\u3009 \u2297a, where the subscript a indicates which (and how many) qubits are involved in the Dirac symbol. For example, if a system consists of two subsystems of a qubits and b qubits and it is in state |0\u3009\u2297(a+b), we can represent it as |0\u3009a+b or |0\u3009a |0\u3009b.\nWe are interested in matrices block-encoded in a mixed quantum state (density operator), which are indeed subnormalized density operators.\nDefinition 2.2 (Subnormalized density operator). A subnormalized density operator A is a semidefinite operator with tr(A) \u2264 1. A (normalized) density operator is a subnormalized density operator with trace 1. An (n+a+b)-qubit unitary operator U is said to prepare an n-qubit subnormalized density operator A, if it prepares the purification |\u03c1\u3009 = U |0\u3009n+a+b of a density operator \u03c1 = trb(|\u03c1\u3009 \u3008\u03c1|), which is a (1, a, 0)-block-encoding of A.\nGiven a subnormalized density operator A prepared by a unitary operator U , we usually need to construct another unitary operator U\u0303 which is a block-encoding of A. This technique was first introduced by [LC19], then generalized for subnormalized density operators by [vAG19,GSLW19].\nLemma 2.1 (Block-encoding of subnormalized density operators [LC19, vAG19,GSLW19]). Suppose U is an (n+a)-qubit unitary operator that prepares an n-qubit subnormalized density operator A. Then there is a (2n + a)-qubit unitary operator U\u0303 which is a (1, n + a, 0)-block-encoding of A, using 1 query to U and U \u2020 and O(a) elementary quantum gates."
        },
        {
            "heading": "2.2 Generalized evolution",
            "text": "It is well-known that after applying a unitary operator U on a mixed quantum state \u03c1, it will become another state U\u03c1U \u2020. Here, we extend the basic unitary evolution to the case of subnormalized density operators, which transforms a subnormalized density operator A to BAB\u2020, where B is block-encoded in a unitary operator.\nLemma 2.2 (Evolution of subnormalized density operators). Suppose\n1. U is an (n+a)-qubit unitary operator that prepares an n-qubit subnormalized density operator A, and\n2. V is an (n+ b)-qubit unitary operator which is a (1, b, 0)-block-encoding of B.\nThen U\u0303 = (V \u2297 Ia)(U \u2297 Ib) is an (n + a + b)-qubit unitary operator that prepares an n-qubit subnormalized density operator BAB\u2020.\nProof. Let a = a1 + a2 such that U prepares an (n + a1)-qubit density operator \u03c1, which is a (1, a1, 0)-block-encoding of A. Suppose\nA = \u2211\nj\n\u03bbj |uj\u3009 \u3008uj | .\nThen we have |\u03c1\u3009n+a1+a2 = \u2211\nj\n\u221a\n\u03bbj |uj\u3009n |0\u3009a1 |\u03c8j\u3009a2 + |\u22a5a1\u3009n+a1+a2 ,\nwhere |\u03c8j\u3009 is an orthogonal basis, and \u2225 \u2225 \u2225\na1 \u30080|\u22a5a1 \u3009n+a1+a2\n\u2225 \u2225 \u2225 = 0. Note that\nU\u0303 |0\u3009n+a+b = (V \u2297 Ia) |\u03c1\u3009n+a1+a2 |0\u3009b = \u2211\nj\n\u221a\n\u03bbj |0\u3009a1 |\u03c8j\u3009a2 ( V |uj\u3009n |0\u3009b ) + V |\u22a5a1\u3009n+a1+a2 |0\u3009b =: |\u03c1\u0303\u3009 .\nLet \u03c1\u0303 = tra2 (|\u03c1\u0303\u3009 \u3008\u03c1\u0303|), then a1+b\u30080|\u03c1\u0303 |0\u3009a1+b = tra2 ( a1+b \u30080|\u03c1\u0303\u3009 \u3008\u03c1\u0303|0\u3009a1+b ) , where\na1+b \u30080|\u03c1\u0303\u3009 =\n\u2211\nj\n\u221a \u03bbj |\u03c8j\u3009a2 \u2297 (b\u30080|V |0\u3009b) |uj\u3009n = \u2211\nj\n\u221a\n\u03bbj |\u03c8j\u3009a2 \u2297B |uj\u3009n .\nWe have that\na1+b \u30080|\u03c1\u0303 |0\u3009a1+b =\n\u2211\nj\n\u03bbjB |uj\u3009n \u3008uj |B \u2020 = BAB\u2020."
        },
        {
            "heading": "2.3 Polynomial eigenvalue transformation",
            "text": "Now we show how a subnormalized density operator A can be transformed to a new subnormalized density operator A(P (A))2, where P (x) is a polynomial. To this end, we recall the polynomial eigenvalue transformation of unitary operators in [GSLW19], and extend it to the case of preparing subnormalized density operators.\nTheorem 2.3 (Polynomial eigenvalue transformation of unitary operators [GSLW19]). Suppose\n1. U is an (n + a)-qubit unitary operator, which is a (1, a, 0)-block-encoding of an Hermitian operator A.\n2. P \u2208 R[x] 7 is a degree-d polynomial such that \u2016P\u2016[\u22121,1] \u2264 12 8. Moreover, if P is even or odd, the condition can be relaxed to \u2016P\u2016[\u22121,1] \u2264 1.\nThen for every \u03b4 > 0, there is a quantum circuit U\u0303 9 such that\n1. U\u0303 is a (1, a + 2, \u03b4)-block-encoding of P (A).\n7Let R\u0303 \u2286 R be the set of polynomial-time computable real numbers. That is, for every real number x \u2208 R\u0303, there is a polynomial-time (classical) Turing machine M such that |M(1n)\u2212 x| < 2\u2212n, where M(1n) denotes the output floating point real number of M on input 1n. Throughout this paper, we only consider polynomial-time computable real numbers, and for any S \u2286 R, we write S to denote S \u2229 R\u0303 for convenience. Especially, we just write R for R\u0303.\n8For a function f : R \u2192 C and a set I \u2286 R, we define \u2016f\u2016I = sup {f(x)|x \u2208 I} . 9Throughout this paper, without explicitly explanation, quantum circuits are uniform. Here, a uniform quantum circuit is a family of quantum circuits whose descriptions can be computed by a polynomial-time (classical) Turing machine.\n2. U\u0303 uses d queries to U and U \u2020, 1 query to controlled-U and O((a+ 1)d) elementary quantum gates.\n3. A description of U\u0303 can be computed by a (classical) Turing machine in O(poly(d, log(1/\u03b4))) time.\nIn the following, combining Theorem 2.3 and Lemma 2.2, we develop a technique of polynomial eigenvalue transformation of subnormalized density operators.\nTheorem 2.4 (Polynomial eigenvalue transformation of subnormalized density operators). Suppose\n1. U is an (n+a)-qubit unitary operator that prepares an n-qubit subnormalized density operator A.\n2. P \u2208 R[x] is a degree-d polynomial such that \u2016P\u2016[\u22121,1] \u2264 12 . Moreover, if P is even or odd, the condition can be relaxed to \u2016P\u2016[\u22121,1] \u2264 1.\nThen for every \u03b4 \u2208 (0, 1), there is a quantum circuit U\u0303 such that\n1. U\u0303 prepares an n-qubit subnormalized density operator B, and B is a (1, 0, \u03b4)-block-encoding of A(P (A))2.\n2. U\u0303 uses O(d) queries to U and U \u2020, 1 query to controlled-U and controlled-U \u2020, and O((n+a)d) elementary quantum gates.\n3. A description of U\u0303 can be computed by a (classical) Turing machine in O(poly(d, log(1/\u03b4))) time.\nProof. By Lemma 2.1, there is a quantum circuit V that is a (1, O(n+ a), 0)-block-encoding of A, which consists of 1 query to U and U \u2020 and O(n+ a) elementary quantum gates. Then by Theorem 2.3, there is a quantum circuit V\u0303 , which is a (1, b, \u03b4)-block-encoding of P (A), with d queries to V and V \u2020, 1 query to controlled-V , and O((n+ a)d) elementary quantum gates, where b = O(n+ a).\nWe claim that U\u0303 = (V\u0303 \u2297 Ia)(U \u2297 Ib) is desired. To see this, by Lemma 2.2, U\u0303 prepares an n-qubit subnormalized density operator ( b\u30080|V\u0303 |0\u3009b ) A ( b\u30080|V\u0303 |0\u3009b )\u2020 . On the other hand,\n\u2225 \u2225 \u2225 \u2225 ( b\u30080|V\u0303 |0\u3009b ) A ( b\u30080|V\u0303 |0\u3009b )\u2020 \u2212A(P (A))2 \u2225 \u2225 \u2225 \u2225 \u2264 \u2225 \u2225 \u2225 \u2225 ( b\u30080|V\u0303 |0\u3009b \u2212 P (A) ) A ( b\u30080|V\u0303 |0\u3009b )\u2020 \u2225 \u2225 \u2225 \u2225 +\n\u2225 \u2225 \u2225 \u2225 P (A)A ( ( b\u30080|V\u0303 |0\u3009b )\u2020 \u2212 P (A) )\u2225 \u2225 \u2225 \u2225\n\u2264 \u03b4 \u2016A\u2016 (\u2016P (A)\u2016+ \u03b4) + \u2016P (A)\u2016 \u2016A\u2016 \u03b4\n\u2264 5 2 \u03b4 = \u0398(\u03b4).\nWe conclude that U\u0303 prepares the purification |\u03c1\u0303\u3009 of \u03c1\u0303, which is a (1, O(n+a),\u0398(\u03b4))-block-encoding of A(P (A))2, which yields the proof.\nBy Theorem 2.4, we are able to transform a subnormalized density operator A to A(f(A))2 for a large range of f(x), provided f(x) can be efficiently approximated by a polynomial.\nTheorem 2.5 (Eigenvalue transformation of subnormalized density operators). Suppose\n1. U is an (n+a)-qubit unitary operator that prepares an n-qubit subnormalized density operator A.\n2. f : [\u22121, 1] \u2192 R can be approximated by a degree-d polynomial P \u2208 R[x] such that there are two parameters \u03b4, \u03b5 \u2208 (0, 12 ], it holds that \u2016P (x)\u2212 f(x)\u2016[\u03b4,1] \u2264 \u03b5 and \u2016P\u2016[\u22121,1] \u2264 12 . Moreover, if P is even or odd, the latter condition can be relaxed to \u2016P\u2016[\u22121,1] \u2264 1.\nThen there is a quantum circuit U\u0303 such that\n1. U\u0303 prepares an n-qubit subnormalized density operator B, and B is a ( 1, 0,\u0398 ( \u03b5+ \u03b4 + \u2225 \u2225x(f(x))2 \u2225 \u2225\n[0,\u03b4]\n))\n-\nblock-encoding of A(f(A))2.\n2. U\u0303 uses O(d) queries to U and U \u2020, 1 query to controlled-U and controlled-U \u2020, and O((n+a)d) elementary quantum gates.\n3. A description of U\u0303 can be computed by a (classical) Turing machine in O(poly(d, log(1/\u03b4))) time.\nProof. Let U\u0303 be the quantum circuit obtained by Theorem 2.4, which prepares an n-qubit subnormalized density operator B as a (1, 0, \u03b4)-block-encoding of A(P (A))2. We analyze the error by the fact that\n\u2225 \u2225x(P (x))2 \u2212 x(f(x))2 \u2225 \u2225 [0,1] \u2264 \u0398\n(\n\u03b5+ \u03b4 + \u2225 \u2225x(f(x))2 \u2225 \u2225\n[0,\u03b4]\n)\n.\nWe consider two cases. Case 1. x \u2208 [\u03b4, 1].\n\u2223 \u2223x(P (x))2 \u2212 x(f(x))2 \u2223 \u2223 \u2264 |x| |P (x) + f(x)| |P (x)\u2212 f(x)| \u2264 (1 + \u03b5)\u03b5 \u2264 2\u03b5 = \u0398(\u03b5).\nCase 2. x \u2208 [0, \u03b4). \u2223\n\u2223x(P (x))2 \u2212 x(f(x))2 \u2223 \u2223 \u2264 \u2223 \u2223x(P (x))2 \u2223 \u2223+ \u2223 \u2223x(f(x))2 \u2223 \u2223 \u2264 \u03b4 + \u2225 \u2225x(f(x))2 \u2225 \u2225\n[0,\u03b4] .\nThen we have\n\u2225 \u2225B \u2212A(f(A))2 \u2225 \u2225 \u2264 \u2225 \u2225B \u2212A(P (A))2 \u2225 \u2225+ \u2225 \u2225A(P (A))2 \u2212A(f(A))2 \u2225 \u2225\n\u2264 \u03b4 +\u0398 ( \u03b5+ \u03b4 + \u2225 \u2225x(f(x))2 \u2225 \u2225\n[0,\u03b4]\n) = \u0398 ( \u03b5+ \u03b4 + \u2225 \u2225x(f(x))2 \u2225 \u2225\n[0,\u03b4]\n)\n.\nAs will be seen, Theorem 2.5 can be used to develop a technique of preparing positive powers of Hermitian operators (see Section 2.4)."
        },
        {
            "heading": "2.4 Positive powers",
            "text": "We will use Theorem 2.5 to develop an efficient approach for implementing positive powers of Hermitian matrix A, which removes the dependence on \u03ba that I/\u03ba \u2264 A \u2264 I as in [CGJ19] (see Lemma 10 of its full version). To this end, we recall some results of polynomial approximations of power functions.\nLemma 2.6 (Polynomial approximation of positive power functions [Gil19, CGJ19]). Let \u03b4, \u03b5 \u2208 (0, 12 ], c \u2208 (0, 1) and f(x) = 12xc. Then there is an even/odd degree-O ( 1 \u03b4 log ( 1 \u03b5 )) polynomial 10 P \u2208 R[x] such that \u2016P (x)\u2212 f(x)\u2016[\u03b4,1] \u2264 \u03b5 and \u2016P\u2016[\u22121,1] \u2264 1.\nLemma 2.7 (Polynomial approximation of negative power functions [Gil19,CGJ19,GSLW19]). Let \u03b4, \u03b5 \u2208 (0, 12 ], c > 0 and f(x) = \u03b4 c 2 x \u2212c. Then there is an even/odd degree-O ( c+1 \u03b4 log ( 1 \u03b5 ))\npolynomial P \u2208 R[x] such that \u2016P (x)\u2212 f(x)\u2016[\u03b4,1] \u2264 \u03b5 and \u2016P\u2016[\u22121,1] \u2264 1.\nFirst, we develop a method of implementing positive powers of Hermitian matrix A, which is given as block-encoded in a density operator \u03c1. Here, the purification of \u03c1 can be prepared by a unitary operator U .\nLemma 2.8 (Positive powers block-encoded in density operators). Suppose\n1. U is an (n+a)-qubit unitary operator that prepares an n-qubit subnormalized density operator A.\n2. \u03b4, \u03b5 \u2208 ( 0, 12 ] and c \u2208 (0, 1).\nThen there is a quantum circuit U\u0303 such that\n1. U\u0303 prepares an n-qubit subnormalized density operator B, and B is a (4\u03b4c\u22121, 0,\u0398(\u03b4c+\u03b5\u03b4c\u22121))block-encoding of Ac.\n2. U\u0303 uses O(d) queries to U and U \u2020, 1 query to controlled-U and controlled-U \u2020, and O((n+a)d) elementary quantum gates, where d = O (\n1 \u03b4 log\n(\n1 \u03b5\n))\n.\n3. A description of U\u0303 can be computed by a (classical) Turing machine in O(poly(d)) time.\nProof. Let f(x) = \u03b4 c 2 x \u2212c, where c \u2208 ( 0, 12 ) . Then x(f(x))2 = \u03b4 2c 4 x 1\u22122c, and \u2225 \u2225x(f(x))2 \u2225 \u2225 [0,\u03b4] \u2264 \u03b44 = \u0398(\u03b4). By Lemma 2.7, we can obtain an even/odd polynomial P (x) of degree O (\n1 \u03b4 log\n(\n1 \u03b5\n))\nsuch\nthat \u2016P \u2212 f\u2016[\u03b4,1] \u2264 \u03b5 and \u2016P\u2016[\u22121,1] \u2264 1. By Theorem 2.5, there is a quantum circuit U\u0303 , which prepares an n-qubit subnormalized density operator B, which is a (1, 0,\u0398(\u03b4 + \u03b5))-block-encoding of A (f(A))2 = \u03b4 2c\n4 A 1\u22122c. In other words, B is a (4\u03b4\u22122c, 0,\u0398(\u03b41\u22122c + \u03b5\u03b4\u22122c))-block-encoding of\nA1\u22122c. These yield the proof by letting c\u2032 = 1\u2212 2c.\nNext, inspired by the above observation, we extend the result to the case that A is given as block-encoded in a unitary operator. Here, we need to implement a threshold projector. The following lemma is Corollary 16 of [GSLW19].\nLemma 2.9 (Polynomial approximation of threshold projectors [GSLW19]). Let \u03b4, \u03b5 \u2208 (0, 12) and t \u2208 [0, 1] such that 0 < t \u2212 \u03b4 < t + \u03b4 < 1. There is an even polynomial P \u2208 R[x] of degree O (\n1 \u03b4 log\n(\n1 \u03b5\n))\nsuch that\n1. \u2016P\u2016[\u22121,1] \u2264 1,\n2. P (x) \u2208 [1\u2212 \u03b5, 1] for x \u2208 [\u2212t+ \u03b4, t\u2212 \u03b4], and 10In this paper, a degree-d polynomial means a uniform family of (polynomial-time computable) polynomials with\nparameter d. That is, suppose Pd(x) = \u2211d k=0 akx k, where ak is a polynomial-time computable real number for 0 \u2264 k \u2264 d, then there is a polynomial-time classical Turing machine that, on input 1d, outputs descriptions Mk of ak for 0 \u2264 k \u2264 d, where Mk is a polynomial-time classical Turing machine that, on input 1\nn, output ak within additive error 2\u2212n.\n3. P (x) \u2208 [0, \u03b5] for x \u2208 [\u22121,\u2212t\u2212 \u03b4] \u222a [t+ \u03b4, 1].\nWe take some special cases of Lemma 2.9 as follows, which will be often used to design our quantum algorithms.\nCorollary 2.10. Let \u03b4, \u03b5 \u2208 (0, 14 ]. Then there is an even degree-O ( 1 \u03b4 log ( 1 \u03b5 )) polynomial R \u2208 R[x] such that \u2016R\u2016[\u22121,1] \u2264 1 and\nR(x) \u2208 { [1\u2212 \u03b5, 1] x \u2208 [\u22121,\u22122\u03b4] \u222a [2\u03b4, 1] [0, \u03b5] x \u2208 [\u2212\u03b4, \u03b4] .\nCorollary 2.11. Let \u03b4, \u03b5 \u2208 (0, 14 ]. Then there is an even degree-O ( 1 \u03b4 log ( 1 \u03b5 )) polynomial R \u2208 R[x] such that \u2016R\u2016[\u22121,1] \u2264 1 and\nR(x) \u2208 { [1\u2212 \u03b5, 1] x \u2208 [\u22121 + 2\u03b4, 1 \u2212 2\u03b4] [0, \u03b5] x \u2208 [\u22121,\u22121 + \u03b4] \u222a [1\u2212 \u03b4, 1] .\nWe also need the following lemma to multiply block-encoded matrices.\nLemma 2.12 (Product of block-encoded matrices [GSLW19]). Suppose\n1. U is an (n+ a)-qubit unitary operator that is a (\u03b1, a, \u03b4)-block-encoding of an n-qubit operator A.\n2. V is an (n+ b)-qubit unitary operator that is a (\u03b2, b, \u03b5)-block-encoding of an n-qubit operator B.\nThen there is a quantum circuit U\u0303 such that\n1. U\u0303 is an (\u03b1\u03b2, a + b, \u03b1\u03b5 + \u03b2\u03b4)-block-encoding of AB.\n2. U\u0303 uses 1 query to each of U and V .\nWith the approximation of threshold functions, we are able to implement positive powers of Hermitian matrix A, which is given as block-encoded in a unitary operator.\nLemma 2.13 (Positive powers block-encoded in unitary operators). Suppose\n1. U is an (n + a)-qubit unitary operator which is a (1, a, 0)-block-encoding of an n-qubit Hermitian operator A.\n2. \u03b4, \u03b5 \u2208 ( 0, 14 ] and c \u2208 (0, 1).\nThen there is a quantum circuit W such that\n1. W is a (2, O(a + 1),\u0398(\u03b5 + \u03b4c))-block-encoding of |A|c.\n2. W uses O(Q) queries to U and U \u2020, O(1) query to controlled-U and O((a+ 1)Q) elementary quantum gates, where Q = O (\n1 \u03b4 log\n(\n1 \u03b5\n))\n.\n3. A description of W can be computed by a (classical) Turing machine in poly(Q) time.\nProof. Let f(x) = 12 |x| c be an even function and \u03b4, \u03b5 \u2208 (0, 14 ]. By Lemma 2.6, there is an even degree-dP polynomial P \u2208 R[x], where dP = O ( 1 \u03b4 log ( 1 \u03b5 ))\n, such that \u2016P (x)\u2212 f(x)\u2016[\u03b4,1] \u2264 \u03b5, \u2016P (x)\u2212 f(x)\u2016[\u22121,\u2212\u03b4] \u2264 \u03b5 and \u2016P\u2016[\u22121,1] \u2264 1. By Theorem 2.3, for \u03b4U > 0, there is a quantum circuit U\u0303 such that\n1. U\u0303 is a (1, a+ 2, 0)-block-encoding of B, and B is a (1, 0, \u03b4U )-block-encoding of P (A).\n2. U\u0303 uses dP queries to U and U \u2020, 1 query to controlled-U and O((a+1)dP ) elementary quantum\ngates.\n3. A description of U\u0303 can be computed by a (classical) Turing machine in poly(dP , log(1/\u03b4U )) time.\nLet R \u2208 R[x] be the even degree-dR polynomial in Corollary 2.10, where dR = O ( 1 \u03b4 log ( 1 \u03b5 ))\n, such that \u2016R\u2016[\u22121,1] \u2264 1 and\nR(x) \u2208 { [1\u2212 \u03b5, 1] x \u2208 [\u22121,\u22122\u03b4] \u222a [2\u03b4, 1] [0, \u03b5] x \u2208 [\u2212\u03b4, \u03b4] .\nBy Theorem 2.3, for \u03b4V > 0, there is a quantum circuit V\u0303 such that\n1. V\u0303 is a (1, a+ 2, 0)-block-encoding of C, and C is a (1, 0, \u03b4V )-block-encoding of R(A).\n2. V\u0303 uses dR queries to U and U \u2020, 1 query to controlled-U and O((a+1)dR) elementary quantum\ngates.\n3. A description of V\u0303 can be computed by a (classical) Turing machine in poly(dR, log(1/\u03b4V )) time.\nBy Lemma 2.12, using one query to each of U\u0303 and V\u0303 , we can obtain a quantum circuitW , which is a (1, 2a+4, 0)-block-encoding ofBC. In the following, we will show that \u2016BC \u2212 f(A)\u2016 \u2264 \u0398(\u03b5+\u03b4c). We note that \u2016P (x)R(x)\u2212 f(x)\u2016[0,1] \u2264 \u0398(\u03b5+ \u03b4c). This is seen by the following three cases:\n1. |x| > 2\u03b4. We have |P (x)R(x) \u2212 f(x)| \u2264 |(P (x)\u2212 f(x))R(x)|+ |f(x)(R(x)\u2212 1)| \u2264 \u0398(\u03b5).\n2. |x| < \u03b4. We have |P (x)R(x)\u2212 f(x)| \u2264 |P (x)| |R(x)|+ |f(x)| \u2264 \u0398(\u03b5+ \u03b4c).\n3. \u03b4 \u2264 |x| \u2264 2\u03b4. We have |P (x)R(x)\u2212 f(x)| \u2264 |(P (x) \u2212 f(x))R(x)| + |f(x)| |R(x)\u2212 1| \u2264 \u0398(\u03b5+ \u03b4c).\nNote that A is Hermitian, we have \u2016P (A)R(A)\u2212 f(A)\u2016 \u2264 \u0398(\u03b5+ \u03b4c). Finally,\n\u2016BC \u2212 f(A)\u2016 \u2264 \u2016BC \u2212 P (A)R(A)\u2016 + \u2016P (A)R(A) \u2212 f(A)\u2016 \u2264 \u0398(\u03b4U + \u03b4V + \u03b5+ \u03b4c).\nThese conclude that W is a (1, 2a + 4,\u0398(\u03b5 + \u03b4c))-block-encoding of f(A) by setting \u03b4U = \u03b4V = \u03b5, and therefore a (2, O(n + a),\u0398(\u03b5 + \u03b4c))-block-encoding of |A|c.\nBy setting \u03ba = 1\u03b4 , Lemma 2.13 reproduces the result of [CGJ19] (see Lemma 10 of its full version). The strength of Lemma 2.13 is to allow implement positive powers of A, regardless of whether the condition I/\u03ba \u2264 A \u2264 I holds."
        },
        {
            "heading": "2.5 Trace estimation",
            "text": "In this subsection, we will provide a method of estimating the trace of an Hermitian matrix which is block-encoded in a density operator. Before that, we recall the quantum amplitude estimation [BHMT02].\nTheorem 2.14 (Quantum amplitude estimation, [BHMT02]). Suppose U is an (a+b)-qubit unitary operator such that\nU |0\u3009a+b = \u221a p |0\u3009a |\u03c60\u3009b + \u221a\n1\u2212 p |1\u3009a |\u03c61\u3009b , where |\u03c60\u3009 and |\u03c61\u3009 are normalized (pure) quantum states and p \u2208 [0, 1]. There is a quantum algorithm that outputs p\u0303 \u2208 [0, 1] such that\n|p\u0303\u2212 p| \u2264 2\u03c0 \u221a p(1\u2212 p) M + \u03c02 M2\nwith probability \u2265 8 \u03c02 , using O(M) queries to U and U \u2020.\nIf we know an upper bound B of p, then we can take M = \u2308 2\u03c0 (\n2 \u221a B\n\u03b5 + 1\u221a \u03b5\n)\u2309 = \u0398 (\u221a\nB \u03b5 + 1\u221a \u03b5\n)\nto guarantee that |p\u0303\u2212 p| \u2264 \u03b5. Based on quantum amplitude estimation, we develop the trace estimation of subnormalized density operators as shown below, which will be useful to design quantum algorithms, see Section 3 and Section 4.\nLemma 2.15 (Trace estimation of subnormalized density operators). Suppose U is an (n+a)-qubit unitary operator that prepares an n-qubit subnormalized density operator A, and B > 0 is a known constant that tr(A) \u2264 B. For every \u03b5 > 0, there is a quantum algorithm that estimates tr(A) within additive error \u03b5 with O (\u221a B \u03b5 + 1\u221a \u03b5 ) queries to U and U \u2020.\nProof. Let a = a1 + a2 such that U prepares an (n + a1)-qubit density operator \u03c1, which is a (1, a1, 0)-block-encoding of A. Suppose\nA = \u2211\nj\n\u03bbj |uj\u3009 \u3008uj | .\nThen we have\nU |0\u3009n+a1+a2 = |\u03c1\u3009n+a1+a2 = \u2211\nj\n\u221a\n\u03bbj |uj\u3009n |0\u3009a1 |\u03c8j\u3009a2 + |\u22a5a1\u3009n+a1+a2\nwhere |\u03c8j\u3009 is an orthogonal basis, and \u2225 \u2225 \u2225\na1 \u30080|\u22a5a1 \u3009n+a1+a2\n\u2225 \u2225 \u2225 = 0. Moreover, we have\nU |0\u3009n+a1+a2 = \u221a p |0\u3009a1 |\u03c60\u3009n+a2 + \u221a\n1\u2212 p |1\u3009a1 |\u03c61\u3009n+a2 for some (pure) quantum states |\u03c60\u3009 and |\u03c61\u3009, where p = tr(A).\nIf we know an upper bound B of tr(A), then let M = \u2308 2\u03c0 (\n2 \u221a B\n\u03b5 + 1\u221a \u03b5\n)\u2309 = \u0398 (\u221a\nB \u03b5 + 1\u221a \u03b5\n)\n, and\nby Theorem 2.14, we can computes p\u0303 such that\n|p\u0303\u2212 p| \u2264 2\u03c0 \u221a p(1\u2212 p) M + \u03c02 M2 \u2264 \u03b5\nwith success probability \u2265 8 \u03c02 , using M queries to U and U \u2020."
        },
        {
            "heading": "2.6 Linear combinations",
            "text": "We will provide a technique (Lemma 2.17) that prepares a linear combination of subnormalized density operators, which is a natural analog of Linear-Combination-of-Unitaries (LCU) algorithm through a series of work [SOG+02,CW12,Kot14,BCC+15,BCK15,CKS17,GSLW19].\nBefore stating our linear combination result of subnormalized density operators, we introduce a technique that embeds a density operator in a larger space.\nLemma 2.16. Suppose U is an (n + a)-qubit unitary operator that prepares an n-qubit density operator \u03c1. For every b \u2265 0, there is an (n+ a+ b)-qubit unitary operator U (b) = U \u2297 Ib such that\n1. U (b) prepares an (n+ b)-qubit density operator \u03c1(b), and \u03c1(b) is a (1, b, 0)-block-encoding of \u03c1.\n2. U (b) uses 1 query to U .\nProof. Let |\u03c8\u3009n+a = U |0\u3009n+a and then \u03c1n = tra(|\u03c8\u3009n+a \u3008\u03c8|). Let U (b) = U \u2297 Ib and \u2223 \u2223\u03c8(b) \u232a n+a+b = U (b) |0\u3009n+a+b = |\u03c8\u3009n+a |0\u3009b. We have\n\u03c1(b) = tra\n(\n\u2223 \u2223 \u2223 \u03c8(b) \u232a\nn+a+b\n\u2329 \u03c8(b) \u2223 \u2223\n\u2223\n)\n= tra ( |\u03c8\u3009n+a \u3008\u03c8| \u2297 |0\u3009b \u30080| ) = \u03c1n \u2297 |0\u3009b \u30080| .\nThe proof is completed by noting that b\u30080|\u03c1(b) |0\u3009b = \u03c1n.\nNow we are ready to show the technique to prepare a linear combination of subnormalized density operators. The basic idea is to prepare a linear combination of (normalized) density operators, but a careful qubit alignment is needed with the help of Lemma 2.16.\nLemma 2.17 (Linear combination of subnormalized density operators). Suppose\n1. V is an m-qubit unitary operator such that V |0\u3009 =\u2211k\u2208[2m] \u221a \u03b1k |k\u3009 11.\n2. For every k \u2208 [2m], Uk is an (n+ak+bk)-qubit unitary operator that prepares an (n+ak)-qubit density operator \u03c1k, and \u03c1k is a (1, ak, 0)-block-encoding of an n-qubit subnormalized density operator Ak.\nLet a = maxk\u2208[2m]{ak} and b = maxk\u2208[2m]{bk}. Then there is an (m + n + a + b)-qubit unitary operator U such that\n1. U (V \u2297 In+a+b) prepares an n-qubit subnormalized density operator\nA = \u2211\nk\u2208[2m] \u03b1kAk.\n2. U uses 1 query to each Uk for k \u2208 [2m].\nProof. Let a\u2032k = a\u2212 ak, b\u2032k = b\u2212 bk, and\nU = \u2211 k\u2208[2m] |k\u3009 \u3008k| \u2297 U(a \u2032 k+b \u2032 k) k\nbe an (m + n + a + b)-qubit unitary operator, where U (b) = U \u2297 Ib is defined as in Lemma 2.16. Here, U (a\u2032k+b \u2032 k)\nk acts on n + a + b qubits. To be precise, if we split the n + a + b qubits into three\n11Here, we use the notation [n] = {0, 1, 2, . . . , n\u2212 1}.\nparts: (i) n qubits, (ii) a qubits and (iii) b qubits, then U (a\u2032k+b \u2032 k)\nk uses 1 query to Uk which acts on: (i) the whole n qubits, (ii) the first ak qubits and (iii) the first bk qubits.\nLet |\u03c8k\u3009n+ak+bk = Uk |0\u3009n+ak+bk . Then we note that\n|\u03c8\u3009 = U (V \u2297 In+a+b) |0\u3009m |0\u3009n |0\u3009a |0\u3009b = U \u2211\nk\u2208[2m]\n\u221a \u03b1k |k\u3009m |0\u3009n |0\u3009a |0\u3009b\n= \u2211\nk\u2208[2m]\n\u221a \u03b1k |k\u3009m\n(\nU (a\u2032k+b \u2032 k) k |0\u3009n |0\u3009a |0\u3009b )\n= \u2211\nk\u2208[2m]\n\u221a \u03b1k |k\u3009m |\u03c8k\u3009n+ak+bk |0\u3009a\u2032k |0\u3009b\u2032k ,\nand\n\u03c1 = trm+b (|\u03c8\u3009 \u3008\u03c8|) = \u2211\nk\u2208[2m] \u03b1k trb\n( |\u03c8k\u3009n+ak+bk \u3008\u03c8k| \u2297 |0\u3009a\u2032k+b\u2032k \u30080| )\n= \u2211\nk\u2208[2m] \u03b1k trbk\n( |\u03c8k\u3009n+ak+bk \u3008\u03c8k| ) \u2297 |0\u3009a\u2032k \u30080|\n= \u2211\nk\u2208[2m] \u03b1k(\u03c1k)n+ak \u2297 |0\u3009a\u2032k \u30080|\n= \u2211\nk\u2208[2m] \u03b1k\n(\n\u03c1 (a\u2032k)\nk\n)\nn+a ,\nwhere \u03c1(b) = \u03c1\u2297 |0\u3009b \u30080| is defined as in Lemma 2.16. To see that \u03c1 is a (1, a, 0)-block-encoding of A = \u2211\nk\u2208[2m]Ak, we note that\na\u30080|\u03c1 |0\u3009a = \u2211 k\u2208[2m] \u03b1k ak\u30080|(\u03c1k)n+ak |0\u3009ak = \u2211 k\u2208[2m] \u03b1kAk = A.\nTherefore, U (V \u2297 Ia \u2297 Ib) prepares a subnormalized density operator A.\nAs will be also used to design quantum algorithms in this paper, we provide the LCU algorithm for comparison. Here, we use the notion as in the full version of [GSLW19].\nDefinition 2.3 (State preparation pair). Let y \u2208 Cm with \u2016y\u20161 \u2264 \u03b2, and \u03b5 \u2265 0. A pair of unitary operator (PL, PR) is called a (\u03b2, b, \u03b5)-state-preparation-pair if PL |0\u3009b = \u2211\nj\u2208[2b] cj |j\u3009 and PR |0\u3009b = \u2211 j\u2208[2b] dj |j\u3009 such that \u2211 j\u2208[m] \u2223 \u2223 \u2223 \u03b2c\u2217jdj \u2212 yj \u2223 \u2223 \u2223 \u2264 \u03b5 and c\u2217jdj = 0 for all m \u2264 j < 2b.\nTheorem 2.18 (Linear combination of unitary operators [GSLW19]). Suppose\n1. y \u2208 Cm with \u2016y\u20161 \u2264 \u03b2, and (PL, PR) is a (\u03b2, b, \u03b51)-state-preparation-pair for y.\n2. For every k \u2208 [m], Uk is an (n + a)-qubit unitary operator that is an (\u03b1, a, \u03b5)-block-encoding of an n-qubit operator Ak.\nThen there is an (n+ a+ b)-qubit quantum circuit U\u0303 such that\n1. W is a (\u03b1\u03b2, a + b, \u03b1\u03b51 + \u03b1\u03b2\u03b52)-block-encoding of A = \u2211 k\u2208[m] ykAk.\n2. W uses 1 query to each of P \u2020L, PR and (controlled-)Uk for k \u2208 [m], and O(b2) elementary quantum gates."
        },
        {
            "heading": "2.7 Eigenvalue threshold projector",
            "text": "In this subsection, we show how to block-encode an eigenvalue threshold projector \u03a0supp(A) of a subnormalized density operator A in another. We note that [vAG19] also provided a technique for block-encoding eigenvalue threshold projectors in subnormalized density operators. The major difference is that our approach does not have any further requirements on the subnormalized density operator A, while [vAG19] requires that A \u2265 q\u03a0 for some projector \u03a0 and the value of q > 0 is known in advance.\nFirst, we introduce the notion of truncated support. Let \u03b4 > 0 and A be an Hermitian operator with spectral decomposition A = \u2211\nj \u03bbj |\u03c8j\u3009 \u3008\u03c8j |. The \u03b4-support of A is\nsupp\u03b4(A) = span{|\u03c8j\u3009 : |\u03bbj | > \u03b4}.\nNote that supp\u03b4(A) \u2286 supp0(A) = supp(A). Here, we write \u03a0S to denote the projector onto a subspace S.\nLemma 2.19 (Eigenvalue threshold projector). Suppose\n1. U is an (n+a)-qubit unitary operator that prepares an n-qubit subnormalized density operator A.\n2. \u03b4, \u01eb \u2208 (0, 110 ] and 32\u03b52 \u2264 \u03b4.\nFor every \u03b4\u2032 > 0, there is a quantum circuit U\u0303 such that\n1. U\u0303 prepares an n-qubit subnormalized density operator, which is a (1, 0, \u03b4\u2032)-block-encoding of B such that\n(\n\u03b4 4 (1\u2212 2\u03b5)\u2212 \u03b41/2\u03b5\n) \u03a0supp2\u03b4(A) \u2264 B \u2264 ( \u03b4\n4 + \u03b52 + \u03b41/2\u03b5\n)\n\u03a0supp(A).\n2. U\u0303 uses O(d) queries to U and U \u2020, 1 query to controlled-U and O((n+a)d) elementary quantum gates, where d = O (\n1 \u03b4 log\n(\n1 \u03b5\n))\n.\n3. A description of U\u0303 can be computed by a (classical) Turing machine in poly(d, log(1/\u03b4\u2032)) time.\nProof. Let f(x) = \u03b4 1/2 2 x \u22121/2, and by Lemma 2.7, there is a degree-O ( 1 \u03b4 log ( 1 \u03b5 ))\neven polynomial P \u2208 R[x] such that \u2016P \u2212 f\u2016[\u03b4,1] \u2264 \u03b5 and \u2016P\u2016[\u22121,1] \u2264 1. By Corollary 2.10, there is a degreeO (\n1 \u03b4 log\n(\n1 \u03b5\n))\neven polynomial R \u2208 R[x] such that \u2016R\u2016[\u22121,1] \u2264 1 and\nR(x) \u2208 { [1\u2212 \u03b5, 1] x \u2208 [\u22121,\u22122\u03b4] \u222a [2\u03b4, 1] [0, \u03b5] x \u2208 [\u2212\u03b4, \u03b4] .\nNote that Q = PR \u2208 R[x] is a degree-d even polynomial, where d = O ( 1 \u03b4 log ( 1 \u03b5 ))\n. By Theorem 2.3, for \u03b4Q > 0, there is a quantum circuit UQ such that\n1. UQ is a (1, O(n + a), 0)-block-encoding of A1, and A1 is a (1, 0, \u03b4Q)-block-encoding of Q(A).\n2. UQ uses d queries to U and U \u2020, 1 query to controlled-U and O((n+a)d) elementary quantum\ngates.\n3. A description of UQ can be computed by a (classical) Turing machine in poly(d, log(1/\u03b4Q)) time.\nBy Lemma 2.2, using 1 query to each of UQ and U , we obtain a unitary operator U\u0303 that prepares A1AA \u2020 1. We note that\n\u2225 \u2225 \u2225 A1AA \u2020 1 \u2212A(Q(A))2 \u2225 \u2225 \u2225 \u2264 \u2225 \u2225 \u2225 A1AA \u2020 1 \u2212Q(A)AA \u2020 1 \u2225 \u2225 \u2225 + \u2225 \u2225 \u2225 Q(A)AA\u20201 \u2212Q(A)AQ(A) \u2225 \u2225 \u2225 \u2264 2\u03b4Q.\nMoreover, A1AA \u2020 1 can be regarded as a (scaled) projector. To see this, let 1S be the indicator function that\n1S(x) =\n{\n1 x \u2208 S 0 otherwise .\nThen \u03a0supp\u03b4(A) = 1[\u03b4,1](A). We note that if 32\u03b5 2 \u2264 \u03b4, then\n(\n\u03b4 4 (1\u2212 2\u03b5)\u2212 \u03b41/2\u03b5\n)\n\u03a0supp2\u03b4(A) \u2264 A(Q(A)) 2 \u2264\n(\n\u03b4 4 + \u03b52 + \u03b41/2\u03b5\n)\n\u03a0supp(A). (3)\nWe need to show that (\n\u03b4 4 (1\u2212 2\u03b5) \u2212 \u03b41/2\u03b5\n) 1[2\u03b4,1](x) \u2264 x(Q(x))2 \u2264 ( \u03b4\n4 + \u03b52 + \u03b41/2\u03b5\n)\n1(0,1](x)\nfor every x \u2208 [0, 1]. This is seen by the following four cases.\n1. x = 0. This case is trivial as each hand side is equal to 0.\n2. x \u2208 (0, \u03b4]. We have 0 \u2264 x(Q(x))2 \u2264 x(R(x))2 \u2264 x\u03b52 \u2264 \u03b4\u03b52.\n3. x \u2208 (\u03b4, 2\u03b4]. We have\n0 \u2264 x(Q(x))2 \u2264 x(P (x))2 \u2264 x(f(x) + \u03b5)2 = x(f(x))2 + x\u03b52 + 2xf(x)\u03b5 \u2264 \u03b4 4 + \u03b52 + \u03b41/2\u03b5.\n4. x \u2208 (2\u03b4, 1]. The right hand side is x(Q(x))2 \u2264 \u03b44 + \u03b52 + \u03b41/2\u03b5 is similar to Case 3. The left hand side is as follows.\nx(Q(x))2 \u2265 x(P (x))2(1\u2212 \u03b5)2\n\u2265 x(f(x)\u2212 \u03b5)2(1\u2212 \u03b5)2\n\u2265 x((f(x))2 \u2212 2f(x)\u03b5)(1 \u2212 2\u03b5)\n=\n(\n\u03b4 4 \u2212 \u03b41/2x1/2\u03b5\n)\n(1\u2212 2\u03b5)\n\u2265 \u03b4 4 (1\u2212 2\u03b5) \u2212 \u03b41/2\u03b5.\nTherefore, we conclude that Eq. (3) holds. We claim the lemma by setting B = A(Q(A))2 and \u03b4\u2032 = 2\u03b4Q."
        },
        {
            "heading": "3 Quantum Entropies",
            "text": "In the Introduction, we have already introduced several quantum entropies such as the von Neumann entropy, quantum Re\u0301nyi entropy and quantum Tsallis entropy. In addition to this, the quantum\nMin entropy Smin(\u03c1) and the quantum Max (Hartley) entropy Smax(\u03c1) are defined as limits of Re\u0301nyi entropies by\nSmin(\u03c1) = SR\u221e(\u03c1) = lim\u03b1\u2192\u221e SR\u03b1 (\u03c1) = \u2212 ln (\u2016\u03c1\u2016) , Smax(\u03c1) = SR0 (\u03c1) = lim \u03b1\u21920 SR\u03b1 (\u03c1) = ln (rank(\u03c1)) .\nThe unified entropy [HY06] is defined by\nSs\u03b1(\u03c1) = 1\n(1\u2212 \u03b1)s ((tr (\u03c1 \u03b1))s \u2212 1)\nfor \u03b1 \u2208 (0, 1)\u222a (1,+\u221e) and s 6= 0, which includes the von Neumann entropy S(\u03c1) = lim\u03b1\u21921 Ss\u03b1(\u03c1), the Re\u0301nyi entropy SR\u03b1 (\u03c1) = lims\u21920 S s \u03b1(\u03c1) and the Tsallis entropy S T \u03b1 (\u03c1) = S 1 \u03b1(\u03c1).\nIn this section, we will propose a series of quantum algorithms for computing several quantum entropies. Section 3.1 provides a quantum algorithm for computing the von Neumann entropy. Section 3.2 is for the Max entropy. Section 3.3 is for the quantum Re\u0301nyi and Tsallis entropies."
        },
        {
            "heading": "3.1 Von Neumann Entropy",
            "text": "The von Neumann entropy is one of the most important quantum information quantities. As mentioned above, both quantum algorithms for estimating von Neumann entropy provided by [AISW19] and [GL20] have time complexity exponential in the number n = log2(N) of qubits of the quantum state. Here, we provide a different approach that exponentially improves the dependence on n given that the density operator of the mixed quantum state is low-rank. Our key technique used here is different from that of [GL20], where they approximated a function \u221d \u2212 ln(x) and constructed a unitary operator that is a block-encoding of S(\u03c1), while we approximate a function \u221d \u221a \u2212 ln(x) and prepare a density operator that is a block-encoding of S(\u03c1).\nTheorem 3.1. Suppose\n1. U\u03c1 is an (n + n\u03c1)-qubit unitary operator that prepares an n-qubit density operator \u03c1 with rank(\u03c1) \u2264 r.\n2. n\u03c1 is a polynomial in n 12.\nThere is a quantum algorithm that computes the von Neumann entropy S(\u03c1) within additive error \u03b5 using O\u0303( r 2\n\u03b52 ) queries to U\u03c1 and O\u0303(\nr2 \u03b52 poly(n)) elementary quantum gates.\nBefore the proof of Theorem 3.1, we need the following method of approximating functions by polynomials based on Taylor series.\nLemma 3.2 (Corollary 66 of the full version of [GSLW19]). Let x0 \u2208 [\u22121, 1], r \u2208 (0, 2], \u03b4 \u2208 (0, r] and f : [x0 \u2212 r \u2212 \u03b4, x0 + r + \u03b4] \u2192 C such that f(x0 + x) = \u2211\u221e k=0 akx\nk for all x \u2208 [\u2212r \u2212 \u03b4, r + \u03b4]. Suppose B > 0 and\n\u2211\u221e k=0 |ak| (r + \u03b4)k \u2264 B. Let \u03b5 \u2208 (0, 12B ], then there is an efficient computable\npolynomial P \u2208 C[x] of degree O ( 1 \u03b4 log ( B \u03b5 )) such that\n\u2016f(x)\u2212 P (x)\u2016[x0\u2212r,x0+r] \u2264 \u03b5, \u2016P\u2016[\u22121,1] \u2264 \u03b5+ \u2016f\u2016[x0\u2212r\u2212\u03b4/2,x0+r+\u03b4/2] \u2264 \u03b5+B,\n\u2016P\u2016[\u22121,1]\\[x0\u2212r\u2212\u03b4/2,x0+r+\u03b4/2] \u2264 \u03b5. 12Theoretically, any n-qubit mixed quantum state has a purification with at most n ancilla qubits, so it is sufficient\nto assume that n\u03c1 \u2264 n. Here, we just assume that n\u03c1 = poly(n) for convenience.\nBy Lemma 3.2, we are able to give an approximation of scaled \u221a \u2212 ln(x) as follows. Lemma 3.3. For every \u03b4\u2032, \u03b5 \u2208 (0, 14 ], there is an efficient computable polynomial P \u2208 R[x] of degree O (\n1 \u03b4\u2032 log\n(\n1 \u03b4\u2032\u03b5\n))\nsuch that \u2225\n\u2225 \u2225 \u2225 \u2225\nP (x)\u2212 \u221a \u2212 ln(x) 2 \u221a \u2212 ln(\u03b4\u2032)\n\u2225 \u2225 \u2225 \u2225 \u2225\n[\u03b4\u2032,1\u2212\u03b4\u2032] \u2264 \u03b5, \u2016P\u2016[\u22121,1] \u2264 1.\nProof. Let f(x) =\n\u221a \u2212 ln(x)\n2 \u221a \u2212 ln(\u03b4\u2032) whose Taylor series expanded around x0 = 1 2 is f(x0+x) = \u2211\u221e k=0 akx k.\nWe note that f(x) is holomorphic in C \\ (\u2212\u221e, 0] \\ [1,\u221e) if we choose the definitions of ln(\u00b7) and \u221a\n(\u00b7) to be their principle branches in complex analysis. Thus the radius of convergence of the Taylor series of f(x) expanded around x0 = 1 2 is R = 1 2 . We have\nlim sup k\u2192\u221e\nk \u221a |ak| = 1\nR = 2.\nTherefore, there exists k0 \u2208 N such that for every k > k0, it holds that k \u221a |ak| < 2+ \u03b4\u2032. Now we set r = 12 \u2212 \u03b4\u2032 and \u03b4 = \u03b4\u2032/2, and we have\n\u221e \u2211\nk=0\n|ak| (r + \u03b4)k \u2264 \u221e \u2211\nk=0\n(2 + \u03b4\u2032)k ( 1 2 \u2212 \u03b4\n\u2032\n2\n)k +O(1) \u2264 \u221e \u2211\nk=0\n( 1\u2212 \u03b4 \u2032\n2\n)k\n+O(1) = 2\n\u03b4\u2032 +O(1) =: B.\nNow applying Lemma 3.2, there is an efficiently computable polynomial P \u2208 C[x] of degree O (\n1 \u03b4 log\n(\nB \u03b5\n)) = O ( 1 \u03b4\u2032 log ( 1 \u03b4\u2032\u03b5 )) such that\n\u2016f(x)\u2212 P (x)\u2016[\u03b4\u2032,1\u2212\u03b4\u2032] \u2264 \u03b5, \u2016P (x)\u2016[\u22121,1] \u2264 \u03b5+ \u2016f\u2016[3\u03b4\u2032/4,1\u22123\u03b4\u2032/4] ,\n\u2016P\u2016[\u22121,1]\\[3\u03b4\u2032/4,1\u22123\u03b4\u2032/4] \u2264 \u03b5. Here, we note that\n\u2016f\u2016[3\u03b4\u2032/4,1\u22123\u03b4\u2032/4] = f ( 3\u03b4\u2032\n4\n)\n\u2264 3 4\nand we obtain \u2016P\u2016[\u22121,1] \u2264 1 combining the three cases above. Finally, since we are only interested in the real part of P (x) and x is always a real number, just selecting the real part of the coefficients of P (x) will obtain a desired polynomial with real coefficients.\nNow we are ready to give the proof of Theorem 3.1.\nProof of Theorem 3.1. Let \u03b4, \u03b51 \u2208 (0, 14) and\nf(x) =\n\u221a\n\u2212 ln(x) 2 \u221a \u2212 ln(\u03b4) .\nBy Lemma 3.3, there is an even polynomial P (x) of degree O (\n1 \u03b4 log\n(\n1 \u03b4\u03b51\n))\nsuch that \u2016P\u2016[\u22121,1] \u2264 1 and \u2016P (x)\u2212 f(x)\u2016[\u03b4,1\u2212\u03b4] \u2264 \u03b51. By Corollary 2.11, there is an even polynomial R(x) of degree O (\n1 \u03b4 log\n(\n1 \u03b51\n))\nsuch that \u2016R\u2016[\u22121,1] \u2264 1 and\nR(x) \u2208 { [1\u2212 \u03b51, 1] x \u2208 [\u22121 + 2\u03b4, 1 \u2212 2\u03b4] [0, \u03b51] x \u2208 [\u22121,\u22121 + \u03b4] \u222a [1\u2212 \u03b4, 1] .\nWe note that P (x)R(x) is an even polynomial of degree d = O (\n1 \u03b4 log\n(\n1 \u03b4\u03b51\n))\n. Let \u03b41 \u2208 (0, 1) and by Lemma 2.4, there is a quantum circuit U\u0303 such that\n1. U\u0303 prepares an n-qubit subnormalized density operator A1, and A1 is a (1, 0, \u03b41)-block-encoding of \u03c1(P (\u03c1)R(\u03c1))2.\n2. U\u0303 uses O(d) queries to U\u03c1 and U \u2020 \u03c1 , 1 query to controlled-U and controlled-U \u2020 \u03c1 , and O((n+a)d)\nelementary quantum gates.\n3. A description of U\u0303 can be computed by a (classical) Turing machine in O(poly(d, log(1/\u03b41))) time.\nNow we are going to show that\n\u2225 \u2225x(P (x)R(x))2 \u2212 x(f(x))2 \u2225 \u2225 [0,1] \u2264 \u0398\n(\n\u03b51 + \u03b4\nln ( 1 \u03b4 )\n)\n,\nwhich immediately yields\n\u2225 \u2225\u03c1(P (\u03c1)R(\u03c1))2 \u2212 \u03c1(f(\u03c1))2 \u2225 \u2225 \u2264 \u0398 ( \u03b51 + \u03b4\nln ( 1 \u03b4 )\n)\n.\nWe consider four cases.\n1. x \u2208 [0, \u03b4]. In this case, \u2223 \u2223x(P (x)R(x))2 \u2212 x(f(x))2 \u2223 \u2223 \u2264 \u2223 \u2223x(P (x)R(x))2 \u2223 \u2223 + \u2223 \u2223x(f(x))2 \u2223 \u2223 \u2264 \u03b4 + \u03b4(f(\u03b4))2 = \u03b4 + \u03b4/4 = \u0398(\u03b4).\n2. x \u2208 [\u03b4, 1 \u2212 2\u03b4]. In this case, \u2223\n\u2223x(P (x)R(x))2 \u2212 x(f(x))2 \u2223 \u2223 \u2264 |x| (\u2223 \u2223(P (x))2 \u2212 (f(x))2 \u2223 \u2223 \u2223 \u2223(R(x))2 \u2223 \u2223+ \u2223 \u2223(R(x))2 \u2212 1 \u2223 \u2223 \u2223 \u2223(f(x))2 \u2223 \u2223 )\n\u2264 2 |P (x)\u2212 f(x)|+ 2 |R(x)\u2212 1| \u2264 \u03b51 + \u03b51 = \u0398(\u03b51).\n3. x \u2208 [1\u2212 2\u03b4, 1 \u2212 \u03b4]. We note that \u2212x ln(x) < 1\u2212 x for every x \u2208 (0, 1). In this case, \u2223\n\u2223x(P (x)R(x))2 \u2212 x(f(x))2 \u2223 \u2223 \u2264 \u2223 \u2223x(P (x)R(x))2 \u2223 \u2223+ \u2223 \u2223x(f(x))2 \u2223 \u2223 \u2264 \u2223 \u2223x(P (x))2 \u2223 \u2223+ \u2223 \u2223x(f(x))2 \u2223 \u2223\n\u2264 2 \u2223 \u2223x(f(x))2 \u2223 \u2223+ \u2223 \u2223x(P (x))2 \u2212 x(f(x))2 \u2223 \u2223 \u2264 2\u2212x ln(x)\u22124 ln(\u03b4) + 2 |P (x)\u2212 f(x)|\n\u2264 1\u2212 x\u22122 ln(\u03b4) + 2\u03b51 \u2264 2\u03b4 \u22122 ln(\u03b4) + 2\u03b51 = \u0398 ( \u03b4 ln (\n1 \u03b4\n) + \u03b51\n)\n.\n4. x \u2208 [1\u2212 \u03b4, 1]. In this case, \u2223\n\u2223x(P (x)R(x))2 \u2212 x(f(x))2 \u2223 \u2223 \u2264 \u2223 \u2223x(P (x)R(x))2 \u2223 \u2223+ \u2223 \u2223x(f(x))2 \u2223 \u2223 \u2264 \u2223 \u2223(R(x))2 \u2223 \u2223+ \u2223 \u2223x(f(x))2 \u2223 \u2223\n\u2264 \u0398 ( \u03b51 + \u03b4\nln ( 1 \u03b4 )\n)\n.\nWe note that tr ( \u03c1(f(\u03c1))2 ) = S(\u03c1) 4 ln( 1\u03b4 ) . Based on this, we have\n\u2223 \u2223 \u2223 \u2223 4 ln ( 1\n\u03b4\n) tr(A1)\u2212 S(\u03c1) \u2223 \u2223 \u2223\n\u2223\n\u2264 \u0398 ( r (\n(\u03b51 + \u03b41) ln\n(\n1\n\u03b4\n)\n+ \u03b4\n))\n.\nOn the other hand, tr(A1) has an upper bound that\ntr(A1) \u2264 S(\u03c1)\n4 ln ( 1 \u03b4\n) +O(1) \u2264 ln(r) 4 ln (\n1 \u03b4\n) +O(1) =: B.\nLet \u03b52 \u2208 (0, 1). By Lemma 2.15, we can compute p\u0303 such that |tr(A1)\u2212 p\u0303| \u2264 \u03b52 withO (\u221a\nB \u03b52 + 1\u221a\u03b52\n)\nqueries to U\u0303 and U\u0303 \u2020. Finally, we choose 4 ln (\n1 \u03b4\n)\np\u0303 to be the approximation of S(\u03c1). The error is bounded by \u2223 \u2223 \u2223 \u2223 4 ln ( 1\n\u03b4\n) p\u0303\u2212 S(\u03c1) \u2223 \u2223 \u2223\n\u2223\n\u2264 \u0398 ( r (\n(\u03b51 + \u03b41) ln\n(\n1\n\u03b4\n)\n+ \u03b4\n)\n+ \u03b52 ln\n(\n1\n\u03b4\n))\n. (4)\nLet the right hand side of Eq. (4) become \u2264 \u03b5, then the number of queries to U\u03c1 is O\u0303(r2/\u03b52)."
        },
        {
            "heading": "3.2 Max Entropy and Rank of Quantum States",
            "text": "The Max (Hartley) entropy Smax(\u03c1) = ln (rank(\u03c1)) of a quantum state \u03c1 is the logarithm of its rank. Low-rank quantum states turn out to be useful in quantum algorithms, e.g. [GLF+10, LMR14, RSML18, BKL+19, WZC+21]. Estimating the rank of quantum states is important in checking whether a quantum state fits in a certain low-rank condition of a quantum algorithm. Recently, [TV21] proposed a variational quantum algorithm to estimate the rank of quantum states. Here, we provide a quantum algorithm for rank estimation. For \u03b4 > 0, the \u03b4-rank of a matrix A is defined by rank\u03b4(A) = min{rank(B) : \u2016A\u2212B\u2016 \u2264 \u03b4}. In particular, rank0(A) = rank(A). We note that if A is Hermitian and has the spectrum decomposition A = \u2211\nj \u03bbj |\u03c8j\u3009 \u3008\u03c8j|, then rank\u03b4(A) = tr ( \u03a0supp\u03b4(A) )\nis the number of eigenvalues \u03bbj such that |\u03bbj | > \u03b4. Theorem 3.4 (Rank estimation). Suppose\n1. U is an (n + a)-qubit unitary operator that prepares an n-qubit density operator \u03c1.\n2. \u03b4 \u2208 (0, 110 ]. For \u03b5, \u03b5\u2032 > 0, there is a quantum algorithm that outputs r\u0303 such that\n(1\u2212 \u03b5) rank\u03b4(\u03c1)\u2212 \u03b5\u2032 \u2264 r\u0303 \u2264 (1 + \u03b5) rank(\u03c1) + \u03b5\u2032,\nusing O\u0303( 1 \u03b42\u03b5 ) queries to U and O\u0303( 1 \u03b42\u03b5 poly(n)) elementary quantum gates. Proof. Step 1. By Lemma 2.19, introducing parameters \u03b41, \u03b51 \u2208 (0, 110 ], there is a quantum circuit U\u0303 such that\n1. U\u0303 prepares an n-qubit subnormalized density operator A, which is a (1, 0, \u03b41)-block-encoding of \u03a0\u0303 such that\n(\n\u03b4 8 (1\u2212 2\u03b51)\u2212\n(\n\u03b4\n2\n)1/2\n\u03b51\n) \u03a0supp\u03b4(\u03c1) \u2264 \u03a0\u0303 \u2264 ( \u03b4 8 + \u03b521 + ( \u03b4 2 )1/2 \u03b51 ) \u03a0supp(\u03c1). (5)\n2. U\u0303 uses O(d) queries to U and U \u2020, 1 query to controlled-U and O((n+a)d) elementary quantum\ngates, where d = O (\n1 \u03b4 log\n(\n1 \u03b51\n))\n.\n3. A description of U\u0303 can be computed by a (classical) Turing machine in poly(d, log(1/\u03b41)) time.\nWe note that \u2223 \u2223 \u2223 tr(A)\u2212 tr(\u03a0\u0303) \u2223 \u2223 \u2223 \u2264 2n\u03b41 and by Eq. (5) we have\n( 1\u2212 2\u03b4\u22121\u03b51 ) rank\u03b4(\u03c1) \u2264 8\u03b4\u22121 tr(\u03a0\u0303) \u2264 ( 1 + 2\u03b4\u22121\u03b51 ) rank(\u03c1).\nStep 2. Introducing a parameter \u03b52, by Lemma 2.15, we can compute p\u0303 that estimates tr(A)\nsuch that |p\u0303\u2212 tr(A)| \u2264 \u03b52 with O (\u221a\nB \u03b52 + 1\u221a\u03b52\n)\nqueries to U\u0303 and U\u0303 \u2020, where B is an upper bound of\ntr(A). Here, we just choose B = 1. Step 3. Output r\u0303 = 8\u03b4\u22121p\u0303 as the estimation of the rank of \u03c1. Here, we see that (\n1\u2212 2\u03b4\u22121\u03b51 ) rank\u03b4(\u03c1)\u2212 8\u03b4\u22121 (2n\u03b41 + \u03b52) \u2264 r\u0303 \u2264 ( 1 + 2\u03b4\u22121\u03b51 ) rank(\u03c1) + 8\u03b4\u22121 (2n\u03b41 + \u03b52) .\nBy letting 2\u03b4\u22121\u03b51 = \u03b5 and 8\u03b4\u22121 (2n\u03b41 + \u03b52) = \u03b5\u2032, the number of queries to U is\nO\n(\n1 \u03b4 log\n(\n1\n\u03b51\n) \u00b7 (\u221a B\n\u03b52 + 1\u221a \u03b52\n))\n= O\u0303\n(\n1\n\u03b42\u03b5\n)\n.\nAnd similarly, the number of elementary quantum gates is O\u0303 ( 1 \u03b42\u03b5 poly(n) ) .\nBased on Theorem 3.4, we can obtain the exact rank of \u03c1 if \u03a0/\u03ba \u2264 \u03c1 for some projector \u03a0 and \u03ba > 0.\nCorollary 3.5 (Exact rank). Suppose\n1. U is an (n + a)-qubit unitary operator that prepares an n-qubit density operator \u03c1.\n2. \u03b4 \u2208 (0, 110 ]. If \u03a0/\u03ba \u2264 \u03c1 for some projector \u03a0 and \u03ba > 0, then there is a quantum algorithm that outputs r = rank(\u03c1) using O\u0303(\u03ba3) queries to U and O\u0303(\u03ba3 poly(n)) elementary quantum gates.\nProof. The claim holds immediately by letting \u03b4 = \u03b5 = \u0398(1/\u03ba) in Theorem 3.4.\nNow we furthermore define the \u03b4-Max entropy by Smax\u03b4 (\u03c1) = ln(rank\u03b4(\u03c1)). Based on Theorem 3.4, we are able to give an estimation of the Max entropy.\nTheorem 3.6 (Max entropy estimation). Suppose\n1. U is an (n + a)-qubit unitary operator that prepares an n-qubit density operator \u03c1.\n2. \u03b4 \u2208 (0, 110 ].\nFor \u03b5 > 0, there is a quantum algorithm that outputs s\u0303 such that\nSmax\u03b4 (\u03c1)\u2212 \u03b5 \u2264 s\u0303 \u2264 Smax(\u03c1) + \u03b5,\nusing O\u0303( 1 \u03b42\u03b5 ) queries to U and O\u0303( 1 \u03b42\u03b5\npoly(n)) elementary quantum gates. Moreover, if \u03a0/\u03ba \u2264 \u03c1 for some projector \u03a0 and \u03ba > 0, there is a quantum algorithm that com-\nputes the Max entropy Smax(\u03c1) within additive error \u03b5 using O\u0303(\u03ba 2 \u03b5 ) queries to U and O\u0303( \u03ba2\n\u03b5 poly(n)) elementary quantum gates.\nProof. By Theorem 3.4, there is a quantum algorithm that outputs r\u0303 such that\n( 1\u2212 \u03b5 2 ) rank\u03b4(\u03c1) \u2264 ( 1\u2212 \u03b5 4 ) rank\u03b4(\u03c1)\u2212 \u03b5 4 \u2264 r\u0303 \u2264 ( 1 + \u03b5 4 ) rank(\u03c1) + \u03b5 4 \u2264 ( 1 + \u03b5 2 ) rank(\u03c1),\nusing O\u0303( 1 \u03b42\u03b5 ) queries to U and O\u0303( 1 \u03b42\u03b5\npoly(n)) elementary quantum gates. After taking logarithm of both sides, we have\nln (rank\u03b4(\u03c1)) + ln ( 1\u2212 \u03b5 2 ) \u2264 ln(r\u0303) \u2264 ln (rank(\u03c1)) + ln ( 1 + \u03b5 2 ) ,\nwhich is Smax\u03b4 (\u03c1)\u2212 \u03b5 \u2264 ln(r\u0303) \u2264 Smax(\u03c1) + \u03b5.\nWe only need to output s\u0303 = ln(r\u0303) as an estimation of the Max entropy Smax(\u03c1). Moreover, if \u03a0/\u03ba \u2264 \u03c1 for some projector \u03a0 and \u03ba > 0, the claim is obtained by letting \u03b4 = 1\u03ba (and then Smax\u03b4 (\u03c1) = S max(\u03c1))."
        },
        {
            "heading": "3.3 Quantum Re\u0301nyi Entropy and Quantum Tsallis Entropy",
            "text": "Now we are going to discuss how quantum algorithms can compute the quantum Re\u0301nyi entropy SR\u03b1 (\u03c1) and the quantum Tsallis entropy S T \u03b1 (\u03c1). The key is to compute tr(\u03c1\n\u03b1), which is given as follows.\nTheorem 3.7 (Trace of positive powers). Suppose\n1. U\u03c1 is an (n + n\u03c1)-qubit unitary operator that prepares an n-qubit density operator \u03c1 with rank(\u03c1) \u2264 r.\n2. n\u03c1 is a polynomial in n.\nFor a \u2208 (0, 1) \u222a (1,+\u221e), there is a quantum algorithm that computes tr(\u03c1\u03b1) within additive error \u03b5 using Q queries to U\u03c1 and Q \u00b7 poly(n) elementary quantum gates, where\nQ =\n\n   \n   \nO\u0303\n(\nr 3\u2212\u03b12 2\u03b1 /\u03b5 3+\u03b1 2\u03b1\n)\n, 0 < \u03b1 < 1\nO (1/\u03b5) , \u03b1 > 1 \u2227 \u03b1 \u2261 1 mod 2 O\u0303 ( r1/{\u03b1\u221212 }/\u03b51+1/{\u03b1\u221212 } ) , otherwise\nand {x} = x\u2212 \u230ax\u230b is the decimal part of real number x.\nProof. We will discuss in three cases as stated in the statement of this theorem. Case 1. 0 < \u03b1 < 1. In this case, we have tr(\u03c1\u03b1) \u2264 r1\u2212\u03b1. By Lemma 2.8 and introducing \u03b41 and \u03b51, there is a quantum circuit U\u0303 such that\n1. U\u0303 prepares an n-qubit subnormalized density operator A, and A is a ( 4\u03b4\u03b1\u221211 , 0,\u0398 ( \u03b4\u03b11 + \u03b51\u03b4 \u03b1\u22121 1 ))\n- block-encoding of \u03c1\u03b1.\n2. U\u0303 usesO(d) queries to U\u03c1 andO((n+n\u03c1)d) elementary quantum gates, where d = O (\n1 \u03b41\nlog (\n1 \u03b51\n))\n.\n3. The description of U\u0303 can be computed by a classical Turing machine in O(poly(d)) time.\nNote that A is a ( 4\u03b4\u03b1\u221211 , 0,\u0398 ( \u03b4\u03b11 + \u03b51\u03b4 \u03b1\u22121 1 )) -block-encoding of \u03c1\u03b1, i.e., \u2225 \u22254\u03b4\u03b1\u221211 A\u2212 \u03c1\u03b1 \u2225 \u2225 \u2264 \u0398(\u03b4\u03b11 + \u03b51\u03b4 \u03b1\u22121 1 ), we have \u2223 \u22234\u03b4\u03b1\u221211 tr(A)\u2212 tr(\u03c1\u03b1) \u2223 \u2223 \u2264 \u0398(r(\u03b4\u03b11 + \u03b51\u03b4\u03b1\u221211 )). Therefore,\ntr(A) \u2264 1 4\u03b4\u03b1\u22121 ( tr(\u03c1\u03b1) + \u0398(r(\u03b4\u03b11 + \u03b51\u03b4 \u03b1\u22121 1 )) ) \u2264 \u0398(r1\u2212\u03b1\u03b41\u2212\u03b11 + r\u03b41 + r\u03b51) =: B.\nBy Lemma 2.15 and introducing \u03b52, we can obtain x\u0303 as an approximation of tr(A) with Q = O (\u221a\nB \u03b52 + 1\u221a\u03b52\n)\nqueries to U\u0303 such that |tr(A)\u2212 x\u0303| \u2264 \u03b52. Then we output 4\u03b4\u03b1\u221211 x\u0303 as an approximation of tr(\u03c1\u03b1) by noting that\n\u2223 \u22234\u03b4\u03b1\u221211 x\u0303\u2212 tr(\u03c1\u03b1) \u2223 \u2223 \u2264 \u0398 ( \u03b4\u03b1\u221211 \u03b52 + r(\u03b4 \u03b1 1 + \u03b51\u03b4 \u03b1\u22121 1 ) ) .\nThe number of queries to U\u03c1 is\nQd = O\u0303\n(\n1\n\u03b41\n(\u221a B\n\u03b52 + 1\u221a \u03b52\n))\n= O\u0303\n(\nr 3\u2212\u03b12 2\u03b1 /\u03b5 3+\u03b1 2\u03b1\n)\nby taking \u03b41 = \u0398\u0303 ( (\u03b5/r)1/\u03b1 ) , \u03b51 = \u0398\u0303 ( (\u03b5/r)1/\u03b1 ) and \u03b52 = \u0398\u0303 ( \u03b51/\u03b1/r1/\u03b1\u22121 ) .\nCase 2. \u03b1 > 1 and \u03b1 is an odd number. Let \u03b1 = 2\u03b2 + 1. By Lemma 2.1, there is a unitary operator U1, which is a (1, n+n\u03c1, 0)-block-encoding of \u03c1 with 1 query to U\u03c1. By Lemma 2.12, there is a unitary operator U\u03b2, which is a (1,\u0398(\u03b2(n+n\u03c1)), 0)-block-encoding of \u03c1\n\u03b2 with \u03b2 queries to U1. By Lemma 2.2, there is a quantum circuit U that prepares \u03c12\u03b2+1 = \u03c1\u03b1 with 1 query to U\u03c1 and 1 query to U\u03b2. Note that tr(\u03c1\n\u03b1) \u2264 1 and by Lemma 2.15, we can obtain x\u0303 as an approximation of tr(\u03c1\u03b1) with O(1/\u03b5) queries to U such that |x\u0303\u2212 tr(\u03c1\u03b1)| \u2264 \u03b5. In total, the number of queries to U\u03c1 is O(1/\u03b5) \u00b7 \u03b2 = O(1/\u03b5).\nCase 3. \u03b1 > 1 and \u03b1 is not an odd number. Let \u03b2 = \u230a \u03b1\u22121 2 \u230b and c = { \u03b1\u22121 2 }\n. By Lemma 2.13 and introducing \u03b41 and \u03b51, there is a unitary operator Uc that is a (2, O(n + n\u03c1),\u0398(\u03b51 + \u03b4 c 1))- block-encoding of \u03c1c with Q1 = O (\n1 \u03b41\nlog (\n1 \u03b51\n))\nqueries to U1. By Lemma 2.12, there is a unitary\noperator U\u03b2+c that is a (2, O(\u03b2(n+n\u03c1)),\u0398(\u03b51+\u03b4 c 1))-block-encoding of \u03c1 \u03b2+c with 1 query to U\u03b2 and 1 query to Uc. By Lemma 2.2, there is a unitary operator U that prepares a subnormalized density operator A with 1 query to U\u03c1 and 1 query to U\u03b2+c, and A is a (4, 0,\u0398(\u03b51 + \u03b4 c 1))-block-encoding of \u03c12(\u03b2+c)+1 = \u03c1\u03b1, i.e., \u20164A\u2212 \u03c1\u03b1\u2016 \u2264 \u0398(\u03b51 + \u03b4c1). Note that\ntr(A) \u2264 1 4 (tr(\u03c1\u03b1) + \u0398(r(\u03b51 + \u03b4 c 1))) =: B.\nBy Lemma 2.15 and introducing \u03b52, we can obtain x\u0303 as an approximation of tr(A) with Q2 = O (\u221a\nB \u03b52 + 1\u221a\u03b52\n)\nqueries to U such that |x\u0303\u2212 tr(A)| \u2264 \u03b52. Then we output 4x\u0303 as an approximation of tr(\u03c1\u03b1) by noting that |4x\u0303\u2212 tr(\u03c1\u03b1)| \u2264 \u0398(\u03b52 + r(\u03b51 + \u03b4c1)). The number of queries to U\u03c1 is\n(\u03b2 +Q1)Q2 = O\u0303\n(\n(\n\u03b2 + 1\n\u03b41\n) (\u221a B\n\u03b52 + 1\u221a \u03b52\n))\n= O\u0303\n(\nr1/c\n\u03b51+1/c\n)\nby taking \u03b41 = \u0398\u0303 ( (\u03b5/r)1/c ) , \u03b51 = \u0398\u0303 (\u03b5/r) and \u03b52 = \u0398\u0303 (\u03b5).\nIn the following, we are going to show how to estimate the quantum Re\u0301nyi and Tsallis entropies based on Theorem 3.7.\nTheorem 3.8 (Quantum Re\u0301nyi entropy). Suppose\n1. U\u03c1 is an (n + n\u03c1)-qubit unitary operator that prepares an n-qubit density operator \u03c1 with rank(\u03c1) \u2264 r.\n2. n\u03c1 is a polynomial in n.\nFor a \u2208 (0, 1) \u222a (1,+\u221e), there is a quantum algorithm that computes SR\u03b1 (\u03c1) within additive error \u03b5 using Q queries to U\u03c1 and Q \u00b7 poly(n) elementary quantum gates, where\nQ =\n\n   \n   \nO\u0303\n(\nr 3\u2212\u03b12 2\u03b1 /\u03b5 3+\u03b1 2\u03b1\n)\n, 0 < \u03b1 < 1\nO ( r\u03b1\u22121/\u03b5 ) , \u03b1 > 1 \u2227 \u03b1 \u2261 1 (mod 2) O\u0303 ( r\u03b1\u22121+\u03b1/{ \u03b1\u22121 2 }/\u03b51+1/{ \u03b1\u22121 2 } ) , otherwise\nand {x} = x\u2212 \u230ax\u230b is the decimal part of real number x.\nProof. We will discuss in cases as stated in the statement of this theorem. Case 1. 0 < \u03b1 < 1. In this case, 1 \u2264 tr(\u03c1\u03b1) \u2264 r1\u2212\u03b1. By Theorem 3.7, there is a quantum algorithm that outputs 1 \u2264 x \u2264 r1\u2212\u03b1 such that |x\u2212 tr(\u03c1\u03b1)| \u2264 \u03b5\u2032. Then \u2223\n\u2223 \u2223 \u2223\n1\n1\u2212 \u03b1 ln(x)\u2212 S R \u03b1 (\u03c1)\n\u2223 \u2223 \u2223 \u2223 \u2264 \u0398 ( \u03b5\u2032\n1\u2212 \u03b1\n)\n.\nLet \u03b5\u2032 = \u0398((1\u2212 \u03b1)\u03b5). The number of queries to U\u03c1 is\nO\u0303\n(\nr 3\u2212\u03b12 2\u03b1 /\u03b5\u2032 3+\u03b1 2\u03b1\n)\n= O\u0303\n(\nr 3\u2212\u03b12 2\u03b1 /\u03b5 3+\u03b1 2\u03b1\n)\n.\nCase 2. \u03b1 > 1. In this case, r1\u2212\u03b1 \u2264 tr(\u03c1\u03b1) \u2264 1. By Theorem 3.7, there is a quantum algorithm that outputs r1\u2212\u03b1 \u2264 x \u2264 1 such that |x\u2212 tr(\u03c1\u03b1)| \u2264 \u03b5\u2032. Then\n\u2223 \u2223 \u2223 \u2223 1\n1\u2212 \u03b1 ln(x)\u2212 S R \u03b1 (\u03c1)\n\u2223 \u2223 \u2223 \u2223 \u2264 \u0398 ( r\u03b1\u22121\u03b5\u2032\n\u03b1\u2212 1\n)\n.\nLet \u03b5\u2032 = \u0398((\u03b1\u2212 1)r1\u2212\u03b1\u03b5). Subcase 2.1. \u03b1 > 1 and \u03b1 is an odd number. The number of queries to U\u03c1 is\nO (\u03b1\n\u03b5\u2032\n)\n= O\n( r\u03b1\u22121\n\u03b5\n)\n.\nSubcase 2.2. \u03b1 > 1 and \u03b1 is not an odd number. The number of queries to U\u03c1 is\nO\u0303 (( \u03b1+ (r/\u03b5\u2032)1/{\u03b1\u221212 } ) /\u03b5\u2032 ) = O\u0303 ( r\u03b1\u22121+\u03b1/{ \u03b1\u22121 2 }/\u03b51+1/{ \u03b1\u22121 2 } ) .\nTheorem 3.9 (Quantum Tsallis entropy). Suppose\n1. U\u03c1 is an (n + n\u03c1)-qubit unitary operator that prepares an n-qubit density operator \u03c1 with rank(\u03c1) \u2264 r.\n2. n\u03c1 is a polynomial in n.\nFor a \u2208 (0, 1) \u222a (1,+\u221e), there is a quantum algorithm that computes ST\u03b1 (\u03c1) within additive error \u03b5 using Q queries to U\u03c1 and Q \u00b7 poly(n) elementary quantum gates, where\nQ =\n\n   \n   \nO\u0303\n(\nr 3\u2212\u03b12 2\u03b1 /\u03b5 3+\u03b1 2\u03b1\n)\n, 0 < \u03b1 < 1\nO (1/\u03b5) , \u03b1 > 1 \u2227 \u03b1 \u2261 1 (mod 2) O\u0303 ( r1/{ \u03b1\u22121 2 }/\u03b51+1/{ \u03b1\u22121 2 } ) , otherwise\nand {x} = x\u2212 \u230ax\u230b is the decimal part of real number x.\nProof. By Theorem 3.7, there is a quantum algorithm that outputs 1 \u2264 x \u2264 r1\u2212\u03b1 such that |x\u2212 tr(\u03c1\u03b1)| \u2264 \u03b5\u2032. Then\n\u2223 \u2223 \u2223 \u2223 1\n1\u2212 \u03b1 ln(x)\u2212 S T \u03b1 (\u03c1)\n\u2223 \u2223 \u2223 \u2223 \u2264 \u0398 ( \u03b5\u2032\n|1\u2212 \u03b1|\n)\n.\nLet \u03b5\u2032 = \u0398(|1\u2212 \u03b1| \u03b5). We will discuss in three cases as stated in the statement of this theorem. Case 1. 0 < \u03b1 < 1. The number of queries to U\u03c1 is\nO\u0303\n(\nr 3\u2212\u03b12 2\u03b1 /\u03b5\u2032 3+\u03b1 2\u03b1\n)\n= O\u0303\n(\nr 3\u2212\u03b12 2\u03b1 /\u03b5 3+\u03b1 2\u03b1\n)\n.\nCase 2. \u03b1 > 1 and \u03b1 is an odd number. The number of queries to U\u03c1 is\nO (\u03b1\n\u03b5\u2032\n)\n= O\n(\n1\n\u03b5\n)\n.\nCase 3. \u03b1 > 1 and \u03b1 is not an odd number. The number of queries to U\u03c1 is\nO\u0303 (( \u03b1+ (r/\u03b5\u2032)1/{\u03b1\u221212 } ) /\u03b5\u2032 ) = O\u0303 ( r1/{ \u03b1\u22121 2 }/\u03b51+1/{ \u03b1\u22121 2 } ) .\nWe note that when \u03b1 > 1 is an odd number, the query complexities of our quantum algorithms for tr(\u03c1\u03b1) and ST\u03b1 (\u03c1) do not depend on r. This result can be applied to computing the classical Tsallis entropy of a distribution p : [N ] \u2192 [0, 1]. Suppose a quantum oracle U is given as\nU |0\u3009 = \u2211\ni\u2208[N ]\n\u221a\np(i) |i\u3009 . (6)\nFor convenience, we assume that N = 2n. This kind of quantum oracle is called \u201cclassical distribution with pure state preparation access\u201d. We start from the quantum state |0\u3009n |0\u3009n, and the algorithm for estimating the classical Tsallis entropy of p is as follows.\n1. Apply U on the first part of the quantum state, then the state becomes \u2211\ni\u2208[N ]\n\u221a\np(i) |i\u3009n |0\u3009n .\n2. Apply a CNOT gate with control qubit the j-th qubit of the first part and target qubit the j-th qubit of the second part for each j \u2208 [n], then the state becomes\n\u2211\ni\u2208[N ]\n\u221a\np(i) |i\u3009n |i\u3009n .\n3. Note that if the second part of the quantum state after step 2 is traced out, it becomes a mixed quantum state (density operator)\n\u03c1 = \u2211\ni\u2208[N ] p(i) |i\u3009 \u3008i| .\nApply the algorithm of Theorem 3.9, we are able to obtain an estimation of the quantum Tsallis entropy ST\u03b1 (\u03c1) (i.e., the classical \u03b1-Tsallis entropy of p) within additive error \u03b5 with O(1/\u03b5) queries to U and O(1/\u03b5 \u00b7 poly(n)) elementary quantum gates.\nCorollary 3.10. For odd integer \u03b1 > 1, given the quantum oracle U to a probability distribution p : [N ] \u2192 [0, 1] as in Eq. (6), there is a quantum algorithm that computes the Tsallis entropy ST\u03b1 (p) of p within additive error \u03b5, using O(1/\u03b5) queries to U and O(1/\u03b5 \u00b7 poly(n)) elementary quantum gates.\nFor integer \u03b1 \u2265 2, according to [EAO+02] (see also [KLL+17]), there is a simple SWAP test like quantum circuit that outputs 0 and 1 with probability (1 \u00b1 tr(\u03c1\u03b1))/2, respectively, using \u03b1 copies of \u03c1. With a straightforward statistical method, we can estimate tr(\u03c1\u03b1) within additive error \u03b5 by O(1/\u03b52) repetitions of that quantum circuit. Directly applying this method also implies a quantum algorithm, which computes the Tsallis entropy (both quantum and classical) within additive error \u03b5, using O(1/\u03b52) queries to quantum oracles. Compare to this simple algorithm, our quantum algorithm (of Theorem 3.9 and Corollary 3.10) yields a quadratic speedup for odd \u03b1 > 1."
        },
        {
            "heading": "3.4 Lower Bounds",
            "text": "We establish lower bounds for estimating quantum entropies in the low-rank case, which are derived from known lower bounds for estimating entropies of classical distributions [LW19,BKT20].\nTheorem 3.11. Suppose U\u03c1 be a quantum oracle that prepares the density operator \u03c1, and r = rank(\u03c1). For \u03b1 \u2265 0, Any quantum algorithm that computes SR\u03b1 (\u03c1) within additive error \u03b5 = \u2126(1), then the number of queries to U\u03c1 is \u2126(Q(r)), where\nQ(r) =\n\n    \n    \nr1/3, \u03b1 = 0, max{r1/7\u03b1\u2212o(1), r1/3}, 0 < \u03b1 < 1, \u2126\u0303(r1/2), \u03b1 = 1, max{r 12\u2212 12\u03b1 , r1/3}, r > 1.\nProof. We obtain lower bounds from those for classical distributions. The quantum query model for classical distributions we adopt is called the \u201cclassical distribution with quantum query access\u201d. Suppose p : [N ] \u2192 [0, 1] is a probability distribution on [N ]. The quantum oracle U is given by\nU |s, 0\u3009 = |s, f(s)\u3009\nfor s \u2208 [S] and S \u2208 N such that\np(i) = 1\nS |{s \u2208 [S] : f(s) = i}|\nfor i \u2208 [N ]. It is pointed out in [GL20] that we can easily construct a \u201cpurified quantum query access\u201d oracle by preparing a uniform superposition through the Hadamard gates, and then makes\na query to U . Therefore, all lower bounds in the \u201cclassical distribution with quantum query access\u201d model also hold in the \u201cpurified quantum query access\u201d model.\nLet B(N) be the lower bound for estimating the Re\u0301nyi entropy. It is straightforward to see that if there is a quantum algorithm that computes the quantum Re\u0301nyi entropy using Q(r) queries to U\u03c1, then with the same algorithm, we can compute the Re\u0301nyi entropy of a probability distribution p : [N ] \u2192 [0, 1] using Q(N) queries to the \u201cclassical distribution with quantum query access\u201d oracle. Therefore, we have Q(r) \u2265 B(r). Our claim immediately holds by taking the lower bounds of B(N) given in [LW19,BKT20]."
        },
        {
            "heading": "4 Quantum Distances",
            "text": "Distance measures of quantum states are quantum information quantities that indicate their closeness. Testing the closeness of quantum states is a basic problem in quantum property testing. Two of the most important distance measures of quantum states are the trace distance and fidelity.\nIn this section, we will provide quantum algorithms for computing them as well as their extensions. Section 4.1 presents quantum algorithms for computing the trace distance and its extension. Section 4.2 presents quantum algorithms for computing the fidelity and its extensions."
        },
        {
            "heading": "4.1 Trace Distance",
            "text": "The \u03b1-trace distance of two quantum states \u03c1 and \u03c3 is defined by\nT\u03b1(\u03c1, \u03c3) = tr\n(\u2223\n\u2223 \u2223 \u2223 \u03c1\u2212 \u03c3 2\n\u2223 \u2223 \u2223 \u2223 \u03b1) .\nHere, T1(\u03c1, \u03c3) = T (\u03c1, \u03c3) is the trace distance. The trace distance of two pure quantum states (i.e., quantum states of rank 1) can be computed directly from their fidelity, which can be solved by the SWAP test [BCWdW01]. The closeness testing of the 1-, 2-, and 3-trace distances were studied in [GL20].\nOur quantum algorithms for computing the \u03b1-trace distance are given as follows.\nTheorem 4.1. Suppose\n1. U\u03c1 is an (n+ n\u03c1)-qubit unitary operator that prepares an n-qubit density operator \u03c1.\n2. U\u03c3 is an (n + n\u03c3)-qubit unitary operator that prepares an n-qubit density operator \u03c3.\n3. n\u03c1 and n\u03c3 are polynomials in n.\n4. r = max{rank(\u03c1), rank(\u03c3)}.\nFor \u03b1 > 0, there is a quantum algorithm that computes T\u03b1(\u03c1, \u03c3) within additive error \u03b5 using Q queries to both U\u03c1 and U\u03c3, and Q \u00b7 poly(n) elementary quantum gates, where\nQ =\n\n \n \nO\u0303(r3/\u03b54), \u03b1 \u2261 0 (mod 2) O\u0303(r5/\u03b1/\u03b55/\u03b1+1), 0 < \u03b1 < 1 O\u0303 ( r3+1/{\u03b1/2}/\u03b54+1/{\u03b1/2} ) , otherwise\nand {\u03b2} = \u03b2 \u2212 \u230a\u03b2\u230b. Especially, taking \u03b1 = 1, we obtain a quantum algorithm for trace distance estimation using O\u0303(r5/\u03b56) queries to U\u03c1 and U\u03c3.\nThe key observation of our quantum algorithm is that\nT\u03b1(\u03c1, \u03c3) = tr\n(\u2223\n\u2223 \u2223 \u2223 \u03c1\u2212 \u03c3 2\n\u2223 \u2223 \u2223 \u2223 \u03b1) = tr\n(\n\u2223 \u2223 \u2223 \u2223 \u03c1\u2212 \u03c3 2 \u2223 \u2223 \u2223 \u2223 \u03b1/2 \u03a0supp(\u00b5) \u2223 \u2223 \u2223 \u2223 \u03c1\u2212 \u03c3 2 \u2223 \u2223 \u2223 \u2223\n\u03b1/2 )\n,\nwhere \u00b5 = (\u03c1+ \u03c3) /2, supp(\u00b5) is the support of \u00b5 and \u03a0S is the projector onto a subspace S. A straightforward idea is to first prepare a subnormalized density operator that is a block-encoding of \u03a0supp(\u00b5), and then prepare another subnormalized density operator that is a block-encoding of |\u03bd|\u03b1/2 \u03a0supp(\u00b5) |\u03bd|\u03b1/2 by the evolution of subnormalized density operators (Lemma 2.2), where \u03bd = (\u03c1\u2212\u03c3)/2. However, we are only able to prepare subnormalized density operator that is a blockencoding of a projector onto a truncated support by Lemma 2.19. In this way, we can prepare a subnormalized density operator |\u03bd|\u03b1/2 \u03a0supp\u03b4(\u00b5) |\u03bd|\n\u03b1/2 for some \u03b4 > 0, instead of |\u03bd|\u03b1/2 \u03a0supp(\u00b5) |\u03bd|\u03b1/2. When \u03b4 is fixed, the inherent error of this approach is\nProposition 4.2. \u2223\n\u2223 \u2223 tr ( |\u03bd|\u03b1/2 \u03a0supp(\u00b5) |\u03bd|\u03b1/2 ) \u2212 tr ( |\u03bd|\u03b1/2 \u03a0supp\u03b4(\u00b5) |\u03bd| \u03b1/2 )\u2223 \u2223 \u2223 \u2264 2r\u03b4min{\u03b1,1}/2.\nProof. Let \u00b5 = \u2211 j \u03bbj |\u03c8j\u3009 \u3008\u03c8j |, where \u03bbj \u2208 [0, 1] and \u2211 j \u03bbj = 1. Then \u2016|\u03bd| |\u03c8j\u3009\u2016 \u2264 \u221a\n\u03bbj. This is seen by the following.\n\u2016|\u03c1\u2212 \u03c3| |\u03c8j\u3009\u20162 = \u3008\u03c8j | (\u03c1\u2212 \u03c3)2 |\u03c8j\u3009 = \u3008\u03c8j | \u03c12 |\u03c8j\u3009+ \u3008\u03c8j | \u03c32 |\u03c8j\u3009 \u2212 \u3008\u03c8j | (\u03c1\u03c3 + \u03c3\u03c1) |\u03c8j\u3009 \u2264 \u3008\u03c8j | \u03c12 |\u03c8j\u3009+ \u3008\u03c8j | \u03c32 |\u03c8j\u3009+ |\u3008\u03c8j | \u03c1\u03c3 |\u03c8j\u3009|+ |\u3008\u03c8j |\u03c3\u03c1 |\u03c8j\u3009| \u2264 \u3008\u03c8j | \u03c12 |\u03c8j\u3009+ \u3008\u03c8j | \u03c32 |\u03c8j\u3009+ 2 \u2016\u03c1 |\u03c8j\u3009\u2016 \u2016\u03c3 |\u03c8j\u3009\u2016\n= \u3008\u03c8j | \u03c12 |\u03c8j\u3009+ \u3008\u03c8j | \u03c32 |\u03c8j\u3009+ 2 \u221a\n\u3008\u03c8j| \u03c12 |\u03c8j\u3009 \u3008\u03c8j |\u03c32 |\u03c8j\u3009 \u2264 2 ( \u3008\u03c8j | \u03c12 |\u03c8j\u3009+ \u3008\u03c8j| \u03c32 |\u03c8j\u3009 ) \u2264 2 (\u3008\u03c8j | \u03c1 |\u03c8j\u3009+ \u3008\u03c8j |\u03c3 |\u03c8j\u3009) = 4 \u3008\u03c8j|\u00b5 |\u03c8j\u3009 \u2264 4 \u2016\u00b5 |\u03c8j\u3009\u2016 = 4\u03bbj .\nNote that \u2223\n\u2223 \u2223 tr ( |\u03bd|\u03b1/2 \u03a0supp(\u00b5) |\u03bd|\u03b1/2 ) \u2212 tr ( |\u03bd|\u03b1/2 \u03a0supp\u03b4(\u00b5) |\u03bd| \u03b1/2 )\u2223 \u2223 \u2223 = tr (( \u03a0supp(\u00b5) \u2212\u03a0supp\u03b4(\u00b5) ) |\u03bd|\u03b1 ) .\nThen for \u03b1 \u2265 1, we have tr ((\n\u03a0supp(\u00b5) \u2212\u03a0supp\u03b4(\u00b5) ) |\u03bd|\u03b1 ) = \u2211\n0<\u03bbj<\u03b4\n\u3008\u03c8j | |\u03bd|\u03b1 |\u03c8j\u3009\n\u2264 \u2211\n0<\u03bbj<\u03b4\n\u3008\u03c8j | |\u03bd| |\u03c8j\u3009\n\u2264 \u2211\n0<\u03bbj<\u03b4\n\u2016|\u03bd| |\u03c8j\u3009\u2016\n\u2264 \u2211\n0<\u03bbj<\u03b4\n\u221a\n\u03bbj\n\u2264 \u221a \u03b4 rank(\u00b5) \u2264 2r \u221a \u03b4.\nBefore deriving bounds for 0 < \u03b1 < 1, we need the following lemma.\nLemma 4.3. Suppose that A is an n-dimensional positive semidefinite operator, |\u03c8\u3009 is an ndimensional vector, and 0 < \u03b1 < 1. Then\n\u2016A\u03b1 |\u03c8\u3009\u2016 \u2264 \u2016A |\u03c8\u3009\u2016\u03b1 \u2016|\u03c8\u3009\u20161\u2212\u03b1 .\nProof. Let\nA = n \u2211\nj=1\n\u03bbj |\u03c8j\u3009 \u3008\u03c8j | ,\nwhere {|\u03c8j\u3009} is an orthonormal basis, and \u03bbj \u2265 0 for all 1 \u2264 j \u2264 n. Let\n|\u03c8\u3009 = n \u2211\nj=1\n\u03b2j |\u03c8j\u3009 .\nBy Ho\u0308lder\u2019s inequality, we have\n\u2016A\u03b1 |\u03c8\u3009\u20162 = n \u2211\nj=1\n\u2223 \u2223\u03bb\u03b1j \u03b2j \u2223 \u2223 2\n=\nn \u2211\nj=1\n\u2223 \u2223\u03bb2\u03b1j \u03b2 2\u03b1 j \u2223\n\u2223 \u00b7 \u2223 \u2223 \u2223 \u03b2 2(1\u2212\u03b1) j \u2223 \u2223 \u2223\n\u2264\n\n\nn \u2211\nj=1\n\u2223 \u2223\u03bb2\u03b1j \u03b2 2\u03b1 j \u2223 \u2223 1/\u03b1\n\n\n\u03b1\n\nn \u2211\nj=1\n\u2223 \u2223 \u2223 \u03b2 2(1\u2212\u03b1) j \u2223 \u2223 \u2223\n1/(1\u2212\u03b1) \n\n1\u2212\u03b1\n=\n\n\nn \u2211\nj=1\n|\u03bbj\u03b2j |2   \u03b1  n \u2211\nj=1\n|\u03b2j |2  \n1\u2212\u03b1\n= \u2016A |\u03c8\u3009\u20162\u03b1 \u2016|\u03c8\u3009\u20162(1\u2212\u03b1) .\nFor 0 < \u03b1 < 1, by Lemma 4.3, we have\ntr (( \u03a0supp(\u00b5) \u2212\u03a0supp\u03b4(\u00b5) ) |\u03bd|\u03b1 ) = \u2211\n0<\u03bbj<\u03b4\n\u3008\u03c8j | |\u03bd|\u03b1 |\u03c8j\u3009\n\u2264 \u2211\n0<\u03bbj<\u03b4\n\u2016|\u03bd|\u03b1 |\u03c8j\u3009\u2016\n\u2264 \u2211\n0<\u03bbj<\u03b4\n\u2016|\u03bd| |\u03c8j\u3009\u2016\u03b1 \u2016|\u03c8j\u3009\u20161\u2212\u03b1\n\u2264 \u2211\n0<\u03bbj<\u03b4\n\u03bb \u03b1/2 j\n\u2264 2r\u03b4\u03b1/2.\nTherefore, \u2223\n\u2223 \u2223 tr ( |\u03bd|\u03b1/2 \u03a0supp(\u00b5) |\u03bd|\u03b1/2 ) \u2212 tr ( |\u03bd|\u03b1/2 \u03a0supp\u03b4(\u00b5) |\u03bd| \u03b1/2 )\u2223 \u2223 \u2223 \u2264 2r\u03b4min{\u03b1,1}/2.\nHence, we could obtain a reasonable error by setting \u03b4 small enough. Step 1. By Lemma 2.17 with the Hadamard gate\nH |0\u3009 = \u221a 1\n2 |0\u3009+\n\u221a\n1 2 |1\u3009 ,\nwe obtain an O(n+n\u03c1+n\u03c3)-qubit unitary operator U\u00b5 that prepares density operator \u00b5 = (\u03c1+\u03c3)/2, using 1 query to U\u03c1 and U\u03c3, and O(1) elementary quantum gates.\nIntroducing three parameters \u03b41, \u03b51, \u03b4Q \u2208 (0, 110 ], by Lemma 2.19, there is a quantum circuit U1, which prepares a subnormalized density operator A1 and A1 is a (1, 0, \u03b4Q)-block-encoding of \u03a01, where\n(\n\u03b41 4 (1\u2212 2\u03b51)\u2212 \u03b41/21 \u03b51\n)\n\u03a0supp2\u03b41 (\u00b5) \u2264 \u03a01 \u2264\n(\n\u03b41 4 + \u03b521 + \u03b4 1/2 1 \u03b51\n)\n\u03a0supp(\u00b5).\nHere, U1 uses Q1 queries to U\u00b5 and O(Q1(n + n\u03c1 + n\u03c3)) elementary quantum gates, where Q1 = O (\n1 \u03b41\nlog (\n1 \u03b51\n)) . Moreover, U1 can be computed by a classical Turing machine in poly ( Q1, log (\n1 \u03b4Q\n))\ntime. Next, we are going to construct a unitary operator that is a block-encoding of |\u03bd|\u03b1/2. By Lemma 2.1, there are two unitary operators V\u03c3 and V\u03c1 which are a (1, n+n\u03c3, 0)-block-encoding of \u03c3 and a (1, n+ n\u03c1, 0)-block-encoding of \u03c1, respectively. Here, V\u03c3 uses 1 query to each of U\u03c3 and U \u2020 \u03c3 and n\u03c3 elementary quantum gates, and V\u03c1 uses 1 query to each of U\u03c1 and U \u2020 \u03c1 and n\u03c1 elementary quantum gates. Let n\u2032 = max(n\u03c1, n\u03c3), then V\u03c1 \u2297 In\u2032\u2212n\u03c1 and V\u03c3 \u2297 In\u2032\u2212n\u03c3 are (1, n + n\u2032, 0)-block-encodings of \u03c1 and \u03c3, respectively. According to Definition 2.3, we note that (HX,H) is a (2, 1, 0)-statepreparation-pair for y = (1,\u22121), where H is the Hadamard gate and X is the Pauli matrix. By Theorem 2.18, there is a (2n+ n\u2032 + 1)-qubit quantum circuit W which is a (1, n+ n\u2032 + 1, 0)-blockencoding of \u03bd = (\u03c1 \u2212 \u03c3)/2, using 1 query to each of V\u03c1 and V\u03c3 and O(1) elementary quantum gates.\nNow we analyze the error if we replace \u03a0supp(\u00b5) by 4\u03b4 \u22121 1 \u03a01 in the following.\nProposition 4.4.\n\u2223 \u2223 \u2223tr ( |\u03bd|\u03b1/2 ( 4\u03b4\u221211 \u03a01 ) |\u03bd|\u03b1/2 ) \u2212 T\u03b1(\u03c1, \u03c3) \u2223 \u2223 \u2223 \u2264\n\n\n\n\u0398 ( \u03b51\u03b4 \u22121/2 1 + r\u03b4 1/2 1 )\n, \u03b1 \u2265 1, \u0398 (\nr1\u2212\u03b1\u03b51\u03b4 \u22121/2 1 + r\u03b4 \u03b1/2 1\n)\n, 0 < \u03b1 < 1.\nProof. Note that \u03a0L \u2264 4\u03b4\u221211 \u03a01 \u2264 \u03a0U , where\n\u03a0L = ( 1\u2212 2\u03b51 \u2212 4\u03b51\u03b4\u22121/21 )\n\u03a0supp2\u03b41 (\u00b5) ,\n\u03a0U = ( 1 + 4\u03b521\u03b4 \u22121 1 + 4\u03b51\u03b4 \u22121/2 1 ) \u03a0supp(\u00b5).\nThis leads to f(\u03a0L) \u2264 f ( 4\u03b4\u221211 \u03a01 ) \u2264 f(\u03a0U ), where f(\u03a0) = tr ( |\u03bd|\u03b1/2 \u03a0 |\u03bd|\u03b1/2 ) for convenience. Therefore,\n\u2223 \u2223f ( 4\u03b4\u221211 \u03a01 ) \u2212 f ( \u03a0supp(\u00b5) )\u2223 \u2223 \u2264 max{TL, TU},\nwhere TL = \u2223 \u2223f (\u03a0L)\u2212 f ( \u03a0supp(\u00b5) )\u2223 \u2223 ,\nTU = \u2223 \u2223f (\u03a0U )\u2212 f ( \u03a0supp(\u00b5) )\u2223 \u2223 .\nBy Proposition 4.2, we have\nTL \u2264 \u2223 \u2223 \u2223 f (\u03a0L)\u2212 f (\n\u03a0supp2\u03b41 (\u00b5)\n)\u2223\n\u2223 \u2223 + \u2223 \u2223 \u2223 f (\n\u03a0supp2\u03b41 (\u00b5)\n)\n\u2212 f ( \u03a0supp(\u00b5) )\n\u2223 \u2223 \u2223\n\u2264 f (( 2\u03b51 + 4\u03b51\u03b4 \u22121/2 1 )\n\u03a0supp2\u03b41 (\u00b5)\n)\n+ 2r(2\u03b41) min{\u03b1,1}/2\n\u2264 \u0398 ( \u03b51\u03b4 \u22121/2 1 T\u03b1(\u03c1, \u03c3) + r\u03b4 min{\u03b1,1}/2 1 ) .\nAlso we have\nTU \u2264 f (( 4\u03b521\u03b4 \u22121 1 + 4\u03b51\u03b4 \u22121/2 1 ) \u03a0supp(\u00b5) ) \u2264 \u0398 ( \u03b51\u03b4 \u22121/2 1 T\u03b1(\u03c1, \u03c3) ) .\nCombining the both, we have \u2223\n\u2223f ( 4\u03b4\u221211 \u03a01 ) \u2212 f ( \u03a0supp(\u00b5) )\u2223 \u2223 \u2264 \u0398 ( \u03b51\u03b4 \u22121/2 1 T\u03b1(\u03c1, \u03c3) + r\u03b4 min{\u03b1,1}/2 1 ) .\nWe note that T\u03b1(\u03c1, \u03c3) \u2264 1 if \u03b1 \u2265 1, and T\u03b1(\u03c1, \u03c3) \u2264 (2r)1\u2212\u03b1 if 0 < \u03b1 < 1. These yield the claim.\nIn the following, we separately consider different cases of \u03b1.\nCase 1: \u03b1 is an even integer\nStep 2. By Lemma 2.12, there is a unitary operator W\u03b1/2, which is a (1, O(\u03b1(n+n \u2032)), 0)-blockencoding of |\u03bd|\u03b1/2, using \u03b1/2 queries to W . By Lemma 2.2, using 1 query to each of W\u03b1/2 and U1, we obtain a quantum circuit U\u0303 , which prepares a subnormalized density operator |\u03bd|\u03b1/2A1 |\u03bd|\u03b1/2. We note that\n\u2225 \u2225 \u2225 |\u03bd|\u03b1/2A1 |\u03bd|\u03b1/2 \u2212 |\u03bd|\u03b1/2 \u03a01 |\u03bd|\u03b1/2 \u2225 \u2225 \u2225 \u2264 \u2016A1 \u2212\u03a01\u2016 \u2264 \u03b4Q.\nStep 3. Introducing a parameter \u03b53, by Lemma 2.15, we can compute p\u0303 that estimates\ntr(|\u03bd|\u03b1/2A1 |\u03bd|\u03b1/2) such that \u2223 \u2223 \u2223 p\u0303\u2212 tr(|\u03bd|\u03b1/2A1 |\u03bd|\u03b1/2) \u2223 \u2223 \u2223 \u2264 \u03b53 with O\n(\u221a B\n\u03b53 + 1\u221a\u03b53\n)\nqueries to U\u0303 , where\nB = \u0398 (\n\u03b41 + \u03b5 2 1 + \u03b4 1/2 1 \u03b51 + r\u03b4Q\n)\nis an upper bound of tr(|\u03bd|\u03b1/2A1 |\u03bd|\u03b1/2). Note that\ntr(|\u03bd|\u03b1/2A1 |\u03bd|\u03b1/2) \u2264 tr ( |\u03bd|\u03b1/2 \u03a01 |\u03bd|\u03b1/2 ) +\u0398(r\u03b4Q)\n\u2264 \u0398 (\n\u03b41 + \u03b5 2 1 + \u03b4 1/2 1 \u03b51 + r\u03b4Q\n)\n.\nStep 4. Output 4\u03b4\u221211 p\u0303 \u2248 T\u03b1(\u03c1, \u03c3) as the estimation. The additive error is \u2223 \u22234\u03b4\u221211 p\u0303\u2212 T\u03b1(\u03c1, \u03c3) \u2223 \u2223 \u2264 4\u03b4\u221211 \u2223 \u2223 \u2223p\u0303\u2212 tr(|\u03bd|\u03b1/2A1 |\u03bd|\u03b1/2) \u2223 \u2223 \u2223+ 4\u03b4\u221211 \u2223 \u2223 \u2223tr(|\u03bd|\u03b1/2A1 |\u03bd|\u03b1/2)\u2212 tr(|\u03bd|\u03b1/2 \u03a01 |\u03bd|\u03b1/2) \u2223 \u2223 \u2223\n+ \u2223 \u2223 \u2223tr ( |\u03bd|\u03b1/2 ( 4\u03b4\u221211 \u03a01 ) |\u03bd|\u03b1/2 ) \u2212 tr ( |\u03bd|\u03b1/2 \u03a0supp(\u00b5) |\u03bd|\u03b1/2 )\u2223 \u2223 \u2223\n\u2264 \u0398 (\nr\u03b4 1/2 1 + \u03b51\u03b4 \u22121/2 1 + \u03b4 \u22121 1 (\u03b53 + r\u03b4Q)\n)\n.\nIn order to make \u2223 \u22234\u03b4\u221211 p\u0303\u2212 T\u03b1(\u03c1, \u03c3) \u2223 \u2223 \u2264 \u03b5, it is sufficient to let \u03b41 = \u0398(\u03b52/r2), \u03b53 = \u0398(\u03b53/r2), and other parameters become small enough polynomials in r and 1/\u03b5. Under these conditions, the number of queries to U\u03c1 and U\u03c3 is\nQ = O\n(\nQ1\u03b1\n(\u221a B\n\u03b53 + 1\u221a \u03b53\n))\n= O\u0303\n(\nr3 \u03b54\n)\n,\nand the number of elementary quantum gates is O(Q \u00b7 poly(n)).\nCase 2: \u03b1 \u2265 1 and \u03b1 is not an even integer\nStep 2. Now introducing two parameters \u03b42, \u03b52 \u2208 (0, 14 ], by Lemma 2.13, there is a quantum circuit W{\u03b1/2} that is a (1, O(n + n \u2032), 0)-block-encoding of A2, and A2 is a (2, 0,\u0398(\u03b52 + \u03b4 {\u03b1/2} 2 ))- block-encoding of |\u03bd|{\u03b1/2}, using Q2 queries to W and O (Q2(n+ n\u2032)) elementary quantum gates, where Q2 = O (\n1 \u03b42\nlog (\n1 \u03b52\n))\n. By Lemma 2.12, there is a unitary operator W\u230a\u03b1/2\u230b, which is a\n(1, O(\u03b1(n + n\u2032)), 0)-block-encoding of |\u03bd|\u230a\u03b1/2\u230b, using \u230a\u03b1/2\u230b queries to W . Again by Lemma 2.12, there is a unitary operator W\u03b1/2, which is a (2, O(\u03b1(n + n \u2032)),\u0398(\u03b52 + \u03b4 {\u03b1/2} 2 ))-block-encoding of |\u03bd|\u03b1/2, using 1 query to W{\u03b1/2} and 1 query to W\u230a\u03b1/2\u230b. By Lemma 2.2, using 1 query to each of W\u03b1/2 and U1, we obtain a quantum circuit U\u0303 , which prepares a subnormalized density operator A2A1A \u2020 2. We note that\n\u2225 \u2225 \u2225 \u2225 A2A1A \u2020 2 \u2212 1\n4 |\u03bd|\u03b1/2 \u03a01 |\u03bd|\u03b1/2\n\u2225 \u2225 \u2225 \u2225 \u2264 \u2225 \u2225 \u2225 A2A1A \u2020 2 \u2212A2\u03a01A \u2020 2 \u2225 \u2225 \u2225 + \u2225 \u2225 \u2225 \u2225 A2\u03a01A \u2020 2 \u2212 1\n4 |\u03bd|\u03b1/2 \u03a01 |\u03bd|\u03b1/2\n\u2225 \u2225 \u2225 \u2225\n\u2264 \u2016A1 \u2212\u03a01\u2016+ \u2225 \u2225 \u2225\n\u2225\nA2 \u2212 1\n2 |\u03bd|\u03b1/2\n\u2225 \u2225 \u2225 \u2225 \u2016\u03a01\u2016 \u2225 \u2225 \u2225A \u2020 2 \u2225 \u2225 \u2225\n+\n\u2225 \u2225 \u2225 \u2225 A\u20202 \u2212 1\n2 |\u03bd|\u03b1/2\n\u2225 \u2225 \u2225 \u2225 \u2016\u03a01\u2016 \u2225 \u2225 \u2225 \u2225 1\n2 |\u03bd|\u03b1/2\n\u2225 \u2225 \u2225 \u2225\n\u2264 \u0398 (\n\u03b4Q + (\u03b41 + \u03b5 2 1 + \u03b4 1/2 1 \u03b51)(\u03b52 + \u03b4 {\u03b1/2} 2 )\n)\n.\nStep 3. Introducing a parameter \u03b53, by Lemma 2.15, we can compute p\u0303 that estimates\ntr(A2A1A \u2020 2) such that\n\u2223 \u2223 \u2223p\u0303\u2212 tr(A2A1A\u20202) \u2223 \u2223 \u2223 \u2264 \u03b53 with O (\u221a B \u03b53 + 1\u221a\u03b53 ) queries to U\u0303 , where B =\n\u0398 (\n(\u03b41 + \u03b5 2 1 + \u03b4 1/2 1 \u03b51)(1 + r(\u03b52 + \u03b4 {\u03b1/2} 2 )) + r\u03b4Q\n)\nis an upper bound of tr(A2A1A \u2020 2). Note that\ntr(A2A1A \u2020 2) \u2264 tr\n(\n1 4 |\u03bd|\u03b1/2 \u03a01 |\u03bd|\u03b1/2\n)\n+\u0398 ( r (\n\u03b4Q + (\u03b41 + \u03b5 2 1 + \u03b4 1/2 1 \u03b51)(\u03b52 + \u03b4 {\u03b1/2} 2 )\n))\n\u2264 \u0398 (\n(\u03b41 + \u03b5 2 1 + \u03b4 1/2 1 \u03b51)(1 + r(\u03b52 + \u03b4 {\u03b1/2} 2 )) + r\u03b4Q\n)\n.\nStep 4. Output 4\u03b4\u221211 p\u0303 \u2248 T\u03b1(\u03c1, \u03c3) as the estimation. The additive error is \u2223\n\u22234\u03b4\u221211 p\u0303\u2212 T\u03b1(\u03c1, \u03c3) \u2223 \u2223 \u2264 4\u03b4\u221211 \u2223 \u2223 \u2223 p\u0303\u2212 tr(A2A1A\u20202) \u2223 \u2223 \u2223 + 4\u03b4\u221211 \u2223 \u2223 \u2223 tr(A2A1A \u2020 2)\u2212 tr(|\u03bd|\u03b1/2 \u03a01 |\u03bd|\u03b1/2) \u2223 \u2223 \u2223\n+ \u2223 \u2223 \u2223tr ( |\u03bd|\u03b1/2 ( 4\u03b4\u221211 \u03a01 ) |\u03bd|\u03b1/2 ) \u2212 tr ( |\u03bd|\u03b1/2 \u03a0supp(\u00b5) |\u03bd|\u03b1/2 )\u2223 \u2223 \u2223\n\u2264 \u0398 (\nr\u03b4 1/2 1 + \u03b51\u03b4 \u22121/2 1 + r(\u03b52 + \u03b4 {\u03b1/2} 2 )(1 + \u03b51\u03b4 \u22121/2 1 ) + \u03b4 \u22121 1 (\u03b53 + r\u03b4Q)\n)\n.\nIn order to make \u2223 \u22234\u03b4\u221211 p\u0303\u2212 T\u03b1(\u03c1, \u03c3) \u2223 \u2223 \u2264 \u03b5, it is sufficient to let \u03b41 = \u0398(\u03b52/r2), \u03b42 = \u0398((\u03b5/r)1/{\u03b1/2}), \u03b53 = \u0398(\u03b5\n3/r2), and other parameters become small enough polynomials in r and 1/\u03b5. Under these conditions, the number of queries to U\u03c1 and U\u03c3 is\nQ = O\n(\nQ1(Q2 + \u03b1)\n(\u221a B\n\u03b53 + 1\u221a \u03b53\n))\n= O\u0303\n(\nr3+1/{\u03b1/2} \u03b54+1/{\u03b1/2}\n)\n,\nand the number of elementary quantum gates is O(Q \u00b7 poly(n)).\nCase 3: 0 < \u03b1 < 1\nStep 2. Introducing two parameters \u03b42, \u03b52 \u2208 (0, 14 ], by Lemma 2.13, there is a quantum circuit W\u03b1/2 that is a (1, O(n+n \u2032), 0)-block-encoding of A2, and A2 is a (2, 0,\u0398(\u03b52+\u03b4 \u03b1/2 2 ))-block-encoding of |\u03bd|\u03b1/2, using Q2 queries to W and O (Q2(n+ n\u2032)) elementary quantum gates, where Q2 = O (\n1 \u03b42\nlog (\n1 \u03b52\n))\n. By Lemma 2.2, using 1 query to each of W\u03b1/2 and U1, we obtain a quantum\ncircuit U\u0303 , which prepares a subnormalized density operator A2A1A \u2020 2. We note that\n\u2225 \u2225 \u2225 \u2225 A2A1A \u2020 2 \u2212 1\n4 |\u03bd|\u03b1/2 \u03a01 |\u03bd|\u03b1/2\n\u2225 \u2225 \u2225 \u2225 \u2264 \u2225 \u2225 \u2225 A2A1A \u2020 2 \u2212A2\u03a01A \u2020 2 \u2225 \u2225 \u2225 + \u2225 \u2225 \u2225 \u2225 A2\u03a01A \u2020 2 \u2212 1\n4 |\u03bd|\u03b1/2 \u03a01 |\u03bd|\u03b1/2\n\u2225 \u2225 \u2225 \u2225\n\u2264 \u2016A1 \u2212\u03a01\u2016+ \u2225 \u2225 \u2225\n\u2225\nA2 \u2212 1\n2 |\u03bd|\u03b1/2\n\u2225 \u2225 \u2225 \u2225 \u2016\u03a01\u2016 \u2225 \u2225 \u2225 A\u20202 \u2225 \u2225 \u2225\n+\n\u2225 \u2225 \u2225 \u2225 A\u20202 \u2212 1\n2 |\u03bd|\u03b1/2\n\u2225 \u2225 \u2225 \u2225 \u2016\u03a01\u2016 \u2225 \u2225 \u2225 \u2225 1\n2 |\u03bd|\u03b1/2\n\u2225 \u2225 \u2225 \u2225\n\u2264 \u0398 (\n\u03b4Q + (\u03b41 + \u03b5 2 1 + \u03b4 1/2 1 \u03b51)(\u03b52 + \u03b4 \u03b1/2 2 )\n)\n.\nStep 3. Introducing a parameter \u03b53, by Lemma 2.15, we can compute p\u0303 that estimates\ntr(A2A1A \u2020 2) such that\n\u2223 \u2223\n\u2223 p\u0303\u2212 tr(A2A1A\u20202)\n\u2223 \u2223 \u2223 \u2264 \u03b53 with O\n(\u221a B\n\u03b53 + 1\u221a\u03b53\n)\nqueries to U\u0303 , where B =\n\u0398 (\nr1\u2212\u03b1\u03b41 + r(\u03b41 + \u03b521 + \u03b4 1/2 1 \u03b51)(\u03b52 + \u03b4 \u03b1/2 2 ) + r\u03b4Q\n)\nis an upper bound of tr(A2A1A \u2020 2). Note that\ntr(A2A1A \u2020 2) \u2264 tr\n(\n1 4 |\u03bd|\u03b1/2 \u03a01 |\u03bd|\u03b1/2\n)\n+\u0398 ( r (\n\u03b4Q + (\u03b41 + \u03b5 2 1 + \u03b4 1/2 1 \u03b51)(\u03b52 + \u03b4 \u03b1/2 2 )\n))\n\u2264 \u0398 ( r1\u2212\u03b1\u03b41 + r(\u03b41 + \u03b5 2 1 + \u03b4 1/2 1 \u03b51)(\u03b52 + \u03b4 \u03b1/2 2 ) + r\u03b4Q ) .\nStep 4. Output 4\u03b4\u221211 p\u0303 \u2248 T\u03b1(\u03c1, \u03c3) as the estimation. The additive error is \u2223 \u22234\u03b4\u221211 p\u0303\u2212 T\u03b1(\u03c1, \u03c3) \u2223 \u2223 \u2264 4\u03b4\u221211 \u2223 \u2223 \u2223p\u0303\u2212 tr(A2A1A\u20202) \u2223 \u2223 \u2223+ 4\u03b4\u221211 \u2223 \u2223 \u2223tr(A2A1A \u2020 2)\u2212 tr(|\u03bd|\u03b1/2 \u03a01 |\u03bd|\u03b1/2) \u2223 \u2223 \u2223\n+ \u2223 \u2223 \u2223 tr ( |\u03bd|\u03b1/2 ( 4\u03b4\u221211 \u03a01 ) |\u03bd|\u03b1/2 ) \u2212 tr ( |\u03bd|\u03b1/2 \u03a0supp(\u00b5) |\u03bd|\u03b1/2 )\u2223 \u2223 \u2223\n\u2264 \u0398 (\nr\u03b4 \u03b1/2 1 + r 1\u2212\u03b1\u03b51\u03b4 \u22121/2 1 + r(\u03b52 + \u03b4 \u03b1/2 2 )(1 + \u03b51\u03b4 \u22121/2 1 ) + \u03b4 \u22121 1 (\u03b53 + r\u03b4Q)\n)\n.\nIn order to make \u2223 \u22234\u03b4\u221211 p\u0303\u2212 T\u03b1(\u03c1, \u03c3) \u2223 \u2223 \u2264 \u03b5, it is sufficient to let \u03b41 = \u0398((\u03b5/r)2/\u03b1), \u03b42 = \u0398((\u03b5/r)2/\u03b1), \u03b53 = \u0398(\u03b5\n2/\u03b1+1/r2/\u03b1), and other parameters become small enough polynomials in r and 1/\u03b5. Under these conditions, the number of queries to U\u03c1 and U\u03c3 is\nQ = O\n(\nQ1Q2\n(\u221a B\n\u03b53 + 1\u221a \u03b53\n))\n= O\u0303\n(\nr5/\u03b1+(1\u2212\u03b1)/2\n\u03b55/\u03b1+1\n)\n,\nand the number of elementary quantum gates is O(Q \u00b7 poly(n))."
        },
        {
            "heading": "4.2 Fidelity",
            "text": "Quantum fidelity estimation is a problem to compute the fidelity of two mixed quantum states given their purifications. The well-known SWAP test [BCWdW01] can solve this problem when one of\nthe quantum states is pure. Recently, [WZC+21] proposes a polynomial-time quantum algorithm for the case that one of the quantum states is low-rank. However, their algorithm has very large exponents of r (rank) and \u03b5 (additive error) in the complexity. Here, we are able to improve the complexity with much smaller exponents, compared to the O\u0303(r21.5/\u03b523.5) quantum algorithm for fidelity estimation proposed by [WZC+21].\nIn addition, the sandwiched quantum Re\u0301nyi relative entropy D\u03b1(\u03c1\u2016\u03c3) [WWY14,MLDS+13] is a generalization of quantum state measures, defined by\nF\u03b1(\u03c1, \u03c3) = exp ((\u03b1\u2212 1)D\u03b1(\u03c1\u2016\u03c3)) = tr (( \u03c3 1\u2212\u03b1 2\u03b1 \u03c1\u03c3 1\u2212\u03b1 2\u03b1 )\u03b1) .\nHere, F1/2(\u03c1, \u03c3) = F (\u03c1, \u03c3) is the quantum state fidelity. It is clear that 0 \u2264 F\u03b1(\u03c1, \u03c3) \u2264 1 for \u03b1 \u2208 (0, 1) (see [MLDS+13]). Recently, the sandwiched quantum Re\u0301nyi relative entropy is used in quantum machine learning [KMW21].\nOur quantum algorithms for computing the \u03b1-fidelity are given as follows.\nTheorem 4.5. Suppose\n1. U\u03c1 is an (n + n\u03c1)-qubit unitary operator that prepares an n-qubit density operator \u03c1 with rank(\u03c1) = r.\n2. U\u03c3 is an (n + n\u03c3)-qubit unitary operator that prepares an n-qubit density operator \u03c3.\n3. n\u03c1 and n\u03c3 are polynomials in n.\nFor \u03b1 \u2208 (0, 1), there is a quantum algorithm that computes F\u03b1(\u03c1, \u03c3) within additive error \u03b5, using O\u0303 ( r 3\u2212\u03b1 2\u03b1 /\u03b5 3+\u03b1 2\u03b1 ) queries to U\u03c1 13, Q queries to U\u03c3, and Q \u00b7poly(n) elementary quantum gates, where\nQ =\n\n\n\nO\u0303 ( r 3\u2212\u03b1 2\u03b1 /\u03b5 3+\u03b1 2\u03b1 )\n, \u03b2 \u2208 N, O\u0303 ( r 3\u2212\u03b1 2\u03b1 + 1 \u03b1{\u03b2}/\u03b5 3+\u03b1 2\u03b1 + 1 \u03b1{\u03b2} ) , \u03b2 /\u2208 N,\nand \u03b2 = (1\u2212 \u03b1)/2\u03b1, {\u03b2} = \u03b2 \u2212 \u230a\u03b2\u230b. Especially, taking \u03b1 = 12 , we obtain a quantum algorithm for fidelity estimation using O\u0303 ( r2.5/\u03b53.5 ) queries to U\u03c1 and O\u0303 ( r6.5/\u03b57.5 ) queries to U\u03c3.\nWe put the detailed proofs into the following subsubsections. In fact, such techniques used in estimating the relative sandwiched Re\u0301nyi entropy can also be used to compute the relative Re\u0301nyi entropy.\nCase 1: \u03b2 is an integer\nStep 1. By Lemma 2.1, there is a unitary operator U1, which is a (1, n+n\u03c3, 0)-block-encoding of \u03c3, using O(1) queries to U\u03c3 and O(n\u03c3) elementary quantum gates. By Lemma 2.12, there is a unitary operator U\u03b2, which is a (1, O(\u03b2(n + n\u03c3)), 0)-block-encoding of \u03c3\n\u03b2 , using \u03b2 queries to U1. By Lemma 2.2, there is a unitary operator U\u03b7, which prepares a subnormalized density operator \u03b7 = \u03c3\u03b2\u03c1\u03c3\u03b2, using 1 query to U\u03b2 and 1 query to U\u03c1.\n13Since the quantum algorithm is complicated, we do not distinguish between the queries to a unitary operator and those to its controlled versions, and we ignore poly-logarithmic factors.\nNow introducing two parameters \u03b41 and \u03b51, by Lemma 2.8, there is a unitary operator U\u0303 , which prepares a subnormalized density operator \u03b7\u2032 and \u03b7\u2032 is a (4\u03b4\u03b1\u221211 , 0,\u0398(\u03b4 \u03b1 1 + \u03b51\u03b4 \u03b1\u22121 1 ))-block-encoding of \u03b7\u03b1, using O(d1) queries to U\u03b7, where d1 = O( 1 \u03b41\nlog 1\u03b51 ). Step 2. Introducing a parameter \u03b52, by Lemma 2.15, we can compute p\u0303 such that |p\u0303\u2212 tr(\u03b7\u2032)| \u2264\n\u03b52, using O (\u221a\nB \u03b52 + 1\u221a\u03b52\n)\nqueries to U\u0303 , where B = \u0398 ( \u03b41\u2212\u03b11 + r(\u03b41 + \u03b51) ) is an upper bound of tr(\u03b7\u2032).\nNote that\ntr(\u03b7\u2032) \u2264 1 4 \u03b41\u2212\u03b11 tr (\u03b7 \u03b1) + \u0398 (r(\u03b41 + \u03b51)) \u2264 \u0398 ( \u03b41\u2212\u03b11 + r(\u03b41 + \u03b51) ) .\nStep 3. Output 4\u03b4\u03b1\u221211 p\u0303 \u2248 F\u03b1(\u03c1, \u03c3) as the estimation. The additive error is \u2223\n\u22234\u03b4\u03b1\u221211 p\u0303\u2212 F\u03b1(\u03c1, \u03c3) \u2223 \u2223 \u2264 4\u03b4\u03b1\u221211 \u2223 \u2223p\u0303\u2212 tr(\u03b7\u2032) \u2223 \u2223+ \u2223 \u2223tr(4\u03b4\u03b1\u221211 \u03b7 \u2032)\u2212 tr(\u03b7\u03b1) \u2223 \u2223\n\u2264 \u0398 ( r(\u03b4\u03b11 + \u03b51\u03b4 \u03b1\u22121 1 ) + \u03b4 \u03b1\u22121 1 \u03b52 ) .\nIn order to make \u2223 \u22234\u03b4\u03b1\u221211 p\u0303\u2212 F\u03b1(\u03c1, \u03c3) \u2223 \u2223 \u2264 \u03b5, it is sufficient to let \u03b41 = \u0398((\u03b5/r)1/\u03b1), \u03b51 = \u0398((\u03b5/r)1/\u03b1), and \u03b52 = \u0398(\u03b5 1/\u03b1/r1/\u03b1\u22121). Under these conditions, the number of queries to U\u03c3 is\nO\n(\n\u03b2d1\n(\u221a B\n\u03b52 + 1\u221a \u03b52\n))\n= O\u0303\n(\nr 3\u2212\u03b1 2\u03b1 \u03b5 3+\u03b1 2\u03b1\n)\n,\nand the number of queries to U\u03c1 is\nO\n(\nd1\n(\u221a B\n\u03b52 + 1\u221a \u03b52\n))\n= O\u0303\n(\nr 3\u2212\u03b1 2\u03b1 \u03b5 3+\u03b1 2\u03b1\n)\n,\nand the number of elementary quantum gates is\nO\n(\n\u03b2d1\n(\u221a B\n\u03b52 + 1\u221a \u03b52\n)) \u00b7 poly(n, n\u03c3, n\u03c1) = O\u0303 ( r 3\u2212\u03b1 2\u03b1\n\u03b5 3+\u03b1 2\u03b1\npoly(n)\n)\n.\nCase 2: \u03b2 is not an integer\nLet {\u03b2} = \u03b2 \u2212 \u230a\u03b2\u230b denote the decimal part of \u03b2. Step 1. By Lemma 2.1, there is a unitary operator U1, which is a (1, n+n\u03c3, 0)-block-encoding of \u03c3, using O(1) queries to U\u03c3 and O(n\u03c3) elementary quantum gates. By Lemma 2.13, introducing two parameters \u03b41 and \u03b51, there is a unitary operator U{\u03b2}, which is a (1, O(n + n\u03c3), 0)-blockencoding of A1, using O(Q1) queries to U1 and O(Q1(n + n\u03c3)) elementary quantum gates, where Q1 = O (\n1 \u03b41 log 1\u03b51\n)\nand A1 is a (2, 0,\u0398(\u03b51 + \u03b4 {\u03b2} 1 ))-block-encoding of \u03c3 {\u03b2}. By Lemma 2.12, there\nis a unitary operator U\u230a\u03b2\u230b, which is a (1, O(\u03b2(n+n\u03c3)), 0)-block-encoding of \u03c3 \u230a\u03b2\u230b, using \u230a\u03b2\u230b queries to U1. Again by Lemma 2.12, there is a unitary operator U\u03b2, which is a (2, O(\u03b2(n+n\u03c3)), 0)-blockencoding of A1\u03c3 \u230a\u03b2\u230b, using 1 query to U\u230a\u03b2\u230b and 1 query to U{\u03b2}. By Lemma 2.2, there is a unitary operator U\u0303 , which prepares a subnormalized density operator A1\u03c3 \u230a\u03b2\u230b\u03c1\u03c3\u230a\u03b2\u230bA\u20201, using 1 query to U\u0303 and 1 query to U\u03c1. Note that\n\u2225 \u2225 \u2225 \u2225 A1\u03c3 \u230a\u03b2\u230b\u03c1\u03c3\u230a\u03b2\u230bA\u20201 \u2212 1\n4 \u03c3\u03b2\u03c1\u03c3\u03b2\n\u2225 \u2225 \u2225 \u2225 \u2264 \u2225 \u2225 \u2225 \u2225 A1\u03c3 \u230a\u03b2\u230b \u2212 1 2 \u03c3\u03b2 \u2225 \u2225 \u2225 \u2225 \u2016\u03c1\u2016 \u2225 \u2225 \u2225 \u03c3\u230a\u03b2\u230bA\u20201 \u2225 \u2225 \u2225 + \u2225 \u2225 \u2225 \u2225 \u03c3\u230a\u03b2\u230bA\u20201 \u2212 1 2 \u03c3\u03b2 \u2225 \u2225 \u2225 \u2225 \u2016\u03c1\u2016 \u2225 \u2225 \u2225 \u2225 1 2 \u03c3\u03b2 \u2225 \u2225 \u2225 \u2225\n\u2264 \u0398 ( \u03b51 + \u03b4 {\u03b2} 1 ) .\nStep 2. By Lemma 2.8, introducing two parameters \u03b42 and \u03b52, there is a unitary operator U2, which prepares a subnormalized density operator A2, using O(Q2) queries to U\u0303 and O(Q2(n+n\u03c3+ n\u03c1)) elementary quantum gates, where Q2 = O (\n1 \u03b42 log 1\u03b52\n)\nand A2 is a (4\u03b4 \u03b1\u22121 2 , 0,\u0398(\u03b4 \u03b1\u22121 2 (\u03b42+ \u03b52)))-\nblock-encoding of ( A1\u03c3 \u230a\u03b2\u230b\u03c1\u03c3\u230a\u03b2\u230bA\u20201 )\u03b1 .\nIn order to analysis the error, we need the following lemma.\nLemma 4.6. Suppose that A and B are two positive semidefinite operators of rank \u2264 r, and 0 < \u03b1 < 1. Then |tr(A\u03b1)\u2212 tr(B\u03b1)| \u2264 5r \u2016A\u2212B\u2016\u03b1 . Proof. Let J = A\u2212B. Let the eigenvalues of A, B and J be\n\u00b51 \u2265 \u00b52 \u2265 \u00b7 \u00b7 \u00b7 \u2265 \u00b5N , \u03bd1 \u2265 \u03bd2 \u2265 \u00b7 \u00b7 \u00b7 \u2265 \u03bdN , \u03be1 \u2265 \u03be2 \u2265 \u00b7 \u00b7 \u00b7 \u2265 \u03beN ,\nrespectively. Then we have \u00b5r+1 = \u00b7 \u00b7 \u00b7 = \u00b5N = \u03bdr+1 = \u00b7 \u00b7 \u00b7 = \u03bdN = 0. By Weyl\u2019s inequality [Wey12], we have \u03bdj \u2212 \u2016J\u2016 \u2264 \u03bdj + \u03beN \u2264 \u00b5j \u2264 \u03bdj + \u03be1 \u2264 \u03bdj + \u2016J\u2016 for every 1 \u2264 j \u2264 N . Furthermore, it holds that \u2223 \u2223\n\u2223 \u00b5\u03b1j \u2212 \u03bd\u03b1j\n\u2223 \u2223 \u2223 \u2264 5 \u2016J\u2016\u03b1. This is seen by the following\ntwo cases.\n1. \u03bdj \u2265 ( 1 + \u03b1 1 1\u2212\u03b1 ) \u2016J\u2016. In this case, \u03bd\u03b1j \u2212\u2016J\u2016\u03b1 \u2264 (\u03bdj\u2212\u2016J\u2016)\u03b1 \u2264 \u00b5\u03b1j \u2264 (\u03bdj+\u2016J\u2016)\u03b1 \u2264 \u03bd\u03b1j +\u2016J\u2016\u03b1.\nThen we obtain that \u2223 \u2223 \u2223\u00b5\u03b1j \u2212 \u03bd\u03b1j \u2223 \u2223 \u2223 \u2264 \u2016J\u2016\u03b1.\n2. \u03bdj < ( 1 + \u03b1 1 1\u2212\u03b1 ) \u2016J\u2016 < 2 \u2016J\u2016. In this case, \u2223 \u2223 \u2223\u00b5\u03b1j \u2212 \u03bd\u03b1j \u2223 \u2223\n\u2223 \u2264 |\u00b5j|\u03b1 + |\u03bdj|\u03b1 \u2264 |\u03bdj + \u2016J\u2016|\u03b1 + |\u03bdj|\u03b1 < (3\u03b1 + 2\u03b1) \u2016J\u2016\u03b1 < 5 \u2016J\u2016\u03b1.\nThese yield that\n|tr(A\u03b1)\u2212 tr(B\u03b1)| =\n\u2223 \u2223 \u2223 \u2223 \u2223 \u2223 N \u2211\nj=1\n\u00b5\u03b1j \u2212 N \u2211\nj=1\n\u03bd\u03b1j\n\u2223 \u2223 \u2223 \u2223 \u2223 \u2223 \u2264 r \u2211\nj=1\n\u2223 \u2223\u00b5\u03b1j \u2212 \u03bd\u03b1j \u2223 \u2223 \u2264 5r \u2016J\u2016\u03b1 .\nBy Lemma 4.6, we have \u2223\n\u2223 \u2223 \u2223\ntr (( A1\u03c3 \u230a\u03b2\u230b\u03c1\u03c3\u230a\u03b2\u230bA\u20201\n)\u03b1) \u2212 tr (( 1\n4 \u03c3\u03b2\u03c1\u03c3\u03b2\n)\u03b1)\u2223 \u2223\n\u2223 \u2223\n\u2264 5r \u2225 \u2225 \u2225\n\u2225\nA1\u03c3 \u230a\u03b2\u230b\u03c1\u03c3\u230a\u03b2\u230bA\u20201 \u2212\n1 4 \u03c3\u03b2\u03c1\u03c3\u03b2\n\u2225 \u2225 \u2225 \u2225 \u03b1\n\u2264 \u0398 ( r ( \u03b51 + \u03b4 {\u03b2} 1 )\u03b1) .\nStep 3. Introducing a parameter \u03b53, by Lemma 2.15, we can compute p\u0303 such that |p\u0303\u2212 tr(A2)| \u2264 \u03b53, using O (\u221a B\n\u03b53 + 1\u221a\u03b53\n) queries to U2, where B = \u0398 ( \u03b41\u2212\u03b12 + r ( \u03b51 + \u03b4 {\u03b2} 1 )\u03b1 + r(\u03b42 + \u03b52) ) is an\nupper bound of tr(A2). Note that\ntr(A2) \u2264 1 4 \u03b41\u2212\u03b12 tr (( A1\u03c3 \u230a\u03b2\u230b\u03c1\u03c3\u230a\u03b2\u230bA\u20201 )\u03b1) +\u0398(r(\u03b42 + \u03b52))\n\u2264 1 4 \u03b41\u2212\u03b12\n(\ntr\n((\n1 4 \u03c3\u03b2\u03c1\u03c3\u03b2\n)\u03b1)\n+\u0398 ( r ( \u03b51 + \u03b4 {\u03b2} 1\n)\u03b1) )\n+\u0398(r(\u03b42 + \u03b52))\n\u2264 \u0398 ( \u03b41\u2212\u03b12 + r ( \u03b51 + \u03b4 {\u03b2} 1 )\u03b1 + r(\u03b42 + \u03b52) ) .\nStep 4. Output 4\u03b1+1\u03b4\u03b1\u221212 p\u0303 \u2248 F\u03b1(\u03c1, \u03c3) as the estimation. The additive error is \u2223 \u22234\u03b1+1\u03b4\u03b1\u221212 p\u0303\u2212 F\u03b1(\u03c1, \u03c3) \u2223 \u2223 \u2264 4\u03b1+1\u03b4\u03b1\u221212 |p\u0303\u2212 tr(A2)|+ 4\u03b1 \u2223 \u2223 \u2223 tr(4\u03b4\u03b1\u221212 A2)\u2212 tr (( A1\u03c3 \u230a\u03b2\u230b\u03c1\u03c3\u230a\u03b2\u230bA\u20201 )\u03b1)\u2223 \u2223 \u2223\n+ 4\u03b1 \u2223 \u2223 \u2223\n\u2223\ntr (( A1\u03c3 \u230a\u03b2\u230b\u03c1\u03c3\u230a\u03b2\u230bA\u20201 )\u03b1) \u2212 tr (( 1\n4 \u03c3\u03b2\u03c1\u03c3\u03b2\n)\u03b1)\u2223 \u2223\n\u2223 \u2223\n\u2264 \u0398 ( r ( \u03b51 + \u03b4 {\u03b2} 1 )\u03b1 + r\u03b4\u03b1\u221212 (\u03b52 + \u03b42) + \u03b4 \u03b1\u22121 2 \u03b53 ) .\nIn order to make \u2223 \u22234\u03b1+1\u03b4\u03b1\u221212 p\u0303\u2212 F\u03b1(\u03c1, \u03c3) \u2223 \u2223 \u2264 \u03b5, it is sufficient to let \u03b41 = \u0398((\u03b5/r)1/\u03b1{\u03b2}), \u03b51 = \u0398((\u03b5/r)1/\u03b1{\u03b2}), \u03b42 = \u0398 ( (\u03b5/r)1/\u03b1 ) , \u03b52 = \u0398 ( (\u03b5/r)1/\u03b1 ) and \u03b53 = \u0398 ( \u03b51/\u03b1/r1/\u03b1\u22121 )\n. Under these conditions, the number of queries to U\u03c3 is\nO\n(\nQ1Q2\n(\u221a B\n\u03b53 + 1\u221a \u03b53\n))\n= O\u0303\n( r 3\u2212\u03b1 2\u03b1 + 1 \u03b1{\u03b2}\n\u03b5 3+\u03b1 2\u03b1 + 1 \u03b1{\u03b2}\n)\n,\nand the number of queries to U\u03c1 is\nO\n(\nQ2\n(\u221a B\n\u03b53 + 1\u221a \u03b53\n))\n= O\u0303\n(\nr 3\u2212\u03b1 2\u03b1 \u03b5 3+\u03b1 2\u03b1\n)\n,\nand the number of elementary quantum gates is\nO\n(\nQ1Q2\n(\u221a B\n\u03b53 + 1\u221a \u03b53\n)) \u00b7 poly(n, n\u03c3, n\u03c1) = O\u0303 ( r 3\u2212\u03b1 2\u03b1 + 1 \u03b1{\u03b2}\n\u03b5 3+\u03b1 2\u03b1 + 1 \u03b1{\u03b2}\npoly(n)\n)\n."
        },
        {
            "heading": "4.3 Lower Bounds and Hardness",
            "text": "Our quantum algorithms for both fidelity estimation and trace distance estimation requires time complexity polynomial in the rank r of quantum states. Here, we show that unless BQP = QSZK, there is no quantum algorithm for both fidelity estimation and trace distance estimation with time complexity polylogarithmic in r.\nTheorem 4.7. If there is a quantum algorithm that computes fidelity or trace distance of quantum states of rank \u2264 r within additive error \u03b5 with time complexity poly (log r, 1/\u03b5), then BQP = QSZK.\nProof. Here, we recall a decision problem called (\u03b1, \u03b2)-Quantum State Distinguishability ((\u03b1, \u03b2)QSD). Given U\u03c1 and U\u03c3 that prepares the purifications of density operators \u03c1 and \u03c3 and a promise that either T (\u03c1, \u03c3) \u2264 \u03b1 or T (\u03c1, \u03c3) \u2265 \u03b2, the problem is to determine which is the case. It was shown in [Wat02] that (\u03b1, \u03b2)-QSD is QSZK-complete if 0 \u2264 \u03b1 < \u03b22 \u2264 1.\nIf there is a quantum algorithm for computing trace distance with time complexity poly (log r, 1/\u03b5), then we can distinguish the two cases with time complexity poly(n) by letting r = 2n be the dimension of the two quantum states and \u03b5 = (\u03b2 \u2212 \u03b1)/2 > 0.\nIf there is a quantum algorithm for computing fidelity with time complexity poly (log r, 1/\u03b5), then we can distinguish the two cases with time complexity poly(n) by letting r = 2n be the dimension of the two quantum states and \u03b5 = ( (1\u2212 \u03b1)\u2212 \u221a 1\u2212 \u03b22 ) /2 > 0. This is because T (\u03c1, \u03c3) \u2264 \u03b1 implies F (\u03c1, \u03c3) \u2265 1 \u2212 \u03b1, and T (\u03c1, \u03c3) \u2265 \u03b2 implies F (\u03c1, \u03c3) \u2264 \u221a\n1\u2212 \u03b22. Then (\u03b1, \u03b2)QSD is reduced to distinguish which is the case with promise that either F (\u03c1, \u03c3) \u2264 \u221a\n1\u2212 \u03b22 and F (\u03c1, \u03c3) \u2265 1\u2212 \u03b1.\nOur quantum algorithms for estimating the fidelity and trace distance achieve a significant speedup under the low-rank assumption. One might wonder whether our algorithms can be \u201cdequantized\u201d through quantum-inspired low-rank techniques such as [Tan19,GLT18, CGL+20]. To this end, we point out the hardness of estimating fidelity and trace distance as follows.\nTheorem 4.8. Computing the fidelity and trace distance are DQC1-hard, even for pure quantum states.\nProof. It was already proved in [CPCC20] that estimating the fidelity is DQC1-hard, even for pure quantum states. Here, we reduce the problem of estimating the fidelity to that of estimating the trace distance, and therefore show the DQC1-hardness of estimating the trace distance.\nFor any two pure quantum states \u03c8 = |\u03c8\u3009 \u3008\u03c8| and \u03c6 = |\u03c6\u3009 \u3008\u03c6|, their trace distance is essentially\nT (\u03c8, \u03c6) = \u221a 1\u2212 (F (\u03c8, \u03c6))2.\nTherefore, any algorithm that computes the trace distance T (\u03c8, \u03c6) will immediately yield the fidelity F (\u03c8, \u03c6) = \u221a\n1\u2212 (T (\u03c8, \u03c6))2. As a result, estimating the trace distance is DQC1-hard even for pure quantum states.\nIt was shown in [FKM+18] that DQC1 is not (classically) weakly simulatable unless the polynomial hierarchy collapses to the second level, i.e., PH = AM. This, together with Theorem 4.8, means that there is unlikely an efficient classical algorithm that estimates the fidelity or trace distance."
        },
        {
            "heading": "Acknowledgements",
            "text": "We would like to thank Wang Fang, Kean Chen and Minbo Gao for helpful discussions."
        }
    ],
    "title": "New Quantum Algorithms for Computing Quantum Entropies and Distances",
    "year": 2022
}