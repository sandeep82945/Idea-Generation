{
    "abstractText": "We consider the Online Rent Minimization problem, where online jobs with release times, deadlines, and processing times must be scheduled on machines that can be rented for a fixed length period of T . The objective is to minimize the number of machine rents. This problem generalizes the Online Machine Minimization problem where machines can be rented for an infinite period, and both problems have an asymptotically optimal competitive ratio of O(log(pmax/pmin)) for general processing times, where pmax and pmin are the maximum and minimum processing times respectively. However, for small values of pmax/pmin, a better competitive ratio can be achieved by assuming unit-size jobs. Under this assumption, Devanur et al. (2014) gave an optimal e-competitive algorithm for Online Machine Minimization, and Chen and Zhang (2022) gave a (3e + 7) \u2248 15.16-competitive algorithm for Online Rent Minimization. In this paper, we significantly improve the competitive ratio of the Online Rent Minimization problem under unit size to 6, by using a clean oracle-based online algorithm framework.",
    "authors": [
        {
            "affiliations": [],
            "name": "Enze Sun"
        },
        {
            "affiliations": [],
            "name": "Zonghan Yang"
        },
        {
            "affiliations": [],
            "name": "Yuhao Zhang"
        }
    ],
    "id": "SP:fb323002955144d2795d1a931649df3ffa59f60f",
    "references": [
        {
            "authors": [
                "Eric Angel",
                "Evripidis Bampis",
                "Vincent Chau",
                "Vassilis Zissimopoulos"
            ],
            "title": "On the Complexity of Minimizing the Total Calibration Cost",
            "venue": "Frontiers in Algorithmics, Lecture Notes in Computer Science,",
            "year": 2017
        },
        {
            "authors": [
                "Nikhil Bansal",
                "Tracy Kimbrel",
                "Kirk Pruhs"
            ],
            "title": "Speed scaling to manage energy and temperature",
            "venue": "J. ACM,",
            "year": 2007
        },
        {
            "authors": [
                "Michael A. Bender",
                "David P. Bunde",
                "Vitus J. Leung",
                "Samuel McCauley",
                "Cynthia A. Phillips"
            ],
            "title": "Efficient scheduling to minimize calibrations",
            "venue": "In Proceedings of the twenty-fifth annual ACM symposium on Parallelism in algorithms and architectures,",
            "year": 2013
        },
        {
            "authors": [
                "Lin Chen",
                "Minming Li",
                "Guohui Lin",
                "Kai Wang"
            ],
            "title": "Approximation of Scheduling with Calibrations on Multiple Machines (Brief Announcement)",
            "venue": "In The 31st ACM Symposium on Parallelism in Algorithms and Architectures,",
            "year": 2019
        },
        {
            "authors": [
                "Zuzhi Chen",
                "Jialin Zhang"
            ],
            "title": "Online scheduling of time-critical tasks to minimize the number of calibrations",
            "venue": "Theoretical Computer Science,",
            "year": 2022
        },
        {
            "authors": [
                "J. Chuzhoy",
                "S. Guha",
                "S. Khanna",
                "J. Naor"
            ],
            "title": "Machine Minimization for Scheduling Jobs with Interval Constraints",
            "venue": "In 45th Annual IEEE Symposium on Foundations of Computer Science,",
            "year": 2004
        },
        {
            "authors": [
                "Mark Cieliebak",
                "Thomas Erlebach",
                "Fabian Hennecke",
                "Birgitta Weber",
                "Peter Widmayer"
            ],
            "title": "Scheduling with release times and deadlines on a minimum number of machines",
            "venue": "Exploring New Frontiers of Theoretical Informatics, IFIP 18th World Computer Congress, TC1 3rd International Conference on Theoretical Computer Science (TCS2004),",
            "year": 2004
        },
        {
            "authors": [
                "Nikhil Devanur",
                "Konstantin Makarychev",
                "Debmalya Panigrahi",
                "Grigory Yaroslavtsev"
            ],
            "title": "Online Algorithms for Machine Minimization",
            "venue": "[cs],",
            "year": 2014
        },
        {
            "authors": [
                "M.R. Garey",
                "David S. Johnson"
            ],
            "title": "Computers and Intractability: A Guide to the Theory of NP-Completeness",
            "year": 1979
        },
        {
            "authors": [
                "Mong-Jen Kao",
                "Jian-Jia Chen",
                "Ignaz Rutter",
                "andDorotheaWagner"
            ],
            "title": "Competitive design and analysis formachineminimizing job scheduling problem",
            "venue": "Algorithms and Computation - 23rd International Symposium, ISAAC 2012, Taipei, Taiwan, December 19-21,",
            "year": 2012
        },
        {
            "authors": [
                "Prabhakar Raghavan",
                "Clark D. Thompson"
            ],
            "title": "Randomized rounding: a technique for provably good algorithms and algorithmic proofs",
            "venue": "Comb., 7(4):365\u2013374,",
            "year": 1987
        },
        {
            "authors": [
                "Barna Saha"
            ],
            "title": "Renting a Cloud",
            "venue": "IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS 2013),",
            "year": 2013
        },
        {
            "authors": [
                "Guosong Yu",
                "Guochuan Zhang"
            ],
            "title": "Scheduling with a minimum number of machines",
            "venue": "Oper. Res. Lett.,",
            "year": 2009
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "Machine Minimization is a classical scheduling problem in combinatorial optimization. We are given n jobs with release time and deadline to schedule. Each job j has a length pj and must be assigned to a machine for pj units of time between its release time rj and its deadline dj . However, in many practical scenarios, such as cloud computing, we may not need to buy the machines but only rent them for a fixed period of time. This motivates the Rent Minimization problem, introduced by Saha [12]. In this problem, we are given a constant T , which represents the duration of a machine rent. The goal is to minimize the number of rents we make to process all jobs within their deadlines.\nAnother related formulation, inspired by nuclear weapon testing, is the Calibration problem, proposed by Bender et al. [3]. In this problem, we are givenmmachines and a set of jobs that must be completed feasibly. However, before using a machine, we need to calibrate it. Each calibration, similar to a rent, activates the machine for a time period of T . The goal is to minimize the number of calibrations to process all jobs on time. The main difference between the Calibration and the Rent Minimization problems is that the former restricts us to have at mostmmachines working in parallel at any given time, while the latter does not have such a constraint. Therefore, the Rent Minimization problem can be regarded as a special case of the Calibration problem when m =\u221e.\nOn the other hand, in the cloud rental scenario and many other practical applications, the computing requests usually increase over time and can be modeled as online released jobs. Therefore, we investigate the problem in an online setting. We do not have any prior knowledge about the jobs before their release time, and need to schedule jobs and rent machines online and irrevocably over time. The goal is to minimize the total number of rents for scheduling all jobs. Note that the online generalization is also studied in the Calibration problem by Chen and Zhang [5]. To ensure that online algorithms can schedule all jobs, they also assume m = \u221e in their model, which coincides with the Online Rent Minimization model.\n\u2217The University of Hong Kong. Email: sunenze@connect.hku.hk. \u2020Shanghai Jiao Tong University. Email: fstqwq@sjtu.edu.cn. \u2021Shanghai Jiao Tong University. Email: zhang_yuhao@sjtu.edu.cn.\nar X\niv :2\n30 6.\n17 24\n1v 1\n[ cs\n.D S]\n2 9\nJu n\n20 23\nWhy consider unit-size jobs? Saha [12] proposes anO(log (pmax/pmin))-competitive algorithm for theOnlineMachine Minimization problem. By paying a constant factor, it can be extended to an O(log (pmax/pmin))-competitive algorithm for the Online Rent Minimization problem. (pmax and pmin are the longest and shortest processing time among all jobs.), which was proved to be the best competitive ratio asymptotically. However, in many real-world applications, one company usually receives similar length requests, so the ratio between pmax and pmin may not be too large; and it is worthwhile to reduce the constant factor of the ratio when pmax/pmin is small. To this end, we focus on the special case of unit-size jobs (i.e., all pj = 1). Note that by partitioning jobs by their length into log(pmax/pmin) groups, the \u03b1-competitive unit-size algorithm can be extended to a roughly (3\u03b1 log (pmax/pmin))competitive algorithm in the general case.\nThe unit-size special case has also been considered in the Online Machine Minimization problem [5, 8, 10]. Devanur et al. [8] present an e-competitive algorithm for the Online Machine Minimization problem under unitsize jobs (though earlier work by Bansal et al. [2] implies the same result), and it is the optimal ratio among all deterministic algorithms. Current best lower bound of the online renting problem under unit-size jobs is also e since it is a generalized model. On the positive side, Chen and Zhang [5] study the online renting problem under unit-size jobs. They improve the implicit constant ratio by Saha [12] to 3e + 7 \u2248 15.16. In their algorithm, jobs are distinguished by whether they are long or short based on the length of their time window (i.e., dj \u2212 rj ) and are handled separately. Our paper significantly improves the competitive ratio to 6with a cleaner oracle-based algorithm without identifying whether jobs are short or long.\nTheorem 1. There exists an efficient 6-competitive algorithm for the online renting problems under unit-size jobs.\nOur techniques. In the work of Chen and Zhang [5], they rent machines for long and short jobs separately; as a result, their final competitive ratio is the sum of two cases, which makes the ratio large. The technical reason behind this result is that they use the e-competitive Online Machine Minimization algorithm by Devanur et al. [8] as a black box, which is only suitable for short jobs. (Roughly speaking, it is because we can view T =\u221ewhen jobs are short.) Therefore, they must use another approach to handle long jobs.\nIn our paper, we formalize and extend the OnlineMachineMinimization algorithm to an oracle-based framework, instead of using the algorithm as a black box. The oracle-based framework uses an offline algorithm to guide our online decision. Note that the OnlineMachineMinimization algorithm also uses an efficient offline optimal algorithm as an oracle. However, we do not know a polynomial offline RentMinimization algorithm for unit-size jobs. Themain algorithmic novelty is that we find an efficient substitute for the optimal algorithm to act as a bridge between online decisions and the optimal offline solution. The oracle is a kind of optimal augmentation algorithm. It is allowed to use a rent length of 3T , and the rent number is at most OPT with rent length T . It also satisfies some online monotone properties so that we can control the cost of the online algorithm. Finally, we prove that by following the offline oracle and paying a factor of 6 online, we can recover the same ability for scheduling jobs as the offline oracle. This concludes the competitive ratio of 6.\nExtension to the model with delay. Chen and Zhang [5] also raise a perspective that the operation rent (a.k.a. calibration in their paper) needs a non-negative time \u03bb to finish. We call it Online Rent Minimization with Delay. They propose an (3(e+ 1)\u03bb+ 3e+ 7) \u2248 (11.15\u03bb+15.16)-competitive algorithm. We use a black box reduction to extend the algorithm in Theorem 1 and improve the ratio to 6(\u03bb+ 1).\nTheorem 2. As a corollary of Theorem 1, there exists an efficient 6(\u03bb+ 1)-competitive algorithm when we need \u03bb time to finish each rent.\nOther related works. Offline Machine Minimization is a well-studied and classic model. Garey and Johnson [9] shows that it is NP-hard. On the algorithm side, Raghavan and Thompson [11] propose anO( lognlog logn )-approximation\nalgorithm. Later, the ratio has been improved toO( \u221a\nlogn log logn ) by Chuzhoy et al. [6]. Whether there exists a constant\napproximation ratio is still open. Moreover, several special cases are also discussed. Cieliebak et al. [7] focus on the case that each job\u2019s active time (dj \u2212 rj) is small. Yu and Zhang [13] achieve a ratio of 2 in the equal release time case and a ratio of 6 in the equal processing time case.\nScheduling to minimize the number of calibrations is proposed by Bender et al. [3]. The general case is NP-hard even for checking feasibility. Under unit-size jobs, Bender et al. give a 2-approximation algorithm; later, Chen et al. [4] give the first PTAS algorithm. However, it is worth noting that whether the unit-size special case is polynomially solvable is still open. Moreover, Angel et al. [1] introduce the concept of delay, which means that each calibration requires \u03bb time to finish. They study the delay setting on the one-machine special case of the offline calibration problem and show that it is polynomially solvable."
        },
        {
            "heading": "2 Preliminaries",
            "text": "We first define the models and introduce the basic notations.\nRent Minimization. We have a set of jobs J = {1, \u00b7 \u00b7 \u00b7 , n} and a fixed rent length T . For job j \u2208 J , it has a release time rj , a deadline dj , and a unit processing time pj = 1. Each job should be assigned to one active machine at an integer time unit [t, t + 1), where t is an integer such that rj \u2264 t \u2264 dj \u2212 1. We can rent a machine at any integer time point t. Then we will have an active machine during [t, t + T ). The objective is to minimize the number of machine rents to process all jobs in J .\nOnline Rent Minimization. In the online version, all jobs are released online, and they become visible at their release time. On the other hand, we need to make rent decisions and assign jobs online irrevocably. In particular, at an integer time point t, we have:\n\u2022 Jobs with release time equal to t become visible.\n\u2022 We can decide to rent a machine at t or any time after that.\n\u2022 We can schedule jobs on active machines during the time unit [t, t+ 1) irrevocably.\nNotations on Rent Set. We use a multiset I = {[s1, c1), [s2, c2), \u00b7 \u00b7 \u00b7 [si, ci), \u00b7 \u00b7 \u00b7 } to denote a set of rents, where the i-th rent interval starts at si and is active in [si, ci). Note that ci always equals si + T when the rent length is T ; however, we use the general notation for future reference.\nFocusing on the time unit [t, t+1), the number of active units AI(t) is defined as the number of active machines at time t, which means that we can schedule at most AI(t) jobs at time t. For a given rent set I , we have AI(t) = |{[si, ci) \u2208 I | t \u2208 [si, ci)}| . We also extend the notation for intervals, such that AI(r\u2217, d\u2217) = \u2211d\u2217\u22121 t=r\u2217 AI(t) is the number of active units during the time interval [r\u2217, d\u2217).\nFeasibility of Rent Set. We call a rent set I feasible for J , if we can schedule all jobs in J on I . We introduce a lemma based on Hall\u2019s Theorem to check whether I is feasible.\nFor a given jobs set J , we define J(r\u2217, d\u2217) = {j \u2208 J |r\u2217 \u2264 rj < dj \u2264 d\u2217} to represent the jobs that must be assigned inside the interval [r\u2217, d\u2217).\nLemma 3 (Feasibility). I is feasible for J iff. \u2200r\u2217 \u2264 d\u2217 \u2208 N, AI(r\u2217, d\u2217) \u2265 |J(r\u2217, d\u2217)| .\nProof. For any fixed r\u2217 and d\u2217, the sum of active units provided by I isAI(r\u2217, d\u2217). Each job released and due between this periodmust be scheduled on these time slots. If there exists a pair of r\u2217 and d\u2217 such thatAI(r\u2217, d\u2217) < |J(r\u2217, d\u2217)|, there is no feasible assignment because of the pigeonhole principle. On the other hand, if the inequality holds for all r\u2217 and d\u2217, we can view it as a bipartite matching between jobs and active units. There is a feasible assignment by Hall\u2019s Theorem.\nAn Efficient Checker and Scheduler: Earliest Deadline First (EDF). Earliest Deadline First is a greedy algorithm that can find a feasible assignment for J on I if and only if I is feasible for J . When we call EDF(J, I), we scan time units from early to late, and assign the released job with the earliest deadline to a free active machine at the current time unit. If a job with deadline d cannot find a free active machine at the time unit [d \u2212 1, d), EDF(J, I) fails, and we call d the fail time of EDF(J, I). Otherwise, EDF(J, I) succeeds. Bender et al. [3] has already proved that EDF can check the feasibility. It is also worth noting that EDF can be efficiently implemented in O(n log n) by using a heap, instead of going through all integer time points directly.\nLemma 4 ([3]). EDF(J, I) succeeds, i.e., it can find a feasible schedule for J on I , if and only if I is feasible for J .\nUsing EDF online. Note that we only make comparisons between released jobs. Therefore, the EDF algorithm can be simulated online : we only need to find a feasible rent set I , and then EDF can automatically find a feasible assignment online."
        },
        {
            "heading": "3 Oracle-based Online Algorithm Framework",
            "text": "Moving towards online algorithms, one natural way is to use an offline algorithm as an oracle to suggest the actions of online algorithms. We keep track of this offline algorithm and make corresponding online decisions when the offline algorithm changes along with the online jobs release. Whenever the offline algorithm increases by one at the moment t because of the change of the job set, the online algorithm performs one Batch-Rent at this time t, which is a fixed rent scheme that contains \u0393machines. Intuitively, we use these \u0393machines to catch up with the one increment of the offline oracle. It is worth noting that the e-competitive algorithm for Online Machine Minimization follows this approach [8].\nIn our case, compared to Machine Minimization, we have two main differences in our oracle-based framework. The first difference is the job set we input to the oracle. Because of the online fashion, the most natural way is to input the set of all released jobs to the oracle. In Machine Minimization, it works because T = \u221e and earlier rents are always more powerful; however, this is not true in Rent Minimization. Indeed, too early rents may cause trouble in Rent Minimization. Intuitively, we are only allowed to make online rent when the offline oracle reports an increment if we want to bound the competitive ratio in the framework. Consider the case where T = 10 and two jobs will be due at 100with release time 0 and 90. If we report the first job to the offline oracle at 0, the offline oracle will return one new rent interval. Following the oracle-based framework, we will make \u0393 online rent intervals at 0. However, we still need to make more rent intervals at 90, while the offline oracle may not increase. To this end, we use the job set Jt as the job set we input to the oracle at time t. A job j is in Jt if it satisfies the following two properties:\n1) It is visible at t, i.e., rj \u2264 t.\n2) It is emergent at (or before) t, i.e., dj \u2264 t+ T .\nAnother difference is an augmentation factor \u03b1. The oracle is allowed to have \u03b1T active time for each rent. Since the existence of a polynomial time optimal offline algorithm for RentMinimization is still unknown, this factor allows us to find an efficient substitute. We use Oracle\u03b1(J, T ) (instead of Oracle(J, \u03b1T ), since the target rent length is still T ) to denote an oracle with augmentation factor \u03b1. The framework is formalized in Algorithm 1.\nAlgorithm 1 Oracle-based Online Algorithm Framework procedure OracleBasedOnline(t: time, J : known jobs, T : length of rent)\n\u2206t = |Oracle\u03b1(Jt, T )| \u2212 |Oracle\u03b1(Jt\u22121, T )| \u25b7 \u03b1 is a positive integer Perform \u2206t(if \u2206t > 0) Batch-Rent operations at t, consisting of \u0393 machines that start at or after t. schedule jobs at t following EDF(J, I), where I is the current online rent set.\nend procedure\nThen, we discuss how this framework helps us control the number of rents made by the online algorithm. First, as a substitute for the optimal offline algorithm, Oracle\u03b1 needs to maintain some properties similar to those of the\noptimal offline algorithm. Second, Batch-Rent should support the online algorithm to be as powerful as the offline oracle in scheduling all released jobs. We integrate and formalize these messages in the following lemma.\nLemma 5. Let OPT(J, T ) be the number of rents used by the optimal offline algorithm to schedule the job set J , Algorithm 1 is \u0393-competitive if these three properties are guaranteed:\n1) For any job set J , |Oracle\u03b1(J, T )| \u2264 OPT(J, T );\n2) The offline oracle is online monotone: |Oracle\u03b1(Jt1 , T )| \u2264 |Oracle\u03b1(Jt2 , T )| if t1 \u2264 t2;\n3) Algorithm 1 is feasible for scheduling all online released jobs. Proof. The online algorithm makes \u2211\n\u2206t>0 \u2206t rent batches, which is exactly |Oracle\u03b1(J , T )| by property 2) and is\nnot greater than |OPT(J , T )| by property 1). Also, the output satisfies the feasibility requirement by property 3). Therefore, Algorithm 1 is \u0393-competitive.\nThe e-competitive algorithm for Online Machine Minimization. We can use the framework to understand the e-competitive Online Machine Minimization algorithm.\n\u2022 Oracle is the optimal offline algorithm, and we set \u03b1 = 1. The monotonicity directly comes from optimality.\n\u2022 Jt is the set of visible jobs at t because all jobs are emergent.\n\u2022 Each Batch-Rent contains e new machines in average; for simplicity, we omit any rounding issues related to e.\nChoice of the oracle. Recall that we do not have an efficient optimal algorithm for Rent Minimization currently. It remains to find a suitable substitute that also uses a small number of rents (property 1). One candidate algorithmmay be the Lazy-Binning algorithm by Bender et al. [3], which requires an augmentation factor of 2 to satisfy property 1). However, Lazy-Binning algorithm, as well as other relatively simple 2 approximation algorithms we come up with, cannot guarantee monotonicity. This will make us fail to bound the competitive ratio of the online algorithm. In the next section, we introduce our oracle with an augmentation factor of 3, called the semi-online algorithm, which provides all the properties we need in Lemma 5."
        },
        {
            "heading": "4 The Semi-Online Algorithm",
            "text": "In this section, we introduce the semi-online algorithm shown as Algorithm 2, which uses an augmentation factor of 3 and acts as the Oracle3 in our framework.\nAlgorithm 2 The Semi-Online Algorithm procedure SemiOnline(J : input job set, T : length of rent)\nJ \u2032, I \u2190 \u2205 \u25b7 I is a multiset for rents. \u03c4j = max{rj , dj \u2212 T} for all j. for j \u2208 J in non-decreasing order of \u03c4j do\nJ \u2032 \u2190 J \u2032 \u222a {j} if EDF(J \u2032, I) fails then\nI \u2190 I \u222a {[\u03c4j \u2212 T, \u03c4j + 2T )} \u25b7 A rent that starts at \u03c4j \u2212 T with length 3T . end if\nend for return I\nend procedure\nWe call Algorithm 2 semi-online, because the enumerating order is exactly the same as how Jt increases in the oracle-based framework. Thus, if we have some new jobs with rj = t or dj\u2212T = twhen the online timemoves from\nt \u2212 1 to t, the only possible difference between SemiOnline(Jt\u22121, T ) and SemiOnline(Jt, T ) is some rent intervals of [t\u2212 T, t+ 2T ). This observation could be formalized into the following properties of the semi-online algorithm.\nLemma 6 (Strong Monotonicity). We have the following two properties for Algorithm 2.\n1. For any Jt1 and Jt2 where t1 \u2264 t2, we have SemiOnline(Jt1 , T ) \u2286 SemiOnline(Jt2 , T ).\n2. SemiOnline(Jt, T ) \\ SemiOnline(Jt\u22121, T ) is a multiset of a fixed rent interval [t\u2212 T, t+ 2T ).\nProof. Intuitively, the reason behind the lemma is that the order of \u03c4j is the same as the order in which we insert jobs into Jt as t increases. Formally speaking, compare Jt1 and Jt2 and consider a job j \u2208 Jt2 \\ Jt1 . By definition, we have that \u03c4j \u2265 max\nj\u2032\u2208Jt1 \u03c4j\u2032 . Therefore, Algorithm 2 first enumerates the jobs in Jt1 and then the jobs in Jt2 \\ Jt1 ,\nwhich concludes the first property immediately. For the second property, the reason is that Jt \\ Jt\u22121 is a set of jobs with rj = t or dj \u2212T = t. In other words, we enumerate them after jobs in Jt\u22121. Thus, if I continues to grow when we enumerate them, the new interval must be [t\u2212 T, t+ 2T ).\nThe strong monotonicity in Lemma 6 suffices to show the weak monotonicity in property 2) of Lemma 5. On the other hand, these two properties are also used in the proof of property 3) later. It remains to prove property 1) by bounding the cardinality of the semi-online algorithm\u2019s solution.\nLemma 7. |SemiOnline(J, T )| \u2264 OPT(J, T ), and SemiOnline(J, T ) is feasible for J .\nBefore proving Lemma 7, we introduce coOPT so that we can better understand the solution structure.\nDefinition 8 (Optimal complement solution). For a job set J , rent length T , and a given rent set I (which may not be length T ), the optimal complement solution of I , denoted as coOPT(I), is defined as a rent set of length T with minimum cardinality such that I \u222a coOPT(I) is feasible for J .\nFact 9. coOPT(\u2205) = OPT, coOPT(OPT) = \u2205.\nConsider a rent set I that is infeasible for J . Below, we state the main property of coOPT.\nLemma 10. Let d be the fail time of EDF(J, I). There exists a coOPT(I) such that there is a rent interval [s, s+ T ) \u2208 coOPT(I) that satisfies: d\u2212 T \u2264 s < d.\nProof. We use coOPT as a shorthand for coOPT(I) in this proof. Let [s, s+ T ) be the earliest interval in coOPT. First, we show that s < d. Suppose, for a contradiction, that s \u2265 d. Let j be the job that fails in EDF(J, I), where J is a fixed given job set. Then, j has no more active units in coOPT, since all rent intervals start at or after d. But this contradicts the definition of coOPT, which is a feasible rent set for J .\nSecond, we show that s \u2265 d\u2212 T can be true. If this is not true, we construct a new rent set coOPT\u2032 = coOPT \\ {[s, s+ T )} \u222a {[d\u2212 T, d)} . That is, we replace the rent interval at s with another one at d \u2212 T . We claim that coOPT\u2032 \u222a I is also feasible for J . This means that coOPT\u2032 is also a feasible coOPT, and [s\u2032 = d\u2212 T, T ) is a feasible rent interval that satisfies our desired condition.\nTo prove our claim, we fix an arbitrary choice of r\u2217 \u2264 d\u2217 \u2208 N, and we verify the condition in Lemma 3, i.e., AI\u222acoOPT\u2032(r\n\u2217, d\u2217) \u2265 |J(r\u2217, d\u2217)|. We consider two cases:\n\u2022 Case 1: d\u2217 < d. If the condition does not hold, we have AI(r\u2217, d\u2217) \u2264 AI\u222acoOPT\u2032(r\u2217, d\u2217) < J \u2032(r\u2217, d\u2217), which means that EDF(I, J \u2032) must fail no later than d\u2217 since the active units are not enough beforehand. This contradicts the definition of d.\n\u2022 Case 2: d\u2217 \u2265 d. The only difference between coOPT and coOPT\u2032 is the contribution of active units by [s, s+T ) and [d\u2212T, d). We prove that [d\u2212T, d)must provide at least as many active units as [s, s+T ) does. Referring to Figure 1, we see that [d\u2212T, d) has more active units than [s, s+T ) in [s+T, d), and vice versa in [s, d\u2212T ). Since d\u2217 \u2265 d, we need r\u2217 \u2264 d \u2212 T to reach the advantage area of coOPT; however, [r\u2217, d\u2217) then covers the whole part of [d\u2212 T, d). This implies that the total contribution of coOPT never exceeds that of coOPT\u2032.\nThe discussion concludes the claim.\nLemma 11. At the end of each iteration of j, I is feasible for J \u2032.\nProof. We prove it by induction. In the base case, I is feasible for J \u2032 when they are \u2205. Then, assume the lemma is true after the (j \u2212 1)-th iteration. At the j-th iteration, we add a job j to J \u2032. This means that \u2200r\u2217 \u2264 rj , d\u2217 \u2265 dj , |J \u2032(r\u2217, d\u2217)|will increase by one. If EDF(J \u2032, I) is already feasible, we are done. Otherwise, the algorithm will employ a new 3T length rent interval [\u03c4j \u2212 T, \u03c4j + 2T ). Notice that d\u2217 \u2265 dj \u2265 \u03c4j . Every AI(r\u2217, d\u2217) also increases by at least one. Thus, we still have AI(r\u2217, d\u2217) \u2265 |J \u2032(r\u2217, d\u2217)| after we employ [\u03c4j \u2212 T, \u03c4j + 2T ) (at the end of the j-th iteration).\nCorollary 12. SemiOnline(J, T ) is feasible for J .\nLemma 13. In the j-th iteration, if EDF(J \u2032, I) is infeasible in Algorithm 2, before we rent [t\u2212 T, t+ 2T ), we have\n|coOPT(I \u222a {[t\u2212 T, t+ 2T )})| \u2264 |coOPT(I)| \u2212 1.\nProof. By the condition of the lemma and Lemma 11, we have EDF(J \u2032, I) is infeasible while EDF(J \u2032 \\ {j}, I) is feasible. By the enumerating order, all the jobs j\u2032 in J \u2032 must satisfy max{rj , dj\u2032 \u2212 T} \u2264 \u03c4j . Therefore, EDF(J \u2032, I) must fail at a deadline d \u2264 \u03c4j + T . On the other hand, for all j\u2032 \u2208 J such that dj\u2032 < \u03c4j , we must have j\u2032 \u2208 J \u2032 \\ {j}, also because of the enumerating order. Thus, we can show that d \u2265 \u03c4j . Otherwise, J \u2032 \\ {j} would be infeasible for I , which is a contradiction. In conclusion, we show that the failure time d of EDF(J \u2032, I) satisfies \u03c4j \u2264 d < \u03c4j + T.\nFinally, by Lemma 10, there exists a coOPT with rent interval [s, s+ T ] such that d\u2212 T \u2264 s < d. It implies that \u03c4j \u2212 T < s < \u03c4j + T . Therefore [s, s+ T ) is always a subset of [\u03c4j \u2212 T, \u03c4j + 2T ). We have\n|coOPT(I \u222a {[t\u2212 T, t+ 2T )})| \u2264 |coOPT(I \u222a {s})| = |coOPT(I)| \u2212 1.\nProof of Lemma 7. Recall Fact 9 that coOPT(\u2205) = OPT. It follows that SemiOnline rents at most OPT times as a corollary of Lemma 13."
        },
        {
            "heading": "5 The 6-competitive Online Algorithm",
            "text": "It remains to define the rent scheme for each Batch-Rent in the framework. For completeness, we formally describe the algorithm in Algorithm 3.\nAlgorithm 3 The Online algorithm procedure OnlineRent(t: time, J : known jobs, T : length of rent)\n\u2206 = |SemiOnline(Jt, T )| \u2212 |SemiOnline(Jt\u22121, T )| Perform \u2206 Batch-Rent at time t, each consists of 6 machines: 4 at t and 2 at t+ T . schedule jobs at t following EDF(J, I), where I is the current online rent set.\nend procedure\nNext, we prove the property 3) of Lemma 5 by our design of Batch-Rent, i.e., to show Algorithm 3 is feasible for the total job set J . Combining with the property 1) and 2) by the semi-online algorithm, we can conclude our online algorithm is 6-compeititve as claimed in Theorem 1.\nFirst, we introduce an obvious relationship between online and semi-online algorithms.\nFact 14. At every moment t, there always exists a bijection from one semi-online rent batch to one online rent batch, such that both batches are at the same time: 4\u00d7 [t, t+T )+2\u00d7 [t+T, t+2T ) in Online 7\u2192 [t\u2212T, t+2T ) in SemiOnline.\nProof. This fact is directly implied by the second property of Lemma 6. Whenever SemiOnline(Jt, T ) increases from SemiOnline(Jt\u22121, T ) by some rent intervals of [t\u2212T, t+2T ), the new batchesmust be 4\u00d7[t, t+T )+2\u00d7[t+T, t+2T ). Each of them can correspond to one [t\u2212 T, t+ 2T ).\nWe prove the feasibility by showing that the active units provided by the online algorithm are always enough for the possible jobs inside any possible interval [r\u2217, d\u2217).\nLemma 15. Let I be the rent sets made by our algorithm. We have \u2200r\u2217 \u2264 d\u2217 \u2208 N, A(r\u2217, d\u2217) \u2265 |J (r\u2217, d\u2217)|, where we use A to denote AI for simplicity.\nWe remark that Lemma 15 provides the necessary information to prove the correctness via the feasibility lemma (Lemma 3). It only remains to complete the proof of Lemma 15."
        },
        {
            "heading": "5.1 Proof of Lemma 15",
            "text": "Let us fix an arbitrary range r\u2217 \u2264 d\u2217, and discussA(r\u2217, d\u2217) and J (r\u2217, d\u2217) separately. First, we discussA(r\u2217, d\u2217). The behavior of the online algorithm can be represented by a set of online rent batches. Note that only those rent batches that start in (r\u2217 \u2212 2T, d\u2217) can provide active units inside [r\u2217, d\u2217). Therefore, we only discuss a subset B of all rent batches with a start time in (r\u2217 \u2212 2T, d\u2217). Each b means a Batch-Rent made by Algorithm 3. We use t(b) to mean its decision time. That is, a batch b contains 4 rent intervals of [t(b), t(b) + T ), and 2 of [t(b) + T, t(b) + 2T ).\nWe partition the time interval [r\u2217, d\u2217) by several critical time points. The first time point is \u03b81 = max {( r\u2217+d\u2217\n2\n) , d\u2217 \u2212 T } .\nIt means that \u03b81 = d\u2217 \u2212 T when d\u2217 \u2212 r\u2217 \u2265 2T and \u03b81 = ( r\u2217+d\u2217\n2\n) when d\u2217 \u2212 r\u2217 < 2T . Remark that in both cases,\n\u03b81 \u2265 d\u2217 \u2212 T . Then we recursively define \u03b8i+1 = ( \u03b8i+d \u2217\n2\n) for every i \u2265 1 until \u230a\u03b8i\u230b = d\u2217 \u2212 1. Besides, we let\n\u03b80 = r \u2217\u22121. For i \u2265 1, we call [\u230a\u03b8i\u22121\u230b+ 1, \u230a\u03b8i\u230b] the i-th sub-interval, which is the minimal sub-interval of (\u03b8i\u22121, \u03b8i] that contains all integers in it. We defineBi \u2286 B as the set of rent batches starting in the i-th sub-interval. Moreover, we let B0 be the set of rent batches starting in (r\u2217 \u2212 2T, r\u2217].\nFor each b \u2208 B, recall that t(b) is the time it was allocated, and we let \u03bbi(b) be the length of the intersecting interval of [t(b), t(b)+2T ) and [\u230a\u03b8i\u22121\u230b+ 1, d\u2217). Note that \u03bb1(b) represents the intersecting interval with the whole [r\u2217, d\u2217). Let L = min{2T, d\u2217 \u2212 r\u2217} = 2(d\u2217 \u2212 \u03b81) denote the maximum possible length in \u03bb1, and by our partition method. It follows the property of the length of sub-intervals by our partition.\nLemma 16 (Partition length property). For any batch b \u2208 Bi where i \u2265 1, the intersection of [t(b), t(b) + 2T ) and [\u230a\u03b8i\u22121\u230b+ 1, d\u2217) satisfies: 2\u2212i \u00b7 L \u2264 \u03bbi(b) \u2264 21\u2212i \u00b7 L.\nProof. For i = 1, \u03bb1(b) = min{2T, d\u2217 \u2212 t(b)}. By definition, r\u2217 \u2264 t(b) \u2264 \u230a\u03b81\u230b, hence\nL/2 = min{T, d\u2217 \u2212 \u03b81} \u2264 min{2T, d\u2217 \u2212 t(b)} \u2264 min{2T, d\u2217 \u2212 r\u2217} = L.\nFor i \u2265 2, by definition d\u2217 \u2212 \u03b8i = 2\u2212i \u00b7 L. Because t(b) \u2208 [\u230a\u03b8i\u22121\u230b+ 1, \u230a\u03b8i\u230b] \u2286 (\u03b8i\u22121, \u03b8i], we have 2\u2212i \u00b7 L \u2264 \u03bbi(b) \u2264 min{2T, 21\u2212i \u00b7 L}. Since 2 \u00b7 L \u2264 2T , we conclude the lemma.\nThen, we present the lemmas for a lower bound of active units and an upper bound of job numbers.\nLemma 17 (Lower bound of active units). A(r\u2217, d\u2217) \u2265 \u2211 b\u2208B0 (2\u03bb1(b) + 2max{\u03bb1(b)\u2212 T, 0})\n+ \u2211 b\u2208B1 (2\u03bb1(b) + 2min{\u03bb1(b), T})\n+ \u2211 i\u22652 4 \u00b7 (2\u2212i \u00b7 L) \u00b7 |Bi|.\nProof. Three terms on the RHS of the inequality are counting of B0, B1 and B\u22652, where the first two are straightforward counting as shown in Figure 2, and the last term was scaled down a bit by Lemma 16:\n4 \u2211 i\u22652 \u2211 b\u2208Bi \u03bb1(b) = 4 \u2211 i\u22652 \u2211 b\u2208Bi \u03bbi(b) \u2265 \u2211 i\u22652 4 \u00b7 (2\u2212i \u00b7 L) \u00b7 |Bi|.\nLet Ji be the job set with deadline at most d\u2217 and released in the i-th subinterval:\nJi = {j \u2208 J | \u230a\u03b8i\u22121\u230b+ 1 \u2264 rj \u2264 \u230a\u03b8i\u230b, dj \u2264 d\u2217} .\nWe provide an upper bound of Ji by the performance of our algorithm.\nLemma 18. Let It be the semi-online batches allocated at or before time t. We have that Ji is no more than the active units after \u230a\u03b8i\u22121\u230b+ 1 provided by SemiOnline at \u230a\u03b8i\u230b. i.e.,\nJi \u2264 AI\u230a\u03b8i\u230b(\u230a\u03b8i\u22121\u230b+ 1, d \u2217).\nProof. Let us observe the time point t = \u230a\u03b8i\u230b. SemiOnline(Jt, T ) reports It at this time. By Lemma 11, It is feasible for Jt. By the definition of \u03b8i, we prove t \u2265 d\u2217 \u2212 T because \u03b81 \u2265 d\u2217 \u2212 T . Thus, all jobs with deadlines at most d\u2217 are already in Jt, and combining with the feasibility of It, we have:\nJi = Jt(\u230a\u03b8i\u22121\u230b+ 1, d\u2217) \u2264 At(\u230a\u03b8i\u22121\u230b+ 1, d\u2217).\nThe lemma then concludes because we define t = \u230a\u03b8i\u230b.\nLemma 19 (Upper bound of job numbers). We have two different upper bounds for Ji:\n\u2022 i = 1: |J1| \u2264 \u2211 b\u2208B0 \u03bb1(b) + \u2211 b\u2208B1 (\u03bb1(b) + L/2) . \u2022 i \u2265 2: |Ji| \u2264 \u2211 b\u2208B0 \u03bbi(b) + 2 \u00b7 (2\u2212i \u00b7 L) \u00b7 i\u2211 j=1 |Bj |.\nProof. In this proof, we apply Lemma 18 and count the number of active units after \u03b8i\u22121 by I\u230a\u03b8i\u230b. Note that by Fact 14, each 3T length rent interval in I\u230a\u03b8i\u230b corresponds to an online Batch-Rent.\nFirst, let us consider the case i = 1. I\u230a\u03b8i\u230b corresponds to the online batches with t(b) \u2264 I\u230a\u03b8i\u230b. Note that the ending time of b and its corresponding semi-online rent interval are both t(b) + 2T . Thus, AI\u230a\u03b8i\u230b(\u230a\u03b8i\u22121\u230b + 1, d\n\u2217) corresponds to B0 and B1.\nFor i = 1, we keep the B0 straightforward and calculate the upper bound of active units provided by the corresponding semi-online batch for each batch b in B1. Note that the semi-online rent set spans [t(b) \u2212 T, t(b) + 2T ). We split the 3T interval into first T and last 2T : the latter could be upper bounded by \u03bb1(b) using Lemma 16, and we could find that the former is at most L/2:\n\u2022 When d\u2217 \u2212 r\u2217 < 2T , t(b)\u2212 r\u2217 < (d\u2217 \u2212 r\u2217)/2, then min {T, t(b)\u2212 r\u2217} < L/2.\n\u2022 When d\u2217 \u2212 r\u2217 \u2265 2T , L = 2T , and thenmin {T, t(b)\u2212 r\u2217} \u2264 T = L/2.\nSo we can conclude that |J1| \u2264 \u2211 b\u2208B0 \u03bb1(b) + \u2211 b\u2208B1 (\u03bb1(b) + L/2) .\nFor the case i \u2265 2, all jobs released in sub-interval i can be allocated at most [\u03b8i\u22121 + 1, d\u2217), and by Lemma 16 each semi-online batch covers at most 2 \u00b7(2\u2212i \u00b7L). Like i = 1, the inequality follows direct counting on \u222aij=0Bj .\nThus far, we are ready to prove Lemma 15 by a charging argument.\nProof of Lemma 15. Recall that in Lemma 17 we have\nA(r\u2217, d\u2217) \u2265 \u2211 b\u2208B0 (2max{\u03bb1(b)\u2212 T, 0}+ 2\u03bb1(b)) + \u2211 b\u2208B1 (2\u03bb1(b) + 2min{T, \u03bb1(b)})\n+ \u2211 i\u22652 4 \u00b7 (2\u2212i \u00b7 L) \u00b7 |Bi|. (1)\nAlso, by Lemma 19,\nJ (r\u2217, d\u2217) \u2264 \u2211 b\u2208B0 \u03bb1(b) + \u2211 b\u2208B1 (\u03bb1(b) + L/2) + \u2211 i\u22652 \u2211 b\u2208B0 \u03bbi(b) + 2 \u00b7 (2\u2212i \u00b7 L) \u00b7 i\u2211 j=1 |Bj |  . (2) Using these two inequalities, we charge the upper bound of J (r\u2217, d\u2217) and the lower bound of A(r\u2217, d\u2217) to each b \u2208 B. We prove that for each b, the charged amount of J (r\u2217, d\u2217)\u2019s upper bound is at mostA(r\u2217, d\u2217)\u2019s lower bound. First, for b \u2208 B0, the contribution of b to the lower bound ofA(r\u2217, d\u2217) (i.e., RHS of Equation (1)) is: 2max{\u03bb1(b)\u2212\nT, 0}+2\u03bb1(b). The contribution to the upper bound of J (r\u2217, d\u2217) (i.e., RHS of Equation (2)) is: \u03bb1(b) + \u2211 i\u22652 \u03bbi(b). Note that b \u2208 B0 only contributes to a prefix of [r, d), it is easy to see that \u03bbi(b) \u2264 21\u2212i\u03bb1(b), and thus\n\u03bb1(b) + \u2211 i\u22652 \u03bbi(b) \u2264 \u03bb1(b) + \u2211 i\u22652 21\u2212i\u03bb1(b) < 2\u03bb1(b).\nWe are done for b \u2208 B0.\nSecond, for b \u2208 B1, the contribution of b to the lower bound of A(r\u2217, d\u2217) (i.e., RHS of Equation (1)) is: 2\u03bb1(b) + 2min{T, \u03bb1(b)}. The contribution to the upper bound of J (r\u2217, d\u2217) (i.e., RHS of Equation (2)) is: \u03bb1(b) + L/2 +\u2211\ni\u22652 2 \u00b7 (2\u2212i \u00b7 L). Then, we have\n\u03bb1(b) + L/2 + \u2211 i\u22652 2 \u00b7 (2\u2212i \u00b7 L) < \u03bb1(b) + L/2 + 2 \u00b7 ( 2\u22121 \u00b7 L ) \u2264 \u03bb1(b) + L/2 + 2 \u00b7min {T, \u03bb1(b)} \u2264 2\u03bb1(b) + 2min{T, \u03bb1(b)}.\nThe last inequality holds by Lemma 16. Therefore, we are done for b \u2208 B1. Finally, for b \u2208 Bi\u22652, the contribution of b to the lower bound ofA(r\u2217, d\u2217) (i.e., RHS of Equation (1)) is: 4\u00b7(2\u2212i\u00b7L).\nThe contribution to the upper bound of J (r\u2217, d\u2217) (i.e., RHS of Equation (2)) is: \u2211\ni\u2032\u2265i 2 \u00b7 (2\u2212i \u2032 \u00b7 L). We are done because \u2211\ni\u2032\u2265i 2 \u2212i\u2032 < 21\u2212i. Summing up three parts, we have proved that A(r\u2217, d\u2217) \u2265 J (r\u2217, d\u2217)."
        },
        {
            "heading": "5.2 A Remark on Running Time.",
            "text": "We only need to recalculate SemiOnline if the job set gets updated, and the procedure of reconstructing the rent set in SemiOnline can be maintained incrementally. Thus, it is possible to implement the algorithm calling EDF at most n + OPT \u2264 2n times, and hence achieve a worst case guarantee of O(n2 log n). Also, note that a job can influence the calculation of SemiOnline for at most O(T ) time units, so the SemiOnline can also update in O(nw logw) if there are at most O(w) jobs within any interval of length O(T ). Therefore, the online algorithm is efficient in terms of worst case guarantee and also average online updating."
        },
        {
            "heading": "6 Online Rent Minimization with Delay",
            "text": "In the version with delay, we are also given an online released job set J and a rent length T . We aim to minimize the number of rents needed to process all jobs. The notations are the same as in the Online Rent Minimization problem. Moreover, we are given a nonnegative integer \u03bb as the delay parameter. It means that if we rent a machine at time t, we will have an active machine at [t + \u03bb, t + \u03bb + T ). Note that it is impossible to serve an unknown emergency job with dj \u2212 rj \u2264 \u03bb online; following Chen and Zhang [5], we require that the active time dj \u2212 rj is at least \u03bb+ 1.\nWe use the following reduction lemma and our 6-competitive no-delay algorithm as a black box to prove Theorem 2. Chen and Zhang [5] also mention this approach.\nLemma 20 (Reduction). If ALG(J ) \u2264 \u0393 \u00b7OPT(J ) for every job set J , we have an algorithm ALG\u03bb that guarantees\nALG\u03bb(J , \u03bb) \u2264 \u0393 \u00b7 (\u03bb+ 1) \u00b7OPT(J ),\nif \u2200j \u2208 J , dj \u2212 rj \u2265 \u03bb+ 1.\nConstruction ofJ\u03bb=0 andALG\u03bb. J\u03bb=0 is amodified job set byJ . For any job j inJ , we construct a corresponding j\u2032 in J\u03bb=0 such that rj\u2032 = rj and dj\u2032 = dj \u2212 \u03bb. Then, we construct ALG\u03bb. At any time t, ALG\u03bb(J ) will make the rent decision as the decisions of ALG(J\u03bb=0) made at t. That is, if there is a rent interval [t, t + T ) in ALG(J\u03bb=0), we will have a rent interval [t+ \u03bb, t+ T + \u03bb) in ALG\u03bb(J ). Because we do not change the releasing time, ALG\u03bb is also an online algorithm. Clearly, the cost of ALG\u03bb(J ) is the same as that of ALG(J\u03bb=0).\nLemma 21. ALG\u03bb(J , \u03bb) \u2264 \u0393(\u03bb+ 1) \u00b7OPT(J ).\nProof. We have ALG\u03bb(J , \u03bb) = ALG(J\u03bb=0) by the construction. Then, let us refer to the lemma for OPT in Chen and Zhang [5]:\nLemma 22 ([5]). OPT(J\u03bb=0) \u2264 (\u03bb+ 1) \u00b7OPT(J ).\nBy Lemma 22, ALG\u03bb(J , \u03bb) = ALG(J\u03bb=0) \u2264 \u0393 \u00b7OPT(J\u03bb=0) \u2264 \u0393(\u03bb+ 1) \u00b7OPT(J ).\nLemma 23. ALG\u03bb(J ) is feasible to process all jobs in J .\nProof. We apply Lemma 3 to prove the feasibility. Let I be the rent set of ALG(J\u03bb=0). Given that ALG(J\u03bb=0) is feasible, we know that \u2200r\u2217 < d\u2217, J\u03bb=0(r\u2217, d\u2217) \u2264 AI(r\u2217, d\u2217). Next, we consider ALG\u03bb(J ) and let its rent set be I \u2032. \u2200r\u2217 < d\u2217 such that d\u2217 \u2212 r\u2217 \u2264 \u03bb, J (r\u2217, d\u2217) = 0 by definition. For those d\u2217 \u2212 r\u2217 \u2265 \u03bb+ 1,\nJ (r\u2217, d\u2217) = J\u03bb=0(r\u2217, d\u2217 \u2212 \u03bb) \u2264 AI(r\u2217, d\u2217 \u2212 \u03bb).\nBy definition, the active unit in AI(r\u2217, d\u2217 \u2212 \u03bb) will be postponed to AI\u2032(r\u2217 + \u03bb, d\u2217). Thus, we have\nJ (r\u2217, d\u2217) \u2264 AI(r\u2217, d\u2217 \u2212 \u03bb) = AI\u2032(r\u2217 + \u03bb, d\u2217) \u2264 AI\u2032(r\u2217, d\u2217).\nTherefore, we can use Lemma 3 to show the feasibility of I \u2032 in both cases.\nWe now can conclude the correctness of Lemma 20 from Lemma 21 and Lemma 23, Theorem 2 also follows directly.\nTheorem 2. As a corollary of Theorem 1, there exists an efficient 6(\u03bb+ 1)-competitive algorithm when we need \u03bb time to finish each rent."
        },
        {
            "heading": "7 Conclusion and Future Work",
            "text": "In conclusion, our main contribution is a 6-competitive algorithm for the Online Rent Minimization problem under unit-size jobs, which follows the oracle-based framework. Since the Online Rent Minimization problem is a generalization of the Online Machine Minimization problem, where we have an optimal e-competitive algorithm, one major question is: Is the Rent Minimization problem strictly harder than the Machine Minimization problem?\nOn the other hand, we are also interested in the power of oracle-based algorithms. Note that the optimal ecompetitive algorithm for Machine Minimization follows the oracle-based framework. It is interesting to ask: What is the best competitive ratio we can achieve for the Online Rent Minimization problem by using the oracle-based framework? The Semi-Online captures our current understanding of the possible range of optimal solutions, so replacing it with an optimal oracle cannot improve ratio directly by the same argument in the paper. Is it possible to obtain a better ratio with access to an optimal oracle?"
        },
        {
            "heading": "Acknowledgement",
            "text": "The authors would like to thank Minming Li, Pinyan Lu, and Biaoshuai Tao for many insightful discussions on the research topic of this paper. Yuhao Zhang is supported by National Natural Science Foundation of China, Grant No. 62102251."
        }
    ],
    "title": "Improved Algorithms for Online Rent Minimization Problem Under Unit-Size Jobs",
    "year": 2023
}