{
    "abstractText": "The paper proposes a quantum algorithm for the traveling salesman problem (TSP) based on the Grover Adaptive Search (GAS), which can be successfully executed on IBM\u2019s Qiskit library. Under the GAS framework, there are at least two fundamental difficulties that limit the application of quantum algorithms for combinatorial optimization problems. One difficulty is that the solutions given by the quantum algorithms may not be feasible. The other difficulty is that the number of qubits of current quantum computers is still very limited, and it cannot meet the minimum requirements for the number of qubits required by the algorithm. In response to the above difficulties, we designed and improved the Hamiltonian Cycle Detection (HCD) oracle based on mathematical theorems. It can automatically eliminate infeasible solutions during the execution of the algorithm. On the other hand, we design an anchor register strategy to save the usage of qubits. The strategy fully considers the reversibility requirement of quantum computing, overcoming the difficulty that the used qubits cannot be simply overwritten or released. As a result, we successfully implemented the numerical solution to TSP on IBM\u2019s Qiskit. For the seven-node TSP, we only need 31 qubits, and the success rate in obtaining the optimal solution is 86.71%.",
    "authors": [
        {
            "affiliations": [],
            "name": "Jieao Zhu"
        },
        {
            "affiliations": [],
            "name": "Yihuai Gao"
        },
        {
            "affiliations": [],
            "name": "Hansen Wang"
        },
        {
            "affiliations": [],
            "name": "Tiefu Li"
        },
        {
            "affiliations": [],
            "name": "Hao Wu"
        }
    ],
    "id": "SP:14a5a299c4060d04dd849330a18aabb19ed34f5d",
    "references": [
        {
            "authors": [
                "A. Montanaro"
            ],
            "title": "Quantum algorithms: an overview",
            "venue": "npj Quantum Information 2,",
            "year": 2016
        },
        {
            "authors": [
                "F Arute"
            ],
            "title": "Quantum supremacy using a programmable superconducting processor",
            "venue": "Nature 574,",
            "year": 2019
        },
        {
            "authors": [
                "D Aharonov"
            ],
            "title": "Adiabatic quantum computation is equivalent to standard quantum computation",
            "venue": "SIAM review 50,",
            "year": 2008
        },
        {
            "authors": [
                "P.W. Shor"
            ],
            "title": "Algorithms for quantum computation: Discrete logarithms and factoring",
            "venue": "In Proceedings 35th annual symposium on foundations of computer science,",
            "year": 1994
        },
        {
            "authors": [
                "L.K. Grover"
            ],
            "title": "A fast quantum mechanical algorithm for database search",
            "venue": "In Proceedings of the twenty-eighth annual ACM symposium on Theory of computing,",
            "year": 1996
        },
        {
            "authors": [
                "M. Boyer",
                "G. Brassard",
                "P. H\u00f8yer",
                "A. Tapp"
            ],
            "title": "Tight bounds on quantum searching",
            "venue": "Fortschritte der Physik: Progress of Physics 46,",
            "year": 1998
        },
        {
            "authors": [
                "M Cerezo"
            ],
            "title": "Variational quantum algorithms",
            "venue": "Nature Reviews Physics",
            "year": 2021
        },
        {
            "authors": [
                "J Biamonte"
            ],
            "title": "Quantum machine learning",
            "venue": "Nature 549,",
            "year": 2017
        },
        {
            "authors": [
                "E. Farhi",
                "J. Goldstone",
                "S. Gutmann",
                "M. Sipser"
            ],
            "title": "Quantum computation by adiabatic evolution",
            "venue": "arXiv preprint quant-ph/0001106",
            "year": 2000
        },
        {
            "authors": [
                "T. Albash",
                "D.A. Lidar"
            ],
            "title": "Adiabatic quantum computation",
            "venue": "Reviews of Modern Physics 90,",
            "year": 2018
        },
        {
            "authors": [
                "B. Apolloni",
                "C. Carvalho",
                "D. de Falco"
            ],
            "title": "Quantum stochastic optimization",
            "venue": "Stochastic Processes and their Applications 33,",
            "year": 1989
        },
        {
            "authors": [
                "A.B. Finnila",
                "M. Gomez",
                "C. Sebenik",
                "C. Stenson",
                "J.D. Doll"
            ],
            "title": "Quantum annealing: A new method for minimizing multidimensional functions",
            "venue": "Chemical physics letters 219,",
            "year": 1994
        },
        {
            "authors": [
                "A. Das",
                "B.K. Chakrabarti"
            ],
            "title": "Colloquium: Quantum annealing and analog quantum computation",
            "venue": "Reviews of Modern Physics 80,",
            "year": 2008
        },
        {
            "authors": [
                "A. Gilliam",
                "S. Woerner",
                "C. Gonciulea"
            ],
            "title": "Grover adaptive search for constrained polynomial binary optimization",
            "venue": "Quantum 5,",
            "year": 2021
        },
        {
            "authors": [
                "S Harwood"
            ],
            "title": "Formulating and solving routing problems on quantum computers",
            "venue": "IEEE Transactions on Quantum Engineering",
            "year": 2021
        },
        {
            "authors": [
                "C.C. McGeoch",
                "C. Wang"
            ],
            "title": "Experimental evaluation of an adiabiatic quantum system for combinatorial optimization",
            "venue": "In Proceedings of the ACM International Conference on Computing Frontiers,",
            "year": 2013
        },
        {
            "authors": [
                "H Ushijima-Mwesigwa"
            ],
            "title": "Multilevel combinatorial optimization across quantum architectures",
            "venue": "ACM Transactions on Quantum Computing",
            "year": 2021
        },
        {
            "authors": [
                "G.G. Guerreschi",
                "A.Y. Matsuura"
            ],
            "title": "QAOA for Max- Cut requires hundreds of qubits for quantum speed-up",
            "venue": "Scientific reports 9,",
            "year": 2019
        },
        {
            "authors": [
                "F.G. Fuchs",
                "H.\u00d8. Kolden",
                "N.H. Aase",
                "G. Sartor"
            ],
            "title": "Efficient encoding of the weighted max k-cut on a quantum computer using qaoa",
            "venue": "SN Computer Science",
            "year": 2021
        },
        {
            "authors": [
                "M.T. Khumalo",
                "H.A. Chieza",
                "K. Prag",
                "M. Woolway"
            ],
            "title": "An investigation of ibm quantum computing device performance on combinatorial optimisation problems",
            "venue": "arXiv preprint",
            "year": 2021
        },
        {
            "authors": [
                "A. Ajagekar",
                "F. You"
            ],
            "title": "Quantum computing for energy systems optimization: Challenges and opportunities",
            "venue": "Energy 179,",
            "year": 2019
        },
        {
            "authors": [
                "R. Marto\u0148\u00e1k",
                "G.E. Santoro",
                "E. Tosatti"
            ],
            "title": "Quantum annealing of the traveling-salesman problem",
            "venue": "Physical Review E 70,",
            "year": 2004
        },
        {
            "authors": [
                "\u00d6. Salehi",
                "A. Glos",
                "J.A. Miszczak"
            ],
            "title": "Unconstrained binary models of the travelling salesman problem variants for quantum optimization",
            "venue": "Quantum Information Processing",
            "year": 2022
        },
        {
            "authors": [
                "C. Durr",
                "P. Hoyer"
            ],
            "title": "A quantum algorithm for finding the minimum",
            "venue": "arXiv preprint quant-ph/9607014",
            "year": 1996
        },
        {
            "authors": [
                "M.A. Nielsen",
                "I. Chuang"
            ],
            "title": "Quantum computation and quantum information",
            "year": 2002
        },
        {
            "authors": [
                "F Schmidt-Kaler"
            ],
            "title": "Realization of the Cirac\u2013Zoller controlled-NOT quantum gate",
            "venue": "Nature 422,",
            "year": 2003
        },
        {
            "authors": [
                "Han",
                "K.-H",
                "Kim",
                "J.-H"
            ],
            "title": "Genetic quantum algorithm and its application to combinatorial optimization problem",
            "venue": "In Proceedings of the 2000 congress on evolutionary computation. CEC00 (Cat. No. 00TH8512),",
            "year": 2000
        },
        {
            "authors": [
                "N. Ishikawa"
            ],
            "title": "Quantum speedup for index modulation",
            "venue": "IEEE Access",
            "year": 2021
        },
        {
            "authors": [
                "J. Preskill"
            ],
            "title": "Quantum computing in the NISQ era and beyond",
            "venue": "Quantum 2,",
            "year": 2018
        },
        {
            "authors": [
                "G. Laporte"
            ],
            "title": "The traveling salesman problem: An overview of exact and approximate algorithms",
            "venue": "European Journal of Operational Research",
            "year": 1992
        },
        {
            "authors": [
                "C. Chauhan",
                "R. Gupta",
                "K. Pathak"
            ],
            "title": "Survey of methods of solving tsp along with its implementation using dynamic programming approach",
            "venue": "International journal of computer applications",
            "year": 2012
        },
        {
            "authors": [
                "N. Christofides"
            ],
            "title": "Worst-case analysis of a new heuristic for the travelling salesman problem",
            "year": 1976
        },
        {
            "authors": [
                "K. Helsgaun"
            ],
            "title": "An effective implementation of the Lin\u2013 Kernighan traveling salesman heuristic",
            "venue": "European journal of operational research 126,",
            "year": 2000
        },
        {
            "authors": [
                "D.S. Johnson"
            ],
            "title": "Local optimization and the traveling salesman problem",
            "venue": "In International colloquium on automata, languages, and programming,",
            "year": 1990
        },
        {
            "authors": [
                "Y. Bengio",
                "A. Lodi",
                "A. Prouvost"
            ],
            "title": "Machine learning for combinatorial optimization: a methodological tour d\u2019horizon",
            "venue": "European Journal of Operational Research 290,",
            "year": 2021
        },
        {
            "authors": [
                "M. Lombardi",
                "M. Milano"
            ],
            "title": "Boosting combinatorial problem modeling with machine learning",
            "venue": "arXiv preprint arXiv:1807.05517",
            "year": 2018
        },
        {
            "authors": [
                "B. Heim",
                "E.W. Brown",
                "D. Wecker",
                "M. Troyer"
            ],
            "title": "Designing adiabatic quantum optimization: A case study for the traveling salesman problem",
            "year": 2017
        },
        {
            "authors": [
                "R.H. Warren"
            ],
            "title": "Adapting the traveling salesman problem to an adiabatic quantum computer",
            "venue": "Quantum information processing",
            "year": 2013
        },
        {
            "authors": [
                "T.D. Kieu"
            ],
            "title": "The travelling salesman problem and adiabatic quantum computation: an algorithm",
            "venue": "Quantum Information Processing",
            "year": 2019
        },
        {
            "authors": [
                "K. Srinivasan",
                "S. Satyajit",
                "B.K. Behera",
                "P.K. Panigrahi"
            ],
            "title": "Efficient quantum algorithm for solving travelling salesman problem: An IBM quantum experience",
            "year": 2018
        },
        {
            "authors": [
                "T. Akiyama",
                "T. Nishizeki",
                "N. Saito"
            ],
            "title": "NP-completeness of the Hamiltonian cycle problem for bipartite graphs",
            "venue": "Journal of Information processing",
            "year": 1980
        },
        {
            "authors": [
                "Wong",
                "L.-P",
                "M.Y.H. Low",
                "C.S. Chong"
            ],
            "title": "An efficient bee colony optimization algorithm for traveling salesman problem using frequency-based pruning",
            "venue": "In 2009 7th IEEE International Conference on Industrial Informatics,",
            "year": 2009
        },
        {
            "authors": [
                "B. Csaba",
                "M. Karpinski",
                "P. Krysta"
            ],
            "title": "Approximability of dense and sparse instances of minimum 2-connectivity, tsp and path problems",
            "venue": "In Proceedings of the thirteenth annual ACM-SIAM symposium on Discrete algorithms,",
            "year": 2002
        },
        {
            "authors": [
                "J.J. Rotman"
            ],
            "title": "An introduction to the theory of groups, vol",
            "venue": "Science & Business Media,",
            "year": 2012
        },
        {
            "authors": [
                "Almudever",
                "C. G"
            ],
            "title": "The engineering challenges in quantum computing",
            "venue": "In Design, Automation & Test in Europe Conference & Exhibition (DATE),",
            "year": 2017
        },
        {
            "authors": [
                "S. Xu"
            ],
            "title": "Reversible logic synthesis with minimal usage of ancilla bits",
            "venue": "arXiv preprint arXiv:1506.03777",
            "year": 2015
        }
    ],
    "sections": [
        {
            "text": "A Realizable GAS-based Quantum Algorithm for Traveling Salesman Problem\nJieao Zhu1, Yihuai Gao1, Hansen Wang2, Tiefu Li3,\u2020,\u2217, and Hao Wu4,\u2021,\u2217 1Department of Electronic Engineering,\nTsinghua University, Beijing, China 2Institute for Interdisciplinary Information Sciences,\nTsinghua University, Beijing, China 3School of Integrated Circuits,\nTsinghua University, Beijing, China 4Department of Mathematical Sciences,\nTsinghua University, Beijing, China\n(Dated: December 7, 2022)\nThe paper proposes a quantum algorithm for the traveling salesman problem (TSP) based on the Grover Adaptive Search (GAS), which can be successfully executed on IBM\u2019s Qiskit library. Under the GAS framework, there are at least two fundamental difficulties that limit the application of quantum algorithms for combinatorial optimization problems. One difficulty is that the solutions given by the quantum algorithms may not be feasible. The other difficulty is that the number of qubits of current quantum computers is still very limited, and it cannot meet the minimum requirements for the number of qubits required by the algorithm. In response to the above difficulties, we designed and improved the Hamiltonian Cycle Detection (HCD) oracle based on mathematical theorems. It can automatically eliminate infeasible solutions during the execution of the algorithm. On the other hand, we design an anchor register strategy to save the usage of qubits. The strategy fully considers the reversibility requirement of quantum computing, overcoming the difficulty that the used qubits cannot be simply overwritten or released. As a result, we successfully implemented the numerical solution to TSP on IBM\u2019s Qiskit. For the seven-node TSP, we only need 31 qubits, and the success rate in obtaining the optimal solution is 86.71%.\nKeywords: Quantum computing, travelling salesman problem (TSP), Grover\u2019s adaptive search (GAS), qubitsaving techniques\nI. INTRODUCTION\nQuantum computing is widely acknowledged as a revolutionary paradigm in computational technology, which enables significant speedup over classical computing for a wide range of problems. The power of quantum computing originates from quantum algorithms [1], which can achieve exponential speedups on certain computing tasks thanks to quantum superposition [2]. According to different computational models, quantum algorithms can be divided into two broad categories, and they are intrinsically equivalent in polynomial time [3]. The algorithms based on the quantum gate model belong to the first category, such as Shor\u2019s integer factorization [4], Grover\u2019s unstructured database search [5, 6], and variational quantum algorithms [7, 8].Another category is the adiabatic quantum algorithm [3, 9, 10], which is based on the evolution of the ground state over a time-varying Hamiltonian. It uses quantum effects instead of thermal effects, enabling tunneling from one state to another [11\u2013 13]. It is often understood as the quantum extension of the simulated annealing algorithm.\n\u2020 litf@tsinghua.edu.cn \u2021 hwu@tsinghua.edu.cn \u2217 Corresponding authors\nDue to the powerful quantum superposition characteristics of quantum computing, it has potential advantages in solving some NP-hard combinatorial optimization problems. Thus, the following problems have been initially explored: the Quadratic Unconstrained Binary Optimization problem [13\u201317], the Max-Cut problem [18, 19], the Quadratic Assignment Problem [20, 21], and the Traveling Salesman Problem (TSP) [22, 23]. For the above problems, Grover Adaptive Search (GAS) algorithm [24] is considered to be the most competitive algorithm framework since it ensures quadratic speedup in most cases and provides exact solutions with guaranteed success probability [25]. Moreover, the quantum computer technology related to GAS and the quantum gate model has also developed rapidly in recent years [14, 26\u2013 28]. Apart from GAS, other different quantum algorithms include quantum annealers [13, 22], which exploit the adiabatic evolution to find the solution, and Variational Quantum Algorithms (VQA) [15, 18], which provide a hybrid quantum-classical approach to approximately solve combinatorial optimization problems. In this work, we focus on developing the GAS algorithm for TSP. We endeavor to discuss two fundamental difficulties in designing GAS-type algorithms for combinatorial optimization problems. One is the feasibility of the solution given by the quantum algorithms. The other is that the quantum algorithms require a large number of qubits, which currently cannot be achieved by quantum ar X iv :2 21 2. 02 73 5v 1\n[ qu\nan t-\nph ]\n6 D\nec 2\n02 2\n2 computers in the NISQ [29] era. Therefore, without loss of generality, we are devoted to addressing these two difficulties for TSP, and we hope that our efforts will provide insightful approaches and lead to more follow-up works on quantum combinatorial solvers.\nTSP is one of the most well-known NP-hard combinatorial optimization problems. This problem considers a number of cities connected by paths of various lengths, and the salesman tries to determine the shortest cyclic tour that visits each city exactly once. There have been extensive studies on this problem, e.g., the exact methods [30, 31], the approximation methods [32], the heuristics methods [33, 34], and the AI-based methods [35, 36]. However, these methods always fail to overcome the hurdle of NP-hard problems. Thus, researchers hope to solve it by designing quantum algorithms. As we discussed earlier, there are two ways. One is the quantum annealing algorithm [37\u201339], which exploits the quantum fluctuation property to find the TSP solution. Another approach is based on the gate model and GAS that belong to our interests. This paper is inspired by Srinivasan et al.\u2019s work [40], which was unsuccessful since illegal tours could not be excluded. Later, IBM\u2019s Qiskit group tackled this problem with a correctly-designed phase estimation process. However, they mentioned that \u201cthis process is imcomplete\u201d, since all the legal Hamiltonian cycles need to be manually imported as candidates before the quantum algorithm is executed. In fact, finding all valid Hamiltonian cycles is inherently an NP-hard problem [41]. Moreover, there is no successful numerical experiments of Srinivasan et al.\u2019s work, and IBM\u2019s Qiskit group only present the results of TSP with four nodes, which is obviously too trivial.\nThis work focuses on the two difficulties mentioned above. First, we present and prove the Cycle Determination Theorem, which converts the valid cycle determinations into problems that can be tested using quantum circuits. Based on the theorem, the Hamiltonian Cycle Detection (HCD) oracle is designed here. Moreover, we also improved the Cycle Determination Theorem to determine the valid cycles with fewer tests by quantum circuits. Thus, the improved Hamiltonian Cycle Detection oracle is designed with fewer qubits and circuit layers. Secondly, we design the anchor register strategy for the problem that qubits can neither be overwritten nor be released due to the reversibility of quantum computation. It significantly saves the use of the number of qubits. This makes it possible to simulate some non-trivial problems on quantum computers or quantum simulators, such as seven-node TSP.\nhttps://qiskit.org/textbook/ch-paper-implementations/ tsp.html"
        },
        {
            "heading": "II. RESULTS",
            "text": "The classical N -city TSP is described as follows: each city vi (0 \u2264 i \u2264 N \u2212 1) has di (2 \u2264 di \u2264 N \u2212 1) roads connected to other cities. And there is at most one road connecting any two cities. The solution is the Hamiltonian cycle with the smallest cost. The TSP graph is complete when di = N \u2212 1,\u2200i, and it is called d-sparse when d = maxi{di} < N\u22121. Note that in order to simplify the problem, a complete TSP problem can be converted into several sparse TSP problems by heuristically pruning the unlikely edges in the tour [42]. It is well-known that complete TSP and sparse TSP are both NP-hard [43]. The interest of this work is to design a quantum algorithm to give exact solutions to the above problems, and require lower complexity than classical algorithms.\nAs discussed earlier, we would like to establish a general approach to overcoming the difficulties of Grover\u2019s adaptive search for combinatorial optimization problems, starting with solving TSP. Our main work is divided into three parts. (1) Encode all the candidate TSP solutions into quantum states. (2) Construct the Cycle Length Comparing (CLC) oracle that selects TSP cycles with a cost less than the threshold. (3) Construct the Hamiltonian Cycle Detection (HCD) oracle that excludes illegal TSP tours. From this, we can extract the desired solution from a uniform superposition state by the standard Grover\u2019s procedure [5, 14]. After several repetitions of quantum measurements, we can obtain the optimal solution with high probability."
        },
        {
            "heading": "A. TSP Problem Encoding",
            "text": "For N -city TSP, the traveling salesman has at most d \u2264 N \u2212 1 choices of roads in each city, so we only need m = dlog2 de qubits to encode his choice. Accordingly, each candidate solution can be specified by a quantum eigenstate on mN qubits. In the following, we refer it as the cycle register |C\u3009. The undirected graph in TSP is represented by the adjacency matrix A = (ai,j), 0 \u2264 i, j < N . This is a symmetric matrix whose element ai,j > 0 represents the traveling cost between two cities i and j, where the self-loops (i \u2192 i) and the non-existing edges (i \u2192 j) are excluded by infinite edge costs: ai,i = \u221e, and ai,j =\u221e, respectively. To store the connections, we use the adjacency list\nPi = (0, 1, \u00b7 \u00b7 \u00b7 , i\u2212 1, i+ 1, \u00b7 \u00b7 \u00b7 , N \u2212 1), \u2200 0 \u2264 i \u2264 N \u2212 1, (1) where the self-loop edge (i \u2192 i) and the non-existing edges should be excluded from the adjacency list Pi, as is mentioned above. Note that both the complete TSP #Pi = N \u2212 1, \u2200i, and the sparse TSP #Pi < N \u2212 1, \u2200i can be processed by this encoding. Thus, the cycle register |C\u3009 can be represented as follows\n|C\u3009 = \u2297N\u22121i=0 |Ci\u3009 = \u2297N\u22121i=0 \u2223\u2223ci,(m\u22121) \u00b7 \u00b7 \u00b7 ci,1ci,0\u232a . (2)\n3\nHere Ci encodes the path choice of the salesman at city vi, and ci,m\u22121 \u00b7 \u00b7 \u00b7 ci,1ci,0 is the binary representation of Ci. According to the adjacency lists (1) and the integer value Ci, we can obtain the binary code of the next city Pi[Ci] from the i-th city.\nNext, we present a simple example to demonstrate the qubit encoding scheme. For a 6-city complete TSP, N = 6, d = 5, only m = 3 qubits are required for encoding the choice. The adjacency lists are given by\nP0 = {1, 2, 3, 4, 5}, P1 = {0, 2, 3, 4, 5}, P2 = {0, 1, 3, 4, 5}, P3 = {0, 1, 2, 4, 5}, P4 = {0, 1, 2, 3, 5}, P5 = {0, 1, 2, 3, 4}.\n(3)\nFor example, in Table. I, the quantum state\n|C\u3009 = |010\u3009 \u2297 |011\u3009 \u2297 |001\u3009 \u2297 |100\u3009 \u2297 |000\u3009 \u2297 |010\u3009 ,\nrepresents the Hamiltonian cycle\n0\u2192 3\u2192 5\u2192 2\u2192 1\u2192 4\u2192 0."
        },
        {
            "heading": "B. Framework",
            "text": "Next, we sketch the ingredients of our Grover Adaptive Search [14]-based Quantum Algorithm for Traveling Salesman Problem (GQ-TSP). It consists of three major steps (see also Fig. 1 for quantum circuit):\n1. Initialization. The cycle register |C\u3009, as a group of qubits, is initialized to the uniform superposition state. And the result qubit |R\u3009 is initialized to |\u2212\u3009 for Grover\u2019s search.\n2. Grover iteration. For k = 1, 2, \u00b7 \u00b7 \u00b7 , Iopt, execute the following five sub-procedures.\n\u2022 Label the states whose length are smaller than the threshold Cth by the CLC oracle.\n\u2022 Label the states that correspond to the legal cycles by the HCD oracle.\n\u2022 Flip the result qubit |R\u3009 through a C2NOT gate whenever the states are labeled by both of the two oracles.\n\u2022 Apply the CLC oracle and HCD oracle again to release the intermediate qubits for reuse.\n\u2022 Complete the Grover iteration by the diffusion operator 2 |s\u3009 \u3008s| \u2212 I, where |s\u3009 is the uniform superposition state.\n3. Measurement. The cycle register |C\u3009 is measured to obtain the solution to TSP.\nThus, the cycle register |C\u3009 contains the probability information of all the cycles that satisfy the requirements of the HCD and CLC oracles. Moreover, the Hamiltonian cycles with smaller costs have larger probability amplitude. Thus, a timely quantum measurement yields a valid optimal cycle with a high probability. It should be mentioned that Iopt and Cth are very important to the effect of the algorithm and will be discussed in detail later."
        },
        {
            "heading": "C. Cycle Length Comparing Oracle",
            "text": "The purpose of designing the Cycle Length Comparing (CLC) oracle is to filter all the candidate solutions according to their cycle costs, which is defined by\ncost(|C\u3009) = N\u22121\u2211 j=0 aj,Pj [Cj ]. (4)\nFollowing Srinivasan, et.al.\u2019s work [40], the quantum computation of (4) is realized by the controlled U - operator, which is composed of N smaller operators Uj , 0 \u2264 j < N defined as\nUj = diag (exp (i\u03b8j,0) , exp (i\u03b8j,1) , \u00b7 \u00b7 \u00b7 , exp (i\u03b8j,2m\u22121)) , (5)\nwith \u03b8j,k =\n{ aj,Pj [k], 0 \u2264 k < #Pj\n0, k \u2265 #Pj . (6)\nCorresponding to different path choices, Uj introduces different phase shifts, i.e.\nUj |Cj\u3009 = exp ( i\u03b8j,Cj ) |Cj\u3009 . (7)\nThus, the effect of the U -operator on |C\u3009 is given as follows U |C\u3009 = N\u22121\u2297 j=0 Uj |Cj\u3009 = N\u22121\u2297 j=0 exp ( i\u03b8j,Cj ) |Cj\u3009\n= N\u22121\u220f j=0 exp ( i\u03b8j,Cj )N\u22121\u2297 j=0 |Cj\u3009 = exp(i \u00b7 cost(|C\u3009)) |C\u3009 .\n(8) The U -operator acts as the cost computation module in the quantum circuit of the CLC oracle. Later, the detailed implementation of the U -operator will be discussed in the Methods section, in which we will elaborate on the techniques to reduce the number of qubits.\nWe now turn to the construction of the CLC oracle. We can divide it into three steps (see also Fig. 2 for illustration). First, apply the standard phase estimation (QPE) routine [25] to obtain the cost values. Here we\nneed to execute the U -operator for arbitrary |`\u3009 times, where |`\u3009 is prepared into a uniform superposition state by the t Hadamard gates. The next thing is to label the states with costs smaller than Cth. Finally, we have to free up the intermediate ancillary qubits for reuse by the mirrored gates."
        },
        {
            "heading": "D. Hamiltonian Cycle Detection Oracle",
            "text": "The purpose of designing the Hamiltonian Cycle Detection (HCD) oracle is to pick out the legal Hamiltonian cycles. Its implementation relies on the following theorem.\nTheorem 1 (Cycle Determination Theorem). Consider the function \u03c0 : {0, 1, \u00b7 \u00b7 \u00b7 , N \u2212 1} \u2192 {0, 1, \u00b7 \u00b7 \u00b7 , N \u2212 1} that corresponds to the cycle register |C\u3009. Then |C\u3009 is a Hamiltonian cycle if and only if: 1) \u22001 6 j 6 N \u2212 1, \u03c0j(0) 6= 0, 2) \u03c0N (0) = 0.\nProof. The necessity is trivial. Here we only prove the sufficiency part. We first show that \u03c0 is a permutation. In fact, we only need to prove the following:\n\u03c0i(0) 6= \u03c0i+s(0), \u22000 \u2264 i < i+ s < N.\nIf not, there would exist \u03c0i(0) = \u03c0i+s(0) for some 0 < s < N \u2212 i. Applying \u03c0N\u2212i on both sides yields\n0 = \u03c0N\u2212i(\u03c0i(0)) = \u03c0(N\u2212i)+(i+s)(0) = \u03c0s(0),\nwhich contradicts the assumption 1). It remains to be shown that \u03c0 is a cycle. According to the permutation decomposition theorem [44, Theorem 1.1],\n\u03c0 = \u03c41\u03c42 \u00b7 \u00b7 \u00b7 \u03c4k,\nwhere \u03c4i, 1 \u2264 i \u2264 k are disjoint cycles, and k \u2265 1. We would like to prove k = 1. If not, then there exists \u03c4j that satisfies\n\u03c4 `j (0) = 0, ` := ord(\u03c4j) < N.\nThus, we have\n\u03c0`(0) = 0,\nwhich leads to a contradiction.\nBased on the above Theorem 1, we present the detailed design of the HCD oracle. The HCD oracle contains the following two steps:\n1. Traveling (see Fig. 3 for illustration). According to the cycle register |C\u3009, the locations |Ij\u3009, j = 1, 2, \u00b7 \u00b7 \u00b7 , N of the salesman at each step are calculated sequentially by the index forwarder F gates.\n2. Checking (see Fig. 4 for illustration). Perform checks on each of the locations, and detect whether the cycle |C\u3009 is valid according to Theorem 1. The checking part is described by the following quantum-logical expression:\nRHCD = N\u22121\u220f j=1 OR(|Ij\u3009)  \u00b7NOR(|IN \u3009), (9) where the product sumbol \u220f j denote the logical AND operation, and the gate OR(|Ij\u3009) represents bitwise logical OR operation on each of the n qubits in the location register |Ij\u3009.\nAfter applying the HCD oracle, if the result qubit is initialized in superposition to |\u2212\u3009 := (|0\u3009 \u2212 |1\u3009)/ \u221a 2, then the state after applying the HCD oracle is described by\nHCD(|C\u3009 |\u2212\u3009) = (\u22121)RHCD |C\u3009 |\u2212\u3009 ,\nwhich introduces a cycle-specific negative sign to label the valid cycles.\nIn practice, all the checking procedures will be inverted by an \u201cuncomputation\u201d process to restore the ancillary qubits OR(|I1\u3009), \u00b7 \u00b7 \u00b7 ,OR(|I6\u3009) to their initial state |0\u3009. It is worth mentioning that the index forwarder F plays an important role in the traveling part. And we will describe its detailed implementation in the Methods section.\nBelow, we discuss the qubit consumption of the HCD oracle. To record the salesman\u2019s locations |Ik\u3009, nN qubits are required, with N and n denoting the number of cities for TSP and the number of qubits for binary-encoding a city index, respectively. And it also needs N qubits to temporarily store the checking results OR(|Ik\u3009), k = 1, \u00b7 \u00b7 \u00b7 , N . In terms of the current scale of quantum computers, the algorithm requires a large number of qubits. Below, we will focus on techniques to save qubits as much as possible to ensure that the qubit number requirements of our algorithm can be satisfied by existing quantum computers.\nE. Improved Hamiltonian Cycle Detection Oracle.\nTheorem 1 provides the necessary and sufficient conditions of a Hamiltonian cycle, based on which we have designed the traveling and checking algorithms for the HCD oracle. However, it is not necessary to track all the cities on the salesman\u2019s tour. Instead, checking some of these tour steps suffices to decide a Hamiltonian cycle. This is based on our improvement of Theorem 1:\nTheorem 2 (Improved Cycle Determination Theorem). Suppose the function \u03c0 : {0, 1, \u00b7 \u00b7 \u00b7 , N \u2212 1} \u2192\n{0, 1, \u00b7 \u00b7 \u00b7 , N \u2212 1} represents |C\u3009. Then |C\u3009 is a Hamiltonian cycle if and only if: 1) \u2200j|N : 1 6 j 6 N \u2212 1, \u03c0j(0) 6= 0; 2) \u03c0N (0) = 0.\nProof. The necessity is trivial. We prove the sufficiency of the theorem in the following.\nWe claim that \u2200j : 1 \u2264 j < N , \u03c0j(0) 6= 0. If not, then there exists some 1 \u2264 j < N such that \u03c0j(0) = 0. We choose the minimum possible j. According to assumption (1), j - N . Let N = kj + r0, where 1 \u2264 r0 < j is the remainder of N divided by j. Thus, we have\n0 = \u03c0N (0) = \u03c0kj+r0(0) = \u03c0r0(\u03c0kj(0)) = \u03c0r0(0), (10)\nwhich means that we find a smaller positive integer r0 < j such that \u03c0r0(0) = 0, leading to a contradiction. Thus, the sufficiency is proved immediately from Theorem 1.\nBased on the above Theorem 2, we can replace the HCD checking step (9) with the following simplified for-\n6 n\nn\nn\nn\n|I1\u27e9 OR\n|I2\u27e9 OR\n|I3\u27e9 OR\n|I6\u27e9 OR\n|0\u27e9 OR(|I1\u27e9)\n|0\u27e9 OR(|I2\u27e9)\n|0\u27e9 OR(|I3\u27e9)\n|0\u27e9 |RHCD\u27e9\nFIG. 5. Quantum circuit illustration (N = 6) of the checking part of the improved HCD oracle.\nmula\nRHCD =  \u220f 1\u2264j<N,j|N OR(|Ij\u3009) \u2295OR(|IN \u3009). (11) This replacement significantly reduces the number of OR operations and the number of corresponding qubits that are required in the checking step of the HCD oracle. (see Fig. 5)\nRemark 1. If the problem size N is close to some large prime number, increasing the problem size may unexpectedly reduce the qubit consumption. An interesting observation occurs when N = 16. Since 16 has 5 divisors {1, 2, 4, 8, 16}, a total number of 5 checks are needed in the HCD oracle. However, if we increase the problem size by one city, i.e., N = 17, only 2 checks are required, since 17 is a prime number."
        },
        {
            "heading": "F. The anchor register strategy.",
            "text": "Qubit is always a scarce resource [45] on both quantum simulators and real-world NISQ quantum computers. As we have already mentioned in the problem encoding scheme, nN qubits are required to record the salesman\u2019s locations |Ij\u3009, which quickly becomes computationally unaffordable when applied to some non-trivial TSP problem sizes, for example, N = 6, due to the scarcity of the qubit resource.\nFortunately, in the HCD oracle, we only need to store the result qubits OR(|Ik\u3009) instead of the whole n-length location registers |Ik\u3009, implying that these location registers |Ik\u3009 may be reused. On the other hand, directly erasing and reusing |Ik\u3009 after the calculation of |Ik+1\u3009 is prohibited since the erasure causes a quantum state collapse. Thus, we introduce a small number of anchor\nregisters |A`\u3009 , ` = 1, 2, \u00b7 \u00b7 \u00b7 , L to store part of the intermediate results. These anchor registers enables us to reversibly uncompute most of the |Ik\u3009\u2019s to save qubit usage. If L anchor registers and k location registers are employed, the number of required qubits is reduced to n(L+k), which significantly reduces the qubit consumption compared with storing all the |Ik\u3009. This is realized by the following algorithm, where it is assumed that N = L(k + 1):\n1. Initialization.\n2. For i = 1, 2, \u00b7 \u00b7 \u00b7 , L do\n\u2022 Apply F gates to calculate the k location registers |Ij\u3009, (i\u2212 1)(k+ 1) + 1 \u2264 j \u2264 i(k+ 1)\u2212 1 from |Ai\u22121\u3009. \u2022 Calculate the corresponding OR(|Ij\u3009). \u2022 Calculate |Ai\u3009 by applying F gate to\u2223\u2223Ii(k+1)\u22121\u232a. \u2022 Use |Ai\u22121\u3009 to sequentially free |Ij\u3009 by uncom-\nputation.\n3. Return the checking results OR(|Ij\u3009).\nIt is worth noting that, in the above algorithm, the assumption N = L(k+ 1) can be dropped, i.e., N need not be a multiple of L. It suffices to let the number of anchor registers L = b Nk+1c, where k is the number of intermediate location registers\n\u2223\u2223I(i\u22121)(k+1)+1\u232a , \u00b7 \u00b7 \u00b7 , \u2223\u2223Ii(k+1)\u22121\u232a. For OR(|Ij\u3009), this calculation is only needed when j|N . For the uncomputation process, since the location registers are reused for different i, the total number of qubits required can be reduced from nN to n(k+L), at the cost of increasing the total circuit depth by a factor of 2 due to the uncomputation.\nThe optimal tradeoff between the number of anchor registers L and the number of intermediate location registers k are given by\nkopt = argmink\n{ n ( b N k + 1 c+ k )} ,\nwhere the total number of required qubits is minimized. The overall design principle is illustrated in Fig. 6."
        },
        {
            "heading": "G. Simulation Results",
            "text": "In this section, we implement our proposed GQ-TSP for graphs with city number N = 4, 5, 6, 7 and provide the numerical results. Specifically, we consider complete graphs for N = 4, 5; and 4-sparse graph, i.e. graph degree d = 4 for N = 6, 7 due to the limitation of simulated qubit number. For N \u2265 5, the sparse encoding is adopted to reduce the number of required qubits. We generate our test graphs by uniformly picking N cities within the\nsquare [0, 1]2, see Fig. 7(a-d) for illustration. The distances between cities follow the Euclidean distance\ndij = \u2016xi \u2212 xj\u20162, xi, xj \u2208 [0, 1]2.\nThe same quantum circuit is executed for Ns = 1024 times to obtain statistical data of final quantum state |C\u3009. Then, the threshold Cth is updated based on the sampled results. For the CLC oracle, the QFT precision is set to t = 6 qubits. We implement our proposed GQTSP with the IBM Qiskit simulator, and run simulations with a Windows 11 PC equipped with an Intel i5-12400 CPU and 32GB RAM.\nFig. 7(e-h) illustrate the sample probability of the top-3 valid cycles, where purple solid line, green dashed line and blue dotted line represent the 1st, 2nd and 3rd short cycle, respectively. The sample probability curves exhibit a sinusoidal waveform, which coincides the rotation interpretation [25] of Grover\u2019s search algorithm. Specifically, the sample probability of the shortest cycle reaches the highest at the optimal Grover iteration Iopt, which is close to the theoretical estimation I\u0302opt derived from the following formula [25] if the threshold Cth excludes all the sub-optimal solutions:\nI\u0302opt = CI\n( \u03c0\n2\u03b8 \u2212 1 2\n) , (12)\nwhere \u03b8 = 2 arcsin ( 1/2(m\u22121)/2 ) , and CI(x) represents the integer closest to the real number x. The optimal sample probability of the top-3 cycles are shown in Table. II, where p1, p2, p3 represents the probability of 1st, 2nd, 3rd shortest cycle, respectively. The probability of the\nshortest cycle at N = 6 is lower in that the length of the 2nd and 3rd short cycles are close to the shortest one. This also leads to Iopt < I\u0302opt when N = 6. We will look more deeply into this issue in the Discussion section. Fig. 7(i-l) is the observed probability distribution over all the edges stored in the cycle register |C\u3009, when the number of iterations reaches 1/3 of the optimal iteration number Iopt. Darker edge color means the corresponding edge is observed at a higher probability. It can be seen from the figure that, the optimal solution can be observed at a reasonable probability even if only 1/3 of the required iterations are performed. Fig. 7(m-p) shows the observed probability distribution over the edges when the optimal number of Grover iteration is reached. At this optimal number, the optimal cycle can be observed with the highest probability. As long as the optimal solution is unique, there exists such Cth that ensures the selection of the optimal solution when the QFT precision t is sufficiently large.\nBy comparing along the columns of Fig. 7, it is shown that the optimal TSP tour can be significantly amplified by the proposed GQ-TSP algorithm.\nIn Table. III, we provide the performance comparison between the proposed GQ-TSP algorithm and the\nVQA (including VQE and QAOA)-based baseline algorithms [20]. Criteria including success rate, qubit number and MT (mean running time on the Qiskit simulator) are considered in the comparison. The success rate (SR99) is the percentage amount of trials within 99% of the optimal TSP solution.\nAs is shown in Table. III, the proposed GQ-TSP has a significantly higher success rate (SR99) than VQE and QAOA. Furthermore, as N grows larger, the qubit consumption of the proposed GQ-TSP is also more efficient than the baselines. The consumption of the proposed algorithm only scales as O(N logN) with a small constant factor guaranteed by the qubit-saving techniques, while both VQE and QAOA need exactly N2 qubits.\nIn conclusion, compared with the baselines, the proposed GQ-TSP enjoys higher success rate and lower qubit consumption when N is large. As a result, the GQ-TSP method will possibly be a promising TSP solver to run on a real-world fault-tolerant physical quantum computer."
        },
        {
            "heading": "III. DISCUSSION",
            "text": "Qubit consumption. Reducing qubit consumption is of practical importance, both from a simulating point\nof view, and from an NISQ-implementable aspect. In our proposed GQ-TSP, the qubits are saved mainly by the qubit-efficient construction of the improved HCD oracle, the anchor register strategy, and the zeroed-ancilla reusing methods (will be thoroughly discussed in the Methods section).\nTo gain quantitative insights into our proposed GQTSP algorithm, we analyze the total qubit usage in the case N = 6,m = 2, i.e., a graph containing 6 nodes with d \u2264 2m = 4. First of all, according to the encoding method of |C\u3009, a number of mN = 2 \u00d7 6 = 12 qubits are needed to encode a TSP cycle on a sparse graph, which also serve as the input of the CLC and HCD oracle. Inside the HCD oracle, another set of quantum registers |Ik\u3009 are needed to store the locations of each tour step, consuming n(b Nk+1c + k) = 12 more qubits, with n = dlog2Ne = 3 being the qubit number required for natural encoding, k = argmink\u2032 ( b Nk\u2032+1c+ k\u2032 ) = 1 being the number of n-qubit quantum registers in the HCD oracle, and b Nk+1c = 3 indicating the number of required anchor registers |A`\u3009. Besides, in the index forwarders (F gates) of the oracle, m = 2 additional qubits are used to temporarily store the result of the quantum multiplexer, which serves as input for the index converter (see Meth-\n9\nods for details). To perform checking operations of the tour, we employ \u03c30(N)\u2212 1 = 3 qubits to store OR(|I1\u3009), OR(|I2\u3009), and OR(|I3\u3009), respectively. Finally, two more qubits are used to store the results of the HCD oracle and the CLC oracle. In conclusion, without considering the ancillary qubits for the CLC oracle, we consume a total number of 12 + 12 + 3 + 2 + 2 = 31 qubits in the case of N = 6,m = 2 with sparse encoding.\nThe CLC oracle is composed of the controlled U - operators, the QFT circuit, and the quantum comparator. The qubit consumption is the summation of all its components. The QFT precision of the CLC oracle is set to t = 6, which means that a number of 2t + 1 = 13 zeroed ancillas should be employed for the whole CLC oracle. This is because a number of t qubits are used to setup the uniform superposition state of |`\u3009, another t qubits are used for the implementation of the controlled U -operators (see Methods for details), and one ancillary qubit is used for storing the output of the CLC oracle. However, since the HCD oracle consumes more ancillary qubits than the CLC oracle, we can reuse the ancilla qubits after the execution of the HCD oracle. Thus, in the case ofN = 6,m = 2, we still consume a total number of 12+12+3+2+2 = 31 qubits, taking into consideration all the oracles and the qubit reusing strategies.\nNow we turn to the more general case. When the precision factor t is fixed, the qubit consumption is directly determined by the problem size N and the sparsity m of the graph. For the general case of sufficiently large problem size N , the qubit consumption is given by the following Theorem 3.\nTheorem 3. The qubit usage nq is O(mN + 2 \u221a N log2N + \u03c30(N)), where N is the number of cities, m is the number of qubits needed to encode all neighbors of a city, and\n\u03c30(N) := #{j \u2208 Z : 1 \u2264 j \u2264 N, j|N}.\nProof. The qubit usage of our proposed GQ-TSP is divided into three parts.\n1. The cycle register |C\u3009 consumes mN qubits. 2. A total number of n(k+b Nk+1c) qubits are consumed\ninside the HCD and CLC oracles. This is because each city needs an n-qubit register to perform natural encoding, and k+b Nk+1c copies of such register\n4. Other qubit usages are all within o(N), thus can be ignored asymptotically. As for the QFT circuits and the Quantum Comparator circuits, they do not consume extra qubits, since the ancilla qubits needed by them can be reused from the HCD oracle. Therefore, it suffices to introduce O(mN+2 \u221a N log2N+ \u03c30(N)) qubits to execute this algorithm.\nAccording to Theorem 3, a general approximation of the qubit usage is given by O(mN + 2 \u221a N log2N + \u03c30(N)), which is asymptotically linear in N . The table below shows the qubit consumption for different problem size N , illustrating the significant qubit-efficiency of the proposed GQ-TSP with all the optimization techniques, compared to the non-optimized naive implementation. Circuit depth. The circuit depth is proportional to the running time of the quantum algorithm, which is both applicable on a classical simulator and on a real quantum hardware.\nFor the HCD oracles, the main building blocks are AND gates (CnNOT gates), since most of the circuit depths are consumed by the index converters (F gates), and the OR gates (realized by AND gates and X gates).\n10\nThe AND gate requires linear complexity on the number of its inputs. As analyzed in the Methods section, the QAQR of address length n consumes O(Ln2n) depths. For the index forwarder, the address is of length n = dlog2Ne, and L = m, so each QAQR in the index forwarder consumes a depth of O(Nnm). Another component of the index forwarder is the index converter (QACR), with m+n input qubits and n output qubits. It consumes a depth ofO(n(m+n)2m+n) = O(Ndn(m+n)) (see Methods). Thus, a single index forwarder consumes a depth of O(Nn((d + 1)m + dn)). During the computation of the HCD oracle, N index forwarders are invoked. Therefore, the total depth for a HCD oracle is O(N2n((d+ 1)m+dn)), and if we assume d be constant, the result is O(N2 log2N).\nFor the CLC oracles, the main part is the controlled U -operators. According to its construction, the depth of a single U -operator is O(2m). Since the CLC oracle requires one application of the U -operator to each of the |Cj\u3009 , 1 \u2264 j \u2264 N , the depth of the QPE module is O(N2m + t2), where t is the number of precision qubits of the QFT subroutine. With the assumption that d and t are invariant with the increase of the problem size N , the total complexity of the CLC oracle is O(N).\nFinally, the GAS iteration should be repeated O(2Nm/2) times according to (12) to ensure optimal amplitude amplification. To sum up, the overall depth of the whole GQ-TSP algorithm is O(2mN/2N2 log2N).\nMETHODS"
        },
        {
            "heading": "1. Implementation of the CLC oracle.",
            "text": "The CLC oracle contains three main parts: the U - operators, the inverse quantum Fourier transform (iQFT) module, and the quantum comparator. The iQFT module [25] is well-studied, so we implement it with the textbook techniques. The quantum comparator with a classical pre-defined threshold Csh can be implemented directly in Qiskit. Consequently, the difficulty of realizing this CLC oracle mainly lies in the implementation of the U -operators, which we will discuss in detail.\nPre-processing. Since the iQFT is subject to a 2\u03c0 phase ambiguity, the maximal allowed cycle length should be normalized to be smaller than 2\u03c0. Note that each term of the total cycle length, i.e., the components of a U - operator Uj : 1 \u2264 j \u2264 N , are determined by the parameters \u03b8j,k. Thus, in order to avoid such ambiguity, we normalize the adjacency matrix A by the sum of all of its entries, and then let: \u03b8j,k = 2\u03c0ak,Pj [k] for 0 \u2264 j < N and all valid k.\nSince Uj acts on the m-qubit register |Cj\u3009, the matrix representation of Uj has both 2\nm rows and columns. Hoever, #Pj may be strictly less than 2\nm, leading to the inability to fill the diagonal of a unitary matrix Uj . To address this problem, these unspecified diagonal entries are filled with 1\u2019s ( exp(i0) ), and accordingly, the\noptimization target of the GAS-QTSP is shifted to maximizing the cycle length instead of minimizing it, in order to exclude these unspecified paths with zero costs. Thus, the problem pre-processing shoud start with converting the cost-minimization problem in to an equivalent maximization one. Construction. The controlled U -operators are constructed recursively in our experiments. For the simplest case m = 1, since the U -operator needs to provide 2m = 2 different phase shifts, it is just a controlled-phase gate:\nU = [ ei\u03b80 0 0 ei\u03b81 ] = ei\u03b80 [ 1 0 0 ei(\u03b81\u2212\u03b80) ] , (13)\nwhere the controlled-U gate can be represented by\ncontrolled-U =  1 1 ei\u03b80\nei\u03b81  . (14) For m = 2, we design a special quantum circuit to implement the unitary operator\nU = diag (exp (i\u03b80) , exp (i\u03b81) , exp (i\u03b82) , exp (i\u03b83)) .\nLet\nx = \u22121 2 (\u03b83 \u2212 \u03b82 \u2212 \u03b81 + \u03b80) ,\nthen, inspired by the paper [40], the corresponding quantum circuit implementing U can be decomposed into two operators V1 and V2:\nV1 =  ei\u03b80 0 0 0 0 ei\u03b81 0 0 0 0 ei\u03b82 0 0 0 0 ei(\u03b82+\u03b81\u2212\u03b80)  (15a)\nV2 = 1 0 0 00 1 0 00 0 1 0 0 0 0 e\u2212i2x  , (15b) where one can easily verify that U = V1V2. The controlled-V1 operator is implemented in Fig. 8 by further decomposing it into controlled phase gates. The implementation of controlled-V2 gate is described in Fig. 9. In both figures, P (\u03b8) denotes the controlled phase gate with rotation angle \u03b8.\nFor larger m > 2, we use recursive construction by only one extra ancillary qubit. Since there are m \u201cchoiceencoding\u201d qubits \u2223\u2223cj,(m\u22121)cj,(m\u22122) \u00b7 \u00b7 \u00b7 cj,0\u232a, we can partition matrix Uj along the diagonal into two smaller matrices, with each of the sub-matrix inheriting half of the original values \u03b8j,k. Thus, we can recursively construct two smaller U -operators, controlled by the first \u201cchoice-encoding\u201d qubit\n\u2223\u2223cj,(m\u22121)\u232a and its flipped version X \u2223\u2223cj,(m\u22121)\u232a, respectively. Note that an ancillary qubit\n11\nis introduced to temporarily save the AND result of the control qubit qctrl and the first qubit \u2223\u2223cj,(m\u22121)\u232a."
        },
        {
            "heading": "2. Efficient implementation of quantum logical gates.",
            "text": "The implementation of AND gate, i.e. CNOT with n control qubits (CnNOT), is a basic component of our TSP quantum circuit, and then OR gates can be easily constructed from CnNOT and X gates. Naive realization of CnNOT consumes (n\u2212 2) additional ancillas and (2n \u2212 3) Toffoli gates. Though it is a linear consumption on qubits and circuit depth, it is still possible to reduce the number of ancillas to 1, while keeping the number of Toffoli gates within O(n). In state-of-the-art quantum technology, qubits are computational resources that are regarded to be much more expensive than circuit depth, which is the same case in classically simulated quantum circuits. So our main efforts are devoted to qubit-reducing.\nHowever, is it possible to implement the CnNOT gate without any ancillas? In fact, it is impossible to do the CnNOT operation only through basic Toffoli gates. The reason is that, the CnNOT gate swaps the all-one state |11 \u00b7 \u00b7 \u00b7 11\u3009 and the state |11 \u00b7 \u00b7 \u00b7 10\u3009, and leaves other states unchanged, so it is an odd permutation on 2n elements. However, the basic Toffoli gates do not touch all the qubits, thus being even permutations. Cascading even permutations cannot result in an odd permutation, so we cannot implement CnNOT only by basic gates only without an ancilla.\nOur O(n) construction requires only 1 \u201czeroed\u201d ancilla\nqubit whose initial state is |0\u3009, which is proposed in the paper [46]. To fulfill this target, we first decompose the CnNOT into four Cn/2NOT gates (approximately n/2 if n is odd), and then implement each half-sized gate with the \u201cborrowed\u201d ancilla technique. Thus, the construction of universal CnNOT consuming only 1 borrowed qubit b can be achieved within only 4 steps, which is shown in the following\n(1) Toggle b conditioned on q0:bn/2c. Use q(bn/2c+1):(n\u22121) as borrowed ancillas,\n(2) Toggle r conditioned on q(bn/2c+1):(n\u22121) and b. Use q0:bn/2c as borrowed ancillas,\n(3) Toggle b conditioned on q0:bn/2c. Use q(bn/2c+1):(n\u22121) as borrowed ancillas,\n(4) Toggle r conditioned on q(bn/2c+1):(n\u22121) and b. Use q0:bn/2c as borrowed ancillas,\nwhere r denotes the result qubit, and q0:(n\u22121) denotes the n input qubits. Step (2) and step (4) together form a toggle-detection circuit on b, whose toggling is conditioned on q0:bn/2c. Step (1) followed by (3) ensures the borrowed ancilla b to be unaffected. Thus, we convert the construction problem of CnNOT into two Cbn/2c+1NOTs and two Cn\u2212bn/2cNOTs, and then implement the four CNOTs by borrowing qubits from each other. Assume n is even, then the circuit depth is 8(n\u22123) in total (counted in Toffolis), which takes linear time to execute within constant number of ancillas.\n12"
        },
        {
            "heading": "3. Realization of the index forwarder.",
            "text": "The index forwarder F plays an important role in the traveling part of the HCD oracle, since it forwardcomputes the next city index |Ik+1\u3009 given the current index |Ik\u3009. An index forwarder in each step consists of two parts: a quantum multiplexer to compute the sparseencoded index of the next city |Sk+1\u3009, and an index converter to get the index of the next city |Ik+1\u3009 from |Sk+1\u3009. From a general point of view, both the quantum multiplexer and the index converter are instances of the quantum-addressed register. However, the difference is that the quantum multiplexer extracts quantum data from the input cycle register |C\u3009, while the index converter extracts classical data in a fixed classical lookup table. In practice, the quantum multiplexer is implemented by quantum-addressed quantum registers (QAQR), while the index converter is implemented by quantum-addressed classical registers (QACR). The construction of the QAQR and QACR from basic quantum gates will be elaborated in the following, but before that we need to introduce what are registers.\nRegisters are essential memory components in modern classical processors. Synchronized by a clock, classical registers can take in the input bits at each clock rise, and keep its value unchanged throughout the clock period. Mathematically, a register stores a numerical value R. Several registers form a register file (RF), which can be represented by a group of 2n length-L bit arrays R[j] \u2208 {0, 1}L, where 0 \u2264 j < 2n is the n-bit index, or the \u201caddress\u201d in computer science. Given a certain address j, the value R[j] stored in the RF can be immediately accessed.\nIn classical registers, the address j is a stable deterministic value during the clock period. However, different from classical registers, a quantum-addressed quantum register (QAQR) allows j to be in superposition, and it outputs all the possible R[j] simultaneously, following the original superposition coefficients. Since quantum data are stored in qubits, the function of a QAQR is to select a certain group of qubits (the data) conditioned on another group of qubits (the address). To realize this function, we design the quantum multiplexers. A single-qubit naddressed quantum multiplexer is addressed by n qubits An\u22121An\u22122 \u00b7 \u00b7 \u00b7A0, and the output of the QAQR can be expressed by Boolean algebra as follows (\u201c\u2295\u201d denotes modulo-2 addition, i.e. XOR)\nS = 2n\u22121\u2295 j=0 ( n\u22121\u220f k=0 A (jk) k ) R[j], (16)\nwhere (jn\u22121jn\u22122 \u00b7 \u00b7 \u00b7 j0)2 is the binary representation of j, and\nA (b) k =\n{ not(Ak), b = 0\nAk, b = 1.\nThe QAQR is then defined by\nQAQR |A\u3009 |0\u3009 = |A\u3009 |S\u3009 . (17)\nSince in (16) there are 2n terms, where each term includes n AND operations, direct implementation (16) of this single-qubit n-addressed multiplexer requires 2n copies of (n + 1)-input AND gates and n2n\u22121 X gates. The AND gate consumption is reasonable because the scale of input data R[j] is also O(2n), but we can reduce the number of X gates to 2n, i.e., a linear reduction, by traversing all the terms following the Gray code [47]. Thus, we have designed a quantum-addressed multiplexer that consumes O(2n), i.e., linear number of gates with respect to the scale of the input data. Based on this design of single-qubit n-addressed quantum multiplexer, we can contruct an n-addressed quantum register file of length L qubits, by simply stacking L copies of single-qubit naddressed quantum multiplexer, within O(Ln2n) gates (the factor n comes from implementing the AND gate)."
        },
        {
            "heading": "4. Algorithm Design",
            "text": "Our GQ-TSP algorithm can be summarized as follows:\nAlgorithm 1 GQ-TSP Algorithm\nInput: Quantum registers of lengths mN, t, 1, 1, 1\nqubits, represented by |C\u3009, |T \u3009, |RCLC\u3009, |RHCD\u3009, and |R\u3009, respectively.\nOutput: The cycle with the lowest cost C\u2217\n1: i\u2190 0. 2: Iopt \u2190 \u2308 \u03c0 \u221a 2mN/4 \u2309 . 3: |C\u3009 \u2190 |0\u3009\u2297mN , |T \u3009 \u2190 |0\u3009\u2297t. 4: |RCLC\u3009 \u2190 |0\u3009, |RHCD\u3009 \u2190 |0\u3009. 5: |R\u3009 \u2190 |\u2212\u3009. 6: Select a proper comparing threshold Cth from several\nsamples on the graph.\n7: Initialize |C\u3009 and |T \u3009 to uniform superposition state: |C\u3009 \u2297 |T \u3009 \u2297 |RCLC\u3009 \u2297 |RHCD\u3009 \u2297 |R\u3009 = \u2211 C aC |C\u3009 \u2297\u2211 k |k\u3009 \u2297 |0\u3009 \u2297 |0\u3009 \u2297 |\u2212\u3009 (aC = 1\u221a2mN ) 8: while i < Iopt do 9: Apply controlled-U gates to |T \u3009, controlled by |C\u3009, c = cost(|C\u3009): \u2192\u2211C (aC |C\u3009 \u2297\u2211k e2\u03c0ikc/2t |k\u3009 \u2297 |0\u3009 \u2297 |0\u3009 \u2297 |\u2212\u3009) 10: Apply iQFT to |T \u3009, obtaining the cost of each |C\u3009: \u2192\u2211C (aC |C\u3009 \u2297 |c\u3009 \u2297 |0\u3009 \u2297 |0\u3009 \u2297 |\u2212\u3009) 11: Use quantum comparator to compare |c\u3009 with the threshold Cth:\n13\n\u2192\u2211C (aC |C\u3009 \u2297 |c\u3009 \u2297 |1c<Cth\u3009 \u2297 |0\u3009 \u2297 |\u2212\u3009) 12: Uncompute and restore |T \u3009 to the initial state \u2192\u2211C (aC |C\u3009 \u2297\u2211k |k\u3009 \u2297 \u2223\u22231{c<Cth}\u232a\u2297 |0\u3009 \u2297 |\u2212\u3009) 13: Use HCD oracle to set |RHCD\u3009: \u2192\u2211C (aC |C\u3009 \u2297\u2211k |k\u3009 \u2297 \u2223\u22231{c<Cth}\u232a\u2297 \u2223\u22231{C valid}\u232a \u2297 |\u2212\u3009)\n14: Apply Toffoli gate on |R\u3009, where 1C = 1{c<Cth} \u00b7 1{C valid}:\n\u2192\u2211C (aC |C\u3009 \u2297\u2211k |k\u3009 \u2297 \u2223\u22231{c<Cth}\u232a\u2297 \u2223\u22231{C valid}\u232a \u2297(\u22121)1C |\u2212\u3009\n) 15: Uncompute |RHCD\u3009: \u2192\u2211C ((\u22121)1CaC |C\u3009 \u2297\u2211k |k\u3009 \u2297 \u2223\u22231{c<Cth}\u232a \u2297 |0\u3009 \u2297 |\u2212\u3009)\n16: Uncompute |RCLC\u3009: \u2192\u2211C ((\u22121)1CaC |C\u3009 \u2297\u2211k |k\u3009 \u2297 |0\u3009 \u2297 |0\u3009 \u2297 |\u2212\u3009)\n17: Apply the diffusion operator, which is equivalent\nto updating the coefficient aC : \u2192 (2 |\u03c8\u3009 \u3008\u03c8| \u2212 I)\u2211C ((\u22121)1CaC |C\u3009 \u2297\u2211k |k\u3009 \u2297 |0\u3009 \u2297 |0\u3009 \u2297 |\u2212\u3009)\n18: i\u2190 i+ 1 19: end while 20: C\u2217 \u2190 Measurement result of |C\u3009\nIt is worth noting that, more ancillary qubits may be used during the execution of CLC and HCD oracles, which are not directly shown in the input of Algorithm 1.\n[1] Montanaro, A. Quantum algorithms: an overview. npj Quantum Information 2, 1\u20138 (2016). [2] Arute, F. et al. Quantum supremacy using a programmable superconducting processor. Nature 574, 505\u2013510 (2019). URL https://www.nature.com/ articles/s41586-019-1666-5. [3] Aharonov, D. et al. Adiabatic quantum computation is equivalent to standard quantum computation. SIAM review 50, 755\u2013787 (2008). [4] Shor, P. W. Algorithms for quantum computation: Discrete logarithms and factoring. In Proceedings 35th annual symposium on foundations of computer science, 124\u2013134 (IEEE, 1994). [5] Grover, L. K. A fast quantum mechanical algorithm for database search. In Proceedings of the twenty-eighth annual ACM symposium on Theory of computing, 212\u2013219 (1996). [6] Boyer, M., Brassard, G., H\u00f8yer, P. & Tapp, A. Tight bounds on quantum searching. Fortschritte der Physik: Progress of Physics 46, 493\u2013505 (1998). [7] Cerezo, M. et al. Variational quantum algorithms. Nature Reviews Physics 3, 625\u2013644 (2021). [8] Biamonte, J. et al. Quantum machine learning. Nature 549, 195\u2013202 (2017). [9] Farhi, E., Goldstone, J., Gutmann, S. & Sipser, M. Quantum computation by adiabatic evolution. arXiv preprint quant-ph/0001106 (2000). [10] Albash, T. & Lidar, D. A. Adiabatic quantum computation. Reviews of Modern Physics 90, 015002 (2018). [11] Apolloni, B., Carvalho, C. & de Falco, D. Quantum stochastic optimization. Stochastic Processes and their Applications 33, 233\u2013244 (1989). URL https://www.sciencedirect.com/science/article/\npii/0304414989900409. [12] Finnila, A. B., Gomez, M., Sebenik, C., Stenson, C. &\nDoll, J. D. Quantum annealing: A new method for minimizing multidimensional functions. Chemical physics letters 219, 343\u2013348 (1994). [13] Das, A. & Chakrabarti, B. K. Colloquium: Quantum annealing and analog quantum computation. Reviews of Modern Physics 80, 1061 (2008).\n[14] Gilliam, A., Woerner, S. & Gonciulea, C. Grover adaptive search for constrained polynomial binary optimization. Quantum 5, 428 (2021). [15] Harwood, S. et al. Formulating and solving routing problems on quantum computers. IEEE Transactions on Quantum Engineering 2, 1\u201317 (2021). [16] McGeoch, C. C. & Wang, C. Experimental evaluation of an adiabiatic quantum system for combinatorial optimization. In Proceedings of the ACM International Conference on Computing Frontiers, 1\u201311 (2013). [17] Ushijima-Mwesigwa, H. et al. Multilevel combinatorial optimization across quantum architectures. ACM Transactions on Quantum Computing 2, 1\u201329 (2021). [18] Guerreschi, G. G. & Matsuura, A. Y. QAOA for MaxCut requires hundreds of qubits for quantum speed-up. Scientific reports 9, 1\u20137 (2019). [19] Fuchs, F. G., Kolden, H. \u00d8., Aase, N. H. & Sartor, G. Efficient encoding of the weighted max k-cut on a quantum computer using qaoa. SN Computer Science 2, 1\u201314 (2021). [20] Khumalo, M. T., Chieza, H. A., Prag, K. & Woolway, M. An investigation of ibm quantum computing device performance on combinatorial optimisation problems. arXiv preprint arXiv:2107.03638 (2021). [21] Ajagekar, A. & You, F. Quantum computing for energy systems optimization: Challenges and opportunities. Energy 179, 76\u201389 (2019). [22] Marton\u030ca\u0301k, R., Santoro, G. E. & Tosatti, E. Quantum annealing of the traveling-salesman problem. Physical Review E 70, 057701 (2004).\n[23] Salehi, O\u0308., Glos, A. & Miszczak, J. A. Unconstrained binary models of the travelling salesman problem variants for quantum optimization. Quantum Information Processing 21, 1\u201330 (2022). [24] Durr, C. & Hoyer, P. A quantum algorithm for finding the minimum. arXiv preprint quant-ph/9607014 (1996). [25] Nielsen, M. A. & Chuang, I. Quantum computation and quantum information (2002). [26] Schmidt-Kaler, F. et al. Realization of the Cirac\u2013Zoller controlled-NOT quantum gate. Nature 422, 408\u2013411 (2003).\n14\n[27] Han, K.-H. & Kim, J.-H. Genetic quantum algorithm and its application to combinatorial optimization problem. In Proceedings of the 2000 congress on evolutionary computation. CEC00 (Cat. No. 00TH8512), vol. 2, 1354\u20131360 (IEEE, 2000). [28] Ishikawa, N. Quantum speedup for index modulation. IEEE Access 9, 111114\u2013111124 (2021). [29] Preskill, J. Quantum computing in the NISQ era and beyond. Quantum 2, 79 (2018). [30] Laporte, G. The traveling salesman problem: An overview of exact and approximate algorithms. European Journal of Operational Research 59, 231\u2013247 (1992). [31] Chauhan, C., Gupta, R. & Pathak, K. Survey of methods of solving tsp along with its implementation using dynamic programming approach. International journal of computer applications 52 (2012). [32] Christofides, N. Worst-case analysis of a new heuristic for the travelling salesman problem. Tech. Rep., CarnegieMellon Univ Pittsburgh Pa Management Sciences Research Group (1976). [33] Helsgaun, K. An effective implementation of the Lin\u2013 Kernighan traveling salesman heuristic. European journal of operational research 126, 106\u2013130 (2000). [34] Johnson, D. S. Local optimization and the traveling salesman problem. In International colloquium on automata, languages, and programming, 446\u2013461 (Springer, 1990). [35] Bengio, Y., Lodi, A. & Prouvost, A. Machine learning for combinatorial optimization: a methodological tour d\u2019horizon. European Journal of Operational Research 290, 405\u2013421 (2021). [36] Lombardi, M. & Milano, M. Boosting combinatorial problem modeling with machine learning. arXiv preprint arXiv:1807.05517 (2018). [37] Heim, B., Brown, E. W., Wecker, D. & Troyer, M. Designing adiabatic quantum optimization: A case study for the traveling salesman problem. arXiv preprint arXiv:1702.06248 (2017). [38] Warren, R. H. Adapting the traveling salesman problem to an adiabatic quantum computer. Quantum information processing 12, 1781\u20131785 (2013). [39] Kieu, T. D. The travelling salesman problem and adiabatic quantum computation: an algorithm. Quantum Information Processing 18, 1\u201319 (2019). [40] Srinivasan, K., Satyajit, S., Behera, B. K. & Panigrahi, P. K. Efficient quantum algorithm for solving travelling salesman problem: An IBM quantum experience. arXiv preprint arXiv:1805.10928 (2018). [41] Akiyama, T., Nishizeki, T. & Saito, N. NP-completeness of the Hamiltonian cycle problem for bipartite graphs. Journal of Information processing 3, 73\u201376 (1980). [42] Wong, L.-P., Low, M. Y. H. & Chong, C. S. An efficient bee colony optimization algorithm for traveling salesman problem using frequency-based pruning. In 2009 7th IEEE International Conference on Industrial Informatics, 775\u2013782 (IEEE, 2009). [43] Csaba, B., Karpinski, M. & Krysta, P. Approximability of dense and sparse instances of minimum 2-connectivity, tsp and path problems. In Proceedings of the thirteenth annual ACM-SIAM symposium on Discrete algorithms, 74\u201383 (2002). [44] Rotman, J. J. An introduction to the theory of groups, vol. 148 (Springer Science & Business Media, 2012). [45] Almudever, C. G. et al. The engineering challenges in quantum computing. In Design, Automation & Test in\nEurope Conference & Exhibition (DATE), 2017, 836\u2013845 (IEEE, 2017). [46] Xu, S. Reversible logic synthesis with minimal usage of ancilla bits. arXiv preprint arXiv:1506.03777 (2015). [47] Bitner, J. R., Ehrlich, G. & Reingold, E. M. Efficient generation of the binary reflected gray code and its applications. Communications of the ACM 19, 517\u2013521 (1976).\n15\nOriginal Graph Iteration 1 Iteration 3\nIteration 5 Iteration 7\n0 10 20 0.0\n0.2\n0.4\n0.6\n0.8\n1.0\n1.2\nPr ob\nab ilit\nSample Probabilit 1st short c cle 2nd short c cle 3rd short c cle\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\nFIG. S1. N = 4, statistical accumulative data of the output of our quantum circuit.\nSUPPLEMENTARY NUMERICAL RESULTS.\nWe present our experimental results in the simplest cases: N = 4, 5, 6. To ensure that our numerical simulation experiment can be carried out by a classical computer within reasonable time, we assume that the maximum degree of the TSP graph does not exceed 4, i.e. d \u2264 4. So m = 2 is sufficient for encoding each path choice.\nThe graphs are randomly generated with edge weights drawn from a uniform distribution on [0, 1], and subject to the degree constraint dv \u2264 4. After different numbers of iterations, we sampled the output of the quantum circuit, and recorded the frequency of each edge being observed. As we can see in the first five subfigures of each case, the frequency of the shortest path grows steadily as the number of Grover iterations increases. Furthermore, the sample probability of the shortest path also takes a sinusoidal waveform, which is consistent with the theory of a Grover rotation.\nFor each case N = 4, 5, 6, 7, we can empirically find the optimal iteration number Iopt = argmaxk P1(k) where the probability of observing the shortest cycle reaches its maximum, where P1(k) denotes the observing probability of the 1-st short cycle after k Grover iterations.\nn N Iopt 4 16 8 5 32 18 6 64 27 7 128 70\n16\nOriginal Graph Iteration 3 Iteration 7\nIteration 12 Iteration 18\n0 10 20 30 40 0.0\n0.2\n0.4\n0.6\n0.8\n1.0\n1.2\nPr ob\nab ilit\ny\nSample Probability 1st short cycle 2nd short cycle 3rd short cycle\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\nFIG. S2. N = 5, statistical accumulative data of the output of our quantum circuit."
        }
    ],
    "title": "A Realizable GAS-based Quantum Algorithm for Traveling Salesman Problem",
    "year": 2022
}