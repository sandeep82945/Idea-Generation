{
    "abstractText": "Skyline query processing is essential to the database community. Many algorithms have been designed to perform efficient skyline computation, which can be generally categorized into sorting-based and partitioning-based by considering the different mechanisms to reduce the dominance tests. Sorting-based skyline algorithms first sort all points with respect to a monotone score function, for instance the sum of all values of a point, then the dominance tests can be bounded by the score function; partitioning-based algorithms create partitions from the dataset so that the dominance tests can be limited in partitions. On the other hand, the incomparability between points has been considered as an important property, that is, if two points are incomparable, then any dominance test between them is unnecessary. In fact, the state-of-the-art skyline algorithms effectively reduce the dominance tests by taking the incomparability into account. In this paper, we present a subset-based approach that allows to integrate subspace-based incomparability to existing sorting-based skyline algorithms and can therefore significantly reduce the total number of dominance tests in large multidimensional datasets. Our theoretical and experimental studies show that the proposed subset approach boosts existing sorting-based skyline algorithms and makes them comparable to the state-ofthe-art algorithms and even faster with uniform independent data.",
    "authors": [
        {
            "affiliations": [],
            "name": "Dominique H. Li"
        }
    ],
    "id": "SP:496a27d87b6e54cb183cbdf9610946467267d768",
    "references": [
        {
            "authors": [
                "Ilaria Bartolini",
                "Paolo Ciaccia",
                "Marco Patella"
            ],
            "title": "Salsa: Computing the skyline without scanning the whole sky",
            "venue": "In CIKM,",
            "year": 2006
        },
        {
            "authors": [
                "Ilaria Bartolini",
                "Paolo Ciaccia",
                "Marco Patella"
            ],
            "title": "Efficient sort-based skyline evaluation",
            "venue": "ACM Transactions on Database Systems (TODS),",
            "year": 2008
        },
        {
            "authors": [
                "Kenneth S B\u00f8gh",
                "Sean Chester",
                "Darius \u0160idlauskas",
                "Ira Assent"
            ],
            "title": "Hashcube: A data structure for space-and query-efficient skycube compression",
            "venue": "In CIKM,",
            "year": 2014
        },
        {
            "authors": [
                "Stephan Borzsony",
                "Donald Kossmann",
                "Konrad Stocker"
            ],
            "title": "The skyline operator",
            "venue": "In ICDE, pages 421\u2013430,",
            "year": 2001
        },
        {
            "authors": [
                "Moses Charikar",
                "Piotr Indyk",
                "Rina Panigrahy"
            ],
            "title": "New algorithms for subset query, partial match, orthogonal range searching, and related problems",
            "venue": "In International Colloquium on Automata, Languages, and Programming,",
            "year": 2002
        },
        {
            "authors": [
                "Sean Chester",
                "Darius \u0160idlauskas",
                "Ira Assent",
                "Kenneth S B\u00f8gh"
            ],
            "title": "Scalable parallelization of skyline computation for multi-core processors",
            "venue": "In ICDE,",
            "year": 2015
        },
        {
            "authors": [
                "Jan Chomicki",
                "Parke Godfrey",
                "Jarek Gryz",
                "Dongming Liang"
            ],
            "title": "Skyline with presorting",
            "venue": "In ICDE,",
            "year": 2003
        },
        {
            "authors": [
                "Jan Chomicki",
                "Parke Godfrey",
                "Jarek Gryz",
                "Dongming Liang"
            ],
            "title": "Skyline with presorting: Theory and optimizations",
            "venue": "In Intelligent Information Processing and Web Mining,",
            "year": 2005
        },
        {
            "authors": [
                "Parke Godfrey",
                "Ryan Shipley",
                "Jarek Gryz"
            ],
            "title": "Maximal vector computation in large data sets",
            "venue": "In VLDB,",
            "year": 2005
        },
        {
            "authors": [
                "Parke Godfrey",
                "Ryan Shipley",
                "Jarek Gryz"
            ],
            "title": "Algorithms and analyses for maximal vector computation",
            "venue": "The VLDB Journal,",
            "year": 2007
        },
        {
            "authors": [
                "Donald Kossmann",
                "Frank Ramsak",
                "Steffen Rost"
            ],
            "title": "Shooting stars in the sky: An online algorithm for skyline queries",
            "venue": "In VLDB,",
            "year": 2002
        },
        {
            "authors": [
                "Hsiang-Tsung Kung",
                "Fabrizio Luccio",
                "Franco P Preparata"
            ],
            "title": "On finding the maxima of a set of vectors",
            "venue": "Journal of the ACM (JACM),",
            "year": 1975
        },
        {
            "authors": [
                "Jongwuk Lee",
                "Seung-won Hwang"
            ],
            "title": "Bskytree: scalable skyline computation using a balanced pivot selection",
            "venue": "In EDBT,",
            "year": 2010
        },
        {
            "authors": [
                "Jongwuk Lee",
                "Seung-won Hwang"
            ],
            "title": "Scalable skyline computation using a balanced pivot selection technique",
            "venue": "Information Systems,",
            "year": 2014
        },
        {
            "authors": [
                "Jongwuk Lee",
                "Seung-won Hwang"
            ],
            "title": "Toward efficient multidimensional subspace skyline computation",
            "venue": "The VLDB Journal,",
            "year": 2014
        },
        {
            "authors": [
                "Ken CK Lee",
                "Wang-Chien Lee",
                "Baihua Zheng",
                "Huajing Li",
                "Yuan Tian"
            ],
            "title": "Z-sky: an efficient skyline query processing framework based on z-order",
            "venue": "The VLDB Journal,",
            "year": 2010
        },
        {
            "authors": [
                "Bin Liu",
                "Chee-Yong Chan"
            ],
            "title": "Zinc: Efficient indexing for skyline computation",
            "venue": "Proceedings of the VLDB Endowment,",
            "year": 2010
        },
        {
            "authors": [
                "Rui Liu",
                "Dominique Li"
            ],
            "title": "Efficient skyline computation in highdimensionality domains",
            "venue": "In EDBT,",
            "year": 2020
        },
        {
            "authors": [
                "Michael Morse",
                "Jignesh M Patel",
                "Hosagrahar V Jagadish"
            ],
            "title": "Efficient skyline computation over low-cardinality domains",
            "venue": "In VLDB,",
            "year": 2007
        },
        {
            "authors": [
                "Dimitris Papadias",
                "Yufei Tao",
                "Greg Fu",
                "Bernhard Seeger"
            ],
            "title": "An optimal and progressive algorithm for skyline queries",
            "venue": "In SIGMOD,",
            "year": 2003
        },
        {
            "authors": [
                "Dimitris Papadias",
                "Yufei Tao",
                "Greg Fu",
                "Bernhard Seeger"
            ],
            "title": "Progressive skyline computation in database systems",
            "venue": "ACM Transactions on Database Systems (TODS),",
            "year": 2005
        },
        {
            "authors": [
                "Jian Pei",
                "Wen Jin",
                "Martin Ester",
                "Yufei Tao"
            ],
            "title": "Catching the best views of skyline: A semantic approach based on decisive subspaces",
            "venue": "In VLDB,",
            "year": 2005
        },
        {
            "authors": [
                "Jian Pei",
                "Yidong Yuan",
                "Xuemin Lin",
                "Wen Jin",
                "Martin Ester",
                "Qing Liu",
                "Wei Wang",
                "Yufei Tao",
                "Jeffrey Xu Yu",
                "Qing Zhang"
            ],
            "title": "Towards multidimensional subspace skyline analysis",
            "venue": "ACM Transactions on Database Systems (TODS),",
            "year": 2006
        },
        {
            "authors": [
                "Cheng Sheng",
                "Yufei Tao"
            ],
            "title": "Worst-case i/o-efficient skyline algorithms",
            "venue": "ACM Transactions on Database Systems (TODS),",
            "year": 2012
        },
        {
            "authors": [
                "Kian-Lee Tan",
                "Pin-Kwang Eng",
                "Beng Chin Ooi"
            ],
            "title": "Efficient progressive skyline computation",
            "venue": "In VLDB,",
            "year": 2001
        },
        {
            "authors": [
                "Yufei Tao",
                "Xiaokui Xiao",
                "Jian Pei"
            ],
            "title": "Subsky: Efficient computation of skylines in subspaces",
            "venue": "In ICDE,",
            "year": 2006
        },
        {
            "authors": [
                "Shiming Zhang",
                "Nikos Mamoulis",
                "David W Cheung"
            ],
            "title": "Scalable skyline computation using object-based space partitioning",
            "venue": "In SIGMOD,",
            "year": 2009
        }
    ],
    "sections": [
        {
            "text": ""
        },
        {
            "heading": "1 INTRODUCTION",
            "text": "Given a set of multidimensional points, the skyline operator [4] returns the skyline that is the set of all non-dominated points. A point \ud835\udc5d\ud835\udc56 is said non-dominated if there is no any other point \ud835\udc5d \ud835\udc57 such that \ud835\udc5d \ud835\udc57 is better than \ud835\udc5d\ud835\udc56 in all dimensions with respect to a user defined preference order. Figure 1 shows a skyline example that is very commonly used in the literature: assume a set of hotels where we want to select the ones with minimized price (Y axis) and distance from the beach (X axis), then the hotels {\ud835\udc4e, \ud835\udc50, \ud835\udc52, \u210e,\ud835\udc5a} form the skyline because no other hotels can be better than them on both of the price and the distance from the beach. The skyline computation problem has received intensive attention from the database community.\nThe simplest way to compute the skyline is nested loop-based pairwise comparison: for each point \ud835\udc5d\ud835\udc56 in the dataset, compare \ud835\udc5d\ud835\udc56 with each other point \ud835\udc5d \ud835\udc57 , if \ud835\udc5d\ud835\udc56 dominates \ud835\udc5d \ud835\udc57 , then drop \ud835\udc5d \ud835\udc57 ; if \ud835\udc5d \ud835\udc57 dominates \ud835\udc5d\ud835\udc56 , then drop the point \ud835\udc5d\ud835\udc56 and break the nested loop; otherwise, continue the nested loop while keeping both \ud835\udc5d\ud835\udc56 and \ud835\udc5d \ud835\udc57 . Such a nested loop procedure finally outputs the set of all non-dominated points in O(\ud835\udc51\ud835\udc41 2) time where \ud835\udc51 is the number of dimensions in each point and \ud835\udc41 is the number of points in the dataset, if we consider O(\ud835\udc51) time for testing the dominance relation (dominance test) between two points of \ud835\udc51 dimensions.\n\u00a9 2023 Copyright held by the owner/author(s). Published in Proceedings of the 26th International Conference on Extending Database Technology (EDBT), 28th March-31st March, 2023, ISBN 978-3-89318-093-6 on OpenProceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0.\nThe dominance tests are the major cost of skyline computation. In order to efficiently resolve the skyline computation problem, many algorithms have been designed and developed based on the reduction of dominance testes, which can be categorized into two classes [14]: sorting-based (such as BNL [4], Index [25], SFS [7, 8], LESS [9, 10], SaLSa [1, 2], BSkyTree-S [13, 14], and SDI [18]) and partitioning-based (such as D&C [4], NN [11], BBS [20, 21], LS [19], OSPS [27], ZSearch [16], and BSkyTree-P [13, 14]). Besides, indexing techniques are also applied to skyline algorithms, such as Index, BBS, ZINC [17], and SDI, with different mechanisms.\nGodfrey et al. [9, 10] and Sheng and Tao [24] theoretically analyzed the time complexity of existing skyline algorithms and concluded that in the worst case, sorting-based algorithms finish in O(\ud835\udc51\ud835\udc41 2) time, however partitioning-based algorithms can finish in O(\ud835\udc41 log\ud835\udc51\u22122 \ud835\udc41 ) time for any dimensionality\ud835\udc51 > 2. Godfrey et al. [9, 10] also gave a time complexity analysis for the average case under the uniform independence and component independence conditions. Essentially, the efficiency of a skyline algorithm heavily relies on how dominance tests are reduced. As the state-ofthe-art skyline algorithms, BSkyTree-S and BSkyTree-P use a pivot point selection schema to map data points to incomparable regions, each can be considered as an optimized algorithm of sorting-based and partitioning-based categories.\nBasically, given a \ud835\udc51-dimensional space, a subspace [22] is a subset of all \ud835\udc51 dimensions, which is extended studied with several skyline problems such as subspace skyline [15, 23, 26] and skycube [3, 23]. Let P be the dataset, \ud835\udc5d \u2208 P be a skyline point, and \ud835\udc5e \u2208 P be any point such that \ud835\udc5d \u2260 \ud835\udc5e, then, if \ud835\udc5d does not dominate \ud835\udc5e, there must exist a subspace where in each dimension the value of \ud835\udc5e is better than the value of \ud835\udc5d , that is, \ud835\udc5e dominates \ud835\udc5d in this subspace. We call such a subspace a dominating subspace. If all points dominated by the skyline point \ud835\udc5d have been pruned, each point that remains in the dataset must possess a dominating subspace where it dominates \ud835\udc5d . Indeed, the above skyline point \ud835\udc5d , also called a pivot point, is used by the BSkyTree-S and BSkyTree-P algorithms to partition points into incomparable regions in order to reduce the dominance tests.\nIn this paper, we present a novel subspace-based skyline indexing approach to manage the incomparability between testing\nSeries ISSN: 2367-2005 391 10.48786/edbt.2023.31\npoints and skyline points. Instead of partitioning the dataset, our method indexes the skyline points by dominating subspaces to reduce the dominance tests. We first show that the dominating subspace of a point can be merged with respect to multiple pivot points, called maximum dominating subspace with respect to a given number of pivot points, then, we show that if a point \ud835\udc5e1 dominates a point \ud835\udc5e2, \ud835\udc5e1\u2019s maximum dominating subspaces with respect to each pivot point must be a superset of \ud835\udc5e2\u2019s maximum dominating subspaces. Based on the properties presented in this paper, the sketch of the application of our method can be described as following:\n(1) Find multiple pivot points to generate the maximum dominating subspace for each non-pruned point. (2) Run a skyline algorithm with the following new actions: (a) Once a skyline point is determined, put it to the pro-\nposed skyline index structure with respect to its maximum dominating subspace. (b) While testing a point with the current skyline, get only the set of comparable points from the skyline index structure with respect to the maximum dominating subspace.\n(3) Return the skyline.\nTherefore, our proposed method does not concern concrete skyline computation algorithms because it is designed as a component like a container that allows to store (as put function) the skyline points and to retrieve (as a get function) a minimum number of skyline points to compare with a testing point. The paradigm of our method fits best sorting-based skyline algorithms that can progressively output the skyline points, however partitioning-based skyline algorithms cannot benefit much from our method because the data have already been partitioned and the dominance tests are limited in partitions, the double partitioning of data and skyline brings additional costs. Therefore, the advantage of our method is to boost existing skyline algorithms. Several sorting-based skyline algorithms such as SFS, SaLSa, and SDI do not depend on any particular data structures (for instance, the lattice and SkyTree required by BSkyTree-S and BSkyTree-P, the ZB-tree required by ZINC, the R-tree required by BBS, and the B+-tree required by Index, etc.), which can be easily implemented in any programming languages including Python and PHP, so to boost such algorithms has realistic interests to data industries.\nThe main result presented in this paper is that the skyline indexing can be efficiently resolved by a subset query. The subset query problem is defined as: given a set X of distinct subsets of a universe \ud835\udc37 , for any set\ud835\udc44 \u2286 \ud835\udc37 , return the set {\ud835\udc44 \u2032 \u2208 X | \ud835\udc44 \u2282 \ud835\udc44 \u2032} that contains all supersets of \ud835\udc44 . The set \ud835\udc44 is called the query set. Indeed, given a testing point, its maximum dominating subspace can be considered as a query set, the task is to return all skyline points of which the maximum dominating subspaces are the supersets of the query set, hence, the required dominance tests can be limited in returned skyline points. In order to make our method efficient, we reversed the subset query problem, that is, to return the set {\ud835\udc44 \u2032 \u2208 X | \ud835\udc44 \u2032 \u2282 \ud835\udc44}. The subset query data structure and algorithms proposed in this paper is hash map based (supported by the most of programming languages), which can add a skyline point in linear time with respect to the dimensionality \ud835\udc51 and can retrieve a set of skyline points with respect to a given subspace in \ud835\udc42 ((\ud835\udc51 2 )2) time in the average case for any \ud835\udc51 > 2. Particularly, in the case of \ud835\udc51 = 2, subset query is\na binary problem so the usefulness of our proposed method is very limited.\nOur experimental results based on SFS, SaLSa, and SDI show the effectiveness and efficiency of our method. We note that the data types considered in skyline computation is generally categorized as [4] anti-correlated (AC), correlated (CO), and uniform independent (UI) with respect to the characteristics of real data, however, in literature, there is no single algorithm be the best on all these three types of data. For instance, BSkyTree-S performs much better than BSkyTree-P on CO data, however BSkyTree-P is the best algorithm on AC and UI data. In our experiments, the boosted SFS, SaLSa, or SDI perform better than BSkyTree-P on UI data.\nThe rest of this paper is organized as follows. Section 2 reviews previous skyline algorithms. Section 3 defines preliminary concepts required by the formalization. We show in Section 4 that the maximum dominating subspace of each point can be merged from multiple pivot points and propose a subspace union algorithm. In Section 5, we present our subset approach to index the skyline, with store and query algorithms. Section 6 reports our experimental evaluation, which shows the performance of our method in boosting skyline algorithms. Finally, we conclude in Section 7."
        },
        {
            "heading": "2 RELATEDWORK",
            "text": "In this section, we review mainstream skyline algorithms by categorizing them into sorting-based and partitioning-based classes. We also discuss the use of indexing techniques in existing skyline algorithms.\nIn general, typical sorting-based skyline algorithms such as SFS [7, 8] presort all points by amonotone sorting function \ud835\udc53 such that for any two points \ud835\udc5d\ud835\udc56 and \ud835\udc5d \ud835\udc57 , we have \ud835\udc53 (\ud835\udc5d\ud835\udc56 ) < \ud835\udc53 (\ud835\udc5d \ud835\udc57 ) \u21d2 \ud835\udc5d \ud835\udc57 \u2280 \ud835\udc5d\ud835\udc56 (we denote by \ud835\udc5d\ud835\udc56 \u227a \ud835\udc5d \ud835\udc57 that \ud835\udc5d\ud835\udc56 dominates \ud835\udc5d \ud835\udc57 and by \ud835\udc5d\ud835\udc56 \u2280 \ud835\udc5d \ud835\udc57 that \ud835\udc5d\ud835\udc56 does not dominate \ud835\udc5d \ud835\udc57 ). If we consider the minima for the skyline, it is clear that the point argmin\ud835\udc5d\u2208P (\ud835\udc53 (\ud835\udc5d)) in the dataset P is immediately the first skyline point, then, by following the order defined by the sorting function \ud835\udc53 , if a point is not dominated by all skyline points, it is a new skyline point and can be added to the skyline.\nThe sorting function used in sorting-based algorithms is heuristic that heavily affects the total number of dominance tests. LESS [9, 10] extends SFS with external sort-merge routines. SaLSa [1, 2] studied different sorting functions with the notion of a stop point that allows to terminate the algorithm by outputting the exact skyline without testing all points. The use of stop point in SaLSa can effectively prune points that are not necessary to be tested. Index [25] builds a B+-tree data structure to sort and index each dimension value of all points in order to prune irrelevant points and to retrieve skyline points by comparing their min/max values. BSkyTree-S first selects a pivot point, then maps any data point to a binary vector w.r.t. the pivot point, so existing sortingbased algorithms can be improved by bypassing dominance tests between incomparable points.\nSDI [18] is a sort-and-scan skyline algorithm that integrates the designs of Index, SFS, and SaLSa. In the sort phase, SDI sorts all indexed data point IDs in each dimension, with respect to the value of each point in each dimension (dimension value), then each point at the top position of each sorted index is immediately a skyline point; in the scan phase, SDI uses the breadth-first strategy to traverse among dimensions. In any dimension, it is necessary to test by progressive depth-first traversal whether all\nknown skyline points in this dimension (called dimension skyline) dominate the current testing point: if the current point is not dominated, then it is a new skyline point and the algorithm switches to the dimension that possesses the least number of skyline points; otherwise, the current point is marked as dominated and it continues to test the next point.\nIn SDI, a testing point can be skipped if it has already been marked as dominated on another dimension or be added to the dimension skyline without test; in the case of duplicate dimension values, that is, the same value in the same dimension for different tuples, SFS-like local dominance tests will be performed among concerned points. Furthermore, any data point can be used as the stop point in SDI, that is, if the progressive depth-first traversal has passed such a point in each dimension, then the algorithm can be safely stopped. In practice, the data point having the minimum Euclidean distance is the most efficient stop point, and by distributing the dominance tests to each dimension, SDI can effectively reduce the total number of dominance tests.\nDifferent from sorting-based algorithm, partitioning-based algorithms divide points to different groups, called partitions (or regions), the dominance tests are limited among the points in the same partition.\nAs a representative divide-and-conquer method, D&C [4] is designed from the algorithm introduced by Kung et al. [12] in order to work with external memory. Basically, D&C partitions the dataset into as fewer as possible blocks to fit in the main memory, then the local skyline will be computed from each block, and recursively the true skyline can be computed from local skyline by applying the basic divide-and-conquer algorithm. The study of Godfrey et al. [9, 10] shows that the average performance of divide-and-conquer methods deteriorates with increasing the dimensionality of data. The study of Sheng and Tao [24] shows that the algorithm presented in [12] requiresO(\ud835\udc512\ud835\udc41 log(\ud835\udc51\u22122) \ud835\udc41 ) time however their result can effectively finish in O(\ud835\udc41 log(\ud835\udc51\u22122) \ud835\udc41 ) time.\nNN [11] partitions the dataset by the nearest neighbor of the query point, then the first nearest neighbor is immediately a skyline point that allows to prune all dominated points; then, the second nearest neighbor can be found in all points that are dominated by the first nearest neighbor in one or several dimensions (a region), and finally all skyline points can be directly output by recursive calls. The effect of NN is similar to SFS and SaLSa if we use Euclidean distance as the sorting function. BBS [20, 21] improves the design of NN by using R-tree to index points that can efficiently prune non-skyline points with dominance tests inside the region. Different techniques have been proposed to perform region-level pruning of non-skyline points, for instance, LS [19] uses a lattice structure, OSPS [27] uses point-based space partition, ZSearch [16] uses Z-order index.\nBSkyTree-P first selects a pivot point, then recursively partitions a specific region into 2\ud835\udc51 disjoint sub-regions in a divide-andconquer manner. Existing partitioning-based skyline algorithms can be improved by the schema of BSkyTree-P.\nOn the other hand, indexing techniques are also widely used in skyline computation to access sorted or partitioned data. For instance, Index uses B+-tree to store the sorted dataset; BBS uses R-tree to partition and indexing the dataset; BSkyTree-S and BSkyTree-P use SkyTree to access indexed dataset; SDI uses indexes to access the dataset from sorted dimension values. In particular, ZINC uses ZB-tree to index the dataset, which can perform skyline computation in both totally ordered and partially\nordered data attribute domains. In this paper, we focus on the skyline computation problem in the totally ordered domain.\nIn our method presented in this paper, we do not index any data points but only the skyline points, in order to minimize the skyline points required by dominance tests, which makes our method being a generic component of skyline algorithms."
        },
        {
            "heading": "3 PRELIMINARY CONCEPTS",
            "text": "We consider a dataset P of \ud835\udc41 \ud835\udc51-dimensional points, where we call \ud835\udc41 the cardinality and \ud835\udc51 the dimensionality of the dataset. Let \ud835\udc5d be a point, we denote \ud835\udc5d [\ud835\udc56] the dimension value of \ud835\udc5d in the dimension \ud835\udc56 , where 1 \u2264 \ud835\udc56 \u2264 \ud835\udc51 . We consider the preference order as a total order in each dimension of points for the skyline.\nWithout loss of generality, the preference order can be defined as the relation < on the values in each dimension. Given two points \ud835\udc5d and \ud835\udc5e, \ud835\udc5d [\ud835\udc56] is better than \ud835\udc5e [\ud835\udc56] if \ud835\udc5d [\ud835\udc56] < \ud835\udc5e [\ud835\udc56]; \ud835\udc5d [\ud835\udc56] is equal to \ud835\udc5e [\ud835\udc56] if \ud835\udc5d [\ud835\udc56] = \ud835\udc5e [\ud835\udc56]; and \ud835\udc5e [\ud835\udc56] is not worse than \ud835\udc5d [\ud835\udc56] if \ud835\udc5d [\ud835\udc56] \u2264 \ud835\udc5e [\ud835\udc56]. To simplify the formal description, in the rest of this paper, any dimension refers to an integer value in the range [1, \ud835\udc51].\nDefinition 3.1. A point \ud835\udc5d dominates a point\ud835\udc5e, denoted by \ud835\udc5d \u227a \ud835\udc5e, if and only if in each dimension \ud835\udc56 we have \ud835\udc5d [\ud835\udc56] \u2264 \ud835\udc5e [\ud835\udc56], and in at least one dimension \ud835\udc58 , 1 \u2264 \ud835\udc58 \u2264 \ud835\udc51 , we have \ud835\udc5d [\ud835\udc58] < \ud835\udc5e [\ud835\udc58]. \u25a0\nGiven two points \ud835\udc5d and \ud835\udc5e, we denote \ud835\udc5d \u2280 \ud835\udc5e that \ud835\udc5d does not dominate \ud835\udc5e; we denote \ud835\udc5d \u2241 \ud835\udc5e \u21d0\u21d2 (\ud835\udc5d \u2280 \ud835\udc5e) \u2227 (\ud835\udc5e \u2280 \ud835\udc5d) that \ud835\udc5d and \ud835\udc5e are incomparable. We extend {\u227a, \u2280, \u2aaf, \u2241} to the set of points: \u2022 \ud835\udc5d \u227a \ud835\udc4b (or \ud835\udc5d \u2aaf \ud835\udc4b ) denotes \u2200\ud835\udc5e \u2208 \ud835\udc4b, \ud835\udc5d \u227a \ud835\udc5e (or \ud835\udc5d \u2aaf \ud835\udc5e); \u2022 \ud835\udc4b \u227a \ud835\udc5d (or \ud835\udc4b \u2aaf \ud835\udc5d) denotes \u2203\ud835\udc5e \u2208 \ud835\udc4b,\ud835\udc5e \u227a \ud835\udc5d (or \ud835\udc5e \u2aaf \ud835\udc5d); \u2022 \ud835\udc4b \u2280 \ud835\udc5d (or \ud835\udc4b \u2aaf\u0338 \ud835\udc5d) denotes \ud835\udc5e \u2208 \ud835\udc4b,\ud835\udc5e \u227a \ud835\udc5d (or \ud835\udc5e \u2aaf \ud835\udc5d); \u2022 \ud835\udc5d \u2241 \ud835\udc4b and \ud835\udc4b \u2241 \ud835\udc5d denote \u2200\ud835\udc5e \u2208 \ud835\udc4b, \ud835\udc5d \u2241 \ud835\udc5e.\nDefinition 3.2. Given a dataset P, a point \ud835\udc5d \u2208 P is a skyline point if and only if \ud835\udc5e \u2208 P such that \ud835\udc5e \u227a \ud835\udc5d . The skyline of P is the complete set of skyline points {\ud835\udc5d \u2208 P | \ud835\udc5e \u2208 P, \ud835\udc5e \u227a \ud835\udc5d}. \u25a0\nThe skyline computation problem is to compute the complete set of skyline points from amultidimensional dataset with respect to a user defined preference order \u227a.\nDefinition 3.3. Given a \ud835\udc51-dimensional dataset P, the set \ud835\udc37 = {1, 2, . . . , \ud835\udc51} is the space of P. Any subset \ud835\udc37\u2032 \u2286 \ud835\udc37 is a subspace of P. \u25a0\nDefinition 3.4. Let \ud835\udc5d and \ud835\udc5e be two points. Let \ud835\udc37\ud835\udc5d\u227a\ud835\udc5e denote the subspace such that \u2200\ud835\udc56 \u2208 \ud835\udc37\ud835\udc5d\u227a\ud835\udc5e \u21d2 \ud835\udc5d [\ud835\udc56] < \ud835\udc5e [\ud835\udc56] and \u2200\ud835\udc56 \u2209 \ud835\udc37\ud835\udc5d\u227a\ud835\udc5e \u21d2 \ud835\udc5e [\ud835\udc56] \u2264 \ud835\udc5d [\ud835\udc56], then \ud835\udc37\ud835\udc5d\u227a\ud835\udc5e is the dominating subspace of \ud835\udc5d with respect to \ud835\udc5e. \u25a0\nAccording to Definition 3.4, given a dataset P, let \ud835\udc37 be the space of P and \ud835\udc5d, \ud835\udc5e \u2208 P be two points, we have: \u2022 \ud835\udc37\ud835\udc5d\u227a\ud835\udc5e = \u2205 \u21d2 \ud835\udc5e \u227a \ud835\udc5d or \ud835\udc5d = \ud835\udc5e; \u2022 \ud835\udc37\ud835\udc5d\u227a\ud835\udc5e = \ud835\udc37 \u21d2 \ud835\udc5d \u227a \ud835\udc5e.\nLemma 3.5. Given a dataset P, let \ud835\udc5d \u2208 P be a skyline point and \ud835\udc5e1, \ud835\udc5e2 \u2208 P, \ud835\udc5e1, \ud835\udc5e2 \u2260 \ud835\udc5d be two arbitrary points such that \ud835\udc5d \u2280 \ud835\udc5e1, \ud835\udc5d \u2280 \ud835\udc5e2, and \ud835\udc5e1 \u2260 \ud835\udc5e2. \ud835\udc5e1 \u2241 \ud835\udc5e2 if \ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d \u2288 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d and \ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d \u2288 \ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d . \u25a0\nProof. \ud835\udc5d is a skyline point, so \ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d \u2260 \ud835\udc37 and \ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d \u2260 \ud835\udc37 , that is, \ud835\udc37\ud835\udc5d\u227a\ud835\udc5e1 \u2260 \ud835\udc37 and \ud835\udc37\ud835\udc5d\u227a\ud835\udc5e2 \u2260 \ud835\udc37 , which impose that \ud835\udc5d \u2280 \ud835\udc5e1 and \ud835\udc5d \u2280 \ud835\udc5e2. We have that \ud835\udc5d \u2280 \ud835\udc5e1 \u21d0\u21d2 \u2203\ud835\udc56, \ud835\udc5e1 [\ud835\udc56] < \ud835\udc5d [\ud835\udc56] and \ud835\udc5d \u2280 \ud835\udc5e2 \u21d0\u21d2 \u2203\ud835\udc56, \ud835\udc5e2 [\ud835\udc56] < \ud835\udc5d [\ud835\udc56], hence, \ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d \u2288 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d implies that there is at least one dimension \ud835\udc56 such that \ud835\udc5e1 [\ud835\udc56] < \ud835\udc5d [\ud835\udc56] \u2264 \ud835\udc5e2 [\ud835\udc56] and \ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d \u2288 \ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d implies that there is at least one dimension \ud835\udc57 such that \ud835\udc5e2 [ \ud835\udc57] < \ud835\udc5d [ \ud835\udc57] \u2264 \ud835\udc5e1 [ \ud835\udc57]. Thus, \ud835\udc5e1 \u2280 \ud835\udc5e2 and \ud835\udc5e2 \u2280 \ud835\udc5e1, that is, \ud835\udc5e1 \u2241 \ud835\udc5e2. \u25a1\nMore simply, Lemma 3.5 can be rewritten as:\n|\ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d \u2229 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d | < \ud835\udc5a\ud835\udc56\ud835\udc5b( |\ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d |, |\ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d |) \u21d2 \ud835\udc5e1 \u2241 \ud835\udc5e2 .\nLemma 3.6. Given a dataset P, let \ud835\udc5d \u2208 P be a skyline point and \ud835\udc5e1, \ud835\udc5e2 \u2208 P, \ud835\udc5e1, \ud835\udc5e2 \u2260 \ud835\udc5d be two arbitrary points such that \ud835\udc5d \u2280 \ud835\udc5e1, \ud835\udc5d \u2280 \ud835\udc5e2, and \ud835\udc5e1 \u2260 \ud835\udc5e2. \ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d \u2289 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d \u21d2 \ud835\udc5e1 \u2280 \ud835\udc5e2. \u25a0\nProof. We have the same context as Lemma 3.5. If \ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d \u2289 \ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d , according to the proof of Lemma 3.5, there exists at least on dimension \ud835\udc56 such that \ud835\udc56 \u2208 \ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d and \ud835\udc56 \u2209 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d , that is,\ud835\udc5e2 [\ud835\udc56] < \ud835\udc5d [\ud835\udc56] \u2264 \ud835\udc5e1 [\ud835\udc56]. Thus, \ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d \u2289 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d \u21d2 \ud835\udc5e1 \u2280 \ud835\udc5e2. \ud835\udc37\ud835\udc5e1\u227a\ud835\udc5d \u2287 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc5d is a necessity of \ud835\udc5e1 \u227a \ud835\udc5e2. \u25a1\nLemma 3.6 shows an inevitable constraint to partition points with respect to Lemma 3.5: if a point \ud835\udc5d is a skyline point in the set of points determined by the subspace \ud835\udc37\ud835\udc65 , then \ud835\udc5d must be compared with all skyline points in the set of points determined by any subspace \ud835\udc37\ud835\udc66 \u2283 \ud835\udc37\ud835\udc65 . Since a \ud835\udc51-dimensional space contains 2\ud835\udc51 \u2212 2 subspaces without \u2205 neither the full space in our context, obviously, the dominance tests can be effectively reduced if all points can be distributed to as many incomparable subspaces as possible."
        },
        {
            "heading": "4 SUBSPACE UNION",
            "text": "In this section, we resolve the unbalanced point distribution problem. According to Lemma 3.5, given a dataset P in space \ud835\udc37 , if a skyline point \ud835\udc5d \u2208 P is compared with each other point \ud835\udc5e \u2208 P, then every non-pruned point \ud835\udc5e can be attributed a dominating subspace \ud835\udc37\ud835\udc5e\u227a\ud835\udc5d , where \ud835\udc37\ud835\udc5e\u227a\ud835\udc5d \u2260 \u2205 and \ud835\udc37\ud835\udc5e\u227a\ud835\udc5d \u2260 \ud835\udc37 .\nFigure 2 shows the distribution of non-pruned points in AC, CO, and UI synthetic datasets1 with 100K points of 8 dimensions, where the pivot point is the skyline point with the minimal Euclidean distance to the zero point. Due to page length limit, it is difficult to list the number of points for all 28 \u2212 2 subspaces, we show in Figure 2 the number of points with respect to subspace size. We see that the distribution of points is unbalanced, most of them are in small-size zones, far away from the 2\ud835\udc51 level. Although recursive calls can be applied to each subspace to find more incomparable subspaces with respect to Lemma 3.5, Lemma 3.6 limits the immediate output of skyline points.\nWe propose a subspace union method to distribute points to as many subspaces as possible , where the term as many as possible is controlled by a given threshold that finally affects the number of pivots points. Given a point, the dominating subspace\n1All concerned synthetic datasets are generated by Skyline Benchmark Data Generator from http://pgfoundry.org/projects/randdataset.\ncan be merged from multiple pivot points, that is, a set of skyline points since all pivot points are skyline points, and we call such a merged subspace a maximum dominating subspace, where the term maximum means the maximum number of dimensions where the given point dominates the pivot points.\nDefinition 4.1. Let \ud835\udc46 be a set of skyline points in a dataset P of space \ud835\udc37 . For a point \ud835\udc5e \u2208 P, the union of dominating subspaces \ud835\udc37\ud835\udc5e\u227a\ud835\udc46 = \u22c3 \ud835\udc5d\u2208\ud835\udc46 \ud835\udc37\ud835\udc5e\u227a\ud835\udc5d , where \ud835\udc37\ud835\udc5e\u227a\ud835\udc46 \u2286 \ud835\udc37 , is the maximum dominating subspace of \ud835\udc5e. \u25a0\nWith the above definition, we have the following extensions of Lemma 3.5 and Lemma 3.6, which are the bases of our results.\nLemma 4.2. Given a dataset P, let \ud835\udc46 be a set of skyline points of P and \ud835\udc5e1, \ud835\udc5e2 \u2208 P be two arbitrary points such that \ud835\udc5e1, \ud835\udc5e2 \u2209 \ud835\udc46 , \ud835\udc46 \u2280 \ud835\udc5e1, \ud835\udc46 \u2280 \ud835\udc5e2, and \ud835\udc5e1 \u2260 \ud835\udc5e2. \ud835\udc5e1 \u2241 \ud835\udc5e2 if \ud835\udc37\ud835\udc5e1\u227a\ud835\udc46 \u2288 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc46 and \ud835\udc37\ud835\udc5e2\u227a\ud835\udc46 \u2288 \ud835\udc37\ud835\udc5e1\u227a\ud835\udc46 . \u25a0\nProof. The proof is as the proof of Lemma 3.5. If \ud835\udc37\ud835\udc5e1\u227a\ud835\udc46 \u2288 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc46 and \ud835\udc37\ud835\udc5e2\u227a\ud835\udc46 \u2288 \ud835\udc37\ud835\udc5e1\u227a\ud835\udc46 , there must be at least one skyline point \ud835\udc5d \u2208 \ud835\udc46 on at least one dimension \ud835\udc56 where \ud835\udc5e1 [\ud835\udc56] < \ud835\udc5d [\ud835\udc56] \u2264 \ud835\udc5e2 [\ud835\udc56] or \ud835\udc5e2 [\ud835\udc56] < \ud835\udc5d [\ud835\udc56] \u2264 \ud835\udc5e1 [\ud835\udc56]. Thus, \ud835\udc5e1 \u2241 \ud835\udc5e2. \u25a1\nLemma 4.3. Given a dataset P, let \ud835\udc46 be a set of skyline points of P and \ud835\udc5e1, \ud835\udc5e2 \u2208 P be two arbitrary points such that \ud835\udc5e1, \ud835\udc5e2 \u2209 \ud835\udc46 , \ud835\udc46 \u2280 \ud835\udc5e1, \ud835\udc46 \u2280 \ud835\udc5e2, and \ud835\udc5e1 \u2260 \ud835\udc5e2. \ud835\udc37\ud835\udc5e1\u227a\ud835\udc46 \u2289 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc46 \u21d2 \ud835\udc5e1 \u2280 \ud835\udc5e2. \u25a0\nProof. If \ud835\udc5e1 \u227a \ud835\udc5e2, then \u2200\ud835\udc56 \u2208 \ud835\udc37,\ud835\udc5e1 [\ud835\udc56] \u2264 \ud835\udc5e2 [\ud835\udc56]. If \ud835\udc37\ud835\udc5e1\u227a\ud835\udc46 \u2289 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc46 , then there exists at least one skyline point \ud835\udc5d \u2208 \ud835\udc46 on at least one dimension \ud835\udc56 where \ud835\udc5e2 [\ud835\udc56] < \ud835\udc5d [\ud835\udc56] \u2264 \ud835\udc5e1 [\ud835\udc56]. Thus, \ud835\udc5e1 \u2280 \ud835\udc5e2. \u25a1\nIn practice, it is difficult to determine the number of pivot points, an optimal value depends on many factors including the number of all skyline points, which should be considered as unknown. Too few pivot points cannot distribute all points to a large number of subspaces but too many pivot points will clearly slow down our method. In general, we use a sorting-based process to select pivot points and merge dominating subspaces, the maximum dominating subspace is constructed in iteration. Each skyline point can assign a dominating subspace to a point \ud835\udc5e \u2208 P and all dominated points will be pruned.\nIn each iteration, we determine the change of point number of each subspace size, that is, the number of points within the same subspace with the same size, which is limited by \ud835\udc51 \u2212 1 instead of all 2\ud835\udc51 \u22122 subspaces. Let P be the dataset and\ud835\udc37\ud835\udc5e be the maximum dominating subspace of a point \ud835\udc5e \u2208 P, then, for each point \ud835\udc5e, the subspace \ud835\udc37\ud835\udc5e may be changed by current pivot point \ud835\udc5d as \ud835\udc37\ud835\udc5e \u222a \ud835\udc37\ud835\udc5e\u227a\ud835\udc5d . Hence, we propose a heuristic measure, the stability\nthreshold, denoted by \ud835\udf0e , to stop merging dominating subspaces. The stability threshold is the number of subspace sizes that do not change while iterating, which means that no new pivot points are necessary to continue to change the maximum dominating subspaces.\nThe following Algorithm 1 merges dominating subspaces of each non-pruned point in a dataset. The algorithm stops while the stability threshold is reached.\nAlgorithm 1:Merge Input: The dataset P and the stability threshold \ud835\udf0e Output: The initial skyline \ud835\udc46 of P and P with\nnon-pruned points 1 Score each point \ud835\udc5e \u2208 P by Euclidean distance to the zero\npoint 2 Initialize the maximum dominating subspace \ud835\udc37\ud835\udc5e = \u2205 for\neach point \ud835\udc5e \u2208 P 3 \ud835\udc46 \u2190 \u2205 4 \ud835\udf0e\u2032 \u2190 0 5 while \ud835\udf0e\u2032 < \ud835\udf0e do 6 if P = \u2205 then 7 return S, P 8 \ud835\udc5d \u2190 the point with the minimal score (which is a skyline point) 9 S \u2190 S \u222a {\ud835\udc5d}\n10 P \u2190 P \\ {\ud835\udc5d}"
        },
        {
            "heading": "11 foreach \ud835\udc5e \u2208 P do",
            "text": "12 Compute dominating subspace \ud835\udc37\ud835\udc5e\u227a\ud835\udc5d 13 if \ud835\udc37\ud835\udc5e\u227a\ud835\udc5d = \u2205 then 14 if \ud835\udc5e = \ud835\udc5d then 15 S \u2190 S \u222a {\ud835\udc5e} 16 P \u2190 P \\ {\ud835\udc5e}"
        },
        {
            "heading": "17 continue",
            "text": "18 \ud835\udc37\ud835\udc5e \u2190 \ud835\udc37\ud835\udc5e \u222a \ud835\udc37\ud835\udc5e\u227a\ud835\udc5d 19 \ud835\udf0e\u2032 \u2190 compute the stability of point distribution"
        },
        {
            "heading": "20 return S, P",
            "text": "First, in our algorithm we score each point in the dataset P by its Euclidean distance to the zero point (line 1). In this step, the sorting of all points is not necessary, which requires O(\ud835\udc41 log\ud835\udc41 ) time: assume that the stability threshold \ud835\udf0e can be satisfied by \ud835\udc58 skyline points, the search of minimal score (line 9) can be done in O(\ud835\udc58\ud835\udc41 ) time in the worst case, where \ud835\udc58 \u226a \ud835\udc41 . The algorithm runs in the iterative loop from line 5 to line 24 with respect to the stability measure \ud835\udf0e\u2032 < \ud835\udf0e . In each iteration, any time if all points have been pruned, then the algorithm returns the skyline \ud835\udc46 and the empty dataset P (line 7), so that the whole computation can be terminated. With pruning dominated points in the dataset, the point \ud835\udc5d having the minimal score is immediately a skyline point (line 9 and 10) and can be pruned from the dataset (line 11). Then, the point \ud835\udc5d will be compared with each point \ud835\udc5e \u2208 P in the dataset (line 12 to line 22) by computing the dominating subspace \ud835\udc37\ud835\udc5e\u227a\ud835\udc5d (line 13). If \ud835\udc46\ud835\udc5e\u227a\ud835\udc5d = \u2205, then \ud835\udc5d \u2280 \ud835\udc5e or \ud835\udc5d = \ud835\udc5e (here we denote by \ud835\udc5d = \ud835\udc5e that \u2200\ud835\udc56 \u2208 \ud835\udc37, \ud835\udc5d [\ud835\udc56] = \ud835\udc5e [\ud835\udc56]), in any case, \ud835\udc5e will be pruned from P (line 18) and \ud835\udc5e will be added to the skyline if \ud835\udc5d = \ud835\udc5e (line 15 to line 17); otherwise, we merge the maximum dominating subspace \ud835\udc37\ud835\udc5e\u227a\ud835\udc5d of \ud835\udc5e (line 21). At the end of each iteration, the stability measure \ud835\udf0e\u2032 will be updated (line 23).\nFinally, the algorithm returns the skyline \ud835\udc46 and the dataset P that contains non-pruned points only (line 25), that is \u2200\ud835\udc5e \u2208 P, \ud835\udc46 \u2280 \ud835\udc5e.\nIn summary, Algorithm 1 is designed to merge the maximum dominating subspace of each point in order to distribute the points in the dataset to asmuch as possible subspaces, the stability threshold \ud835\udf0e is set to control the algorithm. Because each merge procedure of the maximum dominating subspace requires the dominance tests against all non-pruned points in the dataset, the value of stability threshold is sensitive to the performance of our method. For small datasets, the selection of stability threshold is less important because any skyline algorithm can finish in short time; for large datasets, the stability threshold can be tested from a random sample of the dataset. We also note that any measure can be applied to stop dominating subspace merging."
        },
        {
            "heading": "5 SUBSET QUERY FOR SKYLINE INDEXING",
            "text": "In the previous section, we show a maximum dominating space can be assigned to each point, this principle can be used to partition and index skyline points in order to reduce the dominance tests. Lemma 4.3 shows that \ud835\udc37\ud835\udc5e1\u227a\ud835\udc46 \u2289 \ud835\udc37\ud835\udc5e2\u227a\ud835\udc46 is necessary to determine whether \ud835\udc5e1 \u227a \ud835\udc5e2 while \ud835\udc5e1 and \ud835\udc5e2 have been attributed a subspace generated from a set of skyline points \ud835\udc46 .\nLemma 5.1. Given a dataset P, let \ud835\udc46 be a set of skyline points of P and \ud835\udc37\ud835\udc5e\u227a\ud835\udc46 be the superposed dominating subspace of a point \ud835\udc5e \u2208 P, where all points dominated by \ud835\udc46 have been pruned. Let \ud835\udc5d be a skyline point in P, then, the dominance tests to determine whether a point \ud835\udc5e \u2208 P is a skyline point can be done only with each skyline point \ud835\udc5d such that \ud835\udc37\ud835\udc5d\u227a\ud835\udc46 \u2287 \ud835\udc37\ud835\udc5e\u227a\ud835\udc46 , in the condition of presorting. \u25a0\nProof. In the condition of presorting like [1, 2, 7, 8, 18], it is enough to compare a point with all known skyline points to determine whether the testing point is in the skyline. The rest of the proof is as the proof of Lemma 4.3, if \ud835\udc5e1 in Lemma 4.3 is a skyline point. \u25a1\nOur result shows that subspace based partitioning of skyline points can significantly reduce the dominance tests: a testing point is necessary to compare only with the skyline points with the maximum dominating subspace specified in Lemma 5.1. Therefore, if the skyline points can be stored and retrieved by a generic container, then this container can be used to improve any skyline algorithm by reducing the total number of dominance tests. So we have the following problem statements.\nProblem 1. Design a data structure with which: (1) each skyline point can be stored/indexed and partitioned by\nits maximum dominating subspace; (2) given a subspace \ud835\udc37\ud835\udc5e of a testing point \ud835\udc5e, all skyline points\nwith any subspace \ud835\udc37\u2032 \u2287 \ud835\udc37\ud835\udc5e can be efficiently returned.\nLet \ud835\udc37\u00ac\ud835\udc5e denote the reversed maximum dominating subspace with respect to \ud835\udc37 of a point \ud835\udc5e, then the above problem is to find all subsets of \ud835\udc37\u00ac\ud835\udc5e in order to retrieve associated skyline points.\nProblem 2. Given a set X of\ud835\udc5a subsets of a universe \ud835\udc37 , for any query set \ud835\udc44 \u2286 \ud835\udc37 , return the set {\ud835\udc44 \u2032 \u2208 X | \ud835\udc44 \u2032 \u2282 \ud835\udc44}.\nMany studies have been addressed to the subset query problem. The recent result [5] shows that the subset query can be accomplished in O(\ud835\udc51\ud835\udc40 \ud835\udc50 ) time. In our context, where \ud835\udc51 is the the dimensionality, \ud835\udc40 is the number of maximum dominating\nsubspaces, and \ud835\udc50 \u2264 \ud835\udc40 is a constant. We propose a very simple data structure to resolve our reversed subset query problem in O(\ud835\udc51 2 ) average time for adding a point and in O((\ud835\udc51 2 )2) average time for query, note that \ud835\udc51 \u226a \ud835\udc40 .\nFigure 3 shows our data structure, which is a prefix tree like structure based on maps, where each value of the key-value pair of a map consists in two parts: a set of skyline points (IDs, references, or pointers, for instance) and a set of sub-maps (references or pointers, for instance). Each key-value pair is considered as a node. In considering the access cost, hash map is the best choice for constant insertion and retrieval of nodes, hence, the following description and analysis are all based on hash map. Indeed, any map implementation can be used to construct the proposed data structure, for instance, a sorted map, but in this case, the access will be no longer in constant time but in log time. The index size is the map-based prefix tree that contains all dimensions in concerned subspaces plus the total number of skyline points represented by IDs, references, or pointers.\nIn the example illustrated in Figure 3, the reversed maximum dominating subspaces are organized by the index of dimensions, where in this example we have the following subspaces\n{{1, 2}, {1, 3, 5, 7}, {1, 5}, {1, 7}, {3, 5}, {3, 7}, {5, 7}} in the tree. Each node consists of the index of subspace and the set of all points (any point can be represented by a pointer, a reference, or its ID, a real copy is not necessary) assigned with this subspace. Given a query set {1, 3, 5}, we first locate the node 1, the retrieve all points associated with this node, and then, from the node 1, we locate the node 3 with retrieving all associated points, and the node 5. In order to find all subsets of {1, 3, 5}, the node 3 and the node 5 at the first level (root node) should also be accessed.\nWe propose the following two subset query algorithms to store and retrieve skyline points. We suppose that each point in the dataset has been attributed a maximum dominating subspace computed from the Algorithm 1, represented by a bit set (which is supported by many programming languages) or a binary vector of size \ud835\udc51 .\nAlgorithm 2 is quite simple. With respect to the data structure shown in Figure 3, we let the initial node be the root node (line 1). For each dimension in the reversed subspace \ud835\udc37\u00ac\ud835\udc5e (the index of the true bit with respect to a bit set or of the value 1 with respect to a binary vector), we get the last node by a simple loop (line 2 to line 4). We define that the \ud835\udc54\ud835\udc52\ud835\udc61 (\ud835\udc56) method (line 3) of a node returns the sub-node with the index value \ud835\udc56 , which can\nAlgorithm 2: Store Input: A point \ud835\udc5e with a subspace \ud835\udc37\ud835\udc5e\n1 \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52 \u2190 \ud835\udc5f\ud835\udc5c\ud835\udc5c\ud835\udc61 2 foreach \ud835\udc56 \u2208 \ud835\udc37\u00ac\ud835\udc5e do 3 \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52 \u2190 \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52.\ud835\udc54\ud835\udc52\ud835\udc61 (\ud835\udc56) 4 \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52.\ud835\udc5d\ud835\udc62\ud835\udc61 (\ud835\udc5e)\nfinish in constant time while using a hash map to implement the data structure, or in O(log\ud835\udc51) time if a sorted map is used. If the sub-node with the index value \ud835\udc56 does not exist, the \ud835\udc54\ud835\udc52\ud835\udc61 (\ud835\udc56) method create the sub-node. Finally, the point \ud835\udc5e is added to the last node (line 5) by the method \ud835\udc5d\ud835\udc62\ud835\udc61 (\ud835\udc5e).\nLemma 5.2. Algorithm 2 finishes in O(1) time in the best case, in O(\ud835\udc51\u22121) time in the worst case, and in O(\ud835\udc51\n2 ) time in the average\ncase. \u25a0\nProof. In the best case, |\ud835\udc37\u00ac\ud835\udc5e | = 1, the algorithm finishes immediately. In the worst case, |\ud835\udc37\u00ac\ud835\udc5e | = \ud835\udc51\u22121 because \ud835\udc5e is not dominated by any initial skyline points, therefore the algorithm requires \ud835\udc51 \u2212 1 retrievals of sub-node, which requires O(\ud835\udc51 \u2212 1) time with hash map based data structure. In the average case, the mean size of subspaces can be computed by dividing the sum of the total size of all subspaces (which is known as \ud835\udc512\ud835\udc51\u22121) by the total number of subspaces (which is 2\ud835\udc51 ), we have \ud835\udc512\ud835\udc51\u22121\n2\ud835\udc51 = \ud835\udc51 2 . Hence,\nthis average time complexity is O(\ud835\udc51 2 ). \u25a1\nLemma 5.2 also shows that in the case of \ud835\udc51 = 2, Algorithm 2 finishes always in O(1), however, there will be only two independent nodes at the top level to store skyline points, therefore, our method can contribute very limited performance improvement.\nAlgorithm 3: Query Input: A subspace \ud835\udc37\ud835\udc5e Output: A set \ud835\udc46 of points such that \u2200\ud835\udc5d \u2208 \ud835\udc46, \ud835\udc37\ud835\udc5d \u2287 \ud835\udc37\ud835\udc5e\n1 \ud835\udc46 \u2190 \ud835\udc5f\ud835\udc5c\ud835\udc5c\ud835\udc61 .\ud835\udc5d\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61\ud835\udc60 2 foreach \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52 \u2208 \ud835\udc5f\ud835\udc5c\ud835\udc5c\ud835\udc61 .\ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52\ud835\udc60 do 3 if \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52.\ud835\udc56\ud835\udc5b\ud835\udc51\ud835\udc52\ud835\udc65 \u2208 \ud835\udc37\u00ac\ud835\udc5e then 4 \ud835\udc5e\ud835\udc62\ud835\udc52\ud835\udc5f\ud835\udc66 (\ud835\udc37\u00ac\ud835\udc5e , \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52, \ud835\udc46)\n5 return \ud835\udc46\nAlgorithm 4: Recursive query Input: A subspace \ud835\udc37\ud835\udc5e , a node, and a set \ud835\udc46 of points such\nthat \u2200\ud835\udc5d \u2208 \ud835\udc46, \ud835\udc37\ud835\udc5d \u2287 \ud835\udc37\ud835\udc5e 1 \ud835\udc46 \u2190 \ud835\udc46 \u222a \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52.\ud835\udc5d\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61\ud835\udc60 2 foreach \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52 \u2208 \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52.\ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52\ud835\udc60 do 3 if \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52.\ud835\udc56\ud835\udc5b\ud835\udc51\ud835\udc52\ud835\udc65 \u2208 \ud835\udc37\u00ac\ud835\udc5e then 4 \ud835\udc5e\ud835\udc62\ud835\udc52\ud835\udc5f\ud835\udc66 (\ud835\udc37\u00ac\ud835\udc5e , \ud835\udc5b\ud835\udc5c\ud835\udc51\ud835\udc52, \ud835\udc46)\nAlgorithm 3 presents a recursive retrieval of partitioned skyline points with respect to a given subspace \ud835\udc37\ud835\udc5e , all points distributed to any super set of \ud835\udc37\ud835\udc5e will be returned. Algorithm 4 corresponds to the \ud835\udc5e\ud835\udc62\ud835\udc52\ud835\udc5f\ud835\udc66 method in the line 4 of Algorithm 3. The skyline point set \ud835\udc46 is updated by each call of the method\n\ud835\udc5e\ud835\udc62\ud835\udc52\ud835\udc5f\ud835\udc66 (Algorithm 4), which is initialized by all points distributed to the root node (line 1 of Algorithm 3).\nLemma 5.3. Given a subspace \ud835\udc37\ud835\udc5e , Algorithm 3 returns the set \ud835\udc46 such that \u2200\ud835\udc5d \u2208 \ud835\udc46, \ud835\udc37\ud835\udc5d \u2287 \ud835\udc37\ud835\udc5e in O(1) time in the best case, in\nO( (\ud835\udc51 \u2212 1) (\ud835\udc51 \u2212 2) 2 )\ntime in the worst case, and in\nO( (\ud835\udc51/2) (\ud835\udc51/2 \u2212 1) 2 )\ntime in the average case. The average time complexity of Algorithm 3 can be considered as O((\ud835\udc51 2 )2). \u25a0\nProof. Let |\ud835\udc37\u00ac\ud835\udc5e | = \ud835\udc5b, then \ud835\udc5b(\ud835\udc5b \u2212 1)\n2 tests must be done with\nrespect to the data structure shown in Figure 3 to retrieve all subsets of \ud835\udc37\u00ac\ud835\udc5e , that is, all super sets of \ud835\udc37\ud835\udc5e . In the best case, \ud835\udc5b = 1, 1 test returns the subset of \ud835\udc37\u00ac\ud835\udc5e ; in the worst case, \ud835\udc5b = \ud835\udc51 \u2212 1, hence O( (\ud835\udc51 \u2212 1) (\ud835\udc51 \u2212 2) 2 ) time is required. In the average case, as shown in the proof of Lemma 5.2, \ud835\udc5b = \ud835\udc51\n2 , therefore, Algorithm 3\nterminates in O( (\ud835\udc51/2) (\ud835\udc51/2 \u2212 1) 2 ) time, which can be considered in O((\ud835\udc51 2 )2) time complexity. \u25a1\nWe note that the dimensionality \ud835\udc51 of the dataset is much less than the cardinality \ud835\udc41 of the dataset, the O((\ud835\udc51 2 )2) average subset query time can be ignored in comparison with O(\ud835\udc51\ud835\udc41 2) time or O(\ud835\udc41 log(\ud835\udc51\u22122) \ud835\udc41 ) time. However, our method is not suitable to directly partition points in a dataset because 2\ud835\udc51 \u22122 subspaces can\nbe generated in the worst case and in this case O((\ud835\udc51 2 )2\ud835\udc41 ) time is required to retrieve comparable points. Hence, we propose our method to partition skyline points only, and the dominance tests can be performed in general ways. Therefore, the best application of our result is to boost sorting-based skyline algorithms."
        },
        {
            "heading": "6 EXPERIMENTAL RESULTS",
            "text": "In this section, we report the experimental results of our method. We applied our method to SFS, SaLSa, and SDI algorithms without changing their original designs, the main function of our method is to store and to retrieve skyline points. The code is implemented in C++ with the C++11 standard2 and tested on AMD Epyc 7702 2GHz CPU with 512 GB RAM.\nThe evaluation metrics are based on the mean dominance test number [14] and the elapsed processor time, where the mean dominance test number is defined as the ratio of the total number of dominance tests on the total number of points. All elapsed processor time results, in milliseconds, are based on the mean time of 10 runs, all data have been loaded into the main memory before counting."
        },
        {
            "heading": "6.1 Effect of Stability Threshold",
            "text": "First, we study the effect of the stability threshold \ud835\udf0e , where 1 < \ud835\udf0e \u2264 \ud835\udc51 (\ud835\udc51 is the dimensionality of dataset). Note that it is meaningless to set \ud835\udf0e = 1 because the objective of our method is to balance the distribution of points among subspaces. Figure 4 and Figure 5 show that low-value stability thresholds can effectively reduce the mean number of dominance tests however there\n2The source code of our method is available at https://github.com/dominiquehli/ skyline-subset. We thank Jongwuk Lee for the source code of BSkyTree-S and BSkyTree-P.\nis no exact corresponding changes in elapsed processor time on CO and UI (with SDI-Subset) datasets. Note that the format of Y axis of AC and UI datasets is logarithmic and that of CO is linear. The main reason is that AC data require a huge number of dominance tests so that the time variance among different dominance tests can be statistically neutralized, however CO and UI data require much less dominance tests so the different dominance test time makes sense. Indeed, in comparison with Figure 2, Figure 6 can show that while \ud835\udf0e = 3, the most of points in AC data are distributed in high subspaces but that in CO and UI data are distributed in low subspaces, which requires less skyline index accesses and the index is much smaller. We have the similar results on other AC/CO/UI datasets with different dimensionality and cardinality, where the fastest \ud835\udf0e for SDI-Subset is around \ud835\udc51/3. Therefore, in the reported performance evaluations, the stability threshold \ud835\udf0e is set to rounded \ud835\udc51/3."
        },
        {
            "heading": "6.2 Effect of Data Type",
            "text": "We now report the improvements of SFS, SaLSa, and SDI algorithms with the boost of our method, where the state-of-the-art algorithms BSkyTree-S and BSkyTree-P are used as the baseline. Two groups of tests have been conducted in order to study the effect of the data dimensionality and the effect of the data cardinality on synthetic AC, CO, and UI datasets. In the first group, the cardinality of all datasets is fixed to 2 \u00d7 105 (200K) points, the dimensionality varies from 2-D to 24-D; in the second group, the dimensionality of all datasets is fixed to 8-D, the cardinality varies from 105 (100K) to 106 (1M) points. Table 1 lists the skyline size of all synthetic datasets.\nBecause the scale of obtained values is huge, our results are presented as numbers listed in Table 2 \u2014 Table 13, where the algorithms with -Subset suffix are boosted by our method. Furthermore, we introduce the performance gains metric into the presented tables, which is calculated as the ration of any value\nobtained without boosting on the value boosted by our method. If there is no performance gain, we mark it as \u201c\u2013\u201d.\nFrom Table 2 to Table 5, we study the the performance of our method on AC data. It is not surprising that BSkyTree-P is the absolute winner on AC data, and the boost of our method is very limited. We can preview this result from the previous analysis. However, in high-dimensional data, for instance 20-D and 24-D datasets, our method can boost SFS, SaLSa, and SDI up to 30 to 40 times. The reason is that the 200K points have been distributed till to 220 and 224 subspaces, that is also why SDI-Subset wins BSkyTree-P in 16-D and 24-D.\nThe effectiveness of our method on CO data is studied from Table 6 to Table 9. Except SaLSa and SDI, all other methods require at least on scan of the full dataset. We can see that there is almost no performance gain inmany datasets, as already shown in Figure 6: it is difficult to distribute CO data. We also see that SDI is the winner in mean dominance test numbers because of its early stop mechanism, as SaLSa. However SDI needs much more time to finish the computation in comparison with BSkyTree-S because it must first build the dimension index of the full dataset.\nTable 10 to Table 13 prove the performance of our method. We note the in Table 10, our method cannot reduce any mean dominance test numbers on the datasets of which the dimensionality is less than 6 in comparisonwith SaLSa and SDI because of the same reason described with CO data. On 6-D dataset, SaLSa-Subset is the winner, lightly faster then SDI-Subset. However, from 6-D data, the boosted methods SaLSa-Subset and SDI-Subset run faster than BSkyTree-P. From 8-D datasets3, SDI-Subset becomes the fastest algorithm on UI data.\nFinally, our experimental results show that BSkyTree-P is the best choice for AC data, BSkyTree-S is always the winner on CO data and low-dimensional data (for instance, \ud835\udc51 < 6), and the boosted methods, particularly SDI-Subset, is best for UI\n3The 16-D dataset is exceptional. We have tested different 16-D UI datasets from 100K to 1M points, all results are very similar to that of AC datasets.\ndata. Besides, the usefulness of our method is also limited in lowdimensionality domains, such as 2-D to 4-D datasets. The main reason is that the number of subspaces is not enough to boost SFS, SaLSa, and SDI: there is no subspace in 2-D dataset and only 24 \u2212 2 = 14 subspaces can be generated to distribute points. In the presented experiments, any tested algorithm can finish the skyline computation of a 4-D UI dataset with 2 \u00d7 105 (200K) points in millisecond-level, so our method can not give additional performance gain. However, on larger dataset, for instance, on a 4-D UI dataset with 106 (1M) points, our extended experiments show that all boosted methods, SFS-Subset, SaLSa-Subset, and SDI-Subset perform better than BSkyTree-S and BSkyTree-P, where the skyline contains 423 points, as shown in Figure 14 (DT: Mean dominance test numbers; RT: Elapsed processor time)."
        },
        {
            "heading": "6.3 Results on Real Datasets",
            "text": "We also tested our method on the three real world datasets HOUSE (6-D, 127,931 points, 5,774 skyline points), NBA (8-D, 17,264 points, 1,796 skyline points), and WEATHER (15-D, 566,268 points, 26,713 skyline points) [6] as listed from Table 15 to Table 17 (DT: Mean dominance test numbers; RT: Elapsed processor time).\nOur experimental results show that our method can boost SFS, SaLSa, and SDI, where all stability threshold \ud835\udf0e values have been manually adjusted. We note and analyzed the relatively limited (< 2) effectiveness on these three datasets. HOUSE is an AC type dataset, we have already shown the limits of our method with such a data type. NBA is a small dataset with only 17,264 points dataset, SaLSa cannot be boosted at all in terms of elapsed processor time because the I/O of our proposed skyline index\nrequires additional processor time. WEATHER dataset consists of 15 dimensions, so SDI works well because it was designed for high-dimensionality domains. Besides, there are a large number of duplicate values in several dimensions in the WEATHER dataset, and this factor causes that there may be a lot of skyline points in one single node of our proposed skyline index, which will affect the performance of the skyline index. However, both SDI and SDI-Subset perform better then BSkyTree-P."
        },
        {
            "heading": "7 CONCLUSION",
            "text": "In this paper, we present a subset approach to efficient skyline computation, which is designed to boost sorting-based skyline algorithms. We proposed a subspace union method to assign all points a maximum dominating subspace, with which the dominance tests between skyline points and testing points are only necessary between comparable subspaces. In order to efficiently retrieve skyline points for dominance tests with respect to maximum dominating subspaces, we proposed a subset query method to index the skyline. Our theoretical analysis and experimental results show that the skyline computation can be boosted by our subspace union and subset query method. The perspective of the work presented in this paper includes: (1) extending the proposed method to AC and CO data; (2) developing a cost model to improve the stability threshold in order to find the best number of pivot points; (3) adapting the proposed method to updating data such as data streams."
        },
        {
            "heading": "ACKNOWLEDGMENT",
            "text": "The author benefited from the use of the cluster at the Centre de Calcul Scientifique en R\u00e9gion Centre-Val de Loire, France."
        }
    ],
    "title": "Subset Approach to Efficient Skyline Computation",
    "year": 2023
}