{
    "abstractText": "Let [q\u3009 denote the integer set {0, 1, . . . , q \u2212 1} and let B = {0, 1}. The problem of implementing functions [q\u3009 \u2192 B on content-addressable memories (CAMs) is considered. CAMs can be classified by the input alphabet and the state alphabet of their cells; for example, in binary CAMs, those alphabets are both B, while in a ternary CAM (TCAM), both alphabets are endowed with a \u201cdon\u2019t care\u201d symbol. This work is motivated by recent proposals for using CAMs for fast inference on decision trees. In such learning models, the tree nodes carry out integer comparisons, such as testing equality (x = t ?) or inequality (x \u2264 t ?), where x \u2208 [q\u3009 is an input to the node and t \u2208 [q\u3009 is a node parameter. A CAM implementation of such comparisons includes mapping (i.e., encoding) t into internal states of some number n of cells and mapping x into inputs to these cells, with the goal of minimizing n. Such mappings are presented for various comparison families, as well as for the set of all functions [q\u3009 \u2192 B, under several scenarios of input and state alphabets of the CAM cells. All those mappings are shown to be optimal in that they attain the smallest possible n for any given q.",
    "authors": [
        {
            "affiliations": [],
            "name": "Ron M. Roth"
        }
    ],
    "id": "SP:5b7d8f47119aa0e20274b40090005eb885efcc1c",
    "references": [
        {
            "authors": [
                "I. Anderson"
            ],
            "title": "Combinatorics of Finite Sets, Dover Publications, Mineola",
            "venue": "New York,",
            "year": 1987
        },
        {
            "authors": [
                "M. Anthony",
                "N. Biggs"
            ],
            "title": "Computational Learning Theory",
            "year": 1992
        },
        {
            "authors": [
                "A. Birkendorf",
                "N. Klasner",
                "C. Kuhlmann",
                "H.U. Simon"
            ],
            "title": "Structural results about exact learning with unspecified attribute values",
            "venue": "J. Comput. Syst. Sci., 60 (2000), 258\u2013277.",
            "year": 2000
        },
        {
            "authors": [
                "A. Bremler-Barr",
                "D. Hay",
                "D. Hendler"
            ],
            "title": "Layered interval codes for TCAM-based classification",
            "venue": "Proc. 28th IEEE Conf. on Computer Communication (INFOCOM 2009), Rio de Janeiro, Brazil, 2009, pp. 1305\u2013 1313.",
            "year": 2009
        },
        {
            "authors": [
                "W. Fraczak",
                "W. Rytter",
                "M. Yazdani"
            ],
            "title": "Matching integer intervals by minimal sets of binary words with don\u2019t cares",
            "venue": "Proc. 19th Annual Symp. on Combinatorial Pattern Matching (CPM 2008), Pisa, Italy, 2008, pp. 217\u2013228.",
            "year": 2008
        },
        {
            "authors": [
                "R. Govindaraj",
                "S. Ghosh"
            ],
            "title": "Design and analysis of STTRAM-based ternary content addressable memory cell",
            "venue": "ACM J. Emerg. Technol. Comput. Syst., 13 (2017), Article 52, 1\u201322.",
            "year": 2017
        },
        {
            "authors": [
                "G. Kasai",
                "Y. Takarabe",
                "K. Furumi",
                "M. Yoneda"
            ],
            "title": "200MH/200MSPS 3.2W at 1.5V Vdd, 9.4Mbits ternary CAM with new charge injection match detect circuits and bank selection scheme",
            "venue": "Proc. IEEE 2003 Custom Integrated Circuits Conf., San Jose, CA, 2003, pp. 387\u2013380.",
            "year": 2003
        },
        {
            "authors": [
                "C. Li",
                "C.E. Graves",
                "X. Sheng",
                "D. Miller",
                "M. Foltin",
                "G. Pedretti",
                "J.P. Strachan"
            ],
            "title": "Analog content-addressable memories with memristors",
            "venue": "Nat. Commun., 11 (2020), #1638.",
            "year": 2020
        },
        {
            "authors": [
                "D. Lubell"
            ],
            "title": "A short proof of Sperner\u2019s theorem",
            "venue": "J. Comb. Theory, 1 (1966), 299.",
            "year": 1966
        },
        {
            "authors": [
                "T. Natschl\u00e4ger",
                "M. Schmitt"
            ],
            "title": "Exact VC-dimension of Boolean monomials",
            "venue": "Inf. Process. Lett., 59 (1996), 19\u201320.",
            "year": 1996
        },
        {
            "authors": [
                "G. Pedretti",
                "C.E. Graves",
                "C. Li",
                "S. Serebryakov",
                "X. Sheng",
                "M. Foltin",
                "R. Mao",
                "J.P. Strachan"
            ],
            "title": "Tree-based machine learning performed in-memory with memristive analog CAM",
            "venue": "Nat. Commun., 12 (2021), #5806.",
            "year": 2021
        },
        {
            "authors": [
                "X. Yang",
                "S. Sezer",
                "J. McCanny",
                "D. Burns"
            ],
            "title": "A versatile content addressable memory architecture",
            "venue": "Proc. 20th Anniversary IEEE Int\u2019l SOC Conf., Hsinchu, Taiwan, 2007, pp. 215\u2013218.",
            "year": 2007
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n30 5.\n13 15\n9v 1\n[ cs\n.D M\n] 2\n2 M\nay 2\n02 3\nThis work is motivated by recent proposals for using CAMs for fast inference on decision trees. In such learning models, the tree nodes carry out integer comparisons, such as testing equality (x = t ?) or inequality (x \u2264 t ?), where x \u2208 [q\u3009 is an input to the node and t \u2208 [q\u3009 is a node parameter. A CAM implementation of such comparisons includes mapping (i.e., encoding) t into internal states of some number n of cells and mapping x into inputs to these cells, with the goal of minimizing n.\nSuch mappings are presented for various comparison families, as well as for the set of all functions [q\u3009 \u2192 B, under several scenarios of input and state alphabets of the CAM cells. All those mappings are shown to be optimal in that they attain the smallest possible n for any given q.\nIndex Terms\u2014Content-addressable memories, Integer comparisons, Representation of Boolean functions, VC dimension.\nI. INTRODUCTION\nFor a, b \u2208 Z, denote by [a : b] the integer subset {z \u2208 Z : a \u2264 z \u2264 b} and by [a : b\u3009 the set [a : b \u2212 1]; we will use the shorthand notation [b\u3009 for [0 : b\u3009.\nLet B denote the Boolean set {0, 1} and let B\u2217 and B\u2022 denote the alphabets B\u222a {\u2217} and B\u222a{\u2217, \u2022}, respectively. We refer to \u2217 as the \u201cdon\u2019t-care\u201d symbol and to \u2022 as the \u201creject\u201d symbol. Define the function T : B2\u2022 \u2192 B by the truth table shown in Table I. The first argument, u, of T is called the input\nand the second argument, \u03d1, is the internal state. While the function (u, \u03d1) 7\u2192 T(u, \u03d1) is symmetric in its two arguments (in that T(u, \u03d1) = T(\u03d1, u)), there is a distinction between them in the way this function will be used.\nRon M. Roth is with the Computer Science Department, Technion, Haifa 3200003, Israel. This work was done in part while visiting Hewlett Packard Laboratories, Milpitas, CA. This work was supported in part by Grant 1713/20 from the Israel Science Foundation. Part of this work was accepted for presentation at the IEEE Int\u2019l Symposium on Information Theory (ISIT), June 2023. Email: ronny@cs.technion.ac.il.\nWe extend the definition of the function T to words (vectors) over B\u2022 as follows: for u = (uj)j\u2208[n\u3009 and \u03d1 = (\u03d1j)j\u2208[n\u3009 in Bn\u2022 , we define T(u,\u03d1) by\nT(u,\u03d1) = \u2227\nj\u2208[n\u3009\nT(uj , \u03d1j), (1)\nwhere \u2227 denotes Boolean conjunction (i.e., logical \u201cand\u201d). A content-addressable memory (CAM) is a device which consists of an m \u00d7 \u2113 array of cells, with each cell (i, j) \u2208 [m\u3009\u00d7 [\u2113\u3009 implementing the function u 7\u2192 T(u, \u03d1i,j), for some internal state value \u03d1i,j \u2208 B\u2022. The input to the array is a word u = (uj)j\u2208[\u2113\u3009 \u2208 B\u2113\u2022, with uj serving as the input to all the cells along column j. The internal states need to be programmed into the array prior to its use and are therefore\nassumed to change much less frequently than the input word u.\nIn addition, the selections of the internal state values and of\nthe input words are assumed to be independent.\nEach row (\u201cmatch line\u201d) in the array computes the con-\njunction of the outputs of the cells along the row (as in (1)),\nand the results obtained by the m rows form the output word, v \u2208 Bm, of the array. The nonzero entries in v are referred to as \u201cmatches,\u201d and in practice there are settings where one\nmight be interested only in the number of matches (namely,\nthe Hamming weight of v) or in the index i of the first match in v.\nCAMs are classified, inter alia, by the ranges of the input\nvalues uj and the internal state values \u03d1i,j . In a binary CAM (in short, BCAM), these values are constrained to be in B, and in a ternary CAM (in short, TCAM), they are elements\nof B\u2217. BCAMs are used in implementing fast look-up tables, and TCAMs are used in networking equipment for performing\nhigh-speed packet classification.\nThere are several common hardware designs for CAM\ncells, e.g., [6],[7],[13]. Most designs allow in effect the cells (including BCAM cells) to take both \u2217 and \u2022 as input values. Moreover, some of the TCAM designs, such as the one shown\nin [6, Fig. 2(a)] and [7, Fig. 1], allow the internal state to take the value \u2022 (hence our election to define T to have the domain B2\u2022).\nFor an integer q \u2265 2, let Fq denote the set of all functions f : [q\u3009 \u2192 B (to avoid trivialities, we exclude the case q = 1).1 For certain function families \u03a6 \u2286 Fq, we are interested in the implementation of each x 7\u2192 f(x) \u2208 \u03a6 in the form\nf(x) = T(u(x),\u03d1(f)) (1) =\n\u2227\nj\u2208[n\u3009\nT(uj(x), \u03d1j(f)), (2)\n1When q = 2h, one can regard Fq as the set of all h-variate Boolean functions Bh \u2192 B (by simply replacing each element in the domain [q\u3009 by its length-h binary representation).\n2 where u : [q\u3009 \u2192 Bn\u2022 and \u03d1 : \u03a6 \u2192 Bn\u2022 are prescribed mappings which may (only) depend on \u03a6 and n; in fact, for a given family \u03a6, we will be interested in the smallest possible n for which any function f \u2208 \u03a6 can be expressed in the form (2). Note that the first argument of T(\u00b7, \u00b7) in (2) depends only on x, while the second depends only on f . Such a separation is dictated by the common use of CAMs: the functions f are pre-specified and the respective words \u03d1(f) are programmed into (the internal state values of) n CAM cells along a row, while x is an input within a sequence of inputs to which the functions are to be applied.\nOur study of implementations of Boolean functions on\nCAMs is motivated primarily by certain models of machine\nlearning\u2014specifically, by recent proposals for using CAMs\nfor fast inference on decision trees [8],[12]. In such learning\nmodels, the basic operations carried out in the nodes of the\ntrees are comparisons between (real or) integer numbers. The\nimplementation in [8],[12] can be seen as a generalized notion of a CAM which consists of an m\u00d7 \u2113 array A of cells, with each cell (i, s) \u2208 [m\u3009\u00d7 [\u2113\u3009 computing a function (comparator) x 7\u2192 fi,s(x) \u2208 Fq which tests x against some fixed threshold. The input to such an array is a word x = (xs)s\u2208[\u2113\u3009 \u2208 [q\u3009\u2113 and the output of each row i is the conjunction of the outputs of the cells along the row:\n\u2227\ns\u2208[\u2113\u3009\nfi,s(xs). (3)\nWhen used to implement decision trees, the entries of x are\nthe features (attributes) and each row i corresponds to (a path that leads to) a leaf in the tree. The expression (3) evaluates\nto 1 if and only if the feature values in x lead to the (unique) leaf that corresponds to row i.\nOur families \u03a6 of interest have been selected accordingly and, in order to define them, we introduce the following\nnotation. Let the bivariate functions Eq, Nq , \u0393q , and Lq, all with the domain [q\u30092 and range B, be defined for every (x, t) \u2208 [q\u30092 by:\nEq(x, t) = [[x = t]],\nNq(x, t) = [[x 6= t]], \u0393q(x, t) = [[x \u2265 t]], Lq(x, t) = [[x \u2264 t]],\nwhere [[ \u00b7 ]] denotes the Iverson bracket (which evaluates to 1 if its argument is true, and to 0 otherwise). Respectively, define the following subsets of Fq (each of size q):\nEq = { x 7\u2192 Eq(x, t) } t\u2208[q\u3009 ,\nNq = { x 7\u2192 Nq(x, t) } t\u2208[q\u3009 ,\nGq = { x 7\u2192 \u0393q(x, t) } t\u2208[q\u3009 , Lq = { x 7\u2192 Lq(x, t) } t\u2208[q\u3009 .\nThe families \u03a6 that we consider are:\nEq, Nq, Gq (or Lq), Gq \u222a Lq, as well as the whole set Fq .2\n2The family Gq \u222aLq is quite prevailing in decision trees, where the same feature xs is typically compared against both lower and upper thresholds.\nOnce the functions in the selected family \u03a6 have an implementation of the form (2) (with mappings x 7\u2192 u(x) and f 7\u2192 \u03d1(f) that attain the smallest possible n), we can realize an m \u00d7 \u2113 array A of functions fi,s \u2208 \u03a6 by an (ordinary) CAM consisting of an m\u00d7 \u2113n array A\u0303 of cells, with each cell implementing the function u 7\u2192 T(u, \u03d1i,j) with the internal states \u03d1i,j selected so that non-overlapping n-cell blocks in A\u0303 implement the functions fi,s. 3 Specifically, we select the internal states in A\u0303 for each (i, j) \u2208 [m\u3009 \u00d7 [\u2113n\u3009 so that ( \u03d1i,sn \u03d1i,sn+1 . . . \u03d1i,(s+1)n\u22121 ) = \u03d1(fi,s),\nin which case the output of row i in A (namely, (3)) can be expressed as\n\u2227\ns\u2208[\u2113\u3009\nfi,s(xs) (2) =\n\u2227\ns\u2208[\u2113\u3009\nT(u(xs),\u03d1(fi,s))\n= \u2227\ns\u2208[\u2113\u3009\n\u2227\nj\u2208[n\u3009\nT(uj(xs), \u03d1i,sn+j),\nwhich is the output of row i in A\u0303. Based upon the intended use of CAMs and the various\ndesigns of their cells, we consider several scenarios, which will be identified by pairs of symbols from {\u25e6, \u2217, \u2022}: the first (respectively, second) symbol in such a pair specifies the\nalphabet of the range of the mapping u (respectively, \u03d1) that appears in (2), with B\u25e6 = B; for example, in Scenario (\u25e6\u2217), the ranges of u and \u03d1 are Bn and Bn\u2217 , respectively. We will then say that a subset \u03a6 \u2286 Fq is n-cell implementable under a given scenario if there exist mappings u and \u03d1 with the appropriate ranges (Bn, Bn\u2217 , or B n \u2022 ) such that every function f \u2208 \u03a6 can be written in the form (2)."
        },
        {
            "heading": "A. Summary of results",
            "text": "Table II summarizes our results: for each of our selected\nchoices for \u03a6 and for six possible scenarios, the table shows the largest value of q for which \u03a6 is n-cell implementable. Due to the symmetries Eq(x, t) = Eq(t, x), Nq(x, t) = Nq(t, x), and \u0393q(x, t) = \u0393q(q\u22121\u2212t, q\u22121\u2212x) = Lq(t, x), the columns (\u2217\u25e6) and (\u25e6\u2217) are the same in the rows that correspond to the families Eq, Nq, and Gq , and so are the columns (\u2022\u2217) and (\u2217\u2022). Hence, for these families, there are four scenarios to consider.\nThree scenarios were omitted from the table: Scenario (\u25e6\u25e6) corresponds to a BCAM, where the two arguments of T(\u00b7, \u00b7) are restricted to B. Such a restriction limits the subsets \u03a6 that can be expressed in the form (2) (regardless of how large n is), namely, if f(y) = f(z) = 1 for some f \u2208 \u03a6 and some two distinct y, z \u2208 [q\u3009, then g(y) = g(z) for all g \u2208 \u03a6. Among our families of interest, only Eq satisfies this property (see Footnote 4 below). Scenarios (\u25e6\u2022) and (\u2022\u25e6) are also omitted.\n3The particular architecture of CAMs that is proposed [8],[12], referred to therein as an analog CAM (a-CAM), consists of cells which perform comparisons between integers in [q\u3009, for some prescribed q. The design of the cells makes use of programmable resistors and the comparisons are carried out in the analog domain. The reliability of such an a-CAM in practice, however, is yet to be tested and, in any event, such an a-CAM is expected to operate only for relatively small values of q. The alternate approach, which motivates this work, proposes using more traditional CAM designs (which are well tested and robust) to realize the same (targeted) functionality of an a-CAM.\n3 Scenario (\u25e6\u2022) is identical to (\u25e6\u2217) unless \u03a6 contains the allzero function, and among our families of interest, this occurs only when \u03a6 = Fq; in this case Scenarios (\u25e6\u2022) and (\u25e6\u2217) differ only in one isolated case (see Footnote 8 below). Similarly, Scenarios (\u2022\u25e6) and (\u2217\u25e6) would differ only if there were an element y \u2208 [q\u3009 such that f(y) = 0 for all f \u2208 \u03a6; yet this does not happen in any of the families \u03a6 of interest.\nWe see from the table that for a given q \u2265 3 and under Scenarios (\u2217\u25e6), (\u25e6\u2217), (\u2217\u2022), and (\u2022\u2022), the family Nq is n-cell implementable, (if and) only if the whole set Fq is. As such, the family Nq , albeit forming an exponentially small fraction of Fq (q out of the 2q functions), necessarily has the leastefficient CAM implementation under these scenarios. And this \u201crecord\u201d is almost tied by the family Gq (which, too, is of size q). On the other hand, under Scenarios (\u2217\u2217) and (\u2022\u2217), each of the families Nq , Gq (or even Gq \u222a Lq) is \u2308q/2\u2309-cell implementable, while the whole set Fq requires (at least) q cells (i.e., for this set, Scenarios (\u2217\u2217) and (\u2022\u2217) do not offer any advantage over Scenarios (\u2217\u25e6) or (\u25e6\u2217)).\nThe problem of constructing efficient encodings of integer\nintervals on a TCAM (which include in particular efficient\nimplementations of integer comparisons) has been the studied\nin the literature, e.g., [4],[5]. However, in those papers, the\nencoding of an interval indicator (or of a comparison) can\nutilize several rows of the TCAM. This translates into allowing taking a disjunction (\u201cor\u201d, \u201c\u2228\u201d) of several terms of the form seen in the right-hand side of (2), with each term having its own word \u03d1 (the common mapping x 7\u2192 u(x) is usually taken as the ordinary binary representation of x). However, in our setting, each TCAM row may contain (the conjunction of)\nthe implementation of several comparators and, therefore, any\nsuch implementation cannot be split across several rows.\nOur families of interest, Eq, Nq , Gq , Gq \u222a Lq , and Fq are covered, respectively, in Sections II through VI (followed by a\ndiscussion in Section VII). In each section except Section VI,\nthe scenarios are covered in the order they appear in Table II (skipping Scenarios (\u2217\u25e6) and (\u2022\u2217) when they coincide with Scenarios (\u25e6\u2217) and (\u2217\u2022)). Some effort has been put into making the text less tedious, e.g., by combining several proofs. We\nsubstantiate the values in Table II by presenting both lower and\nupper bounds for each entry. The lower bounds are all obtained by presenting explicit mappings x 7\u2192 u(x) and f 7\u2192 \u03d1(f) for which Eq. (2) holds for the respective family \u03a6. Admittedly, many of the optimal mappings are rather straightforward\n(e.g., they are either standard binary representations of their\nargument or kinds of unary representations, as in the proofs\nof Propositions 1\u20133 below); in those cases, the contribution of\nthis work lies mainly in showing that these mappings are, in\nfact, the best possible. Notable exceptions are the mappings for Scenarios (\u2022\u2217), (\u2217\u2022), and (\u2022\u2022) when \u03a6 = Eq, and for Scenarios (\u2217\u2217) and (\u2022\u2217) when \u03a6 = Gq \u222a Lq (and, perhaps, to some extent, Scenario (\u2217\u2217) when \u03a6 = Gq). As part of our study of the whole set Fq in Section VI, we also draw a connection between the subject of this paper and that of computing the\nVC dimension of Boolean monomials."
        },
        {
            "heading": "B. Some simple observations",
            "text": "We end our introduction by stating three simple observations\nwhich will be useful in the sequel.\nProposition 1. Under each of the scenarios in Table II, any\nsubset \u03a6 \u2286 Fq is n-cell implementable, whenever\nq \u2264 n.\nProof. Given that q \u2264 n, we can extend (arbitrarily) the functions in Fq so that they are defined over the (possibly larger) domain [n\u3009 and, so, we assume that q = n. For Scenario (\u25e6\u2217), we take the mappings x 7\u2192 u(x) = (uj(x))j\u2208[n\u3009 and f 7\u2192 \u03d1(f) = (\u03d1j(f))j\u2208[n\u3009 to be\nuj(x) = { 1 if x = j 0 if x 6= j and \u03d1j(f) = { \u2217 if f(j) = 1 0 if f(j) = 0 .\nOtherwise, we take them to be\nuj(x) = { 1 if x = j \u2217 if x 6= j and \u03d1j(f) = f(j).\nTaking the family \u03a6 = Nq = {Nq(\u00b7, t)}t\u2208[q\u3009 as an example, Table III shows the respective mappings x 7\u2192 u(x) and Nq(\u00b7, t) 7\u2192 \u03d1(Nq(\u00b7, t)) under Scenario (\u25e6\u2217).\nProposition 2. Under each of the scenarios in Table II, any\nsubset \u03a6 \u2286 Fq is n-cell implementable, whenever\n|\u03a6| \u2264 n.\nProof. Again, we can assume that |\u03a6| = n. Writing \u03a6 = {f1, f2, . . . , f|\u03a6|}, for Scenario (\u2217\u25e6), we take the mappings x 7\u2192 u(x) and f 7\u2192 \u03d1(f) to be\nuj(x) = { \u2217 if fj(x) = 1 0 if fj(x) = 0 and \u03d1j(f) = { 1 if f = fj 0 if f 6= fj .\nOtherwise, we take them to be\nuj(x) = fj(x) and \u03d1j(f) = { 1 if f = fj \u2217 if f 6= fj .\nProposition 3. Under each of the scenarios (\u2217\u2022) or (\u2022\u2022), any subset \u03a6 \u2286 Fq is n-cell implementable, whenever\nq \u2264 2n.\nProof. Assuming that q = 2n, we take the mappings x 7\u2192 u(x) and f 7\u2192 \u03d1(f) to be\nuj(x) =    0 if x = 2j 1 if x = 2j + 1 \u2217 otherwise\n(4)\nand\n\u03d1j(f) =    \u2217 if f(2j) = f(2j+1) = 1 0 if f(2j) = 1 and f(2j+1) = 0 1 if f(2j) = 0 and f(2j+1) = 1 \u2022 if f(2j) = f(2j+1) = 0 . (5)\n4\nIn this section, we consider the family \u03a6 = Eq . Since each function x 7\u2192 Eq(x, t) \u2208 Eq can be identified by the parameter t \u2208 [q\u3009, we will use for convenience the notation t 7\u2192 \u03d1(t) for Eq(\u00b7, t) 7\u2192 \u03d1(Eq(\u00b7, t)). Due to the symmetry Eq(x, t) = Eq(t, x), it will suffice to state our results only for Scenarios (\u25e6\u2217), (\u2217\u2217), (\u2217\u2022), and (\u2022\u2022).\nThe next proposition handles the case \u03a6 = Eq under Scenarios (\u25e6\u2217) and (\u2217\u2217).\nProposition 4. Under each of the scenarios (\u25e6\u2217) or (\u2217\u2217), the family Eq is n-cell implementable, if and only if\nq \u2264 2n.\nProof. Sufficiency follows by letting u(x) and \u03d1(t) be the length-n binary representations of x and t, respectively.4\nNecessity under Scenario (\u25e6\u2217) follows from the fact that the mapping x 7\u2192 u(x) must be injective (otherwise, if u(x0) = u(x1) for x0 6= x1, then Eq. (2) would imply Eq(x0, x1) = Eq(x1, x1) = 1, which is a contradiction).\nAs for Scenario (\u2217\u2217), suppose that Eq. (2) holds for some x 7\u2192 u(x) and t 7\u2192 \u03d1(t). Define the mapping x 7\u2192 u\u0302(x) =\n4 Such mappings suit also Scenario (\u25e6\u25e6).\n(u\u0302j(x))j\u2208[n\u3009 as follows:\nu\u0302j(x) =   \nuj(x) if uj(x) \u2208 B \u03d1j(x) if uj(x) = \u2217 and \u03d1j(x) \u2208 B 0 if uj(x) = \u03d1j(x) = \u2217 .\nIt readily follows that T(u\u0302(x),\u03d1(x)) = T(u(x),\u03d1(x)) = 1 for every x \u2208 [q\u3009. On the other hand, since u\u0302(x) is obtained from u(x) by (possibly) changing some entries from \u2217 into elements of B, then T(u(x),\u03d1(t)) = 0 implies T(u\u0302(x),\u03d1(t)) = 0. Hence, Eq(x, t) = T(u\u0302(x),\u03d1(t)) for all x, t \u2208 [q\u3009, thereby reducing to Scenario (\u25e6\u2217).\nThe family \u03a6 = Eq under Scenarios (\u2217\u2022) and (\u2022\u2022) will be treated next, yet, to this end, we will need some definitions\nand two lemmas.\nWe introduce the following partial ordering, , on the elements of B\u2022: \u2022 0, 1 \u2217 (with no ordering defined between 0 and 1), and extend it to words v,v\u2032 \u2208 Bn\u2022 , with v v\u2032 if the relation holds componentwise.\nA (maximal) chain over Bn\u2217 is a list of n+ 1 words in B n \u2217 ,\n(v0,v1, . . . ,vn),\nwhere v0 is a word in Bn and for each i \u2208 [n\u3009, the word vi+1 is obtained from vi by changing one non-\u2217 entry into a \u2217; thus, vn is always the all-\u2217 word.5 It is rather easy to see that the number of chains over Bn\u2217 is 2\nn \u00b7 n!. An antichain in Bn\u2217 (respectively, B n \u2022 ) is a subset A of Bn\u2217 (respectively, Bn\u2022 ) such that v v \u2032 for any two distinct words v,v\u2032 \u2208 A. For a word v \u2208 Bn\u2022 and a symbol \u03c3 \u2208 B\u2022, we denote by w\u03c3(v) the number of occurrences of the symbol \u03c3 in v. For w \u2208 [0 : n], let\nBn\u2217 (w) = { v \u2208 Bn\u2217 : w0(v) + w1(v) = w } .\n5The definition of a chain can also be extended to Bn\u2022 , but our analysis below will use a shortcut that will not require this extension.\n5 The following lemma is a generalization of Sperner\u2019s theo-\nrem [1, p. 2].\nLemma 5. Let A be an antichain in Bn\u2217 . Then\n|A| \u2264 ( n\n\u230an/3\u230b\n) \u00b7 2\u23082n/3\u2309,\nwith equality attained by the set Bn\u2217 (\u23082n/3\u2309). Proof. We adapt Lubell\u2019s proof of Sperner\u2019s theorem (in [9]) to our setting. Let A be an antichain and for w \u2208 [0 : n], let A(w) = A\u2229Bn\u2217 (w). We first observe that any word v \u2208 A(w) is contained in exactly\n2n\u2212w \u00b7 w!(n\u2212 w)! chains over Bn\u2217 and none of the other words in those chains belongs to A. Hence,\n\u2211\nw\u2208[0:n]\n2n\u2212w \u00b7 w!(n\u2212 w)! \u00b7 |A(w)| \u2264 2n \u00b7 n!,\nwhich can also be written as\n\u2211\nw\u2208[0:n]\n|A(w)| \u03b2(w) \u2264 1, (6)\nwhere\n\u03b2(w) = 2w \u00b7 ( n\nw\n) .\nThe latter expression is maximized when w = wmax = \u23082n/3\u2309 and, so,\n|A| = \u2211\nw\u2208[0:n]\n|A(w)|\n\u2264 \u2211\nw\u2208[0:n]\n\u03b2(wmax)\n\u03b2(w) \u00b7 |A(w)|\n(6) \u2264 \u03b2(wmax) = ( n\n\u230an/3\u230b\n) \u00b7 2\u23082n/3\u2309.\nThe inequalities become equalities when A = Bn\u2217 (\u23082n/3\u2309) which is, indeed, an antichain.\nThe counterpart of Lemma 5 for Bn\u2022 takes the following form.\nLemma 6. Let A be an antichain in Bn\u2022 . Then\n|A| \u2264 ( 2n\nn\n) ,\nwith equality attained by the set\nBn\u229b = { v \u2208 Bn\u2022 : w\u2022(v) = w\u2217(v) }\n(namely, Bn\u229b is the set of all words in B n \u2022 in which the symbols \u2022 and \u2217 have the same count). Proof. Consider the following mapping \u03bb : B\u2022 \u2192 B2:\n\u03bb(\u2022) = 00, \u03bb(0) = 01, \u03bb(1) = 10, \u03bb(\u2217) = 11. We extend this definition to a mapping from words v = (vj)j\u2208[n\u3009 \u2208 Bn\u2022 to words in B2n by\n\u03bb(v) = \u03bb(v0)\u2016\u03bb(v1)\u2016 . . . \u2016\u03bb(vn\u22121)\n(with \u2016 denoting concatenation) and, accordingly, from subsets of Bn\u2022 to subsets of B\n2n. Clearly, \u03bb is a bijection under all these settings. Moreover, a subset A \u2286 Bn\u2022 is an antichain in Bn\u2022 , if and only if \u03bb(A) is an antichain in B2n under the ordering 0 \u2264 1 on the elements of B; namely, there are no two distinct words v,v\u2032 \u2208 A such that \u03bb(v) \u2264 \u03bb(v\u2032) (componentwise). Hence, by Sperner\u2019s theorem we have, for every antichain A in Bn\u2022 ,\n|A| = |\u03bb(A)| \u2264 ( 2n\nn\n) ,\nwith equality holding when A is the following subset of Bn\u2022 (see [1, p. 2]):\n{ v \u2208 Bn\u2022 : w0(\u03bb(v)) = w1(\u03bb(v)) = n } .\nOne can easily verify that this set is identical to Bn\u229b.\nWe now turn to stating our result for the family \u03a6 = Eq under Scenarios (\u2217\u2022) and (\u2022\u2022).\nProposition 7. The following holds for the subset Eq . (a) Under Scenario (\u2217\u2022), it is n-cell implementable, if and\nonly if\nq \u2264 ( n\n\u230an/3\u230b\n) \u00b7 2\u23082n/3\u2309.\n(b) Under Scenario (\u2022\u2022), it is n-cell implementable, if and only if\nq \u2264 ( 2n\nn\n) .\nProof. Starting with proving necessity, we observe that the mapping x 7\u2192 u(x) has to be injective and its set of images has to be an antichain in Bn\u2217 (for part (a)) or in B n \u2022 (for part (b)): indeed, if we had u(x) u(x\u2032) for distinct x, x\u2032 \u2208 [q\u3009 then, from Eq(x, x) = T(u(x),\u03d1(x)) = 1 we would get the contradiction Eq(x\n\u2032, x) = T(u(x\u2032),\u03d1(x)) = 1. The sought result then follows from Lemmas 5 and 6.\nSufficiency follows by selecting x 7\u2192 u(x) to be any injective mapping into Bn\u2217 (\u23082n/3\u2309) (for part (a)) or into Bn\u229b (for part (b)) and defining t 7\u2192 \u03d1(t) for every t \u2208 [q\u3009 as follows:\n\u03d1j(t) =   \nuj(t) if uj(t) \u2208 B \u2022 if uj(t) = \u2217 \u2217 if uj(t) = \u2022 .\nUsing known approximations for the binomial coefficients\n(see [10, p. 309]), the inequalities in parts (a) and (b) of\nProposition 7 are implied by\nq \u2264 3 4 \u221a n \u00b7 3n and q \u2264 1 2 \u221a n \u00b7 4n,\nrespectively. This means that q can almost get to the size of Bn\u2217 (in part (a)) or of B n \u2022 (in part (b)) (this size would have been reachable if T(\u00b7, \u00b7) had been defined so that T(u, \u03d1) = 1 if and only if u = \u03d1, for any u, \u03d1 \u2208 B\u2022).\nRemark 1. Referring to the mapping \u03bb : B\u2022 \u2192 B2 in the proof of Lemma 6, for any u \u2208 B\u2022, denote by \u03bb0(u) and\n6 \u03bb1(u) the first and second entries (in B) of \u03bb(u). It is fairly easy to see that for every u, \u03d1 \u2208 B\u2022,\nT(u, \u03d1) = ( \u03bb0(u) \u2228 \u03bb1(\u03d1) ) \u2227 ( \u03bb1(u) \u2228 \u03bb0(\u03d1) ) .\nIn fact, this is (essentially) how TCAM cells are implemented in [6, Fig. 2(a)] and in [7, Fig. 1]. Given a family \u03a6 \u2286 Fq, we can therefore rewrite (2) as\nf(x) = \u2227\nj\u2208[2n\u3009\n( u\u0303j(x) \u2228 \u03d1\u0303j(f) )\nwith mappings u\u0303 : [q\u3009 \u2192 B2n and \u03d1\u0303 : \u03a6 \u2192 B2n that satisfy certain constraints, depending on the scenario (the only exception is Scenario (\u2022\u2022), where no constraints are imposed).\nIII. THE FAMILY Nq In this section, we consider the family \u03a6 = Nq. As we did in Section II, we will identify each function x 7\u2192 Nq(x, t) \u2208 Nq by the parameter t \u2208 [q\u3009 and will use the notation t 7\u2192 \u03d1(t) for Nq(\u00b7, t) 7\u2192 \u03d1(Nq(\u00b7, t)). And, here, too, it will suffice to state the results only for Scenarios (\u25e6\u2217), (\u2217\u2217), (\u2217\u2022), and (\u2022\u2022).\nProposition 8. Under Scenario (\u25e6\u2217), the family Nq is n-cell implementable, if and only if\nq \u2264 {\n2 if n = 1 n if n \u2265 2 .\nProof. The case n = 1 is easily verified, so we assume hereafter in the proof that n \u2265 2.\nSufficiency follows from Proposition 1 or 2 (see Table III),\nand necessity follows essentially from the proof of Theorem 1\nin [11]; we include a proof for completeness and for reference in the sequel. Suppose that Eq. (2) holds for Nq with mappings u : [q\u3009 \u2192 Bn and \u03d1 : Nq \u2192 Bn\u2217 ; both these mappings are necessarily injective. For every t \u2208 [q\u3009 we have T(u(t),\u03d1(t)) = Nq(t, t) = 0 and, so, there exists an index j \u2208 [n\u3009 such that \u03d1j(t) \u2208 B and uj(t) 6= \u03d1j(t); moreover, there is no loss of generality in assuming that all the other entries in \u03d1(t) are \u2217. Assume now to the contrary that q > n \u2265 2. By the pigeonhole principle there exist distinct t0, t1 \u2208 [q\u3009 for which that index j is the same. Since the mapping \u03d1 is injective, we must have \u03d1j(t0) 6= \u03d1j(t1). Yet then, for (any) t2 6= t0, t1 in [q\u3009 we have uj(t2) 6= \u03d1j(ti) for some i \u2208 [2\u3009, thereby yielding the contradiction Nq(t2, ti) = T(u(t2),\u03d1(ti)) = 0.\nRecall from Propositions 1 and 2 that the whole set Fq is q-cell implementable and that any subset \u03a6 of Fq of size |\u03a6| < q is (q \u2212 1)-cell implementable. Proposition 8 implies that for any q \u2265 3 and under Scenarios (\u2217\u25e6) and (\u25e6\u2217), the family Nq is a smallest possible subset of Fq that requires the same number of cells, q, as the whole set Fq does.\nProposition 9. Under each of the scenarios (\u2217\u2217), (\u2217\u2022), or (\u2022\u2022), the family Nq is n-cell implementable, if and only if q \u2264 2n. Proof. Sufficiency follows from Proposition 3 which, for the family Nq , holds in fact also under Scenario (\u2217\u2217): specifically,\nfor this family, the range of the mapping \u03d1 in (5) is actually Bn\u2217 . We next prove necessity under (the loosest) Scenario (\u2022\u2022),\nand our arguments will be similar to those used in the previous proof. Specifically, assuming that Eq. (2) holds, for every t \u2208 [q\u3009 there exists an index j \u2208 [n\u3009 such that uj(t), \u03d1j(t) \u2208 B \u222a {\u2022} and either \u03d1j(t) = \u2022 or uj(t) 6= \u03d1j(t); moreover, all the other entries in \u03d1(t) can be assumed to be \u2217. Suppose to the contrary that q > 2n. By the pigeonhole principle there exist distinct t0, t1, t2 \u2208 [q\u3009 for which that index j is the same. Since \u03d1 is injective, we must have \u03d1j(ti) = \u2022 for (exactly) one i \u2208 [3\u3009. Yet then Nq(tk, ti) = T(u(tk),\u03d1(ti)) = 0 for k \u2208 [3\u3009 \\ {i}, which is a contradiction.\nIV. THE FAMILY Gq In this section, we consider the family \u03a6 = Gq . We again identify each function x 7\u2192 \u0393q(x, t) \u2208 Gq by the parameter t \u2208 [q\u3009 and use the notation t 7\u2192 \u03d1(t) for \u0393q(\u00b7, t) 7\u2192 \u03d1(\u0393q(\u00b7, t)). Clearly, \u0393q(x, t) = T(u(x),\u03d1(t)) if and only if Lq(x, t) = T(u\n\u2032(x),\u03d1\u2032(t)), where u\u2032(x) = u(q\u22121\u2212x) and \u03d1\u2032(t) = \u03d1(q\u22121\u2212t); hence, our analysis will apply just as well to \u03a6 = Lq . Moreover, since \u0393q(x, t) = Lq(t, x), it will suffice to state the results only for Scenarios (\u25e6\u2217), (\u2217\u2217), (\u2217\u2022), and (\u2022\u2022).\nProposition 10. Under Scenario (\u25e6\u2217), the family Gq is ncell implementable, if and only if\nq \u2264 n+ 1. Proof. Necessity will follow from the proof of Proposition 11 below and sufficiency follows by defining x 7\u2192 u(x) and t 7\u2192 \u03d1(t) as follows:\nuj(x) = { 0 if x \u2264 j 1 if x > j\nand \u03d1j(t) = { \u2217 if t \u2264 j 1 if t > j\n(these mappings are also shown in Table IV).\nProposition 11. Under Scenario (\u2217\u2217), the family Gq is ncell implementable, if and only if\nq \u2264 {\n2n if n = 1, 2 2n+ 1 if n \u2265 3 .\nProof. Starting with proving necessity, suppose that Eq. (2) holds. For each j \u2208 [n\u3009, let yj denote the smallest t \u2208 [q\u3009 such that \u03d1j(t) \u2208 B (define yj = \u221e if no such t exists). By possibly switching between the roles of 0 and 1 in t 7\u2192 \u03d1j(t) and in\n7 x 7\u2192 uj(x), we can assume without loss of generality that \u03d1j(yj) = 1. We now observe from Eq. (2) that uj(x) \u2208 {1, \u2217} for every x \u2265 yj . Thus, (2) still holds if we re-define \u03d1j(t) to be equal to 1 at every t > yj for which \u03d1j(t) = \u2217. Hence, we assume hereafter without loss of generality that\n\u03d1j(yj) = 1 and \u03d1j(t) \u2208 B for every t > yj (provided that yj < \u221e).\nNext, for each j \u2208 [n\u3009, we let zj be the smallest t \u2208 [yj : q\u3009 such that \u03d1j(t) = 0 (with zj = \u221e if no such t exists). Note that for Eq. (2) to hold, we must have\nuj(x) = \u2217 for every x \u2265 zj . (7)\nIn particular, under Scenario (\u25e6\u2217) (as in Proposition 10), we must have zj = \u221e for every j \u2208 [n\u3009.\nIn summary, the mapping t 7\u2192 \u03d1(t) is assumed hereafter to take the following form:\n\u03d1j(t) =    \u2217 if t < yj 1 if yj \u2264 t < zj 0 if t = zj 0 or 1 if t > zj . (8)\nNext, we claim that\n[1 : q\u3009 \u2286 \u22c3\nj\u2208[n\u3009\n{yj, zj} (9)\n(where the right-hand side is regarded as a set, ignoring\nmultiplicities). Indeed, suppose to the contrary that there exists some y \u2208 [1 : q\u3009 such that y /\u2208 {yj, zj} for every j \u2208 [n\u3009. By (7) and (8) we then have, for every j \u2208 [n\u3009:\n\u03d1j(y) = \u2217 if y < yj \u03d1j(y) = \u03d1j(y \u2212 1) (= 1) if yj < y < zj uj(y \u2212 1) = \u2217 if y > zj . (10)\nHence,6\n\u0393q(y \u2212 1, y) (2)= T(u(y \u2212 1),\u03d1(y)) y 6=yj,zj\n= ( \u2227\nj : y<yj T(uj(y \u2212 1), \u03d1j(y)\ufe38 \ufe37\ufe37 \ufe38 \u2217\n) )\n\u2227 ( \u2227\nj : yj<y<zj\nT(uj(y \u2212 1), \u03d1j(y)) )\n\u2227 ( \u2227\nj : y>zj T(uj(y \u2212 1)\ufe38 \ufe37\ufe37 \ufe38 \u2217\n, \u03d1j(y)) )\n(10) =\n\u2227\nj : yj<y<zj\nT(uj(y \u2212 1), \u03d1j(y))\n(10) =\n\u2227\nj : yj<y<zj\nT(uj(y \u2212 1), \u03d1j(y \u2212 1))\n(2) = 1,\nwhich is a contradiction. By (9) we thus conclude that q\u22121 \u2264 2n, thereby proving the necessary condition for n \u2265 3 (leaving the special cases of n = 1, 2 to Appendix A). Moreover, when the range of u is constrained to Bn, then zj = \u221e for every\n6A conjunction over an empty set is defined to be 1.\nj \u2208 [n\u3009 and, so, by (9) we get q \u2212 1 \u2264 n, thus proving the necessary condition in Proposition 10.\nSufficiency follows from the mappings shown in Table V;\nin that table, u(0) and \u03d1(2n) can be set to any two words in Bn\u2217 that start and end with a 0 and T(u(x),\u03d1(2n)) = 0 (e.g., we can take u(0) and \u03d1(2n) to be distinct in Bn that start and end with a 0). Note that this is always possible when n \u2265 3; for n = 1, 2 we restrict the table to the rows that correspond to x, t \u2208 [2n\u3009.\nProposition 12. Under each of the scenarios (\u2217\u2022) or (\u2022\u2022), the family Gq is n-cell implementable, if and only if\nq \u2264 2n+ 1. Proof. Necessity will follow from the proof of Proposition 16 below, and sufficiency follows from the mappings x 7\u2192 u(x) and t 7\u2192 \u03d1(t) defined in (4)\u2013(5) and extended to the domain [2n+ 1\u3009 by:\nu(2n) = \u2217\u2217 . . . \u2217 and \u03d1(2n) = \u2022\u2022 . . . \u2022. (For n \u2265 3, we can also use the mappings in Table V.)\nV. THE FAMILY Gq \u222a Lq In this section, we consider the family \u03a6 = Gq \u222a Lq . For the subset Gq of functions in this family, we use\u2014as in Section IV\u2014the notation t 7\u2192 \u03d1(t) for \u0393q(\u00b7, t) 7\u2192 \u03d1(\u0393q(\u00b7, t)). For the remaining subset Lq , we use t 7\u2192 \u03d1\u2032(t) for Lq(\u00b7, t) 7\u2192 \u03d1(Lq(\u00b7, t)) so that (2) becomes\nLq(x, t) = T(u(x),\u03d1 \u2032(t)). (11)\nProposition 13. Under Scenario (\u2217\u25e6), the family Gq \u222a Lq is n-cell implementable, if and only if\nq \u2264 n. Proof. Sufficiency follows from Proposition 1. As for necessity, we consider first just the q mappings x 7\u2192 \u0393q(x, t) in Gq \u222a Lq and refer to the containment (9) in the proof of Proposition 11. For Scenario (\u2217\u25e6) we have yj = 0 for all j \u2208 [n\u3009 and, so,\n[1 : q\u3009 \u2286 { zj : j \u2208 [n\u3009 } .\n8 If zj = \u221e for at least one j \u2208 [n\u3009 we are done. Otherwise, by (7), we must have u(q\u22121) = \u2217\u2217 . . . \u2217, yet this would imply Lq(q \u2212 1, 0) = T(u(q \u2212 1),\u03d1\u2032(0)) = 1, which is impossible.\nProposition 14. Under Scenario (\u25e6\u2217), the family Gq \u222a Lq is n-cell implementable, if and only if\nq \u2264 n+ 1.\nProof. Necessity follows from Proposition 10. Sufficiency follows by taking the mappings x 7\u2192 u(x) and t 7\u2192 \u03d1(t) as in the proof of that proposition and defining the mapping t 7\u2192 \u03d1\u2032(t) by \u03d1\u2032j(t) = { 0 if t \u2264 j \u2217 if t > j .\nProposition 15. Under each of the scenarios (\u2217\u2217) or (\u2022\u2217), the family Gq \u222a Lq is n-cell implementable, if and only if\nq \u2264 {\n2 if n = 1 2n\u2212 1 if n \u2265 2 .\nProof. Sufficiency follows from Table VI for n \u2265 2 (some symbols in the table are underlined to make it easier to see\nthe general pattern). As for n = 1, we take:\nx u(x)\n0 0 1 1\nt \u03d1(t) \u03d1\u2032(t) 0 \u2217 0 1 1 \u2217\nWe show necessity by induction on n. Suppose that Eq. (2) holds and, for j \u2208 [n\u3009, let yj and zj be defined for the mapping t 7\u2192 \u03d1(t) in as in the proof of Proposition 11. Also, let y\u2032j be the largest t \u2208 [q\u3009 such that \u03d1\u2032j(t) \u2208 B (define y\u2032j = \u2212\u221e if no such t exists) and let z\u2032j be the largest t \u2208 [y\u2032j\u3009 such that \u03d1\u2032j(t) 6= \u03d1\u2032j(y\u2032j) (with z\u2032j = \u2212\u221e if no such t exists).7 Denote by Y (respectively, Y \u2032) the set of all indexes j \u2208 [n\u3009 such that yj (respectively, y\u2032j) is finite and by Z (\u2286 Y ) (respectively, Z \u2032 (\u2286 Y \u2032)) the set of all indexes j \u2208 [n\u3009 such that zj (respectively, z \u2032 j) is finite Clearly, |Z| \u2264 |Y | \u2264 n and |Z \u2032| \u2264 |Y \u2032| \u2264 n and, by (9) (when applied to x 7\u2192 u(x) and t 7\u2192 \u03d1(t) on the one hand, and to x 7\u2192 u(q\u22121\u2212x) and t 7\u2192 \u03d1\u2032(q\u22121\u2212t) on the other hand), we get:\nq \u2212 1 \u2264 min{|Y |+ |Z|, |Y \u2032|+ |Z \u2032|}. (12)\nIf Y = Z = [n\u3009 then necessarily u(q \u2212 1) = \u2217\u2217 . . . \u2217 (by (7)), yet this would imply by (2) that Lq(q \u2212 1, 0) = 1, which is impossible. Hence, |Y |+ |Z| \u2264 2n\u22121 and, similarly, |Y \u2032| + |Z \u2032| \u2264 2n \u2212 1. We conclude that the right-hand side of (12) is at most 2n \u2212 1, thereby establishing the necessity condition for the induction base n = 1, and also when min{|Y |+ |Z|, |Y \u2032|+ |Z \u2032|} \u2264 2n\u2212 2.\nIt remains to consider the case where Y = Y \u2032 = [n\u3009 and |Z| = |Z \u2032| = n\u2212 1. By (7), the entries of u(q \u2212 1) are then all \u2217 except one, and the same applies to u(0). Without loss of\n7In other words, if y\u0302j and z\u0302j are defined for the mapping t 7\u2192 \u03d1\u0302j(t) = \u03d1\u2032j(q\u22121\u2212t) as yj and zj were defined for t 7\u2192 \u03d1j(t) in the proof of Proposition 11, then y\u2032j = q\u22121\u2212y\u0302j and z \u2032 j = q\u22121\u2212z\u0302j .\ngenerality we can assume that Z = [n\u2212 1\u3009, thereby implying that\nu(q \u2212 1) = \u2217\u2217 . . . \u2217\u2022 or u(q \u2212 1) = \u2217\u2217 . . . \u22171. In the first case we must have \u03d1n\u22121(t) = \u2217 for all t \u2208 [q\u3009, thus effectively reducing the value of n by 1 when writing (2) for the functions in Gq within Gq \u222a Lq; by Proposition 11 we then get q \u2264 2(n\u2212 1) + 1 = 2n\u2212 1. In the remaining part of the proof we assume that u(q \u2212 1) = \u2217\u2217 . . . \u22171; this, in turn, forces having\n\u03d1\u2032n\u22121(t) = 0 for all t \u2208 [q \u2212 1\u3009. (13) We distinguish between the two possible values for \u03d1\u2032n\u22121(q\u2212 1).\nCase 1: \u03d1\u2032n\u22121(q \u2212 1) = 1. Here we get from (13) that un\u22121(x) = \u2217 for all x \u2208 [q \u2212 1\u3009, which means that Eq. (2) holds for all f \u2208 Gq\u222aLq with q and n in (2) replaced by q\u22121 and n\u2212 1, respectively. Hence, by the induction hypothesis,\nq \u2212 1 \u2264 max{2(n\u2212 1)\u2212 1, 2}, namely, q \u2264 max{2n\u2212 2, 3} \u2264 2n\u2212 1 when n \u2265 2.\nCase 2: \u03d1\u2032n\u22121(q \u2212 1) = \u2217. Here we get from (13) that Z \u2032 = Z = [n \u2212 1\u3009, which means that the unique non-\u2217 entry in u(0) must be its last (i.e., co-located with the unique non-\u2217 entry in u(q \u2212 1)). Recalling that \u03d1\u2032n\u22121(0) = 0 (by (13)), we must then have u(0) = \u2217\u2217 . . . \u22170, thereby implying that\n\u03d1n\u22121(t) = 1 for all t \u2208 [1 : q\u3009. Combining this with (13) we must also have un\u22121(x) = \u2217 for all x \u2208 [1 : q \u2212 1\u3009. We conclude that Eq. (2) holds for all f \u2208 Gq \u222a Lq with n in that equation replaced by n \u2212 1 and with x and t restricted to [1 : q \u2212 1\u3009. Replacing x and t in (2) by x+ 1 and t+ 1, respectively, and noting that \u0393q\u22122(x, t) = \u0393q(x+1, t+1) and Lq\u22122(x, t) = Lq(x+1, t+1) for x, t \u2208 [q \u2212 2\u3009, we get from the induction hypothesis that\nq \u2212 2 \u2264 max{2(n\u2212 1)\u2212 1, 2}, namely, q \u2264 max{2n \u2212 1, 4}. This completes the proof for Case 2 when n > 2. As for n = 2, if q = 4 were attainable, then, from what we have just shown, we would have u1(1) = u1(2) = \u2217, which would imply that u0(1) = \u03d1\u20320(1) \u2208 B and u0(2) = \u03d10(2) \u2208 B and u0(1) 6= u0(2). However, this would mean that L4(x, 0) = T(u0(x), \u03d1 \u2032 0(0)) = 1 for at least one x \u2208 {1, 2} (regardless of the value of \u03d1\u20320(0)), which is a contradiction.\nProposition 16. Under each of the scenarios (\u2217\u2022) or (\u2022\u2022), the family Gq \u222a Lq is n-cell implementable, if and only if\nq \u2264 2n. Proof. Sufficiency follows from Proposition 3.\nNecessity follows from arguments that are similar to (and\nin fact are even simpler than) those that we used in the proofs of Propositions 11 and 15. Specifically, for each j \u2208 [n\u3009, let yj denote the smallest t \u2208 [q\u3009 such that \u03d1j(t) \u2208 B\u222a{\u2022} (with yj = \u221e if no such t exists). By the very same reasoning that was given in the proof of Proposition 11, we can assume\n9\nhereafter without loss of generality that \u03d1j(yj) \u2208 {1, \u2022} and that \u03d1j(t) \u2208 B \u222a {\u2022} for every t > yj .\nNext, for each j \u2208 [n\u3009, let zj be the smallest t \u2208 [yj : q\u3009 such that \u03d1j(t) \u2208 {0, \u2022} (with zj = \u221e if no such t exists). By (7) we then must have uj(x) = \u2217 for every x \u2265 zj and, so, without loss of generality we can assume that \u03d1j(t) = \u2022 for every t \u2265 zj . In summary, the mapping t 7\u2192 \u03d1(t) takes the following form:\n\u03d1j(t) =   \n\u2217 if t < yj 1 if yj \u2264 t < zj \u2022 if t \u2265 zj . (14)\nAs our next step, we show that (9) holds. Indeed, if there were y \u2208 [1 : q\u3009 that did not belong to the right-hand side of (9) then, from (14), we would have \u03d1(y) = \u03d1(y \u2212 1). Yet, by (2), this would mean that \u0393q(y \u2212 1, y) = \u0393q(y, y) = 1, which is a contradiction. From (9) we now get the necessary condition in Proposition 12 (for the family \u03a6 = Gq). The necessary condition for \u03a6 = Gq \u222aLq follows by showing that zj = \u221e for at least one j \u2208 [n\u3009 (and, therefore, the righthand side of (9) contains less than 2n elements). Otherwise, we would have \u03d1(q \u2212 1) = \u2022\u2022 . . . \u2022 and, consequently, u(q \u2212 1) = \u2217\u2217 . . . \u2217, which, with (11), would yield Lq(q\u2212 1, 0) = 1, thereby reaching a contradiction.\nVI. THE WHOLE SET Fq In this section, we treat the case where \u03a6 = Fq (the whole set of functions [q\u3009 \u2192 B). Differently from previous sections, we start with Scenarios (\u2022\u2217) and (\u2022\u2022), as they are rather straightforward.\nProposition 17. Under each of the scenarios (\u2217\u2022) or (\u2022\u2022), the set Fq is n-cell implementable, if and only if\nq \u2264 2n.\nProof. Sufficiency follows from Proposition 3 and necessity\nfollows either from Proposition 9 or by a counting argument: \u03d1 : Fq \u2192 Bn\u2022 is injective and, so, 2q \u2264 22n.\nThe next proposition covers all the remaining scenarios in\nTable II.\nProposition 18. Under each of the scenarios (\u2217\u25e6), (\u25e6\u2217), (\u2217\u2217), or (\u2022\u2217), the set Fq is n-cell implementable, if and only if\nq \u2264 n.\nSufficiency follows from Proposition 1. As for necessity, for Scenarios (\u2217\u25e6) and (\u25e6\u2217) it is implied by Proposition 8 (for Scenario (\u2217\u25e6) we can also use Proposition 13 or just a counting argument). For Scenarios (\u2217\u2217) and (\u2022\u2217), however, some more effort is needed; notice that a counting argument only leads to 2q \u2264 3n, namely, to the weaker inequality q \u2264 n \u00b7 log2 3. The proof of Proposition 18 will use the following notation\nand lemma. Recalling the partial ordering of Section II, for elements u, v \u2208 B\u2022, we denote by \u00b5(u, v) the largest element s \u2208 B\u2022 such that both s u and s v, where \u201clargest\u201d is with respect to . Thus, for every u \u2208 B\u2022,\n\u00b5(u, \u2022) = \u2022, \u00b5(u, \u2217) = \u00b5(u, u) = u, and \u00b5(0, 1) = \u2022.\nThe next lemma is easily verified.\nLemma 19. For every u, v, \u03d1 \u2208 B\u2022,\nT(\u00b5(u, v), \u03d1) = T(u, \u03d1) \u2227T(v, \u03d1).\nProof of Proposition 18 (necessity). We prove necessity under (the loosest) Scenario (\u2022\u2217) by induction on q, with the induction base (q = 2) following from a simple counting argument: there are four distinct functions f : [2\u3009 \u2192 B yet only three choices for (the scalar) \u03d1(f) in this case, hence we must have n \u2265 2.8\nTurning to the induction step, suppose to the contrary that Fq is n-cell implementable for q > n and let u : [q\u3009 \u2192 Bn\u2022 and \u03d1 : Fq \u2192 Bn\u2217 be mappings such that (2) holds for all the functions in Fq; obviously, both these mappings are injective.\nConsider the images of the functions in Nq under \u03d1. As argued in the proof of Proposition 8, we can assume that for each t \u2208 [q\u3009 there is a unique entry in \u03d1(Nq(\u00b7, t)) which is non-\u2217. From q > n we get, by the pigeonhole principle, that there exist two distinct elements t0, t1 \u2208 [q\u3009 for which the position j of such an entry is the same, say j = n\u22121. Without loss of generality we can assume further that t0 = q \u2212 2, t1 = q \u2212 1,\n\u03d1n\u22121(Nq(\u00b7, q \u2212 2)) = 0, and \u03d1n\u22121(Nq(\u00b7, q \u2212 1)) = 1.\nThis, in turn, implies that for every x \u2208 [q\u3009:\nun\u22121(x) =    \u2217 if x \u2208 [q \u2212 2\u3009 1 if x = q \u2212 2 0 if x = q \u2212 1 . (15)\nNext, we define the mappings\nu\u2032 : [q \u2212 1\u3009 \u2192 Bn\u22121\u2022 and \u03d1\u2032 : Fq\u22121 \u2192 Bn\u22121\u2217 8 Note that n = 1 would suffice for q = 2 if we allowed \u03d1(f) to take the value \u2022 as well: this corresponds to Scenario (\u25e6\u2022) and it differs from Scenario (\u25e6\u2217) only when n = 1 and q = 2.\n10\nas follows: for every x \u2208 [q \u2212 1\u3009 and j \u2208 [n\u2212 1\u3009,\nu\u2032j(x) =\n{ uj(x) if x \u2208 [q \u2212 2\u3009\n\u00b5(uj(q \u2212 2), uj(q \u2212 1)) if x = q \u2212 2 , (16)\nand for every f \u2208 Fq\u22121 and j \u2208 [n\u2212 1\u3009, \u03d1\u2032j(f) = \u03d1j(f\u0303), (17)\nwhere f\u0303 is the extension of f to the domain [q\u3009 with f\u0303(q \u2212 1) = f(q \u2212 2).\nIn particular, it follows from (16), (17), and Lemma 19 that for every j \u2208 [n\u2212 1\u3009: T(u\u2032j(q\u22122), \u03d1\u2032j(f))\n= T(uj(q\u22122), \u03d1j(f\u0303)) \u2227T(uj(q\u22121)), \u03d1j(f\u0303)). (18) We show that\nf \u2032(x) = T(u\u2032(x),\u03d1\u2032(f))\nfor every x \u2208 [q\u22121\u3009 and f \u2208 Fq\u22121 which, in turn, will imply that Fq\u22121 is (n\u22121)-cell implementable, thereby contradicting the induction hypothesis. We distinguish between three cases.\nCase 1: x \u2208 [q\u2212 2\u3009. We recall from (15) that un\u22121(x) = \u2217 and, so,\nf(x) = f\u0303(x) (2) = T(u(x),\u03d1(f\u0303 )) (16)+(17) = T(u\u2032(x),\u03d1\u2032(f)).\nCase 2: x = q \u2212 2 and f \u2032(q \u2212 2) = 1. Here f\u0303(q \u2212 2) = f\u0303(q \u2212 1) = 1 and, therefore, from (2), for every j \u2208 [n\u3009,\nT(uj(q \u2212 2), \u03d1j(f\u0303)) = T(uj(q \u2212 1), \u03d1j(f\u0303)) = 1. Hence, by (18), for every j \u2208 [n\u2212 1\u3009,\nT(u\u2032j(q \u2212 2), \u03d1\u2032j(f)) = 1, namely, T(u\u2032(q \u2212 2),\u03d1\u2032(f)) = 1 = f(q \u2212 2).\nCase 3: x = q\u22122 and f(q\u22122) = 0. Here f\u0303(q\u22122) = f\u0303(q\u2212 1) = 0; yet, from (15) we have T(un\u22121(y), \u03d1n\u22121(f\u0303)) = 1 for at least one y \u2208 {q\u2212 2, q\u2212 1}. Hence, from T(u(y),\u03d1(f\u0303)) = f\u0303(y) = 0 there must be at least one index j \u2208 [n \u2212 1\u3009 for which\nT(uj(y), \u03d1j(f\u0303)) = 0,\nand for that index we have, by (18),\nT(u\u2032j(q \u2212 2), \u03d1\u2032j(f)) = 0, namely, T(u\u2032(q \u2212 2),\u03d1\u2032(f)) = 0 = f(q \u2212 2)."
        },
        {
            "heading": "A. Connection to the VC dimension of Boolean monomials",
            "text": "Proposition 18 can be stated also in terms of the VC dimension of the following collection, Hn, of 3n subsets of Bn\u2022 : Hn = { S = S(\u03d1) : \u03d1 \u2208 Bn\u2217 } ,\nwhere, for each \u03d1 \u2208 Bn\u2217 , S(\u03d1) = { v \u2208 Bn\u2022 : T(v,\u03d1) = 1 } .\nWe demonstrate this next.\nLet u : [q\u3009 \u2192 Bn\u2022 and \u03d1 : Fq \u2192 Bn\u2217 be injective mappings. The following two conditions are equivalent for any f \u2208 Fq.\n\u2022 Eq. (2) holds for f . \u2022 The images of x 7\u2192 u(x) form a subset U \u2286 Bn\u2022 of size q\nsuch that\nU \u2229 S(\u03d1(f)) = {u(x) : x \u2208 [q\u3009 such that f(x) = 1}. (19)\nIn particular, if Eq. (2) holds for every f \u2208 Fq, then (19) implies that U is shattered by Hn: each of the 2q subsets of U can be expressed as an intersection U \u2229 S, for some S \u2208 Hn. Conversely, if U is a subset of size q of Bn\u2022 that is shattered by Hn, we can fix some arbitrary bijection u : [q\u3009 \u2192 U and define a mapping \u03d1 : Fq \u2192 Bn\u2217 so that (19) holds for every f \u2208 Fq; specifically, we select \u03d1(f) to be such that S(\u03d1(f)) is an element S \u2208 Hn for which U \u2229S equals the subset of U given by the right-hand side of (19). The largest size q of U for which this holds is the VC dimension of Hn [2, \u00a77.3]. Thus, Proposition 18 states that the VC dimension of Hn is n.\nEquivalently, we can state Proposition 18 in terms of the\nVC dimension of the collection of n-variate Boolean monomials where the evaluation points are taken from Bn\u2022 (rather than just from Bn). Specifically, given a vector of n Boolean indeterminates, \u03be = (\u03bej)j\u2208[n\u3009, we associate with every word \u03d1 = (\u03d1j)j\u2208[n\u3009 \u2208 Bn\u2217 the n-variate Boolean monomial\nM\u03d1(\u03be) = ( \u2227\nj :\u03d1j=0\n\u03bej\n) \u2227 ( \u2227\nj :\u03d1j=1\n\u03bej\n) ,\nwhere \u03bej stands for the complement of \u03bej . Substituting an element of B into a variable \u03bej carries its ordinary meaning (with 0 = 1 and 1 = 0), whereas when substituting \u2217 (respectively, \u2022), both \u03bej and \u03bej are defined to be 1 (respectively, 0). Under these rules, S(\u03d1) is the set of all words in Bn\u2022 at which M\u03d1(\u03be) evaluates to 1. Scenario (\u25e6\u2217) corresponds to the case where the evaluation points are restricted to Bn and, for this scenario, it was shown in [11] that the VC dimension of the set of all\nn-variate monomials equals n. Proposition 18 implies that the VC dimension does not increase even if we extend the set of evaluation points to Bn\u2022 . 9"
        },
        {
            "heading": "B. Subsets that are as hard to implement as Fq",
            "text": "Recall that under Scenarios (\u2217\u25e6), (\u25e6\u2217), (\u2217\u2022), and (\u2022\u2022), there are small subsets of Fq which are n-cell implementable, (if and) only if Fq is; e.g., Nq is such as subset of size q = log2 |Fq|. In contrast, it turns out that under Scenarios (\u2217\u2217) and (\u2022\u2217), the condition q \u2264 n becomes necessary only for fairly large subsets of Fq. The next two propositions (which we prove in Appendix B) imply that, with very few exceptions, a deletion of just a single function from Fq results in a subset which is (q \u2212 1)-cell implementable.\nHenceforth, x 7\u2192 1q(x) stands for the tautology function over [q\u3009 (which evaluates to 1 on all the elements of [q\u3009).\nProposition 20. Let \u03a6 = Fq\\{g} where g is any function in Fq that is not in Eq\u222a{1q}. Under Scenario (\u2217\u2217), the subset \u03a6 is n-cell implementable, if and only if\nq \u2264 n+ 1. 9A setting where some variables are allowed to be \u201cunspecified\u201d has been studied in the literature (see, for example, [3]), yet the meaning of \u2217 therein is different.\n11\nProposition 21. Let \u03a6 = Fq \\ {g} where g is any function in Fq \\ {1q}. Under Scenario (\u2022\u2217), the subset \u03a6 is n-cell implementable, if and only if\nq \u2264 n+ 1. It readily follows from Proposition 20 that under Scenario (\u2217\u2217), any subset of Fq of size smaller than 2q \u2212 q is (q \u2212 1)-cell implementable, except (possibly) for the subset\nF\u22c6q = Fq \\ ( Eq \u222a {1q} ) . (20)\nAnd by the following result (which we also prove in Ap-\npendix B), this subset is indeed an exception.\nProposition 22. For q \u2265 3, the subset F\u22c6q in (20) is n-cell implementable under Scenario (\u2217\u2217), (if and) only if Fq is.\nSimilar claims can be stated for Scenario (\u2022\u2217), yet with the subset in (20) replaced by\nFq \\ {1q}. Specifically, all other proper subsets of Fq are (q \u2212 1)-cell implementable."
        },
        {
            "heading": "VII. DISCUSSION",
            "text": "We can see from Table II that under all scenarios and for all families of functions therein except Eq, the number n of cells must grow linearly with the alphabet size q. While this is expected for the whole set Fq (simply because of a counting argument), this also holds for the families Nq , Gq , Lq (and Gq\u222a Lq), which are only of size O(q). This means that for the latter families, CAM implementations are necessarily exponential in the (bit) representation of the parameter t \u2208 [q\u3009 that identifies each function in the family, as well as in the representation of the input x \u2208 [q\u3009 to each function. Thus, some hardware modification is inevitable if more efficient implementations are\nsought.\nAnd this is indeed possible. For example, suppose that q = 2n and we wish to implement each function x 7\u2192 Nq2(x, t) in Nq2 under Scenario (\u2217\u2217), (\u2022\u2217), (\u2217\u2022), or (\u2022\u2022). We can express each x, t \u2208 [q2\u3009 as\nx = x1q + x0 and t = t1q + t0,\nwhere x0, x1, t0, t1 \u2208 [q\u3009, and observe that Nq2(x, t) = Nq(x0, t0) \u2228 Nq(x1, t1). (21)\nThus, while we have squared the alphabet size, the right-hand side of (21) requires only q = 2n cells (and not q2/2 = 2n2\ncells), yet such cells have to be arranged in two n-cell blocks that are connected serially (to compute the disjunction \u2228), as opposed to the ordinary parallel connection among the cells\nalong a row in the CAM."
        },
        {
            "heading": "APPENDIX A SPECIAL CASES IN PROPOSITION 11",
            "text": "We verify here the necessary condition q \u2264 2 for n = 1, and q \u2264 4 for n = 2.\nStarting with n = 1, suppose to the contrary that Eq. (2) can hold for q = 2n + 1 = 3. By (9) we then have y0 = 1\nand z0 = 2, namely, \u03d1(0) = \u2217, \u03d1(1) = 1, and \u03d1(2) = 0. Yet this means that \u03933(0, t) = T(u(0), \u03d1(t)) = 1 for at least one t \u2208 {1, 2} (regardless of the value of u(0)), which is absurd.\nTurning to n = 2, suppose to the contrary that Eq. (2) holds for q = 2n + 1 = 5. Again, by (9) we have {1, 2, 3, 4} = {y0, z0, y1, z1}, where y0 < z0 and y1 < z1. Without loss of generality we assume that z0 > z1, in which case z0 = 4 and, so \u03d10(3) = 1 and \u03d10(4) = 0 (see (8)). Now, if z1 < 3 then, by (7), we would have u1(2) = \u2217; yet then \u03935(2, t) = T(u0(2), \u03d10(t)) = 1 for at least one t \u2208 {3, 4}, which is impossible. Hence, z1 = 3, and from (8) we get \u03d11(2) = 1 and \u03d11(3) = 0; moreover, {y0, y1} = {1, 2} and, so, \u03d10(2) = 1. In summary, we have shown that \u03d1(2) = 11, \u03d1(3) = 10, and \u03d10(4) = 0. Now, since \u03935(x, t) = T(u(x),\u03d1(t)) = 0 for x \u2208 {0, 1} and t \u2208 {2, 3}, we must have u0(0) = u0(1) = 0 (= \u03d10(4)), which implies that u1(0) 6= u1(1). But this means that \u03935(x, 4) = T(u1(x), \u03d11(4)) = 1 for at least one x \u2208 {0, 1}, which is a contradiction."
        },
        {
            "heading": "APPENDIX B",
            "text": "MORE ON THE WHOLE SET Fq We provide in this appendix the proofs of Propositions 20,\n21, and 22.\nWe will sometimes find it convenient to represent a function f \u2208 Fq by its truth table f = (f(x))x\u2208[q\u3009 \u2208 Bq; for example, 11 . . .1 represents the tautology function x 7\u2192 1q(x) over [q\u3009 and 00 . . . 0 represents the all-zero function, which we denote by x 7\u2192 0q(x).\nThe next lemma provides the necessity part in Proposi-\ntion 21 (and, therefore, also in Proposition 20).\nLemma 23. Let \u03a6 = Fq \\ {g} where g is any function in Fq \\ {1q}. Under Scenario (\u2022\u2217), the subset \u03a6 is n-cell implementable, only if\nq \u2264 n+ 1.\nProof. Suppose that (2) holds for the functions in \u03a6 with the mappings u\u2032 : [q\u3009 \u2192 Bn\u2022 and \u03d1\u2032 : \u03a6 \u2192 Bn\u2217 . Since g 6= 1q , there exists a function g \u2208 \u03a6 which is identical to g on the whole domain [q\u3009 except for one element y \u2208 [q\u3009 at which g(y) = 0 yet g(y) = 1.\nDefine the mappings u : [q\u3009 \u2192 Bn+1\u2022 and \u03d1 : Fq \u2192 Bn+1\u2217 as follows. For every x \u2208 [q\u3009,\nu(x) = { u\u2032(x) \u2217 if x 6= y u\u2032(y) 0 if x = y\n(namely, u(x) is obtained from u\u2032(x) by appending a \u2217 or a 0, depending on x), and for every f \u2208 Fq,\n\u03d1(f) = { \u03d1\u2032(f) \u2217 if f 6= g \u03d1\u2032(g) 1 if f = g .\nIt can be verified that f(x) = T(u(x),\u03d1(f)) for every x \u2208 [q\u3009 and f \u2208 Fq , which means that Fq is (n + 1)-cell implementable under Scenario (\u2022\u2217). The result follows from Proposition 18.\nThe next lemma provides the sufficiency part in Proposition 20 (and, therefore, also in Proposition 21 for q \u2265 3) for the\n12\nspecial case where f contains exactly one 0; due to symmetry, we can assume that f = 11 . . .110, i.e., f(x) = Lq(x, q\u2212 2).\nLemma 24. Under Scenario (\u2217\u2217), the subset \u03a6 = Fq \\ {Lq(\u00b7, q \u2212 2)} is n-cell implementable, whenever\n3 \u2264 q \u2264 n+ 1.\nProof. We present mappings u : [q\u3009 \u2192 Bq\u22121\u2217 and \u03d1 : \u03a6 \u2192 Bq\u22121\u2217 for which (2) holds for every f \u2208 \u03a6. We take the mapping u to be\nu(q \u2212 1) = 00 . . . 0 (22)\nand, for x \u2208 [q \u2212 1\u3009:\nuj(x) =    1 if x = j 0 if x = \u3008j+1\u3009 \u2217 otherwise , (23)\nwhere \u3008\u00b7\u3009 = \u3008\u00b7\u3009q\u22121 denotes the remainder (in [q\u2212 1\u3009) modulo q\u2212 1; namely, u(x) is obtained from the unary representation of x by changing all the 0\u2019s into \u2217\u2019s, except the 0 that immediately precedes the (unique) 1 in that representation (with indexes extended cyclically modulo q \u2212 1). Table VII shows this mapping for q = n + 1 = 5. Thus, u(x) contains at least one 0 for every x \u2208 [q\u3009 (recall that n \u2265 2).\nTurning to the mapping \u03d1, we select it so that\n\u03d1(0q) = 11 . . . 1 (24)\n(indeed, T(u(x),\u03d1(0q)) = 0 for all x \u2208 [q\u3009); for all functions other than 0q and Lq(\u00b7, q \u2212 2) we let\n\u03d1j(f) =    0 if f(j) = 0 1 if f(j) = 1 and f(\u3008j+1\u3009) = f(q\u22121) = 0 \u2217 otherwise .\n(25)\nSpecifically, \u03d1(f) is obtained from the (q \u2212 1)-prefix of the truth table, f , of f by changing into \u2217\u2019s all the 1\u2019s (if f(q \u2212 1) = 1), or just the 1\u2019s that immediately precede other 1\u2019s (if f(q \u2212 1) = 0, with indexes taken modulo q \u2212 1). Table VIII shows this mapping for q = n + 1 = 4 (note the missing entry from the table, f = 1110, which corresponds to f(x) = L4(x, 2)). Thus, \u03d1(f) will contain at least one 1 if and only if f(q \u2212 1) = 0 and, so, T(u(q \u2212 1),\u03d1(f)) = f(q \u2212 1).\nIt remains to show that Eq. (2) holds when x \u2208 [q\u2212 1\u3009 and f 6= 0q . If x is such that f(x) = 0 then, by (23) and (25),\nux(x) = 1 yet \u03d1x(f) = 0\nand, so, T(u(x),\u03d1(f)) = 0 = f(x). On the other hand, if f(x) = 1 then, for every j \u2208 [q \u2212 1\u3009:\nuj(x) = \u2217 if j 6\u2208 {x, \u3008x\u2212 1\u3009}\nand\nuj(x) = 1 and \u03d1j(f) \u2208 {1, \u2217} if j = x.\nAs for the index j = \u3008x \u2212 1\u3009, here uj(x) = 0 while \u03d1j(f) 6= 1 in this case (since f(\u3008j+1\u3009) = f(x) = 1). Hence, T(u(x),\u03d1(f)) = 1 = f(x).\nRemark 2. The case q = n + 1 = 2 was excluded from Lemma 24, since, under Scenario (\u2217\u2217), the lemma does not hold for the set\n\u03a6 = F2 \\ {L2(\u00b7, 0)} = {02,\u03932(\u00b7, 1), 12}. (26)\nIndeed, regardless of how we select \u03d1(02), we would get T(u(x), \u03d1(02)) = 1 for at least one x \u2208 [2\u3009.\nHowever, the lemma does hold for the set (26) under\nScenario (\u2022\u2217) by taking\nu(0) = \u2022, u(1) = 1\nand\n\u03d1(02) = 0, \u03d1(\u03932(\u00b7, 1)) = 1, \u03d1(12) = \u2217.\nProof of Proposition 20 (sufficiency). We show that q = n+1 is achievable by induction on n. For n = 1, the only choice for g is 02, in which case we take\nu(0) = 0, u(1) = 1, (27)\nand\n\u03d1(L2(\u00b7, 0)) = 0, \u03d1(\u03932(\u00b7, 1)) = 1, \u03d1(12) = \u2217. (28)\nTurning to the induction step, assume that q = n + 1 \u2265 3 and let g = (g(x))x\u2208[q\u3009 be the truth table of some function g \u2208 Fq not in Eq \u222a {1q}. Without loss of generality we can assume that\ng = 11 . . .1\ufe38 \ufe37\ufe37 \ufe38 t+1 00 . . .0,\nnamely, g(x) = Lq(x, t), where t 6= 0, q\u22121. The case t = q\u22122 is covered by Lemma 24, so we assume hereafter that t \u2264 q\u22123 (i.e., g(q \u2212 2) = g(q \u2212 1) = 0).\nConsider the function g\u2032 \u2208 Fq\u22121 which is the restriction of g to the domain [q \u2212 1\u3009. Then g\u2032 6\u2208 Eq\u22121 \u222a {1q\u22121} by our\n13\nassumptions and, so, by the induction hypothesis, there exist u\u2032 : [q \u2212 1\u3009 \u2192 Bn\u22121\u2217 and \u03d1\u2032 : Fq\u22121 \u2192 Bn\u22121\u2217 such that T(u\u2032(x),\u03d1\u2032(f \u2032)) = f \u2032(x) (29)\nfor every f \u2032 \u2208 Fq\u22121 \\ {g\u2032} and x \u2208 [q \u2212 1\u3009. Define the mapping u : [q\u3009 \u2192 Bn\u2217 by\nu(q \u2212 1) = \u2217\u2217 . . . \u2217\u22171 (30) and, for x \u2208 [q \u2212 1\u3009:\nu(x) = { u\u2032(x) 0 if g(x) = 0 u\u2032(x) \u2217 if g(x) = 1 . (31)\nLet g : [q\u3009 \u2192 B be the function which is identical to g except that g(q \u2212 1) = 1. We define the mapping \u03d1 : Fq \\ {g} \u2192 Bn\u2217 by \u03d1(g) = \u2217\u2217 . . . \u2217\u22171 (32) while for f \u2208 Fq \\ {g, g}:\n\u03d1(f) = { \u03d1\u2032(f \u2032) 0 if f(q \u2212 1) = 0 \u03d1\u2032(f \u2032) \u2217 if f(q \u2212 1) = 1 , (33)\nwhere f \u2032 is the restriction of f to the domain [q \u2212 1\u3009. We now verify that Eq. (2) holds for every x \u2208 [q\u3009 and f \u2208 Fq \\ {g}. For x = q \u2212 1 and f = g we have\nT(u(q \u2212 1),\u03d1(g)) (30)+(32)= 1 = g(q \u2212 1), while for x = q \u2212 1 and f 6= g,\nT(u(q \u2212 1),\u03d1(f)) (30)= T(1, \u03d1n\u22121(f)) (33)= f(q \u2212 1). Assuming now that x \u2208 [q \u2212 1\u3009, for f = g,\nT(u(x),\u03d1(g)) (32) = T(un\u22121(x), 1) (31) = g(x) = g(x),\nwhile for f 6= g,\nT(u(x),\u03d1(f)) (31)+(33) = T(u\u2032(x),\u03d1\u2032(f \u2032)) (29) = f \u2032(x) = f(x).\nProof of Proposition 21 (sufficiency). The proof is very simi-\nlar to that of Proposition 21, except that in the induction base we need to take into account that g may also be L2(\u00b7, 0) (or \u03932(\u00b7, 1)); this case is covered by Remark 2. Respectively, in the induction step, g can also be Lq(\u00b7, 0).\nExample 1. When g = 0q , running the recursive definitions (30)\u2013(33) with the initial conditions (27)\u2013(28) yields, for every j \u2208 [q \u2212 1\u3009, x \u2208 [q\u3009, and f \u2208 Fq \\ {0q}:\nuj(x) =    0 if x \u2264 j 1 if x = j + 1 \u2217 if x > j + 1\nand\n\u03d1j(f) =    0 if f(j+1) = 0 and f(x) = 1 for some x \u2264 j 1 if f(j+1) = 1 and f(x) = 0 for all x \u2264 j \u2217 otherwise .\nIn words, \u03d1(f) is obtained from the truth table of f by changing all the 0\u2019s that precede the first 1 and all the 1\u2019s that succeed it into \u2217\u2019s, and then deleting the first entry\n(which corresponds to x = 0). Table IX shows the mappings x 7\u2192 u(x) and f 7\u2192 \u03d1(f) for q = 4.\nWhen g 6= 0q we can assume that g(x) = Lq(x, t) for some t \u2208 [1 : q \u2212 1\u3009 (or t \u2208 [q \u2212 1\u3009 for Scenario (\u2022\u2217)). We run the recursive definitions (30)\u2013(33) yet now with the initial\nconditions (22)\u2013(25) when stated for q = n + 1 = t + 2. Table X shows the resulting mapping x 7\u2192 u(x) for q = 8 and t = 3. The entries uj(x) that correspond to (x, j) \u2208 [t+ 2\u3009 \u00d7 [t+ 1\u3009 are determined by the initial conditions and are the same as in Table VII, while the entries that correspond to (x+ t+ 1, j + t+ 1) for (x, j) \u2208 [q \u2212 t\u2212 1\u3009 \u00d7 [q \u2212 t\u2212 2\u3009 are the same as in Table IX.\nProof of Proposition 22. Suppose that F\u22c6q is n-cell implementable with mappings u : [q\u3009 \u2192 Bn\u2217 and \u03d1 : F\u22c6q \u2192 Bn\u2217 . Since q \u2265 3, for any two distinct elements x, x\u2032 \u2208 [q\u3009 there exists a function f \u2208 F\u22c6q such that f(x) = 1 yet f(x\u2032) = 0. Hence, the mapping u has to be injective and its set of images must form an antichain in Bn\u2217 (see Section II). For any element t \u2208 [q\u3009 let t\u2032 be a particular element in [q\u3009 \\ {t} (say, t\u2032 = 1 when t = 0, and t\u2032 = 0 otherwise). By the antichain property it follows that there is at least one index \u2113 = \u2113(t) \u2208 [n\u3009 such that u\u2113(t) u\u2113(t\u2032) and, in particular, u\u2113(t) 6= u\u2113(t\u2032), u\u2113(t) 6= \u2022, and u\u2113(t\u2032) 6= \u2217. We define b(t) \u2208 B by\nb(t) =   \nu\u2113(t) if u\u2113(t) \u2208 B 1 if u\u2113(t) = \u2217 and u\u2113(t\u2032) \u2208 {0, \u2022} 0 if u\u2113(t) = \u2217 and u\u2113(t\u2032) = 1 .\nNotice that T(u\u2113(t), b(t)) = 1 yet T(u\u2113(t \u2032), b(t)) = 0. We also define ft : [q\u3009 \u2192 B to be the function in F\u22c6q which evaluates to 1 when x \u2208 {t, t\u2032} and to 0 otherwise.\nWe now extend the mapping \u03d1 to the domain Fq by \u03d1(1q) = \u2217\u2217 . . . \u2217\n14\nand, for every t \u2208 [q\u3009 and j \u2208 [n\u3009,\n\u03d1j(Eq(\u00b7, t)) = {\n\u03d1j(ft) if j 6= \u2113(t) b(t) if j = \u2113(t) .\nIt can be readily verified that Eq. (2) holds for the added functions 1q and Eq(\u00b7, t), t \u2208 [q\u3009, and, therefore, for the whole set Fq . Hence, Fq is n-cell implementable."
        },
        {
            "heading": "ACKNOWLEDGMENT",
            "text": "I would like to express my thanks to Giacomo Pedretti\nfrom Hewlett Packard Labs. This work resulted from many\nstimulating discussions that I had with him during my visit at\nLabs. Thanks are also due to Luca Buoanno and Cat Graves."
        }
    ],
    "title": "On the Implementation of Boolean Functions on Content-Addressable Memories",
    "year": 2023
}