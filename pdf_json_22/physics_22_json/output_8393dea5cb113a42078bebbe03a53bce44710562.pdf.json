{
    "abstractText": "We study the question of when investing additional quantum resources in preparing a ground state will improve the aggregate runtime associated with estimating its energy. We analyze Lin and Tong\u2019s near-optimal state preparation algorithm and show that it can reduce a proxy for the runtime, the T -gate count, of ground state energy estimation near quadratically. Resource estimates are provided that specify the conditions under which the added cost of state preparation is worthwhile.",
    "authors": [
        {
            "affiliations": [],
            "name": "S. Pathak"
        },
        {
            "affiliations": [],
            "name": "A.E. Russo"
        },
        {
            "affiliations": [],
            "name": "S.K. Seritan"
        }
    ],
    "id": "SP:ff57ad0fd743ec906e8eb5f3d8ac6b2f138c9351",
    "references": [],
    "sections": [
        {
            "text": "Quantifying T -gate-count improvements for ground-state-energy estimation with near-optimal state preparation\nS. Pathak,1 A.E. Russo,1 S.K. Seritan,2 and A.D. Baczewski1\n1Quantum Algorithms and Applications Collaboratory, Sandia National Laboratories, Albuquerque NM, USA 2Quantum Algorithms and Applications Collaboratory, Sandia National Laboratories, Livermore CA, USA\nWe study the question of when investing additional quantum resources in preparing a ground state will improve the aggregate runtime associated with estimating its energy. We analyze Lin and Tong\u2019s near-optimal state preparation algorithm and show that it can reduce a proxy for the runtime, the T -gate count, of ground state energy estimation near quadratically. Resource estimates are provided that specify the conditions under which the added cost of state preparation is worthwhile.\nIntroduction.\u2014 A key task in all quantum simulation algorithms is the preparation of a state that encodes the observables of a physical system of interest [1\u20133]. This is often the ground state |\u03a80\u3009 of a Hamiltonian H on an n-qubit Hilbert space [4\u20138]. Independent of whether this represents interacting electrons [9\u201314], spins [15\u2013 17], or quantum fields [18\u201320], we generally produce an approximation to the desired state |\u03a60\u3009 with overlap \u03b3 = |\u3008\u03a60|\u03a80\u3009|. Then the probability of successfully processing |\u03a60\u3009 to estimate some observable of interest (e.g., the ground state energy E0) is generally upper bounded by \u03b32 [21], which would ideally be 1.\nWhile it is likely not possible to efficiently prepare ground states of generic local Hamiltonians on quantum computers [22, 23] physical arguments suggest that the specific instances for which nature can efficiently find the ground state will be efficiently preparable on a quantum computer [24]. Though the question of which instances these are remains an active area of research [25], it is generally of interest to develop algorithms that increase \u03b3i from some easy-to-prepare initial approximation, |\u03a60,i\u3009, to \u03b3f with some associated final approximation |\u03a60,f \u3009. It might be that |\u03a60,i\u3009 comes from the outcome of a classical calculation (e.g., an approximate solution to a mean-field theory) or a hybrid quantum-classical approach like the variational quantum eigensolver [26, 27]. Regardless of the source of |\u03a60,i\u3009, it is often assumed that the cost of preparing it is negligible relative to the cost of boosting \u03b3i \u2192 \u03b3f , making use of some unitary USP (H) |\u03a60,i\u3009 = |\u03a60,f \u3009 [28].\nThe question that we answer in this Letter is \u201cwhen does the added cost of implementing USP (H) outweigh the cost of repeated trials with a lower probability of success?\u201d We are specifically concerned with the potential benefit to estimating E0, for which conventional approaches that apply quantum phase estimation (QPE) [29] to |\u03a60,i\u3009 will project onto |\u03a80\u3009 after a single round with probability \u03b32i [21] (see Fig. 1(a)). One can use more elaborate strategies in which repeated rounds of QPE can iteratively improve our knowledge of E0 [2, 30\u2013 35], though we assume a simple strategy of repeating the\ncircuit O(\u03b3\u22122i ) times for ease of analysis [36]. Broadly speaking there are two classes of state preparation algorithms, those that make use of the adiabatic theorem [37] and those that apply a filter in the eigenbasis of H [4]. In this Letter, we consider a USP (H) in the latter category, derived from a near-optimal approach of Lin and Tong [7]. While adiabatic state preparation is conceptually straightforward, it generally requires time-dependent Hamiltonian simulation, the analysis of a family of Hamiltonians along the entire adiabatic pathway, and potentially many different initial Hamiltonians, rather than a single instance. It also has worse scaling with the minimum spectral gap [38]. However, there are some important exceptions [39] and it may be the case that adiabatic algorithms are found to be the optimal solution in some cases, so we make no claim to the optimality of our results. An added benefit of analyzing filter-based state preparation is that it relies on a block encoding [40] of H that could be identical to one used in QPE, making it straightforward to compare costs.\nWhether exponential, polynomial, or nonexistent, the advantages realized by quantum computers in physical simulation are likely to be problem-specific and depend critically on the cost of implementing USP (H) [41]. We provide estimates for the cost of state preparation based on the T -gate count of implementations of Lin and Tong\u2019s USP (H) [7]. We choose the total number of T gates as a simple-to-compute proxy for an actual runtime estimate because their implementation will dominate the runtime in T-factory-limited surface code architectures [42, 43] and a more precise analysis would involve detailed scheduling of the algorithm\u2019s implementation. Actual runtimes could also be reduced relative to this proxy in contexts in which the availability of magic states is not a limiting factor, in which case the T depth would be the more appropriate quantifier.\nWe propose a ratio \u03b9 that compares the T -gate count for USP (H) and subsequent QPE to the count for \u201ctrivial\u201d state prep and QPE repeated until success. This quantifies the improvement in runtime associated with \u201cbetter\u201d state preparation and allows us to answer the\nar X\niv :2\n21 0.\n10 87\n2v 3\n[ qu\nan t-\nph ]\n1 7\nA pr\n2 02\n3\ntitular question. Even in a scenario where \u03b3i vanishes exponentially with increasing n, there are parameter regimes where there is a robust near-quadratic speedup for better state preparation. This is consistent with the Grover-like speedup [45] that one would expect [46], though we note that we are exploring this in terms of T -gate counts as a proxy for runtime, instead of query complexity or some other more abstract quantifier.\nMethods.\u2014 Circuit diagrams that illustrate the implementation costs being studied are provided in Fig. 1. The quantum computer that runs these circuits consists of four registers: (sys) the n-qubit system register that encodes |\u03a60,i\u3009, (qpe) the auxiliary register that encodes p bits of an estimate for E0, (aa) which implement amplitude amplification (AA), and (be) which block encode H. In what follows, we describe the structure of the circuits in Fig. 1 and any attendant assumptions. Many details that were originally elaborated elsewhere in the literature are summarized in the Supplemental Materials (SM) [47].\nFor QPE, we use the highly optimized implementation of Babbush et al. [10]. We indicate the T count associated with estimating E0 with Holevo variance \u2206E as TQPE(\u2206E) and note that more relevant details can be found in the SM [47]. We assume a particularly simple approach to estimating E0. Each repetition of the circuit will sample an eigenvalue from the spectrum of H with probability proportional to the overlap of the input state\nstate with the associated eigenstate. So afterO(\u03b3\u22122) repetitions the smallest observed eigenvalue will likely be E0. We now derive conditions under which boosting \u03b32 with AA will reduce the expected total runtime for estimating E0 relative to only relying on U\u03a60,i , the cost of which we will denote T\u03a60,i (see Fig. 1(b)).\nAA consists of Niter applications of a product of two reflections (R\u03a60,i , R\u03a80) that boosts the overlap of the state in sys to \u03b3f . Niter is determined by \u03b3i,\nNiter =\n\u2308 1\n2 ( sin\u22121 \u03b3f sin\u22121 \u03b3i \u2212 1 )\u2309 . (1)\nWhile implementing R\u03a60,i only requires controlled applications of U\u03a60,i , the implementation of R\u03a80 is complicated by |\u03a80\u3009 generally being unknown. We will follow Ref. [7] and construct an -approximation to this reflector using quantum signal processing (QSP) [48], R\u03a80( ) (see Fig. 1(c)). This is a degree-N\u03c6 polynomial in (H \u2212 \u00b5I) that approximates a function that is ideally \u22121 for states with energy less than \u00b5\u2212\u2206/2 and ideally 1 for states with energy greater than \u00b5 + \u2206/2. Details pertaining to the calculation of \u00b5 and \u2206 are included in the SM [47].\nHowever, in practice each eigenvalue of R\u03a80( ) is only -close to {\u22121,+1} and R\u03a80( ) is not an exact reflector. One of the technical advances in this Letter is a bound on\n3 such that the QSP circuit produces |\u03a60,f \u3009 with \u03b3f \u2265 \u03b3i,\n\u2264 ( 1\u2212 \u03b32f ) /6N2iter. (2)\nA proof can be found in the SM [47]. The cost of implementing the entire AA circuit is denoted TAA(\u03b3i, \u03b3f ).\nThe only remaining details for the implementation under consideration pertain to the block encoding of H [40]. Block encoding is used both to encode the eigenspectrum of H, as sampled in QPE, and to implement a polynomial in (H \u2212 \u00b5I) in QSP. As many of the details are model-specific and extensively developed in other work, we relegate a detailed discussion of block encoding to the SM [47]. While there are alternatives to block encoding, we leave it to future work to consider variants on the approach in Fig. 1 making use of, e.g., Trotterized Hamiltonian evolution, either for encoding the eigenspectrum of H for QPE or for implementing time-dependent Hamiltonian evolution in adiabatic state preparation [49].\nWith all of the components of our implementation specified, we can prepare T counts for the circuits with and without AA. The ratio of these counts defines the improvement,\n\u03b9 = \u03b3\u22122i (T\u03a60,i + TQPE(\u2206E))\n\u03b3\u22122f (T\u03a60,i + TQPE(\u2206E) + TAA(\u03b3i, \u03b3f )) . (3)\nHere the cost of AA is\nTAA = Niter ( TR\u03a60,i +N\u03c6(TUH + Tei\u03c6\u03a0) ) . (4)\nTR\u03a60,i involves two applications of U\u03a60,i and a single multi-controlled X gate. TUH is the cost of a single application of the block-encoded Hamiltonian. Tei\u03c6\u03a0 involves two multi-controlled X gates and a single-qubit rotation with angles determined using the protocol in Ref. [44]. N\u03c6 is the number of phases used to implement R\u03a80( ) and all parameter values will be chosen to saturate their bounds. We note that Eq. 4 depends on the rotation synthesis error incurred in implementing the Hamiltonian block encoding and the controlled rotations in QSP, and the error analysis used in deriving our results is considered in the SM [47]. We consider better state preparation as being worthwhile when \u03b9 > 1.\nResults.\u2014 We first consider resource estimates for the 1D transverse field Ising model (TFIM) [50] with periodic boundary conditions [51]. sys is encoded such that each of the n qubits represents one of the L sites. We consider a simple form for U\u03a60,i in which Ry rotations are applied to each qubit to generate a product state. We tune the rotation angles to construct a |\u03a60,i\u3009 with a target value of \u03b3i. While not a particularly sophisticated choice for initializing sys, it suffices for our purposes. We select to saturate the bound in Eq. 2 with a target \u03b32f = 0.75, and assume that the true final overlap is also \u03b32f = 0.75; a presentation of the difference between the target and true overlaps can be found in Fig. 3.\n10\u22125 10\u22124 10\u22123 10\u22122 10\u22121\n\u03b32i\n10\u22121\n100\n101\n102\n103\n\u03b9\n\u2206E = 10\u22122\n\u2206E = 10\u22121\nL = 4\nL = 16\nL = 64\n10\u2212110\u2212310\u22125\n\u03b32i\n106\n109\n1012\nT A A\n(\u03b3 i ,\u03b3 f )\n4 10010\u2212210\u2212410\u22126\nTarget 1\u2212 \u03b32f\n100\n10\u22122\n10\u22124\n10\u22126\nS im\nu la\nte d\n1 \u2212 \u03b3\n2 f L = 2 L = 4 L = 6\nFIG. 3. Comparison of the target \u03b3f and simulated \u03b3f for the transverse field Ising model with L = 2, 4, and 6 sites. For each value of L, state-vector simulations of the full Usp(H) circuit were carried out for three target values, 1 \u2212 \u03b32f = 10\u22121, 10\u22122, 10\u22123, and three values of \u03b3i satisfying Niter = 4, 6, 10. The black line is the x = y reference and our results are consistent with the validity of the bound in Eq. 2.\nWe find that the simulated infidelity, 1 \u2212 \u03b32f , is consistently one or two orders of smaller than the target, indicating that our bound for in Eq. 2 could be adjusted to potentially realize further savings in implementing this approach to state preparation. However, the impact of on \u03b9 is only logarithmic, so removing this looseness will only affect our results by a small constant factor. As such, we are confident that our conclusions are not skewed by a loose bound in the state preparation T counts.\nNext, we consider resource estimates for a more realistic and technologically important Hamiltonian. The solid electrolyte \u03b2-alumina is known for its high ionic conductivity [53, 54] and there is broad general interest in using it for low-carbon energy storage [55]. Of particular interest for these applications is the accurate calculation of equilibrium voltage, ionic mobility, and thermal stability, which are all directly related to accurate ground state energies of the battery as outlined by Delgado et al. in their work on the lithium-ion battery Li2FeSiO4 [56].\nClassical computation of accurate ground state energies of the \u03b2-aluminas is challenged by the nonstoichiometric chemical composition, Na1+xAl11O17+x/2, which requires large supercells to resolve finite-size effects. This is a larger supercell than has been considered in other resource estimates of materials. We choose this particular example because it is large enough that mean-\n10\u22125 10\u22124 10\u22123 10\u22122 10\u22121\n\u03b32i\n10\u22121\n100\n101\n102\n103\n104\n\u03b9\n\u2206E = 13 meV\n\u2206E = 130 meV\nN = 103 N = 105 N = 107\n10\u22125 10\u22123 10\u22121\n\u03b32i\n1014\n1017\n1020\nT A A\n(\u03b3 i ,\u03b3 f )\n5 ing near-optimal state preparation [7]. The ratio of the T count for successful ground state energy estimation, without and with this state preparation, define an improvement factor that is related to likely runtime reductions. This improvement is near-quadratic in \u03b3i and demonstrated credible multiple-order-of-magnitude speedups for a toy problem and a highly realistic electronic structure problem.\nFuture work will involve determining more realistic estimates for scenarios under which these types of speedups will be realized. In particular, categorizing the values of \u03b3i typical of classical heuristics that are efficiently implementable as U\u03a60,i is an open research area. It also remains unclear whether efficient implementations of adiabatic state preparation or other variants on filterbased state preparation are more or less efficient than the one examined in this Letter. Finally, whether quantum phase estimation protocols with built-in tolerance to state preparation errors [33, 58] can be exploited to achieve better improvements is a topic for future work.\nNote added.\u2014 Between uploading the first and second versions of this Letter to the arXiv, we became aware of another manuscript considering similar aspects of ground state preparation [59].\nWe gratefully acknowledge useful conversations with Ryan Babbush, Anand Ganti, Lucas Kocia, Alina Kononov, Michael Kreshchuk, Andrew Landahl, Lin Lin, Alicia Magann, Jonathan Moussa, Setso Metodi, Mason Rhodes, and Norm Tubman. All authors were supported by the National Nuclear Security Administration\u2019s Advanced Simulation and Computing Program. AER was partially supported by the U.S. Department of Energy, Office of Science, Office of Advanced Scientific Computing Research, Quantum Computing Application Teams program. ADB was partially supported by the U.S. Department of Energy, Office of Science, National Quantum Information Science Research Centers program and Sandia National Laboratories\u2019 Laboratory Directed Research and Development program (Project 222396).\nThis article has been co-authored by employees of National Technology & Engineering Solutions of Sandia, LLC under Contract No. DE-NA0003525 with the U.S. Department of Energy (DOE). The authors own all right, title and interest in and to the article and are solely responsible for its contents. The United States Government retains and the publisher, by accepting the article for publication, acknowledges that the United States Government retains a non-exclusive, paid-up, irrevocable, world-wide license to publish or reproduce the published form of this article or allow others to do so, for United States Government purposes. The DOE will provide public access to these results of federally sponsored research in accordance with the DOE Public Access Plan https://www.energy.gov/downloads/ doe-public-access-plan.\n[1] S. Lloyd, Science 273, 1073 (1996). [2] A. Aspuru-Guzik, A. D. Dutoi, P. J. Love, and M. Head-\nGordon, Science 309, 1704 (2005). [3] S. P. Jordan, K. S. Lee, and J. Preskill, Science 336,\n1130 (2012). [4] D. Poulin and P. Wocjan, Physical review letters 102,\n130503 (2009). [5] N. M. Tubman, C. Mejuto-Zaera, J. M. Epstein, D. Hait,\nD. S. Levine, W. Huggins, Z. Jiang, J. R. McClean, R. Babbush, M. Head-Gordon, et al., arXiv preprint arXiv:1809.05523 (2018). [6] Y. Ge, J. Tura, and J. I. Cirac, Journal of Mathematical Physics 60, 022202 (2019). [7] L. Lin and Y. Tong, Quantum 4, 372 (2020). [8] J. Lemieux, G. Duclos-Cianci, D. Se\u0301ne\u0301chal, and\nD. Poulin, Physical Review A 103, 052408 (2021). [9] M. Reiher, N. Wiebe, K. M. Svore, D. Wecker, and\nM. Troyer, Proceedings of the national academy of sciences 114, 7555 (2017). [10] R. Babbush, C. Gidney, D. W. Berry, N. Wiebe, J. McClean, A. Paler, A. Fowler, and H. Neven, Physical Review X 8, 041015 (2018). [11] J. Lee, D. W. Berry, C. Gidney, W. J. Huggins, J. R. McClean, N. Wiebe, and R. Babbush, PRX Quantum 2, 030305 (2021). [12] Y. Su, D. W. Berry, N. Wiebe, N. Rubin, and R. Babbush, PRX Quantum 2, 040332 (2021). [13] Y. Su, H.-Y. Huang, and E. T. Campbell, Quantum 5, 495 (2021). [14] V. von Burg, G. H. Low, T. Ha\u0308ner, D. S. Steiger, M. Reiher, M. Roetteler, and M. Troyer, Physical Review Research 3, 033055 (2021). [15] A. M. Childs, D. Maslov, Y. Nam, N. J. Ross, and Y. Su, Proceedings of the National Academy of Sciences 115, 9456 (2018). [16] A. M. Childs and Y. Su, Physical review letters 123, 050503 (2019). [17] M. C. Tran, Y. Su, D. Carney, and J. M. Taylor, PRX Quantum 2, 010323 (2021). [18] N. Klco and M. J. Savage, Physical Review A 99, 052335 (2019). [19] H. Lamm, S. Lawrence, Y. Yamauchi, N. Collaboration, et al., Physical Review D 100, 034518 (2019). [20] A. F. Shaw, P. Lougovski, J. R. Stryker, and N. Wiebe, Quantum 4, 306 (2020). [21] M. A. Nielsen and I. Chuang, \u201cQuantum computation and quantum information,\u201d (2002). [22] A. Y. Kitaev, A. Shen, and M. N. Vyalyi, Classical and quantum computation, 47 (American Mathematical Soc., 2002). [23] J. Kempe, A. Kitaev, and O. Regev, SIAM journal on computing 35, 1070 (2006). [24] R. P. Feynman, International Journal of Theoretical Physics 21, 467 (1982). [25] B. O\u2019Gorman, S. Irani, J. Whitfield, and B. Fefferman, PRX Quantum 3, 020322 (2022). [26] A. Peruzzo, J. McClean, P. Shadbolt, M.-H. Yung, X.-Q. Zhou, P. J. Love, A. Aspuru-Guzik, and J. L. O\u2019brien, Nature communications 5, 1 (2014). [27] P. J. O\u2019Malley, R. Babbush, I. D. Kivlichan, J. Romero, J. R. McClean, R. Barends, J. Kelly, P. Roushan,\n6 A. Tranter, N. Ding, et al., Physical Review X 6, 031007 (2016).\n[28] This cost isn\u2019t always negligible. As has been noted in Ref. [56], sometimes even the cost of preparing simple input states can dominate simulation costs unless certain simplifying assumptions are made. [29] A. Y. Kitaev, arXiv preprint quant-ph/9511026 (1995), 10.48550/arXiv.quant-ph/9511026. [30] S. Kimmel, G. H. Low, and T. J. Yoder, Physical Review A 92, 062315 (2015). [31] N. Wiebe and C. Granade, Physical review letters 117, 010503 (2016). [32] T. E. O\u2019Brien, S. Polla, N. C. Rubin, W. J. Huggins, S. McArdle, S. Boixo, J. R. McClean, and R. Babbush, PRX Quantum 2, 020317 (2021). [33] A. E. Russo, K. M. Rudinger, B. C. Morrison, and A. D. Baczewski, Physical Review Letters 126, 210501 (2021). [34] L. Lin and Y. Tong, PRX Quantum 3, 010318 (2022). [35] G. Wang, D. Stilck-Franc\u0327a, R. Zhang, S. Zhu, and\nP. D. Johnson, arXiv preprint arXiv:2209.06811 (2022), https://doi.org/10.48550/arXiv.2209.06811. [36] We expect that further improvements can be made by adopting the aforementioned \u201cmore elaborate strategies\u201d but these are likely to be constant-factor improvements rather than asymptotic ones. [37] E. Farhi, J. Goldstone, S. Gutmann, and M. Sipser, arXiv preprint quant-ph/0001106 (2000), 10.48550/arXiv.quant-ph/0001106. [38] T. Albash and D. A. Lidar, Reviews of Modern Physics 90, 015002 (2018). [39] K. Wan and I. Kim, arXiv preprint arXiv:2004.04164 (2020), 10.48550/arXiv.2004.04164. [40] A. Gilye\u0301n, Y. Su, G. H. Low, and N. Wiebe, in Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing (2019) pp. 193\u2013204. [41] S. Lee, J. Lee, H. Zhai, Y. Tong, A. M. Dalzell, A. Kumar, P. Helms, J. Gray, Z.-H. Cui, W. Liu, et al., arXiv preprint arXiv:2208.02199 (2022). [42] A. G. Fowler, M. Mariantoni, J. M. Martinis, and A. N. Cleland, Physical Review A 86, 032324 (2012). [43] D. Litinski, Quantum 3, 205 (2019). [44] Y. Dong, X. Meng, K. B. Whaley, and L. Lin, Physical\nReview A 103, 042419 (2021). [45] L. K. Grover, in Proceedings of the twenty-eighth an-\nnual ACM symposium on Theory of computing (1996) pp. 212\u2013219. [46] G. Brassard, P. Hoyer, M. Mosca, and A. Tapp, Contemporary Mathematics 305, 53 (2002). [47] See Supplemental Materials for more details. [48] G. H. Low and I. L. Chuang, Physical review letters 118,\n010501 (2017). [49] L. Kocia, F. A. Calderon-Vargas, M. D. Grace,\nA. B. Magann, J. B. Larsen, A. D. Baczewski, and M. Sarovar, arXiv preprint arXiv:2209.06242 (2022), 10.48550/arXiv.2209.06242. [50] R. B. Stinchcombe, Journal of Physics C: Solid State Physics 6, 2459 (1973). [51] Open boundary conditions will have very similar costs. [52] S. Sivarajah, S. Dilkes, A. Cowtan, W. Simmons, A. Edg-\nington, and R. Duncan, Quantum Sci. Technol. 6, 014003 (2020). [53] Y.-F. Y. Yao and J. T. Kummer, Journal of Inorganic and Nuclear Chemistry 29, 2453 (1967). [54] R. Stevens and J. G. P. Binner, Journal of Materials Sci-\nence 19, 695 (1984). [55] R. Collongues, D. Gourier, A. Kahn, J. Boilot, P. Colom-\nban, and A. Wicker, Journal of Physics and Chemistry of Solids 45, 981 (1984). [56] A. Delgado, P. A. M. Casares, R. d. Reis, M. S. Zini, R. Campos, N. Cruz-Herna\u0301ndez, A.-C. Voigt, A. Lowe, S. Jahangiri, M. A. Martin-Delgado, J. E. Mueller, and J. M. Arrazola, arXiv (2022), 10.48550/arXiv.2204.11890, 2204.11890. [57] R. Babbush, D. W. Berry, J. R. McClean, and H. Neven, npj Quantum Information 5, 1 (2019). [58] Z. Ding and L. Lin, arXiv preprint arXiv:2211.11973 (2022), 10.48550/arXiv.2211.11973. [59] K. Gratsea, C. Sun, and P. D. Johnson, arXiv preprint arXiv:2212.09492 (2022), 10.48550/arXiv.2212.09492. [60] L. Lin and Y. Tong, Quantum 4, 361 (2020), 1910.14596v4. [61] A. M. Childs and N. Wiebe, Quantum Information and Computation 12, 0901 (2012), 1202.5822. [62] P. Selinger, Quantum Info. Comput. 15, 159\u2013180 (2015). [63] P. Niemann, R. Wille, and R. Drechsler, Quantum In-\nformation Processing 19, 317 (2020). [64] D. W. Berry, M. Kieferova\u0301, A. Scherer, Y. R. Sanders,\nG. H. Low, N. Wiebe, C. Gidney, and R. Babbush, npj Quantum Information 4, 1 (2018). [65] Actually, the filtering step succeeds with probability > 1/2, so on average the step needs to be performed twice. [66] P. A. M. Casares, R. Campos, and M. A. MartinDelgado, Quantum 6, 768 (2022).\n1 Supplemental Materials: Quantifying T -gate-count improvements for ground-state-energy estimation with near-optimal state preparation\nThe Supplemental Materials elaborate on details of some of the central results in the main body of the paper.\n\u2022 Appendix A states and proves Theorem 1, which quantifies the impact of using an approximation to a reflector rather than an exact reflector in implementing amplitude amplification.\n\u2022 Appendix B analyzes the impact of rotation synthesis errors.\n\u2022 Appendix C describes the computation of \u00b5 and \u2206, including some details of the overhead associated with the implementation of Lin and Tong\u2019s binary search algorithm.\n\u2022 Appendix D explores different choices for defining \u03b9.\n\u2022 Appendix E summarizes components of prior results from the literature that are essential to the synthesis in this paper.\nAPPENDIX A: THEORETICAL ANALYSIS FOR BOUNDS ON\nHere we extend the error analysis of the filter-based ground state preparation technique developed by Lin and Tong [7]. In their work, they suggest state preparation using amplitude amplification, wherein a guess state \u03a60,i with overlap \u03b3i to the true ground state \u03a80 of a system is boosted to a final state \u03a60,f with overlap \u03b3f > \u03b3i. The problematic reflector required for this operation, a reflector around the true ground state R\u03a80 , is implemented approximately in their work using quantum signal processing via an -accurate block-encoded operator R\u03a80( ). In order to develop resources estimates for implementing Lin and Tong\u2019s algorithm, it is necessary to find a relationship between the approximation parameter and the quantities that define the amplitude amplification, namely \u03b3i, \u03b3f . In this Appendix we compute a bound for such that state preparation using amplitude amplification with the approximate reflector R\u03a80( ) is guaranteed to achieve a final overlap \u03b3f starting from a guess state with overlap \u03b3i.\nProblem statement and theorem\nGiven an initial state \u03a60,i with overlap \u03b3i with the exact ground state \u03a80 of the Hamiltonian H, we would like to construct a state \u03a60,f which has an overlap \u03b3f > \u03b3i. Our approach is to use quantum amplitude amplification, initially posited by Lin and Tong [7], wherein we boost the overlap by applying a sequence of two reflections:\n|\u03a60,f \u3009 = (R\u03a60,iR\u03a80)Niter |\u03a60,i\u3009. (A1)\nHere R\u03a60,i is a reflector around \u03a60,i, R\u03a80 a reflector around \u03a80 using quantum signal processing, and Niter the number of iterations which leads to the highest overlap defined in Eq 1.\nIn practice one must approximate R\u03a80 as the exact ground state \u03a80 is the target one does not know, and wishes to construct. As demonstrated by Lin and Tong [7, 60], R\u03a80 can be approximately computed through a polynomial transformation of the Hamiltonian, constructed via quantum signal processing (QSP). In their work, they first prove that there exists an approximation to the reflector as a polynomial function of H: S(H\u2212\u00b5I\u03b1+|\u00b5| , , \u03b4), which is -close in operator norm to R\u03a80 under the conditions E0 < \u00b5 < E1 and \u03b4 \u2264 mink |Ek \u2212 \u00b5|/4\u03b1 where Ek are the eigenvalues of H and \u03b1 \u2265 ||H||.\nThe matrix function S, however, is not unitary and cannot be directly applied as a quantum circuit. Instead, Lin and Tong describe a method to block-encode S so that the fully block-ended unitary can then be implemented on a quantum computer. They show that given an (\u03b1+ |\u00b5|, m, 0) block encoding of H\u2212\u00b5I, one can construct a (1, m+ 1, 0) block-encoding of S and thereby a (1, m + 1, ) block-encoding of R\u03a80 . We will refer to the (1, m + 1, ) block encoding of R\u03a80 hereafter as R\u03a80( ), noting that the latter acts on both the state register storing \u03a60,i as we all as the auxiliary m+ 1 qubits required for block encoding..\nThe only leftover piece to complete the state preparation analysis suggested by Lin and Tong is determining what values of should be chosen to ensure that using R\u03a80( ) within AA will yield a final overlap \u03b3f starting with overlap \u03b3i. In the next few sections we will show that a bound on can be analytically determined that satisfies the above conditions. Below is a summary of our results:\n2 Theorem 1 Consider a Hamiltonian H with exact ground state \u03a80 and an initial guess state \u03a60,i with overlap \u03b3i. The quantum amplitude amplification procedure |\u03a60,f \u3009 = (R\u03a60,iR\u03a80( ))Niter |\u03a60,i\u3009 described by initially by Lin and Tong [7, 60] is guaranteed to return a state with, at minimum, a desired final overlap \u03b3f if the following conditions are all met:\n1. E0 < \u00b5 < E1, where Ek are eigenvalues of H\n2. \u03b4 \u2264 mink |Ek \u2212 \u00b5|/4\u03b1\n3. \u2264 (1\u2212 \u03b32f )/6N2iter The first two conditions were already introduced in the work by Lin and Tong in their study of ground state preparation with quantum signal processing [7]. The last condition on has been introduced in this work, and what we will work towards proving in the next few sections.\nIt should be noted the form of amplitude amplification in Eq A1 is different from the Brassard approach [46]. We find, rather, that the approach in Eq A1 yields a lower cost by nearly a factor of 2, as the QSP unitary only needs to be queried once per AA iteration, while in the Brassard AA approach the QSP unitary would need to be queried twice per iteration. As the QSP query is the bulk of the cost in AA, this results in a significant reduction in circuit depth.\nStructure of the approximate reflector R\u03a80( )\nIn order to bound we will first study the structure and bounds of sub-matrices of R\u03a80( ). To do so, we will first begin by assuming we are given a Hermitian block encoding of the Hamiltonian, which greatly simplifies all of the following analysis. While this may not seem like a general assumption, Appendix C in Dong et al. [44] provides a technique for constructing a Hermitian block encoding from a non-Hermitian encoding with just a single-qubit overhead.\nWe begin with a few simple observations on the structure of R\u03a80( ).\n1. R\u03a80( ) operates identically and independently on states with support on the QSP |0\u3009 subspace and QSP |1\u3009 subspace. We will work in the |0\u3009 subspace from here on out.\n2. The matrix R\u03a80( ) only contains real values as our polynomial function S(H\u2212\u00b5I\u03b1+|\u00b5| , , \u03b4) is real. The mapping from the complex function that QSP implements to a real one is accomplished by adding a single ancilla qubit as described in Dong et al. [44], Figure 3.\n3. R\u03a80( ) can be made symmetric. To do so, we select symmetric phases as describe in Dong et al. [44]. Alongside the Hermiticity of UH and realness of R\u03a80( ), the symmetric phase factors guarantee that R\u03a80( ) is a symmetric real matrix.\nWith these three observations, we can write down the most general form of R\u03a80( ) within the |0\u3009 QSP subspace as\n|0m\u3009 |0m\u3009 R\u03a80( ) = [ S( ) A AT B ] (A2)\nwhere S( ) is shorthand for the Hamiltonian polynomial S(H\u2212\u00b5I\u03b1+|\u00b5| , , \u03b4), |0m\u3009 refers to the zeroed auxiliary register, |0m\u3009 its orthogonal complement, and two matrices A,B with the latter being symmetric. The matrices A,B have no obvious internal structure, but we can prove bounds on the matrix norms of A,B which will be integral in our analysis of the error propagation from .\nBounds on matrix norms of B,Q\nOur analysis of matrix norms relies on the unitarity of R\u03a80( ). Following the condition that R\u03a80( )\u2020R\u03a80( ) = I, we can derive three linearly independent conditions on matrix norms:\nS2 +A2 = I, SAT +AB = 0, (AT )2 +B2 = I (A3)\n3 We know that S is close in operator norm to the exact reflector R\u03a80 , and more precisely has eigenvalues close to \u00b11[7]. As such, in the eigenbasis S2 = diag({(1\u2212 i)2}) where i < \u2200 i are the errors in each eigenvalue. Considering the first equation in Eq A3, we see that A2 = diag({(2 i \u2212 2i )}). Since i \u2264 , we can therefore bound the left and right as ||A2|| \u2264 2 \u2212 2, which after taking the square root of both sides results in\n||A|| \u2264 \u221a 2 \u2212 2. (A4)\nBounds on ||B|| are not required for our current analysis. The only required information for this submatrix is that the norm is at most unity, in order to maintain unitarity.\nBounds on overlap \u03b3f\nWe can now work out bounds for the overlap after Niter applications of amplitude amplification. Again using the 2-dimensional basis as seen in Eq A2, we can write down the initial state as ( \u03a60,i 0 )T , and the initial state reflector as [ R\u03a60,i 0\n0 \u2212I\n] (A5)\nWe can then write out (R\u03a60,iR\u03a80( ))k|\u03a60,i\u3009 for a few values of k, in this case for k = 0, 1, 2, 3:[ \u03a60,i\n0\n] , [ R\u03a60,iS( )\u03a60,i \u2212AT\u03a60,i ] , [ (R\u03a60,iS( ))2\u03a60,i \u2212R\u03a60,i(AAT )\u03a60,i ATR\u03a60,iS( )\u03a60,i +BAT\u03a60,i ] [ (R\u03a60,iS( ))3\u03a60,i \u2212R\u03a60,iS( )R\u03a60,iAAT\u03a60,i \u2212R\u03a60,iAATR\u03a60,iS( )\u03a60,i +R\u03a60,iABAT\u03a60,i\n\u2212AT (R\u03a60,iS( ))2\u03a60,i +ATR\u03a60,iAAT\u03a60,i +BATR\u03a60,iS( )\u03a60,i \u2212B2AT\u03a60,i ] (A6) To reduce the above expressions to something reasonable, we can see that the vectors as a series can be written as:[\n(R\u03a60,iR\u03a80( ))k|\u03a60,i\u3009 ]T = [ (R\u03a60,iS( ))k\u03a60,i + ak( ) bk( ) ] , (A7)\nwhere ak, bk are some vectors that are functions of as presented in the explicitly computed sequence, and which depend on the iteration k.\nWe can now compute the overlap with the exact ground state using the expression in Eq A7, and then reduce the solution using the bounds we determined in the previous section. First, we look at the exact overlap\n\u03b32f = |\u3008\u03a80|(R\u03a60,iS( ))Niter |\u03a60,i\u3009+ \u3008\u03a80|aNiter ( )\u3009|2 |(R\u03a60,iS( ))Niter\u03a60,i + aNiter ( )|2 + |bNiter ( )|2 . (A8)\nAt this stage the denominator is redundant, as the norm of the vector is always 1 due to unitarity, however we will be replacing ak, bk soon to expression in lowest order to , which will require proper normalization.\nNow we can construct an approximate expression for \u03b3f by computing each dependent term to lowest order in . The first quantity is S( ), which is -close in eigenvalues to the true reflection operator R\u03a80 . The next three quantities are the bounds on ak, bk and ck which are determined by induction by looking at the series in Eq A6: |ak( )| \u2264 (k2 \u2212 k) +O( 2), |bk( )| \u2264 k \u221a 2 +O( ).\nBefore stating our final result, we note that we want to ensure, under any condition, that \u03b3f is achievable. As such, we will write down the worst case expression for \u03b3f which is possible at the lowest order in , allowing us to reduce certain factors like |\u3008\u03a80|(R\u03a60,iS( ))k|\u03a60,i\u3009 to 1 when multiplied by an error source. With that being said, a final expression for \u03b32f , for the worst case in lowest order of , is:\n\u03b32f \u2265 |\u3008\u03a80|(R\u03a60,iR\u03a80)Niter |\u03a60,i\u3009|2(1\u2212 6N2iter ) +O( 3/2) (A9)\nRearranging terms and noting that |\u3008\u03a80|(R\u03a60,iR\u03a80)Niter |\u03a60,i\u3009|2 = 1, we then see that to ensure \u03b3f final overlap we can pick\n\u2264 (1\u2212 \u03b32f )/6N2iter. (A10)\nAs a final remark, the O( 3/2) term in Eq A9 actually increases the bound on , as the next order corrections all emerge as \u221a 2 \u2212 2, effectively reducing the error from bk.\n4 APPENDIX B: IMPACT OF ERRORS IN ROTATION SYNTHESIS\nIn the context of a fault-tolerant implementation of any quantum algorithm, the impact of approximation errors attendant to the synthesis of arbitrary-angle rotations from a finite gate set needs to be quantified. There are two places where these rotation synthesis errors will occur in the algorithm under consideration in this Letter\u2013 (1) the implementation of the Hamiltonian and (2) the implementation of the controlled QSP phase rotations ei\u03c6j\u03a0. Source (1) is an aggregate truncation error associated with potentially numerous choices that are Hamiltonian- and implementation-dependent, which we quantify using a single parameter R,H . Source (2) is a more straightforward truncation error that strictly depends on the precision with respect to which the QSP rotation angles are implemented, which we quantify using a second parameter R,P . Here we describe the impact that these sources of error have on the accuracy and cost of state preparation using QSP at leading order in R,H and R,P . In the following analysis we assume that both of these sources of error are small relative to the QSP errors analyzed in Appendix A.\nRotation synthesis error in H\nFor this analysis we consider an LCU implementation of the Hamiltonian, H = \u2211Ll=0 wlHl/\u03b1, \u03b1 = \u2211Ll=0 wl, and an approximate implementation of H with error R,H , H\u2032 = \u2211L l=0(wl + R,H)Hl/\u03b1\u2032, \u03b1\u2032 = \u2211L l=0(wl + R,H). Here wl are the LCU coefficients and Hl are unitary operators. Next, consider state preparation implemented using an identical set of phases {\u03c6d}, but the truncated Hamiltonian H\u2032, under all conditions specified in Theorem 1. The final state produced by this process, |\u03a6\u20320,f \u3009, can be written as\n|\u03a6\u20320,f \u3009 = \u03b3\u2032f |\u03a8\u20320\u3009+ \u221a 1\u2212 (\u03b3\u2032f )2|\u03a8\u2032ex\u3009, (B1)\nwhere |\u03a8\u20320\u3009 is the ground state of H\u2032 and |\u03a8\u2032ex\u3009 = |\u03a60,i\u3009 \u2212 \u3008\u03a60,i|\u03a8\u20320\u3009|\u03a8\u20320\u3009 is the projection of the initial state |\u03a60,i\u3009 onto the orthogonal complement of the subspace spanned by the ground state of H\u2032. The overlap of |\u03a6\u20320,f \u3009 with the exact ground state of H, |\u03a80\u3009, is then\n\u03b3f = \u3008\u03a6\u20320,f |\u03a80\u3009 = \u03b3\u2032f \u3008\u03a80|\u03a8\u20320\u3009+ \u221a 1\u2212 (\u03b3\u2032f )2\u3008\u03a80|\u03a8\u2032ex\u3009, (B2)\nwhich will generally be less than or equal to \u03b3\u2032f in modulus. Our goal is then to understand how \u03b3f and \u03b3 \u2032 f are related via R,H , which we can do by bounding the overlaps \u3008\u03a80|\u03a8\u20320\u3009 and \u3008\u03a80|\u03a8\u2032ex\u3009. We can use perturbation theory to approximate |\u03a80\u3009 to lowest order in R,H in the eigenbasis of H\u2032. We first note that\nH = H\u2032 + R,H( L\n\u03bb \u2211 i wiHi \u03bb \u2212 \u2211 i Hi \u03bb ) \u2261 H\u2032 + R,HH(1) (B3)\nWe can then construct the first order correction to \u03a80 using standard perturbation theory arguments, and back out the overlaps required. Non-degenerate perturbation theory applies as the first excited state has a gap \u2206 from the ground state.\nWe start with the normalized (to O( R,H)) perturbed state, denoted with a bar\n\u03a8\u03040 = \u03a8 \u2032 0 + R,H \u2211 k>0 \u3008\u03a8\u2032k|H(1)|\u03a8\u20320\u3009 E\u20320 \u2212 E\u2032k \u03a8\u2032k +O( 2 R,H), (B4)\nand bound the second term on the right hand side by noting that |E\u20320 \u2212 E\u2032k| \u2265 \u2206/\u03b1 and that |\u3008\u03a8\u2032k|H(1)|\u03a8\u20320\u3009| \u2264 L/\u03b1:\n| \u3008\u03a8 \u2032 k|H(1)|\u03a8\u20320\u3009 E\u20320 \u2212 E\u2032k | \u2264 L \u2206\n(B5)\nWe can the compute bounds on the normalized overlaps as follows:\n\u3008\u03a80|\u03a8\u20320\u3009 = 1 +O( 2R,H), |\u3008\u03a80|\u03a8\u2032ex\u3009| \u2264 R,H L\n\u2206 +O( 2R,H). (B6)\n5 Plugging the computed bounds into our relationship between \u03b3f and \u03b3 \u2032 f , we find a worst case lower bound\n\u03b3f \u2265 \u03b3\u2032f \u2212 R \u221a 1\u2212 \u03b3\u2032f 2 L\n\u2206 +O( 2R,H). (B7)\nTherefore, to ensure we can get an overlap \u03b3f with a rotation synthesis error R,H , we would need to replace \u03b3f with \u03b3f + R,H \u221a 1\u2212 \u03b3f 2 L\u2206 in Eq A10.\nRotation synthesis error in ei\u03c6j\u03a0\nThe basis for our analysis is the expression for the QSP unitary U\u03a6(x) in the qubitized basis, Eq 13 of Dong et al. [44]\nU\u03a6(x) = e i\u03a60,i\u03c3z\u03a0dj=1[W (x)e i\u03c6j\u03c3z ], (B8)\nwhere \u03a6 = {\u03c6j} are the QSP phases, d the degree of the QSP polynomial, and W (x) the qubitized Hamiltonian operator, which is also unitary. We can also write down the approximate QSP unitary due to a rotation synthesis error U\u03a6+ R,P :\nU\u03a6+ R,P (x) = e i(\u03a60,i+ R,P )\u03c3z\u03a0dj=1[W (x)e i(\u03c6j+ R,P )\u03c3z ]. (B9)\nOur goal will be to compute a bound on the difference between the approximate and exact QSP unitary, and determine how the approximation affects the final overlap from QSP.\nWe begin by Taylor expanding the exponentials in U\u03a6+ R,P to first order in R,P , finding that each exponential gives a single correction term to the exact expression:\nU\u03a6+ R,P \u2212 U\u03a6 =ei\u03a60,i\u03c3z i R,P\u03c3z\u03a0dj=1[W (x)ei\u03c6j\u03c3z ]+\nei\u03a60,i\u03c3z d\u2211 k=1 ( \u03a0k\u22121j=1W (x)e i\u03c6j\u03c3z) ) i R,P\u03c3ze i\u03c6k\u03c3z ( \u03a0dj=k+1W (x)e i\u03c6j\u03c3z) ) +O( 2R,P )\n(B10)\nNoting that each term on the RHS is a product of unitaries, we can compute a bound on the difference of QSP operators as such:\n|U\u03a6+ R,P \u2212 U\u03a6| \u2264 (d+ 1) R,P +O( 2R,P ). (B11)\nWe also know that both U\u03a6, U\u03a6+ R,P have identical eigenvectors, and that if all the conditions in Theorem 1 are met, the eigenvalues of U\u03a6 are -close to \u00b11. As such, if all conditions in Theorem 1 are met, the eigenvalues of U\u03a6+ R,P must be, in the worst case, + (d + 1) R,P -close to \u00b11. Following the analysis in Appendix A, we can therefore replace with + (d+ 1) R,P in Eq A10 to account for the rotation synthesis error in the QSP phases.\nThe issue is, however, that the degree of the polynomial d depends on . As such, the replacement above cannot be carried about in such a trivial way, as we would like to isolate . In general the full analysis for isolating is very complex, but we can consider the analytics in a useful limit for , \u03b4 1 which we have already demonstrated is the region where QSP is a useful technique. Under the limit , \u03b4 \u2192 0, we find that d \u2192 2\u03b4 log 1 as demonstrated in Lin and Tong [7, 60]. Since we know that the error due to R,P must be subleading, we can assert that to lowest order the correction to is linear and can be written as = 0 + p, where 0 is the bare expression in Eq A10 and |p| 1 is the correction to the rotation synthesis error.\nReplacing \u2192 + (d+ 1) R,P in Eq A10, and applying our limits we find the following expression for p:\n0 + p+ 2\n\u03b4 log\n1\n0 + p R,P \u2264 0. (B12)\nTaylor expanding the logarithm, and rearranging terms, we find that p \u2264 \u22122\u03b4 log 1 0 R,P /(1\u2212 2 R,P / 0\u03b4). Noting that the rotation synthesis error is only subleading if (d+ 1) R,P 0 \u2192 2 R,P\u03b4 log 1 0 0 1\u2192 2 R,P / 0\u03b4 1, we find a final expression for p and thereby :\np \u2264 \u22122 \u03b4 R,P log 1 0 , = 0 + p (B13)\n6 Net effect of rotation synthesis error\nWe combine the rotation synthesis errors from the previous two sections into a correction to the bound on in Theorem 1,\n\u2264 1\u2212 \u03b32f 6N2iter \u2212 |\u03b3f |\n\u221a 1\u2212 \u03b32f\n4N2iter\nL \u2206 R,H \u2212 2 \u03b4 log (1\u2212 \u03b32f\n6N2iter\n)\u22121 R,P +O( 2 R,P ). (B14)\nTo understand this expression, we can first look at the sign of . We need to ensure that is bounded above by a positive number, otherwise we cannot accomplish the task of boosting to overlap \u03b3f at all. In order to do this, we will require that the two correction terms are much smaller than the first base term. We note that Niter \u223c |\u03b3i|\u22121 \u223c e\u03b7/2 where \u03b7 is the system size and \u2206 is a constant as \u03b7 \u2192 \u221e. To ensure that the second term on the RHS is smaller than the first, we will require R,H \u223c 1/L, which follows the same scaling with system size determined by Babbush et al. for QPE [10]. Since rotation synthesis errors only appear logarithmically in the T counts, prefactors become negligible and we use the rotation synthesis bounds from Babbush\u2019s work for our Hamiltonian implementation.\nTo ensure that the third term on the RHS is smaller than the first, we require R,P \u223c e\u2212\u03b7/(\u03b7N). While this seems concerning at first thought, we note that rotation synthesis appears in the T counts in a logarithmic factor, ensuring that rotation operators have depth log (e\u2212\u03b7/(\u03b7N)) \u2208 O\u0303(\u03b7) for large system sizes. Additionally, the highdepth rotations are only required for the QSP phases, which are applied once per application of an entire Hamiltonian block-encoding. We include high-depth rotations for the QSP single-qubit rotation implementations using the value R,P = 10 \u221210 0/d.\nAPPENDIX C: COMPUTING \u00b5 AND \u2206\nWe require bounds on two parameters, \u00b5 and \u2206, to implement the approximate reflector R\u03a80( ). Specifically, we require the bounds to satisfy the constraints E0 \u2264 \u00b5\u2212\u2206/2 < \u00b5+ \u2206/2 \u2264 E1. Generically, finding parameters \u00b5 and \u2206 is difficult, as they are related to the ground- and first-excited state energies of H. In this Appendix we describe the methods we have used to find values for the parameters \u00b5 and \u2206 that satisfy the above bounds.\nFor the TFIM calculations we have analytic results for the spectrum which help us compute the values of \u00b5 and \u2206. It is known that the gap in the TFIM defined in Eq. E.2.1 is 2(|g| \u2212 1) when |g| > 1 and 2(1 \u2212 |g|) for |g| < 1 [50]. We ignore the case of |g| = 1 as the TFIM is gapless, and the state preparation considered in this work requires a spectral gap to be present. We can compute the exact ground state energy E0 for the TFIM by transforming the spin operators in the Hamiltonian using the Jordan-Wigner transformation, which results in a non-interacting Hamiltonian that is easily diagonalized on a classical computer. Therefore, knowing both E0 and E1 exactly for the TFIM, we can simply set \u00b5 = (E1 + E0)/2 and \u2206 = (E1 \u2212 E0).\nFor the first quantized calculations, we use the binary search algorithm of Lin and Tong [7] to compute an approximation to the ground state energy E0 to an accuracy of \u03b41: E bin 0 = E0 + \u03b41. To reduce the overhead from conducting the binary search over the range [\u2212\u03b1, \u03b1] Eh, we reduce the binary search range to [E\u03040 \u2212Natom/2, E\u03040 +Natom/2] eV where E\u03040 is an approximate ground state energy computed from a classical simulation which we take to contain the exact ground state energy within 1 eV/atom error. One can search over a larger range at the cost of a logarithmic expense in the range. We note that for a 1 eV/atom range, the logarithmic prefactor for a typical first quantized calculation is \u223c5, while the barebones search over \u00b1\u03b1 has a logarithmic prefactor \u223c50. This prefactor can be further reduced by implementing the requisite phase estimation with an adaptive variance, i.e., estimating with a larger \u2206E for the larger intervals. We find an approximation to the true gap E1\u2212E0 by looking at the experimentally measured value for the gap \u2206exp. In general this will contain an error such that \u2206exp = (E1 \u2212 E0) + \u03b42.\nBased on our knowledge of the magnitudes of \u03b41 and \u03b42, we compute values of \u00b5 and \u2206 that satisfy the required bounds. We assume that \u03b42 \u2264 (E1 \u2212 E0) so that the experimentally measured gap is within at most 100% away of the exact gap. With this assumption, we choose \u03b41 = \u2206 exp/6, and set \u00b5 = \u2206exp/6 + Ebin0 and \u2206 = \u2206 exp/3. Double checking, we find that \u00b5+ \u2206/2 \u2264 \u2206exp/2 +E0 \u2264 E1, satisfying the upper bound. A similar calculation for the lower bound yields \u00b5\u2212\u2206/2 = E0 + \u2206exp/2 \u2265 E0 as required. One can adjust all of the scaling factors appropriately based on the knowledge of \u03b42, but it should be noted that reducing \u2206 increases the cost the most due to the \u2206\n\u22121 scaling of AA. For the calculation on the \u03b2-aluminas in this work we use \u2206exp = 9 eV [55].\n7 APPENDIX D: ALTERNATIVE DEFINITIONS OF \u03b9\n\u03b9 is intended to quantify the improvement in the expected runtime associated with implementing AA in ground state energy estimation, relative to not implementing it and repeating QPE over more trials. Short of mapping either algorithm onto a more detailed fault-tolerant quantum computer architecture, this ratio of runtimes is approximated by the ratio of T counts. In what follows we briefly consider further refinements of this ratio that might more accurately capture the expected speedup.\nIn a model of fault-tolerant quantum computation based on the surface code, the runtime of either algorithm will be proportional to the distance of the logical qubits used in their implementation. We denote the distance with (without) AA as dAA (dAA). If the two algorithms are implemented with the same distance, then these factors will cancel in a runtime ratio, consistent with the definition of \u03b9 in the main text. If the two algorithms use different distances then \u03b9 should be scaled by the proportionality factor dAA/dAA.\nA scenario in which it might be useful to consider running the two algorithms at different distances is one in which having a machine large enough to implement the algorithm with AA naturally enables the implementation of the algorithm without AA at a higher distance. This would improve the probability of successfully implementing any given run of QPE by further reducing the logical error rate of any given logical qubit. In this scenario, dAA/dAA > 1 because the runs without AA will have a longer clock cycle, and making the run without AA slower will naturally increase the speedup for the AA algorithm. However, there is also a scenario in which dAA/dAA < 1, reducing the speedup for the AA algorithm. For a scenario in which the probability of successfully implementing the algorithm with AA is the same or greater than the probability of successfully implementing the algorithm without AA, the logical error rate for any given operation will need to be lower for the former. Assuming that the success probabilities are the same for the two algorithms, dAA/dAA is asymptotically logarithmic in the quadratic speedup factor in Eq. 5, i.e., it scales inversely with log ( \u2206 \u2206E \u03b3i ) .\nAPPENDIX E: BACKGROUND\nBlock Encoding\nThe Hamiltonian itself is not unitary and therefore not amenable to direct application on a quantum computer; however, the Hamiltonian can be embedded into a larger Hilbert space such that the entire operation is unitary through a process known as \u201cblock encoding\u201d [40]. One common strategy for block encoding is the linear combination of unitaries (LCU) approach [61] where the Hamiltonian is written as\nH = L\u2211 l=0 \u03b1lHl. (E.1.1)\nEach Hl is a n-qubit unitary acting on the system register, and the number of terms L necessarily sets the size of the m-qubit auxiliary register such that L < 2m \u2212 1.\nWe can then define a pair of m-qubit state preparation unitaries\nPREPH |0\u3009\u2297m = L\u2211 l=0 al |l\u3009 ,\nUNPREPH |0\u3009\u2297m = L\u2211 l=0 bl |l\u3009 , (E.1.2)\nwith coefficients satisfying\nL\u2211 l=0 \u2223\u2223\u2223\u2223a\u2217l bl \u2212 \u03b1l\u03b1 \u2223\u2223\u2223\u2223 < LCU, (E.1.3)\nwhere \u03b1 = \u2016\u03b1l\u20161 is the norm and LCU is the error of the Hamiltonian LCU block encoding. In the case where \u03b1l > 0, one can set al = bl = \u221a \u03b1l and the state preparation pair reduces to a single prepare oracle. Even in the case of negative coefficients, the two oracles often only differ by the sign on several rotation angles.\n8 We can also define the (n+m)-qubit select unitary as\nSELH = L\u2211 l=0 |l\u3009\u3008l| \u2297Hl, (E.1.4)\nwhich applies each Hl conditioned on the value of the auxiliary register. The full block encoded Hamiltonian is then given by\nUH = (UNPREP \u2020 H \u2297 In)SELH(PREPH \u2297 In), (E.1.5)\nwhich is the core operation used in both quantum phase estimation and ground state preparation. For brevity and due to their often shared implementation, UNPREP\u2020 may simply be denoted PREP\u2020 in the remainder of the paper.\nTherefore, determining efficient circuit implementations and resource estimates for the PREP, UNPREP, and SEL oracles is the critical task for resource estimation of the entire algorithm.\nCircuits, T counts and qubits for transverse field Ising Model (TFIM)\nHamiltonian\nThe LCU implementation of the HTFIM + \u00b5I, with HTFIM defined as\nHTFIM = L\u2211 i=1 Szi S z i+1 + gS x i (E.2.1)\nrequires the specification of three circuit components: PREPTFIM ,UNPREPTFIM and SELTFIM . As \u00b5 < 0 is in general the two circuits PREPTFIM and UNPREPTFIM will not be identical.\nWe begin with the PREPTFIM and UNPREPTFIM circuits. Following the prescription in Eq E.1.2, we will require m = dlog2Le+ 2 auxiliary qubits for an L site TFIM. To understand the additional two qubits, we need to count the total number of coefficients in the system. There are 2L coefficients for each term in HTFIM and a single additional coefficient \u00b5. In order to implement the first set of 2L coefficients we require dlog2 Le+ 1 qubits in register |m\u3009, and the additional coefficient \u00b5 requires one more qubit. We will refer to the registers then as such: |j\u3009 which has size dlog2 Le and two single-qubit registers |g\u3009 and |\u00b5\u3009 which implement the unique coefficients g, \u00b5.\nThe full circuit for PREPTFIM is presented in Fig E.2.1, and can be easily shown to satisfy Eq E.1.2. Following that is the UNPREPTFIM in Fig E.2.2 has a slight modification due to the \u00b5 < 0 coefficient, namely that we have a minus sign on the rotation angle for the Rx gate on the |\u00b5\u3009 register.\n|\u00b5\u3009 Rx(2 cos\u22121 \u221a\n1+g |\u00b5|+g+1 ) \u2022\n|j\u3009 Ry(cos\u22121 \u221a\n1 1+g ) H\nH ...\nH |m\u3009 FIG. E.2.1. Implementation of PREPTFIM over three registers: |\u00b5\u3009, |j\u3009 with a single qubit each and |m\u3009 with dlog2 Le qubits.\nThe circuit SELTFIM is slightly more complex, due to the need for controlled gates. An implementation of SELTFIM for L = 4 is presented in Fig E.2.3, which has has generic features which allow for easy translation to larger L. The first obvious difference from the PREPTFIM ,UNPREPTFIM circuits is the presence of a state register |\u03c8\u3009 with size L that stores the wave function for the L site TFIM. The only gates that need to be applied to the register |\u03c8\u3009 are Z and X gates which are controlled by the registers |\u00b5\u3009, |j\u3009 and |m\u3009. The Z gates are only applied with |\u00b5\u3009 = |0\u3009, |j\u3009 = |0\u3009, and X gates only when |\u00b5\u3009 = |0\u3009, |j\u3009 = |1\u3009. Two Z gates are applied and one X for each possible configuration of the register |m\u3009, with each of the L possible configurations corresponding to the site i which the operator \u03b3zi SZi+1 or \u03b3xi is applied. In general then, we have 2L applications of a controlled Z and L applications of a controlled X over the combined register |\u00b5, j,m\u3009.\n9 |\u00b5\u3009 Rx(\u22122 cos\u22121 \u221a\n1+g |\u00b5|+g+1 ) \u2022\n|j\u3009 Ry(cos\u22121 \u221a\n1 1+g ) H\nH ...\nH |m\u3009 FIG. E.2.2. Implementation of UNPREPTFIM over three registers: |\u00b5\u3009, |j\u3009 with a single qubit each and |m\u3009 with dlog2 Le qubits.\n|\u00b5\u3009\n|j\u3009 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022\n\u2022 \u2022 \u2022 \u2022 |m\u3009 Z Z X\nZ Z X\nZ Z X\nZ Z X\n |\u03c8\u3009\nFIG. E.2.3. Implementation of SELTFIM over three registers: |\u00b5\u3009, |j\u3009 with a single qubit each, |m\u3009 with dlog2 Le qubits, and |\u03c8\u3009 the state register with L qubits.\nT counts: Hamiltonian\nThe T counts are easily read-off the diagrams. Since we have written everything in terms of single-qubit rotations gates, we use the compilation model of d10 + 4 log 2 1\nPREP e T gates per rotation to compute T counts [62]. It should be noted that the controlled rotations can be decomposed as four single-qubit rotations and two CNOTs, with the latter not requiring any T gates to implement The full T counts for the PREPTFIM and UNPREPTFIM is\nT [PREPTFIM ] + T [UNPREPTFIM ] = 10(10 + 4 log2 1\nPREP ). (E.2.2)\nWe can similarly compute the T counts for the SELTFIM circuit, which has no rotations but many multi-controlled gates. Reading off the T counts for multi-controlled X gates using the compilation model in [63]\nT [SELTFIM ] = 3L\u00d7 24(dlog2 Le+ 2). (E.2.3)\nIt should be noted that using a sawtooth or unary implementation from [10] for the control logic can reduce the T counts for the SELTFIM circuit, but given how lightweight the circuits for TFIM already, sophisticated logic implementations were not included in our implementation.\nThe full T counts for implementing the L site TFIM Hamiltonian with a shift \u00b5 is then:\nT [U(HTFIM )] = 100 + 40 log2 1\nPREP + 6L+ 72Ldlog2 Le (E.2.4)\nLogical qubits: Hamiltonian\nFor the second quantized calculation, the total number of qubits required for state preparation are simply those required for block-encoding of the Hamiltonian, plus an additional single QSP qubit. As mentioned above, the |\u00b5\u3009\n10\nregister requires a single qubit, the |j\u3009 register a single qubit, and |m\u3009 requiring dlog2 Le qubits. As the state register |\u00b5\u3009 requires L qubits, we have a total qubit count for implementing the Hamiltonian of\nNqubits = 2 + dlog2 Le+ L. (E.2.5)\nCircuits, T counts and qubits for first quantized systems\nAntisymmetrization\nHere, we briefly describe the anti-symmetrization procedure of [64], as employed in our resource estimates. The overall idea is to prepare an antisymmetrization of |0\u3009. . . |\u03b7 \u2212 1\u3009; a later step will perform a transformation |i\u3009 7\u2192 |\u03d5i\u3009. To wit, the permutations of the \u03b7 system registers are represented as quantum states of a record register. At a high level, a superposition of these permutations is produced, and then the system registers are (coherently) shuffled according to that permutation. While performing that shuffling, the record register is simultaneously \u201cunwound\u201d so that the record and system registers are disentangled. Concretely, the record register is a list of the results of all comparisons made during the execution of a sorting network, which is a sorting algorithm in which predetermined comparisons are made between particular elements of the list, and swaps are performed to put them in the correct order. The state of the sorting network, then, is fully determined by the order of the list being sorted, and the progress through the algorithm. In particular, as suggested in [64], we use the bitonic sorting network, which can also be parallelized (though we do not explicitly track circuit depth).\nProducing the superposition of permutation in record is done by generating all strings of length \u03b7, and filtering them down to bonafide permutations of the system register. The filtering step is performed by looking for any duplicates in the string, and discarding them.\nThe only difference from [64] is that we separate the filtering stage, which generates record, from the shuffling stage, which actually antisymmetrizes the system register. The shuffling step is unitary, and must be repeated for every application of R\u03a60,i , while the filtering step need only be performed once per shot [65]."
        },
        {
            "heading": "Startup/filtering",
            "text": "1. Prepare (|0\u3009 + |1\u3009)\u2297(\u03b7dlog2 \u03b72e). Interpret this as a superposition of length-\u03b7 strings over an alphabet of \u03b72 characters.\n2. Sort the string using a bitonic sorting network. Store each comparison result in record.\n3. Detect repeated terms in the (now sorted) string; if found, restart the algorithm.\nA key result of [64] is that repeated terms happen with probability < 1/2, provided the initial string is over a large enough alphabet\u2014at least the square of \u03b7, as we have here. Additionally, the record register will be disentangled, and in a superposition of all sorted repetition-free strings of length \u03b7.\nShuffling/permuting Run the bitonic sorting network again, with the following performed at each step:\n1. At every step of the sorting algorithm network, swap system registers if the record comparison indicates a swap was performed.\n2. If a swap was performed in the above step, act a Z gate on the same qubit of record. This adds a \u22121 phase for every swap performed, and therefore produces an antisymmetrized wavefunction.\n3. Compare the values of the (possibly) swapped system registers. Use this to zero the value of the qubit in record.\nNotice that the above shuffling step leaves record disentangled from the system register, though it requires that the system registers start out in a sorted state. Also, not that the process can be reversed: one can act this circuit backwards to take an antisymmetrized state back to a prepared record state, and a sorted system register.\n11\nT counts: Antisymmetrization\nThe bitonic sort network has a deterministic progression of comparison/swap steps. The number of those steps is bounded above by\nC = \u230a\u03b7\n2 \u230b blog2 \u03b7c(blog2 \u03b7c+ 1) 2\n(E.3.1)\nFollowing [64], the T cost of comparisons is 8dlog2 \u03b72e, and each controlled-swap can be performed at a T cost of 4dlog2 \u03b72e . This leads to a total cost of the startup circuit:\nTantisym-startup = \u230a\u03b7\n2 \u230b blog2 \u03b7c(blog2 \u03b7c+ 1) 2 ( 4dlog2 \u03b72e+ 8dlog2 \u03b72e ) + 8(\u03b7 \u2212 1)dlog2 \u03b72e. (E.3.2)\nThe shuffle step does not need the test for non-repetition, but is otherwise the same cost:\nTantisym-shuffle = \u230a\u03b7\n2 \u230b blog2 \u03b7c(blog2 \u03b7c+ 1) 2 ( 4dlog2 \u03b72e+ 8dlog2 \u03b72e ) . (E.3.3)\nQubit counts: Antisymmetrization\nThere are \u03b7dlog2Ne qubits used in the system register, and \u03b7dlog2 \u03b72e qubits used to construct the record. The comparison circuit has an overhead of two qubits, so an additional 2 log2 \u03b7 qubits is needed during the sorting and shuffling stages. Similarly, the Fredkin (controlled-swap gate) have an overhead of one qubit. The total overhead for any part of the antisymmetrization stage running is then (at most) 3 log2N . Finally, the record of size C =\u230a \u03b7 2 \u230b blog2 \u03b7c(blog2 \u03b7c+1) 2 qubits. The additional number of qubits required aside from the system register, with no additional handling, is then\n\u03b7dlog2 \u03b72e+ 3dlog2 \u03b7e+ \u230a\u03b7\n2 \u230b blog2 \u03b7c(blog2 \u03b7c+ 1) 2 . (E.3.4)\nThe qubits represented in the first term of Eq E.3.4 must be kept during the entire runtime, while the second and third term represent qubits that can be reused, for example in quantum phase estimation.\nDuring anti-symmetrization we only need \u03b7dlog2 \u03b72e qubits in the system register, meaning that \u03b7dlog2N \u2212 log2 \u03b7e qubits are freed for use on the largest qubit overhead in Eq E.3.4, namely record. The total number of additional qubits other than the system register needed for anti-symmetrization can then be reduced to:\n\u03b7dlog2 \u03b72e+ 3dlog2 \u03b7e+ \u230a\u03b7\n2 \u230b blog2 \u03b7c(blog2 \u03b7c+ 1) 2 \u2212 \u03b7dlog2N \u2212 log2 \u03b7e. (E.3.5)\nDue to the large qubit overhead in producing and using record, we can further reduce the total qubit count for state preparation and QPE by reusing record qubits when not running anti-symmetrization.\nHartree-Fock\nNext, we demonstrate how to perform the unitary V = |j\u3009 7\u2192 |\u03d5j\u3009 on all of the system registers. The most direct approach would simply be to find a circuit for V , and act it on each register. However, as shown in [56], there are significant advantages in exploiting the fact that the system register only contains each |j\u3009 once. We briefly reproduce the algorithm here for completeness.\nThe first observation is that the unitary V ,\nV |j\u3009 = |\u03d5j\u3009 , (E.3.6)\nhas a QR-decomposition using Givens rotations, V = \u220f p \u220f q>p GpqR, (E.3.7)\n12\nwhere R is diagonal and Gpq is unitary; both act non-trivially only on the |p\u3009-|q\u3009 subspace. Moreover, because V is unitary, R is also unitary. And, because the phases only contribute an irrelevant global phase, we ignore R hereafter.\nNext, we observe that we can truncate the expansion to\nV = \u220f p<\u03b7 \u220f q>p Gpq, (E.3.8)\nbecause we do not care about the behavior of V on initial input states besides |0\u3009 . . . |\u03b7 \u2212 1\u3009. We can also truncate the behavior on the output states:\nV = \u220f p<\u03b7 \u220f q\u2265\u03b7 Gpq. (E.3.9)\nThose additional terms would not affect the output state because any rotation of an occupied state into an occupied state will be a no-op, and we are only concerned with the behavior of V on the antisymmetrized state A |0\u3009 . . . |\u03b7 \u2212 1\u3009. Finally, notice that each Gpq can be decomposed into a Z, Y and Z rotation (as well as irrelevant global phase). Notice that initial (rightmost) Z rotation can be absorbed into the diagonal R and ignored. This means that each Gpq can be implemented (sufficient for our purproses) with two rotations.\nThus simplified, we now describe the implementation of V \u2297\u03b7, i.e., the application of V simultaneously on all \u03b7 system registers. It turns out that the dominant cost of this broadcasted-V operation is, for each Givens rotation Gpq, simply checking if the input state is in the state |p\u3009 or |q\u3009. Once that has been determined, we can shuffle the affected register to a known location, and then conditionally apply the Givens rotation. Concretely, the algorithm for performing the broadcasted Givens rotation, G\u2297\u03b7pq , is [56]:\n1. Initialize \u03b7 auxiliary qubits.\n2. For each register, j, detect if it needs to be rotated and store in the jth auxiliary qubit. I.e., do two equality tests on register j comparing to the integers p and q, each controlling a flip on auxiliary register j.\n3. For each register, j, swap the register with the final register controlled on the auxiliary register.\n4. Notice that at most two auxiliary qubits can be flipped, because at most one of p and q each can be present in the antisymmetrized wavefunction. Controlled on exactly one (equivalently, an odd number) of the auxiliary registers being set:\n(a) Identify the first digit that differs in the binary representation of p and q. Controlled on that bit, flip the other digits that differ. Assuming the first difference in the binary representation is a bit that is 0 in p, then, after doing this, the register will be p (if it started in p), or p with that digit flipped.\n(b) Perform Z and Y rotations on that first differing binary digit as required to implement Gpq.\n(c) Undo (equivalently, redo) step (4a).\n5. Undo steps 3 and 2.\nT counts: Hartree-Fock\nThe equality test in step 2 takes a dlog2Ne-Toffoli, which we assume has T cost 24dlog2Ne. Again, following [64], each controlled-swap can be performed at a T cost of 4dlog2 \u03b72e. Additionally, we take the T cost of rotations to be d10\u2212 4 log2 e.\nTGivens = 2(2 \u00b7 24dlog2Ne \u00b7 \u03b7 + 4 \u00b7 dlog2Ne(\u03b7 \u2212 1)) + 2d10\u2212 4 log2( R,H-F)e (E.3.10)\nwhere is the angular error permitted in the Givens rotations realizing the Hartree-Fock state. The total cost for the Hartree-Fock step, then, is\nTHF = \u03b7(N \u2212 \u03b7)TGivens + Tantisymm-shuffle (E.3.11)\n13\nQubit Counts: Hartree-Fock\nAn overhead of \u03b7 auxiliary qubits is required to track if the state is p or q. We perform the equality test with a Toffoli, so it requires only 1 additional qubit. The controlled swap requires log2N qubits. These temporary qubit overheads sum to\n\u03b7 + log2N + 1. (E.3.12)\nHamiltonian\nThe electronic structure Hamiltonian under the Born-Oppenheiemer approximation, i.e. with fixed nuclear degrees of freedom, is generally given as\nH = T + U + V, (E.3.13)\nwhere T is the electronic kinetic energy, U is the nuclear-electron attraction, and V is the electron-electron repulsion. Constant terms such as nuclear-nuclear interactions are also present, but can be computed classically and therefore not included here. Further specification of the Hamiltonian requires a choice of basis set; for materials, one common choice is to use a plane wave basis in a unit cell with periodic boundary conditions. Each plane wave is given by the equation\n\u03c6p(r) = \u221a 1/\u2126e\u2212i kp\u00b7r, (E.3.14)\nwhere r (kp) is a vector in real (reciprocal) space and \u2126 is the volume of the unit cell. As in Su et al. [12], we will only consider a cubic reciprocal lattice of N plane wave functions appropriate for system with no or cubic periodicity such that\nkp = 2\u03c0p\n\u21261/3 , p \u2208 G, G =\n[ \u2212N\n1/3 \u2212 1 2 , N1/3 \u2212 1 2\n]3 \u2282 Z3. (E.3.15)\nAdditionally, let G0 = G\\{(0,0,0)} be the set of allowed frequencies excluding the singular zero mode. The terms of the first-quantized electronic structure Hamiltonian can be expanded in the plane wave basis in a way that is commensurate with the linear combinations of unitaries (LCU) approach:\nT = \u03c02\n\u21262/3 \u03b7\u2211 j=1 \u2211 w\u2208x,y,z np\u22122\u2211 r=0 np\u22122\u2211 s=0 2r+s \u2211 b\u22080,1 \u2211 p\u2208G (\u22121)b(pw,rpw,s\u22951) |p\u3009 \u3008p|j  , (E.3.16) U =\n\u2211 \u03bd\u2208G0 NA\u2211 A=1 2\u03c0\u03b6A \u2126\u2016k\u03bd\u20162 \u03b7\u2211 j=1 \u2211 b\u22080,1 \u2212e\u2212ik\u03bd \u00b7RA \u2211 q\u2208G (\u22121)b[(q\u2212\u03bd)/\u2208G] |q \u2212 \u03bd\u3009 \u3008q|j  , (E.3.17) V =\n\u2211 \u03bd\u2208G0\n\u03c0 \u2126\u2016k\u03bd\u20162 \u03b7\u2211\ni 6=j=1 \u2211 b\u22080,1  \u2211 p,q\u2208G (\u22121)b[(p+\u03bd)/\u2208G]\u2228[(q\u2212\u03bd)/\u2208G] |p+ \u03bd\u3009 \u3008p|i \u00b7 |q \u2212 \u03bd\u3009 \u3008q|j  (E.3.18) where np = dlog(N1/3 + 1)e is the number of qubits needed to store the one component of the momentum pw, \u03b7 is the number of electrons, |p\u3009 \u3008q| is shorthand for I1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 (|p\u3009 \u3008q|)j \u2297 \u00b7 \u00b7 \u00b7 \u2297 I\u03b7, and \u03b6A and RA are the atomic charge and position of nuclei A, respectively, with NA total nuclei. The norms of each of these terms is given by\n\u03b1T = 6\u03b7\u03c02\n\u21262/3 (2np\u22121 \u2212 1)2, \u03b1U = \u03b7\u03b1\u03b6 \u03c0\u21261/3 \u03b1\u03bd , \u03b1V = \u03b7(\u03b7 \u2212 1) 2\u03c0\u21261/3 \u03b1\u03bd , (E.3.19)\nwhere\n\u03b1\u03b6 = NA\u2211 A=1 \u03b6A, \u03b1\u03bd = \u2211 \u03bd\u2208G0 1 \u2016\u03bd\u20162 , (E.3.20)\nand the total norm of the Hamiltonian is given as \u03b1 = \u03b1T + \u03b1U + \u03b1V .\n14\nFor simplicity of discussion, we assume \u03b1l > 0 and therefore PREP = UNPREP below. One naive implementation of the block encoding would be to simply construct PREP and SEL oracles for each term T,U, and V separately; however, it turns out that preparing the shared momentum state depending on the \u03b1\u03bd term in U and V is a large source of complexity, which motivates splitting the prepare oracles into a PREPT and PREPU+V . If we had access to operations such as PREPT ,PREPU+V ,SELT , and SELU+V with block encodings\n\u30080|PREP\u2020TSELTPREPT |0\u3009 = T\n\u03b1T ,\n\u30080|PREP\u2020U+V SELU+V PREPU+V |0\u3009 = U + V\n\u03b1U + \u03b1V ,\n(E.3.21)\nthen we could combine them into a block encoding for the full Hamiltonian as\nPREPH = (\u221a \u03b1T \u03b1 |0\u3009+ \u221a \u03b1U + \u03b1V \u03b1 |1\u3009 ) \u2297 PREPT \u2297 PREPU+V ,\nSELH = |0\u3009 \u30080| \u2297 SELT \u2297 I + |1\u3009 \u30081| \u2297 I \u2297 SELU+V . (E.3.22)\nHowever, the momentum state needed for PREPU+V can only be done efficiently with low magnitude of success; specifically, Berry et al. [64] provides a procedure to efficiently construct the momentum state that allows us to implement\nP\u0303REPU+V |0\u3009 \u2297 I \u2248 1\n2 |0\u3009 \u2297 PREPU+V +\n\u221a 3\n2 |1\u3009 \u2297 PREP\u22a5U+V . (E.3.23)\nWe must now either (i) use amplitude amplification (AA) to boost the success probability of applying PREPU+V\n(but with increased cost), or (ii) find a way to use P\u0303REPU+V directly and account for the new normalization factor of 4(\u03b1U + \u03b1V ). Su et al. [12] show how to use the latter approach and introduce an additional auxiliary qubit which renormalizes the T and U + V terms in Eq. E.3.22. Assuming that \u03b1T < 3(\u03b1U + \u03b1V ) for simplicity, the resulting block encoding is given by\nPREPH = (cos(\u03b8) |0\u3009+ sin(\u03b8) |1\u3009)\u2297 PREPT \u2297 P\u0303REPU+V , SELH = I \u2297 I \u2297 |0\u3009 \u30080| \u2297 SELU+V\ufe38 \ufe37\ufe37 \ufe38\nPREPU+V succeeded, apply SELU+V\n+ |0\u3009 \u30080| \u2297 SELT \u2297 |1\u3009 \u30081| \u2297 I\ufe38 \ufe37\ufe37 \ufe38 PREPU+V failed and first qubit 0,\napply SELT\n+ |1\u3009 \u30081| \u2297 I \u2297 |1\u3009 \u30081| \u2297 I\ufe38 \ufe37\ufe37 \ufe38 PREPU+V failed and first qubit 1,\napply neither\n, (E.3.24)\nwhere \u03b8 = arccos \u221a \u03b1T /3(\u03b1U + \u03b1V ) is needed in order to rebalance the terms and recover a block encoding with the proper normalization factor \u03b1T + \u03b1U + \u03b1V .\n15\nImplementation of PREPPREPH\nThe full state we want to prepare is( cos(\u03b8) |0\u3009a + sin(\u03b8) |1\u3009a )\ufe38 \ufe37\ufe37 \ufe38 Balances T and U+V terms\n|+\u3009b\ufe38\ufe37\ufe37\ufe38 Indexes bit values Used in T, U, V\n\u2297 1 \u03b7 \u221a\u03b7 \u2212 1 |0\u3009c \u03b7\u2211 i 6=j=1 |i\u3009d |j\u3009e + |1\u3009c \u03b7\u2211 j=1 |j\u3009d |j\u3009e  \ufe38 \ufe37\ufe37 \ufe38\nRegister c flags i 6= j, d and e index electrons All used in V , just e used in T, U, V\n( 1\u221a 3 2\u2211 w=0 |w\u3009f ) \ufe38 \ufe37\ufe37 \ufe38\nIndexes x, y, z components Used in T\n\u2297 (\n1\n2np\u22121 \u2212 1 np\u22122\u2211 r,s=0 2(r+s)/2 |r\u3009g |s\u3009h ) \ufe38 \ufe37\ufe37 \ufe38 r and s each index bits in momentum\nUsed in T\n(\u221a \u03b1U\n\u03b1U + \u03b1V |0\u3009i +\n\u221a \u03b1V \u03b1U + \u03b1V |1\u3009i )\n\ufe38 \ufe37\ufe37 \ufe38 Balances U and V terms\n\u2297 (\u221a\np\u03bd \u03bb\u03bd |0\u3009j \u2211 v\u2208G0 1 \u2016\u03bd\u2016 |\u03bd\u3009k + \u221a 1\u2212 p\u03bd |1\u3009j |\u03bd\u22a5\u3009k ) \ufe38 \ufe37\ufe37 \ufe38 Register j heralds good state, i.e. flag qubit in Eq. E.3.23\nRegister k indexes momenta Used in U, V\n( 1 \u221a \u03b1\u03b6 NA\u2211 A=1 \u221a \u03b6A |RA\u3009l ) \ufe38 \ufe37\ufe37 \ufe38\nStores nuclear charge and position Used in U\n,\n(E.3.25)\nwhere the underbraces give a short description, including which Hamiltonian term they are used in, for each part of\nthe state. Su et. al. [12] assigns these terms in the following way: PREPT prepares registers b, f, g, h; P\u0303REPU+V prepares registers c, d, e, j, k, l; and the rotations needed for registers a and i are performed separately. Some of this assignment is arbitrary in that some registers are useful to multiple terms and could be performed by either oracle. Also note that register l is being used to store the nuclear positions RA rather than the index A, saving one set of auxiliary qubits.\nSince explicit circuits have been shown for various components of these oracles in the literature [11, 12, 56, 57], we simply give a high-level overview of the procedure for each register in Eq. E.3.25 below.\n1. Rotate the qubit in register a to select between T and U + V\n2. Perform a Hadamard on register b to index the bit values {0, 1}\n3. Prepare equal superpositions of \u03b7 values in registers d and e using the method described in Appendix A.2 of [11]\n4. Test for equality between registers d and e, storing the result in register c\n5. Prepare equal superpositions of 3 values in register f\n6. Prepare exponential superpositions in registers g and h using the method described in Section II.B of [12]\n7. Prepare an equal superposition of n\u03b7\u03b6 = \u03b7+2\u03b1\u03b6 values and perform an inequality test to determine the weighting between U and V terms in register i\n8. Perform the momemtum state preparation procedure from [57] in register k, with register j as the flag qubit 9. Load nuclear charges \u221a \u03b6A and positions RA into register l using QROM\nWhile the sizes of many of these registers are well-defined based on their limits in Eq. E.3.25, there are three notable exceptions that we enumerate here. Register a has size nT , which determines the precision of the rotation by angle \u03b8. As part of the momentum state preparation, there is a register of size nM that determines the precision of the inequality test that computes the 1/\u2016\u03bd\u2016 coefficient. Finally, the size of register l is given by size nR, which determines the precision of the nuclear positions RA that are loaded in from QROM. The values of nT , nM , and nR contribute to the error of the block encoding and therefore impact the resource estimates, as shown below.\n16\nImplementation of SELH\nThe SEL oracles should perform the transformations\nSELT : |b\u3009b |j\u3009e |w\u3009f |r\u3009g |s\u3009h |pj\u3009 7\u2192 (\u22121)b(pw,rpw,s\u22951) |b\u3009b |j\u3009e |w\u3009f |r\u3009g |s\u3009h |pj\u3009 , SELU : |b\u3009b |j\u3009e |0\u3009i |\u03bd\u3009k |RA\u3009l |qj\u3009 7\u2192 \u2212e\u2212ik\u03bd \u00b7RA(\u22121)b[(q\u2212\u03bd)/\u2208G] |b\u3009b |j\u3009e |0\u3009i |\u03bd\u3009k |RA\u3009l |qj \u2212 \u03bd\u3009 , SELV : |b\u3009b |i\u3009d |j\u3009e |1\u3009i |\u03bd\u3009k |pi\u3009 |qj\u3009 7\u2192 (\u22121)b([(p+\u03bd)/\u2208G]\u2228[(q\u2212\u03bd)/\u2208G]) |b\u3009b |i\u3009d |j\u3009e |1\u3009i |\u03bd\u3009k |pi + \u03bd\u3009 |qj \u2212 \u03bd\u3009 .\n(E.3.26)\nAs all three SEL operations require performing arithmetic on the momentum registers, this is most efficiently done by first controlling a swap of the momentum into auxiliary registers, performing the operation on the auxiliary, and then swapping back.\nAs with the prepare oracles, we note that these oracles are shown in detail in the literature [12, 56] and summarize the high-level overviews for the oracles in Eq. E.3.26 below. For SELT , the procedure is\n1. Controlled on register f , copy component w of momentum p into an auxiliary register\n2. Controlled on register g (h), copy bit r (s) of pw into an auxiliary qubit, respectively\n3. Controlled on the auxiliary qubits containing pw,r and pw,s, perform a phase flip on register b (unless both bits are one)\n4. Erase the auxiliary registers (with Cliffords and measurement)\nwhile for SELU and SELV , the procedure is\n1. (U and V ) Controlled on registers d and e, swap momentum registers p and q into auxiliary registers\n2. (V only) Controlled on |0\u3009 for \u201cV only\u201d qubit, add \u03bd into the auxiliary register for p\n3. (U and V ) Controlled on |0\u3009 for \u201cU or V \u201d qubit, subtract \u03bd into the auxiliary register for q\n4. (U and V ) If p+ \u03bd and q \u2212 \u03bd are inside the box G, perform a phase flip on register b\n5. (U and V ) Controlled on registers d and e, swap the auxiliary registers back to the momentum registers\n6. (U only) Controlled on |0\u3009 for \u201cU or V \u201d qubit and |1\u3009 for \u201cV only\u201d qubit, apply the phase e\u2212ik\u03bd \u00b7RA\nLogical qubit counts: Hamiltonian\nA full accounting of qubit costs are given in Appendix C.1 of [12], but the number of logical qubits needed is\nNqubits = 3\u03b7np + n\u03b7\u03b6 + 2n\u03b7 + 3n 2 p + 17np + max(nT , nR + 1) + 5nR + 5nM + 4nMnp + 31 (E.3.27)\n17\nT counts: Hamiltonian\nThe T cost of block encoding the first-quantized electronic structure Hamiltonian is\nT [U(H)] = 7\ufe38\ufe37\ufe37\ufe38 Toffoli to T conversion from [21]\n[ 2(nT + n\u03b7\u03b6 + 2br \u2212 12)\ufe38 \ufe37\ufe37 \ufe38\nPrepare registers a and i, i.e. rotation between T and U + V and superposition for U and V test\n+ 14n\u03b7 + 8br \u2212 36\ufe38 \ufe37\ufe37 \ufe38 Prepare registers c, d and e,\ni.e. equal superpositions over electron indices and i 6= j test\n+ 2(2np + 9)\ufe38 \ufe37\ufe37 \ufe38 Prepare registers f, g, and h, i.e. equal superpositions over\nmomentum components and bits\n+ 12\u03b7np + 4\u03b7 \u2212 8\ufe38 \ufe37\ufe37 \ufe38 Controlled swaps of p and q registers\nfor SEL operations\n+ 5(np \u2212 1) + 2\ufe38 \ufe37\ufe37 \ufe38 Cost of SELT\n+ a [ 3n2p + 15np \u2212 7 + 4nM (np + 1) ]\ufe38 \ufe37\ufe37 \ufe38 Prepare registers j and k,\ni.e. momentum state\n+ \u03b1\u03b6 + Er(\u03b1\u03b6)\ufe38 \ufe37\ufe37 \ufe38 Prepare register l,\ni.e. \u221a \u03b6l amplitudes and QROM for Rl\n+ 24np\ufe38\ufe37\ufe37\ufe38 Add/subtract \u03bd into momentum registers + 8NpnR\ufe38 \ufe37\ufe37 \ufe38 Phasing by \u2212eik\u03bd \u00b7RA + 18\ufe38\ufe37\ufe37\ufe38 Selection between T, U, and V\n]\n(E.3.28)\nwhere br is the number of bits of precision for rotation on an auxiliary qubit and can be taken as br = 7 for a success\nprobability of over 0.999, a is a factor that is 1 if no amplitude amplification (AA) for P\u0303REPU+V is used and 3 if a single round of AA is used, and\nEr(x) := min k\u2208N\n( 2k + d2\u2212kxe ) (E.3.29)\nis the cost of erasing the output of x entries of QROM. However, we must consider that we rarely want to apply the block encoded Hamiltonian in isolation; rather, we want to use controlled applications of the Hamiltonian both in Usp(H) and \u039b(W(H)) in Fig. 1. Of the qubits in Eqn. E.3.27, there are n\u03b7\u03b6 + 2n\u03b7 + 8np + nM + 16 qubits that need to be controlled/reflected on. Therefore, the full T cost of the controlled Hamiltonian is\nT [\u039b(U(H))] = T [U(H)] + 4 [n\u03b7\u03b6 + 2n\u03b7 + 8Np + nM + 16] (E.3.30)\nFinally, we return to the quantities nT , nM , and nR, which introduce errors\nT = \u03c0\u03b1\n2nT ,\nM = 2\u03b7 2nM\u03c0\u21261/3 (n\u03b7\u03b6 \u2212 1)(7\u00d7 2np+1 \u2212 9np \u2212 11\u2212 3\u00d7 2\u2212np),\n\u03b3R = \u03b7\u03b1\u03b6\n2nR\u21261/3 \u2211 \u03bd\u2208G0 1 \u2016\u03bd\u2016 .\n(E.3.31)\nWe determine nT , nM , and nR by setting their corresponding errors such that T = M = R = /10, where is the total error in the calculation. This is done such that the error from these sources is smaller than those corresponding to coming from Theorem 1 or rotation synthesis discussed in Appendix B. We then performed a grid search over an array of values, starting 4 below and ending 4 above the calculated values. We found that the grid search only improved the T counts by one or two percent. We also compared our values to those found by the TFermion package [66], which performs a gradient-free optimization over these parameters. Empirically, these analytical T counts were within a factor of 2 of the TFermion counts for several test cases we studied.\nT counts and qubits for Quantum Phase Estimation (QPE)\nIn this work we use the low-T cost QPE algorithm of Babbush et al. [10], shown in Fig 1(a). All of the following details can be found in that work. The circuit is composed of three components, the qpe register initialization \u03c7m,\n18\na sequence of controlled Szegedy walk operators \u039b(W(H)), and an inverse Fourier Transform QFT \u2020 to read out the final measured energy. The expense of implementing the phase estimation algorithm is determined entirely by two different parameters: \u2206E, the target Holevo variance of the measured ground state energy, and \u03b1 \u2265 ||H||. The agregate quantity p, defined below in terms of \u2206E and \u03b1, will be used to parameterize the cost of QPE:\np = dlog( \u221a 2\u03c0\u03b1\n2\u2206E )e. (E.4.1)\nT counts\nWe break up the T counts into the three different circuit components. Beginning with \u03c7m, the only non-Clifford gates required are p controlled -single-qubit rotation operators, which would require four single-qubit rotation operators each and a two CNOT gates to implement. For QFT \u2020, we require p(p\u2212 1)/2 controlled-single-qubit rotations, which again each require four single-qubit rotations. We note also that the rotation synthesis error in \u03c7m and QFT\n\u2020 required to ensure a Holevo variance \u2206E is QFT /(\u03c0p) where QFT \u2264 2\u2212(p+1). For the Szegedy walk, we require 2p applications of H, with the T counts for the latter denoted T [U(H)], and can be located in Eq E.2.4 and Eq E.3.28. The total T count for QPE then amounts to:\nT [QPE] = (4p+ 2p(p\u2212 1))(10 + 4 log2 \u03c0p\nQFT ) + 2pT [U(H)] (E.4.2)\nLogical qubits\nOnly p qubits are required for QPE to measure the energy with Holevo variance \u2206E."
        }
    ],
    "title": "Quantifying T -gate-count improvements for ground-state-energy estimation with near-optimal state preparation",
    "year": 2023
}