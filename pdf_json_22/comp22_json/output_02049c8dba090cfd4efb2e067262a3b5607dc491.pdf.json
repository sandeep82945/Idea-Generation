{
    "abstractText": "Many Big Data applications include the processing of data streams on semi-structured data formats such as JSON. A disadvantage of such formats is that an application may spend a significant amount of processing time just on unselectively parsing all data. To relax this issue, the concept of raw filtering is proposed with the idea to remove data from a stream prior to the costly parsing stage. However, as accurate filtering of raw data is often only possible after the data has been parsed, raw filters are designed to be approximate in the sense of allowing false-positives in order to be implemented efficiently. Contrary to previously proposed CPU-based raw filtering techniques that are restricted to string matching, we present FPGA-based primitives for filtering strings, numbers and also number ranges. In addition, a primitive respecting the basic structure of JSON data is proposed that can be used to further increase the accuracy of introduced raw filters. The proposed raw filter primitives are designed to allow for their composition according to a given filter expression of a query. Thus, complex raw filters can be created for FPGAs which enable a drastical decrease in the amount of generated false-positives, particularly for IoT workload. As there exists a trade-off between accuracy and resource consumption, we evaluate primitives as well as composed raw filters using different queries from the RiotBench benchmark. Our results show that up to 94.3% of the raw data can be filtered without producing any observed false-positives using only a few hundred LUTs.",
    "authors": [
        {
            "affiliations": [],
            "name": "Tobias Hahn"
        },
        {
            "affiliations": [],
            "name": "Andreas Becher"
        },
        {
            "affiliations": [],
            "name": "Stefan Wildermann"
        },
        {
            "affiliations": [],
            "name": "J\u00fcrgen Teich"
        }
    ],
    "id": "SP:ca6dafa9acdeae6572ebf4d4ca050a8cd2f9b536",
    "references": [
        {
            "authors": [
                "A. Becher",
                "S. Wildermann",
                "J. Teich"
            ],
            "title": "Optimistic regular expression matching on fpgas for near-data processing",
            "venue": "DAMON \u201918,",
            "year": 2018
        },
        {
            "authors": [
                "A. Becher",
                "A. Herrmann",
                "S. Wildermann",
                "J. Teich"
            ],
            "title": "Reprovide: Towards utilizing heterogeneous partially reconfigurable architectures for near-memory data processing. pages 51\u201370",
            "venue": "Gesellschaft fu\u0308r Informatik,",
            "year": 2019
        },
        {
            "authors": [
                "Y. Fang",
                "C. Zou",
                "A.A. Chien"
            ],
            "title": "Accelerating raw data analysis with the accorda software and hardware architecture",
            "venue": "Proc. VLDB Endow.,",
            "year": 2019
        },
        {
            "authors": [
                "A. Go"
            ],
            "title": "Sentiment classification using distant supervision",
            "year": 2009
        },
        {
            "authors": [
                "T. Jepsen",
                "D. Alvarez",
                "N. Foster",
                "C. Kim",
                "J. Lee",
                "M. Moshref",
                "R. Soul\u00e9"
            ],
            "title": "Fast string searching on pisa",
            "venue": "SOSR \u201919,",
            "year": 2019
        },
        {
            "authors": [
                "G. Langdale",
                "D. Lemire"
            ],
            "title": "Parsing gigabytes of json per second",
            "venue": "The VLDB Journal,",
            "year": 2019
        },
        {
            "authors": [
                "Y. Li",
                "N.R. Katsipoulakis",
                "B. Chandramouli",
                "J. Goldstein",
                "D. Kossmann"
            ],
            "title": "Mison: A fast json parser for data analytics",
            "venue": "Proc. VLDB Endow.,",
            "year": 2017
        },
        {
            "authors": [
                "R. Mueller",
                "J. Teubner",
                "G. Alonso"
            ],
            "title": "Streams on wires: A query compiler for fpgas",
            "venue": "Proc. VLDB Endow.,",
            "year": 2009
        },
        {
            "authors": [
                "R. Mueller",
                "J. Teubner",
                "G. Alonso"
            ],
            "title": "Glacier: a query-to-hardware compiler",
            "year": 2010
        },
        {
            "authors": [
                "S. Palkar",
                "F. Abuzaid",
                "P. Bailis",
                "M. Zaharia"
            ],
            "title": "Filter before you parse: Faster analytics on raw data with sparser",
            "venue": "Proc. VLDB Endow.,",
            "year": 2018
        },
        {
            "authors": [
                "M. Sadoghi",
                "R. Javed",
                "N. Tarafdar",
                "H. Singh",
                "R. Palaniappan",
                "H.-A. Jacobsen"
            ],
            "title": "Multi-query stream processing on fpgas",
            "year": 2012
        },
        {
            "authors": [
                "A. Shukla",
                "S. Chaturvedi",
                "Y. Simmhan"
            ],
            "title": "Riotbench: A real-time iot benchmark for distributed stream processing platforms",
            "venue": "arXiv preprint arXiv:1701.08530,",
            "year": 2017
        },
        {
            "authors": [
                "J. Thomas",
                "P. Hanrahan",
                "M. Zaharia"
            ],
            "title": "Fleet: A framework for massively parallel streaming on fpgas",
            "venue": "ASPLOS \u201920,",
            "year": 2020
        },
        {
            "authors": [
                "L. Woods",
                "J. Teubner",
                "G. Alonso"
            ],
            "title": "Complex event detection at wire speed with fpgas",
            "venue": "Proc. VLDB Endow.,",
            "year": 2010
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n20 5.\n05 46\n4v 1\n[ cs\n.D B\n] 1\n1 M\nay 2\n02 2\nContrary to previously proposed CPU-based raw filtering techniques that are restricted to string matching, we present FPGA-based primitives for filtering strings, numbers and also number ranges. In addition, a primitive respecting the basic structure of JSON data is proposed that can be used to further increase the accuracy of introduced raw filters.\nThe proposed raw filter primitives are designed to allow for their composition according to a given filter expression of a query. Thus, complex raw filters can be created for FPGAs which enable a drastical decrease in the amount of generated false-positives, particularly for IoT workload.\nAs there exists a trade-off between accuracy and resource consumption, we evaluate primitives as well as composed raw filters using different queries from the RiotBench benchmark. Our results show that up to 94.3% of the raw data can be filtered without producing any observed false-positives using only a few hundred LUTs.\nIndex Terms\u2014Raw Filtering, JSON, FPGA, HW/SW-CoDesign\nI. INTRODUCTION\nMany Big Data applications in domains such as the Internet of Things and Industry 4.0 not only face a high volume of data that is generated with a high frequency, but also have strong latency requirements for analyzing this data. In this realm, data stream processing is gaining more and more importance where data is continuously processed and analyzed as soon as it is generated or received. However, data is often streamed in unstructured or semi-structured data formats, such as JSON, XML, SenML. While these formats are easily readable for humans, it is in fact quite the opposite for CPUs: Parsers have to process ASCII characters byte by byte, not fully utilizing the CPU word width. Li et al. [7] reports that Big Data applications can spend 80%-90% of their execution time on parsing. Our own evaluations of the Yahoo streaming benchmark1 have shown that parsing takes 70% of the processing time. Modern parser implementations, like Mison [7] and simdjson [6] for JSON, utilize SIMD instructions to mitigate this problem and can scan documents with up to 2 GB/s with one core. However, sequentially scanning a raw byte stream with a single core would still be 10\u00d7 faster than retrieving the (JSON) structure by parsing it [10]. Therefore, Palkar et al. [10] suggested raw filtering of the byte stream before the parser is applied with the idea of exploiting the selectivity\n1https://github.com/yahoo/streaming-benchmarks\n{\"e\":[ ... {\"v\":\"35.2\",\"u\":\"far\",\"n\":\"temperature\"}, {\"v\":\"12\",\"u\":\"per\",\"n\":\"humidity\"}, {\"v\":\"713\",\"u\":\"per\",\"n\":\"light\"}, {\"v\":\"305.01\",\"u\":\"per\",\"n\":\"dust\"}, {\"v\":\"20\",\"u\":\"per\",\"n\":\"airquality_raw\"} ],\"bt\":1422748800000}\nListing 1: Running Example - JSON record excerpt taken from the RiotBench SmartCity dataset."
        },
        {
            "heading": "Q0 := $.e[?(@.n==\"temperature\"",
            "text": "& @.v \u2265 0.7 & @.v \u2264 35.1)]\nListing 2: Running Example - JSONPath Query\nof the given query to further accelerate JSON parsing. Filter predicates are translated into so-called Raw Filters (RFs), which are inspecting the raw byte stream in a structureagnostic fashion. Listing 2 presents a query on a stream of IoT records as illustrated in Listing 1 as a motivational example. Here, all records containing a \u201dtemperature\u201d sensor measure which lies in the range of [0.7, 35.1] are queried. RFs proposed by [10] are restricted to string comparisons. The \u201dtemperature\u201d string would thus be a possible RF to be searched in the byte stream regardless of any structure. If the string is found at least once in a record, the record is accepted. If no occurrences of the string can be identified, the record is dropped and the parser doesn\u2019t have to deal with it. While this approach may produce some false-positives (e.g., records where the temperature value doesn\u2019t lie within the range), it guarantees that no false-negatives are created (i.e., no records are filtered out that contain temperature measures). The false-positives, on the contrary, are not affecting the end result, as the CPU parser will accurately filter the remaining records. Accordingly, falsepositives only reduce the achievable speedup gained from the filter selectivity. However, the restriction to string matching poses an issue. Many applications, especially from the IoT domain, are gaining their selectivity from filtering numbers, timestamps, or number ranges as exemplified in Listing 2.\nIn this paper, we investigate raw filtering on FPGAs. Particularly, we introduce FPGA-based concepts for string matching and filtering number ranges in byte streams. Such raw filters can be combined to create more complex and ideally more selective filters, e.g., a conjunctive (AND) combination of string matching (s(\u201dtemperature\u201d)) and a value range filter (0.7 \u2264 v \u2264 35.1) for the query in Listing 2. However, filters built by conjunction and disjunction of filter predicates might not always result in improved selectivity. For example, the record in Listing 1 contains the \u201dtemperature\u201d string and numbers (\u201d12\u201d, \u201d20\u201d) which lie in the given value range. However, the temperature value itself (\u201d35.2\u201d) exceeds it. Thus, the described raw filter would generate a false-positive. We therefore additionally\npresent a technique which is able to extract structural information while scanning the byte stream. By using this technique, filter predicates can be combined such that their results are only combined if found in the correct structural context.\nThe contributions of this paper can be summarized as follows:\n1) FPGA-based raw filtering concepts: primitives optimized for FPGA-based RFs: (a) An approximate string matcher. (b) An approximate number range matcher.\nExtracting structural information and building raw filters by conjunctive and disjunctive combination of filter primitives depending on structural context. 2) Raw filter evaluation: query-specifc raw filter configurations: tradeoffs between resource requirements\nand false-positive rates\n3) FPGA hardware architecture and implementation for raw filtering: Filtering data streams at 10 GBit/s (line rate), i.e., no negative effect on performance of\noverall system. Tailored to filter the data stream directly between the data source (e.g., Ethernet, SSD) and CPU (SmartNIC, etc.).\nThe remaining paper is organized as follows: In Section III, concepts and techniques for different raw filtering primitives are introduced and their composition into a complex raw filter is discussed. In Section IV, the proposed filters are evaluated with the RiotBench Benchmark. Finally, the paper finishes in Section V with a conclusion and an outlook for future work."
        },
        {
            "heading": "II. RELATED WORK",
            "text": "There has been a lot of research to accelerate parsing recently [6, 7]. Those implementations rely on SIMDinstructions and can scan documents at a speed of over 2 GB/s. One of these Parsers is Mison [7] presented by Li et al.. Mison uses SIMD-instructions to build a structural index of a record. Queried Fields are then parsed on demand by speculatively jumping to the beforehand indexed attribute positions.\nSparser [10] was the first to approximately pre-filter records using SIMD-based string comparisons on raw data, to reduce the parsing workload itself. Sparser\u2019s RFs are based on two filtering primitives. The main primitive is a substring search, that inspects the input byte stream for 2-, 4- and 8-byte long substrings. The second primitive is used for key-value search and can filter co-occurrences of substrings. One major drawback of Sparser is the limitation to filter only based on string comparisons. Many applications, however, especially those in the IoT domain, are gaining their selectivity from filtering numbers or timestamps. In other scenarios, it\u2019s necessary to have at least a small degree of structural awareness, which is except for the key-value search not possible with Sparser. The concept of raw filtering has been adopted for programmable switches, too [5]. Here, strings are searched by several small cascaded DFAs. Nevertheless, programmable switches have limited resources and packets need to be recirculated through the switch, to filter complex expressions, therefore implying bandwidth limitations.\nThere have been several stream processing Query Compilers for FPGAs [8, 9, 11]. But these compilers solely work on binary data, not considering that the input data might have to be parsed before processing. The Fleet [13] framework can push arbitrary Stream operations, like JSON Parsing,\nonto the FPGA by introducing a new DSL. However, their presented PUs can\u2019t process one character per cycle and must be replicated extensively to achieve a high throughput, hence requiring a lot of resources. ACCORDA [3] tries to improve the processing of raw unstructured data with dedicated Hardware Accelerators. The authors show that their unstructured data processor can parse and filter JSON data for all common predicates, but is in return again very resource intensive. The presented FPGA prototype requires 295K LUTs. Moreover, regular expression matching has already been investigated for FPGAs heavily. Woods et al. [14] suggest regular expression matching with an FPGA located between NIC and CPU, for complex event detection in data streams. As regular expressions can get arbitrarily complex and FPGA resources are limited, Becher et al. [1] propose a optimistic regex evaluation. Compared to our raw filters, this approach enables similar tradeoffs between resource consumption and the accuracy of the filter. Nevertheless, we only used regular expressions for building our value range filter, as the resource consumption can be further reduced by using the other presented primitives."
        },
        {
            "heading": "III. RAW FILTERING PRIMITIVES & COMPOSITION",
            "text": "In this section, we present FPGA filter primitives for string matching and for detecting values and value ranges. We furthermore propose a technique to extract some information of the JSON structure from the byte stream and describe how to compose these primitives to build query-specific selective raw filters."
        },
        {
            "heading": "A. String Search",
            "text": "The original idea of raw filtering is to find a string anywhere in a given byte stream regardless of any structure. In the following, we investigate three techniques to implement string matching on FPGAs. Let the search string have a size of N Bytes. (i) The string can be matched with a state machine accepting the search string with N states, which transitions with one character every cycle. (ii) Another option would be to buffer the last N Bytes of the byte stream and compare them to the full N -Byte search string every cycle. While these solutions exactly match a given search string, we want to introduce a more resource-saving approximate option that allows rare false-positives to occur. (iii) Instead of buffering the full length of the search string, we only buffer the last block length (B) Bytes of the input byte stream. This buffer is compared to all possible substrings of a size of B Bytes of the search string. The results of these comparators are then or-reduced and fed into a counter, which is incremented with each match and reset when no comparator matches. The filter\nemits a \u20191\u2019 if the counter value is equal to N \u2212B +1. As an example, Table IV shows all substrings of the search string \u201dtemperature\u201d for different block lengths B. Figure 1 presents a schematic of our concept for search string \u201dtemperature\u201d and block length B = 2. In the remainder of this paper, searching a string str with block length B is denoted as sB(str).\nIn the following, these three techniques will be evaluated in terms of false-positive rate (FPR) and resource costs (LUTs). For this purpose, the strings used in RiotBench [12] are examined with their associated datasets. As these measurement lists aren\u2019t containing many strings, which might cause false-positives, we additionally evaluated a more diverse Twitter dataset [4]. The results can be seen in Tables I to III. While for the exact solutions (i, ii) the required LUTs increase rapidly with the length of the string, only slightly more resources are required for longer strings for the substring search (iii). This is due to the or-reduction of the many comparisons, which ensures that the entire logic can be combined in one LUT. This large LUT can be mapped effectively to hardware primitives by the synthesis tool. In the comparison of the exact methods (i, ii), the full-length comparison (ii) turns out to be advantageous for shorter strings, since no states have to be encoded. However, as the length of the strings increases, the amount of logic required to process several chars in parallel increases significantly.\nIn contrast, the DFA-based solution (i) only requires one char to be processed per cycle, while the number of bits required to encode the states increases only approximately logarithmically. With respect to the required LUTs, the presented subset matcher with B = 1 turns out to be superior in all cases. But especially for longer strings, where even for B = 1 an FPR of 0 is achieved. For shorter strings, however, an FPR of 0 is only achieved for B = 2, whereby the full-length comparisons in these cases partially require fewer LUTs. In rare cases, with a B = 1, even longer strings can be completely confused with other regularly occurring strings, as can be seen for the string s1(\u201dtolls amount\u201d), which contains the same letters as the string \u201dtotal amount\u201d. Here, however, a favorable solution can be found with a B = 2. All in all, there are three interesting variants for our RFs. For long strings, an FPR of 0 can usually be achieved for B = 1 with a minimum of resources. For all other cases B = 2 is usually advantageous, but in some cases a full length comparison is also preferable. Accordingly, the search space for following evaluations of the RiotBench concentrates on B \u2208 {1, 2, N}, where B = N corresponds to string matching option (ii)."
        },
        {
            "heading": "B. Number Range Filtering",
            "text": "For scanning a byte stream to contain specific integer, float, or time stamp values or even value ranges, we propose to filter the stream with deterministic finite automatas (DFAs). For this, a regular expression for the value (range) is first derived and then converted into a DFA to be synthesized for the FPGA. Figure 2 illustrates the process for detecting integers greater or equal to 35 (i \u2265 35) in a byte stream. The same approach is used for deriving a regex for upper bounds (e.g., i \u2264 35). The comparison against a range of values, i.e. with an upper and a lower bound, can still be performed with only one automaton, which can later be optimized better than two separate automata and thus requires fewer resources overall.\nBuilding these DFAs for floating-point numbers is done similarly. After the decimal point, we just continue to check the given bounds for the decimal places. Nevertheless, there is one major difference between floats and integers which can\u2019t be mapped into DFAs easily. The JSON specification allows an exponent format (e.g., 2.1e3), which is virtually impossible to match via state machines. That\u2019s because of the almost unlimited possibilities to format the same number (e.g., 1e+1, 10, 100e-1, . . . ). As a remedy, we accept any number, including at least one digit followed by an \u2019e\u2019 or an \u2019E\u2019. In such a case, the raw filter primitive might create a false-positive, but at least no false-negative.\nIn step 2 the regular expression is converted into a DFA and minimized.Methods to achieve this are already well known and won\u2019t be explained here. The DFA is evaluated every time a non-numeric (including \u2019+\u2019, \u2019-\u2019, \u2019.\u2019, \u2019e\u2019) character is seen, as it has to mark the end of the number. At this point, the value filter omits a \u20191\u2019 if the last state was an accepted state, or a \u20190\u2019 if the last state wasn\u2019t accepted. The DFA is then reseted and starts over from state s0. The shown method is not only valid for numerical filters, but can also be used for date formats or any other filter which can be represented using regular expressions. A number matcher for an integer i or a float f with a lower bound \u2113 and an upper bound u is denoted in the following as \u2113 \u2264 i \u2264 u or \u2113 \u2264 f \u2264 u, respectively."
        },
        {
            "heading": "C. Structural awareness",
            "text": "In many scenarios, applications require some degree of structural awareness. However, this doesn\u2019t mean that we have to parse the full structure of a given record. Instead, we propose to observe only those elements which help us the most with reducing the number of false-positives.\nAs already shown in the introductory example, it can be advantageous to observe object structures, especially for filtering IoT data, since sensor values are commonly stored together with metadata in an object. This is also evident for the Sensor Measurement Lists (SenML) standard used in running example (Listing 1), where a JSON record is defined over an array of sensor measurements. Since such sensor-\nmeasurement objects usually contain the same attributes for all objects, key-value relationships are hardly relevant for filtering (see Listing 1 where the keys \u201dv\u201d, \u201du\u201d, and \u201dn\u201d appear in all objects of the record). For more conventional JSON data, such as statistics gathered from web service APIs (e.g., Twitter2), key-value relationships are much more important, since the keys are usually only represented once in the entire record and can thus be used as a unique identifier.\nThis sensitivity for nesting levels is achieved by incrementing a counter with every \u2019[\u2019,\u2019{\u2019and decrementing it with every \u2019}\u2019,\u2019]\u2019. As this counter has to be consistent at any time, it\u2019s necessary to detect if a bracket is part of a string and should therefore not be used to alter the nesting level. Detecting strings, however, requires checking if a quote \u201d is escaped by a \u2019\\\u2019 character. And \\can again be escaped by \\\\. This information can then be used to build a string mask and consequently to correctly determine the nesting levels.\nDetecting key-value pairs can be done using the same method. Instead of tracking the nesting levels we just need to check that the key RF and the value RF both appear before the same unescaped comma. Two RFs (RF1, RF2) appearing on the same nesting level are denoted as {RF1 & RF2} in the following."
        },
        {
            "heading": "D. Design Flow",
            "text": "The design flow for generating an optimized raw filter for a given query can be broken down into four steps. i) Extract search strings and value ranges from the query. ii) Select corresponding primitives and their parameters that should be tested (in our case: values for block length B). iii) Determine possible combinations that constitute the design space: (a) Primitives that appear in the same context could be combined via structural-aware filtering or without. (b) Primitives in and-clauses can be omitted to reduce the raw filter size as long as one primitive remains. For or-clauses, however, all input expressions must be considered, to prohibit false-negatives. Finally, iv) the design space is explored to determine design points that are optimal, e.g., with respect to FPR and resource requirements. Section IV exemplifies the design flow for an IoT benchmark."
        },
        {
            "heading": "IV. RAW FILTER EVALUATION",
            "text": "In the following, we evaluate the most interesting design points for three different queries and present an example system that implements the best implementation for one of these queries."
        },
        {
            "heading": "A. Analysis of the Design Space",
            "text": "For our evaluations, we used three different queries operating on two different datasets, from the RiotBench. The queries QS0 & QS1 run on a SmartCity dataset, composed of different sensor measurements (e.g., temperature, humidity). The third Query QT uses a Taxi dataset, where each record corresponds to one Taxi trip (containing attributes like trip distance, fare amount). The queries are shown in Table VIII.\nFollowing the design flow from Section III-D, we extracted all primitives; i.e., five string matchers (each with the option to be implemented with B \u2208 {1, 2, N}) and five number\n2https://developer.twitter.com/en/docs/twitter-api\nrange checks. Additionally, the information which RFs could utilize information about the structure is extracted. All possible configurations are then generated and individually evaluated with respect to resource requirements (LUTs on the FPGA) and FPR over the complete data set. The tested design points are illustrated in Figure 3. Tables V to VII provide the found pareto-optima. For QS1 and QT, we can see that filtering for only 1-2 attributes already achieves a very low FPR, as our queries are more selective over certain attributes. Since all attribute filters here are connected by an and, all but one filter may be omitted, as can be seen for the configurations obtained. For IoT-Data it\u2019s quite common that some attributes highly correlate with each other. E.g., in the taxi dataset the attributes trip time in secs and fare amount are highly dependent on the attribute trip distance. Hence, it\u2019s sufficient to filter only one of these attributes. In other cases, we observed that value distributions of some attributes do not overlap with those of the other attributes. This can be seen for the \u201dlight\u201d attribute, where the light values are mostly > 1000, while the other attributes are mostly < 1000. Accordingly, it can be sufficient to only filter the value range without checking the attributes name. This can be seen for the second Pareto point in QS1 which already obtains a low FPR without searching for the search string \u201dlight\u201d.\nIf we look at the Pareto points independently of the underlying configurations, we notice that the FPRs and the LUTs cannot be mapped linearly to each other. Especially at the ends of the tables, strong deviations can be seen. For example, for QS1, a minimally higher FPR of 0.008 compared to 0.0 requires less than half the resources (103 instead of 223 LUTs). Accordingly, it may be worthwhile to allow a low FPR to save resources.\nTABLE VIII: RiotBench queries as used in the evalution.\nQuery Name Filter expression Selectivity (%)\nSmartCity 0 (QS0)\n(0.7 \u2264 \"temperature\" \u2264 35.1) AND (20.3 \u2264 \"humidity\" \u2264 69.1) AND (0 \u2264 \"light\" \u2264 5153) AND (83.36 \u2264 \"dust\" \u2264 3322.67) AND (12 \u2264 \"airquality_raw\" \u2264 49)\n63.9\nSmartCity 1 (QS1)\n(-12.5 \u2264 \"temperature\" \u2264 43.1) AND (10.7 \u2264 \"humidity\" \u2264 95.2) AND (1345 \u2264 \"light\" \u2264 26282) AND (186.61 \u2264 \"dust\" \u2264 5188.21) AND (17 \u2264 \"airquality_raw\" \u2264 363)\n5.4\nTaxi (QT) (140 \u2264 \"trip_time_in_secs\" \u2264 3155) AND (0.65 \u2264 \"tip_amount\" \u2264 38.55) AND (6.00 \u2264 \"fare_amount\" \u2264 201.00) AND (2.50 \u2264 \"tolls_amount\" \u2264 18.00) AND (1.37 \u2264 \"trip_distance\" \u2264 29.86) 5.7\nNetwork interface\nRF RF\nRF RF\nRF RF\nRF\nRaw filters\nDMA\nProgrammable Logic\nPCIe\nRAM\nCore Core\nCPU System\nFig. 4: Overview of the proposed architecture for filtering raw byte streams."
        },
        {
            "heading": "B. System Architecture",
            "text": "The RFs have been evaluated on a Xilinx ZC706 Zynq-7000 SoC. Figure 4 depicts the architecture of our system, based on [2], consisting of a tightly coupled processor system (PS) and programmable logic (PL). We built 7 parallel pipelined RFs, each processing one byte per cycle, leading to a theoretical bandwidth of 1.4 GB/s at a clock rate of 200 MHz.\nIn our experiment, 44 MB of inflated JSON data from the RiotBench was preloaded into the RAM and transferred to the RFs using DMA. The results, containing only the match signals, were again written back to the RAM using DMA. In the experiment a data rate of 1.33 GB/s could be achieved, which is sufficient to process incoming data from a 10 GBit/s network interface at line rate. Accordingly, our system would also be suitable for passing the ingress data from a network interface directly to the RFs. The filtered data can then be transferred with the DMA into the RAM, in order to process the data directly on the on-chip ARM CPU. Such a setup could be used, for example, as an IoT gateway that directly performs pre-processing of the received data. Alternatively, a SmartNIC can be implemented by forwarding the filtered data to a host CPU via PCIe. Thus, the RFs can significantly increase the achieved data rate or relieve the host CPU without a risk of performance degradation. Since the presented RFs require only a small amount of resources, even more RFs can be used to process multiple data streams in parallel. Furthermore, the programmable logic can be reconfigured, allowing the RFs to be replaced when a new query is to be executed."
        },
        {
            "heading": "V. CONCLUSION AND FUTURE WORK",
            "text": "Raw filters have the potential to relieve the CPU workload and create a potential speedup for CPU-bound stream processing applications. Even for I/O-bound applications, it may be possible to free up CPU cycles. Unlike CPU-based solutions, our versatile primitives allow us to filter a variety of different data sets. Moreover, the RFs can be configured\nin such a way that the best possible FPR is achieved for a given resource requirement.\nCurrently, the RFs are created manually by brute force searching for Pareto points. Since this is too time-consuming for an automatic generation of RFs, meta heuristics such as evolutionary algorithms can be used in the future. Instead of evaluating each design point for the complete dataset, we want to explore sampling methods that can potentially speed up the process without a large increase in the FPR. Furthermore, there are options to further optimize the presented filter primitives which need to be investigated. This can be done, for example, by omitting substrings in the string search, or by adjusting the bounds of value range filters, potentially allowing further resource savings without a large increase in false-positives."
        }
    ],
    "title": "Raw Filtering of JSON Data on FPGAs",
    "year": 2022
}