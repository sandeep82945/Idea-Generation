{
    "abstractText": "We present an implemented XML data model and a new, simplified query language for multi-level annotated corpora. The new query language involves automatic conversion of queries into the underlying, more complicated MMAXQL query language. It supports queries for sequential and hierarchical, but also associative (e.g. coreferential) relations. The simplified query language has been designed with non-expert users in mind.",
    "authors": [
        {
            "affiliations": [],
            "name": "Christoph M \u00fcller"
        }
    ],
    "id": "SP:b61d03f2d62fab4e9bda020ac63d0fc0823ee8ec",
    "references": [
        {
            "authors": [
                "Allen",
                "James"
            ],
            "title": "Time and time again",
            "year": 1991
        },
        {
            "authors": [
                "Bird",
                "Steven",
                "Peter Buneman",
                "Wang-Chiew Tan"
            ],
            "title": "Towards a query language for annotation graphs",
            "year": 2000
        },
        {
            "authors": [
                "Bird",
                "Steven",
                "Mark Liberman"
            ],
            "title": "A formal framework for linguistic annotation.Speech Communication",
            "year": 2001
        },
        {
            "authors": [
                "Carletta",
                "Jean",
                "Stefan Evert",
                "Ulrich Heid",
                "Jonathan Kilgour",
                "J. Robertson",
                "Holger"
            ],
            "title": "The NITE XML toolkit: flexible annotation for multi-modal language data",
            "venue": "Voormann",
            "year": 2003
        },
        {
            "authors": [
                "Cassidy",
                "Steve",
                "Jonathan Harrington"
            ],
            "title": "Multi-level annotation in the EMU speech database management system",
            "venue": "Speech Communication",
            "year": 2001
        },
        {
            "authors": [
                "M\u00fcller",
                "Christoph",
                "Michael Strube"
            ],
            "title": "Multi-level annotation in MMAX",
            "venue": "In Proceedings of the 4th SIGdial Workshop on Discourse and Dialogue,",
            "year": 2003
        }
    ],
    "sections": [
        {
            "text": "Proceedings of the ACL Interactive Poster and Demonstration Sessions, pages 109\u2013112, Ann Arbor, June 2005.c\u00a92005 Association for Computational Linguistics\nWe present an implemented XML data model and a\nnew, simplified query language for multi-level an-\nnotated corpora. The new query language involves\nautomatic conversion of queries into the underly-\ning, more complicated MMAXQL query language.\nIt supports queries for sequential and hierarchical,\nbut also associative (e.g. coreferential) relations.\nThe simplified query language has been designed\nwith non-expert users in mind."
        },
        {
            "heading": "1 Introduction",
            "text": "Growing interest in richly annotated corpora is a driving force for the development of annotation tools that can handle multiple levels of annotation. We find it crucial in order to make full use of the potential of multi-level annotation that individual annotation levels be treated asself-contained modules which are independent of other annotation levels. This independence should also include the storing of each level in a separate file. If these principles are observed, annotation data management (incl. level addition, removal and replacement, but also conversion into and from other formats) is greatly facilitated.\nThe way to keep individual annotation levels independent of each other is by defining each with direct reference to the underlying basedata, i.e. the text or transcribed speech. Both sequential and hierarchical (i.e. embedding or dominance) relations between markables on different levels are thus only expressedimplicitly, viz. by means of the relations of their basedata elements.\nWhile it has become common practice to use the stand-off mechanism to relate several annotation levels to one basedata file, it is also not uncommon to find this mechanism applied for relating markables to other markables (on a different or the same level) directly, expressing the relation between themexplicitly. We argue that this is unfavourable not only with respect to annotation data management (cf. above), but also with respect toquerying: Users should not be required to formulate queries in terms of structural properties of data representation that are irrelevant for their query. Instead, users should be allowed to relate markables from all levels in a fairly unrestricted and ad-hoc way. Since querying is thus considerably simplified, exploratory data analysis of annotated corpora is facilitated for all users, including non-experts.\nOur multi-level annotation tool MMAX21\n(Mu\u0308ller & Strube, 2003) uses implicit relations only. Its query language MMAXQL is rather complicated and not suitable for naive users. We present an alternative query method consisting of a simpler and more intuitive query language and a method to generate MMAXQL queries from the former. The new,simplifiedMMAXQL can express a wide range of queries in a concise way, including queries for associative relations representing e.g. coreference."
        },
        {
            "heading": "2 The Data Model",
            "text": "We propose a stand-off data model implemented in XML. The basedata is stored in a simple XML file\n1The current release version of MMAX2 can be downloaded at http://mmax.eml-research.de.\n109\n<?xml version=\"1.0\" encoding=\"US-ASCII\"?> <!DOCTYPE words SYSTEM \"words.dtd\"> <words>\n... <word id=\"word_1064\">My</word> <word id=\"word_1065\">,</word> <word id=\"word_1066\">uh</word> <word id=\"word_1067\">,</word> <word id=\"word_1068\">cousin</word> <word id=\"word_1069\">is</word> <word id=\"word_1070\">a</word> <word id=\"word_1071\">F</word> <word id=\"word_1072\">B</word> <word id=\"word_1073\">I</word> <word id=\"word_1074\">agent</word> <word id=\"word_1075\">down</word> <word id=\"word_1076\">in</word> <word id=\"word_1077\">Miami</word> <word id=\"word_1078\">.</word>\n... <word id=\"word_1085\">she</word> ... </words>\nFigure 1:basedata file (extract)\n<?xml version=\"1.0\" encoding=\"US-ASCII\"?> <!DOCTYPE markables SYSTEM \"markables.dtd\"> <markables xmlns=\"www.eml.org/NameSpaces/utterances\">\n... <markable id=\"markable_116\" span=\"word_1064..word_1078\"/>\n... </markables>\nwhich serves to identify individual tokens2 and associate an ID with each (Figure 1).\nIn addition, there is one XML file for each annotation level. Each level has a unique, descriptive name, e.g.utterances or pos , and contains annotations in the form of<markable > elements. In the most simple case, a markable only identifies a sequence (i.e.span) of basedata elements (Figure 2).\nNormally, however, a markable is also associated with arbitrarily many user-defined attribute-value pairs (Figure 3, Figure 4). Markables can also be discontinuous, likemarkable 954 in Figure 4.\nFor each level, admissible attributes and their values are defined in a separate annotation scheme file (not shown, cf. M\u0308uller & Strube (2003)). Freetext attributes can have any string value, while nominal attributes can have one of a (user-defined) closed set of possible values. The data model also supports associative relations between markables:Markable set relations associate arbitrarily many markables with each other in a transitive, undirected way. The coref class attribute in Figure 4 is an example of how such a relation can be used to represent a coreferential relation between markables (here: markable 954 andmarkable 963 , rest of set\n2Usually words, but smaller elements like morphological units or even characters are also possible.\ncoref_class=\"set_3\"/> ... </markables>\nFigure 4:ref exp level file (extract)\nnot shown). Markable pointerrelations associate with one markable (thesource) one or moretarget markables in an intransitive, directed fashion."
        },
        {
            "heading": "3 Simplified MMAXQL",
            "text": "Simplified MMAXQL is a variant of the MMAXQL query language. It offers a simpler and more concise way to formulate certain types of queries for multi-level annotated corpora. Queries are automatically converted into the underlying query language and then executed. A query in simplified MMAXQL consists of a sequence ofquery tokenswhich are combined by means ofrelation operators. Each query token queries exactly one basedata element (i.e. word) or one markable."
        },
        {
            "heading": "3.1 Query Tokens",
            "text": "Basedataelements can be queried by matching regular expressions. Each basedata query token consists of a regular expression in single quotes, which mustexactlymatch one basedata element. The query\n\u2019[Tt]he\u2019 matches all definite articles, but not e.g.ether or\nthere. For the latter two words to also match, wildcards have to be used:\n\u2019. * [Tt]he. * \u2019\nSequences of basedata elements can be queried by simply concatenating several space-separated3 okens. The query\n\u2019[Tt]he [A-Z].+\u2019\nwill match sequences consisting of a definite article and a word beginning with a capital letter.\nMarkables are the carriers of the actual annotation information. They can be queried by means of string matching and by means of attribute-value combinations. A markable query token has the form\nstring/conditions\nwhere string is an optional regular expression and conditions specifies which attribute(s) the markable should match. The most simple \u2019condition\u2019 is just the name of a markable level, which will match all markables on that level. If a regular expression is also supplied, the query will return only the matching markables. The query\n[Aa]n? \\s. * /ref exp 4 will return all markables from theref exp level beginning with the indefinite article.\nThe conditions part of a markable query token can indeed be much more complex. A main feature of simplified MMAXQL is that redundant parts of conditions canoptionally be left out, making queries very concise. For example, themarkable level namecan be left out if the name of the attribute accessed by the query is unique across all active markable levels. Thus, the query\n/!coref class=empty\ncan be used to query markables from theref exp level which have a non-empty value in the coref class attribute, granted that only one attribute of this name exists.5 The same applies to the names ofnominal attributesif the value specified in the query unambiguously points to this attribute. Thus, the query\n/pn\n3Using the fact thatmeets is the default relation operator, cf. Section 3.2.\n4The space character in the regular expression must be masked as\\s because otherwise it will be interpreted as a query token separator.\n5If this condition does not hold, attribute names can be disambiguated by prepending the markable level name.\ncan be used to query markables from thepos level which have the valuepn , granted that there is exactly one nominal attribute with the possible value pn . Several conditions can be combined into one query token. Thus, the query / {poss det,pron },!coref class=empty returns all markables from ther f exp level that are either possessive determiners or pronouns and that are part in some coreference set.6"
        },
        {
            "heading": "3.2 Relation Operators",
            "text": "The whole point of querying corpora with multilevel annotation is to relate markables from different levels to each other. The reference system with respect to which the relation between different markables is established is the sequence of basedata elements, which is the same for all markables on all levels. Since this bears some resemblance to differenteventsoccurring in severaltemporalrelations to each other, we (like also Heid et al. (2004), among others) adopt this as a metaphor for expressing the sequential and hierarchical relations between markables, and we use a set of relation operators that is inspired by (Allen, 1991). This set includes (among others) the operatorsbefore , meets (default), starts , during/in , contains/dom , equals , ends , and some inverse relations. The following examples give an idea of how individual query tokens can be combined by means of relation operators to form complex queries. The example uses the ICSI meeting corpus of spoken multiparty dialogue.7 This corpus contains, among others, asegment level with markables roughly corresponding to speaker turns, and ameta level containing markables representing e.g. pauses, emphases, or sounds like breathing or mike noise. These two levels and the basedata level can be combined to retrieve instances ofyou knowthat occur in segments spoken by female speakers8 which also contain a pause or an emphasis: \u2019[Yy]ou know\u2019 in (/participant={f. * } dom /{pause,emphasis})\n6The curly braces notation is used to specify several ORconnected values for a single attribute, while a commaoutside curly braces is used to AND-connect several conditions relating to different attributes.\n7Obtained from the LDC and converted into MMAX2 format, preserving all original information.\n8The first letter of theparticipant value encodes the speaker\u2019s gender.\nRelation operators forassociativerelations (i.e. markable set and markable pointer) arenextpeer , anypeer and nexttarget , anytarget , respectively. Assuming the sample data from Section 2, the query\n/ref_exp nextpeer:coref_class /ref_exp\nretrieves pairs of anaphors (right) and their direct antecedents (left). The query can be modified to /ref_exp nextpeer:coref_class (/ref_exp equals /pron)\nto retrieve only anaphoricpronounsand their direct antecedents.\nIf a query is too complex to be expressed as a single query token sequence,variablescan be used to store intermediate results of sub-queries. The following query retrieves pairs of utterances (incl. the referring expressions embedded into them) that are more than 30 tokens9 apart, and assigns the resulting 4-tuples to the variable$distant utts . (/utterances dom /ref_exp) before:31- (/utterances dom /ref_exp)\n-> $distant_utts\nThe next query accesses the second and last column in the temporary result (by means of the zero-based column index) and retrieves those pairs of anaphors and their direct antecedents that occur in utterances that are more than 30 tokens apart: $distant_utts.1 nextpeer:coref_class $distant_utts.3"
        },
        {
            "heading": "4 Related Work",
            "text": "In the EMU speech database system (Cassidy & Harrington, 2001) the hierarchical relation between levels has to be made explicit. Sequential and hierarchical relations can be queried like with simplified MMAXQL, with the difference that e.g. for sequential queries, the elements involved must come from the same level. Also, the result of a hierarchical query always only contains either the parent or child element. The EMU data model supports an association relation (similar to our markable pointer) which can be queried using a=> operator.\nAnnotation Graphs (Bird & Liberman, 2001) identify elements on various levels as arcs connecting two points on a time scale shared by all levels. Relations between elements are thus also represented implicitly. The model can also express a\n9A means to express distance in terms of markables is not yet available, cf. Section 5.\nbinary association relation. The associated Annotation Graph query language (Bird et al., 2000) is very explicit, which makes it powerful but at the same time possibly too demanding for naive users.\nThe NITE XML toolkit (Carletta et al., 2003) defines a data model that is close to our model, although it allows to express hierarchical relations explicitly. The model supports a labelled pointer relation which can express one-to-many associations. The associated query language NXT Search (Heid et al., 2004) is a powerful declarative language for querying diverse relations (incl. pointers), supporting quantification and constructs likeforall and exists ."
        },
        {
            "heading": "5 Future Work",
            "text": "We work on support for queries like \u2019pairs of referring expressions that are a certain number of referring expressions apart\u2019. We also want to include wild cards and proximity searches, and support for automatic markable creation from query results."
        },
        {
            "heading": "Acknowledgements",
            "text": "This work has been funded by the Klaus Tschira Foundation, Heidelberg, Germany."
        }
    ],
    "title": "A Flexible Stand-Off Data Model with Query Language for Multi-Level Annotation",
    "year": 2005
}