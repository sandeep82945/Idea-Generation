{
    "abstractText": "Let tw(G) denote the treewidth of graph G. Given a graph G and a positive integer k such that tw(G) \u2264 k +1, we are to decide if tw(G) \u2264 k. We give a certifying algorithm RTW (\"R\" for recursive) for this task: it returns one or more tree-decompositions of G of width \u2264 k if the answer is YES and a minimal contraction H of G such that tw(H) > k otherwise. Starting from a greedy upper bound on tw(G) and repeatedly improving the upper bound by this algorithm, we obtain tw(G) with certificates. RTW uses a heuristic variant of Tamaki\u2019s PID algorithm for treewidth (ESA2017), which we call HPID. Informally speaking, PID builds potential subtrees of tree-decompositions of width \u2264 k in a bottom up manner, until such a tree-decomposition is constructed or the set of potential subtrees is exhausted without success. HPID uses the same method of generating a new subtree from existing ones but with a different generation order which is not intended for exhaustion but for quick generation of a full tree-decomposition when possible. RTW, given G and k, interleaves the execution of HPID with recursive calls on G/e for edges e of G, where G/e denotes the graph obtained from G by contracting edge e. If we find that tw(G/e) > k, then we have tw(G) > k with the same certificate. If we find that tw(G/e) \u2264 k, we \"uncontract\" the bags of the certifying tree-decompositions of G/e into bags of G and feed them to HPID to help progress. If the question is not resolved after the recursive calls are made for all edges, we finish HPID in an exhaustive mode. If it turns out that tw(G) > k, then G is a certificate for tw(G\u2032) > k for every G\u2032 of which G is a contraction, because we have found tw(G/e) \u2264 k for every edge e of G. This final round of HPID guarantees the correctness of the algorithm, while its practical efficiency derives from our methods of \"uncontracting\" bags of tree-decompositions of G/e to useful bags of G, as well as of exploiting those bags in HPID. Experiments show that our algorithm drastically extends the scope of practically solvable instances. In particular, when applied to the 100 instances in the PACE 2017 bonus set, the number of instances solved by our implementation on a typical laptop, with the timeout of 100, 1000, and 10000 seconds per instance, are 72, 92, and 98 respectively, while these numbers are 11, 38, and 68 for Tamaki\u2019s PID solver and 65, 82, and 85 for his new solver (SEA 2022). 2012 ACM Subject Classification Theory of computation \u2192 Graph algorithms analysis",
    "authors": [
        {
            "affiliations": [],
            "name": "Hisao Tamaki"
        }
    ],
    "id": "SP:4b96b6081af7bbba9162fe0272b0a554d9440ae5",
    "references": [
        {
            "authors": [
                "Ernst Althaus",
                "Daniela Schnurbusch",
                "Julian W\u00fcschner",
                "Sarah Ziegler"
            ],
            "title": "On tamaki\u2019s algorithm to compute treewidths",
            "venue": "In 19th International Symposium on Experimental Algorithms (SEA 2021). Schloss Dagstuhl-Leibniz-Zentrum fu\u0308r Informatik,",
            "year": 2021
        },
        {
            "authors": [
                "Stefan Arnborg",
                "Derek G Corneil",
                "Andrzej Proskurowski"
            ],
            "title": "Complexity of finding embeddings in a k-tree",
            "venue": "SIAM Journal on Algebraic Discrete Methods,",
            "year": 1987
        },
        {
            "authors": [
                "Jean RS Blair",
                "Pinar Heggernes",
                "Jan Arne Telle"
            ],
            "title": "A practical algorithm for making filled graphs minimal",
            "venue": "Theoretical Computer Science,",
            "year": 2001
        },
        {
            "authors": [
                "Hans L Bodlaender"
            ],
            "title": "A linear-time algorithm for finding tree-decompositions of small treewidth",
            "venue": "SIAM Journal on computing,",
            "year": 1996
        },
        {
            "authors": [
                "Hans L Bodlaender",
                "Fedor V Fomin",
                "Arie MCA Koster",
                "Dieter Kratsch",
                "Dimitrios M Thilikos"
            ],
            "title": "On exact algorithms for treewidth",
            "venue": "Algorithms\u2013ESA",
            "year": 2006
        },
        {
            "authors": [
                "Hans L Bodlaender",
                "Arie MCA Koster"
            ],
            "title": "Safe separators for treewidth",
            "venue": "Discrete Mathematics,",
            "year": 2006
        },
        {
            "authors": [
                "Hans L Bodlaender",
                "Arie MCA Koster"
            ],
            "title": "Treewidth computations i. upper bounds",
            "venue": "Information and Computation,",
            "year": 2010
        },
        {
            "authors": [
                "Hans L Bodlaender",
                "Arie MCA Koster"
            ],
            "title": "Treewidth computations ii. lower bounds",
            "venue": "Information and Computation,",
            "year": 2011
        },
        {
            "authors": [
                "Vincent Bouchitt\u00e9",
                "Ioan Todinca"
            ],
            "title": "Treewidth and minimum fill-in: Grouping the minimal separators",
            "venue": "SIAM Journal on Computing,",
            "year": 2001
        },
        {
            "authors": [
                "Holger Dell",
                "Christian Komusiewicz",
                "Nimrod Talmon",
                "Mathias Weller"
            ],
            "title": "The pace 2017 parameterized algorithms and computational experiments challenge: The second iteration",
            "venue": "In 12th International Symposium on Parameterized and Exact Computation (IPEC 2017). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik,",
            "year": 2018
        },
        {
            "authors": [
                "Fedor V Fomin",
                "Yngve Villanger"
            ],
            "title": "Treewidth computation and extremal combinatorics",
            "year": 2012
        },
        {
            "authors": [
                "Pinar Heggernes"
            ],
            "title": "Minimal triangulations of graphs: A survey",
            "venue": "Discrete Mathematics,",
            "year": 2006
        },
        {
            "authors": [
                "Neil Robertson",
                "Paul D. Seymour"
            ],
            "title": "Graph minors. ii. algorithmic aspects of tree-width",
            "venue": "Journal of algorithms,",
            "year": 1986
        },
        {
            "authors": [
                "Hisao Tamaki"
            ],
            "title": "Computing treewidth via exact and heuristic lists of minimal separators",
            "venue": "In International Symposium on Experimental Algorithms,",
            "year": 2019
        },
        {
            "authors": [
                "Hisao Tamaki"
            ],
            "title": "A heuristic use of dynamic programming to upperbound treewidth",
            "venue": "arXiv preprint arXiv:1909.07647,",
            "year": 2019
        },
        {
            "authors": [
                "Hisao Tamaki"
            ],
            "title": "Positive-instance driven dynamic programming for treewidth",
            "venue": "Journal of Combinatorial Optimization,",
            "year": 2019
        },
        {
            "authors": [
                "Hisao Tamaki"
            ],
            "title": "A heuristic for listing almost-clique minimal separators of a graph",
            "venue": "arXiv preprint arXiv:2108.07551,",
            "year": 2021
        },
        {
            "authors": [
                "Hisao Tamaki"
            ],
            "title": "Heuristic Computation of Exact Treewidth",
            "venue": "editors, 20th International Symposium on Experimental Algorithms (SEA 2022),",
            "year": 2022
        }
    ],
    "sections": [
        {
            "text": "RTW uses a heuristic variant of Tamaki\u2019s PID algorithm for treewidth (ESA2017), which we call HPID. Informally speaking, PID builds potential subtrees of tree-decompositions of width \u2264 k in a bottom up manner, until such a tree-decomposition is constructed or the set of potential subtrees is exhausted without success. HPID uses the same method of generating a new subtree from existing ones but with a different generation order which is not intended for exhaustion but for quick generation of a full tree-decomposition when possible. RTW, given G and k, interleaves the execution of HPID with recursive calls on G/e for edges e of G, where G/e denotes the graph obtained from G by contracting edge e. If we find that tw(G/e) > k, then we have tw(G) > k with the same certificate. If we find that tw(G/e) \u2264 k, we \"uncontract\" the bags of the certifying tree-decompositions of G/e into bags of G and feed them to HPID to help progress. If the question is not resolved after the recursive calls are made for all edges, we finish HPID in an exhaustive mode. If it turns out that tw(G) > k, then G is a certificate for tw(G\u2032) > k for every G\u2032 of which G is a contraction, because we have found tw(G/e) \u2264 k for every edge e of G. This final round of HPID guarantees the correctness of the algorithm, while its practical efficiency derives from our methods of \"uncontracting\" bags of tree-decompositions of G/e to useful bags of G, as well as of exploiting those bags in HPID.\nExperiments show that our algorithm drastically extends the scope of practically solvable instances. In particular, when applied to the 100 instances in the PACE 2017 bonus set, the number of instances solved by our implementation on a typical laptop, with the timeout of 100, 1000, and 10000 seconds per instance, are 72, 92, and 98 respectively, while these numbers are 11, 38, and 68 for Tamaki\u2019s PID solver and 65, 82, and 85 for his new solver (SEA 2022).\n2012 ACM Subject Classification Theory of computation \u2192 Graph algorithms analysis\nKeywords and phrases graph algorithm, treewidth, exact computation, BT dynamic programming, contraction, certifying algorithms\nDigital Object Identifier 10.4230/LIPIcs.CVIT.2016.23\n1 Introduction\nTreewidth is a graph parameter introduced and extensively studied in the graph minor theory [14]. A tree-decomposition of graph G is a tree with each node labeled by a vertex set of G, called a bag, satisfying certain conditions (see Section 2) so that those bags form a tree-structured system of vertex-separators of G. The width w(T ) of a tree-decomposition T is the maximum cardinality of a bag in T minus one and the treewidth tw(G) of graph G is the smallest k such that there is a tree-decomposition of G of width k.\nThe impact of the notion of treewidth on the design of combinatorial algorithms is profound: there are a huge number of NP-hard graph problems that are known to be tractable when parameterized by treewidth: they admit an algorithm with running time f(k)nO(1), where n is the number of vertices, k is the treewidth of the given graph, and f is some typically exponential function (see [10], for example). Those algorithms typically\n\u00a9 Hisao Tamaki; licensed under Creative Commons License CC-BY 4.0\n42nd Conference on Very Important Topics (CVIT 2016). Editors: John Q. Open and Joan R. Access; Article No. 23; pp. 23:1\u201323:17\nLeibniz International Proceedings in Informatics Schloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\nar X\niv :2\n30 7.\n01 31\n8v 1\n[ cs\n.D S]\n3 J\nul 2\n02 3\nperform dynamic programming based on the system of separators provided by the treedecomposition. To make such algorithms practically useful, we need to compute the treewidth, or a good approximation of the treewidth, together with an associated tree-decomposition.\nComputing the treewidth tw(G) of a given graph G is NP-complete [2], but is fixedparameter tractable [14, 4]. In particular, the algorithm due to Bodlaender [4] runs in time linear in the graph size with a factor of 2O(tw(G)3). Unfortunately, this algorithm does not seem to run efficiently in practice.\nIn more practical approaches to treewidth computation, triangulations of graphs play an important role. A triangulation of graph G is a chordal graph H with V (G) = V (H) and E(G) \u2286 E(H). For every tree-decomposition T of G, filling every bag of T into a clique gives a triangulation of G. Conversely, for every triangulation H of G, there is a tree-decomposition of G in which every bag is a maximal clique of H. Through this characterization of treedecompositions in terms of triangulations, we can enumerate all relevant tree-decompositions by going through the total orderings on the vertex set, as each total ordering defines a triangulation for which the ordering is a perfect elimination order (see [7], for example). Practical algorithms in the early stage of treewidth research performed a branch-and-bound search over these total orderings [7]. Dynamic programming on this search space results in a 2nnO(1) time algorithms [5], which works well in practice for graphs with a small number of vertices. It should also be noted that classical upper bound algorithms, such as min-deg or min-fill, which heuristically choose a single vertex ordering defining a tree-decomposition, are fast and often give a good approximation of the treewidth in a practical sense [7].\nAnother important link between chordal graphs and treewidth computation was established by Bouchitt\u00e9 and Todinca [9]. They introduced the notion of potential maximal cliques (PMCs, see below in \"Our approach\" paragraph for a definition) and gave an efficient dynamic programming algorithm working on PMCs (BT dynamic programming) to find a minimal triangulation of the given graph that corresponds to an optimal tree-decomposition. They showed that their algorithm runs in polynomial time for many special classes of graphs. BT dynamic programming is also used in an exponential time algorithm for treewidth that runs in time O(1.7549n) [12].\nBT dynamic programming had been considered mostly of theoretical interest until 2017, when Tamaki presented its positive-instance driven (PID) variant, which runs fast in practice and significantly outperforms previously implemented treewidth algorithms [18]. Further efforts on treewidth computation based on or around his approach have been made since then, with some incremental successes [17, 16, 19, 1].\nIn his most recent work [20], Tamaki introduced another approach to treewidth computation, based on the use of contractions to compute tight lower bounds on the treewidth. For edge e of graph G, the contraction of G by e, denoted by G/e, is a graph obtained from G by replacing e by a new single vertex ve and let ve be adjacent to all neighbors of the ends of e in V (G) \\ e. A graph H is a contraction of G if H is obtained from G by zero ore more successive contractions by edges. It is well-known and easy to see that tw(H) \u2264 tw(G) for every contraction H of G. This fact has been used to quickly compute reasonably good lower bounds on the treewidth of a graph, typically to be used in branch-and-bound algorithms mentioned above [7, 8]. Tamaki [20] gave a heuristic method of successively improving contraction based lower bounds which, together with a separate heuristic method for upper bounds, quite often succeeds in computing the exact treewidth of instances that are hard to solve for previously published solvers."
        },
        {
            "heading": "Our approach",
            "text": "Our approach is based on the observation that contractions are useful not only for computing lower bounds but also for computing upper bounds. Suppose we have a tree-decomposition T of G/e of width k for some edge e = {u, v} of k. Let ve be the vertex to which e contracts. Replacing each bag X of T by X \u2032, where X \u2032 = X \\ {ve} \u222a {u, v} if ve \u2208 X and X \u2032 = X otherwise, we obtain a tree-decomposition T \u2032 of G of width \u2264 k + 1, which we call the uncontraction of T . In a fortunate case where every bag X of T with ve \u2208 X has |X| \u2264 k, the width of T \u2032 is k. To increase the chance of having such fortunate cases, we deal with a set of tree-decompositions rather than a single tree-decomposition. We represent such a set of tree-decompositions by a set of potential maximal cliques as follows.\nA vertex set of G is a potential maximal clique (PMC for short) if it is a maximal clique of some minimal triangulation of G. Let \u03a0(G) denote the set of all PMCs of G. For each \u03a0 \u2286 \u03a0(G), let T\u03a0(G) denote the set of all tree-decompositions of G whose bags all belong to \u03a0. Let tw\u03a0(G) denote the smallest k such that there is a tree-decomposition in T\u03a0(G) of width k; we set tw\u03a0(G) = \u221e if T\u03a0(G) = \u2205. Bouchitt\u00e9 and Todinca [9] showed that T\u03a0(G)(G) contains a tree-decomposition of width tw(G) and developed a dynamic programming algorithm (BT dynamic programming) to find such a tree-decomposition. Indeed, as Tamaki [17] noted, BT dynamic programming can be used for arbitrary \u03a0 \u2286 \u03a0(G) to compute tw\u03a0(G) in time linear in |\u03a0| and polynomial in |V (G)|.\nA set of PMCs is a particularly effective representation of a set of tree-decompositions for our purposes, because BT dynamic programming can be used to work on \u03a0 \u2286 \u03a0(G) and find a tree-decomposition in T\u03a0(G) that minimizes a variety of width measures based on bag weights. In our situation, suppose we have \u03a0 \u2286 \u03a0(G/e) such that tw\u03a0(G/e) = k. Using appropriate bag weights, we can use BT dynamic programming to decide if T\u03a0(G/e) contains T such that the uncontraction T \u2032 of T has width k and find one if it exists.\nThese observation suggests a recursive algorithm for improving an upper bound on treewidth. Given graph G and k such that tw(G) \u2264 k + 1, the task is to decide if tw(G) \u2264 k. Our algorithm certifies the YES answer by \u03a0 \u2286 \u03a0(G) with tw\u03a0(G) \u2264 k. It uses heuristic methods to find such \u03a0 and, when this goal is hard to achieve, recursively solve the question if tw(G/e) \u2264 k for edge e of G. Unless tw(G/e) = k + 1 and hence tw(G) = k + 1, the recursive call returns \u03a0 \u2286 \u03a0(G/e) such that tw\u03a0(G/e) \u2264 k. We use the method mentioned above to look for T \u2208 T\u03a0(G/r) whose uncontraction has width \u2264 k. If we are successful, we are done for G. Even when this is not the case, the uncontractions of tree-decompositions in T\u03a0(G/e) may be useful for our heuristic upper bound method in the following manner.\nIn [17], Tamaki proposed a local search algorithm for treewidth in which a solution is a set of PMCs rather than an individual tree-decomposition and introduced several methods of expanding \u03a0 \u2286 \u03a0(G) into \u03a0\u2032 \u2283 \u03a0 in hope of having tw\u03a0\u2032(G) < tw\u03a0(G). His method compares favourably with existing heuristic algorithms but, like typical local search methods, is prone to local optima. To let the search escape from a local optimum, we would like to inject \"good\" PMCs to the current set \u03a0. It appears that tree-decompositions in T\u03a0\u2032(G/e) such that tw\u03a0\u2032(G/e) \u2264 k, where k = tw\u03a0(G)\u2212 1, are reasonable sources of such good PMCs: we uncontract T \u2208 T\u03a0\u2032(G/e) into a tree-decomposition T \u2032 of G and extract PMCs of G from T \u2032. Each such PMC appears in a tree-decomposition of width \u2264 k + 1 and may appear in a tree-decomposition of width \u2264 k. It is also important that \u03a0\u2032 is obtained, in a loose sense, independently of \u03a0 and not under the influence of the local optimum around which \u03a0 stays.\nOur algorithm for deciding if tw(G) \u2264 k interleaves the execution of a local search algorithm with recursive calls on G/e for edges e of G and injects PMCs obtained from the results of the recursive calls. This process ends in either of the following three ways.\nCVIT 2016\n1. The local search succeeds in finding \u03a0 with tw\u03a0(G) \u2264 k. 2. A recursive call on G/e finds that tw(G/e) = k + 1: we conclude that tw(G) = k + 1 on\nthe spot. 3. Recursive calls G/e have been tried for all edges e and it is still unknown if tw(G) \u2264 k.\nWe invoke a conventional exact algorithm for treewidth to settle the question. Note that, when the algorithm concludes that tw(G) = k + 1, there must be a contraction H of G somewhere down in the recursion path from G such that Case 3 applies and the exact computation shows that tw(H) = k + 1. In this case, H is a minimal contraction of G that certifies tw(G) = k + 1, as the recursive calls further down from H have shown tw(H/e) \u2264 k for every edge e of H.\nAs the experiments in Section 11 show, this approach drastically extends the scope of instances for which the exact treewidth can be computed in practice."
        },
        {
            "heading": "Organization",
            "text": "To quickly grasp the main ideas and contributions of this paper, it is suggested to read the following sections first: Section 3 \u2013 Main algorithm, Section 6 \u2013 Uncontracting PMCs, Section 7 \u2013 Contracting PMCs, and Section 11 \u2013 Experiments (about 9 pages in total including the introduction), together with some parts of the preliminaries section as needed. Section 4 describes some details of the local search algorithm we use, namely heuristic PID. Sections 8, 9, and 10 describe additional techniques for speeding up the main algorithm. Sections 12 offers some concluding remarks.\nThe source code of the implementation of our algorithm used in the experiments is available at https://github.com/twalgor/RTW.\n2 Preliminaries"
        },
        {
            "heading": "Graphs and treewidth",
            "text": "In this paper, all graphs are simple, that is, without self loops or parallel edges. Let G be a graph. We denote by V (G) the vertex set of G and by E(G) the edge set of G. As G is simple, each edge of G is a subset of V (G) with exactly two members that are adjacent to each other in G. The complete graph on V , denoted by K(V ), is a graph with vertex set V in which every vertex is adjacent to all other vertices. The subgraph of G induced by U \u2286 V (G) is denoted by G[U ]. We sometimes use an abbreviation G \\ U to stand for G[V (G) \\ U ]. A vertex set C \u2286 V (G) is a clique of G if G[C] is a complete graph. For each v \u2208 V (G), NG(v) denotes the set of neighbors of v in G: NG(v) = {u \u2208 V (G) | {u, v} \u2208 E(G)}. For U \u2286 V (G), the open neighborhood of U in G, denoted by NG(U), is the set of vertices adjacent to some vertex in U but not belonging to U itself: NG(U) = ( \u22c3 v\u2208U NG(v)) \\ U .\nWe say that vertex set C \u2286 V (G) is connected in G if, for every u, v \u2208 C, there is a path in G[C] between u and v. It is a connected component or simply a component of G if it is connected and is inclusion-wise maximal subject to this condition. We denote by C(G) the set of all components of G. When the graph G is clear from the context, we denote C(G[U ]) by C(U). A vertex set S \u2286 V (G) is a separator of G if G \\ S has more than one component. A graph is a cycle if it is connected and every vertex is adjacent to exactly two vertices. A graph is a forest if it does not have a cycle as a subgraph. A forest is a tree if it is connected.\nA tree-decomposition of G is a pair (T,X ) where T is a tree and X is a family {Xi}i\u2208V (T ) of vertex sets of G, indexed by the nodes of T , such that the following three conditions are satisfied. We call each Xi the bag at node i.\n1. \u22c3\ni\u2208V (T ) Xi = V (G). 2. For each edge {u, v} \u2208 E(G), there is some i \u2208 V (T ) such that u, v \u2208 Xi. 3. For each v \u2208 V (G), the set of nodes Iv = {i \u2208 V (T ) | v \u2208 Xi} \u2286 V (T ) is connected in T . The width of this tree-decomposition is maxi\u2208V (T ) |Xi| \u2212 1. The treewidth of G, denoted by tw(G) is the smallest k such that there is a tree-decomposition of G of width k.\nFor each pair (i, j) of adjacent nodes of a tree-decomposition (T,X ) of G, let T (i, j) denote the subtree of T consisting of nodes of T reachable from i without passing j and let V (i, j) = \u22c3 k\u2208V (T (i,h)) Xk. Then, it is well-known and straightforward to show that Xi\u2229Xj = V (i, j)\u2229V (j, i) and there are no edges between V (i, j)\\V (j, i) and V (j, i)\\V (i, j); Xi \u2229Xj is a separator of G unless V (i, j) \u2286 V (j, i) or V (j, i) \u2286 V (j, i). We say that T uses separator S if there is an adjacent pair (i, j) such that S = Xi\u2229Xj . In this paper, we assume G is connected whenever we consider a tree-decomposition of G.\nIn this paper, most tree-decompositions are such that Xi = Xj only if i = j. Because of this, we use a convention to view a tree-decomposition of G as a tree T whose nodes are bags (vertex sets) of G.\nTriangulations, minimal separators, and Potential maximal cliques\nLet G be a graph and S a separator of G. For distinct vertices a, b \u2208 V (G), S is an a-b separator if there is no path between a and b in G \\ S; it is a minimal a-b separator if it is an a-b separator and no proper subset of S is an a-b separator. A separator is a minimal separator if it is a minimal a-b separator for some a, b \u2208 V (G).\nGraph H is chordal if every induced cycle of H has exactly three vertices. H is a triangulation of graph G if it is chordal, V (G) = V (H), and E(G) \u2286 E(H). A triangulation H of G is minimal if it there is no triangulation H \u2032 of G such that E(H \u2032) is a proper subset of E(H). It is known (see [13] for example) that if H is a minimal triangulation of G then every minimal separator of H is a minimal separator of G. In fact, the set of minimal separators of H is a maximal set of pairwise non-crossing minimal separators of G, where two separators S and R cross each other if at least two components of G \\ S intersects R.\nTriangulations and tree-decompositions are closely related. For a tree-decomposition T of G, let fill(G, T ) denote the graph obtained from G by filling every bag of T into a clique. Then, it is straightforward to see that fill(G, T ) is a triangulation of G. Conversely, for each chordal graph H, consider a tree on the set K of all maximal cliques of H such that if X, Y \u2208 K are adjacent to each other then X \u2229 Y is a minimal separator of H. Such a tree is called a clique tree of H. It is straightforward to verify that a clique tree T of a triangulation H of G is a tree-decomposition of G and that fill(G, T ) = H.\nWe call a tree-decomposition T of G minimal if it is a clique tree of a minimal triangulation of G. It is clear that there is a minimal tree-decomposition of G of width tw(G), since for every tree-decomposition T of G, there is a minimal triangulation H of G that is a subgraph of fill(G, T ) and every clique tree T \u2032 of H has w(T \u2032) \u2264 w(T ).\nA vertex set X \u2286 V (G) is a potential maximal clique, PMC for short, of G, if X is a maximal clique in some minimal triangulation of G. We denote by \u03a0(G) the set of all potential maximal cliques of G. By definition, every bag of a minimal tree-decomposition of G belongs to \u03a0(G)."
        },
        {
            "heading": "Bouchitt\u00e9-Todinca dynamic programming",
            "text": "For each \u03a0 \u2286 \u03a0(G), say that \u03a0 admits a tree-decomposition T of G if every bag of T belongs to \u03a0. Let T\u03a0(G) denote the set of all tree-decompositions of G that \u03a0 admits\nCVIT 2016\nand let tw\u03a0(G) denote the smallest k such that there is T \u2208 T\u03a0(G) of width k; we set tw\u03a0(G) =\u221e if T\u03a0(G) = \u2205. The treewidth algorithm of Bouchitt\u00e9 and Todinca [9] is based on the observation that tw(G) = tw\u03a0(G)(G). Given G, their algorithm first constructs \u03a0(G) and then search through T\u03a0(G)(G) by dynamic programming (BT dynamic programming) to find T of width tw\u03a0(G)(G). As observed in [17], BT dynamic programming can be used to compute tw\u03a0(G) for an arbitrary subset \u03a0 of \u03a0(G) to produce an upper bound on tw(G). As we extensively use this idea, we describe how it works here.\nFix \u03a0 \u2286 \u03a0(G) such that T\u03a0(G) is non-empty. To formulate the recurrences in BT dynamic programming, we need some definitions. A vertex set B of G is a block if B is connected and either NG(B) is a minimal separator or is empty. As we are assuming that G is connected, B = V (G) in the latter case. A partial tree-decomposition of a block B in G is a tree-decomposition of G[B \u222a NG(B)] that has a bag containing NG(B), called the root bag of this partial tree-decomposition. Note that a partial tree-decomposition of block V (G) is a tree-decomposition of G. For graph G and block B, let P\u03a0(B, G) denote the set of all partial tree-decompositions of B in G all of whose bags belong to \u03a0 and, when this set is non-empty, let tw\u03a0(B, G) denote the smallest k such that there is T \u2208 P\u03a0(B, G) with w(T ) = k; if P\u03a0(B, G) is empty we set tw\u03a0(B, G) =\u221e.\nA PMC X of G is a cap of block B if NG(B) \u2286 X and X \u2286 B \u222aNG(B). Note that a cap of B is a potential root bag of a partial tree-decomposition of B. For each block B, let B\u03a0(B) denote the set of all caps of B belonging to \u03a0. Recall that, for each vertex set U \u2286 V (G), C(U) denotes the set of components of G[U ]. The following recurrence holds.\ntw\u03a0(G, B) = minX\u2208B\u03a0(B) max{|X| \u2212 1, maxC\u2208C(B\\X) tw\u03a0(G, C)}} (1)\nBT dynamic programming evaluates this recurrence for blocks in the increasing order of cardinality and obtains tw\u03a0(G) = tw\u03a0(G, V (G)). Tracing back the recurrences, we obtain a tree-decomposition T \u2208 T\u03a0(G) with w(T ) = tw\u03a0(G).\nTamaki\u2019s PID algorithm [18], unlike the original algorithm of Bouchitt\u00e9 and Todinca [9], does not construct \u03a0(G) before applying dynamic programming. It rather uses the above recurrence to generate relevant blocks and PMCs. More precisely, PID is for the decision problem whether tw(G) \u2264 k for given G and k and it generates all blocks C with tw(C, G) \u2264 k using the recurrence in a bottom up manner. We have tw(G) \u2264 k if and only if V (G) is among those generated blocks."
        },
        {
            "heading": "Contractors and contractions",
            "text": "To extend the notation G/e of a contraction by an edge to a contraction by multiple edges, we define contractors. A contractor \u03b3 of G is a partition of V (G) into connected sets. For contractor \u03b3 of G, the contraction of G by \u03b3, denoted by G/\u03b3, is the graph obtained from G by contracting each part of \u03b3 to a single vertex, with the adjacency inherited from G. For notational convenience, we also view a contractor \u03b3 as a mapping from V (G) to {1, 2, . . . , m}, the index set of the parts of the partition \u03b3. In this view, the vertex set of G/\u03b3 is {1, 2, . . . , m} and \u03b3(v) for each v \u2208 V (G) is the vertex of G/\u03b3 into which v is contracted. For each w \u2208 V (G/\u03b3), \u03b3\u22121(w) is the part of the partition \u03b3 that contracts to w. For U \u2286 V (G/\u03b3), we define \u03b3\u22121(U) = \u22c3 w\u2208U \u03b3 \u22121(w).\n3 Main algorithm\nThe pseudo code in Algorithm 1 shows the main iteration of our treewidth algorithm. It starts from a greedy upper bound and repeatedly improves the upper bound by algorithm RTW. The call RTW (G, k, \u03a0), where \u03a0 \u2286 \u03a0(G) and tw\u03a0(G) \u2264 k + 1, decides if tw(G) \u2264 k. If tw(G) \u2264 k, it returns YES with certificate \u03a0\u2032 \u2286 \u03a0(G) such that tw\u03a0\u2032(G) \u2264 k; otherwise it returns NO with certificate H, a minimal contraction of G such that tw(H) = k + 1.\nAlgorithm 1 Main iteration for computing tw(G)\nEnsure: compute tw(G) for given G 1: T \u2190 a minimal tree-decomposition of G obtained by a greedy algorithm 2: \u03a0\u2190 the set of bags of T 3: k \u2190 w(T ) 4: while true do 5: call RTW (G, k \u2212 1, \u03a0) 6: if the call returns NO with certificate H then 7: stop: tw(G) equals k with tw(G) \u2264 k certified by \u03a0 and tw(G) \u2265 k certified by H 8: else 9: k \u2190 k \u2212 1 10: \u03a0\u2190 the certificate of the YES answer 11: end if 12: end while\nThe pseudo code in Algorithm 2 describes RTW in its basic form. We sketch here the functions of subalgorithms used in this algorithm. More details can be found in subsequent sections.\nOur method of local search in the space of sets of PMCs is a heuristic variant, which we call HPID, of the PID algorithm due to Tamaki [18]. PID constructs partial tree-decompositions of width \u2264 k using the recurrence of BT dynamic programming in a bottom up manner to exhaustively generate all partial tree-decompositions of width \u2264 k, so that we have a tree-decomposition of width \u2264 k if and only if tw(G) \u2264 k. HPID uses the same recurrence to generate partial tree-decompositions of width \u2264 k but the aim is to quickly generate a tree-decomposition of G of width \u2264 k and the generation order it employs does not guarantee exhaustive generation. The state of HPID computation is characterized by the set \u03a0 of root bags of the generated partial tree-decompositions. Recall that the bags of the set of partial tree-decompositions generated by the BT recurrence are PMCs, so \u03a0 \u2286 \u03a0(G). Using BT dynamic programming, we can reconstruct the set of partial tree-decompositions from \u03a0, if needed, in time linear in |\u03a0| and polynomial in |V (G)|. Thus, we may view HPID as performing a local search in the space of sets of PMCs. This view facilitates communications between HPID and external upper bound heuristics. Those communications are done through the following operations.\nWe consider each invocation of HPID as an entity having a state. Let s denote such an invocation instance of HPID for G and k. Let \u03a0(s) denote the set of PMCs that are root bag of the partial tree-decompositions generated so far by s. The following operations are available. s. width() returns tw\u03a0(s)(G). s. usefulP MCs() returns the set of PMCs that are the root bags of the partial tree-\ndecompositions of width \u2264 s.width() generated so far by s.\nCVIT 2016\nAlgorithm 2 Procedure RT W (G, k, \u03a0)\nRequire: \u03a0 \u2286 \u03a0(G) and tw\u03a0(G) \u2264 k + 1 Ensure: returns YES with \u03a0 \u2286 \u03a0(G) such that tw\u03a0(G) \u2264 k if tw(G) \u2264 k; NO with a\nminimal contraction H of G such that tw(H) = k + 1 otherwise 1: create an HPID instance s for G and k 2: s. importPMCs(\u03a0) 3: if s. width() \u2264 k then 4: return YES with s. usefulPMCs() 5: end if 6: order the edges of G appropriately as e1, e2, . . . em. 7: for i = 1, . . . , m do 8: \u0398\u2190 contractPMCs(s. usefulPMCs(), G, ei) 9: call RTW (G/ei, k, \u0398)\n10: if the call returns NO with certificate H then 11: return NO with certificate H 12: else 13: \u03a8\u2190 the certificate for the YES answer 14: \u03a8\u2032 \u2190 uncontractPMCs(\u03a8, G, e) 15: s. importPMCs(\u03a8\u2032) 16: s. improve(UNIT_BUDGET \u00d7 i) 17: if s. width() \u2264 k then 18: return YES with s. usefulPMCs() 19: end if 20: end if 21: end for 22: s. finish() 23: if s. width() \u2264 k then 24: return YES with s. usefulPMCs() 25: else 26: return NO with certificate G 27: end if\ns. importP MCs(\u03a0) updates \u03a0(s) to \u03a0(s) \u222a \u03a0 and updates the set of partial treedecompositions by BT dynamic programming.\ns. improve(budget) generates more partial tree-decompositions under the specified budget, in terms of the number of search step spent for the generation.\ns. finish() exhaustively generates remaining partial decompositions of width \u2264 k, thereby deciding if tw(G) \u2264 k.\nSee Section 4 for details of these procedures. We use two additional procedures. uncontractP MCs(\u03a0, G, e) , where e is an edge of G and \u03a0 \u2286 \u03a0(G/e), returns \u03a0\u2032 \u2286 \u03a0(G) such that tw\u03a0\u2032(G) \u2264 tw\u03a0(G/e) + 1 and possibly tw\u03a0\u2032(G) \u2264 tw\u03a0(G/e) contractP MCs(\u03a0, G, e) , where e is an edge of G and \u03a0 \u2286 \u03a0(G), returns \u03a0\u2032 \u2286 \u03a0(G/e) such that tw\u03a0\u2032(G/e) \u2264 tw\u03a0(G) and possibly tw\u03a0\u2032(G/e) \u2264 tw\u03a0(G)\u2212 1 See Sections 6 and 7 for details of these procedures. Given these procedures, RTW works as follows. It receives G, k, and \u03a0 such that tw\u03a0(G) \u2264 k + 1 and creates an HPID instance s for G and k and let it import \u03a0. If it turns out that tw\u03a0(G) \u2264 k at this point, then RTW returns YES with s. usefulPMCs(), a subset \u03a0\u2032 of \u03a0 such that tw\u03a0\u2032(G) \u2264 k, as the certificate. Otherwise, it orders the edges of G in such a way to increase the chance of having an edge e width tw(G/e) = k + 1 early in the list if any. Then it iterates over those edges. To process ei it makes a recursive call RTW (G/ei, k, \u0398) where \u0398 \u2286 \u03a0(G/e) is obtained by \"contracting\" \u03a0. If the result is negative, the answer of RTW (G, k, \u03a0) is also negative with the same certificate. If the result is positive with \u03a8 \u2286 \u03a0(G/ei), then \u03a8 is \"uncontracted\" to \u03a8\u2032 \u2286 \u03a0(G), which is imported to s. Then it lets s advance its PID state under a budget proportional to i. If s succeeds in finding tree-decompositions of G of width k, then RTW returns YES with the certificate constructed by s. Otherwise, it proceeds to the next edge. When it has tried all edges without resolving the question, it lets s finish the exhaustive generation of partial tree-decompositions to answer the question. If it turns out that tw(G) \u2264 k, it returns YES with the certificate provided by s. Otherwise it returns NO with the certificate being G itself.\nThe correctness of this algorithm can be proved by straightforward induction and does not depend on the procedures expand, contractPMCs, or uncontractPMCs except that the procedure contractPMCs(\u03a0, G, e) must return \u0398 such that tw\u0398(G/e) \u2264 tw\u03a0(G) as promised. On the other hand, practical efficiency of this algorithm heavily depends on the performances of these procedures. If they collectively work really well, then we expect that the for loop would exit after trying only a few edges, assuming tw(G) \u2264 k, and s. finish() would be called only if tw(G) = k + 1 and tw(G/e) \u2264 k for every edge e. On the other extreme of perfect incapability of these procedures, the for loop would always run to the end and s. finish() would be called in every call of RTW (G, k, \u03a0), making the recursion totally meaningless. Our efforts are devoted to developing effective methods for these procedures.\n4 Heuristic PID\nIn this section, we give some details of the HPID algorithm. In particular, we describe in some details how the procedures improve(budget) and finish() work.\nWe first describe how we use Recurrence 1 to generate a new partial tree-decomposition from existing ones. The method basically follows that of PID [18] but there are some differences. The most important difference is in the manners we turn tree-decompositions into rooted tree-decompositions, which is done in order to restrict partial tree-decompositions to be generated. In the original PID, the choice of roots heavily depends on the total order\nCVIT 2016\nassumed on V (G). For the sake of interactions of HPID with other upper bound components through PMCs, we prefer the choice to depend less on the vertex order and thus be fairer for vertices.\nFix G and k. We assume a total order < on V (G) and say that U \u2286 V (G) is larger then V \u2286 V (G) if |U | > |V | or |U | = |V | and U is lexicographically larger than V . We say that a block B of G is feasible if tw(B, G) \u2264 k. We use recurrence 1, with \u03a0 set to \u03a0(G), to generate feasible blocks. Our goal is to see if V (G) is feasible and, to this end, it turns out that we do not need to generate all feasible blocks: it suffices to generate only small feasible blocks except for V (G) itself, where a block B is small if there is some block B\u2032 with NG(B\u2032) = NG(B) such that B\u2032 > B.\nTo see this, we construct rooted tree-decompositions from minimal triangulations of G. Let H be a minimal triangulation of G. We define a rooted tree DH on the set of maximal cliques of H, which may be denoted by \u03a0(H) because every PMC of H is a maximal clique. For X \u2208 \u03a0(H) and a minimal separator S \u2282 X, let B(S, X) denote the full component of S that intersects X. Note that B(S, X) is a block since NG(B(S, X)) = S is a minimal separator. For X, Y \u2208 \u03a0(H) such that X \u2229 Y is a separator of H, let S(X, Y ) denote the inclusion-minimal minimal separator of H contained in X \u2229 Y . Such an inclusion minimal separator is unique: if distinct S1, S2 \u2286 X \u2229 Y are both inclusion-minimal separators, then both of the strict inclusions of B(S1, X) \u2282 B(S2, Y ) and B(S2, Y ) \u2282 B(S1, X) must hold, which is impossible.\nWe first define a dag WH on \u03a0(H): for distinct X, Y \u2208 \u03a0(H)there, WH has an edge from X to Y if X \u2229 Y is a separator of H and B(S(X, Y ), Y ) is larger than B(S(X, Y ), X).\n\u25b6 Proposition 1. WH is acyclic.\nProof. Suppose, for contradiction, there is a directed cycle in WH and let X1, . . . , Xm, Xm+1 = X1 be the shortest such. Let S = S(X1, X2). It cannot be that m = 2, since then we would have both B(S, X1) < B(S, X2) and B(S, X1) > B(S, X2).\nLet i \u2265 2 be such that Xi \u0338\u2286 B(S, X1) \u222a S and Xi+1 \u2286 B(S, X1) \u222a S. Such i must exist since X2 \u0338\u2286 B(S, X1)\u222aS and Xm+1 \u2286 B(S, X1)\u222aS. Let S\u2032 = S(Xi, Xi+1). Since every block of H is either contained in B(S, X1) or disjoint from it, we have B(S\u2032, Xi)\u2229B(S, X1) = \u2205 and B(S\u2032, Xi+1) \u2286 B(S, X1). Since S\u2032 separates these blocks, we must have S\u2032 \u2286 NG(B(S, X1)) = X1 \u2229X2. Since S and S\u2032 are both inclusion-minimal, we must have S = S\u2032 as argued above. Then, we have B(S, X2) > B(S, X1) \u2287 B(S, Xi+1) > B(S, Xi) and therefore we have an edge from Xi to X2, contradicting the assumption that our directed cycle is the shortest. \u25c0\nNow we construct a directed tree DH on \u03a0(H) with a unique sink. As WH is acyclic, it has a sink X0. Let B denote the set of components of G \\X0. Each B \u2208 B is a block since NH(B) \u2286 X0 is a minimal-separator. Let \u03a0(H, B) denote the set of maximal cliques of H contained in B \u222aNH(B). Note that \u03a0(H, B), B \u2208 B, partitions \u03a0(H) \\ {X0}. For each such B, we construct a directed tree DH(B) on \u03a0(H, B) with unique sink XB such that WH has an edge from XB to X0. Combining DH(B), B \u2208 B, with these edges from XB to X0, we obtain DH . It remains to show how we construct DH(B).\nObserve that every B \u2208 B is small. For each small block B, we construct a directed tree DH(B) on \u03a0(H, B) with sink XB such that NH(B) \u2286 XB inductively as follows. Let CB denote the set of caps of B belonging to \u03a0(H). By the definition of caps, each X \u2208 CB satisfies NH(B) \u2286 X and X \u2286 B \u222aNH(B). The subgraph of WH induced by CB has a sink XB since WH is acyclic. Let B(XB , B) denote the set of blocks of H that are components of B \\XB . For each B\u2032 \u2208 B(XB , B), we have B\u2032 \u2286 B and, moreover, for each block C \u0338= B of NH(B), we have C \u2286 C(NH(B\u2032), XB). Therefore, since there is a block C of NH(B) such\nthat C > B as B is small, we have C(NH(B\u2032), XB) > B\u2032 for each B\u2032, that is, B\u2032 is small. By the induction hypothesis, we have a directed tree DH(B\u2032) on \u03a0(H, B\u2032) with sink XB\u2032 such that NH(B\u2032) \u2286 XB\u2032 , for each B\u2032 \u2208 B(XB , B). Combining DH(B\u2032), B\u2032 \u2208 B(X, B), with an edge from each XB\u2032 to XB , we obtain the desired directed tree DH(B).\nLet H be a minimal triangulation of G such that tw(H) = tw(G). In view of the existence of the rooted clique tree DH of H, feasibility of V (G) can be determined by generating only small feasible blocks using recurrence 1 and then seeing if the same recurrence can be used to show tw(G) = tw(V (G), G) = k. Thus, each HPID instance s maintains a set set F of small feasible blocks. To generate a new feasible block to add to F , it invokes a backtrack search procedure searchNewFeasible(B) on a block B \u2208 F which enumerates B \u2286 F such that 1. B \u2208 B and B is the largest block in B and 2. there is a block BB that is either small or is equal to V (G) and a PMC XB \u2208 \u03a0(G) such\nthat C(BB \\XB) = B. For each such B found, we add BB to F since the recurrence 1 shows that BB is feasible.\nProcedure s. improve(budget) uses this search procedure as follows. It uses a priority queue Q of small feasible blocks, in which larger blocks are given higher priority. It first put all blocks in F to Q. Then, it dequeues a block B, call searchNewFeasible(B), and add newly generated feasible blocks to Q. This is repeated until either Q is empty or the cumulative number of search steps exceeds budget. Because of the queuing policy, there is a possibility of V (G) found feasible, when it is indeed feasible, even with a small budget.\nProcedure s. finish() works similarly, except that smaller blocks are given higher priority in the queue and the budget is unlimited, to generate all small feasible blocks and V (G) if it is feasible.\nAn alternative way to to implement the finish() procedure is to call another exact treewidth algorithm based on BT dynamic programming, such as SemiPID [16], to decide if V (G) is feasible. The implementation used in our experiment uses this alternative method.\n5 Minimalizing tree-decompositions\nGiven a graph G and a triangulation H of G, minimalizing H means finding a minimal triangulation H \u2032 of G such that E(H \u2032) \u2286 E(H). Minimalizing a tree-decomposition T of G means finding a minimal tree-decomposition T \u2032 of G whose bags are maximal cliques of the minimalization of fill(G, T ). We want to minimalize a tree-decomposition for two reasons. One is our decision to represent a set of tree-decompositions by a set of PMCs. Whenever we get a tree-decomposition T by some method that may produce non-minimal tree-decompositions, we minimalize it to make all bags PMCs. Another reason is that minimalization may reduce the width. We have two procedures for minimalization. When the second reason is of no concern, we use minimalize(T ) which is an implementation of one of the standard triangulation minimalization algorithm due to Blair et al [3]. When the second reason is important, we use minimalize_optimally(T ), which finds a minimalization of T of the smallest width. This task is NP-hard, but the following algorithm works well in practice.\nSay a minimal separator of G is admissible for T if it is a clique of fill(G, T ). Observe that, for every minimalization T \u2032 of T , every separator used by T \u2032 is a minimal separator of G admissible for T . We first construct the set of all minimal separators of G admissible for T . Then we apply the SemiPID variant of BT dynamic programming, due to Tamaki [16], to this set and obtain a tree-decomposition of the smallest width, among those using only admissible minimal separators. Because of the admissibility constraint, the number of\nCVIT 2016\nminimal separators is much smaller and both the enumeration part and the SemiPID part run much faster in practices than in the general case without such constraints.\n6 Uncontracting PMCs\nIn this section, we develop an algorithm for procedure uncontractPMCs(G, \u03a0, e). In fact, we generalize this procedure to uncontractPMCs(G, \u03a0, \u03b3), where the third argument is a general contractor of G.\nGiven a graph G, \u03a0 \u2286 \u03a0(G), and a contractor \u03b3 of G, we first find tree-decompositions T \u2208 T\u03a0 that minimize w(\u03b3\u22121(T )). This is done by BT dynamic programming over T\u03a0(G/\u03b3), using bag weights defined as follows. For each weight function \u03c9 that assigns weight \u03c9(U) to each vertex set U , define the width of tree-decomposition T with respect to \u03c9, denoted by tw(G, \u03c9), to be the maximum of \u03c9(X) over all bags of T . Thus, if \u03c9 is defined by \u03c9(U) = |U | \u2212 1 then tw(G, \u03c9) = tw(G). A natural choice for our purposes is to set \u03c9(X) = |\u03b3\u22121(X)|\u2212 1. Then, the width of a tree decomposition T of G/\u03b3 with respect to this bag weight is w(\u03b3\u22121(T )). Therefore, BT dynamic programming with this weight function \u03c9 gives us the desired tree-decomposition in T\u03a0(G/r).\nWe actually use a slightly modified weight function, considering the possibility of reducing the weight of \u03b3\u22121(T ) by minimalization.\nLet T \u2208 T\u03a0(G/\u03b3) and X a bag of T . If X \u2032 = \u03b3\u22121(X) is a PMC of G, then every minimalization of \u03b3\u22121(T ) must contain X \u2032 as a bag. Therefore, if |X \u2032| > k + 1 then it is impossible that the width of \u03b3\u22121(T ) is reduced to k by minimalization. On the other hand, if X \u2032 is not a PMC, then no minimalization of \u03b3\u22121(T ) has X \u2032 has a bag and there is a possibility that there is a minimalization of \u03b3\u22121(T ) of width k even if |X \u2032| > k + 1. These considerations lead to the following definition of our weight function \u03c9.\n\u03c9(U) = 2|\u03b3\u22121(U)| if \u03b3\u22121(U) is a PMC of G (2) \u03c9(U) = 2|\u03b3\u22121(U)| \u2212 1 otherwise (3)\nAlgorithm 3 describes the main steps of procedure uncontractPMCs(\u03a0, G, \u03b3).\nAlgorithm 3 Procedure uncontractP MCs(\u03a0, G, \u03b3)\nRequire: \u03a0 \u2286 \u03a0(G/\u03b3) Ensure: returns \u03a0\u2032 \u2286 \u03a0(G) that results from uncontracting \u03a0 and then minimalizing\n1: let \u03c9 be the weight function on 2V (G/\u03b3) defined by equations 2 and 3 2: use BT dynamic programming to obtain tree-decompositions Ti, 1 \u2264 i \u2264 m, of G/\u03b3 such\nthat w(Ti, \u03c9) = tw\u03a0(G, \u03c9) 3: for each i, 1 \u2264 i \u2264 m do 4: T \u2032i \u2190 minimalize_optimally(\u03b3\u22121(Ti)) 5: \u03a0i \u2190 the set of bags of T \u2032i 6: end for 7: return \u22c3 i \u03a0i\n7 Contracting PMCs\nThe algorithm for procedure contractPMCs is similar to that for uncontractPMCs. Given a graph G, \u03a0 \u2286 \u03a0(G), and a contractor \u03b3 of G, we first find tree-decompositions T \u2208 T\u03a0(G/\u03b3)\nthat minimize w(\u03b3(T )). This is done by BT dynamic programming with the following weight function \u03c9.\n\u03c9(U) = 2|\u03b3(U)| if \u03b3(U) is a PMC of G/\u03b3 \u03c9(U) = 2|\u03b3(U)| \u2212 1 otherwise\nThen, we minimalize those tree-decompositions and collect the bags of those minimalized tree-decompositions.\n8 Safe separators\nBodlaender and Koster [6] introduced the notion of safe separators for treewidth. Let S be a separator of a graph G. We say that S is safe for treewidth, or simply safe, if tw(G) = tw(G\u222aK(S)). As every tree-decomposition of G\u222aK(S) must have a bag containing S, tw(G) is the larger of |S| \u2212 1 and max{tw(G[C \u222aNG(C)] \u222aK(NG(C))}, where C ranges over all the components of G \\ S. Thus, the task of computing tw(G) reduces to the task of computing tw(G[C \u222aNG(C)]\u222aK(NG(C))} for every component C of G \\S. The motivation for looking at safe separators of a graph is that there are sufficient conditions for a separator being safe and those sufficient conditions lead to an effective preprocessing method for treewidth computation. We use the following two sufficient conditions.\nA vertex set S of G is an almost-clique if S \\ {v} is a clique for some v \u2208 S. Let R be a vertex set of G. A contractor \u03b3 of G is rooted on R if, for each part C of \u03b3, |C \u2229R| = 1.\n\u25b6 Theorem 2. Bodlaender and Koster [6] 1. If S is an almost-clique minimal separator of G, then S is safe. 2. Let lb be a lower bound on tw(G). Let C \u2286 V (G) be connected and let S = NG(C).\nSuppose (1) tw(G[C \u222a S] \u222aK(S)) \u2264 lb and (2) G[C \u222a S] has a contractor \u03b3 rooted on S such that G[C \u222a S]/\u03b3 is a complete graph. Then, S is safe.\nWe use safe separators both for preprocessing and during recursion. For preprocessing, we follow the approach of [19]: to preprocess G, we fix a minimal triangulation H of G and test the sufficient conditions in the theorem for each minimal separator of H. Since deciding if the second condition holds is NP-complete, we use a heuristic procedure. Let S be the set of all minimal separators of H that are confirmed to satisfy the first or the second condition of the theorem. Let A be a tree-decomposition of G that uses all separators of S but no other separators. Then, A is what is called a safe-separator decomposition in [6]. A tree-decomposition of G of width tw(G) can be obtained from A by replacing each bag X of A by a tree-decomposition of G[X] \u222a \u22c3 C\u2208C(G\\X) K(NG(C)), the graph obtained from the subgraph of G induced by X by filling the neighborhood of every component of G \\X into a clique.\nSafe separators are also useful during the recursive computation. Given G, we wish to find a contractor \u03b3 of G such that tw(G/\u03b3) = tw(G), so that we can safely recurse on G/\u03b3. The second sufficient condition in Theorem 2 is useful for this purpose. Let C, S, and \u03b3 be as in the condition. We construct \u03b3\u2032 such that tw(G/\u03b3\u2032) = tw(G) as follows. The proof of this sufficient condition is based on the fact that we get a clique on S when we apply the contractor \u03b3 on G[C \u222a S]. Thus, we may define a contractor \u03b3\u2032 on G such that G/\u03b3\u2032 = (G \\ C) \u222a K(S). As each tree-decomposition of tw(G/\u03b3) can be extended to a tree-decomposition of G, using the tree-decomposition of G[C \u222a S] \u222aK(S) of width at most lb \u2264 tw(G), we have tw(G/\u03b3\u2032) = tw(G) as desired. When the recursive call on tw(G/\u03b3\u2032) returns a certificate \u03a0 \u2286 \u03a0(G/\u03b3\u2032) such that tw\u03a0(G/\u03b3\u2032) \u2264 k, we need to \"uncontract\" \u03a0 into\nCVIT 2016\na \u03a0\u2032 \u2286 \u03a0(G) such that tw\u03a0\u2032(G) \u2264 k. Fortunately, this can be done without invoking the general uncontraction procedure. Observe first that each PMC in \u03a0 naturally corresponds to a PMC of (G \\C) \u222aK(S), which in turn corresponds to a PMC of G contained in V (G) \\C. Let \u03a01 be the set of those PMCs of G to which a PMC in \u03a0 corresponds in that manner. Let \u03a02 \u2286 \u03a0(G[C \u222a S]\u222aK(S)) be such that tw\u03a02(G[C \u222a S]\u222aK(S)) \u2264 lb. Similarly as above, each PMC of \u03a02 corresponds to a PMC of G contained C \u222aS. Let \u03a0\u20322 denote the set of those PMCs of G to which a PMC in \u03a02 corresponds. As argued above, a tree-decomposition in T\u03a0((G \\C)\u222aK(S)) of (G \\C)\u222aK(S) and a tree-decomposition in T\u03a02(G[C \u222aS]\u222aK(S)) of G[C \u222a S] \u222aK(S) can be combined into a tree-decomposition belonging to T\u03a0\u20322(G) of width \u2264 k. Thus, \u03a0\u20322 is a desired certificate for tw(G) \u2264 k.\n9 Edge ordering\nWe want an edge e such that tw(G/e) = tw(G), if any, to appear early in our edge order. Heuristic criteria for such an ordering have been studied in the classic work on contraction based lower bounds [8]. Our criterion is similar to those but differs in that it derives from a special case of safe separators. The following is simple corollary of Theorem 2.\n\u25b6 Proposition 3. Let e = {u, v} be an edge of G and let S = NG(v). Suppose S \\ {u} is a clique of G. Then, we have tw(G/e) = tw(G).\nIf e satisfies the above condition, then we certainly put e first in the order. Otherwise, we evaluate e in terms of its closeness to this ideal situation. Define the deficiency of graph H, denoted by defic(H), to be the number of edges of its complement graph. For each ordered pair (u, v) of adjacent vertices of G, let deficG(u, v) denote defic(G[NG(v) \u222a {v}]/{u, v}). Note that deficG(u, v) = 0 means that the condition of the above proposition is satisfied with S = NG(v). Thus, we regard e = {u, v} preferable if either deficG(u, v) or deficG(v, u) is small. We relativize the smallness with respect to the neighborhood size, so the value of edge e = {u, v} is min{deficG(u, v)/|NG(v)|, deficG(v, u)/|NG(u)|}. We order edges so that this value is non-decreasing.\n10 Suppressed edges\nConsider the recursive call on G/e from the call of RTW on G, where e is an edge of G. Suppose there is an ancestor call on G\u2032 such that G = G\u2032/\u03b3 and edge e\u2032 of G\u2032 such that \u03b3 maps the ends of e\u2032 to the ends of e. If the call on G\u2032/e\u2032 has been made and it is known that tw(G\u2032/e\u2032) \u2264 k then we know that tw(G/e) \u2264 k, since G/e is a contraction of G\u2032/e\u2032. In this situation, we that e is suppressed by the pair (G\u2032, e\u2032). We may omit the recursive call on G/e without compromising the correctness if e is suppressed. For efficiency, however, it is preferable to obtain the certificate \u03a0 \u2286 \u03a0(G/e) for tw(G/e) \u2264 k and feed the uncontraction of \u03a0 to the HPID instance on G to help progress. Fortunately, this can be done without making the recursive call on G as follows. Suppose e is suppressed by (G\u2032, e\u2032) and let \u03a0\u2032 \u2286 \u03a0(G\u2032/e\u2032) such that tw\u03a0\u2032(G\u2032/e\u2032) \u2264 k. Let \u03b3\u2032 be the contractor of G\u2032/e\u2032 such that G\u2032/e\u2032/\u03b3\u2032 = G/\u03b3/e: such \u03b3\u2032 is straightforward to obtain from \u03b3. Letting \u03a0 = contractPMCs(\u03a0, G\u2032/e\u2032, \u03b3\u2032), we obtain \u03a0 \u2286 \u03a0(G/e) such that tw\u03a0(G/e) \u2264 k.\n11 Experiments\nWe have implemented RTW and evaluated it by experiments. The computing environment for our experiments is as follows. CPU: Intel Core i7-8700K, 3.70GHz; RAM: 64GB; Operating\nsystem: Windows 10Pro, 64bit; Programming language: Java 1.8; JVM: jre1.8.0_271. The maximum heap size is set to 60GB. The implementation uses a single thread except for additional threads that may be invoked for garbage collection by JVM.\nOur primary benchmark is the bonus instance set of the exact treewidth track of PACE 2017 algorithm implementation challenge [11]. This set, consisting of 100 instances, is intended to be a challenge for future implementations and, as a set, are hard for the winning solvers of the competition. Using the platform of the competition, about half of the instances took more than one hour to solve and 15 instances took more than a day or were not solvable at all.\nWe have run our implementation on these instances with the timeout of 10000 seconds each. For comparison, we have run Tamaki\u2019s PID solver [18], which is one of the PACE 2017 winners, available at [15] and his new solver [20] available at [21]. Figure 1 summarizes the results on the bonus set. In contrast to PID solver which solves only 68 instances within the timeout, RTW solves 98 instances. Moreover, it solve 72 of them in 100 seconds and 92 of them in 1000 seconds. Thus, we can say that our algorithm drastically extends the scope of practically solvable instances. Tamaki\u2019s new solver also quickly solves many instances that are hard for PID solver and is indeed faster then RTW on many instances. However, its performance in terms of the number of instances solvable in practical time is inferior to RTW.\nWe have also run the solvers on the competition set of the exact treewidth track of PACE 2017. This set, consisting of 200 instances, is relatively easy and the two winning solvers of the competitions solved all of the instances within the allocated timeout of 30 minutes for each instance. Figure 2 summarizes the results on the competition set. Somewhat expectedly, PID performs the best on this instance set. It solves almost all instances in 200 seconds for each instance, while RTW fails to do so on about 30 instances. There are two instances that RTW fails to solve in 10000 seconds and one instance it fails to solve at all. Tamaki\u2019s new solver shows more weakness on this set, failing to sove about 50 instances in the timeout of 10000 seconds.\nThese results seem to suggest that RTW and PID should probably complement each\nCVIT 2016\nother in a practical treewidth solver.\n12 Conclusions and future work\nWe developed a treewdith algorithm RTW that works recursively on contractions. Experiments show that our implementation solves many instances in practical time that are hard to solve for previously published solvers. RTW, however, does not perform well on some instances that are easy for conventional solvers such as PID. A quick compromise would be to run PID first with an affordable timeout and use RTW only when it fails. It would be, however, interesting and potentially fruitful to closely examine those instances that are easy for PID and hard for RTW and, based on such observations, to look for a unified algorithm that avoids the present weakness of RTW.\nReferences 1 Ernst Althaus, Daniela Schnurbusch, Julian W\u00fcschner, and Sarah Ziegler. On tamaki\u2019s\nalgorithm to compute treewidths. In 19th International Symposium on Experimental Algorithms (SEA 2021). Schloss Dagstuhl-Leibniz-Zentrum f\u00fcr Informatik, 2021. 2 Stefan Arnborg, Derek G Corneil, and Andrzej Proskurowski. Complexity of finding embeddings in a k-tree. SIAM Journal on Algebraic Discrete Methods, 8(2):277\u2013284, 1987. 3 Jean RS Blair, Pinar Heggernes, and Jan Arne Telle. A practical algorithm for making filled graphs minimal. Theoretical Computer Science, 250(1-2):125\u2013141, 2001. 4 Hans L Bodlaender. A linear-time algorithm for finding tree-decompositions of small treewidth. SIAM Journal on computing, 25(6):1305\u20131317, 1996. 5 Hans L Bodlaender, Fedor V Fomin, Arie MCA Koster, Dieter Kratsch, and Dimitrios M Thilikos. On exact algorithms for treewidth. In Algorithms\u2013ESA 2006: 14th Annual European Symposium, Zurich, Switzerland, September 11-13, 2006. Proceedings, pages 672\u2013683. Springer, 2006. 6 Hans L Bodlaender and Arie MCA Koster. Safe separators for treewidth. Discrete Mathematics, 306(3):337\u2013350, 2006."
        },
        {
            "heading": "Hisao Tamaki 23:17",
            "text": "7 Hans L Bodlaender and Arie MCA Koster. Treewidth computations i. upper bounds. Information and Computation, 208(3):259\u2013275, 2010. 8 Hans L Bodlaender and Arie MCA Koster. Treewidth computations ii. lower bounds. Information and Computation, 209(7):1103\u20131119, 2011. 9 Vincent Bouchitt\u00e9 and Ioan Todinca. Treewidth and minimum fill-in: Grouping the minimal separators. SIAM Journal on Computing, 31(1):212\u2013232, 2001. 10 Marek Cygan, Fedor V Fomin, \u0141ukasz Kowalik, Daniel Lokshtanov, D\u00e1niel Marx, Marcin Pilipczuk, Micha\u0142 Pilipczuk, and Saket Saurabh. Parameterized algorithms. Springer, 2015. 11 Holger Dell, Christian Komusiewicz, Nimrod Talmon, and Mathias Weller. The pace 2017 parameterized algorithms and computational experiments challenge: The second iteration. In 12th International Symposium on Parameterized and Exact Computation (IPEC 2017). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2018. 12 Fedor V Fomin and Yngve Villanger. Treewidth computation and extremal combinatorics. Combinatorica, 32(3):289\u2013308, 2012. 13 Pinar Heggernes. Minimal triangulations of graphs: A survey. Discrete Mathematics, 306(3):297\u2013 317, 2006. 14 Neil Robertson and Paul D. Seymour. Graph minors. ii. algorithmic aspects of tree-width. Journal of algorithms, 7(3):309\u2013322, 1986. 15 Hisao Tamaki. PID. https://github.com/TCS-Meiji/PACE2017-TrackA, 2017. [github repository]. 16 Hisao Tamaki. Computing treewidth via exact and heuristic lists of minimal separators. In International Symposium on Experimental Algorithms, pages 219\u2013236. Springer, 2019. 17 Hisao Tamaki. A heuristic use of dynamic programming to upperbound treewidth. arXiv preprint arXiv:1909.07647, 2019. 18 Hisao Tamaki. Positive-instance driven dynamic programming for treewidth. Journal of Combinatorial Optimization, 37(4):1283\u20131311, 2019. 19 Hisao Tamaki. A heuristic for listing almost-clique minimal separators of a graph. arXiv preprint arXiv:2108.07551, 2021. 20 Hisao Tamaki. Heuristic Computation of Exact Treewidth. In Christian Schulz and Bora U\u00e7ar, editors, 20th International Symposium on Experimental Algorithms (SEA 2022), volume 233 of Leibniz International Proceedings in Informatics (LIPIcs), pages 17:1\u201317:16, Dagstuhl, Germany, 2022. Schloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik. URL: https://drops. dagstuhl.de/opus/volltexte/2022/16551, doi:10.4230/LIPIcs.SEA.2022.17. 21 Hisao Tamaki. twalgor/tw. https://github.com/twalgor/tw, 2022. [github repository].\nCVIT 2016\n,"
        }
    ],
    "title": "A contraction-recursive algorithm for treewidth",
    "year": 2023
}