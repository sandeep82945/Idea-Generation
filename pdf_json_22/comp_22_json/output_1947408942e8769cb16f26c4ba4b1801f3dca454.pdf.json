{
    "abstractText": "Traditional software defenses take corresponding actions after the attacks are discovered. The defenders in this situation are comparatively passive because the attackers may try many different ways to find vulnerability and bugs, but the software remains static. This leads to the imbalance between offense and defense. Software diversity alleviates the current threats by implementing a heterogeneous software system. The N-Variant eXecution (NVX) systems, effective and applicable runtime diversifying methods, apply multiple variants to imporove software security. Higher diversity can lead to less vulnerabilities that attacks can exploit. However, runtime diversifying methods such as address randomization and reverse stack can only provide limited diversity to the system. Thus, the authors enhance the diversity of variants with a compiler-assisted approach. They use a deep reinforcement learning-based algorithm to generate variants, ensuring the high diversity of the system. For different numbers of variants, they show the results of the Deep Q Network algorithm under different parameter settings.",
    "authors": [
        {
            "affiliations": [],
            "name": "Junchao Wang"
        }
    ],
    "id": "SP:ce1fe508dc8177b72cb67ac557d339a232ab63e4",
    "references": [
        {
            "authors": [
                "S. Banescu",
                "A. Pretschner"
            ],
            "title": "A tutorial on software obfuscation",
            "venue": "Advances in Computers,",
            "year": 2018
        },
        {
            "authors": [
                "S. Bansal",
                "A. Aiken"
            ],
            "title": "Automatic generation of peephole superoptimizers",
            "venue": "ACM SIGARCH Computer Architecture News,",
            "year": 2006
        },
        {
            "authors": [
                "E.D. Berger",
                "B.G. Zorn"
            ],
            "title": "DieHard: Probabilistic memory safety for unsafe languages",
            "venue": "ACM SIGPLAN Notices,",
            "year": 2006
        },
        {
            "authors": [
                "D. Bruschi",
                "L. Cavallaro",
                "Lanzi",
                "April"
            ],
            "title": "Diversified process replic\u00e6 for defeating memory error exploits",
            "venue": "IEEE International Performance,",
            "year": 2007
        },
        {
            "authors": [
                "D. Forte",
                "S. Bhunia",
                "M.M. Tehranipoor"
            ],
            "title": "Hardware protection through obfuscation",
            "year": 2017
        },
        {
            "authors": [
                "M. Fortunato",
                "M.G. Azar",
                "B. Piot",
                "J. Menick",
                "I. Osband",
                "A. Graves",
                "S. Legg"
            ],
            "title": "Noisy networks for exploration",
            "venue": "arXiv preprint arXiv:1706.10295",
            "year": 2017
        },
        {
            "authors": [
                "M. Franz"
            ],
            "title": "Making multivariant programming practical and inexpensive",
            "venue": "IEEE Security and Privacy,",
            "year": 2018
        },
        {
            "authors": [
                "M. Franz"
            ],
            "title": "Making multivariant programming practical and inexpensive",
            "venue": "IEEE Security and Privacy,",
            "year": 2018
        },
        {
            "authors": [
                "C. Giuffrida",
                "A. Kuijsten",
                "A.S. Tanenbaum"
            ],
            "title": "Enhanced operating system security through efficient and fine-grained address space randomization",
            "venue": "In 21st USENIX Security Symposium (USENIX Security",
            "year": 2012
        },
        {
            "authors": [
                "E. G\u00f6ktas",
                "B. Kollenda",
                "P. Koppe",
                "E. Bosman",
                "G. Portokalidis",
                "T. Holz",
                "Giuffrida",
                "April"
            ],
            "title": "Position-independent code reuse: On the effectiveness of aslr in the absence of information disclosure",
            "venue": "IEEE European Symposium on Security and Privacy (EuroS&P) (pp. 227-242)",
            "year": 2018
        },
        {
            "authors": [
                "G. Goth"
            ],
            "title": "Addressing the monoculture",
            "venue": "IEEE Security and Privacy,",
            "year": 2003
        },
        {
            "authors": [
                "Z.Y. Gu",
                "X.M. Zhang",
                "Lin",
                "S. j"
            ],
            "title": "Research on load-aware dynamic scheduling mechanism based on security strategies",
            "venue": "Jisuanji Yingyong,",
            "year": 2017
        },
        {
            "authors": [
                "M. Hessel",
                "J. Modayil",
                "H. Van Hasselt",
                "T. Schaul",
                "G. Ostrovski",
                "W. Dabney",
                "Silver",
                "April"
            ],
            "title": "Rainbow: Combining improvements in deep reinforcement learning",
            "venue": "Thirty-second AAAI conference on artificial intelligence",
            "year": 2018
        },
        {
            "authors": [
                "A. Homescu",
                "T. Jackson",
                "S. Crane",
                "S. Brunthaler",
                "P. Larsen",
                "M. Franz"
            ],
            "title": "Large-scale automated software diversity\u2014Program evolution redux",
            "venue": "IEEE Transactions on Dependable and Secure Computing,",
            "year": 2015
        },
        {
            "authors": [
                "P. Hosek",
                "Cadar",
                "May"
            ],
            "title": "Safe software updates via multi-version execution",
            "venue": "In 2013 35th International Conference on Software Engineering (ICSE) (pp. 612-621)",
            "year": 2013
        },
        {
            "authors": [
                "P. Hosek",
                "C. Cadar"
            ],
            "title": "Varan the unbelievable: An efficient n-version execution framework",
            "venue": "ACM SIGARCH Computer Architecture News,",
            "year": 2015
        },
        {
            "authors": [
                "H. Hu",
                "S. Shinde",
                "S. Adrian",
                "Z.L. Chua",
                "P. Saxena",
                "Liang",
                "May"
            ],
            "title": "Data-oriented programming: On the expressiveness of non-control data attacks",
            "venue": "IEEE Symposium on Security and Privacy (SP) (pp. 969-986)",
            "year": 2016
        },
        {
            "authors": [
                "M. Jacob",
                "M.H. Jakubowski",
                "P. Naldurg",
                "C.W.N. Saw",
                "R. Venkatesan"
            ],
            "title": "November). The superdiversifier: Peephole individualization for software protection",
            "venue": "In International Workshop on Security (pp",
            "year": 2008
        },
        {
            "authors": [
                "D. Kim",
                "Y. Kwon",
                "W.N. Sumner",
                "X. Zhang",
                "D. Xu"
            ],
            "title": "Dual execution for on the fly fine grained execution comparison",
            "venue": "ACM SIGARCH Computer Architecture News,",
            "year": 2015
        },
        {
            "authors": [
                "K. Koning",
                "H. Bos",
                "Giuffrida",
                "June"
            ],
            "title": "Secure and efficient multi-variant execution using hardwareassisted process virtualization",
            "venue": "In 2016 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN) (pp. 431-442)",
            "year": 2016
        },
        {
            "authors": [
                "Y. Kwon",
                "D. Kim",
                "W.N. Sumner",
                "K. Kim",
                "B. Saltaformaggio",
                "X. Zhang",
                "Xu",
                "March"
            ],
            "title": "Ldx: Causality inference by lightweight dual execution",
            "venue": "In Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems (pp. 503-515)",
            "year": 2016
        },
        {
            "authors": [
                "W. Li",
                "Z. Zhang",
                "L. Wang",
                "J. Wu"
            ],
            "title": "The modeling and risk assessment on redundancy adjudication of mimic defense",
            "venue": "Journal of Cyber Security,",
            "year": 2018
        },
        {
            "authors": [
                "K. Lu",
                "M. Xu",
                "C. Song",
                "T. Kim",
                "W. Lee"
            ],
            "title": "Stopping memory disclosures via diversification and replicated execution",
            "venue": "IEEE Transactions on Dependable and Secure Computing",
            "year": 2018
        },
        {
            "authors": [
                "H. Massalin"
            ],
            "title": "Superoptimizer: A look at the smallest program",
            "venue": "ACM SIGARCH Computer Architecture News,",
            "year": 1987
        },
        {
            "authors": [
                "M. Maurer",
                "D. Brumley"
            ],
            "title": "TACHYON: Tandem execution for efficient live patch testing",
            "venue": "In 21st {USENIX} Security Symposium ({USENIX} Security",
            "year": 2012
        },
        {
            "authors": [
                "R. Miikkulainen",
                "J. Liang",
                "E. Meyerson",
                "A. Rawal",
                "D. Fink",
                "O. Francon",
                "B. Hodjat"
            ],
            "title": "Evolving deep neural networks. In Artificial intelligence in the age of neural networks and brain computing (pp. 293\u2013312)",
            "year": 2019
        },
        {
            "authors": [
                "V. Mnih",
                "K. Kavukcuoglu",
                "D. Silver",
                "A. Graves",
                "I. Antonoglou",
                "D. Wierstra",
                "M. Riedmiller"
            ],
            "title": "Playing atari with deep reinforcement learning",
            "venue": "arXiv preprint arXiv:1312.5602",
            "year": 2013
        },
        {
            "authors": [
                "G. Novark",
                "Berger",
                "E. D",
                "October"
            ],
            "title": "DieHarder: securing the heap",
            "venue": "In Proceedings of the 17th ACM conference on Computer and communications security (pp. 573-584)",
            "year": 2010
        },
        {
            "authors": [
                "S. \u00d6sterlund",
                "K. Koning",
                "P. Olivier",
                "A. Barbalace",
                "H. Bos",
                "Giuffrida",
                "April"
            ],
            "title": "kMVX: Detecting kernel information leaks with multi-variant execution",
            "venue": "In Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (pp. 559-572)",
            "year": 2019
        },
        {
            "authors": [
                "L.I.U. Qinrang",
                "L.I.N. Senjie",
                "G.U. Zeyu"
            ],
            "title": "Heterogeneous redundancies scheduling algorithm for mimic security defense",
            "venue": "Journal of Communication,",
            "year": 2018
        },
        {
            "authors": [
                "B. Salamat",
                "T. Jackson",
                "A. Gal",
                "Franz",
                "April"
            ],
            "title": "Orchestra: intrusion detection using parallel execution and monitoring of program variants in user-space",
            "venue": "In Proceedings of the 4th ACM European conference on Computer systems (pp. 33-46)",
            "year": 1907
        },
        {
            "authors": [
                "R.S. Sutton",
                "A.G. Barto"
            ],
            "title": "Reinforcement learning: an introduction",
            "year": 1998
        },
        {
            "authors": [
                "S. Thrun",
                "M.L. Littman"
            ],
            "title": "Reinforcement learning: An introduction",
            "venue": "AI Magazine,",
            "year": 2000
        },
        {
            "authors": [
                "Q. Tong",
                "Y. Guo",
                "H. Hu",
                "W. Liu",
                "G. Cheng",
                "L.S. Li"
            ],
            "title": "A Diversity Metric Based Study on the Correlation between Diversity and Security",
            "venue": "IEICE Transactions on Information and Systems,",
            "year": 2019
        },
        {
            "authors": [
                "H. Van Hasselt",
                "A. Guez",
                "Silver",
                "March"
            ],
            "title": "Deep reinforcement learning with double q-learning",
            "venue": "Proceedings of the AAAI Conference on Artificial Intelligence,",
            "year": 2016
        },
        {
            "authors": [
                "S. Volckaert",
                "B. Coppens",
                "B. De Sutter"
            ],
            "title": "Cloning your gadgets: Complete ROP attack immunity with multi-variant execution",
            "venue": "IEEE Transactions on Dependable and Secure Computing,",
            "year": 2015
        },
        {
            "authors": [
                "S. Volckaert",
                "B. Coppens",
                "A. Voulimeneas",
                "A. Homescu",
                "P. Larsen",
                "B. De Sutter",
                "M. Franz"
            ],
            "title": "Secure and efficient application monitoring and replication",
            "venue": "In 2016 {USENIX} Annual Technical Conference ({USENIX}{ATC}",
            "year": 2016
        },
        {
            "authors": [
                "S. Volckaert",
                "B. De Sutter",
                "T. De Baets",
                "K. De Bosschere"
            ],
            "title": "October). GHUMVEE: efficient, effective, and flexible replication",
            "venue": "In International Symposium on Foundations and Practice of Security (pp",
            "year": 2012
        },
        {
            "authors": [
                "A. Voulimeneas",
                "D. Song",
                "F. Parzefall",
                "Y. Na",
                "P. Larsen",
                "M. Franz",
                "Volckaert",
                "June"
            ],
            "title": "Distributed heterogeneous n-variant execution",
            "venue": "In International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (pp. 217-237)",
            "year": 2020
        },
        {
            "authors": [
                "Z. Wang",
                "T. Schaul",
                "M. Hessel",
                "H. Hasselt",
                "M. Lanctot",
                "Freitas",
                "June"
            ],
            "title": "Dueling network architectures for deep reinforcement learning",
            "venue": "In International conference on machine learning (pp. 1995-2003)",
            "year": 2003
        },
        {
            "authors": [
                "R. Wojtczuk"
            ],
            "title": "The advanced return-into-lib (c) exploits: Pax case study",
            "venue": "Hacking blind",
            "year": 2001
        },
        {
            "authors": [
                "J. Wu"
            ],
            "title": "Cyberspace mimic defense",
            "venue": "Springer International Publishing",
            "year": 2020
        },
        {
            "authors": [
                "M. Xu",
                "K. Lu",
                "T. Kim",
                "W. Lee"
            ],
            "title": "Bunshin: compositing security mechanisms through diversification",
            "venue": "{USENIX} Annual Technical Conference ({USENIX}{ATC}",
            "year": 2017
        },
        {
            "authors": [
                "J.X. Zhang",
                "J.M. Pang",
                "Z. Zhang"
            ],
            "title": "Quantification method for heterogeneity on Web server with mimic construction",
            "venue": "Journal of Software,",
            "year": 2020
        },
        {
            "authors": [
                "J.X. Zhang",
                "J.M. Pang",
                "Z. Zhang",
                "M. Tai",
                "H. Zhang",
                "G.L. Nie"
            ],
            "title": "The Executors Scheduling Algorithm for the Web Server with Mimic Construction",
            "venue": "Computer Engineering,",
            "year": 2019
        },
        {
            "authors": [
                "Zhang Fan"
            ],
            "title": "He was Ph. D., associate researcher, doctoral supervisor. His main research areas are information communication network and high efficiency computer architecture. He presided over 1 projects on the National Natural Science Foundation, 2 provincial ministerial projects and Participated 6 national level projects and 9 provincial and ministerial projects. He applied for 15 national technical invention patents and, 8 rights were authorized",
            "year": 1981
        }
    ],
    "sections": [
        {
            "text": "DOI: 10.4018/IJDCF.302878\nThis article published as an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/4.0/) which permits unrestricted use, distribution, and production in any medium,\nprovided the author of the original work and original publication source are properly credited.\n*Corresponding Author\nTraditional software defenses take corresponding actions after the attacks are discovered. The defenders in this situation are comparatively passive because the attackers may try many different ways to find vulnerability and bugs, but the software remains static. This leads to the imbalance between offense and defense. Software diversity alleviates the current threats by implementing a heterogeneous software system. The N-Variant eXecution (NVX) systems, effective and applicable runtime diversifying methods, apply multiple variants to imporove software security. Higher diversity can lead to less vulnerabilities that attacks can exploit. However, runtime diversifying methods such as address randomization and reverse stack can only provide limited diversity to the system. Thus, the authors enhance the diversity of variants with a compiler-assisted approach. They use a deep reinforcement learning-based algorithm to generate variants, ensuring the high diversity of the system. For different numbers of variants, they show the results of the Deep Q Network algorithm under different parameter settings.\nKeywoRDS Deep Q Network, Multi-Compiling, N-Variant Execution, Software Diversity, Software Security, Variant Generation\nI. INTRoDUCTIoN\nSoftware monoculture means that software systems adopt a relatively static fixed architecture and roughly similar operating mechanisms, which allows attacks that work on one system to be easily applied to all similarly configured systems. Most monoculture computer systems are subject to catastrophic failure in the event of a successful attack (Goth, 2003).\nHowever, software diversity, a technical means that can effectively improve software security, has been a concern in recent years. Software systems with high diversity tend to resist more complex attacks, just as diverse biological populations form a safer and more stable ecosystem. This technology increases the cost and difficulty of attackers. With the continuous improvement of attack methods, the increasing variety of attack methods has led to an imbalance between offense and defense. A\nsingle software diversifying method often fails to achieve the expected security effect (Bansal, 2006; Massalin, 1987; Szekeres, 2013; Nergal, 2001; Bittau, 2014; Gras, 2017; Hund, 2013; Snow, 2013). Comparatively, N-variant eXecution (NVX) systems (Cox, 2006; Berger, 2006; Novark, 2010; Bruschi, 2007; Hosek, 2013, 2015; Kim, 2015; Kwon, 2016; Koning, 2016; Lu, 2018; Maurer, 2012; Salamat, 2009; Volckaert, 2015; Volckaert, 2016; Volckaert, 2012; Xu, 2017; Osterlund, 2019; Voulimeneas, 2020; Wu, 2020) are more effective and adaptable. The work of Franz (2018) mentioned that NVX technology tries to make a system achieve probabilistic security by introducing redundant variants. The more considerable diversity between variants will make the system safer. The implementation principle of this technology is to run different variants of the same program simultaneously and watch the behaviors of these variants. The attackers need to simultaneously destroy multiple program variants without causing system errors. In recent research, NVX systems have been widely used in systems with high security requirements, but there are still some problems in existing NVX systems. Most NVX systems only use runtime diversifying approaches, such as the disjoint code layout (DCL) (Volckaert et al., 2015), reverse stack (Salamat, 2009), and address randomization (Berger, 2006; Lu, 2018), which only provide limited diversity. Thus, they are often incapable of attacks using program structures or data flows, such as position-independent return-oriented programming (PIROP) attacks (G\u00f6ktas et al., 2018\u0327) and certain data-oriented programming (DOP) attacks (Hu et al., 2016).\nOur approach proposed in this paper solves the above problem. We increase the diversity of the NVX systems by using a multicompiling method and propose a compilation tree model to evaluate the variants\u2019 diversity. In addition, we present a variant generation algorithm based on deep reinforcement learning, which is verified in the experimental part.\nApplying multicompiling methods can increase the variants\u2019 diversity and maintain their functional equivalence. The traditional obfuscation methods used by attackers to protect them from anti-virus software can also be applied for software protection. Thus, we can achieve multicompiling on the source code of software by using existing obfuscation tools. The current obfuscation tools provide many obfuscation approaches, so we can establish NVX systems with great diversity with these existing obfuscation options. To quantitatively measure the diversity of variants, we propose a compilation tree method. In our model, the tree\u2019s nodes represent the variants with different compiling methods, and the distances between the nodes represent the difference between the variants. In this way, the problem of diversity measurement is transformed into calculating the distance between tree nodes. The optimization goal of our algorithm is to maximize the variants\u2019 diversity. We apply a brute force algorithm and deep Q-learning network (DQN) (Mnih et al., 2013) algorithm to generate variants. We also verify in the experiments that the DQN method is more practical than the brute force method when the number of variants is large.\nThe contributions of this paper are as follows:\n\u2022 We increase the diversity of variants by using multicompiling methods to enhance the security of the NVX systems. \u2022 We propose a compilation tree model to represent the differences between the compiled variants. The advantage of this method is that the differences between variants can be calculated through the tree structure, which provides a basis for the variant generation algorithm. \u2022 We propose a variant generation algorithm that can be applied in NVX systems. We use a brute force algorithm and DQN algorithm to generate the combination of the most secure variant. \u2022 We verify the applicability of our algorithm in the experiment. For different numbers of multicompiling methods and required variants, we compare the diversity of variant sets and analyze the DQN algorithm under different settings."
        },
        {
            "heading": "II. ReLATeD woRKS",
            "text": "We list the works related to our approach in this section. We find that most of the NVX systems use runtime diversifying approaches, and we summarize the multicompiling methods that can be used to enhance the diversity in the NVX systems. Moreover, compared with the existing variants\u2019 diversity measuring methods, we quantitatively analyze the diversity that our method brings to the system from the compilation perspective."
        },
        {
            "heading": "A. NVX SySTemS",
            "text": "Since 2006, many NVX systems have been used in security scenarios, such as memory security and kernel security. The variants of NVX run on the same (Cox, 2006; Berger, 2006; Novark, 2010; Bruschi, 2007; Hosek, 2013, 2015; Kim, 2015; Kwon, 2016; Koning, 2016; Lu, 2018; Maurer, 2012; Salamat, 2009; Volckaert, 2015; Volckaert, 2016; Volckaert, 2012; Xu, 2017; Osterlund, 2019) or different (Voulimeneas, 2020; Wu, 2020) physical machines simultaneously. They provide the same incentives to the variants and compare the variants\u2019 output behavior through a monitor. The idea of NVX systems has progressed rapidly in recent years. The authors of Berger and Zorn (2006), Novark and Berger (2010) built Diehard and DieHarder architecture and probabilistic analysis to protect memory security. The work of Kim et al. (2015) and Kwon et al. (2016) reduced the uncertainty of offline comparison by comparing two variants in real time. The work of Osterlund et al. (2019) protected kernel security through NVX systems. Moreover, Cox et al. (2006) first proposed the N-variant system in 2006 and compared several variant generation strategies, such as disjoint layout mapping and instruction set randomization. Salamat et al. (2009) proposed Orchestra, using reverse stack growth to generate stacks in opposite directions. GHUMVEE (Volckaert, 2015; Volckaert, 2016; Volckaert, 2012) applied disjoint code layouts (DCLs) to introduce software diversity. This method ensured no segment overlap in the address space of code variants so that there were no coexisting gadgets during return-oriented programming (ROP) attacks. In 2015, Hosek and Cadar (2015) proposed Varan, which relied on static binary tools to significantly improve the NVX systems\u2019 performance, focusing more on software reliability than security. Similarly, Mx (Hosek & Cadarl, 2013) and Taychon (Maurer & Brumley, 2012) also focused more on the system\u2019s performance. As a new NVX system, MvArmor (Koning et al., 2016) realized a high-performance NVX system through hardware assistance and virtualized processes, and they put the software in user-level privilege instead of kernel-level privilege to protect the security of the monitor. In summary, existing NVX systems use runtime diversifying approaches to introduce limited diversity.\nB. VARIANTS\u2019 DIVeRSITy meASURINg meThoDS\nHomescu et al. (2017) mentioned that entropy and granularity are two critical indicators for variant systems. The two indicators are large enough so that the attacker must spend many resources to brute the force of the crack. Measuring the variants\u2019 diversity. The authors of Liu et al. (2018), Gu et al. (2017), and Tong et al (2019) divided variants into components such as processor, operating system, application software, protocol stack, etc., and measured the differences of components separately. From a security perspective, the works of Zhang et al. (2020), and Li et al. (2018) used symbiosis vulnerabilities to compare the similarity between the two variants. The more common vulnerabilities contained in the two variants, the smaller the diversity between the two variants. The authors of Liu et al. (2018), and Gu et al. (2017) evaluated variant diversity by measuring the heterogeneity or safety of the variant system. The work of Zhang et al. (2019) also considered the heterogeneity and service quality of the generated variants. Software diversity can be easily introduced from the compiling process, but we do not find any existing work evaluating the variants\u2019 diversity from the perspective of compilation."
        },
        {
            "heading": "C. mULTICompILINg meThoDS",
            "text": "Multicompiling can be regarded as a program compiling algorithm that takes a particular program as input, and the output is a functionally equivalent program but more challenging to understand. The work of Banescu and Pretschner (2018) lists many compiling techniques currently in use, including opaque predicate, variable division/merging, control flow flattening, instruction replacement, garbage code injection, virtualization obfuscation, etc. The current multicompiling methods have been integrated into automation tools. For C language, for example, obfuscator-llvm (OLLVM)1, Hikari2, Armariris3, Tigresss4, etc., they mainly support control flow flattening, instruction replacement, bogus control flow, and other means. These tools are easy to transplant to other tools. Multicompiler5 supports more obfuscation methods than other tools, including code randomization, such as function sorting, CPU register variable allocation, instruction scheduling, insertion of NOP instructions and instruction replacement; stack layout randomization, such as reordering stack elements, filling stack elements and frames; global variables randomizing, such as rearranging the order of global variables, randomly adding padding values to destroy global variables attack. Additionally, ProGuard6 can obfuscate the files in the format of jars, aars, wars, ears, zips, apks, or directories; PyArmor7 uses the encrypted command to achieve the purpose of protection; Obfuscator.io8 supports obfuscation of JavaScript; Yakpro PO9 supports obfuscation of PHP language; SharpLoader10 supports obfuscation of C# language.\nMulticompiling methods always have many applications in computer security. Jacob et al. (2008) proposed the idea of a \u201csuperdiversifier\u201d, a super performance compiler aimed at improving computer security. Giuffrida et al. (2012) used multicompiling methods to protect kernel-level system security by transforming the layout of code and data. Their code conversion mainly included function shuffling and reordering of basic blocks in functions. Homescu et al. (2017) proposed a compiler-based software automatic diversification technology by considering the two indicators of entropy and granularity. Two obfuscation methods were discussed: insertion of NOP instructions and instruction scheduling. The vast number of multicompiling options can provide us with enough diversifying options to build a compilation tree."
        },
        {
            "heading": "III. CompILATIoN TRee",
            "text": ""
        },
        {
            "heading": "A. Compilation Tree Framework",
            "text": "As shown in Figure 1, our method\u2019s input is the source code of a software and users\u2019 security requirements, and the output is a set of compiled binaries named variants. Based on the heterogeneous variants generated by multicompiling methods, we can build a robust software diversity system. To compile the source code of the software, we can use the different compiling options provided by existing compiling tools, such as control flow flattening, variable division, instruction replacement, and bogus control flow. We can also use different parameters in the same method or a combination of different compilation methods. Thus, we propose a compilation tree model to represent the differences between different variants. We also apply a DQN algorithm to generate variants; this part is introduced in detail in section IV.\nThe notation in our model and their description are listed in Table 1.\nDefinition 1 node vi: The i-th node in the tree, representing a variant generated by using a specific compiling method or several compiling methods. Definition 2 root node v0: A node without a predecessor node in a nonempty tree, representing a variant that does not use the multicompiling method to compile. Definition 3 edge: the edges connect two adjacent nodes. Definition 4 edge weight d (vi, vj): the weight of edges, used to represent the distance between the\ntwo variants connected by the edge. For adjacent nodes v1 and v2, the distance between them is d (v1, v2). It should be noted that in the compilation tree, any two nodes cannot be generated with\nthe same multicompiling methods. This is mainly because the same multicompiling methods cannot introduce diversity.\nOur compilation tree model is shown in Fig. 2. v 0 is the root node, meaning the source code of software; v\n1 ~ v 8 denote the variants compiled by the single or combined compiling methods. The\nedges of the tree model represent several compiling methods, including instruction replacement, bogus control flow, and string encryption. In this tree structure, the edge weights represent the distance between the two connected nodes.\nWhen using multicompiling options to achieve different code obfuscation levels, we need to define the parameters of multicompiling options. For example, in OLLVM, the instruction replacement option can be expressed as \u201c-sub\u201d or \u201c-sub_loop=num1\u201d. \u201c-sub\u201d means to perform instruction replacement with the default value. \u201c-sub_loop=num1\u201d means that the number of replacement loops is num1. num1 can be any integer, and the default value of num1 is 1. The bogus control flow option is to add a basic block before the current basic block to modify the function call graph or fill the original basic block with randomly selected garbage commands. This option can be expressed as \u201c-bcf\u201d or \u201c-bcf_prob=num2\u201d. \u201c-bcf\u201d means to perform bogus control flow with the default value. \u201c-bcf_prob=num2\u201d means this method covers num2 percent blocks. Therefore, each method\u2019s parameters can also introduce diversity to the variants. As an example, nodes v\n1 , v 2 , v 3 , v 4 and v 5\nrepresent the variants realized by the single compiling methods. v 1 and v 4 indicate the variants generated using the instruction replacement method. Since num1 can be any number except the default value, v\n1 and v 4 are also different. Similarly, the number of blocks applied by the bogus control\nflow command is different, so that v 2 and v 5 are different. The distance between v 4 and v 5 can be expressed in Eq.\nd v v d v v d v v d v v 4 1 1 0 0 2 2 5 , , , ,( )+ ( )+ ( )+ ( ) (1)\nWhen using two or more methods to compile the variants, we find that it can produce a strong effect, and there are many combined compilation technologies in many practice to improve the security of the variants\u2019 environment (Naumovich et al., 2006; Forte et al., 2017) Nodes v\n6 , v 7 and v 8\nrepresent the variants compiled by the combined compiling methods. Starting from the root node v\n0 , reaching the v 6 node needs to pass through v 1 and v 4 , which indicates that v 6 is obtained after\nv 4 implementing control flow flattening (-fla). In the same way, to reach node v 7 , we first need to use bogus control flow to compile the variants and then apply basic block division (-split) to the variant. The difference between v\n7 and v 8 is the difference in the divided instruction blocks. The\ndistance between v 6 and v 8 is presented in Eq. 2, where d v v 4 5 ,( ) can be calculated by Eq.\nd v v d v v d v v d v v 6 8 6 4 4 5 5 8 , , , ,( ) = ( )+ ( )+ ( ) (2)"
        },
        {
            "heading": "B. problem Formulation",
            "text": "Our purpose is to solve the problem of variant generation to achieve the maximum diversity. Here are a few terms that we will use in our optimization problem.\nDefinition 5 set V: The variant set is generated by our method, which is also the output variant combination in Figure 1. Definition 6 variants\u2019 diversity dv: the diversity of variants set. Definition 7 selecting factor x\ni : x i indicates whether variant v i is included in variant set V generated\nby our algorithm.\nx x V\nx Vi i\ni\n= \u2208 \u2209   \n \n     1 0 , , (3)\nIt is worth noting that the distance between two nodes v i and v j is the sum of weights of edges along the shortest path between two nodes. In our model, there is no variant of the repeated compiling method in the generated variant set V. We can define our optimal function as:\nmax ,dv x x d v v i j i\nm\ni\nm\ni j i j = ( ) \u2260\n= = \u2211\u2211 1 1\n(4)\nm is the number of nodes in the compilation tree. This formula means that the diversity of set V is the sum of distances between nodes in V.\nThe simplest way to solve this optimization problem is to traverse each combination of variants to find the node set with the largest d\nk . The time complexity of this brute forcing method is\nO C O m\nk m km k( ) (\n!\n!( )! )= \u2212 . Therefore, the size of the search space is related to the compilation trees\u2019\nscale and the number of required variants.\nAlgorithm 2\nAlgorithm 1"
        },
        {
            "heading": "IV. oUR ALgoRIThm",
            "text": "For a given number of variants k, our algorithm\u2019s goal is to maximize the diversity of the system. The security of the system is directly proportional to the variants\u2019 diversity. To achieve this goal, we need to select the most diverse combination of variants. Therefore, there are two difficulties that need to be solved:\n1) How to quantify the variants\u2019 diversity? 2) How can the most diverse combination of variants be generated?\nFor the first problem, we use the distance of the variant\u2019s combination to define the variants\u2019 diversity. For the second problem, we introduce two variant generation algorithms: the brute force method and the DQN method.\nA. Variant generation method Based on Brute Force Algorithms For a compilation tree, all nodes can be regarded as a method of variant generation. Therefore, in the brute force algorithm, we permutate all possible combinations and find the most diverse combination of variants. By using Eq. 4 to calculate the variants\u2019 diversity, this process is presented in Algorithm 1.\nB. Variants generation method based on DQN Algorithm Q-learning is a typical algorithm for value-based solutions in reinforcement learning (Sutton & Barto, 2018). We can use the Q-table or Q-function to store the action-value function (Q value) corresponding to each state action to make the next action selection. Q s a* ( , ) can be defined as the optimal actionvalue function, which means the maximum expected return achievable by any following strategy, in state s for action a. The optimal action-value function obeys the Bellman equation:\nQ s a E reward Q s a a * max *,( ) = + ( )        \u2032 \u2032 \u2032 \u00b3 (5)\ny is the discount factor, and max ( ', ') 'a i Q s a means the optimal value in the next state for all\npossible actions a ' We can use an iterative update for the Bellman equation:"
        },
        {
            "heading": "Q E reward Q s a",
            "text": "i s a a+ ( ) \u2032 = + ( )   \u2032 \u2032 1 * , maxg (6)\nIt can be proved that Q Q as i i \u2192 \u2192\u221e* (Sutton & Barto, 1998).\nThe work of Mnih et al. (2013) proposed the deep Q network (DNN), which combines a deep neural network (DNN) (Miikkulainen et al., 2019) and Q-learning. As shown in Fig. 3, the input of the DNN with weight \u03b8 is the current state, and the output is an action that can be selected. The environment gives the corresponding reward value to guide the agent to complete a specific purpose or make a profit maximized action. The DQN algorithm also encourages many algorithms that combine DNN and Q-learning, such as the double deep Q network (DDQN) (Hasselt et al., 2016), Du Lin DQN (Wang et al., 2019), Noisy DQN (Fortunato et al., 2017), and Rainbow (Hessel et al., 2018).\nAlgorithm 1 is not applicable when the number of nodes is enormous. Thus, we apply the DQN to generate variants. In our algorithm, the state space is discrete. When training the neural network, to train more variant combinations, we map the entire state space into a one-dimensional array. The input to the neural network is a state, which is a combination of variants of the required number. Our network starts with two 100-way fully connected layers with the ReLU function and ends with a 3-way fully connected layer with a linear function. We define the symbols used in the DQN algorithm as follows:\nDefinition 8 node combination: a combination of k nodes, where k is the number of variants required by the user.\nDefinition 9 state s: each node combination corresponds to a state. s i is the i-th state in state array. Definition 10 action a: selecting different node combinations in the state space array, the corresponding action values are different. The new node combination is randomly selected, and each variant in the combination may be different from the previous state. Suppose the current state is s\ni , and\nthe state after selecting the variant in the next step is s j . Then, we can define the value of action:\naction\nj i\nj i\nj i i= = = = \u2212 \u2260\n\n\n  \n\n\n   0 1 2 0 , , ,\n(7)\nDefinition 11 reward: the reward score given by the environment when taking different actions. Assuming that the current state is s\ni and the state obtained after taking action is s j , the expression\nof reward is represented as follows:\nreward d s d s i j\n= ( )\u2212 ( ) (8)\nThe loss function is defined as:\nL reward Q s a Q s a a \u03b8 \u03b3 \u03b8 \u03b8( ) = + ( )\u2212 ( )( )\u2032 \u2032 \u2032 \u2032\u2032max ; ;* (9)\ny is the discount factor; the larger the value is, the more critical it is to historical experience. When y=0, only the current benefit (reward) is considered; is the optimal value that can be obtained in the next state.\nWe perform a gradient descent step on the equation to update the weight \u00b8 . Moreover, in Eq. 9, we choose off-policy temporal-difference (TD) learning (Sutton & Barto, 1998) to update the Q-value as follows:\nQ s a lr Q s a lr reward Q s a a \u2032 \u2032 \u2032 \u2032( ) = \u2212( ) ( )+ + ( ) )\u2032; , ; max ( ; ]\u03b8 \u03b8 \u03b3 \u03b81 * (10)\nwhere ir \u00ce ( , )0 1 in Eq.10 is the learning rate. The TD algorithm is the central and novel part of reinforcement learning, which can update the knowledge of the agent at every timestep. It contains two policies: on-policy TD control (Sarsa) and off-policy TD control (Q-learning).\nReferring to work (Mnih et al., 2013), we introduce the variant generation method illustrated in Algorithm 2."
        },
        {
            "heading": "V. eXpeRImeNTS",
            "text": ""
        },
        {
            "heading": "A. experimental Setup and Dataset",
            "text": "The experiments are performed on a server with an Intel(R) Xeon(R) Gold 5218 CPU @ 2.30 GHz 16-core CPU and 250 GB RAM.\nWe analyze different factors that can affect variant generation. Thus, we benchmark the performance of our proposed algorithm under different settings. To evaluate the experimental data, we randomly generate a tree structure with different numbers of node and edge weights."
        },
        {
            "heading": "B. experimental Results",
            "text": "1) different numbers of compiling options\nTo compare the impact of different compilation options on the experimental results, we generated compilation trees with 10, 50, 100, 500, and 1000 nodes. In our model, each node represents a compilation option.\nThe following experimental results are all obtained under the condition of the required number of variants k=3. The brute force and the DQN algorithms use the same tree model.\nTable 2 shows the experimental results of the brute force algorithm.\nFigure 4, Figure 5, and Figure 6 show the effect of the learning rate, discount factor, and episode on the DQN algorithm result. The x-axis is the number of nodes in the compiled tree. As the number of nodes increases, the diversity of the generated variants increases.\nIn Figure 4, the red line represents the brute force algorithm\u2019s experimental results, and the five black lines represent the diversity of generated variants when the learning = 0.5, 0.6, 0.7, 0.8, and 0.9. The default factor = 0.95; episodes = 100. The value of the learning rate affects the experimental results. When the learning rate is equal to 0.7, the generated variants\u2019 diversity is the largest.\nThe six black lines in Figure 5 represent the diversity of generated variants when the discount factor Y takes different values. The default parameters are lr = 0.8 and episodes = 100. When the number of nodes is small, the variants\u2019 diversity is largest when Y= 0.7, and when the number of variants is large, Y= 0.9 is better.\nFigure 6 shows that when the number of episodes is set to 1000, the generated variant combination has greater diversity, and larger training times can obtain better experimental results.\n2) different numbers of required variants\nWhen the number of nodes is 50, we compare the impact of different required variant numbers k on the generated variant diversity. As shown in Figure 7, the parameters of the DQN algorithm are . When k increases, the gap of diversity between the DQN algorithm and the brute force decreases, and our algorithm has strong applicability. We can also conclude that as the number of required variants increases, the diversity of generated variants will also increase.\nIt can be seen from the experimental results that if the cost permits, we can appropriately increase the number of compilation options and required variants to obtain high diversity. In addition, although the DQN algorithm cannot obtain the optimal solution every time, it is more efficient and can achieve better results when the number of variants is large."
        },
        {
            "heading": "VI. CoNCLUSIoN",
            "text": "In this paper, we enhance the diversity of NVX systems by using the multicompiling method. We present a compilation tree model to measure the variants\u2019 diversity and apply the DQN algorithm to generate variants. Our variant generation algorithm ensures the high diversity of the NVX systems to improve the system\u2019s resistance to attacks. In the experiment, we compare the results of the DQN algorithm with different settings and analyze the impact of variant numbers and compiling option numbers on variant diversity.\nIn future work, we will generate the weights of the edges in the compilation tree based on techniques such as binary diffing analysis. We will also consider system performance and more factors when generating variants."
        },
        {
            "heading": "VII. ACKNowLeDgmeNTS",
            "text": "This research is supported by the National Key Research and Development Program of China (2017YFB0803202), Major Scientific Research Project of Zhejiang Lab (No. 2018FD0ZX01), National Core Electronic Devices, High-end Generic Chips and Basic Software Major Projects (2017ZX01030301), the National Natural Science Foundation of China (No. 61309020) and the National Natural Science Fund for Creative Research Groups Project (No. 61521003)."
        }
    ],
    "title": "Security enhancement Through Compiler-Assisted Software Diversity with Deep Reinforcement Learning",
    "year": 2022
}