{
    "abstractText": "This paper is devoted to finite state automata, regular expression matching, pattern recognition, and the exponential blow-up problem, which is the growing complexity of automata exponentially depending on regular expression length. This paper presents a theoretical and hardware solution to the exponential blow-up problem for some complicated classes of regular languages, which caused severe limitations in Network Intrusion Detection Systems work. The article supports the solution with theorems on correctness and complexity.",
    "authors": [
        {
            "affiliations": [],
            "name": "A Preprint"
        },
        {
            "affiliations": [],
            "name": "Alexandra Bernadotte"
        }
    ],
    "id": "SP:b9c43d3422ebaefdaa1449e5b03630e9039b9e2b",
    "references": [
        {
            "authors": [
                "S. Kumar",
                "B. Chandrasekaran",
                "F. Yu",
                "J. Crowley P. Turner"
            ],
            "title": "Algorithms to Accelerate Multiple Regular Expressions Matching for Deep Packet Inspection",
            "venue": "In ACM SIGCOMM Computer Communication Review,",
            "year": 2006
        },
        {
            "authors": [
                "S. Kumar",
                "B. Chandrasekaran",
                "J. Turner",
                "G. Varghese"
            ],
            "title": "Curing regular expressions matching algorithms from insomnia, amnesia, and acalculia",
            "venue": "Proceedings of the 3rd ACM/IEEE Symposium on Architecture for networking and communications systems,",
            "year": 2008
        },
        {
            "authors": [
                "S. Kumar"
            ],
            "title": "A Thesis on Accelerationof Network Processing Algorithms",
            "venue": "Doctor of Science Thesis,",
            "year": 2008
        },
        {
            "authors": [
                "C.L. Nehaniv",
                "E. Antonova"
            ],
            "title": "Simulating and reconstructing neurodynamics with Epsilon-automata applied to electroencephalography (EEG) Microstate Sequences",
            "venue": "IEEE Symposium Series on Computational Intelligence (SSCI), Honolulu, HI,",
            "year": 2017
        },
        {
            "authors": [
                "C.L. Nehaniv",
                "E. Antonova"
            ],
            "title": "Simulating and Reconstructing Neurodynamics with Epsilon-Automata Applied to Electroencephalography (EEG) Microstate Sequences",
            "venue": "arXiv:1710.02387v1 [q-bio.NC]",
            "year": 2017
        },
        {
            "authors": [
                "A. Bernadotte",
                "R. Kumar",
                "B. Winblad",
                "P.F. Pavlov"
            ],
            "title": "In silico identification and biochemical characterization of the human dicarboxylate clamp TPR protein interaction network",
            "venue": "FEBS Open Bio,",
            "year": 2018
        },
        {
            "authors": [
                "A. Podkolzin",
                "L. Ivanovic",
                "A. Bolotov",
                "M. Grinchuk",
                "S. Afonin"
            ],
            "title": "Impulse Regular Expression Matching",
            "venue": "US 2014/0136465",
            "year": 2014
        },
        {
            "authors": [
                "Al Tariq Sheik",
                "Ugur Ilker Atmaca",
                "Carsten Maple",
                "Gregory Epiphaniou"
            ],
            "title": "Challenges in Threat Modelling of New Space Systems: A Teleoperation Use-Case",
            "venue": "Advances in Space Research,",
            "year": 2022
        },
        {
            "authors": [
                "I. Menshikov",
                "A. Bernadotte"
            ],
            "title": "Intelligent Robotic Motion Copying System LevshAi for Neurosurgical Endovascular Operations with Haptic Feedback and Preoperative Personalized Simulation",
            "venue": "IEEE International Conference on Cyborg and Bionic Systems (CBS), Wuhan,",
            "year": 2022
        },
        {
            "authors": [
                "A. Bernadotte"
            ],
            "title": "Cyber Security for Surgical Remote Intelligent Robotic Systems",
            "venue": "9th International Conference on Automation, Robotics and Applications (ICARA), Abu Dhabi, United Arab Emirates,",
            "year": 2023
        },
        {
            "authors": [
                "B. Kudryavtsev V",
                "V. Aleshin S",
                "S. Podkolzin A"
            ],
            "title": "Introduction to Automata Theory",
            "venue": "In Nauka, Moscow,",
            "year": 1985
        },
        {
            "authors": [
                "\u0412. \u041a\u0443\u0434\u0440\u044f\u0432\u0446\u0435\u0432"
            ],
            "title": "\u0411., \u0413\u0430\u0441\u0430\u043d\u043e\u0432 \u042d. \u042d., \u041f\u043e\u0434\u043a\u043e\u043b\u0437\u0438\u043d \u0410",
            "venue": "\u0421. \u041e\u0441\u043d\u043e\u0432\u044b \u0442\u0435\u043e\u0440\u0438\u0438 \u0438\u043d\u0442\u0435\u043b\u043b\u0435\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0445 \u0441\u0438\u0441\u0442\u0435\u043c In\u041c\u0430\u043a\u0441 \u041f\u0440\u0435\u0441\u0441, \u041c\u043e\u0441\u043a\u0432\u0430,",
            "year": 2016
        },
        {
            "authors": [
                "J. Hopcroft",
                "R. Motwani",
                "J. Ulman"
            ],
            "title": "Introduction to the Theory of Automata",
            "venue": "Languages and Computing,",
            "year": 2017
        },
        {
            "authors": [
                "M.O. Rabin",
                "D. Scott"
            ],
            "title": "Finite automata and their decision problems",
            "venue": "In IBM J. Research and Development,",
            "year": 1959
        },
        {
            "authors": [
                "K. Salomaa"
            ],
            "title": "Descriptional Complexity of Nondeterministic Finite Automata",
            "venue": "Developments in Language Theory. DLT",
            "year": 2007
        },
        {
            "authors": [
                "B.L. Chamberlain"
            ],
            "title": "Graph Partitioning Algorithms for Distributing Workloads of Parallel Computations",
            "venue": "In University of Washington Technical Report UW-CSE-98-10-03,",
            "year": 1998
        },
        {
            "authors": [
                "Brookshear",
                "J. Glenn"
            ],
            "title": "Theory of Computation: Formal Languages, Automata, and Complexity",
            "venue": "Redwood City, California: Benjamin/Cummings Publish Company, Inc. ISBN 978-0-8053-0143-4,",
            "year": 1989
        },
        {
            "authors": [
                "T. Jiang",
                "B. Ravikumar"
            ],
            "title": "Minimal NFA problems are hard",
            "venue": "In SIAMJ.Computing22,",
            "year": 1993
        },
        {
            "authors": [
                "R. Meyer A",
                "J. Fischer M"
            ],
            "title": "Economy of description by automata, grammars, and formal systems",
            "venue": "In Proceedings of the Annual Symposium on Foundations of Computer Science,",
            "year": 1971
        },
        {
            "authors": [
                "A. Backurs",
                "P. Indyk"
            ],
            "title": "Which Regular Expression Patterns are Hard to Match",
            "year": 2016
        },
        {
            "authors": [
                "R. Smith",
                "C. Estan",
                "S. Jha"
            ],
            "title": "XFA: Faster Signature Matching with Extended Automata",
            "venue": "In IEEE Symposium on Security and Privacy,",
            "year": 2008
        },
        {
            "authors": [
                "\u0415. \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432 \u0414"
            ],
            "title": "\u041e\u0431 \u0443\u043c\u0435\u043d\u044c\u0448\u0435\u043d\u0438\u0438 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u043d\u043e\u0439 \u0441\u043b\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0441\u0447\u0435\u0442 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u044f \u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u043e\u0432",
            "venue": "In \u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u0430\u044f \u0438\u043d\u0436\u0435\u043d\u0435\u0440\u0438\u044f,",
            "year": 2014
        },
        {
            "authors": [
                "\u0415. \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432 \u0414"
            ],
            "title": "\u041e\u0431 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u043d\u043e\u0439 \u0441\u043b\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0440\u0430\u0441\u043f\u043e\u0437\u043d\u0430\u0432\u0430\u043d\u0438\u044f \u043a\u043b\u0430\u0441\u0441\u0430 \u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u043e\u0432",
            "venue": "In \u0418\u043d\u0442\u0435\u043b\u043b\u0435\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0435 \u0441\u0438\u0441\u0442\u0435\u043c\u044b. \u0422\u0435\u043e\u0440\u0438\u044f \u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f, pages 121\u2013146,",
            "year": 2014
        },
        {
            "authors": [
                "\u0415. \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432 \u0414"
            ],
            "title": "\u041e\u0431 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043a\u043b\u0430\u0441\u0441\u043e\u0432 \u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u043e\u0432",
            "venue": "\u0414\u0438\u0441\u043a\u0440\u0435\u0442. \u043c\u0430\u0442\u0435\u043c.,",
            "year": 2015
        },
        {
            "authors": [
                "A. Bernadotte"
            ],
            "title": "Structural Modification of the Finite State Machine to Solve the Exponential Explosion Problem",
            "venue": "Programmnaya Ingeneria. vol. 13,",
            "year": 2022
        },
        {
            "authors": [
                "A.V. Aho",
                "M.J. Corasick"
            ],
            "title": "Efficient string matching: an aid to bibliographic search",
            "venue": "In Communication of the ACM,",
            "year": 1975
        },
        {
            "authors": [
                "R. De La Briandais"
            ],
            "title": "File Searching Using Variable Length Keys",
            "venue": "In Proceedings of Western Joint Computer Conference. ACM.,",
            "year": 1959
        },
        {
            "authors": [
                "B. Kruskal J"
            ],
            "title": "On the shortest spanning subtree of a graph and the traveling salesman problem",
            "venue": "In Proceedings of the American Mathematical Society,",
            "year": 1956
        },
        {
            "authors": [
                "D. Ficara",
                "S. Giordano",
                "G. Procissi"
            ],
            "title": "An improved DFA for fast regular expression matching",
            "venue": "In ACM SIGCOMM Computer Communication Review,",
            "year": 2008
        },
        {
            "authors": [
                "M. Becchi",
                "P. Crowley"
            ],
            "title": "A-DFA: A Time- and Space-Efficient DFA Compression Algorithm for Fast Regular Expression Evaluation",
            "venue": "In Transactions on Architecture and Code Optimization. ACM.",
            "year": 2013
        },
        {
            "authors": [
                "C. Liu",
                "J. Wu"
            ],
            "title": "Fast Deep Packet Inspection with a Dual Finite Automata",
            "venue": "In IEEE Transactions on Computers,",
            "year": 2013
        },
        {
            "authors": [
                "F. Yu",
                "Zh. Chen",
                "Y. Diao",
                "T.V. Lakshman",
                "R.H. Katz"
            ],
            "title": "Fast and memory-efficient regular expression matching for deep packet inspection",
            "venue": "In Proceedings of the 2006 ACM/IEEE symposium on Architecture for networking and communications systems",
            "year": 2006
        },
        {
            "authors": [
                "J. Rohrer",
                "K. Atasu",
                "J. van Lunteren",
                "C. Hagleitner"
            ],
            "title": "Memory-efficient distribution of regular expressions for fast deep packet inspection",
            "venue": "In Proceedings of the 7th IEEE/ACM international conference on Hardware/software codesign and system synthesis",
            "year": 2009
        },
        {
            "authors": [
                "C. Xu",
                "J. Su",
                "S. Chen"
            ],
            "title": "Exploring efficient grouping algorithms in regular expression matching",
            "venue": "PLoS ONE,",
            "year": 2018
        },
        {
            "authors": [
                "A. Bernadotte",
                "A.V. Galatenko"
            ],
            "title": "Structural automaton design for solving the problem of exponential blowup for one class of regular languages",
            "venue": "Intelligent systems. Theory and applications,",
            "year": 2019
        }
    ],
    "sections": [
        {
            "text": "Keywords Regular Expression \u00b7 Regular Expression Matching \u00b7 Real-time Matching \u00b7 Automata theory \u00b7 telesurgery \u00b7 NIDS \u00b7 cybersecurity"
        },
        {
            "heading": "1 Introduction",
            "text": "Regular expression matching is a search for patterns in discrete data using regular expressions. Regular expression matching is used in cybersecurity tasks, computational biology for interacting sequencing searching, and at any software and hardware analysers of a signal represented by a sequence of symbols or patterns [1, 2, 3, 4, 5, 6, 7].\nThere are tasks for which pattern detection using regular expression matching should be accurate, fast, and carried out on-line. For example, such tasks include the cybersecurity of telesurgical operations, in which surgeons remotely control the operating robotic device [8, 9, 10].\nThe following cyber attacks are typical for the above application: intentional manipulation, intentional modification of control commands, and denial of service.\nThe good news is that signs of the above attacks can be detected in network traffic. Cybersecurity experts compile regular expression databases of characteristic features of malicious code, XSS, Trojan signs, etc. Existing Network Intrusion Detection Systems (NIDS) scan network traffic for malware using these regular expression databases such as Bro and Snort.\nThese NIDS often use finite state automata (FSA) to implement fast traffic analysis. State machines are an efficient and fast way to parse regular expressions.\n\u2217Use footnote for providing further information about author (webpage, alternative address)\u2014not for acknowledging funding agencies.\nar X\niv :2\n30 8.\n10 20\n8v 1\n[ cs\n.F L\nHowever, there is a mathematical problem of an exponentially growing number of states of a finite automaton from the length of regular expressions specific to a certain type of regular expression. The problem of the exponentially growing number of states of the state machine on the length of regular expressions leads to the impossibility of implementing compact hardware for analysing malicious traffic in practice since the memory requirements for storing a state machine that uses existing regular expressions from the Bro and Snort databases, exceed reasonable limits. From a practical point of view, analysing traffic for malware on-line is impossible using classical FSA since the solution has to be either fast or space efficient.\nFSA is the best thought for pattern recognition in NIDS and data mining. Space is usually a more critical issue than time. However, for NIDS, both parameters are essential.\nThe use of this problem in intrusion detection systems is called The Regular expression Denial of Service (ReDoS). The Regular expression Denial of Service (ReDoS) is a Denial of Service attack that exploits a finite automaton\u2019s exponentially growing number of states and makes NIDS works slowly (exponentially related to input size). An attacker can then cause a program using a Regular Expression to enter these extreme situations and then hang remote hardware for a very long time [11].\nThis work is devoted to this problem and its solution. This paper provides the solution for the exponential problem of most regular expressions, which caused severe limitations in NIDS work.\n1.1 Definitions\n1.1.1 Regular languages and regular expressions\nDefinition 1.1. A regular language (event or set) over the alphabet A is defined recursively as follows [13, 14].:\n1. \u2205, {\u03bb} and {a} are regular languages, where \u03bb is an empty word, a \u2208 A;\n2. if M1 and M2 are regular languages, then M1 \u222aM2 union, M1 \u00b7M2 concatenation, and Kleene star M\u22171 are regular languages, where\nM1 \u222aM2 = {\u03b11 \u222a \u03b12|\u03b11 \u2208M1, \u03b12 \u2208M2}, M1 \u00b7M2 = {\u03b11 \u00b7 \u03b12|\u03b11 \u2208M1, \u03b12 \u2208M2},\nM\u22171 = {\u03bb} \u222a {\u03b11 \u00b7 . . . \u03b1n|\u03b1i \u2208M1, i \u2208 1, n, n \u2208 N}.\nRegular languages correspond to regular expressions. Definition 1.2. Regular expression is defined recursively as follows:\n1. \u2205, \u03bb, a are regular expressions, where a \u2208 A;\n2. if R1, R2 are regular expressions, then the (R1 \u222aR2), (R1 \u00b7R2), and (R1)\u2217 are regular expressions.\nRegular expression is a language over the alphabet A\u222a{\u222a, (, ), \u00b7, \u2217}, where the operation \u201c\u2217\u201d has the maximum priority and the operation \u201c\u222a\u201d has the minimum. The syntax and semantics of the regular expressions that are supported by PCRE (Perl Compatible Regular Expressions) are described below:\nIn practice, in the Snort, Zeek, and Cisco databases, regular expressions are represented using the PCRE\u2013 notation (Perl Compatible Regular Expressions) [12]. Here is the PCRE\u2013notation that we will use in the paper:\n\u201c.\u201d is any character; \u201c.*\u201d is 0 or more quantifier; \u201c+\u201d is 1 or more quantifier; \u201c{n}\u201d is n quantifier ; \u201c{n,m}\u201d is form n to m quantifier; \u201c|\u201d is logic \u201cor\u201d; \u201c\u00ac\u201d is logic \u201cnot\u201d; \u201c[\u201d is POSIX character class (only if followed by POSIX syntax);\n\u201c]\u201d is terminates the character class; \u201c[0\u2212 9]\u201dis any decimal digit; \u201c[A\u2212 Za\u2212 z0\u2212 9]\u201dis any decimal digit or letter character.\n1.1.2 Finite state automata\nFinite state automata (FSA), also known as finite state machines (FSM), are used to recognize regular languages by accepting or rejecting a given string (word) of a certain regular language. Definition 1.3. A FSA is a tuple, (A,Q,F, \u03c6), where A is a finite set of input symbols called the input alphabet, Q is a finite set of states (state alphabet), F is a set of accept states F \u2286 Q, \u03c6 is a transition function, \u03c6 : Q\u00d7A\u2192 Q.\nFSAs can be subdivided into some classes. A FSA with a starting state called the initial finite automaton, and it is a 5-tuple (A,Q,B, \u03c6, \u03c8, q0), where q0 is an initial state in which the FSA starts [13, 14].\nA finite state transducer (FST), following the terminology for Turing machines, has input and output tape. Instead of accepting states, this class of FSAs has an output alphabet. Definition 1.4. A FST is a tuple, (A,Q,B, \u03c6, \u03c8), where A is a finite set of input symbols called the input alphabet, Q is a finite set of states (state alphabet), B is a set of accept states B \u2286 Q, \u03c6 is a transition function, \u03c6 : Q\u00d7A\u2192 Q, \u03c8 is an output function, \u03c8 : Q\u00d7A\u2192 B.\nFSAs recognize regular languages. Acceptors (detectors or recognizers) produce binary output, indicating whether or not the received input is accepted. Each state of an acceptor is either accepting or non-accepting.\nAccording to Kleene\u2019s theorem, an event (word, string) over the alphabet A is representable by a finite automaton if and only if it is a regular language [13, 14, 15, 16].\nBoth representations of finite automata FSA and FST are equivalent. The FSA recognizes a regular language by mapping strings (words of the language) into the set of accepting states. In contrast, an equivalent FST recognizes a regular language by mapping strings into the output set {0, 1}.\n1.1.3 Deterministic and non-deterministic finite state automata\nFSAs are classified as deterministic (DFA) or non-deterministic (NFA).\nThe no-ndeterministic finite automaton (NFA) allows jumping over the empty word. It is a set (A,Q,B, \u03c6), where A,Q,B are finite sets: input alphabet, state alphabet, and a set of accepting states B \u2286 Q, \u03c6 is a transition function, \u03c6 : Q\u00d7 {A \u222a \u03bb} \u2192 2Q, \u03c6 returns a set of states. A deterministic finite automaton (DFA) has no \u03bb\u2013transitions, the transitions on the empty word, and all DFA transitions are uniquely defined [13, 14, 15, 16].\nAccording to the theorem on the equivalence of deterministic and nondeterministic finite automata, any language is accepted by some NFA if and only if this language is accepted by some DFA [13, 14, 15, 16]: Theorem 1.1. Let language L \u2286 A\u2217, and suppose L is accepted by NFA N = (A,Q, q0, F, \u03b4). There exists a DFA D = (A,Q \u2032 , q \u2032 0, F \u2032 , \u03b4 \u2032 ) that also accepts L. L(N) = L(D).\nIn addition, there is an algorithm allows to convert any DFA to an equivalent NFA [15, 16].\nBoth types of automata (DFA and NFA) are used in regular expression real-time matching. In the choice of a FSA, time and space complexity are significant.\n1.1.4 Deterministic and non-deterministic complexity\nThe theory of complexity of formal languages posts the question of the optimality of a regular language representation. As applied to regular languages, the classical measures of descriptive complexity are deterministic and non-deterministic complexity [17, 18, 19, 21]. Definition 1.5. The deterministic state complexity (or deterministic complexity or spatial complexity) of a regular language L is the number of states of the minimal DFA recognizing L (the amount of memory). Definition 1.6. The non-deterministic state complexity of a regular language L is the smallest number of transitions of a NFA recognizing L.\n\u0420\u0438\u0441. 1: The exponential blow-up problem of the {(. \u2217 ab. \u2217 cd) \u222a (. \u2217 ef. \u2217 gh)} regular language over the alphabet {a, b, c, d, e, f, g, h}. Source: [26]\nDefinition 1.7. The non-deterministic transition complexity (or time complexity) of a regular language L is the smallest number of states of a NFA recognizing L (corresponding to the clock rate).\nThe transition complexity gives NFAs a more realistic complexity measure than the number of states because the number of transitions determines the size of a NFA. It is generally accepted that the calculation of the value of the transition function of an automaton has constant complexity. It comes down to retrieving the value from memory.\nWhile DFAs can be efficiently minimized, the minimization of NFAs is known to be PSPACE-complete [20]. NFAs have optimal spatial complexity, but time complexity can be insufficient for application. The NFAs spatial complexity is linear in regex length. At the same time, the processing time of one character of the input word is generally also linear in the length of the regular expression.\nDFAs have optimal time complexity, but the number of states (spatial complexity) can grow exponentially with the length of the regular expression.\nWhen passing from a NFA to a DFA, the time complexity of processing the input symbol becomes constant; on the other hand, according to Lupanov\u2019s theorem, if the input alphabet contains at least two symbols, the power of the set of states, in general, exponentially increases [13, 14, 22].\n1.1.5 Exponential blow-up problem\nIn applications with real-time regular matching, there is a problem of the exponentially growing DFA states. The exponentially growing accepting DFA states number depending on the length of the regular expression is called the exponential blow-up problem [13, 14, 17, 22, 23, 24].\nThere are signs that cause the exponential blow-up problem: \u201c .+\u201d, \u201c .\u2217\u201d, \u201c .{n} \u201d, \u201c [\u00acai]{n}, \u201c .{n,m} \u201d, and \u201c[\u00acai]{n,m}\u201d, where ai is a word, n,m \u2208 N [17, 23, 24, 25]. Special attention is paid to the exponential blow-up problem for the \u22c3n i=1 . \u2217 \u03b1i. \u2217 \u03b2i.\u2217 language, where \u03b1i, \u03b2i\nare non-empty words, and \u22c3n\ni=1 . \u2217Ri. \u2217Ri\u2032 .\u2217 language, where Ri, Ri\u2032 are regular excretions. It is known that, in the general case, this regular language requires an exponential (in n) number of states of a DFA [29].\nAn illustrative example demonstrating the exponential blow-up problem for the \u22c3n\ni=1 . \u2217 \u03b1i. \u2217 \u03b2i.\u2217 language is presented by colleagues (Fig. 1) [26].\nIt is known that regular languages can be expressed with different regular expressions. For example, the language L over the finite alphabet A,A = {a, b, ..., z, A,B, ..., Z} can be written like this regular expression R1 = .{10, 20} or like this one R2 = [a|b|...|z|A|B|...|Z]{10, 20} or like this one R2 = [a\u2212Z]{10, 20}. However, repetitions such as the Kleene star or {k,m}, {k} in PCRE\u2013notation are valid as signs that cause the exponential blow-up.\n1.2 Exponential Blow-up Problem Solving Approaches Review\nThere are three main approaches to solving this problem using FSA: regular language restriction specified by experts, regular language, and FSA modification.\n1.2.1 Regular language restriction\nThe regular language restriction method involves the expert selection of regular expressions, which reduces the number of states of a given FSA. The disadvantage of this approach is low automation and labour intensity.\n1.2.2 Regular language modification Approaches\nRegular language modification. This method reduces FSA complexity, which is significant from a practical point of view [27]. However, this approach results in Type I (false-positive) errors, the so-called regular language extension problem, or Type II (false-negative) errors in language matching. For example, the Exponential Blow-up Problem arises when regular expressions are combined as follows:\u22c3n i=1 .\u2217R2i\u22121.\u2217R2i.\u2217, i \u2208 1, n [27, 28]. To reduce the states number of the FSA recognizing \u22c3 .\u2217Ri.\u2217Rj .\u2217, i, j \u2208\n1, n language Aleksandrov [29] proposes to extend the regular language \u22c3n\ni=1 . \u2217R2i\u22121. \u2217R2i.\u2217 to the language (.\u2217(R1|R3).\u2217(R2|R4).\u2217)\u222a( \u22c3n i=3 .\u2217R2i\u22121.\u2217R2i.\u2217). The new FSA recognizing (.\u2217(R1|R3).\u2217(R2|R4).\u2217)\u222a( \u22c3n i=3 .\u2217\nR2i\u22121.\u2217R2i.\u2217) may accept words not from the language \u22c3n\ni=1 .\u2217R2i\u22121.\u2217R2i.\u2217. However, it will have no more, and in some cases noticeably fewer states than an FSA that accepts the language \u22c3n i=1 .\u2217R2i\u22121.\u2217R2i.\u2217 [27, 28, 29].\n1.2.3 FSA modification\nThe FSA modification approach can be implemented as FSA compression approaches and FSA Structural modifications [30, 31].\n1.2.4 FSA Compression Approaches\nMost compression methods are based on adding non-deterministic transitions to a DFA that recognizes a given language [31].\nIn 1975, Alfred Aho and Margaret Corasick developed an algorithm that searches for words over the alphabet A from a given dictionary in a string. The algorithm builds a modified initial DFA based on a prefix tree [32, 33]. Compression is done through the use of \u201cerror jumps\u201d that are not present in the pre-built prefix tree. For each state, it is necessary to store information about only two outgoing transitions: about a deterministic transition along the corresponding symbol from the alphabet A (the transition corresponds to the transition of the prefix tree) and about the transition in the case \u201cotherwise\u201d. This modification of the DFA makes it possible to reduce the number of transitions, leaving the number of states of the original DFA intact.\nThe computational complexity of the Aho-Corasick algorithm directly depends on the data structure. Spatially, the Aho-Corasick FSA with error transitions has \u03a3ni=1|wi| states, where wi is a word from the set of recognizable words, and the number of transitions is reduced from |A| \u00d7 |Q| of the original DFA up to 2\u03a3ni=1|wi| in the worst case scenario for the Aho-Corasick FSA with error transitions.\nAn evolution of the Aho-Corasick algorithm is an algorithm that uses regular expressions with common prefixes instead of string (Fig. 2) [38].\nHowever, this evolution to regular expressions was carried out in more detail by Kumar et al. and presented as NFA with delays (D2FA) [1, 2, 3]. Like Aho-Corasick NFA with error transitions, NFA with delays allows reducing the transition table without affecting the number of states (Fig. 3).\nThe algorithm for constructing an optimal NFA with delays begins with constructing an undirected graph. Then, a set of spanning trees (using the Kruskal algorithm is constructed from the obtained undirected graphs [34]. When constructing a D2FA, such a characteristic as the longest path consisting exclusively of default transitions (\u201cthe longest \u03b4-path\u201d) is considered. When choosing an automaton, preference is given to an automaton with the minimum given characteristic from equivalent NFA with delays. The length of the \u03b4-path is one of the parameters that limit the efficiency of compression and the speed of D2FA, so when building a tree, diameter is a restriction. However, building a spanning tree that satisfies the maximum diameter limitation is NP-hard.\n\u0420\u0438\u0441. 2: The Aho-Corasick based algorithm that uses regular expressions with common prefixes. The modified DFA accepts . \u2217AB(CD|AB) language. Source: [38]\n\u0420\u0438\u0441. 3: DFA and equivalent NFA with delays (D2FA). Source: [1]\nThe application of this approach to reduce the number of transitions through the construction of a NFA with delays in practice (based on Cisco System 2008, Snort 2008, Bro NIDS 2008) showed that the reduction in the number of transitions could reach 99% of the initial number of transitions [1, 2, 3].\nA continuation of the idea of NFA with delays (D2FA) is reducing the transition table and, thus, reducing required memory. The idea of Ficara and co-authors of the D2FA modification called \u03b4-FA, is that for each state, not all transition values are stored in the transition table, but only those that differ from the parent state (if any) (Fig. 4) [35].\nAuthors Michela Bechi and Patrick Crowley came up with an algorithm (called \u201cA Amortized time/bandwidth overhead DFAs\u201d, or A-DFA for short) that exploits the transition redundancy of a recognizing FSA. The redundancy was noticed empirically by the authors and consisted in the fact that most of the states of the DFA, built on data sets of signature databases of intrusion detection systems, had similar sets of outgoing transitions [36]. This was previously noted in the work of Kumar et al. [1, 2, 3]. In their work, the A-DFA authors improved the delayed DFA (D2FA) solution proposed by Kumar et al. in 2006 [1].\nThe A-DFA algorithm of Michela Becchi and Patrick Crowley uses 2N transitions and N(k+1)/k transitions in the worst case to process a string of length N , where k is a predefined value, k \u2208 N [36]. It is shown that, in general, A-DFA provides improved compression over D2FA. As for the time complexity asymptotics, the algorithms for constructing D2FA and A-DFA have time bounds O(n2 log2 n) and O(n2), respectively.\nThe construction of a multiautomaton (or multistride DFA) is a fundamentally different approach in terms of FSA compression in comparison with the algorithms that were considered above. Compression methods using regular expression grouping are united by the strategy not to adapt to the initial structure of the FSA that recognizes the language, but to select independent (or conditionally independent) subsets in the language. This subsetting allows to build a DFA for each subset and combining the resulting DFAs into a single NFA, while reducing memory requirements (Fig. 5) [38, 39, 40].\n\u0420\u0438\u0441. 4: \u03b4-FA with the reduced transition table. Source: [35]\n\u0420\u0438\u0441. 5: Multistride DFA. Source: [38]\n\u0420\u0438\u0441. 6: DFA with fast and slow memory. Source: [1]\nFinding the best memory-efficient grouping of regular expressions is an NP-hard problem. However, the regular expressions grouping for multiautomaton allows multithreading for parallel computing, using each thread for each selected group of interacting regular expressions.\nIn practice, in intrusion detection systems and network traffic analysis systems, this algorithm has achieved a memory reduction by order of magnitude compared to the classical DFA [38]. Thus, the upper bound on the number of states of such a multiautomatic machine is O(m2l), where m is the number of regular expressions Ri, from the language \u22c3m i=1Ri, where l = max(|Ri|).\n1.2.5 FSA Structural Modification Approaches\nThe most common structural elements that expand the capabilities of the FSA are counters and memory elements that store certain properties of the FSA. This section provides a list of existing solutions, the main idea of which is the transition from an abstract FSA to a structural FSA that combines the abstract part stored in memory and various additives such as bit arrays, circuit, and counters [30, 41].\nIn this case, the space complexity is defined as a memory size for the abstract part and the circuit complexity. The exponential number of states is moved into the structural part so that the overall complexity remains acceptable.\nThe most common structural elements that extend the capabilities of the FSAs are counters and memory elements that store certain grouped states.\nDealing with malicious traffic recognition, Kumar et al. [1] introduce several concepts that characterize the shortcomings of using the classical DFA in the context of the exponential blow-up problem. Thus, the authors call \u201cinsomnia\u201d the wasteful storage of all states of the DFA, regardless of the probability of their activation. Indeed, when analysing traffic, most states are rarely activated, and the probability of activating a state decreases with distance from the initial state of the DFA. The authors propose to divide the regular expression into the prefix and suffix parts, determined by the probability of the DFA transition. The authors propose to store transitions to high-probability DFA states in fast memory, while transitions to low-probability states are stored in the \u201csleep state\u201d (slow memory). Switching from fast memory to slow memory should be carried out if necessary by trigger. The trigger is the recognition of the prefix by the fast part of the DFA (Fig. 6).\nThe peculiarity of such state storage gives a benefit in terms of fast memory consumed while accessing slow memory slows down the operation of this construction compared to the classical DFA. However, a preliminary statistical analysis of traffic can reduce the need to access slow memory. Thus, the construction makes it possible to reduce the memory consumed without significant speed losses [1, 2].\nThe issue of separating states into probable and improbable ones authors propose to solve empirically by considering the probability distribution of input network traffic. Thus, using the existing database of regular expressions marking malicious traffic is not enough. It is required to \"train\"the system on the collected dataset, where the traffic will be labeled according to the frequency of states activation. This aspect complicates the use of the solution.\n\u0420\u0438\u0441. 7: DFA and equivalent History based Finite Automaton accepting (. \u2217 ab[\u00aca] \u2217 c) \u222a (. \u2217 def) language. Source: [2]\nThe inability of the FSA to remember \u201cvisited states\u201d Kumar et al. called \u201camnesia\u201d and suggested storing checking bits in addition to the current state of the FSA [2].\nThe automaton with this bits modification is called History based Finite Automaton or H-FA for short [2]. Formally, a DFA with memory is represented by a set, H \u2212 FA = (A,Q, q0, QB , \u03c6,H), where A is the input alphabet; Q is the alphabet of states; q0 is the initial state; QB is the set of accepting states; H is a bit array; \u03c6 is the transition function, \u03c6 : A\u00d7Q\u00d7H \u2192 Q\u00d7H. The bit array takes the value equal to 1, if the transition to this state was previously made, and the value equal to 0, if there was no such transition (Fig. 7).\nAnother Structural Modification Approach is counting structural elements. Counters complement FSA that matches expressions like R{k} and R{n, k}, where R is a regular expression (Fig. 8) [26]. The practical application of DFA with memory and counters on existing datasets of intrusion detection systems led to a decrease in the number of states by an order of magnitude compared to the classical DFA [1, 2, 3].\nOne more Structural Modification Approach is a DFA and NFA combination. The combination of DFA and NFA provides a tangible advantage for solving the exponential blow-up problem by combining the positive properties of determinism and non-determinism in terms of saving resources and time. There are several proposals for using this combination [36, 37]. Despite many proposed solutions, solutions still need to be improved in front of some regular languages (( \u22c3n i=1 . \u2217 Ri) \u222a ( \u22c3n i=1 . \u2217 R \u2032 i).\u2217 language, where Ri, R \u2032 i are regular expressions), as indicated in the section\n\u0420\u0438\u0441. 8: The counting structural elements for solving the {n}, {n,m}- related exponential blow-up problem. Source: [26]\nwhere we described the exponential blow-up problem. The proposed solutions do not make it possible to correctly and quickly check whether a word belongs to a given type of language and run into either inefficiency or the language extension problem described above. In the next section, we provide a universal solution for this type of language."
        },
        {
            "heading": "2 FSA modification Approach: DFA with counters solves exponential blow-up problem",
            "text": "This part presents the author\u2019s solution to the exponential blow-up problem by using a FSA with additions of structural elements (Fig. 9).\nPresented DFA construction solves the exponential space complexity by decomposing an automaton accepting a given language into two components: an \u201cabstract\u201d component, which complexity is defined as the amount of required memory, and a \u201cstructural\u201d component, which complexity is defined as the number of elements in the schema. The DFA construction accepts the \u22c3n i=1 . \u2217Ri. \u2217 \u03b2i.\u2217 regular language, where Ri is a regular expression that does not contain signs that cause the exponential blow-up problem, \u03b2i is a non-empty word over the alphabet A.\nThe construction consists of three blocks. Block 1 is a DFA accepting a language ( \u22c3n i=1 . \u2217Ri) \u222a ( \u22c3n\ni=1 . \u2217 \u03b2i), where Ri is a regular expression that does not contain signs that cause the exponential blow-up problem, \u03b2i is a non-empty word over the A alphabet. The DFA can be constructed by applying the Aho\u2013Corasick algorithm, memory-efficient regular expressions grouping algorithm, and minimization of automata algorithm [13, 14, 32? ].\nIf a word from the ( \u22c3n\ni=1 . \u2217Ri) language is accepted by the block 1, the counters of the block 2 with preset values are turned on.\nThe block 2 counts the lengths of the words of the ( \u22c3n\ni=1 . \u2217 \u03b2i) language. It is these counters that ensure that there is no language extension.\nThe block 3 consists of a layer of n+ 1 logic gates (n logic gates of the \u201cconjunction\u201d type and 1 logic gate of the \u201cdisjunction\u201d type) and the next layer of n+ 1 single-pole single-throw (SPST) switches.\nIf the prefix of a word or a whole word from language ( \u22c3n\ni=1 . \u2217 \u03b2i) is a suffix of a word from language ( \u22c3n\ni=1 . \u2217 \u03b1i), then it is the counters of the block 2 and logical elements of the block 3 that make it possible not to accept such a word.\nLet us prove the correctness theorem. Theorem 2.1 (the correctness theorem). The presented construction correctly accepts the regular language\u22c3n i=1 . \u2217Ri. \u2217 \u03b2i.\u2217, where Ri is a regular expression that does not contain signs that cause the exponential blow-up problem, \u03b2i is a non-empty word over the alphabet A. The i-th output of the construction is equal to 1 if and only if the input word corresponds to the i\u2212th summand (. \u2217Ri), and the n+ 1-st output is equal to 1 if and only if the word belongs to the . \u2217Ri. \u2217 \u03b2i.\u2217 language.\nProof. Suppose \u03b3 is a word from the regular language \u22c3n\ni=1 . \u2217Ri. \u2217 \u03b2i.\u2217. Hence \u03b3 \u2208 . \u2217Ri. \u2217 \u03b2i.\u2217, \u03b3 is of the form \u03b4\u03b4Ri \u03b4 \u2032 \u03b2i\u03b4 \u2032\u2032 , where \u03b4 does not contain word from Ri as a subword, \u03b4 \u2032 does not contain \u03b2i as a subword, \u03b4Ri corresponds to Ri.\n\u0420\u0438\u0441. 9: DFA with counters construction that accepts the ( \u22c3n i=1 . \u2217 Ri) \u222a ( \u22c3n\ni=1 . \u2217 \u03b2i) language, where Ri is a regular expression that does not contain signs that cause the exponential blow-up problem, \u03b2i, \u03b3i are non-empty words over the alphabet A.. Block 1 is a DFA, that accepts the language ( \u22c3n i=1 .\u2217Ri)\u222a( \u22c3n i=1 .\u2217\u03b2i). In block 2 there are ti, t\u2032i, t\u2032\u2032i , t \u2032\u2032\u2032 triggers and c1, ..., cn counters, i \u2208 1, n .\nThis means that after the word \u03b4\u03b4Ri is fed to the input, counter number i starts counting, and by the time \u03b4\u03b4Ri \u03b4 \u2032 \u03b2i is finished, firstly, the i-th output of the block 2 becomes equal to one, and, secondly, 2n + i-th output of the block 1 becomes equal to 1. Consequently, the output of the i-th conjunction of the block 3 becomes equal to 1 and it will be saved by the i-th trigger.\nConversely, let the i-th output of block 3 be equal to 1. Consider the moment the value changed from 0 to 1 for the first time. Then at this moment, both inputs of the i-th conjunction of block 3 became equal to one. This means that the input word is \u03b4\n\u2032\u2032 \u03b2i, and at least |\u03b2i| steps ago, the word had the form \u03b4\u03b4Ri . Therefore, the\ninput word is \u03b4\u03b4Ri \u03b4 \u2032 \u03b2i and belongs to the regular language . \u2217Ri. \u2217 \u03b2i.\u2217. After this moment, the output will remain equal to 1, while any word . \u2217 \u03b4\u03b4Ri \u03b4 \u2032 \u03b2i.\u2217 also belongs to the language \u22c3n i=1 . \u2217Ri. \u2217 \u03b2i.\u2217.The statement about n+ 1 output follows from the statement about the first n outputs.\nHence proved.\nTheorem 2.2 (theorem on the absence of an exponential blow-up). For language recognition, \u22c3n\ni=1 .\u2217Ri.\u2217\u03b2i.\u2217, where Ri is regular expression that does not contain signs that cause the exponential blow-up problem and \u03b2i is non-empty word, the presented construction requires O(mn(log2m+ n)) bits of memory to store the diagrams of block 1, and O(n log2m) elements to implement blocks 2 and 3, where m is the maximum length of the regular expression Ri and \u03b2i word.\nProof. Let us look at the first block. The minimal automata algorithm constructs a FSA with the number of states estimated as (mn), where m is the maximum length of the regular expression Ri and \u03b2i word. The transition diagram requires |A| \u00d7 |Q| cells of length ]log2|Q|[. Given that the cardinality of the alphabet A is a constant, block 1 requires O(mn log2(mn)) memory bits to store the transition diagram.\nThe output has 2n dimension; therefore, it is needed |A| \u00d7 |Q| cells of length 2n to store the output function diagram. That is, O(mn2). Altogether, for both diagrams it requires O(mn(log2(mn) + n)) memory bits or O(mn log2m+mn 2). Thus, block 1 requires O(mn(log2m+ n)) memory bits to store the diagrams.\nLet us look at the second block. It consists of a linear in n number of triggers and counters. The trigger has constant complexity; the counter is logarithmic in m, where m is the maximum length of the regular expression Ri and \u03b2i word. As a result, we get the complexity O(n log2m).\nFinally, the third block is linear in n and constant in m. Thus, 2 and 3 blocks have the structural complexity of order O(n log2m).\nHence proved.\n2.1 Multi extension of the DFA with counters The construct naturally extends to the following languages: \u22c3n\ni=1 .\u2217Ri.\u2217\u03b2i.\u2217\u03b3i.\u2217 ...\u03c9i.\u2217, where Ri is a regular expression that does not contain signs that cause the exponential blow-up problem, \u03b2i, \u03b3i, ..., \u03c9i are non-empty words over the alphabet A. The modified block 1 accepts ( \u22c3n i=1 .\u2217Ri)\u222a( \u22c3n i=1 .\u2217\u03b2i)\u222a( \u22c3n i=1 .\u2217\u03b3i)\u222a...\u222a( \u22c3n i=1 .\u2217\u03c9i), where Ri is a regular expression that does not contain signs that cause the exponential blow-up problem, \u03b2i, \u03b3i, ... ,\u03c9i are non-empty words over the alphabet A. For each, except for the first \u22c3n i=1 . \u2217Ri, its own block 2 with counters is created (Fig. 10).\n2.2 Quantifier extension of the DFA with counters The extended construction accepts \u22c3n i=1 . \u2217Ri[\u00ac\u03b3i]{ki,mi}\u03b2i.\u2217 and \u22c3n\ni=1 . \u2217Ri[\u00ac\u03b3i]{ki}\u03b2i.\u2217 languages, where Ri is a regular expression that does not contain signs that cause the exponential blow-up problem and \u03b2i, \u03b3i are non-empty words over the alphabet A, the values in the curly brackets set the number of repetitions (for {ki}) and the interval {ki,mi} of repetitions of the words other than \u03b3i (See Fig. 11). In the extended construction, block 1 accepts the language ( \u22c3n i=1 . \u2217Ri) \u222a ( \u22c3n i=1 . \u2217 \u03b2i) \u222a ( \u22c3n i=1 . \u2217 \u03b3i), where Ri is a regular expression that does not contain signs that cause the exponential blow-up problem, \u03b2i, \u03b3i are non-empty words over the alphabet A.\nFrom the 1, n outputs of the block 1, the signal goes to the block 1a corresponding to the \u03b1i. In the block 1a, counters with preset values ki, mi, m \u2032\ni are switched on, where ki, mi corresponds to the values in curly brackets of the . \u2217Ri[\u00ac\u03b3i]ki,mi. \u2217 \u03b2i.\u2217, and m \u2032\ni corresponds to the value (mi + |\u03b2i|+ 1). The i-th input of the block 1a is switched on to receive a signal from the 2n+ i-th output of the block 1.\nThe block 2 counts the lengths of the words of the \u22c3n\ni=1 . \u2217 \u03b2i. The block 3 consists of a layer of n+ 1 logic gates (n \u201cconjunctions\u201d and 1 \u201cdisjunction\u201d) and the next layer of the n+ 1 SPST switches.\n2.3 Double counting extension of the DFA with counters\nThe proposed DFA with counters design can be additionally equipped with counting structural elements in block 1 (Fig. 9). For example, counters that were proposed in the work of colleagues to avoid the exponential blow-up of the {n}, {n,m} regular signatures [26]. This double counting extension allows solving the exponential explosion problem for a class of languages, such as: (\nn\u22c3 i=1 . \u2217Ri. \u2217 \u03b2i. \u2217 \u03b3i. \u2217 ...\u03c9i. \u2217 )\u22c3( n\u22c3 i=1 . \u2217Ri[\u00ac\u03b3i]{ki,mi}\u03b2i. \u2217 . \u2217 \u03b3i. \u2217 ...\u03c9i. \u2217 ) , (1)\nwhere Ri is a regular expression that does not contain wild-card signs \u201c.*\u201d and \u201c.+\u201d and can contain {n}, {n,m} counters, \u03b2i, \u03b3i, ..., \u03c9i are non-empty word over the alphabet A, n, k,m \u2208 N, i \u2208 1, n.\n\u0420\u0438\u0441. 10: DFA with counters construction, that accepts the \u22c3n\ni=1 . \u2217Ri. \u2217\u03b2i. \u2217 \u03b3i. \u2217 ...\u03c9i.\u2217 language, where Ri is a regular expression that does not contain signs that cause the exponential blow-up problem, \u03b2i, \u03b3i, ... ,\u03c9i are non-empty words over the alphabet A. Block 1 is a DFA, that accepts the language ( \u22c3n i=1 . \u2217Ri) \u222a ( \u22c3n i=1 . \u2217\n\u03b2i)\u222a ( \u22c3n i=1 . \u2217 \u03b3i)\u222a ...\u222a ( \u22c3n i=1 . \u2217\u03c9i). In block 2 there are ti, t\u2032i, t\u2032\u2032i , t \u2032\u2032\u2032 triggers and c1, ..., cn counters, i \u2208 1, n .\n\u0420\u0438\u0441. 11: The extended DFA with counters construction. Block 1 is a DFA that accepts the language ( \u22c3n i=1 . \u2217Ri) \u222a ( \u22c3n i=1 . \u2217 \u03b2i) \u222a ( \u22c3n\ni=1 . \u2217 \u03b3i), where Ri is a regular expression that does not contain signs that cause the exponential blow-up problem, \u03b2i, \u03b3i are non-empty words over the alphabet A. Block 1a is a counting block. ti, t\u2032i, t\u2032\u2032i , t \u2032\u2032\u2032 are triggers, i \u2208 1, n c1, ..., cn are counters in a counting block 2.\nMoreover, the theorem 2.2 on the absence of an exponential blow-up remains true.\nLet us look at the first block. The block 1 requires O(mn(log2m+n)) memory bits to store the DFA diagrams and a linear in n number of triggers and counters with O(n log2m) structural complexity, where m is the maximum length of the regular expression Ri and max(|\u03b2i|, |\u03b3i|, ...|\u03c9i|) non-empty words. Altogether, block 1 requires O(mn(log2m+ n)) elements."
        },
        {
            "heading": "3 Conclusion",
            "text": "In solving the regular expression matching problem, some ideas and algorithms are exceptionally successful, which became the progenitors of entire directions in signature analysis.\nFirst, such findings include the Aho-Corasick searching algorithm with error transitions. The algorithms can significantly reduce the memory requirements in practice. However, the algorithms that use transitions in case of an error do not solve the exponential blow-up problem in the general case.\nSecondly, building a multi-automatic machine based on a grouping of interacting regular expressions initiated parallel computing for regular expression matching. However, despite a decent number of ideas, regular expression grouping algorithms remain an NP-complete problem and do not guarantee a solution to the exponential blow-up problem in the general case.\nDespite many proposed solutions, solutions still need to be improved in front of some regular languages (such as (\u22c3n i=1 . \u2217Ri. \u2217 \u03b2i. \u2217 \u03b3i. \u2217 ...\u03c9i. \u2217 )\u22c3(\u22c3n i=1 . \u2217Ri[\u00ac\u03b3i]{ki,mi}\u03b2i. \u2217 . \u2217 \u03b3i. \u2217 ...\u03c9i. \u2217 ) , where Ri are regular\nexpressions, \u03b2i, \u03b3i, ..., \u03c9i are non-empty word over the alphabet A, n, k,m \u2208 N, i \u2208 1, n), which cause the exponential blow-up problem.\nThis paper provides a theoretical and hardware solution to the exponential blow-up problem for the complicated classes of regular languages, which caused severe limitations in Network Intrusion Detection Systems work.\nThe article supports the solution with theorems on correctness and complexity.\n\u0421\u043f\u0438\u0441\u043e\u043a \u043b\u0438\u0442\u0435\u0440\u0430\u0442\u0443\u0440\u044b [1] Kumar S., Chandrasekaran B., Yu F., Crowley P. Turner J. Algorithms to Accelerate Multiple Regular\nExpressions Matching for Deep Packet Inspection. In ACM SIGCOMM Computer Communication Review, vol 36, issue 4, pages 155\u2013164, 2006\n[2] Kumar S., Chandrasekaran B., Turner J., Varghese G. Curing regular expressions matching algorithms from insomnia, amnesia, and acalculia. In ANCS \u201907 Proceedings of the 3rd ACM/IEEE Symposium on Architecture for networking and communications systems, pages 155\u2013164, 2008.\n[3] Kumar S. A Thesis on Accelerationof Network Processing Algorithms. Doctor of Science Thesis, Washington University, Saint Louis, Missouri, 2008.\n[4] C. L. Nehaniv and E. Antonova. \u201cSimulating and reconstructing neurodynamics with Epsilon-automata applied to electroencephalography (EEG) Microstate Sequences\u201d. 2017 IEEE Symposium Series on Computational Intelligence (SSCI), Honolulu, HI, USA, 2017, pp. 1-9, doi: 10.1109/SSCI.2017.8285438.\n[5] C. L. Nehaniv and E. Antonova. Simulating and Reconstructing Neurodynamics with Epsilon-Automata Applied to Electroencephalography (EEG) Microstate Sequences. arXiv:1710.02387v1 [q-bio.NC] 29 Sep 2017\n[6] Bernadotte A., Kumar R., Winblad B., Pavlov P.F. In silico identification and biochemical characterization of the human dicarboxylate clamp TPR protein interaction network. FEBS Open Bio, vol 8, pages 1830\u20131843, 2018.\n[7] Podkolzin A., Ivanovic L., Bolotov A., Grinchuk M., Afonin S. Impulse Regular Expression Matching. US 2014/0136465 A1, pages 1\u201311, 2014\n[8] Al Tariq Sheik, Ugur Ilker Atmaca, Carsten Maple, Gregory Epiphaniou. Challenges in Threat Modelling of New Space Systems: A Teleoperation Use-Case. Advances in Space Research, 2022 DOI: 10.1016/j.asr.2022.07.013\n[9] I. Menshikov and A. Bernadotte. Intelligent Robotic Motion Copying System LevshAi for Neurosurgical Endovascular Operations with Haptic Feedback and Preoperative Personalized Simulation. In 2022 IEEE International Conference on Cyborg and Bionic Systems (CBS), Wuhan, China, 2023, pp. 386-391, doi: 10.1109/CBS55922.2023.10115398.\n[10] A. Bernadotte Cyber Security for Surgical Remote Intelligent Robotic Systems. 2023 9th International Conference on Automation, Robotics and Applications (ICARA), Abu Dhabi, United Arab Emirates, 2023, pp. 65-69, doi: 10.1109/ICARA56516.2023.10126050.\n[11] OWASP: Regular expression Denial of Service. https://owasp.org/www-community/attacks/\n[12] Perl regular expressions. http://perldoc.perl.org/perlre.html The document describes the syntax of regular expressions in Perl.\n[13] Kudryavtsev V. B., Aleshin S. V., Podkolzin A. S. Introduction to Automata Theory. In Nauka, Moscow, 1985, (in Russian).\n[14] \u041a\u0443\u0434\u0440\u044f\u0432\u0446\u0435\u0432 \u0412. \u0411., \u0413\u0430\u0441\u0430\u043d\u043e\u0432 \u042d. \u042d., \u041f\u043e\u0434\u043a\u043e\u043b\u0437\u0438\u043d \u0410. \u0421. \u041e\u0441\u043d\u043e\u0432\u044b \u0442\u0435\u043e\u0440\u0438\u0438 \u0438\u043d\u0442\u0435\u043b\u043b\u0435\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0445 \u0441\u0438\u0441\u0442\u0435\u043c In\u041c\u0430\u043a\u0441 \u041f\u0440\u0435\u0441\u0441, \u041c\u043e\u0441\u043a\u0432\u0430, 2016.\n[15] Hopcroft J., Motwani R., Ulman J. Introduction to the Theory of Automata. Languages and Computing, Moscow, Williams, 528 p, 2017.\n[16] Rabin M.O., Scott D. Finite automata and their decision problems. In IBM J. Research and Development, vol 3, issue 2, pages 115\u2013125, 1959.\n[17] Salomaa K. Descriptional Complexity of Nondeterministic Finite Automata. In: Harju, T., Karhuma\u0308ki, J., Lepisto\u0308, A. (eds) Developments in Language Theory. DLT 2007. Lecture Notes in Computer Science, vol 4588. Springer, Berlin, Heidelberg. 2007.\n[18] Chamberlain B.L. Graph Partitioning Algorithms for Distributing Workloads of Parallel Computations. In University of Washington Technical Report UW-CSE-98-10-03, pages 1\u201332, 1998.\n[19] Brookshear, J. Glenn. Theory of Computation: Formal Languages, Automata, and Complexity. Redwood City, California: Benjamin/Cummings Publish Company, Inc. ISBN 978-0-8053-0143-4, 1989.\n[20] Jiang T., Ravikumar B. Minimal NFA problems are hard. In SIAMJ.Computing22, pages 1117\u20141141, 1993.\n[21] Meyer A. R., Fischer M. J. Economy of description by automata, grammars, and formal systems. In Proceedings of the Annual Symposium on Foundations of Computer Science, pages 188\u2013191, 1971.\n[22] \u041b\u0443\u043f\u0430\u043d\u043e\u0432 \u041e.\u0411. \u041e \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0438 \u0434\u0432\u0443\u0445 \u0442\u0438\u043f\u043e\u0432 \u043a\u043e\u043d\u0435\u0447\u043d\u044b\u0445 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u043e\u0432. \u041f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u043a\u0438\u0431\u0435\u0440\u043d\u0435\u0442\u0438\u043a\u0438, \u0424\u0438\u0437\u043c\u0430\u0442\u0433\u0438\u0437, issue 9, pages 321\u2013326, 1963.\n[23] \u041c\u0430\u0441\u043b\u043e\u0432 \u0410. \u041d. \u041e\u0446\u0435\u043d\u043a\u0438 \u0447\u0438\u0441\u043b\u0430 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0439 \u043a\u043e\u043d\u0435\u0447\u043d\u044b\u0445 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u043e\u0432. \u0414\u043e\u043a\u043b\u0430\u0434\u044b \u0410\u043a\u0430\u0434\u0435\u043c\u0438\u0438 \u043d\u0430\u0443\u043a \u0421\u0421\u0421\u0420. \u0422. 194 (6). \u0421. 1266\u20131268, 1970.\n[24] \u041c\u0430\u0441\u043b\u043e\u0432 \u0410. \u041d. \u041e \u0446\u0438\u043a\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0445 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430\u0445 \u044f\u0437\u044b\u043a\u043e\u0432. \u041f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438. \u0422. 9 (4). \u0421. 81\u201387, 1973.\n[25] Backurs A., Indyk P. Which Regular Expression Patterns are Hard to Match? arXiv:1511.07070, 2016 [26] Smith R., Estan C., Jha S. XFA: Faster Signature Matching with Extended Automata. In IEEE\nSymposium on Security and Privacy, pages 187\u2013201, 2008 [27] \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432 \u0414. \u0415. \u041e\u0431 \u0443\u043c\u0435\u043d\u044c\u0448\u0435\u043d\u0438\u0438 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u043d\u043e\u0439 \u0441\u043b\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0437\u0430 \u0441\u0447\u0435\u0442 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u044f \u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u043e\u0432.\nIn \u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u0430\u044f \u0438\u043d\u0436\u0435\u043d\u0435\u0440\u0438\u044f, pages 26\u201334, issue 11, 2014. [28] \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432 \u0414. \u0415. \u041e\u0431 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u043d\u043e\u0439 \u0441\u043b\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0440\u0430\u0441\u043f\u043e\u0437\u043d\u0430\u0432\u0430\u043d\u0438\u044f \u043a\u043b\u0430\u0441\u0441\u0430 \u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u043e\u0432.\nIn \u0418\u043d\u0442\u0435\u043b\u043b\u0435\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0435 \u0441\u0438\u0441\u0442\u0435\u043c\u044b. \u0422\u0435\u043e\u0440\u0438\u044f \u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f, pages 121\u2013146, vol 18, issue 4, 2014. [29] \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432 \u0414. \u0415. \u041e\u0431 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043a\u043b\u0430\u0441\u0441\u043e\u0432 \u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u043e\u0432. \u0414\u0438\u0441\u043a\u0440\u0435\u0442. \u043c\u0430\u0442\u0435\u043c.,\n27:2 (2015), 3\u201321; Discrete Math. Appl., 25:6, 323\u2013337, 2015. [30] Bernadotte A. Structural Modification of the Finite State Machine to Solve the Exponential Explosion\nProblem. Programmnaya Ingeneria. vol. 13, no. 9, pp. 449\u2013461, 2022. [31] \u0410. \u0411\u0435\u0440\u043d\u0430\u0434\u043e\u0442\u0442 \u041c\u043e\u0434\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f \u043a\u043e\u043d\u0435\u0447\u043d\u043e\u0433\u043e \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0430 \u0447\u0435\u0440\u0435\u0437 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u043e\u0432 \u0441\u0436\u0430\u0442\u0438\u044f. \u0418\u043d\u0442\u0435\u043b\u043b\u0435\u043a-\n\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0435 \u0441\u0438\u0441\u0442\u0435\u043c\u044b. \u0422\u0435\u043e\u0440\u0438\u044f \u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f, 24:3 (2020), 25\u201341, 2020. http://mi.mathnet.ru/ista273 [32] Aho A.V., Corasick M.J. Efficient string matching: an aid to bibliographic search. In Communication of\nthe ACM, vol 18, issue 6, pages 333\u2013340, 1975. [33] De La Briandais R. File Searching Using Variable Length Keys. In Proceedings of Western Joint\nComputer Conference. ACM., 295\u2013298, 1959. [34] Kruskal J. B. On the shortest spanning subtree of a graph and the traveling salesman problem. In\nProceedings of the American Mathematical Society, vol 7, issue 1, pages 48\u201350, 1956. [35] Ficara, D., Giordano, S., Procissi, G. An improved DFA for fast regular expression matching. In ACM\nSIGCOMM Computer Communication Review, vol 38, issue 5, pages 29\u201340, 2008. [36] Becchi M., Crowley P. A-DFA: A Time- and Space-Efficient DFA Compression Algorithm for Fast\nRegular Expression Evaluation. In Transactions on Architecture and Code Optimization. ACM.. vol 10, issue 1, pages 4.1-4.4, 2013.\n[37] Liu C. and Wu J. Fast Deep Packet Inspection with a Dual Finite Automata. In IEEE Transactions on Computers, vol 62, issue 2, pages 310-321, 2013.\n[38] Yu F., Chen Zh., Diao Y., Lakshman T.V., Katz R.H. Fast and memory-efficient regular expression matching for deep packet inspection. In Proceedings of the 2006 ACM/IEEE symposium on Architecture for networking and communications systems. ACM., pages 93\u2013102, 2006.\n[39] Rohrer J., Atasu K., van Lunteren J., Hagleitner C. Memory-efficient distribution of regular expressions for fast deep packet inspection. In Proceedings of the 7th IEEE/ACM international conference on Hardware/software codesign and system synthesis. ACM., pages 147\u2013154, 2009.\n[40] Xu C., Su J., Chen S. Exploring efficient grouping algorithms in regular expression matching. PLoS ONE, vol 13, issue 10, pages e0206068, 2018.\n[41] A. Bernadotte, A. V. Galatenko Structural automaton design for solving the problem of exponential blowup for one class of regular languages. Intelligent systems. Theory and applications, 23:4 (2019), 27\u201338, 2019. http://mi.mathnet.ru/ista247"
        }
    ],
    "title": "Real-time Regular Expression Matching",
    "year": 2023
}