{
    "abstractText": "A line of work has looked at the problem of recovering an input from distance queries. In this setting, there is an unknown sequence s \u2208 {0, 1}\u2264n, and one chooses a set of queries y \u2208 {0, 1}O(n) and receives d(s, y) for a distance function d. The goal is to make as few queries as possible to recover s. Although this problem is well-studied for decomposable distances, i.e., distances of the form d(s, y) = \u2211n i=1 f(si, yi) for some function f , which includes the important cases of Hamming distance, lp-norms, and M -estimators, to the best of our knowledge this problem has not been studied for non-decomposable distances, for which there are important special cases such as edit distance, dynamic time warping (DTW), Fr\u00e9chet distance, earth mover\u2019s distance, and so on. We initiate the study and develop a general framework for such distances. Interestingly, for some distances such as DTW or Fr\u00e9chet, exact recovery of the sequence s is provably impossible, and so we show by allowing the characters in y to be drawn from a slightly larger alphabet this then becomes possible. In a number of cases we obtain optimal or near-optimal query complexity. We also study the role of adaptivity for a number of different distance functions. One motivation for understanding non-adaptivity is that the query sequence can be fixed and the distances of the input to the queries provide a non-linear embedding of the input, which can be used in downstream applications involving, e.g., neural networks for natural language processing. 2012 ACM Subject Classification Theory of computation \u2192 Lower bounds and information complexity; Theory of computation \u2192 Parameterized complexity and exact algorithms; Theory of computation \u2192 Algorithm design techniques",
    "authors": [
        {
            "affiliations": [],
            "name": "Zhuangfei Hu"
        },
        {
            "affiliations": [],
            "name": "Xinda Li"
        },
        {
            "affiliations": [],
            "name": "David P. Woodruff"
        },
        {
            "affiliations": [],
            "name": "Hongyang Zhang"
        },
        {
            "affiliations": [],
            "name": "Shufan Zhang"
        }
    ],
    "id": "SP:46b05aef25acdd0a9f02495c733dbbb2ce7e10f2",
    "references": [
        {
            "authors": [
                "Amir Abboud",
                "Arturs Backurs",
                "Virginia Vassilevska Williams"
            ],
            "title": "Tight hardness results for LCS and other sequence similarity measures",
            "venue": "In 2015 IEEE 56th Annual Symposium on Foundations of Computer Science,",
            "year": 2015
        },
        {
            "authors": [
                "Peyman Afshani",
                "Manindra Agrawal",
                "Benjamin Doerr",
                "Carola Doerr",
                "Kasper Green Larsen",
                "Kurt Mehlhorn"
            ],
            "title": "The query complexity of a permutation-based variant of Mastermind",
            "venue": "Discrete Applied Mathematics,",
            "year": 2019
        },
        {
            "authors": [
                "Pankaj K Agarwal",
                "Rinat Ben Avraham",
                "Haim Kaplan",
                "Micha Sharir"
            ],
            "title": "Computing the discrete fr\u00e9chet distance in subquadratic time",
            "venue": "SIAM Journal on Computing,",
            "year": 2014
        },
        {
            "authors": [
                "M Aldridge",
                "O Johnson",
                "J Scarlett"
            ],
            "title": "Group testing: An information theory perspective",
            "venue": "Foundations and Trends in Communications and Information Theory,",
            "year": 2019
        },
        {
            "authors": [
                "A Andoni",
                "M Deza",
                "A Gupta",
                "P Indyk",
                "S Raskhodnikova"
            ],
            "title": "Lower bounds for embedding edit distance into normed spaces",
            "venue": "In Proceedings of the fourteenth annual ACM-SIAM symposium on Discrete algorithms,",
            "year": 2003
        },
        {
            "authors": [
                "Alexandr Andoni",
                "Robert Krauthgamer",
                "Krzysztof Onak"
            ],
            "title": "Polylogarithmic approximation for edit distance and the asymmetric query complexity",
            "venue": "In 2010 IEEE 51st Annual Symposium on Foundations of Computer Science,",
            "year": 2010
        },
        {
            "authors": [
                "Boris Aronov",
                "Sariel Har-Peled",
                "Christian Knauer",
                "Yusu Wang",
                "Carola Wenk"
            ],
            "title": "Fr\u00e9chet distance for curves, revisited",
            "venue": "In European symposium on algorithms,",
            "year": 2006
        },
        {
            "authors": [
                "Djamal Belazzougui",
                "Qin Zhang"
            ],
            "title": "Edit distance: Sketching, streaming, and document exchange",
            "venue": "IEEE 57th Annual Symposium on Foundations of Computer Science (FOCS),",
            "year": 2016
        },
        {
            "authors": [
                "Vladimir Braverman",
                "Moses Charikar",
                "William Kuszmaul",
                "David P Woodruff",
                "Lin F Yang"
            ],
            "title": "The one-way communication complexity of dynamic time warping distance",
            "venue": "arXiv preprint,",
            "year": 1903
        },
        {
            "authors": [
                "Nader H Bshouty"
            ],
            "title": "Optimal algorithms for the coin weighing problem with a spring scale",
            "venue": "In COLT,",
            "year": 2009
        },
        {
            "authors": [
                "Maike Buchin",
                "Anne Driemel",
                "Koen van Greevenbroek",
                "Ioannis Psarros",
                "Dennis Rohde"
            ],
            "title": "Approximating length-restricted means under dynamic time warping",
            "venue": "arXiv preprint,",
            "year": 2021
        },
        {
            "authors": [
                "Xingyu Cai",
                "Tingyang Xu",
                "Jinfeng Yi",
                "Junzhou Huang",
                "Sanguthevar Rajasekaran"
            ],
            "title": "DTWNet: a dynamic time warping network",
            "venue": "Advances in neural information processing systems,",
            "year": 2019
        },
        {
            "authors": [
                "David G Cantor",
                "WH Mills"
            ],
            "title": "Determination of a subset from certain combinatorial properties",
            "venue": "Canadian Journal of Mathematics,",
            "year": 1966
        },
        {
            "authors": [
                "Diptarka Chakraborty",
                "Elazar Goldenberg",
                "Michal Kouck\u1ef3"
            ],
            "title": "Streaming algorithms for embedding and computing edit distance in the low distance regime",
            "venue": "In Proceedings of the forty-eighth annual ACM symposium on Theory of Computing,",
            "year": 2016
        },
        {
            "authors": [
                "Moses Charikar",
                "Ofir Geri",
                "Michael P Kim",
                "William Kuszmaul"
            ],
            "title": "On estimating edit distance: Alignment, dimension reduction, and embeddings",
            "year": 2018
        },
        {
            "authors": [
                "Moses Charikar",
                "Robert Krauthgamer"
            ],
            "title": "Embedding the Ulam metric into l1",
            "venue": "Theory of Computing,",
            "year": 2006
        },
        {
            "authors": [
                "Lei Chen",
                "Raymond Ng"
            ],
            "title": "On the marriage of lp-norms and edit distance",
            "venue": "In Proceedings of the Thirtieth international conference on Very large data bases-Volume",
            "year": 2004
        },
        {
            "authors": [
                "Jeremy M Cohen",
                "Elan Rosenfeld",
                "J Zico Kolter"
            ],
            "title": "Certified adversarial robustness via randomized smoothing",
            "venue": "arXiv preprint,",
            "year": 1902
        },
        {
            "authors": [
                "Amin Coja-Oghlan",
                "Oliver Gebhard",
                "Max Hahn-Klimroth",
                "Philipp Loick"
            ],
            "title": "Optimal group testing",
            "venue": "In Conference on Learning Theory,",
            "year": 2020
        },
        {
            "authors": [
                "Graham Cormode"
            ],
            "title": "Sequence distance embeddings",
            "venue": "PhD thesis, Department of Computer Science,",
            "year": 2003
        },
        {
            "authors": [
                "Robert Dorfman"
            ],
            "title": "The detection of defective members of large populations",
            "venue": "The Annals of Mathematical Statistics,",
            "year": 1943
        },
        {
            "authors": [
                "Manuel Fern\u00e1ndez",
                "David P Woodruff",
                "Taisuke Yasuda"
            ],
            "title": "The query complexity of mastermind with lp distances. Approximation, Randomization, and Combinatorial Optimization",
            "venue": "Algorithms and Techniques,",
            "year": 2019
        },
        {
            "authors": [
                "Zhuangfei Hu",
                "Xinda Li",
                "David P Woodruff",
                "Hongyang Zhang",
                "Shufan Zhang"
            ],
            "title": "Recovery from non-decomposable distance oracles",
            "venue": "arXiv preprint,",
            "year": 2022
        },
        {
            "authors": [
                "Zilin Jiang",
                "Nikita Polyanskii"
            ],
            "title": "On the metric dimension of cartesian powers of a graph",
            "venue": "Journal of Combinatorial Theory, Series A,",
            "year": 2019
        },
        {
            "authors": [
                "Subhash Khot",
                "Assaf Naor"
            ],
            "title": "Nonembeddability theorems via Fourier analysis",
            "venue": "In 46th Annual IEEE Symposium on Foundations of Computer Science",
            "year": 2005
        },
        {
            "authors": [
                "Donald E Knuth"
            ],
            "title": "The computer as Master Mind",
            "venue": "Journal of Recreational Mathematics,",
            "year": 1976
        },
        {
            "authors": [
                "Robert Krauthgamer",
                "Yuval Rabani"
            ],
            "title": "Improved lower bounds for embeddings into l1",
            "venue": "SIAM Journal on Computing,",
            "year": 2009
        },
        {
            "authors": [
                "Ilan Kremer",
                "Noam Nisan",
                "Dana Ron"
            ],
            "title": "On randomized one-round communication complexity",
            "venue": "Proceedings of the Twenty-Seventh Annual ACM Symposium on Theory of Computing,",
            "year": 1995
        },
        {
            "authors": [
                "Mathias Lecuyer",
                "Vaggelis Atlidakis",
                "Roxana Geambasu",
                "Daniel Hsu",
                "Suman Jana"
            ],
            "title": "Certified robustness to adversarial examples with differential privacy",
            "venue": "In IEEE Symposium on Security and Privacy,",
            "year": 2019
        },
        {
            "authors": [
                "Vladimir I Levenshtein"
            ],
            "title": "Binary codes capable of correcting deletions, insertions, and reversals",
            "venue": "In Soviet physics doklady,",
            "year": 1966
        },
        {
            "authors": [
                "Ming Li",
                "Paul MB Vit\u00e1nyi"
            ],
            "title": "Combinatorics and Kolmogorov complexity",
            "venue": "Proceedings of the Sixth Annual Structure in Complexity Theory Conference,",
            "year": 1991
        },
        {
            "authors": [
                "Juan A Rodr\u00edguez-Vel\u00e1zquez",
                "Ismael G Yero",
                "Dorota Kuziak",
                "Ortrud R Oellermann"
            ],
            "title": "On the strong metric dimension of Cartesian and direct products of graphs",
            "venue": "Discrete Mathematics,",
            "year": 2014
        },
        {
            "authors": [
                "Nathan Schaar",
                "Vincent Froese",
                "Rolf Niedermeier"
            ],
            "title": "Faster binary mean computation under dynamic time warping",
            "venue": "arXiv preprint,",
            "year": 2020
        },
        {
            "authors": [
                "Staffan S\u00f6derberg",
                "Harold S Shapiro"
            ],
            "title": "A combinatory detection problem",
            "venue": "The American Mathematical Monthly,",
            "year": 1963
        },
        {
            "authors": [
                "Roman Vershynin"
            ],
            "title": "Lectures in geometric functional analysis",
            "venue": "Unpublished manuscript. Available at https://www.math.uci.edu/~rvershyn/papers/GFA-book.pdf,",
            "year": 2011
        },
        {
            "authors": [
                "Chao Wang",
                "Qing Zhao",
                "Chen-Nee Chuah"
            ],
            "title": "Optimal nested test plan for combinatorial quantitative group testing",
            "venue": "IEEE Transactions on Signal Processing,",
            "year": 2017
        }
    ],
    "sections": [
        {
            "text": "and receives d(s, y) for a distance function d. The goal is to make as few queries as possible to recover s. Although this problem is well-studied for decomposable distances, i.e., distances of the form d(s, y) = \u2211n i=1 f(si, yi) for some function f , which includes the important cases of Hamming distance, \u2113p-norms, and M -estimators, to the best of our knowledge this problem has not been studied for non-decomposable distances, for which there are important special cases such as edit distance, dynamic time warping (DTW), Fr\u00e9chet distance, earth mover\u2019s distance, and so on. We initiate the study and develop a general framework for such distances. Interestingly, for some distances such as DTW or Fr\u00e9chet, exact recovery of the sequence s is provably impossible, and so we show by allowing the characters in y to be drawn from a slightly larger alphabet this then becomes possible. In a number of cases we obtain optimal or near-optimal query complexity. We also study the role of adaptivity for a number of different distance functions. One motivation for understanding non-adaptivity is that the query sequence can be fixed and the distances of the input to the queries provide a non-linear embedding of the input, which can be used in downstream applications involving, e.g., neural networks for natural language processing.\n2012 ACM Subject Classification Theory of computation \u2192 Lower bounds and information complexity; Theory of computation \u2192 Parameterized complexity and exact algorithms; Theory of computation \u2192 Algorithm design techniques\nKeywords and phrases Sequence Recovery, Edit Distance, DTW Distance, Fr\u00e9chet Distance\nDigital Object Identifier 10.4230/LIPIcs.ITCS.2023.73\nRelated Version Full Version: https://arxiv.org/abs/2209.05676 [23]\nFunding David P. Woodruff : David P. Woodruff would like to thank support from ONR grant N00014-18-1-2562 and a Simons Investigator Award. Hongyang Zhang: Hongyang Zhang would like to thank support from NSERC Discovery Grant RGPIN-2022-03215, DGECR-2022-00357.\n1 Introduction\nWe study the problem of exact recovery of a sequence from queries to a distance oracle. Suppose there is an unknown input sequence s with length at most n, defined on a binary alphabet {0, 1}. Assume we have a distance oracle which returns the distance d(s, q) between\n\u00a9 Zhuangfei Hu, Xinda Li, David P. Woodruff, Hongyang Zhang, and Shufan Zhang; licensed under Creative Commons License CC-BY 4.0\n14th Innovations in Theoretical Computer Science Conference (ITCS 2023). Editor: Yael Tauman Kalai; Article No. 73; pp. 73:1\u201373:22\nLeibniz International Proceedings in Informatics Schloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\na query sequence q and the unknown sequence s, where the query sequence q is chosen either adaptively or non-adaptively. The problem is to determine the sequence s with a minimal number of queries to the distance oracle. To the best of our knowledge, this problem has not been studied for non-decomposable distances, where the distance function cannot be decomposed into a sum of functions of each entry. Among all non-decomposable distances, we are particularly interested in the edit distance, (p)-Dynamic Time Warping (p-DTW), and Fr\u00e9chet distances. The edit distance measures the minimum number of edit operations (i.e., insertions, deletions, and substitutions) for transforming one sequence to another. The p-DTW distance (1 \u2264 p < \u221e) between two sequences x, y is defined to be the minimum \u2113p distance between two equal-length expansions of x, y, where the expansion of a sequence means you can duplicate each character of each sequence an arbitrary number of times. When p = 1, the p-DTW distance is called the DTW distance. If we consider the \u2113\u221e norm instead of the \u2113p norm, we obtain the Fr\u00e9chet distance.\nThe problem of exact recovery for decomposable distances is well-studied in the literature, and is related to the coin-weighing problem [34, 10] and the group testing problems [21, 4, 19]. The coin-weighing problem is to identify the weight of each coin from a collection of n coins, each being of weight either w0 or w1 (w0 and w1 are distinct). In this problem, our only access to the coins is via weighing a subset of the coins on a spring scale. The group testing problem has also been shown to be equivalent to the coin-weighing problem in some settings [37]. This line of research has been extensively studied with interesting applications. For example, the coin-weighing problem can be used in the detection problem [35], in the problem of determining a collection [13], and in the distinguishing family problem [31].\nThe query complexity of the adaptive version of the problem is also related to the original Mastermind game [26]. The Mastermind problem can be phrased as guessing an input sequence based on Hamming distance queries. The non-adaptive version of the problem can be shown to be equivalent to the well-studied coin-weighing problem [10]. One can then consider other variants of the Mastermind game where the input sequence is guessed based on other distance metrics, such as permutation-based distances [2], \u2113p distances [22] and graph distances [32, 24]. However, general distance metrics that do not decompose into coordinate sums are less understood. In this paper, we initiate the study of this exact recovery problem on non-decomposable distances.\nOne motivation of our exact recovery problem is its application to adversarially robust learning on discrete domains. It is well-known that deep neural networks are vulnerable to adversarial examples: test inputs that have been modified slightly in the \u2113p space can lead to problematic machine predictions. Though there exist various techniques such as PixelDP [29] and randomized smoothing [18] that achieve certified robustness against \u2113p-norm perturbations in continuous domains, in many tasks such as natural language processing, the \u2113p norm is not well-defined for discrete perturbations. To resolve this issue, inputs from a discrete domain are usually mapped to vectors in the \u2113p space before being passed to a classifier; this is also known as a word embedding. We require two properties of such a mapping: 1) zero information loss; 2) Lipschitzness with respect to the distance metric in the input space. We show that the exact recovery problem yields a direct construction of such mappings: suppose the set of query sequences is {q1, . . . , qm} and s is the unknown input sequence; the mapping for s: \u03d5(s) = [d(s, q1), . . . , d(s, qm)] has Lipschitz constant at most \u221a m (in the \u21132 norm) and maintains complete information about s. Similar to edit distance, which can be used for describing the adversarial capability in changing sequences, the DTW and Fr\u00e9chet distances have received significant attention for their flexibility in handling temporal sequences. The special instance of our problem on DTW and Fr\u00e9chet distances may be useful for analyzing the robustness of DTW neural networks [12].\nA distance embedding further inspires theoretical applications in functional analysis [36]. While the space of input sequences s is a metric space, it may not be a Hilbert space with a definition of norm and inner product. Our result provides us with a tool to define a mapping from a metric space to a Hilbert space without loss of information about the input sequences. One can then use the norm or inner product to analyze input sequences, e.g., when two input sequences are orthogonal and how to normalize an input sequence to have norm 1."
        },
        {
            "heading": "1.1 Our Results",
            "text": "Assumptions. Throughout the paper, we assume the alphabet of the unknown input sequence s is {0,1}. We note that under this assumption, our results for DTW described below will apply to p-DTW. To recover the sequence s, we submit adaptive or non-adaptive query sequences to a distance oracle. As we will show in Section 1.1.1, for some distance metrics, there exist input sequences that any sequence on a binary alphabet cannot distinguish. Therefore, our query sequences may be allowed to utilize alphabets outside {0,1}with O(1) extra characters to exactly recover the input sequence. We assume the maximum length of s is n, while the exact length of s is unknown.\nExtension to non-binary alphabets. Our results are presented for the binary alphabet {0, 1}. We note that these results can be extended to any non-binary alphabet \u03a3 by encoding the non-binary alphabet in a binary domain. This will increase the query complexity by a factor of |\u03a3| if using a one-hot encoding, or a factor of log(|\u03a3|) if using a binary encoding, for example. This extension works for the results for all distance metrics shown in this paper.\nWe begin with a general coordinate descent framework that can help recover sequences from a large class of distance oracles, including but not limited to earth mover\u2019s distance (EMD), cascaded norms (\u2113p of \u2113q), and A norms (a.k.a. Mahalanobis distance). We then present improved results on three specific distance metrics: edit distance, DTW distance, and Fr\u00e9chet distance. We first provide several observations on the sequence recovery problem, showing the existence of indistinguishable input sequences despite the fact that we can query their DTW and Fr\u00e9chet distances with all possible binary query sequences. We also prove lower bounds on the query complexity in our distance recovery problem with respect to DTW, edit, and Fr\u00e9chet distances. Then we present our main results on recovering sequences from edit, DTW, and Fr\u00e9chet distance oracles, with adaptive and non-adaptive strategies."
        },
        {
            "heading": "1.1.1 Existence of Indistinguishable Sequences",
            "text": "We observe that, for some distances, there exist sequences that cannot be distinguished by any query sequence over a binary alphabet. This can be proved by showing concrete examples, i.e., a pair of sequences that cannot be distinguished, which we show is true for the DTW and the Fr\u00e9chet distances, as stated in the following theorem.\n\u25b6 Theorem 1 (Informal, existence of indistinguishable sequences). There exists a pair of sequences (s, s\u2032) such that s and s\u2032 cannot be distinguished by any query sequence on a binary alphabet, for the DTW distance and the Fr\u00e9chet distance.\nThe formal proof of this theorem for the DTW distance is deferred to Theorem 24. The analogous discussion for the Fr\u00e9chet distance can be found in Section 6. Due to the existence of indistinguishable sequences, we define the concept of an equivalence class of sequences, which is a set of input sequences which are indistinguishable from all queries by a given distance oracle.\nITCS 2023\nThis observation suggests the scope of the distance recovery problem we study. We further categorize the recovery guarantee into the following three levels, from strong to weak: 1) recover the exact input sequence; 2) recover any sequence in the same equivalence class of the input sequence, where the equivalence class is defined to be a set for which any two input sequences in the equivalence class cannot be distinguished by calling the distance oracle on all query sequences; 3) recover any sequence which has zero distance to the input sequence. While the third level is the weakest one, in certain cases it can be reduced to the first two levels \u2013 for norm-induced distance functions, the recovered sequence is exactly the input sequence; for semi-norm-induced distance functions, the recovered sequence is in the same equivalence class. We will show that our general coordinate descent framework can recover sequences with the third-level guarantee.\n1.1.2 General Coordinate Descent Framework for Adaptively Querying Distance Oracles\nWe develop a general framework for recovering an input sequence from adaptive queries, which models the problem as a zero-th order optimization problem and utilizes a coordinate-descentbased algorithm to give a solution. The coordinate descent framework defines the distance between the input sequence and the query sequence as the loss function. The objective of the optimization is to reduce the loss function to 0, which guarantees what we call the third level of recovery. We define a step operation to modify the query sequence. For example, in the context of edit distance, a step operation is defined as adding/removing/substituting a character of the query sequence. To perform coordinate descent, our algorithm performs one step operation each time and queries the oracle to find a direction for which the loss decreases by 1. By iteratively performing this method, the loss can be reduced to 0 and we show that the overall complexity of this method is poly(n), given that the maximum length of the sequence is n. For a large class of non-decomposable distance functions, such as the earth mover\u2019s distance (EMD), the cascaded norm (\u2113p of \u2113q), and the A norm, we can use this framework to yield a solution, as stated in the following theorem.\n\u25b6 Theorem 2 (Informal, Coordinate Descent for Adaptive Distance Queries). For an arbitrary distance oracle, a binary alphabet {0, 1} and any input sequence s \u2208 {0, 1}i where 0 \u2264 i \u2264 n, using coordinate descent can reduce the distance to the input sequence s to 0, by adaptively querying the distance oracle between s and a set of query sequences with query complexity at most poly(n).\nSufficient conditions for using this framework and details can be found in Theorem 15."
        },
        {
            "heading": "1.1.3 Lower Bounds on the Recovery Problem",
            "text": "If we study the problem of exact recovery (the first level of recovery), we can obtain an information-theoretic lower bound of \u2126\u0303(n) for various distance oracles, given by the following theorem. Here f(n) = \u2126\u0303(g(n)) if f(n) = \u2126(g(n)/polylog(n)).\n\u25b6 Theorem 3 (Informal, Lower Bounds for Exact Recovery). For any input sequence s \u2208 {0, 1}i where 0 \u2264 i \u2264 n, if for any input sequence and query the distance oracle has poly(n) possible output values, any algorithm which exactly recovers s by querying the distance oracle between s and a set of query sequences requires query complexity at least \u2126\u0303(n).\nThe idea behind this bound is that, there are exponentially many possible input sequences with length at most n, while the output of each query is a distance between two sequences which only has poly(n) possibilities. Hence, we need at least \u2126\u0303(n) = logpoly(n)(2n+1) queries.\nWe also show the same lower bound holds for any adaptive randomized query algorithm, by a reduction to a one-way communication game called INDEX [28]. We instantiate this theorem for the edit distance and DTW distance in Theorem 19 and Theorem 32.\nWe note for the DTW distance and Fr\u00e9chet distance, there exist indistinguishable sequences which lead to the recovery problem for an equivalence class. Since the total number of equivalence classes is smaller than the number of input sequences, the previous lower bound no longer holds. So we need a different argument, as we give in the following theorem:\n\u25b6 Theorem 4 (Informal, Lower Bounds for Equivalence Class Recovery). For a binary alphabet {0, 1} and any input sequence s \u2208 {0, 1}i where 0 \u2264 i \u2264 n, any algorithm which recovers the sequence in the same equivalence class as s, by querying the DTW or Fr\u00e9chet distance oracle between s and a set of query sequences, requires query complexity at least \u2126(n).\nThe formal proof is given in Theorem 31 and Theorem 40."
        },
        {
            "heading": "1.1.4 Adaptively Querying Distance Oracles, Optimally",
            "text": "We first answer the distance recovery problem with adaptive query strategies. Our solutions are summarized in the theorem below.\n\u25b6 Theorem 5 (Informal, Upper Bounds for Adaptive Exact Recovery). For a binary alphabet {0, 1} and any input sequence s \u2208 {0, 1}i where 0 \u2264 i \u2264 n, there exists an algorithm which can exactly recover the input sequence s, by adaptively querying the distance oracle (for the edit and DTW distances) between s and a set of query sequences with query complexity at most O(n).\nAll results in Theorem 5 match our lower bounds on the query complexity. Without extra character(s), using the DTW distance oracle we can only recover a sequence in the same equivalence class. Our result in Theorem 5 for the DTW distance is achieved with the assistance of 1 extra character outside the alphabet {0, 1}, and the proof and algorithm can be found in Theorem 18.\nFor the edit distance, we have two different adaptive algorithms that can achieve the O(n) bound. The first algorithm makes use of the property that, for two sequences, the edit distance is equal to the difference in their lengths, if and only if one sequence is a subsequence of the other. We construct an O(n) adaptive query set and a binary search algorithm utilizing this property to recover the input sequence. Our second algorithm instead queries the length of the input sequence by an empty sequence and then finds a set of O(n) bases as the query set, from which we can reconstruct the input sequence. These are further detailed in Theorem 16.\nFor the Fr\u00e9chet distance, adaptive and non-adaptive strategies are essentially the same, because we prove that 2n\u22121 queries are necessary and sufficient for recovering from a Fr\u00e9chet distance oracle. However, we can only recover a sequence in the equivalence class in this setting. This result is described as a non-adaptive query strategy in Theorem 42."
        },
        {
            "heading": "1.1.5 Non-adaptively Querying Distance Oracles, Optimally",
            "text": "Next we describe our non-adaptive query strategies for the distance recovery problem. Theorem 6 shows upper bounds for exact sequence recovery, while Theorem 7 summarizes our results on the recovery problem of finding a sequence in the same equivalence class as the input sequence.\nITCS 2023\n\u2020 For both adaptively and non-adaptively querying the Fr\u00e9chet distance oracle, the optimal bound on the query complexity is 2n \u2212 1. * Increasing #EC to a larger constant cannot improve the query complexity to be better than O\u0303(n). ** Involving extra characters not only cannot improve the level of recovery from \u201cequivalence class\u201d to \u201cexact sequence\u201d, but also cannot improve the query complexity (see Theorem 41).\n\u25b6 Theorem 6 (Informal, Upper Bounds for Non-adaptive Exact Recovery). For a binary alphabet {0, 1} and any input sequence s \u2208 {0, 1}i where 0 \u2264 i \u2264 n, there exists an algorithm which can exactly recover the input sequence s by querying the distance oracle (for the edit and DTW distances) between s and a non-adaptive set of query sequences with query complexity at most O(n), with the assistance of O(1) extra characters in the query sequences.\nWith 1 extra character, we show the construction of a set of non-adaptive queries that can exactly recover sequences from the edit distance (Theorem 21), while with 2 extra characters, we can exactly recover input sequences from the DTW distance (Theorem 34). Both results match our lower bound on the query complexity, while we complement our results with an O(n2) query complexity algorithm for the DTW distance with 1 extra character (Theorem 33). We note that non-adaptive strategies have limited power compared to adaptive strategies. Hence, we need to use more extra characters to construct the query set to solve the problem. For the edit distance, introducing more than 1 extra character cannot encode more information in the query results, because the cost between 0 (or 1) and any other additional character is always the same.\n\u25b6 Theorem 7 (Informal, Upper Bounds for Non-adaptive Equivalence Class Recovery). For a binary alphabet {0, 1} and any input sequence s \u2208 {0, 1}i where 0 \u2264 i \u2264 n, there exists an algorithm which can recover the sequence in the same equivalence class as the input sequence s, by querying the distance oracle (for the DTW and Fr\u00e9chet distances) between s and a non-adaptive set of query sequences with query complexity at most O(n), without extra characters in the query sequence.\nBy Theorem 7, if we are not allowed to use extra characters, we can only recover the sequence in the same equivalence class as the input sequence for the DTW distance. Our query construction and proof are shown in Theorem 27. We also remark that for Fr\u00e9chet distance, using extra characters cannot help to improve the results of Theorem 42, as shown in Theorem 41.\nSummary. The main technical results of this paper are summarized in Table 1.\n2 Preliminaries\nWe briefly introduce the definitions and notations of the distance metrics we consider, namely, the edit distance, DTW distance, and Fr\u00e9chet distance.\n\u25b6 Definition 8 (Edit Distance, Levenshtein Distance). Given two sequences x and y, the edit distance dL(x, y) equals the minimal number of edit operations required for a sequence x to be transformed to sequence y. Specifically, we consider the Levenshtein distance [30] which captures the addition, deletion, and substitution of single symbols.\n\u25b6 Definition 9 (Runs and Expansion, [9]). The runs of a sequence x are the maximal substrings consisting of a single repeated character. Any sequence obtained from x by extending x\u2019s runs is an expansion of x. We denote the number of runs of a sequence x by runs(x).\n\u25b6 Definition 10 (Condensed Expression). We say y is a condensed expression of x if (i) y has the same number of runs as x, (ii) each run of y only has 1 character.\n\u25b6 Definition 11 (Subsequence and Substring). Given a sequence y, its subsequence x is derived by deleting zero or more characters from y without changing the order of the remaining characters. The substring x\u2032 is a contiguous subsequence of y. We use x[a] to denote the a-th character of the sequence x, and x[a, b] to denote a substring of x which starts from the a-th character and ends at the b-th character.\n\u25b6 Definition 12 (DTW Distance, [9]). Consider two sequences x, y of length m1 (and m2, respectively). A correspondence (x, y) between x and y is a pair of equal-length expansions of x and y. The cost of a correspondence is calculated as the \u21131 distance between x, y: \u2225x \u2212 y\u22251. A correspondence between x and y is said to be optimal if it has the minimum attainable cost, and the resulting cost is called the dynamic time warping distance dDT W (x, y), that is dDT W (x, y) = min(x,y)\u2208Wx,y \u2225x \u2212 y\u22251, where Wx,y denotes the set of all correspondences (x, y).\n\u25b6 Definition 13 (p-DTW Distance, [11]). By replacing the \u21131 norm in Definition 12 with the \u2113p norm (1 \u2264 p < \u221e), we obtain the definition for the p-DTW distance.\n\u25b6 Definition 14 (Fr\u00e9chet Distance). By replacing the \u21131 norm in Definition 12 with the \u2113\u221e norm, we obtain the definition of the Fr\u00e9chet distance.\nNote. The Fr\u00e9chet distance in our paper is equivalent to the discrete Fr\u00e9chet distance in the prior works of [3, 7].\n3 Recovery Using Adaptive Queries"
        },
        {
            "heading": "3.1 General Framework of Coordinate Descent",
            "text": "\u25b6 Theorem 15 (Coordinate Descent). There exists an adaptive algorithm which returns a sequence s\u2032 such that its distance to the input sequence s satisfies dist(s\u2032, s) = 0 using poly(n) queries, given that the following two conditions are true:\n\u2200q, q\u2032(q\u2032 \u0338= q), we can find q\u2032\u2032 in poly(n) queries such that dist(q, q\u2032) > dist(q, q\u2032\u2032); \u2200q, q\u2032, dist(q, q\u2032) \u2264 poly(n).\nProof sketch. The two above conditions naturally imply a local search algorithm. To recover the sequence q, we perform the following steps: 1) randomly initialize q\u2032. 2) find q\u2032\u2032 such that dist(q, q\u2032) > dist(q, q\u2032\u2032). 3) set q\u2032 to q\u2032\u2032 and repeat 2) to 3). The algorithm\nITCS 2023\nterminates if dist(q, q\u2032) = 0. Since we reduce dist(q, q\u2032) by least 1 in each iteration, and dist(q, q\u2032) \u2264 poly(n), the algorithm terminates in at most poly(n) iterations. Therefore, the total number of queries is O(poly(n)). Notice that the above local search algorithm can be applied to all aforementioned distances. Specifically, the complexity for the edit distance, DTW distance and Fr\u00e9chet distance is O(n2), O(n2) and O(n), respectively. A detailed instantiation of the algorithm on these distances can be found in Appendix A. \u25c0"
        },
        {
            "heading": "3.2 Edit Distance",
            "text": "We show that a binary input sequence with maximum length n can be adaptively recovered using at most O(n) queries to the edit distance oracle, by the following theorem.\n\u25b6 Theorem 16 (Adaptive Strategy for Edit Distance). For a binary alphabet {0, 1}, and any input sequence s \u2208 {0, 1}\u2113 where 0 \u2264 \u2113 \u2264 n, there exists an adaptive algorithm to recover the input sequence s using at most n + 2 queries Q of length \u2264 n and the exact Levenshtein distance of s to each query sequence qi \u2208 Q, where the query sequences use no extra characters.\nProof. The adaptive query strategy is the following. We first use an empty sequence to query the length \u2113 \u2208 [n] = {1, 2, . . . , n} of the input sequence. Then we use \u2113 + 1 \u2264 n + 1 queries: an e0 = 0\u2113 query and a set of ei = 0i\u2212110\u2113\u2212i, i \u2208 [\u2113] queries (all with length \u2113).\n\u25b7 Claim 17. s[i] = {\n0, if dL(s, e0) \u2212 dL(s, ei) \u2264 0; 1, if dL(s, e0) \u2212 dL(s, ei) = 1.\nProof of claim. If s[i] = 1, dL(s, e0)\u2212dL(s, ei) = (#1\u2019s in s) \u2212 (#1\u2019s in s\u22121) = 1. If s[i] = 0, dL(s, e0) = (#1\u2019s in s). We show that dL(s, ei) \u2265 (#1\u2019s in s). First, dL(s, ei) \u2265 (#1\u2019s in s) \u2212 (#1\u2019s in ei) = #1\u2019s in s \u2212 1. Consider the series of transformations from s to ei: 1) If we only perform substitutions on s, we need at least #1\u2019s in s + 1 operations. 2) Otherwise we show that we have at least one insertion. If we perform at least one deletion operation(s) on s, since s and ei are of the same length, we would need at least one insertion(s) on s. Note that insertions on s cannot reduce the difference of the number of 1\u2019s between s and ei. Thus, we need at least (#1\u2019s in s \u22121) extra operations to reduce the difference to 0 and we have dL(s, ei) \u2265 (#1\u2019s in s \u22121) +1 = #1\u2019s in s. Combining these cases, we obtain dL(s, ei) \u2265 (#1\u2019s in s). \u25c1\nBy claim 17, we can recover the sequence s character by character. \u25c0\n\u25b6 Remark. We remark that we have two meaningful strategies for edit distance, for details please refer to the full version of this paper."
        },
        {
            "heading": "3.3 DTW Distance",
            "text": "\u25b6 Theorem 18 (Adaptive Strategy for DTW Distance). For a binary alphabet {0, 1}, and any input sequence s \u2208 {0, 1}\u2113 where 0 \u2264 \u2113 \u2264 n, there exists an adaptive algorithm to recover the input sequence s using at most n + 1 queries Q of length \u2264 n and the exact DTW distance of s to each query sequence qi \u2208 Q, where the query sequences use 1 extra character.\nProof. Using an adaptive method, for a binary alphabet {0, 1}, an input sequence s \u2208 {0, 1}i where 0 \u2264 i \u2264 n can be exactly recovered with at most n + 1 queries to the DTW distance oracle. We need 1 additional character, which is the fractional character 12 , to construct the set of query sequences. The details are presented as follows. Here we use q(i) to denote the i-th query, sj to denote the j-th character in s and q(i)j to denote the j-th character in q(i).\nFirst, with a single-character query sequence q(1) = 12 , we can obtain the length of the input sequence s, which is \u2113 = 2dDT W (s, q(1)). We show how to recover the whole sequence by induction. Base case: To recover s1, we consider the query q(2) = 0 ( 12 )\n\u2113\u22121. Note that each 12 in the q(2) corresponds to at least 12 cost in the query result, and we have dDT W (s, q\n(2)) \u2265 \u2113\u221212 . If s1 = 0, then s1 and q(2)1 are perfectly matched, so dDT W (s, q(2)) = \u2113\u221212 . Otherwise, the first character 0 in q(2) would correspond to cost > 0 in the query result, so dDT W (s, q(2)) > \u2113\u221212 . Induction step: Suppose we have recovered s1, s2, . . . , sk. We show that we can recover sk+1 with the query sequence q(k+2) = s1s2 \u00b7 \u00b7 \u00b7 s2k( 12 ) \u2113\u2212k\u22121. Noting that each 12 in q (k+2) corresponds to at least a 12 cost in the query result, we have dDT W (s, q (k+2)) \u2265 \u2113\u2212k\u221212 . If sk+1 = sk, then s1, s2, . . . , sk, sk+1 and q(k+2)1 , q (k+2) 2 , . . . , q (k+2) k , q (k+2) k+1 can be perfectly matched, so dDT W (s, q(k+2)) = \u2113\u2212k\u221212 . Otherwise, we claim that dDT W (s, q (k+2)) > \u2113\u2212k\u221212 . If the cost corresponding to q(k+2)k+1 > 0, we would already have dDT W (s, q(k+2)) > \u2113\u2212k\u22121\n2 , so we can assume that the cost corresponding to q(k+2)k+1 is 0. Since q (k+2) k+1 = sk =\u0338 sk+1, we know that q(k+2)k+1 cannot be matched with sk+1. Suppose q (k+2) k+1 is matched with substring su, su+1, . . . , su+t in the optimal DTW matching, where t \u2265 0 and su = su+1 = \u00b7 \u00b7 \u00b7 = su+t = q(k+2)k+1 = sk. Since k + 1 /\u2208 [u, u + t], we either have k + 1 > u + t or k + 1 < u. If k + 1 > u + t, since \u2200u + t < j \u2264 \u2113 we have sj matched to a 12 , the total cost would be at least \u2113\u2212(u+t)2 > \u2113\u2212k\u22121 2 . Otherwise if k + 1 < u, note that s1, s2, . . . , su are matched to q (k+2) 1 , q (k+2) 2 , . . . , q (k+2) k+1 in the optimal DTW matching. Since sk+1 \u0338= sk, the number of runs in s1, s2, . . . , sk+1 would be greater than the number of runs in q(k+2)1 , q (k+2) 2 , . . . , q (k+2) k+1 by 1. Thus, the number of runs in s1, s2, . . . , su would be greater than the number of runs in q\n(k+2) 1 , q (k+2) 2 , . . . , q (k+2) k+1 by at least 1, and they cannot be perfectly matched. Therefore, the\ncost corresponding to q(k+2)1 , q (k+2) 2 , . . . , q (k+2) k+1 would be greater than 0, yielding a total cost of greater than \u2113\u2212k\u221212 . Therefore, we can recover the input sequence of maximum length n with n + 1 queries. \u25c0\n4 Recovery Using a Non-Adaptive Edit Distance Oracle\nWe begin with a lower bound for edit distance.\n\u25b6 Theorem 19. For a binary alphabet {0, 1}, any algorithm to recover an arbitrary input sequence s \u2208 {0, 1}\u2113 where 0 \u2264 \u2113 \u2264 n by querying the Levenshtein distance to a set of sequences of length O(n) requires a query complexity of \u2126( nlog n ).\nProof. We start with a lower bound for deterministic algorithms. For each query, the result is an integer d = O(n), yielding O(n) possibilities. For 0 \u2264 k \u2264 n, the number of different sequences of length k is 2k, and the total number of sequences of length no greater than n would be \u2211n k=0 2k = 2n+1 \u2212 1. Thus, to distinguish all possible sequences, one would need at least logO(n)(2n+1) = \u2126( nlog n ) queries. Next we give a proof if one is allowed to use a randomized algorithm. To show this, we introduce a one-way two-party communication game called INDEX.\n\u25b6 Definition 20 (INDEX Game [28]). Consider two players Alice and Bob. Alice and Bob have access to a common public coin and their computation can depend on this. Alice holds an n-bit string x \u2208 {0, 1}n and is allowed to send a single message M to Bob (i.e., this is a one-way protocol). Bob has an index i \u2208 [n] and his goal is to learn x[i], i.e., Prr[Out(M) = x[i]] \u2265 23 ).\nITCS 2023\nIt is shown in [28] that the above problem requires |M | = \u2126(n). To reduce our recovery problem from the INDEX game, let R be an adaptive randomized recovery algorithm which works as follows. First, Alice randomly selects a query q1 based on the first part r1 of the shared public coin, and computes d(q1, x). Alice then adaptively selects a set of queries qi, where each qi is chosen based on disjoint parts r1, . . . , ri of the public coin, as well as the responses d(q1, x), . . . , d(qi\u22121, x) to previous queries. Alice then sends all query results d(qi, x) to Bob as the message M .\nWe now show that, if the algorithm R is correct w.p. 2/3, then M contains \u2126( nlog n ) query results. Given the success probability 2/3 of R, from message M , Bob can reconstruct the string x w.p. at least 2/3, so Bob can learn each bit of x w.p. at least 2/3. According to [28], |M | = \u2126(n) bits. Since each distance query result contains at most O(log n) bits, it follows that \u2126( nlog n ) queries are required. \u25c0"
        },
        {
            "heading": "4.1 Exact Recovery with Extra Character(s)",
            "text": "We now move on to the analysis of our upper bound for edit distance with the assistance of extra character(s).\n\u25b6 Theorem 21. For a binary alphabet {0, 1} and an input sequence s \u2208 {0, 1}\u2113 where 0 \u2264 \u2113 \u2264 n, there exists an algorithm to recover the input sequence s, given O(n) query sequences Q of length \u2264 n and the exact Levenshtein distance of s to each query sequence qi \u2208 Q, where an extra character 2 is allowed in the query sequences.\nProof. To prove Theorem 21, the following Lemma 22 gives a useful result.\n\u25b6 Lemma 22. Consider a sequence defined on a binary alphabet {0, 1} with maximum length n, which is defined as s = [prefix]0[suffix] where the length of sequence a is \u2225s\u2225 = n\u2032 \u2264 n and the length of the prefix is \u2225[prefix]\u2225 = j. Consider another sequence s\u2032 = 1j+12n\u2212j\u22121, where 2 denotes a random character not in the binary alphabet {0, 1}. Let k denote the number of 1\u2019s in the prefix [prefix] of the sequence s. The claim is that the edit distance between s and s\u2032 is greater than or equal to n \u2212 k.\nDue to space constraints, the proof of Lemma 22 is deferred to the full version. The construction of the query sequences is an extension of the query sequence we present in Lemma 22. We describe how this can be generalized to distinguish all the different input sequence pairs by constructing a set of n + 1 query sequences. We show that using this set of queries, any two possible input sequences s =\u0338 s\u2032 can be distinguished by n + 1 non-adaptive query results.\nQuery Sequence Construction. We assume the query sequences can include a character that is not in the alphabet. The n + 1 query sequences are constructed as follows. We use an empty sequence together with n sequences of the form 1j2n\u2212j for j = 1, . . . , n where 2 denotes a \u201cnot-in-the-alphabet\u201d character. We will show that any two input sequences s \u0338= s\u2032 are distinguished by this construction of query sequences.\nFirst, it is clear that the empty sequence can distinguish two sequences with different length, i.e., |s| \u0338= |s\u2032|. Next we need to show that, for two input sequences s \u0338= s\u2032 with the same length n\u2032 \u2264 n, the remaining query sequences can distinguish them. Without loss of generality, we suppose s and s\u2032 have the same prefix with length j and first disagree on the (j + 1)th character. That is, s = [prefix]1[ssuffix] and s\u2032 = [prefix]0[s\u2032suffix] where ssuffix and s\u2032suffix are not necessarily equal. Consider a query sequence qi = 1j+12n\u2212j\u22121. We use the\nresults from Lemma 22 and obtain dist(s\u2032, qi) \u2265 n \u2212 k where k denotes the number of 1\u2019s in the prefix of sequence s\u2032. Since we also know that d(s, qi) \u2264 n \u2212 k \u2212 1, this query sequence qi can distinguish s and s\u2032. This finishes the proof. \u25c0\n\u25b6 Remark. The proof for Theorem 21 implicitly implies an exact recovery algorithm that takes the edit distance query results as input and outputs the target sequence. We defer the algorithm to the full version of the paper."
        },
        {
            "heading": "4.2 Exact Recovery without Extra Characters",
            "text": "\u25b6 Theorem 23. For a binary alphabet {0, 1} and an input sequence s \u2208 {0, 1}\u2113 where 0 \u2264 \u2113 \u2264 n, there exists an algorithm to recover the input sequence s, given O(n2) query sequences Q of length \u2264 n and the exact Levenshtein distance of s to each query sequence qi \u2208 Q, without extra characters.\nProof. The construction can be obtained by naturally extending the query set in the proof of Theorem 16 to all lengths \u2113 \u2208 [n]. This gives us \u2211n 1 n = O(n2) queries. \u25c0\n5 Recovery Using a Non-Adaptive DTW Distance Oracle"
        },
        {
            "heading": "5.1 Hardness Result without Extra Characters",
            "text": "\u25b6 Theorem 24. There exists a pair of input sequences s and s\u2032 such that for any query sequence q, dDT W (s, q) = dDT W (s\u2032, q). That is, s and s\u2032 cannot be distinguished by DTW Distance Oracle queries without extra characters.\nConsider the following counterexample: s = 010110 and s\u2032 = 011010. We can argue that this pair of input sequences cannot be distinguished by any binary sequence query q. Due to space constraints, the proof can be found in the full version of the paper. This hardness result shows that sequences cannot be exactly recovered using DTW queries."
        },
        {
            "heading": "5.2 Recovery without Extra Characters w.r.t. Equivalence Classes",
            "text": "For ease of presentation, we say that any two different input sequences s and s\u2032 are distinguishable if s and s\u2032 can be distinguished by DTW Distance Oracle queries. We categorize mutually indistinguishable sequences into equivalence classes. In this context, using binary queries, the best solution we can provide in this setting is to recover those input sequences up to their equivalence class. First, we would like to characterize the set of indistinguishable binary sequences, given a parameterized sequence length n. The equivalence class is not so simple to describe, as can be seen from Observation 4 of [33]. However, we can propose an optimal query strategy in this setting to distinguish all distinguishable sequences and prove optimality by making use of the reduction between the calculation of DTW distance and the min 1-separated sum problem [1, 33]. We introduce the necessary results from [33] below and interpret them in our setting.\nMSS Problem. The min 1-separated sum (MSS) problem takes as input a sequence seq of m positive integers and an integer r \u2265 0. The problem is to select r integers from seq and minimize their sum, under the constraint that any two adjacent integers cannot be selected simultaneously. We say (seq, r) is an MSS instance.\nITCS 2023\n\u25b6 Theorem 25 (DTW-to-MSS Reduction, [33], Theorem 2). Let x \u2208 {0, 1}m and y \u2208 {0, 1}n be two binary strings such that x[1] = y[1], x[m] = y[n], and |x\u0303| \u2265 |y\u0303|. Then, the DTW distance between x and y, i.e., dDT W (x, y), equals the sum of a solution for MSS ( ( \u2223\u2223x(2)\u2223\u2223 , . . . , \u2223\u2223x(|x\u0303|\u22121)\u2223\u2223), (|x\u0303| \u2212 |y\u0303|)/2).\nFor ease of presentation, we will use MSS(x, (|x\u0303|\u2212|y\u0303|)/2) to represent the same MSS instance.\n\u25b6 Theorem 26 ([33], Observation 4). Let x \u2208 {0, 1}m, y \u2208 {0, 1}n with m\u2032 := |x\u0303| \u2265 n\u2032 := |y\u0303|. Further, let a := \u2223\u2223x(1)\u2223\u2223 , a\u2032 := \u2223\u2223\u2223x(m\u2032)\u2223\u2223\u2223 , b := \u2223\u2223y(1)\u2223\u2223, and b\u2032 := \u2223\u2223\u2223y(n\u2032)\u2223\u2223\u2223. The following holds: If x[1] \u0338= y[1], then:\ndDT W (x, y) =  max(a, b), m\u2032 = n\u2032 = 1; a + dDT W (x[a + 1, m], y), m\u2032 > n\u2032 = 1; min (a + dDT W (x[a + 1, m], y), b + dDT W (x, y[b + 1, n])) , n\u2032 > 1.\nIf x[1] = y[1] and x[m] \u0338= y[n], then: dDT W (x, y) = {\na\u2032 + dDT W (x [1, m \u2212 a\u2032] , y) , n\u2032 = 1; min (a\u2032 + dDT W (x [1, m \u2212 a\u2032] , y) , b\u2032 + dDT W (x, y [1, n \u2212 b\u2032])) , n\u2032 > 1.\nIn Theorem 26, we call a, b, a\u2032 and b\u2032 (which are the length of first/last blocks of x or y) offsets. Theorem 26 actually states that, for two sequences x, y with different starting and ending characters, by removing the first/last run of x or y, calculating dDT W (x, y) can be reduced to calculating the offset and solving a DTW sub-problem where the sub-sequences start and end with the same character.\nWith these useful results at hand, now we prove the following results for recovering sequences using the DTW distance oracle with only binary queries.\n\u25b6 Theorem 27. There exists a set Q of O(n) queries, each of which has O(n) length, such that for any two different input sequences s and s\u2032, s and s\u2032 are distinguishable \u21d0\u21d2 s and s\u2032 can be distinguished by Q.\nProof. First (\u21d0), for any given query set Q and two different input sequences s and s\u2032, if s and s\u2032 can be distinguished by Q then s and s\u2032 are distinguishable. Then we need to prove the opposite side (\u21d2). To see this, we construct the following query set Q and prove the contrapositive: if s and s\u2032 cannot be distinguished by Q, then s and s\u2032 are not distinguishable.\nLet zi =  0n, i = 1; 0n1(01)m\u221210n, i = 2m + 1; 0n(10)m\u221211n, i = 2m,\nand oi =  1n, i = 1; 1n0(10)m\u221211n, i = 2m + 1; 1n(01)m\u221210n, i = 2m,\nwhere 1 \u2264 i \u2264 n and m is a positive integer. It is clear that oi\u2019s and zi\u2019s are of O(n) length. Let Q = {oi|1 \u2264 i \u2264 n} \u22c3 {zi|1 \u2264 i \u2264 n}. We show that given any two different input sequences s and s\u2032, if s and s\u2032 cannot be distinguished by Q then s and s\u2032 are not distinguishable.\n\u25b7 Claim 28. Given two different input sequences s and s\u2032, if the condensed expressions of s and s\u2032 are different, then s and s\u2032 can be distinguished by Q.\nSuppose s and s\u2032 cannot be distinguished by Q. By Claim 28, we know that the condensed expression of s and s\u2032 are the same. Suppose the number of runs in s and s\u2032 is k, the length of the i-th run in s is \u03b1i, and the length of the i-th run in s\u2032 is \u03b1\u2032i. We denote the length of a sequence by len(\u00b7).\n\u25b7 Claim 29. If s and s\u2032 cannot be distinguished by Q, then k \u2265 3.\n\u25b7 Claim 30. If s and s\u2032 cannot be distinguished by Q, then \u03b11 = \u03b1\u20321 and \u03b1k = \u03b1\u2032k.\nWe defer the proof of the claims 28, 29, and 30 to the full paper. We next show that s and s\u2032 cannot be distinguished by any binary query r. Suppose the number of runs in r is l, and the length of the i-th run in r is \u03b2i. Given s and r, we can calculate dDT W (s, r) with Theorem 26 and Theorem 25. Note that in Theorem 26, we may remove the first/last blocks of s (and s\u2032) or r to reduce to the case of Theorem 25. By Claim 30 we have \u03b11 = \u03b1\u20321 and \u03b1k = \u03b1\u2032k, while \u03b21 and \u03b2l are only related to r but not s and s\u2032. Therefore, the offsets while reducing to the case of Theorem 25 are the same. To prove that dDT W (s, r) = dDT W (s\u2032, r), we only need to prove that for each possible reduction, the corresponding reduced MSS instances have the same sum of solutions.\nSuppose after applying Theorem 26, s and r are reduced to sub-sequences s\u2217 and r\u2217 (where s\u2217 and r\u2217 have the same beginning and ending characters), while s\u2032 and r are reduced to s\u2032\u2217 and r\u2217. Now we calculate dDT W (s\u2217, r\u2217) and dDT W (s\u2032\u2217, r\u2217) according to Theorem 25. Suppose s\u2217 and s\u2032\u2217 have k\u2217 runs and r\u2217 have l\u2217 runs. Case 1. If k\u2217 = l\u2217, then dDT W (s\u2217, r\u2217) = dDT W (s\u2032\u2217, r\u2217) = 0. Case 2. If k\u2217 < l\u2217, by Theorem 25 the generated MSS instance only depends on r\u2217 and k\u2217.\nThus, dDT W (s\u2217, r\u2217) = dDT W (s\u2032\u2217, r\u2217). Case 3. If k\u2217 > l\u2217, we have the MSS instances MSS(s\u2217, k\n\u2217\u2212l\u2217 2 ) and MSS(s \u2032\u2217, k \u2217\u2212l\u2217\n2 ). Note that, we can always find a query q \u2208 Q which has l\u2217 runs and has the same starting and ending characters as s\u2217 and s\u2032\u2217. Consider dDT W (s, q) and dDT W (s\u2032, q). Note that the first and last runs of q are both of length n and removing them would yield cost at least n - the only possible reduction would be dDT W (s\u2217, q) and dDT W (s\u2032\u2217, q). Since q cannot distinguish s and s\u2032, we have dDT W (s, q) = dDT W (s\u2032, q), so dDT W (s\u2217, q) = dDT W (s\u2032\u2217, q), implying that MSS(q\u2217, k\n\u2217\u2212l\u2217 2 ) and MSS(q \u2032\u2217, k \u2217\u2212l\u2217\n2 ) have the same sum of solutions. Therefore, dDT W (s\u2217, r\u2217) = dDT W (s\u2032\u2217, r\u2217). Combining the 3 cases above, we always have dDT W (s\u2217, r\u2217) = dDT W (s\u2032\u2217, r\u2217), so dDT W (s, r) = dDT W (s\u2032, r), implying that s and s\u2032 cannot be distinguished by r. This finishes the proof for Theorem 27. \u25c0\nWe complete the study of equivalence class recovery with a lower bound on the query complexity using binary queries.\n\u25b6 Theorem 31. For binary alphabet {0, 1}, any algorithm to recover an arbitrary input sequence s \u2208 {0, 1}\u2113, where 0 \u2264 \u2113 \u2264 n, up to equivalence class, by querying the DTW distance to a set of sequences, requires a query complexity of \u2126(n).\nProof sketch. Note that in the query construction of Theorem 27, our constructed query set Q\u2217 contains queries of all numbers of runs. The intuition for the proof of Theorem 31 is that, for each given constant-length interval of number of runs, we can construct a certain pair of input sequences which can only be distinguished by queries with a number of runs within this interval. E.g., it can be proved that s1 = 013013031303130 and s2 = 0130213021303130 can only be distinguished with queries with a number of runs within [4, 10]. Thus, an \u2126(n) number of such constructed pairs of input sequences can correspond to \u2126(n) disjoint intervals, yielding an \u2126(n) lower bound for this problem.\nWe now construct a class of pairs of input sequences (s, s\u2032) such that s and s\u2032 can only be distinguished by queries q with a number of runs within [#runs(s)+c1, #runs(s)+c2] for two constants c1 < c2. According to Theorem 25, as long as the constructed pair of input sequences (s, s\u2032) have the same number of runs, for a query q with more than\nITCS 2023\n#runs(s) number of runs, dDT W (q, s) and dDT W (q, s\u2032) are only determined by the query q and #runs(s), and thus q cannot distinguish s and s\u2032. For a query q with fewer than #runs(s) number of runs, dDT W (q, s) and dDT W (q, s\u2032) are reduced to two MSS instances. Note that for different queries q, the sequences (i.e., the first parameter) of MSS instances remain the same, while #runs(q) determines the number of elements selected in the sequences of MSS instances (i.e., #runs(s)\u2212#runs(q)2 ). We hope to construct a pair of sequences seq and seq\u2032 such that MSS(seq, 1) \u0338= MSS(seq\u2032, 1) and MSS(seq, x) = MSS(seq\u2032, x) for all x > 1: let seq and seq\u2032 be the sequences corresponding to MSS instances of s and s\u2032; in this way, s and s\u2032 would still be distinguishable because MSS(seq, x) \u0338= MSS(seq\u2032, x) for x = 1, but any query q with fewer than #runs(s) \u2212 4 runs cannot distinguish s and s\u2032 because MSS(seq, x) = MSS(seq\u2032, x) for all x \u2265 2, where x = #runs(s)\u2212#runs(q)2 . \u25c0"
        },
        {
            "heading": "5.3 Exact Recovery with Extra Character(s)",
            "text": "\u25b6 Theorem 32. For a binary alphabet {0, 1}, any algorithm to recover an arbitrary input sequence s \u2208 {0, 1}\u2113, where 0 \u2264 \u2113 \u2264 n, by querying the DTW distance to a set of sequences of length O(n) requires a query complexity of \u2126( nlog n ).\nTheorem 32 shows a lower bound on the exact recovery problem for DTW queries, which is given by an information-theoretic argument, referring back to the proof of Theorem 19.\nBefore diving into the exact recovery problem, we first introduce the concept of matching for the DTW distance. Given input sequence s and query sequence q, if we regard the characters in s and q as two sets of vertices, a matching M between s and q is a bipartite graph where each vertex has degree \u2265 1 and there do not exist \u201ccrossing\u201d edges, i.e., \u2204i < k and j > l such that the edges (s[i], q[j]) and (s[k], q[l]) both exist. Fig (a) and Fig (b) in Fig 1 are two examples of matchings. The weight of an edge (s[i], q[j]) in the matching is \u2225s[i] \u2212 q[j]\u2225, and the cost of a matching is defined to be the sum of the weights of all edges in the matching. The DTW distance between sequences corresponds to the smallest cost of a matching between them. For the formal definitions of Monotonic Sequence, Matching, DTW Matching, and Isomorphic Matching, please refer to the full version of our paper.\nWe show that, if we augment the ability of our oracles by introducing extra characters, we can solve the DTW distance oracle recovery problem with optimal query complexity up to polylogarithmic factors.\n5.3.1 With O(1) Extra Characters \u25b6 Theorem 33. For a binary alphabet {0, 1} and an input sequence s := {0, 1}\u2113 where 0 \u2264 \u2113 \u2264 n, there exists an algorithm to recover the input sequence s, given O(n2) query sequences Q and the values dDT W (s, q) to each query sequence q \u2208 Q, where the query sequences are allowed to use only one extra character.\nFor the proof of Theorem 33, please refer to the full version of the paper.\n\u25b6 Theorem 34. For a binary alphabet {0, 1} and an input sequence s := {0, 1}\u2113 where 0 \u2264 \u2113 \u2264 n, there exists an algorithm to recover the input sequence s, given O(n) query sequences Q of length \u2264 n and the values dDT W (s, q) to each query sequence q \u2208 Q, where the query sequences are allowed to use only O(1) extra characters.\nProof sketch. We would like to construct a query set of size O(n) that can recover the input sequence using a DTW distance oracle. A natural idea is to retrieve information about the input sequence by differentiating (i.e., computing the difference between) the query results of neighbouring queries (i.e., queries only differing by 1 character). To achieve this, we construct a query set satisfying the following three properties:\n1) Isomorphism: The matchings corresponding to neighboring queries should be isomorphic. Fig (a) and (b) in Fig 1 is an example of an isomorphism, where only one character of the input sequence is changed, while the structure of both optimal matchings remains identical. With this property, we know that the difference between the query results of neighboring queries only reflects the effects of the different characters in neighboring queries. This property is the essence of guaranteeing the correctness of differentiation.\n2) Input-uniqueness: Each character in the query sequence should be matched to exactly 1 character in the input sequence. With this property, we can use differentiation to get the information of a single character in the input sequence with a pair of neighboring queries. Note that if the differing character in the neighboring queries is matched to multiple characters in the input sequence, the difference in the query results can only reflect the sum of the costs over these characters, which makes exact recovery hard. Take Fig (a) and Fig (b) in Fig 1 as an example. Input-uniqueness is satisfied for both Fig (a) and Fig (b), since all characters in the query sequences of both figures have degree 1. Since Fig (a) has cost 3(1 \u2212 a) + 2a + b while Fig (b) has cost 2(1 \u2212 a) + 2a + (1 \u2212 b) + b, we know that Cost(Fig(a)) \u2212 Cost(Fig(b)) = b \u2212 a. By differentiation, we can infer that s[4] = 1; otherwise, if s[4] = 0, we would have Cost(Fig(a)) \u2212 Cost(Fig(b)) = (a \u2212 0) \u2212 (b \u2212 0) = a \u2212 b.\nCombining properties 1) and 2), we note that each character in the input sequence can match to 1 or more characters in the query sequence, so we can obtain an expansion of the input sequence. Based on the example, Fig (a) and Fig (b) in Fig 1, we can obtain an expansion, 110010, of the input sequence. We can then infer that the input sequence is of the form 1x0y10, where x, y \u2208 [1, 2]. To recover the exact input sequence, we require more information given by the following third property.\n3) 0/1-uniqueness: In an optimal matching w.r.t. our constructed queries, either all 0\u2019s or all 1\u2019s in the input sequence have degree 1. Using this property, we can locate the exact position of either all 0\u2019s or all 1\u2019s in the input sequence, and exactly recover the input\nITCS 2023\nsequence by combining the two cases. In example Fig 1, 1-uniqueness is satisfied in Fig (a) and Fig (b), while 0-uniqueness is not, since s[3] in both figures has degree 2. According to 1-uniqueness, we can reduce the form of the input sequence from 1x0y10 to 110y10. Similarly, we can construct another set of queries that satisfies 0-uniqueness to locate the positions of 0\u2019s in the input sequence, which determines y in this example.\nSequence Monotonicity \u2192 Input-uniqueness. We observe that property 2) can be obtained from a monotonic design of the query sequences.\n\u25b6 Lemma 35. Given a monotonic sequence r = r1r2...rn where\nmin i\u2208[n] max{|ri \u2212 0|, |ri \u2212 1|} > max i,j\u2208[n] |ri \u2212 rj |, (1)\nfor any input sequence s with length \u2113 \u2264 n, given a DTW matching M for (r, s), we have deg(ri) = 1 for all elements ri in r.\nWhile we defer the formal proof to the full version of this work, the intuition for Lemma 35 is that, with the monotonic property and equation (1) guaranteed in our query construction, we can ensure that there do not exist characters s[i] \u2208 s and r[j] \u2208 r where deg(s[i]) > 1 and deg(r[j]) > 1 are satisfied at the same time. Otherwise, for such a pair of s[i] and r[j], we can always construct a matching with lower cost where one of their degrees is decreased to 1. Therefore, either all characters in s or all characters in r would have degree 1. Since len(r) = n \u2265 len(s), we know that deg(ri) = 1 for all characters ri in r. Fig (a) and Fig (b) in Fig 1 satisfy sequence monotonicity since the query sequences in both figures are monotonic sequences of length n and mini\u2208[n] max{|qi \u2212 0|, |qi \u2212 1|} = 35 > ( 2 5 \u2212 1 3 ) = maxi,j\u2208[n] |qi \u2212 qj |.\nSequence 0/1-preference \u2192 0/1-uniqueness. We observe that property 3) can be guaranteed by the 0/1-preferred design of the query sequences. If all characters in the query sequence are less than (or greater than) 12 , then we can guarantee 1-uniqueness (or 0-uniqueness) of the input sequence. Intuitively, this would hold because, if all characters in the query sequence are less than (or greater than) 12 , matching them to 0\u2019s (or 1\u2019s) in the input sequence yields lower cost than matching to 1\u2019s (or 0\u2019s). Fig (a) and Fig (b) in Fig 1 satisfies 0-preference, since all characters in query sequences (either a = 13 or b = 2 5 ) are less than 1 2 .\nQuery Construction. We now propose the following design of the query sequence. We first need a single 0 query and a single 1 query to obtain the number of 1\u2019s and 0\u2019s in the input sequence. Let a, b be two fractional characters that satisfy 0 < b \u2212 a < a < b < 12 and the denominators of a, b are co-prime. Without loss of generality, we can assume a = 13 and b = 25 . We will use a, b as the extra characters to construct the query sequences. In particular, the rest of the query sequences (other than the 0 query and the 1 query) consist of queries Q in the form of q(i) = an\u2212ibi, where i = 1, . . . , n. This query construction satisfies sequence monotonicity and sequence 0/1-preference properties. Now we need to prove it also satisfies isomorphism.\nNotation clarification. For the rest of the proof, we will use q(i) to denote the i-th query in the query set Q and q(i)j the j-th character in q(i).\n\u25b6 Lemma 36. For any input sequence s, there exists an isomorphic set of matchings M, where Mi \u2208 M is optimal for query q(i) \u2208 Q.\nLemma 36 guarantees the isomorphism property of the constructed query set Q. Here we construct an isomorphic set of matchings Mi \u2208 M such that only the first 0 in the input sequence has degree greater than 1, while all other characters in the matching are of degree 1. Fig (a) and Fig (b) in Fig 1 are instances of M1 and M2, where the matchings in both figures are isomorphic to each other. Note that in this construction, the structure of the matchings is only determined by the position of the first 0 in the input sequence and the length of both sequences. Since all query sequences in Q have the same length, an isomorphism of constructed matchings is naturally guaranteed.\nTo prove the optimality of the Mi, we introduce the notion of a \u201cshifting\u201d operation. Consider two 0\u2019s in the input sequence. If any character between them has degree 1 and the first 0 has degree greater than 1, by running the shifting operation we decrease the degree of the first 0 by 1 and increase the degree of the last 0 by 1, while preserving the degree of all other characters. Fig (c) in Fig 1 illustrates an example of the shifting operation.\n\u25b7 Claim 37. For our constructed query set Q, a shifting operation would not reduce the total cost of the matching.\n\u25b7 Claim 38. Given input sequence s, query q(i) \u2208 Q and any optimal matching M\u2217i between s and q(i), we can obtain M\u2217i by applying a series of shifting operations to Mi.\nCombining the above two claims, we can show that the Mi are always optimal, which proves Lemma 36. So far, the constructed query set satisfies three properties \u2013 isomorphism, input-uniqueness, and 0/1-uniqueness. Further details of our algorithm to recover the input sequence are given in the full version. For an algorithmic sketch, see Algorithm 1. \u25c0\n6 Recovery Using Fr\u00e9chet Distance Oracle\nConsider two sequences x and y (x \u0338= y) defined on the binary alphabet {0, 1}. It is not possible to distinguish any x and y under Fr\u00e9chet distance, because the Fr\u00e9chet distance between x and y can be 0. To make the problem non-trivial for Fr\u00e9chet distance, we first define the concept of equivalent sequences under Fr\u00e9chet distance.\n\u25b6 Definition 39 (Equivalent Sequences under Fr\u00e9chet Distance). Given two sequences x and y, we say x and y are equivalent if y is obtained by taking any bit in x and copying this bit contiguously any number of times. For any pair of equivalent sequences, the Fr\u00e9chet distance between them is 0.\n\u25b6 Theorem 40. For a binary alphabet {0, 1}, any algorithm to recover an arbitrary input sequence s \u2208 {0, 1}i, where 0 \u2264 i \u2264 n, by querying its Fr\u00e9chet distance to a non-adaptive set of sequences, requires a query complexity of \u2126(n).\nProof. For each length 1 \u2264 i \u2264 n, there exists two non-equivalent sequences under Fr\u00e9chet distance, which are 010101 . . . and 101010 . . ., yielding 2n mutually non-equivalent sequences. As the Fr\u00e9chet distance oracle returns 0 when the input sequence and the query sequence are equivalent and 1 otherwise, we would need at least 2n \u2212 1 queries to exactly recover the input sequence. If the number of queries is less than 2n \u2212 1, we can always select 2 sequences from the 2n mutually non-equivalent sequences which are not covered by the queries, and these two sequences cannot be distinguished by the query sequences. This yields an \u2126(n) lower bound on the query complexity. \u25c0\n\u25b6 Theorem 41 (Extra Characters Are Not Helpful). Given two sequences s and s\u2032, if dF (s, s\u2032) = 0, then any query q with extra characters cannot distinguish s and s\u2032.\nITCS 2023\nAlgorithm 1 Exact Recovery via Non-adaptive DTW Queries (with O(1) Extra Chars).\nInput: Non-adaptive query sequences Q = {q(1), q(2), . . . , q(n+2)}, where q(n+1) = 0, q(n+2) = 1 and the rest of the queries follow our construction; The DTW query results R = {d1, d2, . . . , dn+2}.\nOutput: The sequence s to be recovered. 1 Function RecoveryDTW(Q, R): 2 if dn+1 = 0 then 3 return s := 0dn+2 4 if dn+2 = 0 then 5 return s := 1dn+1 6 positions:= [], coef_1 := 0 7 for i \u2208 [1, n] do \u25b7 Corresponding queries q(i) = an\u2212ibi 8 coef := di \u2217 15 \u2217 2 mod 5 9 if (coef - coef_1 + 5) mod 5 = 2 then\n10 positions.append(0) 11 else if (coef - coef_1 + 5) mod 5 = 3 then 12 positions.append(1) 13 coef_1 := coef 14 positions.reverse() 15 sequence := [], i := 0 16 n_0 := dn+2, n_1 := dn+1 17 while positions[i] = 1 do 18 sequence.append(1) 19 i += 1 20 i += n \u2212 n_0 \u2212 n_1 21 while i < n do 22 sequence.append(positions[i]) 23 i += 1 24 return s := sequence\nProof. We show that, given an optimal matching between s and any query q, we can construct a matching between s\u2032 and q with the same cost, and vice versa. In this way, we know that dF (s, q) \u2265 dF (s\u2032, q) and dF (s\u2032, q) \u2265 dF (s, q), so dF (s, q) = dF (s\u2032, q) and q cannot distinguish s and s\u2032. Since dF (s, s\u2032) = 0, s and s\u2032 have the same condensed expression. Suppose s and s\u2032 have k runs. Let qsi denote the substring in q which is matched to the i-th run of s, where i \u2208 [k]. We can always match all qsi\u2019s to the i-th run of s\u2032 instead, and obtain a matching between s\u2032 and q with a cost of dF (s, q). This finishes the proof of Theorem 41. \u25c0\n\u25b6 Theorem 42. For a binary alphabet {0, 1} and two input sequences s, s\u2032 \u2208 {0, 1}i where 0 \u2264 i \u2264 n and s and s\u2032 are non-equivalent sequences under Fr\u00e9chet distance, there exists an algorithm to distinguish the input sequences s and s\u2032, given O(n) query sequences Q and the Fr\u00e9chet distance of s and s\u2032 to each query sequence q \u2208 Q.\nProof. We first show that for each length 0 \u2264 i \u2264 n, there are only two non-equivalent sequences under Fr\u00e9chet distance, which are 010101... and 101010... sequences, viz., we can identify two non-equivalent sequences by specifying the sequence length i and the starting bit. Therefore, for a maximum length n, there are only 2n mutually non-equivalent sequences.\nGiven any two different sequences from this 2n-sized collection of non-equivalent sequences under Fr\u00e9chet distance, we can use O(n) query sequences to distinguish them. That is, we can utilize the exact set of 2n non-equivalent sequences as the query sequences. If the query sequence p is exactly the input sequence q, the Fr\u00e9chet distance between p and q is dF (p, q) = 0. If the query sequence p is not equivalent to the input sequence q, then the Fr\u00e9chet distance between p and q is dF (p, q) = 1 because it is impossible to skip over a bit without paying cost 1. Therefore, 2n query sequences suffice to distinguish any two sequences from the non-equivalent sequence set and this finishes the proof. \u25c0\nThis theorem shows that, if an input is in the collection of non-equivalent sequences under Fr\u00e9chet distance, we can use O(n) queries to exactly recover this sequence given the query results under the Fr\u00e9chet distance.\n7 Related Work\nA distance embedding [20] embeds sequences from the original distance metric space to other distance measures (usually lp norms), such that the distance measurements in the original space can be preserved up to a factor of D, namely the distortion rate. The sequence distance embedding problem is related to our problem in the sense that, in our problem, we intend to recover the input sequence from a list of query results that are in the lp space, which can be regarded as finding a special distance embedding. Existing works on the sequence distance embedding problem mainly focus on constructing such an embedding which can have a close approximation (viz., low distortion rate) and reduce the computational complexity (i.e., cost) on the new distance space. [5] shows a lower bound of 3/2 on the distortion rate of embedding edit distance into \u2113p norm spaces. An improvement of (log n) 1 2 \u2212o(1) on this lower bound [25] has been further simplified and improved into \u2126(log n) by [27]. Distance embeddings can be used to estimate the distance on the complex metric space because the evaluation and computations on the new (simpler metric) space can be significantly faster [20]. Under the asymmetric query model (when estimating the edit distance between x and y, the algorithm has unrestricted power accessing x but limited power accessing y), [6] proposes a (log n)O(1/\u03f5) approximation algorithm that runs in n1+\u03f5 time. [15] considers the alignment problem when estimating the edit distance (finding the sequence of edits between the estimated sequences) and presents an alignment with (log n)O(1/\u03f52) approximation in time O\u0303(n1+\u03f5). The sequence distance embedding problem has been investigated on other distance metrics as well, for example, the block edit distance [20] and the Ulam distance [16]. Existing work also shows embeddings from edit distance to the Hamming space [8, 14]. However, to the best of our knowledge, there is no prior work considering the embedding problem of the DTW distance and the exact recovery problem based on distance queries.\n8 Open Problems and Research Directions\nWe initiate the study of an exact recovery problem of sequences using queries to a nondecomposable distance oracle. We show recovery algorithms for edit distance, DTW distance, and Fr\u00e9chet distance, as well as a general adaptive algorithm for a wide class of distance oracles. We envision the following directions for future work.\nFirst, for the edit distance, there is still a quadratic gap between the non-adaptive query complexity upper and lower bounds without extra characters. Closing this gap may require a deeper understanding about the properties of edit distance.\nITCS 2023\nSecond, for the DTW distance, it remains unclear whether 1 extra character suffices for an O(n) non-adaptive upper bound, or we can have an \u2126(n2) non-adaptive lower bound with 1 extra character (our proof uses 2 extra characters).\nLastly, it would be interesting to consider the exact sequence recovery problem using the properties of specific distance metrics. For example, the Edit distance with Real Penalty (ERP) distance [17] which supports local time shifting in time series by the marriage of the \u21131 norm and edit distance, would be of interest. One can also consider other variants of our problem in terms of adaptive queries or approximate recovery in the presence of noise.\nReferences 1 Amir Abboud, Arturs Backurs, and Virginia Vassilevska Williams. Tight hardness results\nfor LCS and other sequence similarity measures. In 2015 IEEE 56th Annual Symposium on Foundations of Computer Science, pages 59\u201378. IEEE, 2015. 2 Peyman Afshani, Manindra Agrawal, Benjamin Doerr, Carola Doerr, Kasper Green Larsen, and Kurt Mehlhorn. The query complexity of a permutation-based variant of Mastermind. Discrete Applied Mathematics, 260:28\u201350, 2019. 3 Pankaj K Agarwal, Rinat Ben Avraham, Haim Kaplan, and Micha Sharir. Computing the discrete fr\u00e9chet distance in subquadratic time. SIAM Journal on Computing, 43(2):429\u2013449, 2014. 4 M Aldridge, O Johnson, and J Scarlett. Group testing: An information theory perspective. Foundations and Trends in Communications and Information Theory, 15(3-4):196\u2013392, 2019. 5 A Andoni, M Deza, A Gupta, P Indyk, and S Raskhodnikova. Lower bounds for embedding edit distance into normed spaces. In Proceedings of the fourteenth annual ACM-SIAM symposium on Discrete algorithms, pages 523\u2013526, 2003. 6 Alexandr Andoni, Robert Krauthgamer, and Krzysztof Onak. Polylogarithmic approximation for edit distance and the asymmetric query complexity. In 2010 IEEE 51st Annual Symposium on Foundations of Computer Science, pages 377\u2013386. IEEE, 2010. 7 Boris Aronov, Sariel Har-Peled, Christian Knauer, Yusu Wang, and Carola Wenk. Fr\u00e9chet distance for curves, revisited. In European symposium on algorithms, pages 52\u201363. Springer, 2006. 8 Djamal Belazzougui and Qin Zhang. Edit distance: Sketching, streaming, and document exchange. In 2016 IEEE 57th Annual Symposium on Foundations of Computer Science (FOCS), pages 51\u201360. IEEE, 2016. 9 Vladimir Braverman, Moses Charikar, William Kuszmaul, David P Woodruff, and Lin F Yang. The one-way communication complexity of dynamic time warping distance. arXiv preprint, 2019. arXiv:1903.03520. 10 Nader H Bshouty. Optimal algorithms for the coin weighing problem with a spring scale. In COLT, volume 2009, page 82, 2009. 11 Maike Buchin, Anne Driemel, Koen van Greevenbroek, Ioannis Psarros, and Dennis Rohde. Approximating length-restricted means under dynamic time warping. arXiv preprint, 2021. arXiv:2112.00408. 12 Xingyu Cai, Tingyang Xu, Jinfeng Yi, Junzhou Huang, and Sanguthevar Rajasekaran. DTWNet: a dynamic time warping network. Advances in neural information processing systems, 32, 2019. 13 David G Cantor and WH Mills. Determination of a subset from certain combinatorial properties. Canadian Journal of Mathematics, 18:42\u201348, 1966. 14 Diptarka Chakraborty, Elazar Goldenberg, and Michal Koucky\u0300. Streaming algorithms for embedding and computing edit distance in the low distance regime. In Proceedings of the forty-eighth annual ACM symposium on Theory of Computing, pages 712\u2013725, 2016. 15 Moses Charikar, Ofir Geri, Michael P Kim, and William Kuszmaul. On estimating edit distance: Alignment, dimension reduction, and embeddings. In ICALP, 2018.\n16 Moses Charikar and Robert Krauthgamer. Embedding the Ulam metric into l1. Theory of Computing, 2(1):207\u2013224, 2006.\n17 Lei Chen and Raymond Ng. On the marriage of lp-norms and edit distance. In Proceedings of the Thirtieth international conference on Very large data bases-Volume 30, pages 792\u2013803, 2004.\n18 Jeremy M Cohen, Elan Rosenfeld, and J Zico Kolter. Certified adversarial robustness via randomized smoothing. arXiv preprint, 2019. arXiv:1902.02918.\n19 Amin Coja-Oghlan, Oliver Gebhard, Max Hahn-Klimroth, and Philipp Loick. Optimal group testing. In Conference on Learning Theory, pages 1374\u20131388. PMLR, 2020.\n20 Graham Cormode. Sequence distance embeddings. PhD thesis, Department of Computer Science, 2003.\n21 Robert Dorfman. The detection of defective members of large populations. The Annals of Mathematical Statistics, 14(4):436\u2013440, 1943.\n22 Manuel Fern\u00e1ndez, David P Woodruff, and Taisuke Yasuda. The query complexity of mastermind with lp distances. Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques, 2019.\n23 Zhuangfei Hu, Xinda Li, David P Woodruff, Hongyang Zhang, and Shufan Zhang. Recovery from non-decomposable distance oracles. arXiv preprint, 2022. arXiv:2209.05676.\n24 Zilin Jiang and Nikita Polyanskii. On the metric dimension of cartesian powers of a graph. Journal of Combinatorial Theory, Series A, 165:1\u201314, 2019.\n25 Subhash Khot and Assaf Naor. Nonembeddability theorems via Fourier analysis. In 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS\u201905), pages 101\u2013110. IEEE, 2005.\n26 Donald E Knuth. The computer as Master Mind. Journal of Recreational Mathematics, 9(1):1\u20136, 1976.\n27 Robert Krauthgamer and Yuval Rabani. Improved lower bounds for embeddings into l1. SIAM Journal on Computing, 38(6):2487\u20132498, 2009.\n28 Ilan Kremer, Noam Nisan, and Dana Ron. On randomized one-round communication complexity. In Frank Thomson Leighton and Allan Borodin, editors, Proceedings of the Twenty-Seventh Annual ACM Symposium on Theory of Computing, 29 May-1 June 1995, Las Vegas, Nevada, USA, pages 596\u2013605. ACM, 1995. doi:10.1145/225058.225277.\n29 Mathias Lecuyer, Vaggelis Atlidakis, Roxana Geambasu, Daniel Hsu, and Suman Jana. Certified robustness to adversarial examples with differential privacy. In IEEE Symposium on Security and Privacy, pages 656\u2013672, 2019.\n30 Vladimir I Levenshtein. Binary codes capable of correcting deletions, insertions, and reversals. In Soviet physics doklady, volume 10, pages 707\u2013710, 1966.\n31 Ming Li and Paul MB Vit\u00e1nyi. Combinatorics and Kolmogorov complexity. In 1991 Proceedings of the Sixth Annual Structure in Complexity Theory Conference, pages 154\u2013155. IEEE Computer Society, 1991.\n32 Juan A Rodr\u00edguez-Vel\u00e1zquez, Ismael G Yero, Dorota Kuziak, and Ortrud R Oellermann. On the strong metric dimension of Cartesian and direct products of graphs. Discrete Mathematics, 335:8\u201319, 2014.\n33 Nathan Schaar, Vincent Froese, and Rolf Niedermeier. Faster binary mean computation under dynamic time warping. arXiv preprint, 2020. arXiv:2002.01178.\n34 Harold S Shapiro and NJ Fine. E1399. The American Mathematical Monthly, 67(7):697\u2013698, 1960.\n35 Staffan S\u00f6derberg and Harold S Shapiro. A combinatory detection problem. The American Mathematical Monthly, 70(10):1066\u20131070, 1963.\n36 Roman Vershynin. Lectures in geometric functional analysis. Unpublished manuscript. Available at https://www.math.uci.edu/~rvershyn/papers/GFA-book.pdf, 3(3):3\u20133, 2011.\n37 Chao Wang, Qing Zhao, and Chen-Nee Chuah. Optimal nested test plan for combinatorial quantitative group testing. IEEE Transactions on Signal Processing, 66(4):992\u20131006, 2017.\nITCS 2023\nA Coordinate Descent Algorithm Instantiation\nNow we briefly discuss how we apply our Coordinate Descent algorithm to all three distances we consider in this paper by justifying the two conditions hold.\nEdit distance. For condition 2, we know that \u2200q, q\u2032, dist(q, q\u2032) \u2264 n since the maximum length of q and q\u2032 is n. For condition 1, in each iteration, we consider a set Q that contains all sequences that can be transformed from q\u2032 by inserting, deleting or substituting one character in q\u2032 (edit operations). Note that |Q| cannot exceed (n + 1) + n + n = 3n + 1. We claim that there exists a q\u2032\u2032 in Q such that dist(q, q\u2032) > dist(q, q\u2032\u2032). Let dist(q\u2032, q) = d. By the definition of edit distance, there exists a chain of edit operations of length d that transforms q\u2032 to q, resulting in a list of intermediate sequences q1, . . . , qd\u22121. Note that dist(q\u2032, q) > dist(q1, q), otherwise dist(q1, q) \u2265 d. However, the chain implies we can transform q1 to q in d \u2212 1 edit operations, which leads to a contradiction. Since q1 \u2208 Q, we can find q1 satisfying the condition in 3n + 1 searches. Therefore, the algorithm is guaranteed to recover the input in O(n2) steps.\nDTW distance. For DTW distance, condition 2 holds since \u2200q, q\u2032, dist(q, q\u2032) \u2264 n. For condition 1, consider the #runs(x) in q\u2032 and q. If #runs(x) of q\u2032 < q, then either adding an (arbitrary length) run to the start or the end of q\u2032 will decrease the DTW distance from q. On the other hand, if #runs(x) of q\u2032 > q, then either deleting a run from the start or the end of q\u2032 will decrease the DTW distance from q. If #runs(x) of q\u2032 = q and dist(q\u2032, q) \u0338= 0, we can still decrease the distance from q by either adding/deleting a run to the start/end of the sequence. Therefore, the algorithm is guaranteed to recover the input in O(n) steps.\nFr\u00e9chet distance. Condition 2 holds since \u2200q, q\u2032, dist(q, q\u2032) \u2264 1. For condition 1, enumerating 2n non-equivalent sequences, (i.e., 010101... and 101010...) guarantees finding q\u2032\u2032 such that dist(q, q\u2032) > dist(q, q\u2032\u2032) = 0. Therefore, the algorithm terminates in O(n) steps."
        }
    ],
    "title": "Recovery from Non-Decomposable Distance Oracles",
    "year": 2023
}