{
    "abstractText": "Driven by exploring the power of quantum computation with a limited number of qubits, we present a novel complete characterization for space-bounded quantum computation, which encompasses settings with one-sided error (unitary coRQL) and two-sided error (BQL), approached from a quantum (mixed) state testing perspective: \u2022 The first family of natural complete problems for unitary coRQL, namely space-bounded quantum state certification for trace distance and Hilbert-Schmidt distance; \u2022 A new family of (arguably simpler) natural complete problems for BQL, namely spacebounded quantum state testing for trace distance, Hilbert-Schmidt distance, and (von Neumann) entropy difference. In the space-bounded quantum state testing problem, we consider two logarithmic-qubit quantum circuits (devices) denoted as Q0 and Q1, which prepare quantum states \u03c10 and \u03c11, respectively, with access to their \u201csource code\u201d. Our goal is to decide whether \u03c10 is \u01eb1-close to or \u01eb2-far from \u03c11 with respect to a specified distance-like measure. Interestingly, unlike time-bounded state testing problems, which exhibit computational hardness depending on the chosen distance-like measure (either QSZK-complete or BQP-complete), our results reveal that the space-bounded state testing problems, considering all three measures, are computationally as easy as preparing quantum states. Our results primarily build upon a space-efficient variant of the quantum singular value transformation (QSVT) introduced by Gily\u00e9n, Su, Low, and Wiebe (STOC 2019), which is of independent interest. Our technique provides a unified approach for designing spacebounded quantum algorithms. Specifically, we show that implementing QSVT for any bounded polynomial that approximates a piecewise-smooth function incurs only a constant overhead in terms of the space required for (special forms of) the projected unitary encoding. Email: legall@math.nagoya-u.ac.jp Email: yupan.liu.e6@math.nagoya-u.ac.jp Email: QishengWang1994@gmail.com",
    "authors": [
        {
            "affiliations": [],
            "name": "Fran\u00e7ois Le Gall"
        },
        {
            "affiliations": [],
            "name": "Yupan Liu"
        },
        {
            "affiliations": [],
            "name": "Qisheng Wang"
        }
    ],
    "id": "SP:14948ba33662c2eda9e05bb06ee09ffecdaff09a",
    "references": [
        {
            "authors": [
                "Jayadev Acharya",
                "Sourbh Bhadane",
                "Piotr Indyk",
                "Ziteng Sun"
            ],
            "title": "Estimating entropy of distributions in constant space",
            "venue": "Advances in Neural Information Processing Systems,",
            "year": 2019
        },
        {
            "authors": [
                "William Aiello",
                "Johan H\u00e5stad"
            ],
            "title": "Statistical zero-knowledge languages can be recognized in two rounds",
            "venue": "Journal of Computer and System Sciences,",
            "year": 1991
        },
        {
            "authors": [
                "Jayadev Acharya",
                "Ibrahim Issa",
                "Nirmal V. Shende",
                "Aaron B. Wagner"
            ],
            "title": "Estimating quantum entropy",
            "venue": "IEEE Journal on Selected Areas in Information Theory,",
            "year": 2020
        },
        {
            "authors": [
                "Dorit Aharonov",
                "Vaughan Jones",
                "Zeph Landau"
            ],
            "title": "A polynomial quantum algorithm for approximating the Jones polynomial",
            "year": 2009
        },
        {
            "authors": [
                "Dorit Aharonov",
                "Alexei Kitaev",
                "Noam Nisan"
            ],
            "title": "Quantum circuits with mixed states",
            "venue": "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing,",
            "year": 1998
        },
        {
            "authors": [
                "Maryam Aliakbarpour",
                "Andrew McGregor",
                "Jelani Nelson",
                "Erik Waingarten"
            ],
            "title": "Estimation of entropy in constant space with improved sample complexity",
            "venue": "Advances in Neural Information Processing Systems,",
            "year": 2022
        },
        {
            "authors": [
                "Noga Alon",
                "Joel H Spencer"
            ],
            "title": "The Probabilistic Method",
            "year": 2016
        },
        {
            "authors": [
                "Zeyuan Allen-Zhu",
                "Yin Tat Lee",
                "Lorenzo Orecchia"
            ],
            "title": "Using optimization to obtain a width-independent, parallel, simpler, and faster positive SDP solver",
            "venue": "In Proceedings of the 27th Annual ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2016
        },
        {
            "authors": [
                "Avraham Ben-Aroya",
                "Oded Schwartz",
                "Amnon Ta-Shma"
            ],
            "title": "Quantum expanders: Motivation and construction",
            "venue": "Theory of Computing,",
            "year": 2010
        },
        {
            "authors": [
                "Michel Boyer",
                "Gilles Brassard",
                "Peter H\u00f8yer",
                "Alain Tapp"
            ],
            "title": "Tight bounds on quantum searching",
            "venue": "Fortschritte der Physik: Progress of Physics,",
            "year": 1998
        },
        {
            "authors": [
                "Dominic W. Berry",
                "Andrew M. Childs",
                "Richard Cleve",
                "Robin Kothari",
                "Rolando D. Somma"
            ],
            "title": "Simulating Hamiltonian dynamics with a truncated Taylor series",
            "venue": "Physical Review Letters,",
            "year": 2015
        },
        {
            "authors": [
                "Adam Bouland",
                "Lijie Chen",
                "Dhiraj Holden",
                "Justin Thaler",
                "Prashant Nalini Vasudevan"
            ],
            "title": "On the power of statistical zero knowledge",
            "venue": "SIAM Journal on Computing,",
            "year": 2019
        },
        {
            "authors": [
                "Harry Buhrman",
                "Richard Cleve",
                "John Watrous",
                "Ronald de Wolf"
            ],
            "title": "Quantum fingerprinting",
            "venue": "Physical Review Letters,",
            "year": 2001
        },
        {
            "authors": [
                "Itay Berman",
                "Akshay Degwekar",
                "Ron D Rothblum",
                "Prashant Nalini Vasudevan"
            ],
            "title": "Statistical difference beyond the polarizing regime",
            "venue": "In Theory of Cryptography Conference,",
            "year": 2019
        },
        {
            "authors": [
                "Jop Bri\u00ebt",
                "Peter Harremo\u00ebs"
            ],
            "title": "Properties of classical and quantum JensenShannon divergence",
            "venue": "Physical review A,",
            "year": 2009
        },
        {
            "authors": [
                "Gilles Brassard",
                "Peter H\u00f8yer",
                "Michele Mosca",
                "Alain Tapp"
            ],
            "title": "Quantum amplitude amplification and estimation",
            "venue": "Quantum Computation and Information,",
            "year": 2002
        },
        {
            "authors": [
                "Andrej Bogdanov",
                "Chin Ho Lee"
            ],
            "title": "Limits of provable security for homomorphic encryption",
            "venue": "In Annual Cryptology Conference,",
            "year": 2013
        },
        {
            "authors": [
                "Jos\u00e9 L Balc\u00e1zar",
                "Antoni Lozano",
                "Jacobo Tor\u00e1n"
            ],
            "title": "The complexity of algorithmic problems on succinct instances",
            "venue": "In Computer science: research and applications,",
            "year": 1992
        },
        {
            "authors": [
                "Costin B\u0103descu",
                "Ryan O\u2019Donnell",
                "John Wright"
            ],
            "title": "Quantum state certification",
            "venue": "In Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing,",
            "year": 2019
        },
        {
            "authors": [
                "Cl\u00e9ment L Canonne"
            ],
            "title": "A survey on distribution testing: Your data is big. but is it blue",
            "venue": "Theory of Computing,",
            "year": 2020
        },
        {
            "authors": [
                "Rui Chao",
                "Dawei Ding",
                "Andras Gilyen",
                "Cupjin Huang",
                "Mario Szegedy"
            ],
            "title": "Finding angles for quantum signal processing with machine precision",
            "venue": "arXiv preprint arXiv:2003.02831,",
            "year": 2020
        },
        {
            "authors": [
                "Gil Cohen",
                "Dean Doron",
                "Ori Sberlo",
                "Amnon Ta-Shma"
            ],
            "title": "Approximating iterated multiplication of stochastic matrices in small space",
            "venue": "In Proceedings of the 55th Annual ACM Symposium on Theory of Computing,",
            "year": 2023
        },
        {
            "authors": [
                "Siu-On Chan",
                "Ilias Diakonikolas",
                "Paul Valiant",
                "Gregory Valiant"
            ],
            "title": "Optimal algorithms for testing closeness of discrete distributions",
            "venue": "In Proceedings of the 25th Annual ACM-SIAM Symposium on Discrete Algorithms,",
            "year": 2014
        },
        {
            "authors": [
                "Howard Cheng",
                "Barry Gergel",
                "Ethan Kim",
                "Eugene Zima"
            ],
            "title": "Space-efficient evaluation of hypergeometric series",
            "venue": "ACM SIGSAM Bulletin,",
            "year": 2005
        },
        {
            "authors": [
                "Steve Chien",
                "Katrina Ligett",
                "Andrew McGregor"
            ],
            "title": "Space-efficient estimation of robust statistics and distribution testing",
            "venue": "In ICS,",
            "year": 2010
        },
        {
            "authors": [
                "Anirban N. Chowdhury",
                "Guang Hao Low",
                "Nathan Wiebe"
            ],
            "title": "A variational quantum algorithm for preparing quantum Gibbs states",
            "venue": "ArXiv e-prints,",
            "year": 2020
        },
        {
            "authors": [
                "Ilias Diakonikolas",
                "Themis Gouleakis",
                "Daniel M Kane",
                "Sankeerth Rao"
            ],
            "title": "Communication and memory efficient testing of discrete distributions",
            "venue": "In Conference on Learning Theory,",
            "year": 2019
        },
        {
            "authors": [
                "Yulong Dong",
                "Xiang Meng",
                "K Birgitta Whaley",
                "Lin Lin"
            ],
            "title": "Efficient phase-factor evaluation in quantum signal processing",
            "venue": "Physical Review A,",
            "year": 2021
        },
        {
            "authors": [
                "Ronald de Wolf"
            ],
            "title": "Quantum computing: Lecture notes",
            "venue": "arXiv preprint arXiv:1907.09415,",
            "year": 1907
        },
        {
            "authors": [
                "Bill Fefferman",
                "Hirotada Kobayashi",
                "Cedric Yen-Yu Lin",
                "Tomoyuki Morimae",
                "Harumichi Nishimura"
            ],
            "title": "Space-efficient error reduction for unitary quantum computations. In 43rd International Colloquium on Automata, Languages, and Programming (ICALP 2016)",
            "venue": "Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik,",
            "year": 2016
        },
        {
            "authors": [
                "Joan Feigenbaum",
                "Sampath Kannan",
                "Martin J. Strauss",
                "Mahesh Viswanathan"
            ],
            "title": "An approximate l1-difference algorithm for massive data streams",
            "venue": "SIAM Journal on Computing,",
            "year": 2002
        },
        {
            "authors": [
                "Steven T. Flammia",
                "Yi-Kai Liu"
            ],
            "title": "Direct fidelity estimation from few Pauli measurements",
            "venue": "Physical Review Letters,",
            "year": 2011
        },
        {
            "authors": [
                "Bill Fefferman",
                "Cedric Yen-Yu Lin"
            ],
            "title": "A complete characterization of unitary quantum space. In 9th Innovations in Theoretical Computer Science Conference (ITCS 2018)",
            "venue": "Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik,",
            "year": 2018
        },
        {
            "authors": [
                "Lance Fortnow"
            ],
            "title": "The complexity of perfect zero-knowledge",
            "venue": "In Proceedings of the 19th Annual ACM Symposium on Theory of Computing,",
            "year": 1987
        },
        {
            "authors": [
                "Bill Fefferman",
                "Zachary Remscrim"
            ],
            "title": "Eliminating intermediate measurements in space-bounded quantum computation",
            "venue": "In Proceedings of the 53rd Annual ACM SIGACT Symposium on Theory of Computing,",
            "year": 2021
        },
        {
            "authors": [
                "Christopher A Fuchs",
                "Jeroen van de Graaf"
            ],
            "title": "Cryptographic distinguishability measures for quantum-mechanical states",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 1999
        },
        {
            "authors": [
                "Alexandru Gheorghiu",
                "Matty J Hoban"
            ],
            "title": "Estimating the entropy of shallow circuit outputs is hard",
            "venue": "arXiv preprint arXiv:2002.12814,",
            "year": 2020
        },
        {
            "authors": [
                "Tom Gur",
                "Min-Hsiu Hsieh",
                "Sathyawageeswar Subramanian"
            ],
            "title": "Sublinear quantum algorithms for estimating von Neumann entropy",
            "venue": "ArXiv e-prints,",
            "year": 2021
        },
        {
            "authors": [
                "Andr\u00e1s Gily\u00e9n"
            ],
            "title": "Quantum singular value transformation & its algorithmic applications",
            "venue": "PhD thesis, University of Amsterdam,",
            "year": 2019
        },
        {
            "authors": [
                "Andr\u00e1s Gily\u00e9n",
                "Tongyang Li"
            ],
            "title": "Distributional property testing in a quantum world",
            "venue": "Schloss Dagstuhl-Leibniz-Zentrum fu\u0308r Informatik,",
            "year": 2020
        },
        {
            "authors": [
                "Sudipto Guha",
                "Andrew McGregor",
                "Suresh Venkatasubramanian"
            ],
            "title": "Streaming and sublinear approximation of entropy and information distances",
            "venue": "In Proceedings of the 17th Annual ACM-SIAM Symposium on Discrete Algorithm,",
            "year": 2006
        },
        {
            "authors": [
                "Oded Goldreich"
            ],
            "title": "Introduction to property testing",
            "year": 2017
        },
        {
            "authors": [
                "Andr\u00e1s Gily\u00e9n",
                "Alexander Poremba"
            ],
            "title": "Improved quantum algorithms for fidelity estimation",
            "venue": "arXiv preprint arXiv:2203.15993,",
            "year": 2022
        },
        {
            "authors": [
                "Lov Grover",
                "Terry Rudolph"
            ],
            "title": "Creating superpositions that correspond to efficiently integrable probability distributions",
            "venue": "arXiv preprint quant-ph/0208112,",
            "year": 2002
        },
        {
            "authors": [
                "Uma Girish",
                "Ran Raz"
            ],
            "title": "Eliminating intermediate measurements using pseudorandom generators",
            "venue": "In 13th Innovations in Theoretical Computer Science Conference, ITCS 2022,",
            "year": 2022
        },
        {
            "authors": [
                "Uma Girish",
                "Ran Raz",
                "Wei Zhan"
            ],
            "title": "Quantum logspace algorithm for powering matrices with bounded norm",
            "venue": "In 48th International Colloquium on Automata, Languages, and Programming (ICALP 2021),",
            "year": 2021
        },
        {
            "authors": [
                "Andr\u00e1s Gily\u00e9n",
                "Yuan Su",
                "Guang Hao Low",
                "Nathan Wiebe"
            ],
            "title": "Quantum singular value transformation and beyond: exponential improvements for quantum matrix arithmetics",
            "venue": "arXiv preprint arXiv:1806.01838,",
            "year": 2018
        },
        {
            "authors": [
                "Andr\u00e1s Gily\u00e9n",
                "Yuan Su",
                "Guang Hao Low",
                "Nathan Wiebe"
            ],
            "title": "Quantum singular value transformation and beyond: exponential improvements for quantum matrix arithmetics",
            "venue": "In Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing,",
            "year": 2019
        },
        {
            "authors": [
                "Oded Goldreich",
                "Amit Sahai",
                "Salil Vadhan"
            ],
            "title": "Honest-verifier statistical zeroknowledge equals general statistical zero-knowledge",
            "venue": "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing,",
            "year": 1998
        },
        {
            "authors": [
                "Oded Goldreich",
                "Salil Vadhan"
            ],
            "title": "Comparing entropies in statistical zero knowledge with applications to the structure of SZK",
            "venue": "In Proceedings. Fourteenth Annual IEEE Conference on Computational Complexity (Formerly: Structure in Complexity Theory Conference)(Cat. No. 99CB36317),",
            "year": 1999
        },
        {
            "authors": [
                "Aram W Harrow",
                "Avinatan Hassidim",
                "Seth Lloyd"
            ],
            "title": "Quantum algorithm for linear systems of equations",
            "venue": "Physical review letters,",
            "year": 2009
        },
        {
            "authors": [
                "Alexander Semenovich Holevo"
            ],
            "title": "Bounds for the quantity of information transmitted by a quantum communication channel",
            "venue": "Problemy Peredachi Informatsii,",
            "year": 1973
        },
        {
            "authors": [
                "Jiantao Jiao",
                "Kartik Venkat",
                "Yanjun Han",
                "Tsachy Weissman"
            ],
            "title": "Minimax estimation of functionals of discrete distributions",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2015
        },
        {
            "authors": [
                "Rahul Jain",
                "Penghui Yao"
            ],
            "title": "A parallel approximation algorithm for positive semidefinite programming",
            "venue": "IEEE 52nd Annual Symposium on Foundations of Computer Science,",
            "year": 2011
        },
        {
            "authors": [
                "Alastair Kay"
            ],
            "title": "Tutorial on the quantikz package",
            "venue": "arXiv preprint arXiv:1809.03842,",
            "year": 2018
        },
        {
            "authors": [
                "Alexei Yu Kitaev"
            ],
            "title": "Quantum measurements and the Abelian stabilizer problem",
            "venue": "arXiv preprint quant-ph/9511026,",
            "year": 1995
        },
        {
            "authors": [
                "Alexei Yu Kitaev"
            ],
            "title": "Quantum computations: algorithms and error correction",
            "venue": "Russian Mathematical Surveys,",
            "year": 1997
        },
        {
            "authors": [
                "Phillip Kaye",
                "Michele Mosca"
            ],
            "title": "Quantum networks for generating arbitrary quantum states",
            "venue": "In International Conference on Quantum Information. Optica Publishing Group,",
            "year": 2001
        },
        {
            "authors": [
                "Hirotada Kobayashi",
                "Keiji Matsumoto",
                "Tomoyuki Yamakami"
            ],
            "title": "Quantum Merlin-Arthur proof systems: Are multiple Merlins more helpful to Arthur",
            "venue": "Chicago Journal of Theoretical Computer Science,",
            "year": 2009
        },
        {
            "authors": [
                "Guang Hao Low",
                "Isaac L Chuang"
            ],
            "title": "Hamiltonian simulation by uniform spectral amplification",
            "venue": "arXiv preprint arXiv:1707.05391,",
            "year": 2017
        },
        {
            "authors": [
                "Guang Hao Low",
                "Isaac L. Chuang"
            ],
            "title": "Hamiltonian simulation by qubitization",
            "year": 2019
        },
        {
            "authors": [
                "Yupan Liu"
            ],
            "title": "Quantum state testing beyond the polarizing regime and quantum triangular discrimination",
            "venue": "arXiv preprint arXiv:2303.01952,",
            "year": 2023
        },
        {
            "authors": [
                "Tongyang Li",
                "Xinzhao Wang",
                "Shengyu Zhang"
            ],
            "title": "A unified quantum algorithm framework for estimating properties of discrete probability distributions",
            "venue": "ArXiv e-prints,",
            "year": 2022
        },
        {
            "authors": [
                "Ashley Montanaro",
                "Ronald de Wolf"
            ],
            "title": "A survey of quantum property testing",
            "venue": "Theory of Computing,",
            "year": 2016
        },
        {
            "authors": [
                "Marc Mezzarobba"
            ],
            "title": "A note on the space complexity of fast D-finite function evaluation",
            "venue": "In Computer Algebra in Scientific Computing: 14th International Workshop,",
            "year": 2012
        },
        {
            "authors": [
                "Ana P Majtey",
                "Pedro W Lamberti",
                "Domingo P Prato"
            ],
            "title": "Jensen-Shannon divergence as a measure of distinguishability between mixed quantum states",
            "venue": "Physical Review A,",
            "year": 2005
        },
        {
            "authors": [
                "Ashley Montanaro",
                "Sam Pallister"
            ],
            "title": "Quantum algorithms and the finite element method",
            "venue": "Physical Review A,",
            "year": 2016
        },
        {
            "authors": [
                "John M Martyn",
                "Zane M Rossi",
                "Andrew K Tan",
                "Isaac L Chuang"
            ],
            "title": "Grand unification of quantum algorithms",
            "venue": "PRX Quantum,",
            "year": 2021
        },
        {
            "authors": [
                "Michael Mitzenmacher",
                "Eli Upfal"
            ],
            "title": "Probability and computing: Randomization and probabilistic techniques in algorithms and data analysis",
            "venue": "Cambridge university press,",
            "year": 2017
        },
        {
            "authors": [
                "Danial Motlagh",
                "Nathan Wiebe"
            ],
            "title": "Generalized quantum signal processing",
            "venue": "arXiv preprint arXiv:2308.01501,",
            "year": 2023
        },
        {
            "authors": [
                "Tony Metger",
                "Henry Yuen"
            ],
            "title": "stateQIP = statePSPACE",
            "venue": "arXiv preprint arXiv:2301.07730,",
            "year": 2023
        },
        {
            "authors": [
                "Michael A Nielsen",
                "Isaac Chuang"
            ],
            "title": "Quantum Computation and Quantum Information",
            "venue": "American Association of Physics Teachers,",
            "year": 2002
        },
        {
            "authors": [
                "Ryan O\u2019Donnell",
                "John Wright"
            ],
            "title": "Quantum spectrum testing",
            "venue": "Communications in Mathematical Physics, 387(1):1\u201375,",
            "year": 2021
        },
        {
            "authors": [
                "Michael JD Powell"
            ],
            "title": "On the maximum errors of polynomial approximations defined by interpolation and by least squares criteria",
            "venue": "The Computer Journal,",
            "year": 1967
        },
        {
            "authors": [
                "Aaron Putterman",
                "Edward Pyne"
            ],
            "title": "Near-optimal derandomization of mediumwidth branching programs",
            "venue": "In Proceedings of the 55th Annual ACM Symposium on Theory of Computing,",
            "year": 2023
        },
        {
            "authors": [
                "Christos H Papadimitriou",
                "Mihalis Yannakakis"
            ],
            "title": "A note on succinct representations of graphs",
            "venue": "Information and Control,",
            "year": 1986
        },
        {
            "authors": [
                "Soorya Rethinasamy",
                "Rochisha Agarwal",
                "Kunal Sharma",
                "Mark M Wilde"
            ],
            "title": "Estimating distinguishability measures on quantum computers",
            "venue": "Physical Review A,",
            "year": 2023
        },
        {
            "authors": [
                "Omer Reingold"
            ],
            "title": "Undirected connectivity in log-space",
            "venue": "Journal of the ACM (JACM),",
            "year": 2008
        },
        {
            "authors": [
                "Michael Saks"
            ],
            "title": "Randomization and derandomization in space-bounded computation",
            "venue": "In Proceedings of Computational Complexity (Formerly Structure in Complexity Theory),",
            "year": 1996
        },
        {
            "authors": [
                "Endre S\u00fcli",
                "David F Mayers"
            ],
            "title": "An introduction to numerical analysis",
            "year": 2003
        },
        {
            "authors": [
                "Amit Sahai",
                "Salil Vadhan"
            ],
            "title": "A complete problem for statistical zero knowledge",
            "venue": "Journal of the ACM (JACM),",
            "year": 2003
        },
        {
            "authors": [
                "Michael Saks",
                "Shiyu Zhou"
            ],
            "title": "BPHSPACE(s) \u2286 DSPACE(s3/2)",
            "venue": "Journal of computer and system sciences,",
            "year": 1999
        },
        {
            "authors": [
                "Amnon Ta-Shma"
            ],
            "title": "Inverting well conditioned matrices in quantum logspace",
            "venue": "In Proceedings of the 45th Annual ACM Symposium on Theory of Computing,",
            "year": 2013
        },
        {
            "authors": [
                "Joran van Apeldoorn",
                "Andr\u00e1s Gily\u00e9n",
                "Sander Gribling",
                "Ronald de Wolf"
            ],
            "title": "Quantum SDP-solvers: Better upper and lower",
            "venue": "bounds. Quantum,",
            "year": 2020
        },
        {
            "authors": [
                "Dieter van Melkebeek",
                "Thomas Watson"
            ],
            "title": "Time-space efficient simulations of quantum computations",
            "venue": "Theory of Computing,",
            "year": 2012
        },
        {
            "authors": [
                "John Watrous"
            ],
            "title": "Space-bounded quantum complexity",
            "venue": "Journal of Computer and System Sciences,",
            "year": 1999
        },
        {
            "authors": [
                "John Watrous"
            ],
            "title": "Quantum simulations of classical random walks and undirected graph connectivity",
            "venue": "Journal of computer and system sciences,",
            "year": 2001
        },
        {
            "authors": [
                "John Watrous"
            ],
            "title": "Limits on the power of quantum statistical zero-knowledge",
            "venue": "In The 43rd Annual IEEE Symposium on Foundations of Computer Science,",
            "year": 2002
        },
        {
            "authors": [
                "John Watrous"
            ],
            "title": "On the complexity of simulating space-bounded quantum computations",
            "venue": "computational complexity,",
            "year": 2003
        },
        {
            "authors": [
                "John Watrous"
            ],
            "title": "Quantum computational complexity",
            "venue": "arXiv preprint arXiv:0804.3401,",
            "year": 2008
        },
        {
            "authors": [
                "John Watrous"
            ],
            "title": "Zero-knowledge against quantum attacks",
            "venue": "SIAM Journal on Computing,",
            "year": 2009
        },
        {
            "authors": [
                "Qisheng Wang",
                "Ji Guan",
                "Junyi Liu",
                "Zhicheng Zhang",
                "Mingsheng Ying"
            ],
            "title": "New quantum algorithms for computing quantum entropies and distances",
            "venue": "arXiv preprint arXiv:2203.13522,",
            "year": 2022
        },
        {
            "authors": [
                "Yihong Wu",
                "Pengkun Yang"
            ],
            "title": "Minimax rates of entropy estimation on large alphabets via best polynomial approximation",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2016
        },
        {
            "authors": [
                "Qisheng Wang",
                "Zhicheng Zhang"
            ],
            "title": "Fast quantum algorithms for trace distance estimation",
            "venue": "arXiv preprint arXiv:2301.06783,",
            "year": 2023
        },
        {
            "authors": [
                "Qisheng Wang",
                "Zhicheng Zhang"
            ],
            "title": "Quantum lower bounds by sample-to-query lifting",
            "venue": "arXiv preprint arXiv:2308.01794,",
            "year": 2023
        },
        {
            "authors": [
                "Qisheng Wang",
                "Zhicheng Zhang",
                "Kean Chen",
                "Ji Guan",
                "Wang Fang",
                "Junyi Liu",
                "Mingsheng Ying"
            ],
            "title": "Quantum algorithm for fidelity estimation",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2023
        },
        {
            "authors": [
                "Christof Zalka"
            ],
            "title": "Simulating quantum systems on a quantum computer",
            "venue": "Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences,",
            "year": 1998
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n30 8.\n05 07\n9v 1\n[ qu\nan t-\nph ]\n9 A\nug 2\n02 3\n\u2022 The first family of natural complete problems for unitary coRQL, namely space-bounded quantum state certification for trace distance and Hilbert-Schmidt distance;\n\u2022 A new family of (arguably simpler) natural complete problems for BQL, namely spacebounded quantum state testing for trace distance, Hilbert-Schmidt distance, and (von Neumann) entropy difference.\nIn the space-bounded quantum state testing problem, we consider two logarithmic-qubit quantum circuits (devices) denoted as Q0 and Q1, which prepare quantum states \u03c10 and \u03c11, respectively, with access to their \u201csource code\u201d. Our goal is to decide whether \u03c10 is \u01eb1-close to or \u01eb2-far from \u03c11 with respect to a specified distance-like measure. Interestingly, unlike time-bounded state testing problems, which exhibit computational hardness depending on the chosen distance-like measure (either QSZK-complete or BQP-complete), our results reveal that the space-bounded state testing problems, considering all three measures, are computationally as easy as preparing quantum states.\nOur results primarily build upon a space-efficient variant of the quantum singular value transformation (QSVT) introduced by Gily\u00e9n, Su, Low, and Wiebe (STOC 2019), which is of independent interest. Our technique provides a unified approach for designing spacebounded quantum algorithms. Specifically, we show that implementing QSVT for any bounded polynomial that approximates a piecewise-smooth function incurs only a constant overhead in terms of the space required for (special forms of) the projected unitary encoding.\n\u2217Email: legall@math.nagoya-u.ac.jp \u2020Email: yupan.liu.e6@math.nagoya-u.ac.jp \u2021Email: QishengWang1994@gmail.com\nContents"
        },
        {
            "heading": "1 Introduction 1",
            "text": "1.1 Main results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.2 Background on space-bounded quantum computation . . . . . . . . . . . . . . . . 3 1.3 Time-bounded and space-bounded distribution and state testing . . . . . . . . . . 4\n1.3.1 Time-bounded distribution and state testing . . . . . . . . . . . . . . . . . 5 1.3.2 Space-bounded distribution and state testing . . . . . . . . . . . . . . . . 6\n1.4 Proof technique: Space-efficient quantum singular value transformation . . . . . . 7 1.5 Proof overview: A general framework for quantum state testing . . . . . . . . . . 9 1.6 Discussion and open problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 1.7 Related works: more on quantum state testing problems . . . . . . . . . . . . . . 11"
        },
        {
            "heading": "2 Preliminaries 11",
            "text": "2.1 Distances and divergences for quantum states . . . . . . . . . . . . . . . . . . . . 11 2.2 Space-bounded quantum computation . . . . . . . . . . . . . . . . . . . . . . . . 12 2.3 Near-minimax approximation by Chebyshev interpolation . . . . . . . . . . . . . 14 2.4 Tools for space-bounded randomized and quantum algorithms . . . . . . . . . . . 14"
        },
        {
            "heading": "3 Space-efficient quantum singular value transformations 16",
            "text": "3.1 Space-efficient bounded polynomial approximations . . . . . . . . . . . . . . . . . 17\n3.1.1 Bounded functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 3.1.2 Piecewise-smooth functions . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n3.2 Applying Chebyshev interpolation to bitstring indexed encodings . . . . . . . . . 25 3.3 Examples: the sign function and the normalized logarithmic function . . . . . . . 28 3.4 Application: space-efficient error reduction for unitary quantum computations . . 29"
        },
        {
            "heading": "4 Space-bounded quantum state testing 30",
            "text": "4.1 Space-bounded quantum state testing: a general framework . . . . . . . . . . . . 32 4.2 GapQSDlog is in BQL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 4.3 GapQEDlog and GapQJSlog are in BQL . . . . . . . . . . . . . . . . . . . . . . . 35 4.4 CertQSDlog and CertQHSlog are in coRQUL . . . . . . . . . . . . . . . . . . . 37\n4.4.1 CertQSDlog is in coRQUL . . . . . . . . . . . . . . . . . . . . . . . . . . 38 4.4.2 CertQHSlog is in coRQUL . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n4.5 BQL- and coRQUL-hardness for space-bounded state testing problems . . . . . . . 41 4.5.1 Hardness results for GapQSDlog, GapQHSlog, and their certification version 41 4.5.2 Hardness results for GapQJSlog and GapQEDlog . . . . . . . . . . . . . . 43"
        },
        {
            "heading": "A Omitted proofs in space-efficient QSVT 50",
            "text": "B Omitted proofs in space-bounded quantum state testing 56"
        },
        {
            "heading": "1 Introduction",
            "text": "In recent years, exciting experimental advancements in quantum computing have been achieved, but concerns about their scalability persist. It thus becomes essential to characterize the computational power of feasible models of quantum computation that operate under restricted resources, such as time (i.e., the number of gates in the circuit) and space (i.e., the number of qubits on which the circuit acts). This paper specifically focuses on the latter aspect: what is the computational power of quantum computation with a limited number of qubits?\nPrevious studies [Wat99,Wat03,vMW12] on complete problems of space-bounded quantum computation have primarily focused on well-conditioned versions of standard linear-algebraic problems [TS13,FL18,FR21] and have been limited to the two-sided error scenario. In contrast, we propose a novel family of complete problems that not only characterize the one-sided error scenario (and extend to the two-sided scenario) but also arise from a quantum property testing perspective. Our new complete problems are arguably more natural and simpler, driven by recent intriguing challenges of verifying the intended functionality of quantum devices.\nConsider the situation where a quantum device is designed to prepare a quantum (mixed) state \u03c10, but a possibly malicious party could provide another quantum device that outputs a different n-qubit (mixed) state \u03c11, claiming that \u03c10 \u2248\u01eb \u03c11. The problem of testing whether \u03c10 is \u01eb1-close to or \u01eb2-far from \u03c11 with respect to a specified distance-like measure, given the ability to produce copies of \u03c10 and \u03c11, is known as quantum state testing [MdW16, Section 4]. Quantum state testing (resp., distribution testing) typically involves utilizing sample accesses to quantum states \u03c10 and \u03c11 (resp., distributions D0 and D1) and determining the number of samples required to test the closeness between quantum states (resp., distributions). This problem is a quantum (non-commutative) generalization of classical property testing, which is a fundamental problem in theoretical computer science (see [Gol17]), specifically (tolerant) distribution testing (see [Can20]). Moreover, this problem is an instance of the emerging field of quantum property testing (see [MdW16]), which aims at designing quantum testers for the properties of quantum objects.\nIn this paper, we investigate quantum state testing problems where quantum states \u03c10 and \u03c11 are preparable by computationally constrained resources, specifically state-preparation circuits (viewed as the \u201csource code\u201d of devices) that are (log)space-bounded. Our main result conveys a conceptual message that testing quantum states prepared in bounded space is (computationally) as easy as preparing these states in a space-bounded manner. Consequently, we can introduce the first family of natural coRQUL-complete promise problems since Watrous [Wat01] introduced unitary RQL and coRQL (known as RQUL and coRQUL, respectively) in 2001, as well as a new family of natural BQL-complete promise problems.\nOur main technique is a space-efficient variant of the quantum singular value transformation (QSVT) [GSLW19], distinguishing itself from prior works primarily focused on time-efficient QSVT. As time-efficient QSVT provides a unified framework for designing time-efficient quantum algorithms [GSLW19,MRTC21], we believe our work indicates a unified approach to designing space-bounded quantum algorithms, potentially facilitating the discovery of new complete problems for BQL and its one-sided error variants. Subsequently, we will first state our main results and then provide justifications for the significance of our results from various perspectives."
        },
        {
            "heading": "1.1 Main results",
            "text": "We will commence by providing definitions for time- and space-bounded quantum circuits. We say that a quantum circuit Q is (poly)time-bounded if Q is polynomial-size and acts on poly(n) qubits. Likewise, we say that a quantum circuit Q is (log)space-bounded if Q is polynomial-size and acts on O(log n) qubits. It is worthwhile to note that primary complexity classes, e.g., BQL, coRQUL, and BPL, mentioned in this paper correspond to promise problems.\nComplete characterizations of quantum logspace from state testing. While prior works [TS13,FL18,FR21] on BQL-complete problems have mainly focused on well-conditioned versions of standard linear-algebraic problems (in DET\u2217), our work takes a different perspective by exploring quantum property testing. Specifically, we investigate the problem of space-bounded quantum state testing, which aims to test the closeness between two quantum states that are preparable by (log)space-bounded quantum circuits (devices), with access to the corresponding \u201csource code\u201d of these devices.\nWe begin by considering a computational problem that serves as a \u201cwhite-box\u201d space-bounded counterpart of quantum state certification [BOW19], equivalent to quantum state testing with one-sided error. Our first main theorem (Theorem 1.1) demonstrates the first family of natural coRQUL-complete problems in the context of space-bounded quantum state certification with respect to the trace distance (td) and the squared Hilbert-Schmidt distance (HS2).\nTheorem 1.1 (Informal of Theorem 4.5). The following (log)space-bounded quantum state certification problems are coRQUL-complete: for any \u03b1(n) \u2265 1/poly(n), decide whether\n(1) CertQSDlog: \u03c10 = \u03c11 or td(\u03c10, \u03c11) \u2265 \u03b1(n);\n(2) CertQHSlog: \u03c10 = \u03c11 or HS 2(\u03c10, \u03c11) \u2265 \u03b1(n);\nBy extending the error requirement from one-sided to two-sided, we broaden the scope of space-bounded quantum state testing to include two more distance-like measures: the quantum entropy difference, denoted by S(\u03c10)\u2212 S(\u03c11), and the quantum Jensen-Shannon divergence (QJS2). As a result, we establish our second main theorem, introducing a new family of natural BQL-complete problems:\nTheorem 1.2 (Informal of Theorem 4.6). The following (log)space-bounded quantum state testing problems are BQL-complete: for any \u03b1(n) and \u03b2(n) such that \u03b1(n)\u2212 \u03b2(n) \u2265 1/poly(n), or for any g(n) \u2265 1/poly(n), decide whether\n(1) GapQSDlog: td(\u03c10, \u03c11) \u2265 \u03b1(n) or td(\u03c10, \u03c11) \u2264 \u03b2(n);\n(2) GapQEDlog: S(\u03c10)\u2212 S(\u03c11) \u2265 g(n) or S(\u03c11)\u2212 S(\u03c10) \u2265 g(n);\n(3) GapQJSlog: QJS2(\u03c10, \u03c11) \u2265 \u03b1(n) or QJS2(\u03c10, \u03c11) \u2264 \u03b2(n);\n(4) GapQHSlog: HS 2(\u03c10, \u03c11) \u2265 \u03b1(n) or HS2(\u03c10, \u03c11) \u2264 \u03b2(n);\nNotably, Theorem 1.2(1) demonstrates that our algorithm for GapQSDlog exhibits a polynomial advantage in space over the best-known classical algorithms [Wat02], since Watrous implicitly showed in [Wat02, Proposition 21] that GapQSDlog is contained in (classical) polylogarithmic space.1\nSpace-efficient quantum singular value transformation. Proving our main theorems mentioned above poses a significant challenge: establishing the containment in the relevant class (BQL or coRQUL), which is also the difficult direction for showing the known family of BQL-complete problems [TS13,FL18,FR21].\nProving the containment for the one-sided error scenario is not an effortless task: such a task is not only already relatively complicated for CertQHSlog, but also additionally requires novel techniques for CertQSDlog. On the other hand, for two-sided error scenarios, while showing the containment is straightforward for GapQHSlog, it still demands sophisticated techniques for all other problems, such as GapQSDlog, GapQEDlog, and GapQJSlog.\n1Notably, our algorithm for GapQSDlog provides an alternating proof for the original statement that (\u03b1, \u03b2)QSD is in PSPACE when \u03b1(n) \u2212 \u03b2(n) \u2265 exp(\u2212poly(n)). In particular, Watrous [Wat02] provided an algorithm in NC to solve the Trace Norm Approximation problem on estimating \u2016X\u20161 with polynomial precision, given that the polynomial-size matrix X enables evaluation of all entries in deterministic O(log n) space.\nAs explained in Section 1.4, our primary technical contribution and proof technique involve developing a space-efficient variant of the quantum singular value transformation (QSVT), which constitutes our third main theorem (Theorem 1.4)."
        },
        {
            "heading": "1.2 Background on space-bounded quantum computation",
            "text": "Watrous [Wat99, Wat03] initiated research on space-bounded quantum computation and showed that fundamental properties, including closure under complement, hold for BQSPACE[s(n)] with s(n) \u2265 \u2126(log n). Watrous also investigated classical simulations of space-bounded quantum computation (with unbounded error), presenting deterministic simulations in O(s2(n)) space and unbounded-error randomized simulations in O(s(n)) space. A decade later, van Melkebeek and Watson [vMW12] provided a simultaneous O\u0303(t(n)) time and O(s(n) + log t(n)) space unbounded-error randomized simulation for a bounded-error quantum algorithm in t(n) time and s(n) space. The complexity class corresponding to space-bounded quantum computation with s(n) = \u0398(log(n)) is known as BQL, or BQUL if only unitary gates are permitted.\nSignificantly, several developments over the past two decades have shown that BQL is welldefined, independent of the following factors in chronological order:\n\u2022 The choice of gateset. The Solovey-Kitaev theorem [Kit97] establishes that most quantum classes are gateset-independent, given that the gateset is closed under adjoint and all entries in gates have reasonable precision. The work of [vMW12] presented a space-efficient counterpart of the Solovay-Kitaev theorem, implying that BQL is also gateset-independent.\n\u2022 Error reduction. Repeating BQUL sequentially necessitates reusing the workspace, making it unclear how to reduce errors for BQUL as intermediate measurements are not allowed. To address this issue, the work of [FKL+16] adapted the witness-preserving error reduction for QMA [MW05] with several other ideas to the space-efficient setting.\n\u2022 Intermediate measurements. In the space-bounded scenario, the principle of deferred measurement is not applicable since this approach leads to an exponential increase in space complexity. Initially, BQL appeared to be seemingly more powerful than BQUL since we cannot directly demonstrate that BPL \u2286 BQUL. Recently, Fefferman and Remscrim [FR21] (as well as [GRZ21,GR22]) proved the equivalence between BQL and BQUL, indicating a space-efficient approach to eliminating intermediate measurements.\nBQL-complete problems. Identifying natural complete problems for the class BQL (or BQUL) is a crucial and intriguing question. Ta-Shma [TS13] proposed the first candidate BQL-complete problem, building upon the work of Harrow, Hassidim, and Lloyd [HHL09] which established a BQP-complete problem for inverting a (polynomial-size) well-conditioned matrix. Specifically, Ta-Shma showed that inverting a well-conditioned matrix with polynomial precision is in BQL. Similarly, computing eigenvalues of an Hermitian matrix is also in BQL. These algorithms offer a quadratic space advantage over the best-known classical algorithms that saturate the classical simulation bound [Wat99,Wat03,vMW12]. Fefferman and Lin [FL18] later improved upon this result to obtain the first natural BQUL-complete problem by ingeniously utilizing amplitude estimation to avoid intermediate measurements.\nMore recently, Fefferman and Remscrim [FR21] further extended this natural BQUL-complete problem (or BQL-complete, equivalently) to a family of natural BQL-complete problems. They showed that a well-conditioned version of standard DET\u2217-complete problems is BQL-complete, where DET\u2217 denotes the class of problems that are NC1 (Turing) reducible to intDET, including well-conditioned integer determinant (DET), well-conditioned matrix powering (MATPOW), and well-conditioned iterative matrix product (ITMATPROD), among others.\nRQUL- and coRQUL-complete problems. Watrous [Wat01] introduced the one-sided error counterpart of BQUL, namely RQUL and coRQUL, and developed error reduction techniques.\nMoreover, Watrous proved that the undirected graph connectivity problem (USTCON) is in RQUL \u2229 coRQUL whereas Reingold [Rei08] demonstrated that USTCON is in L several years later. Recently, Fefferman and Remscrim [FR21] proposed a \u201cverification\u201d version of the wellconditioned iterative matrix product problem (vITMATPROD) as a candidate coRQL-complete problem. However, although this problem is known to be coRQL-hard, its containment remains unresolved. Specifically, vITMATPROD requires to decide whether a single entry in the product of polynomially many well-conditioned matrices is equal to zero."
        },
        {
            "heading": "1.3 Time-bounded and space-bounded distribution and state testing",
            "text": "We summarize prior works and our main results for time-bounded2 and space-bounded distribution and state testing with respect to \u21131 norm, entropy difference, and \u21132 norm in Table 1.\nInterestingly, the sample complexity of testing the closeness of quantum states (resp., distributions) depends on the choice of distance-like measures,3 including the one-sided error counterpart known as quantum state certification [BOW19]. In particular, for distance-like measures such as the \u21131 norm, called total variation distance in the case of distributions [CDVV14] and trace distance in the case of states [BOW19], as well as classical entropy difference [JVHW15, WY16] and its quantum analog [AISW20, OW21], the sample complexity of distribution and state testing is polynomial in the dimension N . However, for distance-like measures such as the \u21132 norm, called Euclidean distance in the case of distributions [CDVV14] and Hilbert-Schmidt distance in the case of states [BOW19], the sample complexity is independent of dimension N .\nAs depicted in Table 1, this phenomenon that the required sample complexity for distribution and state testing, with polynomial precision and exponential dimension, depends on the choice of distance-like measure has reflections on time-bounded quantum state testing:\n\u2022 For \u21131 norm and entropy difference, the time-bounded scenario is seemingly much harder than preparing states or distributions since QSZK \u2286 BQP and SZK \u2286 BPP are unlikely.\n\u2022 For \u21132 norm, the time-bounded scenario is as easy as preparing states or distributions.\nHowever, interestingly, a similar phenomenon does not appear for space-bounded quantum state testing. Although no direct classical counterpart has been investigated before in a complexity-theoretic fashion, namely space-bounded distribution testing, there is another closely related model (a version of streaming distribution testing) that does not demonstrate an analogous phenomenon either, as we will discuss in Section 1.3.2.\n2The problem of time-bounded distribution (resp., state) testing aims to test the closeness between two distributions (resp., states) that are preparable by (poly)time-bounded circuits (devices), with access to the corresponding \u201csource code\u201d of these devices.\n3It is noteworthy that the quantum entropy difference is not a distance."
        },
        {
            "heading": "1.3.1 Time-bounded distribution and state testing",
            "text": "We review prior works on time-bounded state (resp., distribution) testing, with a particular focus on testing the closeness between states (resp., distributions) are preparable by (poly)timebounded quantum (resp., classical) circuits (device), with access to the \u201csource code\u201d of corresponding devices. For time-bounded distribution testing, we also recommend a brief survey [GV11] by Goldreich and Vadhan.\n\u21131 norm scenarios. Sahai and Vadhan [SV03] initiated the study of the time-bounded distribution testing problem, where distributions D0 and D1 are efficiently samplable, and the distance-like measure is the total variation distance. Their work named this problem Statistical Difference (SD). In particular, the promise problem (\u03b1, \u03b2)-SD asks whether D0 is \u03b1-far from or \u03b2-close to D1 with respect to \u2016D0 \u2212D1\u2016TV. Although sampling from the distribution is in BPP,4 testing the closeness between these distributions is SZK-complete [SV03, GSV98], where SZK is the class of promise problems possessing statistical zero-knowledge proofs. It is noteworthy that the SZK containment of (\u03b1, \u03b2)-SD for any \u03b1(n)\u2212\u03b2(n) \u2265 1/poly(n) is currently unknown.5 In addition, we note that SZK is contained in AM \u2229 coAM [For87,AH91].\nFollowing the pioneering work [SV03], Watrous [Wat02] introduced the time-bounded quantum state testing problem, where two quantum states \u03c10 and \u03c11 that are preparable by timebounded quantum circuits Q0 and Q1, respectively, as well as the distance-like measure is the trace distance. This problem is known as the Quantum State Distinguishability (QSD), specifically, (\u03b1, \u03b2)-QSD asks whether \u03c10 is \u03b1-far from or \u03b2-close to \u03c11 with respect to td(\u03c10, \u03c11). Analogous to its classical counterpart, QSD is QSZK-complete [Wat02, Wat09], whereas the QSZK containment for any \u03b1(n)\u2212 \u03b2(n) \u2265 1/poly(n) remains an open question.6 Additionally, it is worth noting that QIP(2) contains QSZK [Wat02,Wat09].\nEntropy difference scenarios. Beyond \u21131 norm, another distance-like measure commonly considered in time-bounded quantum state testing (or distribution testing) is the (quantum) entropy difference, which also corresponds to the (quantum) Jensen-Shannon divergence. The promise problem Entropy Difference (ED), first introduced by Goldreich and Vadhan [GV99] following the work of [SV03], asks whether efficiently samplable distributions D0 and D1 satisfy H(D0) \u2212 H(D1) \u2265 g or H(D1) \u2212 H(D0) \u2265 g for g = 1. They demonstrated that ED is SZKcomplete. Ben-Aroya, Schwartz, and Ta-Shma [BASTS10] further investigated the promise problem Quantum Entropy Difference (QED), which asks whether S(\u03c10) \u2212 S(\u03c11) \u2265 g or S(\u03c11) \u2212 S(\u03c10) \u2265 g, for efficiently preparable quantum states \u03c10 and \u03c11 and g = 1/2. They showed that QED is QSZK-complete. Moreover, the SZK (resp., QSZK) containment for ED (resp., QED) automatically holds for any g(n) \u2265 1/poly(n).\nFurthermore, Berman, Degwekar, Rothblum, and Vasudevan [BDRV19] demonstrated that the Jensen-Shannon divergence problem (JSP), asking whether JS(D0,D1) \u2265 \u03b1 or JS(D0,D1) \u2264 \u03b2 for efficiently samplable distributions D0 and D1, is SZK-complete. Their work accomplished this result by reducing the problem to ED, and this containment applies to \u03b1(n) \u2212 \u03b2(n) \u2265 1/poly(n). Recently, Liu [Liu23] showed a quantum counterpart, referred to as the Quantum Jensen-Shannon Divergence Problem (QJSP), is QSZK-complete. Notably, the quantum\n4Rigorously speaking, as an instance in SD, sample-generating circuits are not necessarily (poly)time-uniform. 5The works of [SV03, GSV98] demonstrated that (\u03b1, \u03b2)-SD is in SZK for any constant \u03b12 \u2212 \u03b2 > 0. The same technique works for the parameter regime \u03b12(n) \u2212 \u03b2(n) \u2265 1/O(log n). However, further improvement of the parameter regime requires new ideas, as clarified in [Gol19]. Recently, the work of [BDRV19] improved the parameter regime to \u03b12(n)\u2212\u03b2(n) \u2265 1/poly(n) by utilizing a series of tailor-made reductions. Currently, we only know that (\u03b1, \u03b2)-SD for \u03b1(n) \u2212 \u03b2(n) \u2265 1/ poly(n) is also in AM \u2229 coAM [BL13].\n6Like SD and SZK, the techniques in [Wat02,Wat09] show that (\u03b1, \u03b2)-QSD is in QSZK for \u03b12(n) \u2212 \u03b2(n) \u2265 1/O(log n), and the same limitation also applies to the quantum settings. A recent result [Liu23] following the line of work of [BDRV19] improved the parameter regime to \u03b12(n)\u2212 \u221a 2 ln 2\u03b2(n) \u2265 1/poly(n), but the differences between classical and quantum distances make it challenging to push the bound further. In [Wat02, Proposition 21], Watrous implicitly proved a PSPACE upper bound for the parameter regime \u03b1(n)\u2212 \u03b2(n) \u2265 exp(\u2212poly(n)).\nJensen-Shannon divergence is a special instance of the Holevo \u03c7 quantity [Hol73].7\n\u21132 norm scenarios. For the quantum setting, it is straightforward that applying the SWAP test [BCWdW01]8 to efficiently preparable quantum states \u03c10 and \u03c11 can lead to a BQP containment, in particular, additive-error estimations of Tr(\u03c120), Tr(\u03c1 2 1), and Tr(\u03c10\u03c11) with polynomial precision. Recently, the work of [RASW23] observed that time-bounded quantum state testing with respect to the squared Hilbert-Schmidt distance is BQP-complete. For the classical setting, namely the squared Euclidean distance, the BPP-completeness is relatively effortless.9"
        },
        {
            "heading": "1.3.2 Space-bounded distribution and state testing",
            "text": "To the best of our knowledge, no prior work has specifically focused on space-bounded distribution testing from a complexity-theoretic perspective. Instead, we will review prior works that are (closely) related to this computational problem. Afterward, we will delve into spacebounded quantum state testing, which constitutes the main contribution of our work.\nSpace-bounded distribution testing and related works. We focus on a computational problem involving two poly(n)-size classical circuits C0 and C1, which generate samples from the distributions D0 and D1 respectively. Each circuit contains a read-once polynomial-length random-coins tape.10 The input length and output length of the circuits are O(log n). The task is to decide whether D0 is \u03b1-far from or \u03b2-close to D1 with respect to some distance-like measure. Additionally, we can easily observe that space-bounded distribution testing with respect to the squared Euclidean distance (\u21132 norm) is BPL-complete, much like its time-bounded counterpart.\nSeveral models related to space-bounded distribution testing have been investigated previously. Earlier streaming-algorithmic works [FKSV02,GMV06] utilize entries of the distribution as the data stream, with entries given in different orders for different models. On the other hand, a later work [CLM10] considered a data stream consisting of a sequence of i.i.d. samples drawn from distributions and studied low-space streaming algorithms for distribution testing.\nRegarding (Shannon) entropy estimation, previous streaming algorithms considered worstcase ordered samples drawn from N -dimensional distributions and required poly log(N/\u01eb) space, where \u01eb is the additive error. Recently, Acharya, Bhadane, Indyk, and Sun [ABIS19] addressed the entropy estimation problem with i.i.d. samples drawn from distributions as the data stream and demonstrated the first O(log(N/\u01eb)) space streaming algorithm. The sample complexity, viewed as the time complexity, was subsequently improved in [AMNW22].\nHowever, for the total variation distance (\u21131 norm), previous works focused on the trade-off between the sample complexity and the space complexity (memory constraints), achieving only a nearly-log-squared space streaming algorithm [DGKR19].\nNotably, the main differences between the computational and streaming settings lie in how we access the sampling devices.11 In the computational problem, we have access to the \u201csource code\u201d of the devices and can potentially use them for purposes like \u201creverse engineering\u201d. Conversely, the streaming setting utilizes the sampling devices in a \u201cblack-box\u201d manner, obtaining i.i.d. samples. As a result, a logspace streaming algorithm will result in a BPL containment.12\n7In particular, the quantum Jensen-Shannon divergence coincides with the Holevo \u03c7 quantity on size-2 ensembles with a uniform distribution, which arises in the Holevo bound [Hol73]. See [NC02, Theorem 12.1].\n8We note that the SWAP test also applies to mixed states, see Proposition 9 in [KMY09]. 9Specifically, we achieve BPP containment by following the approach in [BCH+19, Theorem 7.1]. On the other hand, the BPP hardness owes to the fact that the squared Euclidean distance between the distribution (pacc, 1\u2212 pacc) from the output bit of any BPP algorithm and the distribution (1, 0) is (1\u2212 pacc)2.\n10It is noteworthy that random coins are provided as input to classical circuits C0 and C1 for generating samples from the corresponding distributions in the time-bounded scenario, such as SD and ED.\n11Of course, not all distributions can be described as a polynomial-size circuit (i.e., a succinct description). 12In particular, the sample-generating circuits C0 and C1 in space-bounded distribution testing can produce\nthe i.i.d. samples in the data stream.\nSpace-bounded quantum state testing. Among the prior works on streaming distribution testing, particularly entropy estimation, the key takeaway is that the space complexity of the corresponding computational problem is O(log(N/\u01eb)). This observation leads to a conjecture that the computational hardness of space-bounded distribution and state testing is independent of the choice of commonplace distance-like measures. Our work, in turn, provides a positive answer for space-bounded quantum state testing.\nSpace-bounded state testing with respect to the squared Hilbert-Schmidt distance (\u21132 norm) is BQL-complete, as shown in Theorem 1.2(4). Specifically, the BQL containment follows from the SWAP test [BCWdW01], similar to the time-bounded scenario. Moreover, proving BQL hardness, as well as coRQUL-hardness for state certification, are also straightforward. 13\nRegarding space-bounded state testing with respect to the trace distance (\u21131 norm), we note that [Wat02, Proposition 21] implicitly established an NC containment. The BQL-hardness, as well as coRQUL-hardness for state certification, is adapted from [RASW23]. Similarly, we derive the BQL-hardness for space-bounded state testing with respect to the quantum Jensen-Shannon divergence and the quantum entropy difference from previous works [Liu23].\nFinally, we devote the remainder of this section to our main technique (Theorem 1.4), and consequently, we present BQL (resp., coRQUL) containment for state testing (resp., certification) problems for other distance-like measures beyond the squared Hilbert-Schmidt distance."
        },
        {
            "heading": "1.4 Proof technique: Space-efficient quantum singular value transformation",
            "text": "The quantum singular value transformation (QSVT) [GSLW19] is a powerful and efficient framework for manipulating the singular values {\u03c3i}i of a linear operator A, using a corresponding projected unitary encoding U of A = \u03a0\u0303U\u03a0 for projectors \u03a0\u0303 and \u03a0. The singular value decomposition is A = \u2211 i \u03c3i|\u03c8\u0303i\u3009\u3008\u03c8i| where |\u03c8\u0303i\u3009 and |\u03c8i\u3009 are left and right singular vectors, respectively. QSVT has numerous applications in quantum algorithm design, and is even considered a grand unification of quantum algorithms [MRTC21]. To implement the transformation f (SV)(A) = f (SV)(\u03a0\u0303U\u03a0), we require a degree-d polynomial P\u0302d(x) that satisfies two conditions. Firstly, P\u0302d well-approximates f on the interval of interest I , with maxx\u2208I\\I\u03b4 |P\u0302d(x) \u2212 f(x)| \u2264 \u01eb, where I\u03b4 \u2286 I \u2286 [\u22121, 1] and typically I\u03b4 := (\u2212\u03b4, \u03b4). Secondly, P\u0302d is bounded, with maxx\u2208[\u22121,1] |P\u0302d(x)| \u2264 1. The degree of P\u0302d depends on the precision parameters \u03b4 and \u01eb, with d = O(\u03b4\u22121 log \u01eb\u22121), and all coefficients of P\u0302d can be computed efficiently.\nAccording to [GSLW19], we can use an alternating phase modulation to implement P\u0302 (SV) d (\u03a0\u0303U\u03a0), 14\nwhich requires a sequence of rotation angles \u03a6 \u2208 Rd. For instance, consider P\u0302d(x) = Td(x) where Td(x) is the d-th Chebyshev polynomial (of the first kind), then we know that \u03c61 = (1\u2212 d)\u03c0/2 and \u03c6j = \u03c0/2 for all j \u2208 {2, 3, \u00b7 \u00b7 \u00b7 , d}. QSVT techniques, including classical pre-processing and quantum circuit implementation, are generally time-efficient. Additionally, the quantum circuit implementation of QSVT is already space-efficient because implementing QSVT with a degreed bounded polynomial for any s(n)-qubit projected unitary encoding requires O(s(n)) qubits, where s(n) \u2265 \u2126(log n). However, the classical pre-processing in the QSVT techniques is typically not space-efficient. Indeed, prior works on classical pre-processing for QSVT, specifically angle-finding algorithms in [Haa19, CDG+20, DMWL21], which have time complexity polynomially dependent on the degree d, do not consider the space-efficiency. Therefore, the use of previous angle-finding algorithms may lead to an exponential increase in space complexity. This raises a fundamental question on making the classical pre-processing space-efficient as well:\nProblem 1.3 (Space-efficient QSVT). Can we implement a degree-d QSVT for any s(n)-qubit\n13In particular, considering any BQL circuit Cx that accepts with probability pacc = ||1\u3009\u30081|outCx|0\u0304\u3009|22, we can construct a new circuit C\u2032x from Cx such that C \u2032 x accepts with probability ||0\u0304\u3009\u30080\u0304|C\u2032x|0\u0304\u3009|22 = pacc2 = Tr(\u03c10\u03c11) = 1\u2212 HS2(\u03c10, \u03c11), where pure states \u03c10 = |0\u0304\u3009\u30080\u0304| and \u03c11 = C\u2032x|0\u0304\u3009\u30080\u0304|C\u2032x\u2020. See Lemma 4.17 for details. 14This procedure is a generalization of quantum signal processing, as explained in [MRTC21, Section II.A].\nprojected unitary encoding with d \u2264 2O(s(n)), using only O(s(n)) space in both classical preprocessing and quantum circuit implementation?\nQSVT via Chebyshev interpolation. Recently, Metger and Yuen [MY23] constructed bounded polynomial approximations of the sign and square root functions with exponential precision in polynomial space by utilizing Chebyshev interpolation, which offers a partial solution to Problem 1.3.15 The key ingredient behind their approach is the near-minimax approximation by Chebyshev interpolation [Pow67]. More precisely, for any continuous function f : [\u22121, 1] \u2192 R, if there is a degree-d polynomial P\u0302d satisfying maxx\u2208[\u22121,1] |f(x) \u2212 P\u0302d(x)| \u2264 \u01eb, then we have a Chebyshev interpolation polynomial Pd(x) := c0 2 + \u2211d k=1 ckTk where ck := 2 \u03c0 \u222b 1 \u22121 f(x)Tk(x)\u221a 1\u2212x2 dx such that maxx\u2208[\u22121,1] |Pd(x)\u2212 f(x)| \u2264 O(\u01eb log d). As the angles for any Chebyshev polynomial Tk(x) are explicitly known, the implementation involves applying a Chebyshev polynomial to a bitstring indexed encoding, which additionally requires projectors \u03a0\u0303 and \u03a0 span on the corresponding subset of {|0\u3009, |1\u3009}\u2297s,16 and implementing the Chebyshev interpolation polynomial by LCU techniques [BCC+15]. It is noteworthy that combining the aforementioned techniques causes a super-quadratic dependence of the degree d in the query complexity to U .\nA refined analysis indicates that applying a Chebyshev interpolation polynomial to a bitstring indexed encoding for any d \u2264 2O(s(n)) and \u01eb \u2265 2\u2212O(s(n)) requires O(s(n)) qubits and deterministic O(s(n)) space, provided that an evaluation oracle EvalPd estimates coefficients {ck}dk=0 of the Chebyshev interpolation polynomial with O(log(\u01eb/d)) precision. This result leads to the establishment of a space-efficient variant of QSVT:\nTheorem 1.4 (Space-efficient QSVT, informal of Theorem 3.4). Let f : R \u2192 R be a continuous function bounded on I \u2286 [\u22121, 1]. If there exists a degree-d polynomial P\u0302d that approximates h : [\u22121, 1] \u2192 R, where h approximates f only on I, such that maxx\u2208[\u22121,1] |h(x)\u2212P\u0302d(x)| \u2264 \u01eb, then Chebyshev interpolation yields another degree-d polynomial Pd satisfying the following conditions: maxx\u2208I |f(x)\u2212 Pd(x)| \u2264 O(\u01eb log d) and maxx\u2208[\u22121,1] |Pd(x)| \u2264 1. Furthermore, we have an algorithm Af that computes any coefficient {ck}dk=0 of the Chebyshev interpolation polynomial Pd space-efficiently. The algorithm is deterministic for bounded f , and bounded-error randomized for piecewise-smooth f . Additionally, for any s(n)-qubit bitstring indexed encoding U of A = \u03a0\u0303U\u03a0 with d \u2264 2O(s(n)), we can implement the quantum singular value transformation P\n(SV) d (A) using O(d 2\u2016c\u20161) queries17 In addition, \u2016c\u20161 is generally upperbounded by O(d) for all piecewise-smooth functions. However, for specific functions, such as the sign function, we can improve the upper bound to O(log d). to U with O(s(n)) qubits.\nOur techniques in Theorem 1.4 offer two advantages over the techniques proposed by [MY23]. Firstly, our techniques can handle any piecewise-smooth function, such as the normalized logarithmic function ln\u03b2(x) := ln(1/x) 2 ln(2/\u03b2) on the interval I = [\u03b2, 1] for any \u03b2 \u2265 2\u2212O(s(n)), whereas the techniques from [MY23] are restricted to functions that are bounded on the interval I = [\u22121, 1]. Secondly, our technique is constant overhead in terms of the space complexity of the bitstring indexed encoding U , while the techniques from [MY23] are only poly-logarithmic overhead.\nIn addition, it is noteworthy that applying the space-efficient QSVT with the sign function will imply a unified approach to error reduction for the classes BQUL, coRQUL and RQUL.\nComputing the coefficients. We will implement the evaluation oracle EvalPd to prove Theorem 1.4. To estimate the coefficients {ck}dk=0 resulting from Chebyshev interpolation for any\n15To clarify, we can see from [MY23] that directly adapting their construction shows that implementing QSVT for any s(n)-qubit block-encoding with O(s(n))-bit precision requires poly(s(n)) classical and quantum space for any s(n) \u2265 \u2126(log n). However, Problem 1.3 (space-efficient QSVT) seeks to reduce the dependence of s(n) in the space complexity from polynomial to linear.\n16To ensure that \u03a0\u0303U\u03a0 admits a matrix representation, we require the basis of projectors \u03a0\u0303 and \u03a0 to have a well-defined order, leading us to focus exclusively on bitstring indexed encoding. Additionally, for simplicity, we assume no ancillary qubits are used here, and refer to Definition 3.1 for a formal definition.\n17The dependence of \u2016c\u20161 arises from renormalizing the bitstring indexed encoding via amplitude amplification.\nfunction f that is bounded on the interval I = [\u22121, 1], we can use standard numerical integral techniques,18 given that the integrand\u2019s second derivative in {ck}dk=0 is bounded by poly(d).\nHowever, implementing the evaluation oracle for piecewise-smooth functions f on an interval I ( [\u22121, 1] is relatively convoluted. We cannot simply apply Chebyshev interpolation to f . Instead, we consider a low-degree Fourier approximation g resulting from implementing smooth functions to Hamiltonians [vAGGdW20, Appendix B]. We then make the error vanish outside I by multiplying with a Gaussian error function, resulting in h which approximates f only on I . Therefore, we can apply Chebyshev interpolation and our algorithm for bounded functions to h through a somewhat complicated calculation.\nFinally, we need to compute the coefficients of the low-degree Fourier approximation g. Interestingly, this step involves the stochastic matrix powering problem, which lies at the heart of space-bounded derandomization, e.g., [SZ99, CDSTS23, PP23]. We utilize space-bounded random walks on a directed graph to estimate the power of a stochastic matrix. Consequently, we can only develop a bounded-error randomized algorithm Af for piecewise-smooth functions.19"
        },
        {
            "heading": "1.5 Proof overview: A general framework for quantum state testing",
            "text": "Our framework enables space-bounded quantum state testing, specifically for proving Theorem 1.1 and Theorem 1.2, and is based on the one-bit precision phase estimation [Kit95], also known as the Hadamard test [AJL09]. Prior works [TS13, FL18] have employed (one-bit precision) phase estimation in space-bounded quantum computation.\nTo address quantum state testing problems, we reduce them to estimating Tr(Pd(A)\u03c1), where \u03c1 is a (mixed) quantum state prepared by a quantum circuit Q\u03c1, A is an Hermitian operator block-encoded in a unitary operator UA, and Pd is a space-efficiently computable degree-d polynomial. This approach has been applied in time-bounded quantum state testing, including fidelity estimation [GP22] and subsequently trace distance estimation [WZ23a].\nTo implement a unitary operator UPd(A) that (approximately) block-encodes Pd(A) in a space-efficient manner, we require Pd to meet the conditions specified in Theorem 1.4. As illustrated in Figure 1, we denote the quantum circuit as T (Q\u03c1, UA, Pd), where we exclude the precision for simplicity. The measurement outcome of T (Q\u03c1, UA, Pd) will be 0 with a probability close to 1+Tr(Pd(A)\u03c1)2 . This property allows us to estimate Tr(Pd(A)\u03c1) within an additive error \u01eb using O(1/\u01eb2) sequential repetitions, resulting in a BQL containment.\nAs an example of the application, T (Qi, U \u03c10\u2212\u03c11 2 , P sgnd ) is utilized in GapQSD, where U \u03c10\u2212\u03c11 2\nis a block-encoding of \u03c10\u2212\u03c112 , and P sgn d is a space-efficient polynomial approximation of the\n18We remark that using a more efficient numerical integral technique, such as the exponentially convergent trapezoidal rule, may improve the required space complexity for computing coefficients by a constant factor.\n19The classical pre-processing in space-efficient QSVT is not part of the deterministic Turing machine producing the quantum circuit description in the BQL model (Definition 2.6). Instead, we treat it as a component of quantum computation, allowing the use of randomized algorithms since BPL \u2286 BQL [FR21].\nsign function. Similarly, T (Qi, U\u03c1i , P lnd ) is utilized in GapQED, where U\u03c1i is a block-encoding of \u03c1i for i \u2208 {0, 1}, and P lnd is a space-efficient polynomial approximation of the normalized logarithmic function. Both P sgnd and P ln d can be obtained by employing Theorem 1.4. 20\nMaking the error one-sided. The main challenge is constructing a unitary U of interest, such as T (Q\u03c1, UA, Pd), that accepts with a certain fixed probability p for yes instances (\u03c10 = \u03c11), while having a probability that polynomially deviates from p for no instances. As an example, we consider CertQHSlog and express HS 2(\u03c10, \u03c11) as a linear combination of Tr(\u03c1 2 0), Tr(\u03c1 2 1), and Tr(\u03c10\u03c11). We thus design a unitary quantum algorithm employing the LCU technique, which accepts with probability ( 1 2 + 1 4HS 2(\u03c10, \u03c11) )2\n, equal 1/4 for yes instances. Applying the exact amplitude amplification [BBHT98,BHMT02], we achieve perfect completeness, and the analysis demonstrates that the acceptance probability polynomially deviates from 1 for no instances. By applying error reduction for coRQUL, the resulting algorithm is indeed in coRQUL.\nMoving on to CertQSDlog, we consider the quantum circuit Ui = T (Qi, U \u03c10\u2212\u03c11 2 , P sgnd ) for i \u2208 {0, 1}. Let pi be the probability that the measurement outcome of Ui|0\u0304\u3009 in Figure 1 is 0. Since our space-efficient QSVT preserves parity, specifically the approximation polynomial P sgnd satisfies P sgnd (0) = 0,\n21 we obtain p0 = p1 = 1/2 for yes instances (\u03c10 = \u03c11). With a simple modification, U0 and U1 enable algorithm A to meet the condition of exact amplitude amplification for yes instances. Further analysis shows that A accepts with probability polynomially away from 1 for no instances. We thus can conclude a coRQUL containment similar to CertQHSlog."
        },
        {
            "heading": "1.6 Discussion and open problems",
            "text": "Since space-efficient quantum singular value transformation (QSVT) offers a unified framework for designing quantum logspace algorithms, it suggests a new direction to find applications of space-bounded quantum computation. An intriguing candidate is solving positive semidefinite programming (SDP) programs with constant precision [JY11,AZLO16]. A major challenge in achieving a BQL containment for this problem is that iteratively applying the space-efficient QSVT super-constantly many times may lead to a bitstring indexed encoding requiring \u03c9(log n) ancillary qubits, raising the question:\n(i) Is it possible to have an approximation scheme (possibly under certain conditions) that introduces merely O(1) additional ancillary qubits in the bitstring indexed encoding per iteration, such that applying space-efficient QSVT log n times results in a bitstring indexed encoding with at most O(log n) ancillary qubits?\nFurthermore, as quantum distances investigated in this work are all instances of a quantum analog of symmetric f -divergence, there is a natural question on other instances:\n(ii) Can we demonstrate that space-bounded quantum state testing problems with respect to other quantum distances are also BQL-complete, such as quantum analogs of squared Hellinger distance or quantum analogs of triangular discrimination [Liu23]?\nIn addition, there is a question on improving the efficiency of the space-efficient QSVT:\n(iii) Can we improve the query complexity of U and U \u2020 in the space-efficient QSVT implementation (e.g., for the sign function) from O(d2 log d) to O(d)?\nNotably, classical pre-processing in QSVT techniques usually involves finding the sequence of z-axis rotation angles, while our approach instead uses Chebyshev interpolation and the LCU technique. A solution thus involves developing a space-efficient angle-finding algorithm. An interesting direction from a recent work [MW23], which investigated QSVT with SU(2) rotations, may shed light on Question (iii) since finding SU(2) rotation angles appears easier.\n20In particular, P sgnd is given in Corollary 3.7, as well as P ln d is given in Corollary 3.10.\n21Let f be any odd function such that space-efficient QSVT associated with f can be implemented by Theorem 1.4. It follows that the corresponding approximation polynomial P\n(f) d is also odd. See Remark 3.12."
        },
        {
            "heading": "1.7 Related works: more on quantum state testing problems",
            "text": "Testing the spectrum of quantum states was studied in [OW21]: for example, whether a quantum state is maximally mixed or \u01eb-far away in trace distance from mixed states can be tested using \u0398(N/\u01eb2) samples. Later, it was generalized in [BOW19] to quantum state certification with respect to fidelity and trace distance. Estimating distinguishability measures of quantum states [RASW23] is another topic, including the estimation of fidelity [FL11,WZC+23, GP22] and trace distance [WGL+22,WZ23a].\nEntropy estimation of quantum states has been widely studied in the literature. Given quantum purified access, it was shown in [GL20] that the von Neumann entropy S(\u03c1) can be estimated within additive error \u01eb with query complexity O\u0303(N/\u01eb1.5). If we know the reciprocal \u03ba of the minimum non-zero eigenvalue of \u03c1, then S(\u03c1) can be estimated with query complexity O\u0303(\u03ba2/\u01eb) [CLW20]. We can estimate S(\u03c1) within multiplicative error \u01eb with query complexity O\u0303(n 1 2 + 1+\u03b7\n2\u01eb2 ) [GHS21], provided that S(\u03c1) = \u2126(\u01eb + 1/\u03b7). If \u03c1 is of rank r, then S(\u03c1) can be estimated with query complexity O\u0303(r2/\u01eb2) [WGL+22]. Estimating the R\u00e9nyi entropy S\u03b1(\u03c1) given quantum purified access was first studied in [GHS21], and then was improved in [WGL+22, LWZ22]. In addition, the work of [GH20] investigates the (conditional) hardness of GapQED with logarithmic depth or constant depth.\nPaper organization. Our paper begins by introducing key concepts in Section 2, including quantum distance and divergences, space-bounded quantum computation, Chebyshev polynomials and interpolation, and a toolkit for space-bounded randomized and quantum computation. In Section 3, we demonstrate our space-efficient variant of quantum singular value transformation (Theorem 1.4) and offer examples for bounded functions and piecewise-smooth functions. We also provide a simple proof of space-efficient error reduction for unitary quantum computation. Then, in Section 4, we formally define space-bounded quantum state testing problems with four distance-like measures, and present the first family of natural coRQUL-complete problems (Theorem 1.1), as well as a novel family of natural BQL-complete problems (Theorem 1.2)."
        },
        {
            "heading": "2 Preliminaries",
            "text": "We assume that the reader is familiar with quantum computation and the theory of quantum information. For an introduction, the textbooks by [NC02] and [dW19] provide a good starting point, while for a more comprehensive survey on quantum complexity theory, refer to [Wat08].\nIn addition, we adopt the convention that the logarithmic function log has a base of 2, denoted by log(x) := log2(x) for any x \u2208 R+. For the purpose of clarity, we will denote the operator norm as \u2016A\u2016 := \u2016A\u20162\u21922. Moreover, for the sake of simplicity, we utilize the notation |0\u0304\u3009 to represent |0\u3009\u2297a with a > 1."
        },
        {
            "heading": "2.1 Distances and divergences for quantum states",
            "text": "We will provide an overview of relevant quantum distances and divergences, along with useful inequalities among different quantum distance-like measures. Additionally, we recommend [BOW19, Section 3.1] for a nice survey on quantum distance and divergences.\nDefinition 2.1 (Quantum distances and divergences). For any quantum states \u03c10 and \u03c11, we define several distance-like measures and relevant quantities:\n\u2022 Trace distance. td(\u03c10, \u03c11) := 1 2Tr|\u03c10 \u2212 \u03c11| = 12Tr(((\u03c10 \u2212 \u03c11)\u2020(\u03c10 \u2212 \u03c11))1/2). \u2022 (Uhlmann) Fidelity. F(\u03c10, \u03c11) := Tr| \u221a \u03c10 \u221a \u03c11|.\n\u2022 Squared Hilbert-Schmidt distance. HS2(\u03c10, \u03c11) := 1 2Tr(\u03c10 \u2212 \u03c11)2.\n\u2022 von Neumann entropy. S(\u03c1) := \u2212Tr(\u03c1 ln \u03c1) for any quantum state \u03c1. \u2022 Quantum Jensen-Shannon divergence. QJS(\u03c10, \u03c11) := S (\u03c10+\u03c11\n2 ) \u2212 S(\u03c10)+S(\u03c11)2 .\nThe trace distance and the squared Hilbert-Schmidt distance reach the minimum of 0 when \u03c10 equals \u03c11, while the fidelity attains a maximum value of 1. Additionally, there are two equalities when at least one of the two states is a pure state:\n\u2022 For a pure state \u03c10 and a mixed state \u03c11, F 2(\u03c10, \u03c11) = Tr(\u03c10\u03c11).\n\u2022 For two pure states \u03c10 and \u03c11, Tr(\u03c10\u03c11) = 1\u2212HS2(\u03c10, \u03c11).\nMoreover, we have HS2(\u03c10, \u03c11) = 1 2(Tr(\u03c1 2 0)+Tr(\u03c1 2 1))\u2212Tr(\u03c10\u03c11). Additionally, Fuchs and van\nde Graaf [FvdG99] showed a well-known inequality between the trace distance and the fidelity:\nLemma 2.2 (Trace distance vs. fidelity, adapted from [FvdG99]). For any states \u03c10 and \u03c11,\n1\u2212 F(\u03c10, \u03c11) \u2264 td(\u03c10, \u03c11) \u2264 \u221a 1\u2212 F2(\u03c10, \u03c11).\nThe joint entropy theorem (Lemma 2.3) enhances our understanding of entropy in classicalquantum states and is necessary for our usages of the von Neumann entropy.\nLemma 2.3 (Joint entropy theorem, adapted from Theorem 11.8(5) in [NC02]). Suppose pi are probabilities corresponding to a distribution D, |i\u3009 are orthogonal state of a system A, and {\u03c1i}i is any set of density operators for another system B. Then S (\u2211 i pi|i\u3009\u3008i|\u2297\u03c1i ) = H(D)+ \u2211 i piS(\u03c1i).\nLet us now turn our attention to the quantum Jensen-Shannon divergence, which is defined in [MLP05]. For simplicity, we define QJS2(\u03c10, \u03c11) := QJS(\u03c10, \u03c11)/ ln 2 using the base-2 (matrix) logarithmic function. Notably, when considering size-2 ensembles with a uniform distribution, the renowned Holevo bound [Hol73] (see Theorem 12.1 in [NC02]) indicates that the quantum Shannon distinguishability studied in [FvdG99] is at most the quantum Jensen-Shannon divergence. Consequently, this observation yields inequalities between the trace distance and the quantum Jensen-Shannon divergence.22\nLemma 2.4 (Trace distance vs. quantum Jensen-Shannon divergence, adapted from [FvdG99, Hol73,BH09]). For any quantum states \u03c10 and \u03c11, we have\n1\u2212H2 ( 1\u2212td(\u03c10,\u03c11)\n2\n) \u2264 QJS2(\u03c10, \u03c11) \u2264 td(\u03c10, \u03c11).\nHere, the binary entropy H2(p) := \u2212p log(p)\u2212 (1\u2212 p) log(1\u2212 p)."
        },
        {
            "heading": "2.2 Space-bounded quantum computation",
            "text": "We say that a function s(n) is space-constructible if there exists a deterministic space s(n) Turing machine that takes 1n as an input and output s(n) in the unary encoding. Moreover, we say that a function f(n) is s(n)-space computable if there exists a deterministic space s(n) Turing machine that takes 1n as an input and output f(n). Our definitions of space-bounded quantum computation are formulated in terms of quantum circuits, whereas many prior works focused on quantum Turing machines [Wat09,Wat03,vMW12]. For a discussion on the equivalence between space-bounded quantum computation using quantum circuits and quantum Turing machines, we refer readers to [FL18, Appendix A] and [FR21, Section 2.2].\nWe begin by defining time-bounded and space-bounded quantum circuit families, and then proceed to the corresponding complexity class BQUSPACE[s(n)]. It is worth noting that we use the abbreviated notation Cx to denote that the circuit C|x| takes input x.\n22For a detailed proof of these inequalities, please refer to [Liu23, Appendix B].\nDefinition 2.5 (Time- and space-bounded quantum circuit families). A (unitary) quantum circuit is a sequence of quantum gates, each of which belongs to some fixed gateset that is universal for quantum computation, such as {Hadamard,CNOT,T}. For a promise problem L = (Lyes,Lno), we say that a family of quantum circuits {Cx : x \u2208 L} is t(n)-time-bounded if there is a deterministic Turing machine that, on any input x \u2208 L, runs in time O(t(|x|)), and outputs a description of Cx such that Cx accepts (resp., rejects) if x \u2208 Lyes (resp., x \u2208 Lno). Similarly, we say that a family of quantum circuits {Cx : x \u2208 L} is s(n)-space-bounded if there is a deterministic Turing machine that, on any input x \u2208 L, runs in space O(s(|x|)) (and hence time 2O(s(|x|))), and outputs a description of Cx such that Cx accepts (resp., rejects) if x \u2208 Lyes (resp., x \u2208 Lno), as well as Cx is acting on O(s(|x|)) qubits and has 2O(s(|x|) gates..\nDefinition 2.6 (BQUSPACE[s(n), a(n), b(n)], adapted from Definition 5 in [FR21]). Let s : N \u2192 N be a space-constructible function such that s(n) \u2265 \u2126(log n). Let a(n) and b(n) be functions that are computable in deterministic space s(n). A promise problem (Lyes,Lno) is in BQUSPACE[s(n), a(n), b(n)] if there exists a family of s(n)-space-bounded (unitary) quantum circuits {Cx}x\u2208L, where n = |x|, satisfying the following:\n\u2022 The output qubit is measured in the computational basis after applying Cx. We say that Cx accepts x if the measurement outcome is 1, whereas Cx rejects x if the outcome is 0.\n\u2022 Pr[Cx accepts x] \u2265 a(|x|) if x \u2208 Lyes, whereas Pr[Cx accepts x] \u2264 b(|x|) if x \u2208 Lno.\nWe remark that Definition 2.6 is gateset-independent, given that the gateset is closed under adjoint and all entries in chosen gates have reasonable precision. This property is due to the space-efficient Solovay-Kitaev theorem presented in [vMW12]. Moreover, we can achieve error reduction for BQUSPACE[s(n), a(n), b(n)] as long as a(n) \u2212 b(n) \u2265 2\u2212O(s(n)), which follows from [FKL+16] or our space-efficient QSVT-based construction in Section 3.4. We thereby define BQUSPACE[s(n)] := BQUSPACE[s(n), 2/3, 1/3] to represent (two-sided) bounded-error unitary quantum space, and BQUL := BQUSPACE[O(log n)] to denote unitary quantum logspace.\nWe next consider general space-bounded quantum computation, which allows intermediate quantum measurements. As indicated in [AKN98, Section 4.1], for any quantum channel \u03a6 mapping from density matrices on k1 qubits to density matrices on k2 qubits, we can exactly simulate this quantum channel \u03a6 by a unitary quantum circuit acting on 2k1 + k2 qubits. Therefore, we extend Definition 2.5 to general quantum circuits, which allows local operations, such as intermediate measurements in the computational basis, resetting qubits to their initial states, and tracing out qubits. Now we proceed with a definition on BQSPACE[s(n)].\nDefinition 2.7 (BQSPACE[s(n), a(n), b(n)], adapted from Definition 7 in [FR21]). Let s : N \u2192 N be a space-constructible function such that s(n) \u2265 \u2126(log n). Let a(n) and b(n) be functions that are computable in deterministic space s(n). A promise problem (Lyes,Lno) is in BQSPACE[s(n), a(n), b(n)] if there exists a family of s(n)-space-bounded general quantum circuits {\u03a6x}x\u2208L, where n = |x|, satisfying the following holds:\n\u2022 The output qubit is measured in the computational basis after applying \u03a6x. We say that \u03a6x accepts x if the measurement outcome is 1, whereas \u03a6x rejects x if the outcome is 0.\n\u2022 Pr[\u03a6x accepts x] \u2265 a(|x|) if x \u2208 Lyes, whereas Pr[\u03a6x accepts x] \u2264 b(|x|) if x \u2208 Lno.\nIt is noteworthy that unitary quantum circuits, which correspond to unitary channels, are a specific instance of general quantum circuits that correspond to quantum channels. we thus infer that BQUSPACE[s(n)] \u2286 BQSPACE[s(n)] for any s(n) \u2265 \u2126(log n). However, the opposite direction was a long-standing open problem. Recently, Fefferman and Remscrim [FR21] demonstrated a remarkable result that BQSPACE[s(n)] \u2286 BQUSPACE[O(s(n))]. In addition, it is evident that BQSPACE[s(n)] can achieve error reduction since it admits sequential repetition simply by resetting working qubits. Therefore, we define BQSPACE[s(n)] := BQSPACE[s(n), 2/3, 1/3]\nto represent (two-sided) bounded-error general quantum space, and denote general quantum logspace by BQL := BQSPACE[O(log n)].\nWe now turn our attention to one-sided bounded-error unitary quantum space RQUSPACE[s(n)] and coRQUSPACE[s(n)] for s(n) \u2265 \u2126(log n). These complexity classes were first introduced by Watrous [Wat01] and have been further discussed in [FR21]. We proceed with the definitions:\n\u2022 RQUSPACE[s(n), a(n)] := BQUSPACE[s(n), a(n), 0];\n\u2022 coRQUSPACE[s(n), b(n)] := BQUSPACE[s(n), 1, b(n)].\nNote that RQUSPACE[s(n), a(n)] and coRQUSPACE[s(n), b(n)] can achieve error reduction, as shown in [Wat01] or our space-efficient QSVT-based construction in Section 3.4. We define\nRQUSPACE[s(n)] := BQUSPACE [ s(n), 12 , 0 ] and coRQUSPACE[s(n)] := BQUSPACE [ s(n), 1, 12 ]\nto represent one-sided bounded-error unitary quantum space, as well as logspace counterparts\nRQUL := RQUSPACE[O(log n)] and coRQUL := coRQUSPACE[O(log n)].\nRemark 2.8 (RQUL and coRQUL are gateset-dependent). We observe that changing the gateset in space-efficient Solovay-Kitaev theorem [vMW12] can cause errors, revealing the gatesetdependence of unitary quantum space classes with one-sided bounded-error. To address this issue, we adopt a larger gateset G for RQUSPACE[s(n)] and coRQUSPACE[s(n)], which includes any single-qubit gates whose amplitudes can be computed in deterministic O(s(n)) space."
        },
        {
            "heading": "2.3 Near-minimax approximation by Chebyshev interpolation",
            "text": "We will define Chebyshev polynomials and introduce Chebyshev interpolation, which is notable for providing near-minimax approximations. These concepts are essential to our spaceefficient quantum singular value transformation techniques (Section 3).\nDefinition 2.9 (Chebyshev polynomials). The Chebyshev polynomials (of the first kind) Tk(x) are defined via the following recurrence relation: T0(x) := 1, T1(x) := x, and Tk+1(x) := 2xTk(x)\u2212 Tk\u22121(x). For x \u2208 [\u22121, 1], an equivalent definition is Tk(cos \u03b8) = cos(k\u03b8).\nIn order to use Chebyshev polynomials for interpolation, we first need to define an inner product between two functions, f and g, as long as the following integral exists:\n\u3008f, g\u3009 := 2 \u03c0\n\u222b 1\n\u22121 f(x)g(x)\u221a 1\u2212 x2 dx = 2 \u03c0\n\u222b 0\n\u2212\u03c0 f(cos \u03b8)g(cos \u03b8)d\u03b8.\nThe Chebyshev polynomials form an orthonormal basis in this inner product space induced by \u3008\u00b7, \u00b7\u3009. As a result, any degree-d polynomial Pd can be represented as a linear combination of Chebyshev polynomials using a technique called Chebyshev interpolation, see [MH02, Section 6.5] for the details. In particular, Pd = 1 2 \u3008T0, Pd\u3009 + \u2211d k=1\u3008Tk, Pd\u3009Tk. It is noteworthy that Lemma 2.10 is first proven in [Pow67].\nLemma 2.10 (Near-minimax approximation by Chebyshev interpolation, adapted from Theorem 6.13 in [MH02]). For any continuous function f : [\u22121, 1] \u2192 R, if there exists an explicit degree-d polynomial P\u0302d \u2208 R[x] such that maxx\u2208[\u22121,1] |f(x) \u2212 P\u0302d(x)| \u2264 \u01eb, then we know that Pd = 1 2\u3008T0, f\u3009+ \u2211d k=1\u3008Tk, f\u3009Tk satisfies maxx\u2208[\u22121,1] |f(x)\u2212 Pd(x)| \u2264 O(\u01eb log d)."
        },
        {
            "heading": "2.4 Tools for space-bounded randomized and quantum algorithms",
            "text": "Our convention assumes that for any algorithm A in bounded-error randomized time t(n) and space s(n), A outputs the correct value with probability at least 2/3 (viewed as \u201csuccess probability\u201d). We first proceed with space-efficient success probability estimation.\nLemma 2.11 (Space-efficient success probability estimation by sequential repetitions). Let A be a randomized (resp., quantum) algorithm that outputs the correct value with probability p, has time complexity t(n), and space complexity s(n). We can obtain an additive-error estimation p\u0302 such that |p \u2212 p\u0302| \u2264 \u01eb, where \u01eb \u2265 2\u2212O(s(n)). Moreover, this estimation can be computed in bounded-error randomized (resp., quantum) time O(\u01eb\u22122t(n)) and space O(s(n)).\nProof. Consider a m-time sequential repetition of the algorithm A, and let Xi be a random variable indicating whether the i-th repetition succeeds, then we obtain a random variable X = 1 m \u2211m i=1Xi such that E[X] = p. Now let X\u0302 = 1 m \u2211m i=1 X\u0302i be the additive-error estimation, where X\u0302i is the outcome of A in the i-th repetition. By the Chernoff-Hoeffding bound (e.g., Theorem 4.12 in [MU17]), we know that Pr [ |X\u0302 \u2212 p| \u2265 \u01eb ] \u2264 2 exp(\u22122m\u01eb2). By choosing m = 2\u01eb\u22122, this choice of m ensures that each run of A succeeds with probability at least 2/3. Furthermore, the space complexity of our algorithm is O(s(n)) since we can simply reuse the workspace. Also, the time complexity is m \u00b7 t(n) = O(\u01eb\u22122t(n)) as desired.\nNotably, when applying Lemma 2.11 to a quantum algorithm, we introduce intermediate measurements to retain space complexity through reusing working qubits. While space-efficient success probability estimation without intermediate measurements is possible,23 we will use Lemma 2.11 for convenience, given that BQL = BQUL [FR21].\nThe SWAP test was originally proposed for pure states in [BCWdW01]. Subsequently, in [KMY09], it was demonstrated that the SWAP test can also be applied to mixed states.\nLemma 2.12 (SWAP test for mixed states, adapted from [KMY09, Proposition 9]). Suppose \u03c10 and \u03c11 are two n-qubit mixed quantum states. There is a (2n + 1)-qubit quantum circuit that outputs 0 with probability 1+Tr(\u03c10\u03c11)2 , using 1 sample of each \u03c10 and \u03c11 and O(n) one- and two-qubit quantum gates.\nA matrix B is said to be sub-stochastic if all its entries are non-negative and the sum of entries in each row (respectively, column) is strictly less than 1. Moreover, a matrix B is row-stochastic if all its entries are non-negative and the sum of entries in each row is equal to 1.\nLemma 2.13 (Sub-stochastic matrix powering in bounded space). Let B be an l \u00d7 l substochastic matrix, where each entry of B requires at most \u2113-bit precision. Then, there exists an explicit randomized algorithm that computes the matrix power Bk[s, t] in log(l+1) space and O(\u2113k) time. Specifically, the algorithm accepts with probability Bk[s, t].\nProof. Our randomized algorithm leverages the equivalence between space-bounded randomized computation and Markov chains, see [Sak96, Section 2.4] for a detailed introduction.\nFirst, we construct a row-stochastic matrix B\u0302 from B by adding an additional column and row. Let B\u0302[i, j] denote the entry at the i-th column and the j-th row of B\u0302. Specifically,\nB\u0302[i, j] :=    B[i, j], if 1 \u2264 i, j \u2264 l; 1\u2212\u2211l+1\u2212ij=1 b (1) j , if i = l + 1 and 1 \u2264 j \u2264 l + 1;\n0, if 1 \u2264 i \u2264 l and j = l + 1.\nNext, we view B\u0302 as a transition matrix of a Markov chain since B\u0302 is row-stochastic. We consequently have a random walk on the directed graph G = (V,E) where V = {1, 2, \u00b7 \u00b7 \u00b7 , l}\u222a{\u22a5} and (u, v) \u2208 E iff B\u0302(u, v) > 0. In particular, the probability that a k-step random walk starting at node s and ending at node t is exactly B\u0302k[s, t] = Bk[s, t]. This is because the walker who visits the dummy node \u22a5 will not reach other nodes.\n23Fefferman and Lin [FL18] noticed that one can achieve space-efficient success probability estimation for quantum algorithms without intermediate measurements via quantum amplitude estimation [BHMT02].\nFinally, note that B\u0302 is a (l+1)\u00d7 (l+1) matrix, the matrix powering of B\u0302k can be computed in log(l) space. In addition, the overall time complexity is O(\u2113k) since we simulate the dyadic rationals (with \u2113-bit precision) of a single transition exactly by \u2113 coin flips."
        },
        {
            "heading": "3 Space-efficient quantum singular value transformations",
            "text": "We begin by defining the projected unitary encoding and its special forms, viz. the bitstring indexed encoding and the block-encoding, as well as notations on singular value decomposition and singular value transformation.\nDefinition 3.1 (Projected unitary encoding and its special forms, adapted from [GSLW19]). Let U be an (\u03b1, a, \u01eb)-projected unitary encoding of a linear operator A if \u2016A \u2212 \u03b1\u03a0\u0303U\u03a0\u2016 \u2264 \u01eb, where U and orthogonal projectors \u03a0\u0303 and \u03a0 act on s+a qubits, and both rank(\u03a0\u0303) and rank(\u03a0) are at least 2a (a is viewed as the number of ancillary qubits). Furthermore, we are interested in two special forms of the projected unitary encoding:\n\u2022 Bitstring indexed encoding. We say that a projected unitary encoding is a bitstring indexed encoding if both orthogonal projectors \u03a0\u0303 and \u03a0 span on S\u0303, S \u2286 {|0\u3009, |1\u3009}\u2297(a+s) , respectively.24 In particular, for any |s\u0303i\u3009 \u2208 S\u0303 and |sj\u3009 \u2208 S, we have a matrix representation AS\u0303,S(i, j) := \u3008s\u0303i|U |sj\u3009 of A.\n\u2022 Block-encoding. We say that a projected unitary encoding is a block-encoding if both orthogonal projectors are of the form \u03a0 = \u03a0\u0303 = |0\u3009\u30080|\u2297a \u2297 Is. We use the shorthand A = (\u30080\u0304| \u2297 Is)U(|0\u0304\u3009 \u2297 Is) for convenience.\nDefinition 3.2 (Singular value decomposition of a projected unitary, adapted from Definition 7 in [GSLW19]). Given a projected unitary encoding of A, denoted by U , associated with orthogonal projectors \u03a0 and \u03a0\u0303 on a finite-dimensional Hilbert space HU . Namely, A = \u03a0\u0303U\u03a0. Then there exists orthonormal bases of \u03a0 and \u03a0\u0303 such that \u03a0: {|\u03c8i\u3009 : i \u2208 [d]}, where d := rank(\u03a0), of a subspace Img(\u03a0) = span {|\u03c8i\u3009}; \u03a0\u0303: { |\u03c8\u0303i\u3009 : i \u2208 [d\u0303] } , where d\u0303 := rank(\u03a0\u0303), of a subspace Img(\u03a0\u0303) = span { |\u03c8\u0303i\u3009 } . These bases ensure that the singular value decomposition \u03a0\u0303U\u03a0 = \u2211min{d,d\u0303}\ni=1 \u03c3i|\u03c8\u0303i\u3009\u3008\u03c8i| where singular values \u03c3i > \u03c3j for any i < j \u2208 [min{d, d\u0303}].\nDefinition 3.3 (Singular value transformation by even or odd functions, adapted from Definition 9 in [GSLW19]). Let f : R \u2192 C be an even or odd function. We consider a linear operator A \u2208 Cd\u0303\u00d7d satisfying the singular value decomposition A = \u2211min{d,d\u0303}i=1 \u03c3i|\u03c8\u0303i\u3009\u3008\u03c8\u0303i|. We define the singular value transformation corresponding to f as follows:\nf (SV)(A) := {\u2211min{d,d\u0303} i=1 f(\u03c3i)|\u03c8\u0303i\u3009\u3008\u03c8i|, for odd f,\u2211d i=1 f(\u03c3i)|\u03c8i\u3009\u3008\u03c8i|, for even f.\nHere, for i \u2208 {min{d, d\u0303}+ 1, \u00b7 \u00b7 \u00b7 , d\u2212 1, d}, we define \u03c3i := 0. It is worth noting that f (SV)(A) = f(A) when A is an Hermitian matrix.\nWith these definitions in place, we present the main (informal) theorem in this section:\nTheorem 3.4 (Space-efficient QSVT). Let f : R \u2192 R be a continuous function bounded on the closed interval of interest I \u2286 [\u22121, 1]. If there exists a degree-d polynomial P\u0302d that approximates h : [\u22121, 1] \u2192 R, where h approximates f only on I, such that maxx\u2208[\u22121,1] |h(x)\u2212P\u0302d(x)| \u2264 \u01eb, then Chebyshev interpolation yields another degree-d polynomial Pd satisfying the following conditions: maxx\u2208I |f(x)\u2212 Pd(x)| \u2264 O(\u01eb log d) and maxx\u2208[\u22121,1] |Pd(x)| \u2264 1.\n24Typically, to ensure these orthogonal projectors coincide with space-bounded quantum computation, we additionally require the corresponding subsets S\u0303 and S admit space-efficient set membership, namely deciding the membership of these subsets is in deterministic O(s+ a) space.\nMoreover, we have space-efficient classical algorithms for computing any entry in the coefficient vector c of the Chebyshev interpolation polynomial Pd:\n\u2022 If f is a bounded function,25 then any entry in the coefficient vector c can be computed in deterministic O(log d) space;\n\u2022 If f is a piecewise-smooth function, then any entry in the coefficient vector c can be computed in bounded-error randomized O(log d) space.\nFurthermore, for any (1, a, 0)-bitstring indexed encoding U of A = \u03a0\u0303U\u03a0, acting on s+ a qubits where a(n) \u2264 s(n), and any Pd with d \u2264 2O(s(n)), we can implement the quantum singular value transformation P\n(SV) d (A) that acts on O(s(n)) qubits by using O(d 2\u2016c\u20161) queries to U .\nWe remark that we can apply Theorem 3.4 to general forms of the projected unitary encoding U with orthogonal projectors \u03a0 and \u03a0\u0303, as long as such an encoding meets the conditions: (1) The basis of \u03a0 and \u03a0\u0303 admits a well-defined order; (2) Both controlled-\u03a0 and controlled-\u03a0\u0303 admit computationally efficient implementation. We note that bitstring indexed encoding defined in Definition 3.1 trivially meets the first condition, and a sufficient condition for the second condition is that the corresponding subsets S and S\u0303 have space-efficient set membership.\nSpecifically, we elaborate on three main technical contributions that culminate in our spaceefficient quantum singular value transformations (Theorem 3.4):\n\u2022 We provide deterministic space-efficient polynomial approximations for bounded functions (Lemma 3.5), including the sign function (Corollary 3.7). Our approach leads to a simple proof of space-efficient error reduction for unitary quantum computations (Section 3.4).\n\u2022 We present bounded-error randomized space-efficient polynomial approximations for piecewisesmooth functions (Theorem 3.8), such as the normalized logarithmic function (Corollary 3.10).\n\u2022 We propose QSVT implementations using Chebyshev interpolation polynomials (Theorem 3.11), including those for the sign function (Corollary 3.16) and the normalized logarithmic function (Corollary 3.17)."
        },
        {
            "heading": "3.1 Space-efficient bounded polynomial approximations",
            "text": "We provide a systematic approach for constructing space-efficient polynomial approximations of real-valued piecewise-smooth functions, which is a space-efficient counterpart of Corollary 23 in [GSLW19]. It is worth mentioning that our algorithm (Lemma 3.5) is deterministic for continuous functions that are bounded on the interval [\u22121, 1]. However, for general piecewise-smooth functions, we only introduce a randomized algorithm (Theorem 3.8). In addition, please refer to Section 2.3 as a brief introduction to Chebyshev polynomials and Chebyshev interpolation."
        },
        {
            "heading": "3.1.1 Bounded functions",
            "text": "We propose a space-efficient algorithm for computing the coefficients of a polynomial approximation with high accuracy for bounded functions. Our approach uses Chebyshev interpolation and numerical integration, building upon the methodology outlined in Lemma 2.10 of [MY23] with meticulous analysis.\nLemma 3.5 (Space-efficient polynomial approximations for bounded functions). Consider a continuous function f , and let P\u0302 (f) d be a degree-d polynomial with the same parity as f , such that maxx\u2208[\u22121,1]|f(x)\u2212 P\u0302 (f)d (x)| \u2264 \u01eb, where f is bounded with maxx\u2208[\u22121,1] |f(x)| \u2264 B. By using 25This conclusion also applies to a linear combination of bounded functions, provided that the coefficients are bounded and can be computed deterministically and space-efficiently.\nChebyshev interpolation, we can obtain another degree-d polynomial P (f) d that has the same parity as P\u0302 (f) d and satisfies maxx\u2208[\u22121,1] |f(x) \u2212 P (f) d (x)| \u2264 O(\u01eb log d). This polynomial P (f) d is defined as a linear combination of Chebyshev polynomials Tk(cos \u03b8) = cos(k\u03b8):\nP (f) d (x) = c0 2\n+ d\u2211\nk=1\nckTk(x) where ck := 2\n\u03c0\n\u222b 0\n\u2212\u03c0 Fk(\u03b8)d\u03b8 and Fk(\u03b8) := cos(k\u03b8)f(cos \u03b8).\nIf the integrand Fk(\u03b8) satisfies max\u03be\u2208[\u2212\u03c0,0] |F \u2032\u2032k (\u03be)| \u2264 O(d\u03b3) for some constant \u03b3, then any entry of the coefficient vector c = (c0, \u00b7 \u00b7 \u00b7 , cd) can be computed in deterministic time O(d(\u03b3+1)/2\u01eb\u22121/2t(\u2113)) and space O(log(d\u03b3+1\u01eb\u22121B)), where evaluating F (\u03b8) in \u2113-bit precision is in deterministic time t(\u2113) and space O(\u2113) for \u2113 = O(log(d(\u03b3+1)/2\u01eb\u22123/2)). Furthermore, the coefficient vector c has a norm bounded by \u2016c\u20161 \u2264 O(Bd). Proof. To apply Chebyshev interpolation to a bounded continuous function f(x), we begin with a degree-d polynomial P\u0302 (f) d such that maxx\u2208[\u22121,1] |f(x)\u2212 P\u0302 (f) d (x)| \u2264 \u01eb. By utilizing Lemma 2.10, we can construct a degree-d Chebyshev interpolation of f(x) denoted as P (f) d . This interpolation is expressed as P (f) d = c0/2+ \u2211d k=1 ckTk, where ck = 2 \u03c0 \u222b 0 \u2212\u03c0 Fk(\u03b8)d\u03b8 and Fk(\u03b8) := cos(k\u03b8)f(cos \u03b8),\nand additionally satisfies the error bound: maxx\u2208[\u22121,1] \u2223\u2223\u2223f(x)\u2212 P (f)d (x) \u2223\u2223\u2223 \u2264 O(\u01eb log d).\nComputing the coefficients. It is left to compute the coefficients ck for 0 \u2264 k \u2264 d. We can estimate the numerical integration using the composite trapezium rule, as described in [SM03, Section 7.5]. The application of this method yields the following result: \u222b 0\n\u2212\u03c0 Fk(x)dx \u2248\n\u03c0\nm (Fk(x0) 2 + m\u2211\nl=1\nFk(xl) + Fk(xm)\n2\n) where xl := \u2212\u03c0 + \u03c0l\nm for l = 0, 1, \u00b7 \u00b7 \u00b7 ,m.\n(3.1) Moreover, we know the upper bound on the numerical errors for computing the coefficient ck:\n\u03b5 (f) d,k :=\nm\u2211\nl=1\n\u2223\u2223\u2223 \u222b xi\nxi\u22121\nFk(x)dx\u2212 \u03c0\n2m \u00b7 (Fk(xi\u22121) + Fk(xi))\n\u2223\u2223\u2223 \u2264 \u03c0 3\n12m2 max \u03be\u2208[\u2212\u03c0,\u03c0]\n\u2223\u2223F \u2032\u2032k (\u03be) \u2223\u2223 . (3.2)\nTo obtain an upper bound on the number of intervals m, we need to ensure that the error of the numerical integration is within \u03b5 (f) d = \u2211d k=1 \u03b5 (f) d,k \u2264 \u01eb. Plugging the assumption |F \u2032\u2032k (x)| \u2264 O(d\u03b3) into Equation (3.2), by choosing an appropriate value of m = O(\u01eb\u22121/2d(\u03b3+1)/2), we establish that \u03b5 (f) d \u2264 O(d\u03b3+1/m2) \u2264 O(\u01eb). Moreover, to guarantee that the accumulated error is O(\u01eb) in Equation (3.1), we need to evaluate the integrand F (\u03b8) with \u2113-bit precision, where \u2113 = O(log (m/\u01eb)) = O(log(\u01eb\u22123/2d(\u03b3+1)/2)). In addition, note that ck = 2 \u03c0 \u222b 0 \u2212\u03c0 Fk(\u03b8)d\u03b8 \u2264 2 \u00b7maxx\u2208[\u22121,1] |f(x)| \u2264 2B, we know that the coefficient vector c satisfies \u2016c\u20161 = \u2211d k=0 |ci| \u2264 O(Bd).\nAnalyzing time and space complexity. The presented numerical integration algorithm is deterministic, and therefore, the time complexity for computing the integral is O(mt(\u2113)), where t(\u2113) is the time complexity for evaluating the integrand Fk(\u03b8) within 2\n\u2212\u2113 accuracy (i.e., \u2113-bit precision) in O(\u2113) space. The space complexity required for computing the numerical integration is the number of bits required to index the integral intervals and represent the resulting coefficients. To be specific, the space complexity is max { O(logm), O ( log m\u01eb ) , log \u2016c\u2016\u221e } \u2264 O ( max { log ( \u01eb\u2212 3 2d\u2212 \u03b3+1 2 ) , logB }) \u2264 O ( log ( \u01eb\u2212 3 2 d\u2212 \u03b3+1 2 B )) .\nHere, \u2016c\u2016\u221e = max 0\u2264k\u2264d 2 \u03c0 | \u222b 0 \u2212\u03c0 cos(k\u03b8)f(cos \u03b8)d\u03b8| \u2264 max0\u2264k\u2264d max\u2212\u03c0\u2264\u03b8\u22640O(|f(cos \u03b8)|) \u2264 O(B), and the last inequality is due to the fact that \u0398(max{logA, logB}) = \u0398(log(AB)) for any A,B > 0.\nIt is worth noting that evaluating a large family of functions, called holonomic functions, with \u2113-bit precision requires only deterministic O(\u2113) space:\nRemark 3.6 (Space-efficient evaluation of holonomic functions). Holonomic functions encompass several commonly used functions,26 such as polynomials, rational functions, sine and cosine functions (but not other trigonometric functions such as tangent or secant), exponential functions, logarithms (to any base), the Gaussian error function, and the normalized binomial coefficients. In [CGKZ05,Mez12], these works have demonstrated that evaluating a holonomic function with \u2113-bit precision is achievable in deterministic time O\u0303(\u2113) and space O(\u2113). Prior works achieved the same time complexity, but with a space complexity of O(\u2113 log \u2113).\nWe now present an example of bounded functions, specifically the sign function.\nCorollary 3.7 (Space-efficient approximation to the sign function). For any \u03b4, \u01eb > 0, there is an explicit odd polynomial P sgnd := c0 2 + \u2211d k=1 ckTk \u2208 R[x] of degree d \u2264 C\u0303sgn\u03b4\u22121 log \u01eb\u22121, where C\u0303sgn is a universal constant. Any entry of the coefficient vector c := (c0, \u00b7 \u00b7 \u00b7 , cd) can be computed in deterministic time O\u0303 ( \u01eb\u22121/2d2 ) and space O(log(\u01eb\u22121d4)). Furthermore, the polynomial P sgnd satisfies the following conditions:\n\u2200x \u2208 [\u22121, 1] \\ [\u2212\u03b4, \u03b4], \u2223\u2223sgn(x)\u2212 P sgnd (x) \u2223\u2223 \u2264 Csgn\u01eb log d, where Csgn is a universal constant, \u2200x \u2208 [\u22121, 1], \u2223\u2223P sgnd (x) \u2223\u2223 \u2264 1.\nAdditionally, the coefficient vector c has a norm bounded by \u2016c\u20161 \u2264 C\u0302sgn log d, where C\u0302sgn is another universal constant. Without loss of generality. we assume that all constants Csgn, C\u0302sgn, and C\u0303sgn are at least 1.\nProof. We start from a degree-d polynomial P\u0302 sgnd that well-approximates sgn(x).\nProposition 3.7.1 (Polynomial approximation of the sign function, adapted from Lemma 10 and Corollary 4 in [LC17]). For any \u03b4 > 0, x \u2208 R, \u01eb \u2208 (0, \u221a 2e\u03c0). Let \u03ba = 2\u03b4 log 1/2 ( \u221a 2\u221a \u03c0\u01eb ) , Then\ng\u03b4,\u01eb(x) := erf(\u03bax) satisfies that |g\u03b4,\u01eb(x)| \u2264 1 and max |x|\u2265\u03b4/2 |g\u03b4,\u01eb(x)\u2212 sgn(x)| \u2264 \u01eb.\nMoreover, there is an explicit odd polynomial P\u0302 sgnd \u2208 R[x] of degree d = O( \u221a (\u03ba2 + log \u01eb\u22121) log \u01eb\u22121)\nsuch that maxx\u2208[\u22121,1] \u2223\u2223\u2223P\u0302 sgnd (x)\u2212 erf(\u03bax) \u2223\u2223\u2223 \u2264 \u01eb\nBy applying Proposition 3.7.1, we obtain a polynomial P\u0302 sgnd that well approximates the\nfunction erf(\u03bax) where \u03ba = O(\u03b4\u22121 \u221a\nlog \u01eb\u22121). Consequently, this polynomial P\u0302 sgnd has a degree of d \u2264 C\u0303sgn\u03b4\u22121 log \u01eb\u22121, where C\u0303sgn is a universal constant. Note that the Gaussian error function is bounded, namely | erf(\u03bax)| \u2264 1 for any x. To utilize Lemma 3.5, it suffices to upper bound max\u03be\u2208[\u2212\u03c0,0] |F \u2032\u2032k (\u03be)| for any 0 \u2264 k \u2264 d, as specified in Fact 3.7.2 and the proof is deferred to Appendix A.1.1.\nFact 3.7.2. Let Fk(\u03b8) := erf(\u03ba cos \u03b8) cos(k\u03b8), max 0\u2264k\u2264d max \u03be\u2208[\u2212\u03c0,0]\n|F \u2032\u2032k (\u03be)| \u2264 2\u221a\u03c0\u03ba+k 2+ 4\u221a \u03c0 \u03ba3+ 4\u221a \u03c0 k\u03ba.\nNote that \u03ba \u2264 O(d) and k \u2264 d, Fact 3.7.2 indicates that max\u03be\u2208[\u2212\u03c0,0] |F \u2032\u2032k (\u03be)| \u2264 O(d3) for any 0 \u2264 k \u2264 d. Hence, we result in an approximation polynomial P\u0303 sgnd by Lemma 3.5 satisfies that maxx\u2208[\u22121,1] | erf(\u03bax)\u2212 P\u0303 sgnd (x)| \u2264 O(\u01eb log d), which additionally derives that\nmax x\u2208[\u22121,1] |sgn(x)\u2212 P\u0303 sgnd (x)| \u2264 \u01eb+ max x\u2208[\u22121,1] | erf(\u03bax)\u2212 P\u0303 sgnd (x)| \u2264 Csgn\u01eb log d.\nHere, Csgn is a universal constant. Moreover, we specify the bound of \u2016c\u0303sgn\u20161 in Fact 3.7.3, and the proof is deferred to Appendix A.1.1:\nFact 3.7.3 (Implicit in [MY23, Lemma 2.10]). For the coefficient vector c\u0303sgn corresponding to a degree-d polynomial P\u0303 sgnd , we have \u2016c\u0303sgn\u20161 \u2264 C\u0302sgn log d where C\u0302sgn is a universal constant.\n26For a more detailed introduction, please refer to [BZ10, Section 4.9.2].\nIn addition, the coefficient vector c\u0303sgn can be computed in deterministic space O(log(d\u01eb\u22121)). As the evaluation of the integrand F (\u03b8) requires \u2113-bit precision where \u2113 = O(log(\u01eb\u22123/2d2)), together with Remark 3.6, c\u0303sgn can be computed in deterministic time O\u0303(\u01eb\u22121/2d2).\nFinally, we obtain that |P\u0303 sgnd (x)| \u2264 1+ \u01eb for any x \u2208 [\u22121, 1] since |sgn(x)| \u2264 1 for any x. We finish the proof by normalizing P\u0303 sgnd , in particular, considering P sgn d (x) := (1 + \u01eb)\n\u22121P\u0303 sgnd . It is evident to verify that P sgnd is an odd polynomial that satisfies all desired requirements."
        },
        {
            "heading": "3.1.2 Piecewise-smooth functions",
            "text": "We present a randomized algorithm for constructing bounded polynomial approximations of piecewise-smooth functions, which can be seen as a space-efficient alternative to Corollary 23 in [GSLW19], as described in Theorem 3.8. Our algorithm leverages Lemma 3.5 and Lemma 3.9.\nTheorem 3.8 (Taylor series based space-efficient bounded polynomial approximations). Consider a real-valued function f : [\u2212x0\u2212 r\u2212 \u03b4, x0 + r+ \u03b4] \u2192 R such that f(x0+x) = \u2211\u221e l=0 alx\nl for all x \u2208 [\u2212r\u2212\u03b4, r+\u03b4], where x0 \u2208 [\u22121, 1], r \u2208 (0, 2], \u03b4 \u2208 (0, r]. Assume that \u2211\u221e l=0(r+\u03b4)\nl|al| \u2264 B where B > 0. Let \u01eb \u2208 (0, 12B ] such that B > \u01eb, then there is a polynomial P \u2208 R[x] of degree O(\u03b4\u22121 log(\u01eb\u22121B)), such that any entry of the coefficient vector c(P ) can be computed in boundederror randomized time O\u0303(max{(\u03b4\u2032)\u22125\u01eb\u22122B2, d2\u01eb\u22121/2B}) and space O(log(d4(\u03b4\u2032)\u22124\u01eb\u22121B)) where \u03b4\u2032 := \u03b42(r+\u03b4) , such that\n\u2016f(x)\u2212 P (x)\u2016[x0\u2212r,x0+r] \u2264 O(\u01eb log d), \u2016P (x)\u2016[\u22121,1] \u2264 O(\u01eb log d) + \u2016f(x)\u2016[x0\u2212r\u2212\u03b4/2,x0+r+\u03b4/2] \u2264 O(\u01eb log d) +B,\n\u2016P (x)\u2016[\u22121,1]\\[x0\u2212r\u2212\u03b4/2,x0+r+\u03b4/2] \u2264 O(\u01eb log d). Furthermore, the coefficient vector c(P ) of P has a norm bounded by \u2016c(P )\u20161 \u2264 O(Bd).\nThe main ingredient, and the primary challenge, for demonstrating Theorem 3.8 is to construct a low-weight approximation using Fourier series, as shown in Lemma 37 of [vAGGdW20], which requires computing the powers of sub-stochastic matrices in bounded space (Lemma 2.13).\nLemma 3.9 (Space-efficient low-weight approximation by Fourier series). Let 0 < \u03b4, \u01eb < 1 and f : R \u2192 R be a real-valued function such that |f(x) \u2212 \u2211Kk=0 akxk| \u2264 \u01eb/4 for all x \u2208 I\u03b4, the interval I\u03b4 := [\u22121 + \u03b4, 1 \u2212 \u03b4] and \u2016a\u20161 \u2264 O(max{\u01eb\u22121, \u03b4\u22121}). Then there is a coefficient vector c \u2208 C2M+1 such that\n\u2022 For even functions, \u2223\u2223\u2223f(x)\u2212 \u2211M m=\u2212M c (even) m cos(\u03c0xm) \u2223\u2223\u2223 \u2264 \u01eb for any x \u2208 I\u03b4; \u2022 For odd functions, \u2223\u2223\u2223f(x)\u2212 \u2211M m=\u2212M c (odd) m sin ( \u03c0x ( m+ 12 ))\u2223\u2223\u2223 \u2264 \u01eb for any x \u2208 I\u03b4; \u2022 Otherwise, \u2223\u2223\u2223f(x)\u2212 \u2211M m=\u2212M ( c (even) m cos(\u03c0xm)+c (odd) m sin ( \u03c0x ( m+ 12 )) )\u2223\u2223\u2223\u2264\u01eb for any x \u2208 I\u03b4.\nHere M := max ( 2\u2308\u03b4\u22121 ln(4\u2016a\u20161\u01eb\u22121)\u2309, 0 ) and \u2016c\u20161 \u2264 \u2016a\u20161. Moreover, the coefficient vector c can be computed in bounded-error randomized time O\u0303(\u03b4\u22125\u01eb\u22122) and space O(log(\u03b4\u22124\u01eb\u22121)).\nProof. We begin by defining \u2016f\u2016\u221e := sup{|f(x)| : x \u2208 [\u22121+\u03b4, 1\u2212\u03b4]}. It is worth noting that the truncation error of \u2211K k=0 akx\nk, as shown in [SM03, Theorem A.4], is (1\u2212 \u03b4)k+1 \u2264 e\u2212\u03b4(k+1) \u2264 \u01eb, implying that K \u2265 \u2126(\u03b4\u22121 ln \u01eb\u22121). Without loss of generality, we can assume that \u2016a\u20161 \u2265 \u01eb/2.27\nConstruction of polynomial approximations. Our construction involves three approximations, as described in Lemma 37 of [vAGGdW20]. We defer the detailed proofs of all three approximations to Appendix A.1.2.\nThe first approximation combines the assumed \u2211K\nk=0 akx k with arcsin(x)\u2019s Taylor series.\n27This is because if \u2016a\u20161 < \u01eb/2, then \u2016f\u2016\u221e \u2264 \u2016f(x) \u2212 \u2211K k=0 akx k\u2016\u221e + \u2016 \u2211K k=0 akx k\u2016\u221e \u2264 \u01eb/4 + \u2016a\u20161 < \u01eb, implying that M = 0 and c = 0.\nProposition 3.9.1 (First approximation). Let f\u03021(x) := \u2211K k=0 akx k such that \u2016f \u2212 f\u03021\u2016\u221e \u2264 \u01eb/4. Then we know that f\u03021(x) = \u2211K k=0 ak \u2211\u221e l=0 b (k) l sin l ( x\u03c0 2 ) where the coefficients b (k) l satisfy that\nb (k+1) l =\nl\u2211\nl\u2032=0\nb (k) l\u2032 b (1) l\u2212l\u2032 where b (1) l = { 0 if l is even,(l\u22121\nl\u22121 2\n) 2\u2212l+1\nl \u00b7 2\u03c0 if l is odd. (3.3)\nFurthermore, the coefficients {b(k)l } satisfies the following: (1) \u2016b(k)\u20161 = 1 for all k \u2265 1; (2) b(k) is entry-wise non-negative for all k \u2265 1; (3) b(k)l = 0 if l and k have different parities.\nThe second approximation truncates the series at l = L, and bounds the truncation error.\nProposition 3.9.2 (Second approximation). Let f\u03022(x) := \u2211K k=0 ak \u2211L l=0 b (k) l sin l ( x\u03c0 2 ) where L := \u2308\u03b4\u22122 ln(4\u2016a\u20161\u01eb\u22121)\u2309, then we have that \u2016f\u03021 \u2212 f\u03022\u2016\u221e \u2264 \u01eb/4. The third approximation approximates the functions sinl(x) in f\u03022(x) using a tail bound of the binomial distribution. Notably, this construction not only quadratically improves the dependence on \u03b4, but also ensures that the integrand\u2019s second derivative is bounded when combined with Lemma 3.5.\nProposition 3.9.3 (Third approximation). Let f\u03023(x) be polynomial approximations of f that depends on the parity of f such that \u2016f\u03022\u2212f\u03023\u2016\u2264\u01eb/2 and M=\u230a\u03b4\u22121 ln(4\u2016a\u20161\u01eb\u22121)\u230b, then we have\nf\u0302 (even) 3 (x) := K\u2211 k=0 ak L/2\u2211\nl\u0302=0\n(\u22121)l\u03022\u22122l\u0302b(k) 2l\u0302\nl\u0302+M\u2211\nm\u2032=l\u0302\u2212M (\u22121)m\u2032\n( 2l\u0302 m\u2032 ) cos(\u03c0x(m\u2032 \u2212 l\u0302)),\nf\u0302 (odd) 3 (x) := K\u2211 k=0 ak (L\u22121)/2\u2211\nl\u0302=0\n(\u22121)l\u0302+12\u22122l\u0302\u22121b(k) 2l\u0302+1\nl\u0302+1+M\u2211\nm\u2032=l\u0302+1\u2212M (\u22121)m\u2032\n( 2l\u0302+1 m\u2032 ) sin ( \u03c0x ( m\u2032 \u2212 l\u0302 \u2212 12 )) .\nTherefore, we have that f\u03023(x) := f\u0302 (even) 3 (x) if f is even, whereas f\u03023(x) := f\u0302 (odd) 3 (x) if f is odd. In addition, if f is neither even or odd, then f\u03023(x) := f\u0302 (even) 3 (x) + f\u0302 (odd) 3 (x).\nWe adopt the third approximation as our construction by rearranging the summations and introducing a new parameter m. The value of m is defined as m := m\u2032 \u2212 l\u0302 if f is even and m := m\u2032 \u2212 l\u0302\u2212 1 if f is odd. Moreover, the definition of m depends on the parity of l = 2l\u0302 + 128 if f is neither even nor odd. By applying this approach, we can derive the following:\nf\u0302 (even) 3 (x)= M\u2211 m=\u2212M c (even) m cos(\u03c0xm) where c (even) m :=(\u22121)m K\u2211 k=0 ak L/2\u2211\nl\u0302=0\nb (k)\n2l\u0302\n( 2l\u0302 m+l\u0302 ) 2\u22122l\u0302;\nf\u0302 (odd) 3 (x)= M\u2211 m=\u2212M c (odd) m sin ( \u03c0x ( m+ 12 )) where c (odd) m :=(\u22121)m K\u2211 k=0 ak (L\u22121)/2\u2211\nl\u0302=0\nb (k)\n2l\u0302+1\n( 2l\u0302+1 m+l\u0302+1 ) 2\u22122l\u0302\u22121.\n(3.4)\nWe then notice that the rearrangement of terms in Equation (3.4) can be directly applied to the definition of f\u03023(x) in Proposition 3.9.3. As a consequence, we obtain the following bound on the accumulative error: \u2016f\u2212f\u03023\u2016\u221e \u2264 \u2016f\u2212f\u03021\u2016\u221e + \u2016f\u03021\u2212f\u03022\u2016\u221e + \u2016f\u03022\u2212f\u03023\u2016\u221e \u2264 \u01eb. Additionally, we remark that \u2016c\u20161 \u2264 \u2016a\u20161, since \u2016b(k)\u20161 = 1 (see Proposition 3.9.1) and \u2211l m=0 ( l m ) = 2l.\nAnalyzing time and space complexity. To evaluate the bounded polynomial approximation f\u03023(x) with \u01eb accuracy, it is necessary to approximate the summand with \u2113-bit precision, where \u2113 = O(log(KLM\u01eb\u22121)) = O(log(\u03b4\u22124\u01eb\u22121)). Since the summand is a product of a constant number of holonomic functions, approximating b (k) l with \u2113-bit precision is sufficient. Other quantities in the summand can be evaluated with the desired accuracy in deterministic time O\u0303(\u2113) and space O(\u2113) as stated in Remark 3.6.\n28In particular, the summand in f\u03023(x) is c (even) m cos(\u03c0xm)+ c (odd) m sin\n( \u03c0x ( m+ 1 2 )) if f is neither even nor odd.\nWe now present a bounded-error randomized algorithm for estimating b (k) l . As b (1) is entry-\nwise non-negative and \u2211l\ni=1 b (1) i < \u2016b(1)\u20161 = 1 following Proposition 3.9.1, we can express the\nrecursive formula in Equation (3.3) as the matrix powering of a sub-stochastic matrix B1:\nBk1 :=   b (1) 1 b (1) 2 \u00b7 \u00b7 \u00b7 b (1) l\u22121 b (1) l 0 b (1) 1 \u00b7 \u00b7 \u00b7 b (1) l\u22122 b (1) l\u22121 ... ... . . . ... ...\n0 0 \u00b7 \u00b7 \u00b7 b(1)1 b (1) 2 0 0 \u00b7 \u00b7 \u00b7 0 b(1)1\n  k =   b (k) 1 b (k) 2 \u00b7 \u00b7 \u00b7 b (k) l\u22121 b (k) l 0 b (k) 1 \u00b7 \u00b7 \u00b7 b (k) l\u22122 b (k) l\u22121 ... ... . . . ... ...\n0 0 \u00b7 \u00b7 \u00b7 b(k)1 b (k) 2 0 0 \u00b7 \u00b7 \u00b7 0 b(k)1\n  := Bk.\nIn addition, we approximate the sub-stochastic matrix B1 by dyadic rationals with \u2113-bit precision, denoted as B\u03021. Utilizing Lemma 2.13, we can compute any entry B\u0302 k 1 [s, t] with a randomized algorithm that runs in O(\u2113k) time and log(l+1) space with acceptance probability B\u0302k1 [s, t]. To evaluate B\u0302 k 1 [s, t] with an additive error of \u01eb, we use the sequential repetitions outlined in Lemma 2.11. Specifically, we repeat the algorithm m = 2\u01eb\u22122 ln(KLM) = O(\u01eb\u22122 log(\u03b4\u22124)) times, and each turn succeeds with probability at least 1 \u2212 1/(3KLM). Note that the number of the evaluation of b\n(k) l for computing f\u03023(x) is O(KLM), and by the union bound, we can\nconclude that the success probability of evaluating all coefficients in c is at least 2/3. Finally, we complete the proof by analyzing the overall computational complexity. It is evident that our algorithm utilizes O(\u2113 + logm) = O(log(\u03b4\u22124\u01eb\u22123)) space because indexing m repetitions requires additional O(logm) bits. Moreover, since there are O(KLM) summands in f\u03023(x), and evaluating b (k) l takes m repetitions with time complexity O(\u2113K) for a single turn, the overall time complexity is O(KLM \u00b7 \u2113K \u00b7 \u01eb\u22122 log(KLM)) = O\u0303(\u03b4\u22125\u01eb\u22122).\nNow we present the proof of Theorem 3.8, which is a space-efficient and randomized algorithm for constructing bounded polynomial approximations of piecewise-smooth functions.\nProof of Theorem 3.8. Our approach is based on Theorem 40 in [vAGGdW20] and Corollary 23 in [GSLW19]. Firstly, we obtain a Fourier approximation f\u0302(x) of the given function f(x) by truncating it using Lemma 3.9. Next, we ensure that f\u0302(x) is negligible outside the interval [\u2212x0 \u2212 r, x0 + r] by multiplying it with a suitable rectangle function, denoted as h(x). Finally, we derive a space-efficient polynomial approximation h\u0302(x) of h(x) by applying Lemma 3.5.\nConstruction of a bounded function. Let us begin by defining a linear transformation L(x) := x\u2212x0r+\u03b4 that maps [x0 \u2212 r \u2212 \u03b4, x0 + r + \u03b4] to [\u22121, 1]. For convenience, we denote g(y) := f(L\u22121(y)) and bl := al(r + \u03b4)l, then it is evident that g(y) := \u2211\u221e l=0 bly\nl for any y \u2208 [\u22121, 1]. To construct a Fourier approximation by Lemma 3.9, we need to bound the truncation error\n\u03b5 (g) J . We define \u03b4 \u2032 := \u03b42(r+\u03b4) and J := \u2308(\u03b4\u2032)\u22121 log(12B\u01eb\u22121)\u2309. This ensures that the truncation error \u03b5\n(g) J := \u2223\u2223g(y) \u2212\u2211J\u22121j=0 bjyj \u2223\u2223 for any y \u2208 [\u22121 + \u03b4\u2032, 1 \u2212 \u03b4\u2032] satisfies the following:\n\u03b5 (g) J =\n\u2223\u2223\u2223 \u221e\u2211\nj=J\nbjy j \u2223\u2223\u2223 \u2264 \u221e\u2211\nj=J\n\u2223\u2223bj(1\u2212 \u03b4\u2032)j \u2223\u2223 \u2264 (1\u2212 \u03b4\u2032)J\n\u221e\u2211\nj=J\n|bj | \u2264 (1\u2212 \u03b4\u2032)JB \u2264 e\u2212\u03b4 \u2032JB \u2264 \u01eb\n12 :=\n\u01eb\u2032 4 .\nAfterward, let b\u0302 := (b0, b1, \u00b7 \u00b7 \u00b7 , bJ\u22121), then we know that \u2016b\u0302\u20161 \u2264 \u2016b\u20161 \u2264 B by the assumption. Now we utilize Lemma 3.9 and obtain the Fourier approximation g\u0302(y):\ng\u0302(y) :=    \u2211M m=\u2212M c (even) m cos(\u03c0ym), if f is even\u2211M m=\u2212M c (odd) m sin ( \u03c0y ( m+ 12 )) , if f is odd\n\u2211M m=\u2212M ( c (even) m cos(\u03c0ym) + c (odd) m sin ( \u03c0y ( m+ 12 ))) , otherwise\n. (3.5)\nBy appropriately choosing M = O ( (\u03b4\u2032)\u22121log ( \u2016b\u0302\u20161/\u01eb\u2032 )) = O ( r\u03b4\u22121log ( B/\u01eb )) , we obtain that the vectors of coefficients c(even) and c(odd) satisfy \u2016c(even)\u20161 \u2264 \u2016b\u0302\u20161 \u2264 \u2016b\u20161 \u2264 B and similarly \u2016c(odd)\u20161 \u2264 B. Plugging f(x) = g(L(x)) into Equation (3.5), we conclude that f\u0302(x) = g\u0302(L(x)) is a Fourier approximation of f with an additive error of \u01eb/3 on the interval [x0\u2212r\u2212\u03b4/2, x0+r+\u03b4/2]:\nf\u0302(x) = g\u0302 (x\u2212x0 r+\u03b4 ) =    M\u2211 m=\u2212M c (even) m cos ( \u03c0m ( x\u2212x0 r+\u03b4 )) , if f is even M\u2211 m=\u2212M c (odd) m sin ( \u03c0 ( m+ 12 )( x\u2212x0 r+\u03b4 )) , if f is odd\nM\u2211 m=\u2212M c (even) m cos ( \u03c0m ( x\u2212x0 r+\u03b4 )) + c (odd) m sin ( \u03c0 ( m+ 12 )( x\u2212x0 r+\u03b4 )) , otherwise\n.\nMaking the error negligible outside the interval. Subsequently, we define the function h(x) = f\u0302(x) \u00b7 R(x) such that it becomes negligible outside the interval of interest, i.e., [x0 \u2212 r \u2212 \u03b4/2, x0 + r + \u03b4/2]. Here, the approximate rectangle function R(x) is \u01eb\u0303-close to 1 on the interval [x0 \u2212 r, x0 + r], and is \u01eb\u0303-close to 0 on the interval [\u22121, 1] \\ [x0 \u2212 r \u2212 2\u03b4\u0303, x0 + r + 2\u03b4\u0303], where \u01eb\u0303 := \u01eb/(3B) and \u03b4\u0303 := \u03b4/4. Moreover, |R(x)| \u2264 1 for any x \u2208 [\u22121, 1]. Similar to Lemma 29 in [GSLW19], R(x) can be expressed as a linear combination of Gaussian error functions:\nR(x) := 12\n[ erf ( \u03ba(x\u2212x0+r+\u03b4\u2032) ) \u2212erf ( \u03ba(x\u2212x0\u2212r\u2212\u03b4\u2032) )] where \u03ba := 2\u03b4\u2032 log 1 2 \u221a 2\u221a \u03c0\u01eb\u2032 = 8\u03b4 log 1 2 \u221a 18B\u221a \u03c0\u01eb . (3.6)\nBounded polynomial approximation with Chebyshev interpolation. We here present an algorithmic, space-efficient, randomized polynomial approximation method using Chebyshev interpolation to approximate the function h(x) := f\u0302(x)\u00b7R(x). As suggested in Proposition 3.8.1, we use an explicit polynomial approximation P\u0302 (x) of the bounded function h(x) of degree d = O(\u03b4\u22121 log(B\u01eb\u22121)) that satisfies the conditions specified in Equation (3.7).\nProposition 3.8.1 (Bounded polynomial approximations based on a local Taylor series, adapted from [GSLW19, Corollary 23]). Let x0 \u2208 [\u22121, 1], r \u2208 (0, 2], \u03b4 \u2208 (0, r] and let f : [\u2212x0\u2212r\u2212\u03b4, x0+ r+\u03b4] \u2192 R and be such that f(x0+x) := \u2211\u221e l=0 alx\nl for all x \u2208 [\u2212r\u2212\u03b4, r+\u03b4]. Suppose B > 0 is such that \u2211\u221e l=0(r + \u03b4) l|al| \u2264 B. Let \u01eb \u2208 ( 0, 12B ] , there is a \u01eb/3-precise Fourier approximation f\u0303(x) of f(x) on the interval [x0\u2212 r+\u03b4/2, x0+r+\u03b4/2], where f\u0302(x) := \u2211M m=\u2212MRe [ c\u0303me \u2212 i\u03c0m 2(r+\u03b4) x0e i\u03c0m 2(r+\u03b4) x ] and \u2016c\u0303\u20161 \u2264 B. We have a time-efficient polynomial P \u2217 \u2208 R[x] of degree O(\u03b4\u22121 log(B\u01eb\u22121)) s.t. \u2016f\u0302(x)R(x)\u2212 P \u2217(x)\u2016[x0\u2212r,x0+r] \u2264 \u01eb,\n\u2016P \u2217(x)\u2016[\u22121,1] \u2264 \u01eb+ \u2016f\u0302(x)R(x)\u2016[x0\u2212r\u2212\u03b4/2,x0+r+\u03b4/2] \u2264 \u01eb+B, \u2016P \u2217(x)\u2016[\u22121,1]\\[x0\u2212r\u2212\u03b4/2,x0+r+\u03b4/2] \u2264 \u01eb.\n(3.7)\nTo utilize Lemma 3.5, we need to bound the second derivative max\u03be\u2208[\u2212\u03c0,0] |F \u2032\u2032k (\u03be)|, where the integrand Fk(cos \u03b8) := cos(k\u03b8)h(cos \u03b8) for any 0 \u2264 k \u2264 d. We will calculate this upper bound directly in Fact 3.8.2, and the proof is deferred to Appendix A.1.3. Fact 3.8.2. Consider the integrand Fk(\u03b8)= \u2211M m=\u2212M cm 2 ( H (+) k,m\u2212H (\u2212) k,m ) for any function f which is either even or odd. If f is even, we have that cm = c (even) m defined in Lemma 3.9, and\nH (\u00b1) k,m(\u03b8) := cos\n( \u03c0m (cos \u03b8 \u2212 x0 r + \u03b4 )) \u00b7 cos(k\u03b8) \u00b7 erf ( \u03ba ( cos \u03b8 \u2212 x0 \u00b1 r \u00b1 \u03b4 4 )) . (3.8)\nLikewise, if f is odd, we know that cm = c (odd) m defined in Lemma 3.9, and\nH (\u00b1) k,m(\u03b8) := sin\n( \u03c0 ( m+ 1\n2 )(cos \u03b8 \u2212 x0 r + \u03b4 )) \u00b7 cos(k\u03b8) \u00b7 erf ( \u03ba ( cos \u03b8 \u2212 x0 \u00b1 r \u00b1 \u03b4 4 )) . (3.9)\nMoreover, the integrand is Fk(\u03b8)= \u2211M\nm=\u2212M ( c (even) m 2 ( H\u0302 (+) k,m\u2212H\u0302 (\u2212) k,m ) + c (odd) m 2 ( H\u0303 (+) k,m\u2212H\u0303 (\u2212) k,m )) when f\nis neither even nor odd, where H\u0302 (\u00b1) k,m and H\u0303 (\u00b1) k,m follow from Equation (3.8) and Equation (3.9),\nrespectively. Regardless of the parity of f , we have that the second derivative F \u2032\u2032k (\u03b8) \u2264 O(Bd3).\nTogether with Fact 3.8.2, we are ready to apply Lemma 3.5 to h(x) = f\u0302(x)R(x), resulting in a degree-d polynomial P (x). Since P (x) is the minimax approximation of P \u2217(x) by Chebyshev interpolation and satisfies Equation (3.7), we can define intervals Iint := [x0 \u2212 r, x0 + r] and Iext := [x0 \u2212 r \u2212 \u03b4/2, x0 + r + \u03b4/2] to obtain:\n\u2016f(x)\u2212 P (x)\u2016Iint \u2264 \u2016f(x)\u2212 h(x)\u2016Iint + \u2016h(x) \u2212 P (x)\u2016Iint \u2264 \u01eb+O(\u01eb log d) = O(\u01eb log d), \u2016P (x)\u2212 0\u2016Iext \u2264 \u2016P (x) \u2212 h(x)\u2016Iext + \u2016h(x)\u2212 0\u2016Iext \u2264 O(\u01eb log d) +O(\u01eb) \u2264 O(\u01eb log d). (3.10) We can achieve the desired error bound by observing that Equation (3.10) implies |P (x)|[\u22121,1] \u2264\nO(\u01eb log d)+ |P (x)|[\u22121,1]\\Iext \u2264 O(\u01eb log d)+B. Moreover, we note that the norm of the coefficient vector c(P ) of the polynomial P (x) is bounded by |c(P )| \u2264 O(Bd) \u00b7 (1 + O(\u01eb log d)) = O(Bd), which follows directly from our utilization of Lemma 3.5.\nAnalyzing time and space complexity. The construction of f\u0302(x) can be implemented in bounded-error randomized time O\u0303((\u03b4\u2032)\u22125\u01eb\u22122B2) and space O(log((\u03b4\u2032)\u22124\u01eb\u22121B)), given that this construction uses Lemma 3.9 with \u03b4\u2032 = \u03b42(r+\u03b4) \u2208 (0, 1 2 ] and \u01eb \u2032 = \u01eb3B . Having f\u0302(x), we can construct a bounded polynomial approximation h\u0302(x) deterministically using Lemma 3.5. This construction can be implemented in deterministic time O\u0303(d2\u01eb\u22121/2B) and space O(log(d4\u01eb\u22121B)) since the integrand Fk(\u03b8) is a product of a constant number of (compositions of) holonomic functions (Remark 3.6). Therefore, our construction can be implemented in bounded-error randomized time O\u0303(max { (\u03b4\u2032)\u22125\u01eb\u22122B2, d2\u01eb\u22121/2B } ) and space O(log(d4(\u03b4\u2032)\u22124\u01eb\u22121B)).\nWith the aid of Theorem 3.8, we can provide a space-efficient polynomial approximation to the normalized logarithmic function utilized in Lemma 11 of [GL20].\nCorollary 3.10 (Space-efficient polynomial approximation to the normalized logarithmic function). Let \u03b2 \u2208 (0, 1] and \u01eb \u2208 (0, 1/2), there is an even polynomial P of degree d \u2264 C\u0303ln\u03b2\u22121 log \u01eb\u22121 where C\u0303ln is a universal constant such that\n\u2200x \u2208 [\u03b2, 1], \u2223\u2223\u2223P (x)\u2212 ln(1/x)2 ln(2/\u03b2) \u2223\u2223\u2223 \u2264 Cln\u01eb log d, where Cln is a universal constant,\n\u2200x \u2208 [\u22121, 1],|P (x)| \u2264 1. Moreover, the coefficient vector c(P ) of P has a norm bounded by \u2016c(P )\u20161 \u2264 C\u0302lnd, where C\u0302ln is another universal constant. In addition, any entry of the coefficient vector c(P ) can be computed in bounded-error randomized time O\u0303(max{\u03b2\u22125\u01eb\u22122, d2\u01eb\u22121/2}) and space O(log(d4\u03b2\u22124\u01eb\u22121)). Without loss of generality, we assume that all constants Cln, C\u0302ln, and C\u0303ln are at least 1.\nProof. Consider the function f(x) := ln(1/x)2 ln(2/\u03b2) . We apply Theorem 3.8 to f(x) by choosing the same parameters as in Lemma 11 of [GL20], specifically \u01eb\u2032 = \u01eb/2, x0 = 1, r = 1 \u2212 \u03b2, \u03b4 = \u03b2/2, and B = 1/2.29 This results in a space-efficient randomized polynomial approximation P\u0303 \u2208 R[x] of degree d = O(\u03b4\u22121 log(\u01eb\u22121B)) \u2264 C\u0303ln\u03b2\u22121 log \u01eb\u22121, where C\u0303ln is a universal constant. By appropriately choosing \u03b7 \u2264 1/2 such that C \u2032ln\u01eb log d = \u03b7/4 for a universal constant C \u2032ln, the approximation guarantees the following inequalities:\n\u2016f(x)\u2212 P\u0303 (x)\u2016[\u03b2,2\u2212\u03b2] \u2264 C \u2032ln\u01eb log d = \u03b74 \u2016P\u0303 (x)\u2016[\u22121,1] \u2264 B + C \u2032ln\u01eb log d \u2264 12 + C \u2032 ln\u01eb log d = 1 2 + \u03b7 4\n\u2016P\u0303 (x)\u2016[\u22121,\u03b2/2] \u2264 C \u2032ln\u01eb log d = \u03b74 . (3.11)\n29As indicated in Lemma 11 of [GL20], since the Taylor series of f(x) at x = 1 is 1 2 ln(2/\u03b2) \u2211\u221e l=1\n(\u22121)lxl\nl , we\nobtain that B = f ( \u03b2 2 \u2212 1 ) = 1 2 ln(2/\u03b2) \u2211\u221e l=1\n(1\u2212\u03b2/2)l\nl = \u2212 1 2 ln(2/\u03b2) \u2211\u221e l=1\n(\u22121)l\u22121\nl (\u03b2/2\u2212 1)l = \u2212 1 2 ln(2/\u03b2) ln \u03b2 2 = 1 2 .\nAdditionally, the coefficient vector c(P\u0303 ) of P\u0303 satisfies that \u2016c(P\u0303 )\u20161 \u2264 O(Bd) \u2264 C\u0302lnd where C\u0302ln is a universal constant. Notice that \u03b4\u2032 = \u03b42(r+\u03b4) = \u03b2/2 2(1\u2212\u03b2+\u03b2/2) = \u03b2 4(1\u2212\u03b2/2) = \u0398(\u03b2), our utilization of Theorem 3.8 yields a bounded-error randomized algorithm that requires O(log(d4(\u03b4\u2032)\u22124\u01eb\u22121B)) = O(log(d4\u03b2\u22124\u01eb\u22121)) space and O\u0303(max{(\u03b4\u2032)\u22125\u01eb\u22122B2, d2\u01eb\u22121/2B}) = O\u0303(max{\u03b2\u22125\u01eb\u22122, d2\u01eb\u22121/2}) time.\nFurthermore, note that the real-valued function f(x) only defines when x > 0, then P\u0303 (x) is not an even polynomial in general. Instead, we consider P (x) := (1 + \u03b7)\u22121(P\u0303 (x) + P\u0303 (\u2212x)) for all x \u2208 [\u22121, 1]. Together with Equation (3.11), we have derived that:\n\u2016f(x)\u2212 P (x)\u2016[\u03b2,1] \u2264 \u2225\u2225f(x)\u2212 11+\u03b7 P\u0303 (x) \u2225\u2225 [\u03b2,1] + \u2225\u2225 1 1+\u03b7 P\u0303 (\u2212x) \u2225\u2225 [\u03b2,1]\n\u2264 \u2225\u2225f(x)\u2212 P\u0303 (x) \u2225\u2225 [\u03b2,1] + \u2225\u2225P\u0303 (x)\u2212 11+\u03b7 P\u0303 (x) \u2225\u2225 [\u03b2,1] + \u2225\u2225 1 1+\u03b7 P\u0303 (\u2212x) \u2225\u2225 [\u03b2,1] \u2264 \u03b74 + \u03b7 1+\u03b7 \u00b7 ( 1 2 + \u03b7 4 ) + 11+\u03b7 \u00b7 \u03b7 4 = \u03b74 + \u03b7 1+\u03b7 \u00b7 1+\u03b7 4 + 1 1+\u03b7 \u00b7 \u03b7 2 \u2264 \u03b7. (3.12)\nHere, the last line owes to the fact that \u03b7 > 0. Consequently, Equation (3.12) implies that \u2016f(x)\u2212 P (x)\u2016[\u03b2,1] \u2264 4C \u2032ln\u01eb log d := Cln\u01eb log d for another universal constant Cln. Notice P (x) is an even polynomial with deg(P ) \u2264 C\u0303ln\u03b2\u22121 log \u01eb\u22121, Equation (3.11) yields that:\n\u2016P (x)\u2016[\u22121,1] = \u2016P (x)\u2016[0,1] \u2264 \u2016 11+\u03b7 P\u0303 (x)\u2016[0,1] + \u2016 11+\u03b7 P\u0303 (x)\u2016[\u22121,0] \u2264 11+\u03b7 \u00b7 1+\u03b7 2 + 1 1+\u03b7 \u00b7 \u03b7 2 \u2264 1. We now complete the proof by noticing \u03b7 \u2264 1/2."
        },
        {
            "heading": "3.2 Applying Chebyshev interpolation to bitstring indexed encodings",
            "text": "Equipped with space-efficient bounded polynomial approximations of piecewise-smooth functions, it suffices to implement Chebyshev interpolation on bitstring indexed encodings, as specified in Theorem 3.11. The proof follows from combining Lemma 3.13 and Lemma 3.14.\nTheorem 3.11 (Chebyshev interpolation applied to bitstring indexed encodings). Let A be an Hermitian matrix acting on s qubits, and let U be a (1, a, \u01eb1)-bitstring indexed encoding of A that acts on s+a qubits. For any degree-d polynomial Pd(x) = c0 2 + \u2211d k=1 ckTk(x) where d \u2264 2O(s(n)) and Tk is the k-th Chebyshev polynomial (of the first kind), equipped with an evaluation oracle Eval that returns c\u0302k with precision \u03b5 := O(\u01eb 2 2/d), then we have a (1, a \u2032, 144d \u221a \u01eb1\u2016c\u201621+36\u01eb2\u2016c\u20161)bitstring indexed encoding V of Pd(A) that acts on s + a \u2032 qubits where a\u2032 := a + \u2308log d\u2309 + 3. This implementation requires O(d2\u2016c\u20161) uses of U , U \u2020, C\u03a0NOT, C\u03a0\u0303NOT, and O(d2\u2016c\u20161) multi-controlled single-qubit gates.30 Moreover, we can compute the description of the resulting quantum circuit in deterministic time O\u0303(d2\u2016c\u20161 log(d/\u01eb2)) and space O(max{s(n), log(d/\u01eb22)})31, also O(d2\u2016c\u20161) oracle calls to Eval with precision \u03b5. Furthermore, our construction straightforwardly extends to any linear (possibly non-Hermitian) operator A by simply replacing Pd(A) with P (SV) d (A) defined in Definition 3.3.\nRemark 3.12 (QSVT implementations of Chebyshev interpolation preserve the parity). As shown in Proposition 3.13.1, we can implement the quantum singular value transformation Tk(A) exactly for any Hermitian matrix that admits a bitstring indexed encoding, because we observe that the rotation angles corresponding to the k-th Chebyshev polynomials are either \u03c0/2 or (1\u2212 k)\u03c0/2, indicating that Tk(0) = 0 for any odd k. We then implement the QSVT corresponding to the Chebyshev interpolation polynomial Pd(x) = \u2211(d\u22121)/2 l=0 c2l+1T2l+1(x), as described in Theorem 3.11, although the actual implementation results in a slightly different polynomial, P\u0302d(x) = \u2211(d\u22121)/2\nl=0 c\u03022l+1T2l+1(x). However, we still have P\u0302d(0) = 0 = Pd(0), indicating that the implementations in Theorem 3.11 preserve the parity.\n30As indicated in Figure 3(c) of [GSLW19] (see also Lemma 19 in [GSLW18]), we replace the single-qubit gates used in Lemma 3.13 with multi-controlled (or \u201cmultiply controlled\u201d) single-qubit gates.\nWe first demonstrate an approach, based on Lemma 3.12 in [MY23], that constructs Chebyshev polynomials of bitstring indexed encodings in a space-efficient manner.\nLemma 3.13 (Chebyshev polynomials applied to bitstring indexed encodings). Let A be a linear operator acting on s qubits, and let U be a (1, a, \u01eb)-bitstring indexed encoding of A that acts on s+ a qubits. Then, for the k-th Chebyshev polynomial (of the first kind) Tk(x) of degree k \u2264 2O(s), there exists a new (1, a+1, 4k\u221a\u01eb)-bitstring indexed encoding V of T (SV)k (A) that acts on s + a + 1 qubits. This implementation requires k uses of U , U \u2020, C\u03a0NOT, C\u03a0\u0303NOT, and k single-qubit gates. Moreover, we can compute the description of the resulting quantum circuit in deterministic time k and space O(s). Furthermore, consider A\u2032 := \u03a0\u0303U\u03a0, where \u03a0\u0303 and \u03a0 are the corresponding orthogonal projectors of the bitstring indexed encoding U . If A and A\u2032 satisfy the conditions \u2016A\u2212A\u2032\u2016+ \u2225\u2225A+A\u2032 2\n\u2225\u22252 \u2264 1 and \u2225\u2225A+A\u2032 2 \u2225\u22252 \u2264 \u03b6, then V is a ( 1, a+ 1, \u221a 2\u221a 1\u2212\u03b6k\u01eb ) -bitstring indexed encoding of T (SV) k (A).\nProof. As specified in Proposition 3.13.1, we first notice that we can derive the sequence of rotation angles corresponding to Chebyshev polynomials Tk(x) by directly factorizing them.\nProposition 3.13.1 (Chebyshev polynomials in quantum signal processing, adapted from Lemma 6 in [GSLW19]). Let Tk \u2208 R[x] be the k-th Chebyshev polynomial (of the first kind). Consider the corresponding sequence of rotation angles \u03a6 \u2208 Rk such that \u03c61 := (1\u2212 k)\u03c0/2, and \u03c6j := \u03c0/2 for all j \u2208 [k] \\ {1}, then we know that \u220fkj=1 [( exp(i\u03c6j) 0\n0 exp(\u2212i\u03c6j)\n)( x \u221a 1\u2212x2\u221a\n1\u2212x2 \u2212x\n)] = ( Tk \u00b7\u00b7 \u00b7 ).\nThen we implement the quantum singular value transformation T (SV) k (A), utilizing an alternating phase modulation (Proposition 3.13.2) with the aforementioned sequence of rotation angles, denoted by V .\nProposition 3.13.2 (QSVT by alternating phase modulation, adapted from Theorem 10 and\nFigure 3 in [GSLW19]). Suppose P \u2208 C[x] is a polynomial, and let \u03a6 \u2208 Rn be the corresponding\nsequence of rotation angles. We can construct P (SV)(\u03a0\u0303U\u03a0) =\n{\n\u03a0\u0303U\u03a6\u03a0, if n is odd\n\u03a0U\u03a6\u03a0, if n is even with a\nsingle ancillary qubit. Moreover, this implementation in [GSLW19, Figure 3] makes k uses of U , U \u2020, C\u03a0NOT, C\u03a0\u0303NOT, and single-qubit gates.\nOwing to the robustness of QSVT (Lemma 22 in [GSLW18], full version of [GSLW19]), we\nhave that \u2225\u2225T (SV)k (U) \u2212 T (SV) k (U \u2032) \u2225\u2225 \u2264 4k \u221a \u2016A\u2212A\u2032\u2016 = 4k\u221a\u01eb, where U \u2032 is a (1, a, 0)-bitstring indexed encoding of A. Moreover, with a tighter bound for A and A\u2032, namely \u2016A \u2212 A\u2032\u2016 +\u2225\u2225A+A\u2032 2 \u2225\u22252 \u2264 1, we can deduce that \u2016T (SV)k (U) \u2212 T (SV) k (U \u2032)\u2016 \u2264 k \u221a 2\u221a 1\u2212\u2016(A+A\u2032)/2\u20162 \u2016A \u2212 A\u2032\u2016 \u2264\n\u221a 2\u221a\n1\u2212\u03b6k\u01eb following [GSLW18, Lemma 23], indicating an improved dependence of \u01eb. Finally, we can compute the description of the resulting quantum circuits in O(log k) = O(s(n)) space and O(k) times because of the implementation specified in Proposition 3.13.2.\nWe then proceed by presenting a linear combination of bitstring indexed encodings, which adapts the LCU technique proposed by Berry, Childs, Cleve, Kothari, and Somma in [BCC+15], and incorporates a space-efficient state preparation operator. We say that Py is an \u01eb-state preparation operator for y if Py|0\u0304\u3009 := \u2211m i=1 \u221a y\u0302i|i\u3009 for some y\u0302 such that \u2016y/\u2016y\u20161 \u2212 y\u0302\u20161 \u2264 \u01eb.\nLemma 3.14 (Linear combinations of bitstring indexed encodings, adapted from Lemma 29 in [GSLW19]). Given a matrix A = \u2211m\u22121 i=0 yiAi such that each linear operator Ai (1 \u2264 i \u2264 m) acts on s qubits with the corresponding (\u2016y\u20161, a, \u01eb1)-bitstring indexed encoding Ui acting on s+a qubits associated with projections \u03a0\u0303i and \u03a0i. Also each yi (1 \u2264 i \u2264 m) can be expressed in O(s(n)) bits with an evaluation oracle Eval that returns y\u0302i with precision \u03b5 := O(\u01eb 2 2/m). Then utilizing an \u01eb2-state preparation operator Py for y acting on O(logm) qubits, and a (s + a +\n\u2308logm\u2309)-qubit unitary W = \u2211m\u22121i=0 |i\u3009\u3008i| \u2297 Ui + ( I \u2212 \u2211m\u22121i=0 |i\u3009\u3008i| ) \u2297 I, we can implement a (\u2016y\u20161, a + \u2308logm\u2309, \u01eb1\u2016y\u201621 + \u01eb2\u2016y\u20161)-bitstring indexed encoding of A acting on s + a + \u2308logm\u2309 qubits with a single use of W , Py, P \u2020 y. In addition, the classical pre-processing can be implemented in deterministic time O\u0303(m2 log(m/\u01eb2)) and space O(log(m/\u01eb 2 2)),\n31 as well as m2 oracle calls to Eval with precision \u03b5. Proof. For the \u01eb2-state preparation operator Py such that Py|0\u0304\u3009 = \u2211m\ni=1\n\u221a y\u0302i|i\u3009, we utilize a\nscheme introduced by Zalka [Zal98] (also independently rediscovered in [GR02] and [KM01]). We make an additional analysis of the required classical computational complexity, and the proof can be found in Appendix A.2.\nProposition 3.14.1 (Space-efficient state preparation, adapted from [Zal98, KM01, GR02]). Given an l-qubit quantum state |\u03c8\u3009 := \u2211mi=1 \u221a y\u0302i|i\u3009, where l = \u2308logm\u2309 and y\u0302i are real amplitudes associated with an evaluation oracle Eval(i, \u03b5) that returns y\u0302i up to accuracy \u03b5 we can prepare |\u03c8\u3009 up to accuracy \u01eb in deterministic time O\u0303(m2 log(m/\u01eb)) and space O(log(m/\u01eb2)), together with m2 evaluation oracle calls with precision \u03b5 := O(\u01eb2/m).\nNow consider the bitstring indexed encoding ( P \u2020y\u2297Is ) W ( Py\u2297Is ) of A acting on s+a+\u2308logm\u2309\nqubits. Let y\u2032i := yi/\u2016y\u20161, then we obtain the implementation error:\u2225\u2225A\u2212 \u2016y\u20161 ( |0\u0304\u3009\u30080\u0304| \u2297 \u03a0\u0303 )( P \u2020y \u2297 Is ) W ( Py \u2297 Is ) (|0\u0304\u3009\u30080\u0304| \u2297\u03a0) \u2225\u2225\n= \u2225\u2225A\u2212 \u2016y\u20161 \u2211m\u22121 i=0 y\u0302i\u03a0\u0303iUi\u03a0i \u2225\u2225 \u2264 \u2225\u2225A\u2212 \u2016y\u20161 \u2211m\u22121 i=0 y \u2032 i\u03a0\u0303iUi\u03a0i \u2225\u2225+ \u2016y\u20161 \u2211m\u22121 i=0 (y \u2032 i \u2212 y\u0302i)\u2016\u03a0\u0303iUi\u03a0i\u2016 \u2264\u2016y\u20161 \u2211m\u22121 i=0 y \u2032 i\u2016Ai \u2212 \u03a0\u0303iUi\u03a0i\u2016+ \u01eb2\u2016y\u20161\n\u2264\u01eb1\u2016y\u201621 + \u01eb2\u2016y\u20161. Here, the third line is due to the triangle inequality, the fourth line owes to Proposition 3.14.1, and the fifth line is because Ui is a (1, a, \u01eb1)-bitstring indexed encoding of Ai for 0 \u2264 i < m.\nTo make the resulting bitstring indexed encoding from Lemma 3.14 with \u03b1 = 1, we need to perform a renormalization procedure to construct a new encoding with the desired \u03b1. We achieve this by extending the proof strategy outlined by Gilyen [Gil19, Page 52] for block-encodings to bitstring indexed encodings. The renormalization procedure is provided in Lemma 3.15, and the complete proof is available in Appendix A.2. Additionally, similar results have been established in [MY23, Lemma 3.10] and [WZ23b, Corollary 2.8].\nLemma 3.15 (Renormalizing bitstring indexed encoding). Let U be an (\u03b1, a, \u01eb)-bitstring indexed encoding of A, where \u03b1 > 1 and 0 < \u01eb < 1, and A is a linear operator acting on s(n) qubits. We can implement a quantum circuit V , serving as a normalization of U , such that V is a (1, a + 2, 36\u01eb)-bitstring indexed encoding of A. This implementation requires O(\u03b1) uses of U , U \u2020, C\u03a0NOT, C\u03a0\u0303NOT, and O(\u03b1) single-qubit gates. Moreover, the description of the resulting quantum circuit can be computed in deterministic time O(\u03b1) and space O(s).\nFinally, we combine Lemma 3.14 and Lemma 3.13 to proceed with the proof of Theorem 3.11.\nProof of Theorem 3.11. By using Lemma 3.13, we have Pd(A) = c0 2 + \u2211d k=1 ckTk(A) where Tk(A)\ncorresponding to a (1, a+1, 4k \u221a \u01eb1)-bitstring indexed encoding Vk. Employing Lemma 3.14, we result in a (\u2016c\u20161, a\u0302, 4k \u221a \u01eb1\u2016c\u201621+\u01eb2\u2016c\u20161)-bitstring indexed encoding V\u0302 where a\u0302 := a+\u2308log d\u2309+1.\nMoreover, by utilizing Lemma 3.15, we obtain a (1, a\u2032, 144k \u221a \u01eb1\u2016c\u201621+36\u01eb2\u2016c\u20161)-bitstring indexed encoding V acts on s+a\u2032 qubits where a\u2032 := a\u0302+2 = a+ \u2308log d\u2309+3. A direct calculation demonstrates that this implementation makes \u2211d k=1 k \u00b7O(\u2016c\u20161) = O(d2\u2016c\u20161) uses of U , U \u2020, C\u03a0NOT,\n31It is noteworthy that we define O\u0303(f) := O(f poly log(f)).\nC\u03a0\u0303NOT, also \u2211d\nk=0 k \u00b7 O(\u2016c\u20161) = O(d2\u2016c\u20161) uses of multi-controlled single-qubit gates. In addition, the descriptions of quantum circuits {Vk}dk=0 can be computed in O(s(n)) space and\u2211d\nk=0 k \u00b7 O(\u2016c\u20161) = O(d2\u2016c\u20161) time. Therefore, the description of the quantum circuit V can be computed in deterministic time max{O\u0303(d2\u2016c\u20161 log(d/\u01eb2)), O(d2\u2016c\u20161)} = O\u0303(d2\u2016c\u20161 log(d/\u01eb2)) and space O(max{s(n), d/\u01eb22}), as well as O(d2\u2016c\u20161) oracle calls to Eval with precision \u03b5.\nFinally, we can extend our construction to any linear operator A by replacing Pd(A) with P (SV) d as defined in Definition 3.3, taking into account that the Chebyshev polynomial (of the first kind) Tk is either an even or an odd function."
        },
        {
            "heading": "3.3 Examples: the sign function and the normalized logarithmic function",
            "text": "In this subsection, we provide explicit examples that illustrate the usage of the space-efficient quantum singular value transformation (QSVT) technique. We define two functions:\nsgn(x) :=    1, x > 0\n\u22121, x < 0 0, x = 0\nand ln\u03b2(x) := ln(1/x)\n2 ln(2/\u03b2) .\nIn particular, the sign function is a bounded function, and we derive the corresponding bitstring indexed encoding with deterministic space-efficient classical pre-processing in Corollary 3.7. On the other hand, the logarithmic function is a piecewise-smooth function that is bounded by 1, and we deduce the corresponding bitstring indexed encoding with randomized space-efficient classical pre-processing in Corollary 3.10.\nCorollary 3.16 (Sign polynomial with space-efficient coefficients applied to bitstring indexed encodings). Let A be an Hermitian matrix that acts on s qubits, where s(n) \u2265 \u2126(log(n)). Let U be a (1, a, \u01eb1)-bitstring indexed encoding of A that acts on s+a qubits. Then, for any d \u2264 2O(s(n)) and \u01eb2 \u2265 2\u2212O(s(n)), we have an ( 1, a+\u2308log d\u2309+3, 144C\u03022sgnd\u01eb 1/2 1 log 2(d)+36C\u0302sgn\u01eb2 log(d)) ) -bitstring indexed encoding V of P sgnd (A), where P sgn d is a space-efficient bounded polynomial approximation of the sign function specified in Corollary 3.7, and C\u0302sgn is a universal constant. This implementation requires O(d2 log d) uses of U , U \u2020, C\u03a0NOT, C\u03a0\u0303NOT, and O(d\n2 log d) multicontrolled single-qubit gates30. Moreover, we can compute the description of V in deterministic time O\u0303(\u01eb\u221212 d\n9/2) and space O(s(n)). Furthermore, our construction straightforwardly extends to any non-Hermitian (but linear) matrix A by simply replacing P sgnd (A) with P (SV) sgn,d(A) defined in the same way as Definition 3.3.\nProof. In Corollary 3.7, we can express P sgnd (x) as c0 2 + \u2211d k=1 ckTk(x), where d = O(\u03b4\n\u22121 log \u01eb\u22121). For all x \u2208 [\u22121, 1]\\[\u2212\u03b4, \u03b4], we have |sgn(x)\u2212P sgnd (x)| \u2264 O(\u01eb log d) := \u01eb2. To implement Eval with precision \u03b5, we can compute the corresponding entry ci of the coefficient vector, which requires O(log(\u03b5\u22121d4)) = O(log(\u01eb\u221222 d 5)) space and O\u0303(\u03b5\u22121/2d2) = O\u0303(\u01eb\u221212 d 5/2) time. Using Theorem 3.11, we can conclude that P sgnd has a ( 1, a\u2032, 144dC2sgn\u01eb 1/2 1 log 2(d) + 36C\u0302sgn\u01eb2 log d ) -bitstring indexed encoding V that acts on s+ a\u2032 qubits, where a\u2032 := a+ \u2308log d\u2309+ 3 and \u2016c\u20161 \u2264 C\u0302sgn log d. Furthermore, the quantum circuit of V makes O(d2 log d) uses of U , U \u2020, C\u03a0NOT, and C\u03a0\u0303NOT as well as O(d 2 log d) multi-controlled single-qubit gates. We note that d \u2264 2O(s(n)) and \u01eb2 \u2265 2\u2212O(s(n)). Moreover, we can compute the description of V in O(s(n)) space since each oracle call to Eval with precision \u03b5 can be computed in O(log(\u01eb\u221222 d\n5)) space. Additionally, the time complexity for computing the description of V is\nmax{O\u0303(d2 log d log(d/\u01eb2)), d2 log d \u00b7 O\u0303(\u01eb\u221212 d5/2)} = O\u0303(\u01eb\u221212 d9/2).\nCorollary 3.17 (Log polynomial with space-efficient coefficients applied to bitstring indexed encodings). Let A be an Hermitian matrix that acts on s qubits, where s(n) \u2265 \u2126(log(n)). Let U be a (1, a, \u01eb1)-bitstring indexed encoding of A that acts on s+a qubits. Then, for any d \u2264 2O(s(n)),\n\u01eb2 \u2265 2\u2212O(s(n)), and \u03b2 \u2265 2\u2212O(s(n)), we have a (1, a+\u2308log d\u2309+3, 144C\u0302ln\u01eb1/21 d3+36C\u0302ln\u01eb2d)-bitstring indexed encoding V of P lnd (A), where P ln d is a space-efficient bounded polynomial approximation of the normalized log function specified in Corollary 3.10, and C\u0302ln is a universal constant. This implementation requires O(d3) uses of U , U \u2020, C\u03a0NOT, C\u03a0\u0303NOT, and O(d\n3) multi-controlled single-qubit gates30. Moreover, we can compute the description of the resulting quantum circuit in bounded-error randomized time O\u0303(max{\u03b2\u22125\u01eb\u221242 d5, \u01eb\u221212 d11/2}) and space O(s(n)).\nProof. In Corollary 3.10, we can express P lnd (x) as c0 2 + \u2211d k=1 ckTk(x), where d = O(\u03b4\n\u22121 log \u01eb\u22121). For any ln\u03b2(x), we have | ln\u03b2(x) \u2212 P lnd (x)| \u2264 O(\u01eb log d) := \u01eb2 for all x \u2208 [\u03b2, 1]. To implement Eval with precision \u03b5, we can compute the corresponding entry ci of the coefficient vector by a bounded-error randomized algorithm. This requires O(log(\u03b5\u22121d4\u03b2\u22124)) = O(log(\u03b2\u22124\u01eb\u221222 d\n5)) space and O\u0303(max{\u03b2\u22125\u03b5\u22122, \u03b5\u22121/2d2}) = O\u0303(max{\u03b2\u22125\u01eb\u221242 d2, \u01eb\u221212 }d5/2) time. Using Theorem 3.11, we conclude that P lnd has a (1, a \u2032, 144C2ln\u01eb 1/2 1 d 3 + 36C\u0302ln\u01eb2d)-bitstring indexed encoding V that acts on s+ a\u2032 qubits, where a\u2032 := a+ \u2308log d\u2309+ 3 and \u2016c\u20161 \u2264 C\u0302lnd. Furthermore, the quantum circuit of V makes O(d3) uses of U , U \u2020, C\u03a0NOT, and C\u03a0\u0303NOT as well as O(d3) multi-controlled single-qubit gates. We note that d \u2264 2O(s(n)), \u01eb2 \u2265 2\u2212O(s(n)), and \u03b2 \u2265 2\u2212O(s(n)). Additionally, we can compute the description of V in O(s(n)) space since each oracle call to Eval with precision \u03b5 can be computed in O(log(\u03b2\u22124\u01eb\u221222 d\n5)) space. The time complexity for computing the description of V is given by:\nmax{O\u0303(d3 log(d/\u01eb2)), d3 \u00b7 O\u0303(max{\u03b2\u22125\u01eb\u221242 d2, \u01eb\u221212 d5/2}) = O\u0303(max{\u03b2\u22125\u01eb\u221242 d5, \u01eb\u221212 d11/2}). (3.13) Finally, to guarantee that the probability that all O(d3) oracle calls to Eval succeed is at least 2/3, we use a (4 ln d)-time sequential repetition of Eval for each oracle call. Together with the Chernoff-Hoeffding bound and the union bound, the resulting randomized algorithm succeeds with probability at least 1\u2212 d3 \u00b7 2 exp(\u22124 ln d) \u2265 2/3. We further note that the time complexity specified in Equation (3.13) only increase by a 4 ln d factor."
        },
        {
            "heading": "3.4 Application: space-efficient error reduction for unitary quantum computations",
            "text": "We provide a unified space-efficient error reduction for unitary quantum computations. In particular, one-sided error scenarios (e.g., RQUL and coRQUL) have been proven in [Wat01], and the two-sided error scenario (e.g., BQUL) has been demonstrated in [FKL +16].\nTheorem 3.18 (Space-efficient error reduction for unitary quantum computations). Let s(n) be a space-constructible function, and let a(n), b(n), and l(n) be deterministic O(s(n)) space computable functions such that a(n) \u2212 b(n) \u2265 2\u2212O(s(n)), we know that for any l(n) \u2264 O(s(n)), there is d := l(n)/max{\u221aa\u2212 \u221a b, \u221a 1\u2212 b\u2212 \u221a 1\u2212 a} such that\nBQUSPACE[s(n), a(n), b(n)] \u2286 BQUSPACE [ s(n) + \u2308log d\u2309+ 1, 1\u2212 2\u2212l(n), 2\u2212l(n) ] .\nFurthermore, for one-sided error scenarios, we have that for any l(n) \u2264 2O(s(n)): RQUSPACE[s(n), a(n)] \u2286 RQUSPACE [ s(n) + \u2308log d0\u2309+ 1, 1\u2212 2\u2212l(n) ] where d0 :=\nl(n)\nmax{\u221aa,1\u2212 \u221a 1\u2212a} ,\ncoRQUSPACE[s(n), b(n)] \u2286 coRQUSPACE [ s(n) + \u2308log d1\u2309+ 1, 2\u2212l(n) ] where d1 :=\nl(n)\nmax{1\u2212 \u221a b, \u221a 1\u2212b} .\nBy choosing s(n) = \u0398(log(n)), we derive error reduction for logarithmic-space quantum computation in a unified approach:\nCorollary 3.19 (Error reduction for BQUL, RQUL, and coRQUL). For deterministic logspace computable functions a(n), b(n), and l(n) satisfying a(n) \u2212 b(n) \u2265 1/poly(n) and l(n) \u2264\nO(log n), we have the following inclusions:\nBQUL[a(n), b(n)] \u2286 BQUL[1\u2212 2\u2212l(n), 2\u2212l(n)], RQUL[a(n)] \u2286 RQUL[1\u2212 2\u2212l(n)],\ncoRQUL[b(n)] \u2286 coRQUL[2\u2212l(n)].\nThe construction specified in Theorem 3.18 crucially relies on Lemma 3.20. And the proof of Lemma 3.20 directly follows from Theorem 20 in [GSLW19], which is deferred to Appendix A.3.\nLemma 3.20 (Space-efficient singular value discrimination). Let 0 \u2264 \u03b1 < \u03b2 \u2264 1 and A := \u03a0\u0303U\u03a0 be a (1, 0, 0)-bitstring indexed encoding where U acts on s qubits and s(n) \u2265 \u2126(log n). Consider an unknown quantum state |\u03c8\u3009, with the promise that it is a right singular vector of A with a singular value either above \u03b1 or below \u03b2. We can distinguish the two cases with error probability at most \u03b5 := O(\u01eb log d) using a degree-d quantum singular value transformation where d = log 1/\u01eb max{\u03b2\u2212\u03b1, \u221a 1\u2212\u03b12\u2212 \u221a 1\u2212\u03b22} . Moreover, we can make the error one-sided if \u03b1 = 0 or \u03b2 = 1. In particular, the implementation requires O(d2 log d) uses of U , U \u2020, C\u03a0NOT, C\u03a0\u0303NOT, and O(d2 log d) multi-controlled single-qubit gates. Also, we can compute the description of the implementation in deterministic time O\u0303(\u03b5\u22121d9/2) and space O(s(n)).\nFinally, we provide the proof of Theorem 3.18, which closely relates to Theorem 38 in [GSLW18] (the full version of [GSLW19]).\nProof of Theorem 3.18. It suffices to amplify the promise gap by QSVT. Note that the probability that a BQUSPACE[s(n)] circuit Cx accepts is Pr[Cx accepts] = \u2016|1\u3009\u30081|outCx|0k+m\u3009\u201622 \u2265 a for yes instances, whereas Pr[Cx accepts ] = \u2016|1\u3009\u30081|outCx|0k+m\u3009\u201622 \u2264 b for no instances. Then consider a (1, 0, 0)-bitstring indexed encoding Mx := \u03a0outCx\u03a0in such that \u2016Mx\u2016 \u2265 \u221a a for\nyes instances while \u2016Mx\u2016 \u2264 \u221a b for no instances, where \u03a0in := |0\u3009 \u30080|\u2297k+m and \u03a0out := |1\u3009\u30081|out \u2297 Im+k\u22121. Since \u2016Mx\u2016 = \u03c3max(Mx) where \u03c3max(Mx) is the largest singular value of Mx, it suffices to distinguish the largest singular value of Mx are either above \u221a a or below \u221a b.\nBy setting \u03b1 := \u221a a, \u03b2 := \u221a b and \u03b5 := 2\u2212l(n), this task is a direct corollary of Lemma 3.20."
        },
        {
            "heading": "4 Space-bounded quantum state testing",
            "text": "We begin by defining the problem of quantum state testing in a space-bounded manner:\nDefinition 4.1 (Space-bounded Quantum State Testing). Given polynomial-size quantum circuits (devices) Q0 and Q1 that act on O(log n) qubits and have a succinct description (the \u201csource code\u201d of devices), with r(n) specified output qubits, where r(n) is a deterministic logspace computable function such that 0 < r(n) \u2264 O(log(n)). Let \u03c1i denote the mixed state obtained by running Qi on the all-zero state |0\u0304\u3009 and tracing out the non-output qubits. We define a space-bounded quantum state testing problem, with respect to a specified distancelike measure, to decide whether \u03c10 and \u03c11 are easily distinguished or almost indistinguishable. Likewise, we also define a space-bounded quantum state certification problem to decide whether \u03c10 and \u03c11 are easily distinguished or exactly indistinguishable.\nWe remark that space-bounded quantum state certification, defined in Definition 4.1, represents a \u201cwhite-box\u201d (log)space-bounded counterpart of quantum state certification [BOW19].\nRemark 4.2 (Lifting to exponential-size instances by succinct encodings). For s(n) space-uniform quantum circuits Q0 and Q1 acting on O(s(n)) qubits, if these circuits admit a succinct encoding,32 namely there is a deterministic O(s(n))-space Turing machine with time complexity\n32For instance, the construction in [FL18, Remark 11], or [PY86,BLT92] in general.\npoly(s(n)) can uniformly generate the corresponding gate sequences, then Definition 4.1 can be extended to any s(n) satisfying \u2126(log n) \u2264 s(n) \u2264 poly(n).33\nNext, we define space-bounded quantum state testing problems, based on Definition 4.1, with respect to four commonplace distance-like measures.\nDefinition 4.3 (Space-bounded Quantum State Distinguishability Problem, GapQSDlog). Consider deterministic logspace computable functions \u03b1(n) and \u03b2(n), satisfying 0 \u2264 \u03b2(n) < \u03b1(n) \u2264 1 and \u03b1(n)\u2212 \u03b2(n) \u2265 1/poly(n). Then the promise is that one of the following holds:\n\u2022 Yes instances: A pair of quantum circuits (Q0, Q1) such that td(\u03c10, \u03c11) \u2265 \u03b1(n); \u2022 No instances: A pair of quantum circuits (Q0, Q1) such that td(\u03c10, \u03c11) \u2264 \u03b2(n).\nMoreover, we also define the certification counterpart of GapQSDlog, referred to as CertQSDlog, given that \u03b2 = 0. Specifically, CertQSDlog[\u03b1(n)] := GapQSDlog[\u03b1(n), 0].\nLikewise, we can define GapQJSlog and GapQHSlog, also the certification version CertQHSlog, in a similar manner to Definition 4.3 by replacing the distance-like measure accordingly:\n\u2022 GapQJSlog[\u03b1(n), \u03b2(n)]: Decide whether QJS2(\u03c10, \u03c11) \u2265 \u03b1(n) or QJS2(\u03c10, \u03c11) \u2264 \u03b2(n);\n\u2022 GapQHSlog[\u03b1(n), \u03b2(n)]: Decide whether HS 2(\u03c10, \u03c11) \u2265 \u03b1(n) or HS2(\u03c10, \u03c11) \u2264 \u03b2(n).\nFurthermore, we use the notation CertQSDlog to indicate the complement of CertQSDlog with respect to the chosen parameter \u03b1(n), and so does CertQHSlog.\nDefinition 4.4 (Space-bounded Quantum Entropy Difference Problem, GapQEDlog). Consider a deterministic logspace computable function g : N \u2192 R+, satisfying g(n) \u2265 1/poly(n). Then the promise is that one of the following cases holds:\n\u2022 Yes instance: A pair of quantum circuits (Q0, Q1) such that S(\u03c10)\u2212 S(\u03c11) \u2265 g(n); \u2022 No instance: A pair of quantum circuits (Q0, Q1) such that S(\u03c11)\u2212 S(\u03c10) \u2265 g(n).\nNovel complete characterizations for space-bounded quantum computation. We now present the main theorems in this section and the paper. Theorem 4.5 establishes the first family of natural coRQUL-complete problems. By relaxing the error requirement from one-sided to twosided, Theorem 4.6 identifies a new family of natural BQL-complete problems on space-bounded quantum state testing.\nTheorem 4.5. The computational hardness of the following (log)space-bounded quantum state certification problems, for any deterministic logspace computable \u03b1(n) \u2265 1/poly(n), is as follows:\n(1) CertQSDlog[\u03b1(n)] is coRQUL-complete;\n(2) CertQHSlog[\u03b1(n)] is coRQUL-complete.\nTheorem 4.6. The computational hardness of the following (log)space-bounded quantum state testing problems, where \u03b1(n) \u2212 \u03b2(n) \u2265 1/poly(n) or g(n) \u2265 1/poly(n) as well as \u03b1(n), \u03b2(n), g(n) can be computed in deterministic logspace, is as follows:\n(1) GapQSDlog[\u03b1(n), \u03b2(n)] is BQL-complete;\n(2) GapQEDlog[g(n)] is BQL-complete;\n(3) GapQJSlog[\u03b1(n), \u03b2(n)] is BQL-complete;\n33It is noteworthy that Definition 4.1 (mostly) coincides with the case of s(n) = \u0398(O(log n)) and directly takes the corresponding gate sequence of Q0 and Q1 as an input.\n(4) GapQHSlog[\u03b1(n), \u03b2(n)] is BQL-complete.\nIt is noteworthy that we can naturally extend Theorem 4.5 and Theorem 4.6 to their exponential-size up-scaling counterparts with 2\u2212O(s(n))-precision, employing the extended version of Definition 4.1 outlined in Remark 4.2, thus achieving the complete characterizations for coRQUSPACE[s(n)] and BQPSPACE[s(n)], respectively.\nIn the remainder of this section, we first address problems with two-sided errors. Specifically, by employing a general framework for space-bounded quantum state testing demonstrated in Section 4.1, we demonstrate the BQL containment of GapQSDlog in Section 4.2, as well as the BQL containment of GapQEDlog and GapQJSlog in Section 4.3. Subsequently, in Section 4.4, we focus on making the error one-sided and establish the coRQUL containment of CertQSDlog and CertQHSlog. Additionally, we show the BQL containment of GapQHSlog in Appendix B. The corresponding hardness proof for all these problems is provided in Section 4.5."
        },
        {
            "heading": "4.1 Space-bounded quantum state testing: a general framework",
            "text": "In this subsection, we introduce a general framework for quantum state testing that utilizes a quantum tester T . Specifically, the space-efficient tester T succeeds (outputting the value \u201c0\u201d) with probability x, which is linearly dependent on some quantity closely related to the distancelike measure of interest. Consequently, we can obtain an additive-error estimation x\u0303 of x with high probability through sequential repetition (Lemma 2.11).\nTo construct T , we combine the one-bit precision phase estimation [Kit95], commonly known as the Hadamard test [AJL09], for block-encodings (Lemma 4.9), with our space-efficient quantum singular value transformation (QSVT) technique, which we describe in Section 3.\nConstructing a space-efficient quantum tester. We now provide a formal definition and the detailed construction of the quantum tester T . The quantum circuit shown in Figure 2 defines the quantum tester T (Q,UA, Pd, \u01eb) using the following parameters with s(n) = \u0398(log n):\n\u2022 A s(n)-qubit quantum circuit Q prepares the purification of an r(n)-qubit quantum state \u03c1 where \u03c1 is the quantum state of interest;\n\u2022 UA is a (1, s\u2212 r, 0)-block-encoding of an r(n)-qubit Hermitian operator A where A relates to the quantum states of interest and r(n) \u2264 s(n);\n\u2022 Pd is a degree-d bounded polynomial with a particular form Pd = c0 2 + \u2211d k=1 ckTk \u2208 R[x]\nwhere Tk is the k-th Chebyshev polynomial, with d \u2264 2O(s(n)), such that the coefficients c := (c0, \u00b7 \u00b7 \u00b7 , cd) can be computed in bounded-error randomized space O(s(n));\n\u2022 \u01eb is the precision parameter used in the estimation of x, with \u01eb \u2265 2\u2212O(s(n)). Moreover, we define the corresponding estimation procedure, denoted as T\u0302 (Q,UA, Pd, \u01eb, \u01ebH , \u03b4),\nnamely a quantum algorithm that computes an additive-error estimation x\u0303 of the output x from\nthe tester T (Q,UA, Pd, \u01eb). Technically speaking, T\u0302 outputs x\u0303 such that |x\u2212 x\u0303| \u2264 \u01eb\u2016c\u20161+\u01ebH with probability at least 1\u2212\u03b4. Now we will demonstrate that both the tester T and the corresponding estimation procedure T\u0302 are space-efficient: Lemma 4.7 (Quantum tester T and estimation procedure T\u0302 are space-efficient). The quantum tester T (Q,UA, Pd, \u01eb), as specified in Figure 2, accepts (outputting the value \u201c0\u201d) with probability 1 2(1 + Re(Tr(Pd(A)\u03c1))) \u00b1 12\u01eb\u2016c\u20161. Moreover, we can compute the quantum circuit description of T in deterministic space O(s + log(1/\u01eb)) given the coefficient vector c of Pd. Furthermore, we can implement the corresponding estimation procedure T\u0302 (Q,UA, Pd, \u01eb, \u01ebH , \u03b4) in bounded-error quantum space O(s+ log(1/\u01eb) + log(1/\u01ebH) + log log(1/\u03b4)).\nWe first provide two useful lemmas for implementing our quantum tester T . It is noteworthy that Lemma 4.8 originates from [LC19], as well as Lemma 4.9 is a specific version of one-bit precision phase estimation (or the Hadamard test) [Kit95,AJL09].\nLemma 4.8 (Purified density matrix, [GSLW19, Lemma 25]). Suppose \u03c1 is an s-qubit density operator and U is an (a + s)-qubit unitary operator such that U |0\u3009\u2297a|0\u3009\u2297s = |\u03c1\u3009 and \u03c1 = Tra(|\u03c1\u3009\u3008\u03c1|). Then, we can construct an O(a+s)-qubit quantum circuit U\u0303 that is an (O(a+s), 0)- block-encoding of \u03c1, using O(1) queries to U and O(a+ s) one- and two-qubit quantum gates.\nLemma 4.9 (Hadamard test for block-encodings, adapted from [GP22, Lemma 9]). Suppose U is an (a + s)-qubit unitary operator that is a block-encoding of s(n)-qubit operator A. We can implement an O(a+ s)-qubit quantum circuit that, on input s(n)-qubit quantum state \u03c1, outputs 0 with probability 1+Re(Tr(A\u03c1))2 .\nFinally, we proceed with the actual proof of Lemma 4.7.\nProof of Lemma 4.7. By applying Chebyshev interpolation on UA (Theorem 3.11 with the choice of \u01eb1 = 0 and \u01eb2 = \u01eb/36), we can implement an O(s(n))-qubit quantum circuit UPd(A) that is a (1, a, 0)-block-encoding of A\u2032Pd using O(d\n2\u2016c\u20161) queries to UA, where a = s \u2212 r + \u2308log d\u2309 + 3 and A\u2032Pd is specified in Theorem 3.11 satisfying \u2016Pd(A) \u2212 A \u2032 Pd \u2016 \u2264 \u01eb\u2016c\u20161. Additionally, we can compute the quantum circuit description of UPd(A) in deterministic space O(s+ log(1/\u01eb)) given the coefficient vector c of Pd. As the quantum tester T (Q,UA, Pd, \u01eb) is mainly based on the Hadamard test, by employing Lemma 4.9, we have that T outputs 0 with probability\nPr[x = 0] = 1\n2\n( 1 + Re(Tr(A\u2032Pd\u03c1)) ) = 1\n2 (1 + Re(Tr(Pd(A)\u03c1))) \u00b1\n1 2 \u01eb\u2016c\u20161.\nIt is left to construct the estimation procedure T\u0302 . As detailed in in Lemma 2.11, we can obtain an estimation x\u0303 by sequentially repeating the quantum tester T (Q,UA, Pd, \u01eb) for O(1/\u01eb2H) times. This repetition ensures that |x\u0303\u2212Re(Tr(A\u2032Pd\u03c1))| \u2264 \u01ebH holds with probability at least \u2126(1), and derives an further implication on Pd(A):\nPr[|x\u0303\u2212 Re(Tr(Pd(A)\u03c1))| \u2264 \u01eb\u2016c\u20161 + \u01ebH ] \u2265 \u2126(1). We thus conclude that construction of the estimation procedure T\u0302 (Q,UA, Pd, \u01eb, \u01ebH , \u03b4) by utilizing O(log(1/\u03b4)/\u01eb2H ) sequential repetitions of T (Q,UA, Pd, \u01eb). Similarly following Lemma 2.11, T\u0302 (Q,UA, Pd, \u01eb, \u01ebH , \u03b4) outputs an estimation x\u0303 satisfies the following condition:\nPr[|x\u0303\u2212 Re(Tr(Pd(A)\u03c1))| \u2264 \u01eb\u2016c\u20161 + \u01ebH ] \u2265 1\u2212 \u03b4. In addition, a direct calculation indicates that we can implement T\u0302 (Q,UA, Pd, \u01eb, \u01ebH , \u03b4) in quantum space O(s+ log(1/\u01eb) + log(1/\u01ebH) + log log(1/\u03b4)) as desired.\n4.2 GapQSDlog is in BQL\nIn this subsection, we demonstrate Theorem 4.10 by constructing a quantum algorithm that incorporates testers T (Qi, U \u03c10\u2212\u03c11\n2 , P sgnd , \u01eb) for i \u2208 {0, 1}, where the construction of testers utilizes the space-efficient QSVT associated with the sign function.\nTheorem 4.10. For any functions \u03b1(n) and \u03b2(n) that can be computed in deterministic logspace and satisfy \u03b1(n)\u2212 \u03b2(n) \u2265 1/poly(n), we have that GapQSDlog[\u03b1(n), \u03b2(n)] is in BQL.\nProof. Inspired by time-efficient algorithms for the low-rank variant of GapQSD [WZ23a], we devise a space-efficient algorithm for GapQSDlog, present formally in Algorithm 1.\nAlgorithm 1: Space-efficient algorithm for GapQSDlog.\nInput : Quantum circuits Qi that prepares the purification of \u03c1i for i \u2208 {0, 1}. Output: An additive-error estimation of td(\u03c10, \u03c11). Params: \u03b5 := \u03b1\u2212\u03b24 , \u03b4 := \u03b5 2r+3 , \u01eb := \u03b5\n2(C\u0302sgn+2Csgn)C\u0303sgn2r+3 \u00b7 1 2 log ( 2(C\u0302sgn+2Csgn)C\u0303sgn2r+3/\u03b5 ) ,\nd := C\u0303sgn\u03b4 \u22121 log \u01eb\u22121, \u03b5H := \u03b54 .\n1. Construct block-encodings of \u03c10 and \u03c11, denoted by U\u03c10 and U\u03c11 , respectively, using O(1) queries to Q0 and Q1 and O(s(n)) ancillary qubits by Lemma 4.8; 2. Construct a block-encoding of \u03c10\u2212\u03c112 , denoted by U\u03c10\u2212\u03c11 2 , using O(1) queries to U\u03c10\nand U\u03c11 and O(s(n)) ancillary qubits by Lemma 3.14;\nLet P sgnd be the degree-d polynomial specified in Corollary 3.7 with parameters \u03b4 and \u01eb such that its Chebyshev coefficients are computable in deterministic space O(log(d/\u01eb));\n3. Set x0 := T\u0302 (Q0, U \u03c10\u2212\u03c11 2 , P sgnd , \u01eb, \u01ebH , 1/10), x1 := T\u0302 (Q1, U \u03c10\u2212\u03c11 2 , P sgnd , \u01eb, \u01ebH , 1/10); 4. Compute x = (x0 \u2212 x1)/2. Return \u201cyes\u201d if x > (\u03b1+ \u03b2)/2, and \u201cno\u201d otherwise.\nLet us demonstrate the correctness of Algorithm 1 and analyze the computational complexity. We focus on the setting with s(n) = \u0398(log n). We set \u03b5 := (\u03b1 \u2212 \u03b2)/4 \u2265 2\u2212O(s) and assume that Q0 and Q1 are s(n)-qubit quantum circuits that prepare the purifications of \u03c10 and \u03c11, respectively. According to Lemma 4.8, we can construct O(s)-qubit quantum circuits U\u03c10 and U\u03c11 that encode \u03c10 and \u03c11 as (1, O(s), 0)-block-encodings, using O(1) queries to Q0 and Q1 as well as O(1) one- and two-qubit quantum gates. Next, we apply Lemma 3.14 to construct a (1, O(s), 0)-block-encoding U \u03c10\u2212\u03c11\n2\nof \u03c10\u2212\u03c112 , using O(1) queries to Q\u03c10 and Q\u03c11 , as well as O(1)\none- and two-qubit quantum gates. Let \u03b4 := \u03b52r+3 , \u01eb := \u03b5 2(C\u0302sgn+2Csgn)C\u0303sgn2r+3 \u00b7 1 2 log ( 2(C\u0302sgn+2Csgn)C\u0303sgn2r+3/\u03b5 ) and d := C\u0303sgn\u03b4\u22121 log \u01eb\u22121 = 2O(s) where C\u0303sgn comes from Corollary 3.7. Let P sgn d \u2208 R[x] be the polynomial specified in Corollary 3.7. Let \u01ebH = \u03b5/4. By employing Corollary 3.16 and the corresponding estimation procedure T\u0302 (Qi, U \u03c10\u2212\u03c11\n2 , P sgnd , \u01eb, \u01ebH , 1/10) from Lemma 4.7, we obtain the values xi for i \u2208 {0, 1}, ensuring the following inequalities:\nPr [\u2223\u2223\u2223\u2223xi \u2212 Tr ( P sgnd ( \u03c10 \u2212 \u03c11\n2\n) \u03c1i )\u2223\u2223\u2223\u2223 \u2264 C\u0302sgn\u01eb log d+ \u01ebH ] \u2265 9\n10 for i \u2208 {0, 1}. (4.1)\nHere, the implementation uses O(d2 log d) queries to U \u03c10\u2212\u03c11 2 and O(d2 log d) multi-controlled single-qubit gates. Moreover, the circuit descriptions of T\u0302 (Qi, U \u03c10\u2212\u03c11 2 , P sgnd , \u01eb, \u01ebH , 1/10) can be computed in deterministic time O\u0303(d9/2/\u01eb) and space O(s).\nNow let x := (x0 \u2212 x1)/2. We will finish the correctness analysis of Algorithm 1 by showing Pr[|x\u2212 td(\u03c10, \u03c11)| \u2264 \u03b5] > 0.8 through Equation (4.1). By considering the approximation error of P sgnd in Corollary 3.7 and the QSVT implementation error in Corollary 3.16, we derive the following inequality in Proposition 4.10.1, and the proof is deferred to Appendix B.1: Proposition 4.10.1. Pr [ |x\u2212 td(\u03c10, \u03c11)| \u2264 C\u0302sgn\u01eb log d+ \u01ebH + 2Csgn\u01eb log d+ 2r+1\u03b4 ] > 0.8.\nConsequently, it is left to show that C\u0302sgn\u01eb log d + \u01ebH + 2Csgn\u01eb log d + 2 r+1\u03b4 \u2264 \u03b5 for the aforementioned choice of \u03b4, \u01eb, and \u01ebH . Note that \u01ebH = \u03b5/4 and 2 r+1\u03b4 = \u03b5/4, we complete the\ncorrectness analysis by choosing \u01eb := \u03b4\u2032/2 log(\u03b4\u2032\u22121) with \u03b4\u2032 := \u03b4/ ( 2(C\u0302sgn + 2Csgn)C\u0303sgn ) \u2264 1/2 and subsequently deriving the following inequality: (C\u0302sgn + 2Csgn)\u01eb log d \u2264 (C\u0302sgn + 2Csgn)\u01eb log(\u03b4\u2032\u22121 log(\u01eb\u22121)) \u2264 (C\u0302sgn + 2Csgn)\u03b4\u2032 \u2264 \u03b5/2. Here, the second inequality results from the fact that \u03b3 log(\u03b5\u22121 log \u03b3\u22121) \u2264 \u03b5 for 0 < \u03b5 \u2264 1/2, with \u03b3 := \u03b5/2 log(\u03b5\u22121), and the last inequality owes to the chosen \u03b4\u2032, along with the facts that \u03b4 := \u01eb/2r+3 \u2264 \u03b5 and C\u0303sgn \u2265 1.\nFinally, we analyze the computational resources required for Algorithm 1. According to Lemma 4.7, we can compute x in BQL, with the resulting algorithm requiring O(d2 log d/\u01eb2H) = O\u0303(22r/\u03b54) queries to Q0 and Q1. In addition, its circuit description can be computed in deterministic time O\u0303(d9/2/\u03b5) = O\u0303(24.5r/\u03b55.5).\n4.3 GapQEDlog and GapQJSlog are in BQL\nIn this subsection, we will demonstrate Theorem 4.11 by devising a quantum algorithm that encompasses testers T (Qi, U\u03c1i , P lnd , \u01eb) for i \u2208 {0, 1}, where the construction of testers employs the space-efficient QSVT associated with the normalized logarithmic function. Consequently, we can deduce that GapQJSlog is in BQL via a reduction from GapQJSlog to GapQEDlog.\nTheorem 4.11. For any deterministic logspace computable function g(n) that satisfies g(n) \u2265 1/poly(n), we have that GapQEDlog[g(n)] is in BQL.\nProof. We begin with a formal algorithm in Algorithm 2.\nAlgorithm 2: Space-efficient algorithm for GapQEDlog.\nInput : Quantum circuits Qi that prepares the purification of \u03c1i for i \u2208 {0, 1}. Output: An additive-error estimation of S(\u03c10)\u2212 S(\u03c11). Params: \u03b5 := g4 , \u03b2 := min{ \u03b52r+5 ln(2r+4/\u03b5) , 1 4}, d := C\u0303ln \u00b7 1\u03b2 log 1\u01eb ,\n\u01eb := \u03b2\u03b5 4C\u0303ln(C\u0302ln+Cln) ln(1/\u03b2) \u00b7 1 4 log ( 4C\u0303ln(C\u0302ln+Cln) ln(1/\u03b2)/(\u03b2\u03b5) ) , \u01ebH := \u03b58 ln(1/\u03b2) .\n1. Construct block-encodings of \u03c10 and \u03c11, denoted by U\u03c10 and U\u03c11 , respectively, using O(1) queries to Q0 and Q1 and O(s(n)) ancillary qubits by Lemma 4.8;\nLet P lnd be the degree-d polynomial specified in Corollary 3.10 with parameters \u03b4 and \u01eb such that its Chebyshev coefficients are computable in bounded-error randomized space O(log(d/\u01eb));\n2. Set x0 := T\u0302 (Q0, U\u03c10 , P lnd , \u01eb, \u01ebH , 1/10), x1 := T\u0302 (Q1, U\u03c11 , P lnd , \u01eb, \u01ebH , 1/10); 3. Compute x = (x0 \u2212 x1) ln(2/\u03b2). Return \u201cyes\u201d if x > 0, and \u201cno\u201d otherwise.\nLet us now demonstrate the correctness and computational complexity of Algorithm 2. We concentrate on the scenario with s(n) = \u0398(log n) and \u03b5 = g/4 \u2265 2\u2212O(s). Our strategy is to estimate the entropy of each of \u03c10 and \u03c11, respectively. We assume that Q0 and Q1 are s-qubit quantum circuits that prepare the purifications of \u03c10 and \u03c11, respectively. By Lemma 4.8, we can construct (1, O(s), 0)-block-encodings U\u03c10 and U\u03c11 of \u03c10 and \u03c11, respectively, using O(1) queries to Q0 and Q1 as well as O(1) one- and two-qubit quantum gates.\nLet \u03b2 = min{ \u03b5 2r+5 ln(2r+4/\u03b5) , 14}, \u01eb := \u03b2\u03b5 4C\u0303ln(C\u0302ln+Cln) ln(1/\u03b2) \u00b7 1 4 log ( 4C\u0303ln(C\u0302ln+Cln) ln(1/\u03b2)/(\u03b2\u03b5) ) and d = C\u0303ln\u03b2 \u22121 log \u01eb\u22121 = 2O(s(n)) where C\u0303ln comes from Corollary 3.10. Let P lnd \u2208 R[x] be the polynomial specified in Corollary 3.10. Let \u01ebH = \u03b5\n8 ln(1/\u03b2) . By utilizing Corollary 3.17 and the\ncorresponding estimation procedure T\u0302 (Qi, U\u03c1i , P lnd , \u01eb, \u01ebH , 1/10) from Lemma 4.7, we obtain the values xi for i \u2208 {0, 1}, ensuring the following inequalities:\nPr [\u2223\u2223\u2223xi \u2212Tr ( P lnd (\u03c1i) \u03c1i )\u2223\u2223\u2223 \u2264 C\u0302ln\u01ebd+ \u01ebH ] \u2265 9\n10 for i \u2208 {0, 1}. (4.2)\nHere, the implementation uses O(d3) queries to U\u03c10 and O(d 3) multi-controlled single-qubit gates. Moreover, the circuit descriptions of T\u0302 (Qi, U\u03c1i , P lnd , \u01eb, \u01ebH , 1/10) can be computed in bounded-error time O\u0303(d9/\u01eb4) and space O(s).\nWe will finish the correctness analysis of Algorithm 2 by demonstrating Pr[|xi \u2212 S(\u03c1i)| \u2264 \u03b5] \u2265 0.9 through Equation (4.2). By considering the approximation error of P lnd in Corollary 3.10 and the QSVT implementation error in Corollary 3.17, we derive the following inequality in Proposition 4.11.1, and the proof is deferred to Appendix B.1:\nProposition 4.11.1. The following inequality holds for i \u2208 {0, 1}:\nPr [ |xi ln ( 2 \u03b2 ) \u2212 S(\u03c1i)| \u2264 2 ln ( 1 \u03b2 )( C\u0302ln\u01ebd+ \u01ebH + Cln\u01eb log d+ 2 r+1\u03b2 ) ] \u2265 910 .\nConsequently, it is left to show that 2 ln ( 1 \u03b2 ) ( C\u0302ln\u01ebd+ \u01ebH + Cln\u01eb log d+ 2 r+1\u03b2 )\n\u2264 \u03b5 for the aforementioned choice of \u03b2, \u01eb, and \u01ebH . Note that 2 ln(1/\u03b2)\u01ebH = \u03b5/4 and 2 ln(1/\u03b2) \u00b7 2r+1\u03b2 \u2264 \u03b5/4, we complete the correctness analysis by choosing \u01eb := \u03b4/4 \u00b7 log(1/\u03b4) with \u03b4 :=\n\u03b2\u03b5 4C\u0303ln(C\u0302ln+Cln) ln(1/\u03b2) \u2264 1/2, and subsequently deriving the following inequality:\n2 ln(\u03b2\u22121)(C\u0302ln\u01ebd+ Cln\u01eb log(d)) \u2264 2 ln(\u03b2\u22121)(C\u0302ln + Cln)\u01ebd = 2 ln(\u03b2\u22121)(C\u0302ln + Cln)C\u0303ln\u03b2 \u22121\u01eb log(\u01eb\u22121)\n\u2264 2 ln(\u03b2\u22121)(C\u0302ln + Cln)C\u0303ln\u03b2\u22121\u03b4 = \u03b5/2.\nHere, the first line is because of log(d) \u2264 d, the third line owes to the fact that \u01eb log(\u01eb\u22121) \u2264 \u03b4, and the last line is due to choice of \u03b4.\nFinally, we analyze the computational resources required for Algorithm 2. As per Lemma 4.7, we can compute x in BQL, with the resulting algorithm requiring O(d3/\u01eb2H) = O\u0303(2\n3r/\u03b54) queries toQ0 andQ1. Furthermore, its circuit description can be computed in bounded-error randomized time O\u0303(d11/\u03b54) = O\u0303(211r/\u03b515).\nGapQJSlog is in BQL. It is noteworthy that we can achieve GapQJSlog \u2208 BQL by employing the estimation procedure T\u0302 in Algorithm 2 for three according states, given that the quantum Jensen-Shannon divergence QJS(\u03c10, \u03c11) is a linear combination of S(\u03c10),S(\u03c11), and S (\u03c10+\u03c11 2 ) . Nevertheless, the log-space Karp reduction from GapQJSlog to GapQEDlog (Corollary 4.12) allows us to utilize T\u0302 for only two states. Furthermore, our construction is adapted from the time-bounded scenario [Liu23, Lemma 4.3].\nCorollary 4.12. For any functions \u03b1(n) and \u03b2(n) that can be computed in deterministic logspace and satisfy \u03b1(n)\u2212 \u03b2(n) \u2265 1/poly(n), we have that GapQJSlog[\u03b1(n), \u03b2(n)] is in BQL.\nProof. Let Q0 and Q1 be the given s(n)-qubit quantum circuits where s(n) = \u0398(log n). Consider a classical-quantum mixed state on a classical register B and a quantum register Y, denoted by \u03c1\u20321 := 1 2 |0\u3009\u30080| \u2297 \u03c10 + 12 |1\u3009\u30081| \u2297 \u03c11, where \u03c10 and \u03c11 are the state obtained by running Q0 and Q1, respectively, and tracing out the non-output qubits. We utilize our reduction to output classicalquantum mixed states \u03c1\u20320 and \u03c1 \u2032 1, which are the output of (s(n) + 2)-qubit quantum circuits Q \u2032 0\nand Q\u20321, 34 respectively, where \u03c1\u20320 := (p0|0\u3009\u30080| + p1|1\u3009\u30081|) \u2297 (12\u03c10 + 12\u03c11) and B\u2032 := (p0, p1) is an independent random bit with entropy H(B\u2032) = 1 \u2212 12 [\u03b1(n) + \u03b2(n)]. Let S2(\u03c1) := S(\u03c1)/ ln 2 for any quantum state \u03c1, we then have derived that:\nS2(\u03c1 \u2032 0)\u2212 S2(\u03c1\u20321) = S2(B\u2032,Y)\u03c1\u20320 \u2212 S2(B,Y)\u03c1\u20321\n= [H(B\u2032) + S2(Y|B\u2032)\u03c1\u20320 ]\u2212 [H(B) + S2(Y|B)\u03c1\u20321 ] = S2(Y)\u03c1\u20320 \u2212 S2(Y|B)\u03c1\u20321 +H(B\n\u2032)\u2212H(B) = S2(Y)\u03c1\u20320 \u2212 S2(Y|B)\u03c1\u20321 \u2212 1 2 [\u03b1(n) + \u03b2(n)] = S2 ( 1 2\u03c10 + 1 2\u03c11 ) \u2212 12 (S2(\u03c10) + S2(\u03c11))\u2212 12 [\u03b1(n) + \u03b2(n)] = QJS2(\u03c10, \u03c11)\u2212 12 [\u03b1(n) + \u03b2(n)].\n(4.3)\nHere, the second line derives from the definition of quantum conditional entropy and acknowledges that both B and B\u2032 are classical registers. The third line owes to the independence of B\u2032 as a random bit. Furthermore, the fifth line relies on the Joint entropy theorem (Lemma 2.3). By plugging Equation (4.3) into the promise of GapQJSlog[\u03b1(n), \u03b2(n)], we can define g(n) := ln 2 2 ( \u03b1(n \u2212 1)\u2212 \u03b2(n\u2212 1) ) and conclude that:\n\u2022 If QJS2(\u03c10, \u03c11) \u2265 \u03b1(n), then S(\u03c1\u20320)\u2212 S(\u03c1\u20321) \u2265 ln 22 ( \u03b1(n)\u2212 \u03b2(n) ) = g(n + 1); \u2022 If QJS2(\u03c10, \u03c11) \u2264 \u03b2(n), then S(\u03c1\u20320)\u2212 S(\u03c1\u20321) \u2264 \u2212 ln 22 ( \u03b1(n)\u2212 \u03b2(n) ) = \u2212g(n+ 1).\nAs \u03c1\u20321 and \u03c1 \u2032 0 are r \u2032(n)-qubit states where r\u2032(n) := r(n)+1, the output length of the corresponding space-bounded quantum circuits Q\u20320 and Q \u2032 1 is r\n\u2032(n). Therefore, GapQJSs(n)[\u03b1(n), \u03b2(n)] is logspace Karp reducible to GapQEDs+1[g(n)] by mapping (Q0, Q1) to (Q \u2032 0, Q \u2032 1).\n4.4 CertQSDlog and CertQHSlog are in coRQUL\nTo make the error one-sided, we adapt the Grover search when the number of solutions is one quarter [BBHT98], also known as the exact amplitude amplification [BHMT02].\nLemma 4.13 (Exact amplitude amplification, adapted from [BHMT02, Equation 8]). Suppose U is a unitary of interest such that U |0\u0304\u3009 = sin(\u03b8)|\u03c80\u3009 + cos(\u03b8)|\u03c81\u3009, where |\u03c80\u3009 and |\u03c81\u3009 are normalized pure states and \u3008\u03c80|\u03c81\u3009 = 0. Let G = \u2212U(I\u22122|0\u0304\u3009\u30080\u0304|)U \u2020(I\u22122|\u03c80\u3009\u3008\u03c80|) be the Grover operator. Then, for every integer j \u2265 0, we have GjU |0\u0304\u3009 = sin((2j+1)\u03b8)|\u03c80\u3009+cos((2j+1)\u03b8)|\u03c81\u3009. In particular, with a single application of G, we obtain GU |0\u0304\u3009 = sin(3\u03b8)|\u03c80\u3009 + cos(3\u03b8)|\u03c81\u3009, signifying that GU |0\u0304\u3009 = |\u03c80\u3009 when sin(\u03b8) = 1/2.\nNotably, when dealing with the unitary of interest with the property specified in Lemma 4.13, which is typically a quantum algorithm with acceptance probability linearly dependent on the chosen distance-like measure (e.g., a tester T from Lemma 4.7), Lemma 4.13 guarantees that the resulting algorithm A accepts with probability exactly 1 for yes instances (\u03c10 = \u03c11). However, achieving A to accept with probability polynomially deviating from 1 for no instances requires additional efforts, leading to the coRQUL containment established through error reduction for coRQUL (Corollary 3.19). In a nutshell, demonstrating coRQUL containment entails satisfying the desired property, which is achieved differently for CertQSDlog and CertQHSlog.\n34To constructQ\u20321, we follow these steps: We start by applying a Hadamard gate on B followed by a CNOTB\u2192R gate where B and R are single-qubit quantum registers initialized on |0\u3009. Next, we apply the controlled-Q1 gate on the qubits from B to S, where S = (Y,Z) is an s(n)-qubit register initialized on |0\u0304\u3009. We then apply X gate on B followed by the controlled-Q0 gate on the qubits from B to S, and we apply X gate on B again. Finally, we obtain \u03c1\u20321 by tracing out R and the qubits in Z. In addition, we can construct Q \u2032 0 similarly.\n4.4.1 CertQSDlog is in coRQUL\nOur algorithm in Theorem 4.14 relies on the quantum tester T (Qi, U \u03c10\u2212\u03c11 2 , P sgnd , \u01eb) specified in Algorithm 1. Note that the exact implementation of the space-efficient QSVT associated with odd polynomials preserves the original point (Remark 3.12). Consequently, T (Qi, U \u03c10\u2212\u03c11\n2\n, P sgnd , \u01eb)\noutputs 0 with probability exactly 1/2 when \u03c10 = \u03c11, enabling us to derive the coRQUL containment through a relatively involved analysis for cases when td(\u03c10, \u03c11) \u2265 \u03b1: Theorem 4.14. For any deterministic logspace computable function \u03b1(n) \u2265 1/poly(n), we have that CertQSDlog[\u03b1(n)] is in coRQUL.\nProof. We first present a formal algorithm in Algorithm 3:\nAlgorithm 3: Space-efficient algorithm for CertQSDlog.\nInput : Quantum circuits Qi that prepares the purification of \u03c1i for i \u2208 {0, 1}. Output: Return \u201cyes\u201d if \u03c10 = \u03c11, and \u201cno\u201d otherwise. Params: \u03b5 := \u03b12 , \u03b4 := \u03b5 2r+3 , \u01eb := \u03b5\n2(C\u0302sgn+2Csgn)C\u0303sgn2r+3 \u00b7 1 2 log ( 2(C\u0302sgn+2Csgn)C\u0303sgn2r+3/\u03b5 ) ,\nd := C\u0303sgn\u03b4 \u22121 log \u01eb\u22121.\n1. Construct block-encodings of \u03c10 and \u03c11, denoted by U\u03c10 and U\u03c11 , respectively, using O(1) queries to Q0 and Q1 and O(s(n)) ancillary qubits by Lemma 4.8; 2. Construct a block-encoding of \u03c10\u2212\u03c112 , denoted by U \u03c10\u2212\u03c11 2 , using O(1) queries to U\u03c10\nand U\u03c11 and O(s(n)) ancillary qubits by Lemma 3.14;\nLet P sgnd be the degree-d odd polynomial specified in Corollary 3.7 with parameters \u03b4 and \u01eb such that its Chebyshev coefficients are computable in deterministic space O(log(d/\u01eb));\n3. Let U0 := T (Q0, U \u03c10\u2212\u03c11 2 , P sgnd , \u01eb) and U1 := T (Q1, U \u03c10\u2212\u03c11 2 , P sgnd , \u01eb); 4. Let Gi := \u2212(H \u2297 Ui)(I \u2212 2|0\u0304\u3009\u30080\u0304|)(H \u2297 U \u2020i )(I \u2212 2\u03a00) for i \u2208 {0, 1}, where \u03a00 is the projector onto the subspace spanned by {|0\u3009|0\u3009|\u03d5\u3009} over all |\u03d5\u3009;\n5. Measure the first two qubits of Gi(H \u2297 Ui)|0\u3009|0\u3009|0\u0304\u3009, and let xi0 and xi1 be the outcomes, respectively. Return \u201cyes\u201d if x00 = x01 = x10 = x11 = 0, and \u201cno\u201d otherwise.\nConstructing the unitary of interest via the space-efficient QSVT. We consider the setting with s(n) = \u0398(log n) and \u03b5 = \u03b1/2. Suppose Q0 and Q1 are s(n)-qubit quantum circuits that prepare the purifications of \u03c10 and \u03c11, respectively. Similar to Algorithm 1, we first construct an O(s)-qubit quantum circuit U \u03c10\u2212\u03c11\n2 that is a (1, O(s), 0)-block-encoding of \u03c10\u2212\u03c112 , using O(1)\nqueries to Q\u03c10 and Q\u03c11 and O(1) one- and two-qubit quantum gates. Let \u03b4 = \u03b52r+3 , \u01eb := \u03b5 2(C\u0302sgn+2Csgn)C\u0303sgn2r+3 \u00b7 1 2 log ( 2(C\u0302sgn+2Csgn)C\u0303sgn2r+3/\u03b5 ) and d := C\u0303sgn\u03b4\u22121 log \u01eb\u22121 = 2O(s) where C\u0303sgn comes from Corollary 3.7. Let P sgn d \u2208 R[x] be the odd polynomial specified in Corollary 3.7. Let Ui := T (Qi, U \u03c10\u2212\u03c11 2\n, P sgnd , \u01eb) for i \u2208 {0, 1}, then we have the following equalities with 0 \u2264 p0, p1 \u2264 1:\nU0|0\u3009|0\u0304\u3009 = \u221a p0|0\u3009|\u03c80\u3009+ \u221a 1\u2212 p0|1\u3009|\u03c81\u3009, U1|0\u3009|0\u0304\u3009 = \u221a p1|0\u3009|\u03c60\u3009+ \u221a 1\u2212 p1|1\u3009|\u03c61\u3009.\nLet H be the Hadamard gate, then we derive the following equality for i \u2208 {0, 1}:\n(H \u2297 Ui)|0\u3009|0\u3009|0\u0304\u3009 = \u221a pi 2 |0\u3009|0\u3009|\u03c80\u3009+ \u221a pi 2 |0\u3009|1\u3009|\u03c80\u3009+ \u221a 1\u2212 pi 2 |1\u3009|0\u3009|\u03c81\u3009+ \u221a 1\u2212 pi 2 |1\u3009|1\u3009|\u03c81\u3009\n\ufe38 \ufe37\ufe37 \ufe38 \u221a\n1\u2212 pi 2 |\u22a5i\u3009\n.\nMaking the error one-sided by exact amplitude amplification. Consider the Grover operator Gi := \u2212(H \u2297 Ui)(I \u2212 2|0\u0304\u3009\u30080\u0304|)(H \u2297 U \u2020i )(I \u2212 2\u03a00), where \u03a00 is the projector onto the subspace spanned by {|0\u3009|0\u3009|\u03d5\u3009} over all |\u03d5\u3009. By employing the exact amplitude amplification (Lemma 4.13), we can obtain that: Gi(H\u2297Ui)|0\u3009|0\u3009|0\u0304\u3009 = sin(3\u03b8i)|0\u3009|0\u3009|\u03c80\u3009+ cos(3\u03b8i)|\u22a5i\u3009 where sin2(\u03b8i)= pi2 when \u03b8i\u2208 [ 0,\u03c04 ] . (4.4) Let xi0 and xi1 be the measurement outcomes of the first two qubits of Gi(H \u2297 Ui)|0\u3009|0\u3009|0\u0304\u3009 for i \u2208 {0, 1}. Algorithm 3 returns \u201cyes\u201d if x00 = x01 = x10 = x11 = 0, and \u201cno\u201d otherwise. We will show the correctness of our algorithm as follows:\n\u2022 For yes instances (\u03c10 = \u03c11), UP sgnd ( \u03c10\u2212\u03c11 2 ) is a (1, O(s), 0)-block-encoding of the zero op-\nerator, following from Remark 3.12. Consequently, T (Qi, U \u03c10\u2212\u03c11 2 , Pd, \u01eb) outputs 0 with probability 1/2 for i \u2208 {0, 1}, i.e., p0 = p1 = 1/2. As a result, we have \u03b80 = \u03b81 = \u03c0/6 and sin2(3\u03b80) = sin\n2(3\u03b81) = 1. Substituting these values into Equation (4.4), we can conclude that x00 = x01 = x10 = x11 = 0 with certainty, which completes the analysis.\n\u2022 For no instances (td(\u03c10, \u03c11) \u2265 \u03b1), UP sgnd ( \u03c10\u2212\u03c11 2 ) is a (1, O(s), 0)-block-encoding of A satis-\nfying \u2225\u2225A\u2212 P sgnd (\u03c10\u2212\u03c11 2 )\u2225\u2225 \u2264 C\u0302sgn\u01eb log d. Let pi be the probability that T (Qi, U \u03c10\u2212\u03c11 2 , Pd, \u01eb)\noutputs 0 for i \u2208 {0, 1}, then pi = 12 ( 1 +Re(Tr(\u03c1iA)) ) following from Lemma 4.7. A direct calculation similar to Proposition 4.10.1 indicates that:\n|(p0 \u2212 p1)\u2212 td(\u03c10, \u03c11)| \u2264 C\u0302sgn\u01eb log d+ 2Csgn\u01eb log d+ 2r+1\u03b4. Under the choice of \u03b4, \u01eb, and d in the proof of Theorem 4.11, we obtain that |(p0 \u2212 p1) \u2212 td(\u03c10, \u03c11)| \u2264 \u03b5 which yields that max{|p0 \u2212 1/2|, |p1 \u2212 1/2|} \u2265 \u03b5/2.35 Note that Pr[xi0 = xi1 = 0] = sin 2(3\u03b8i) for i \u2208 {0, 1}, Algorithm 3 will return \u201cyes\u201d with probability pyes = sin 2(3\u03b80) sin\n2(3\u03b81). We provide an upper bound for pyes in Proposition 4.14.1, with the proof deferred to Appendix B.2:\nProposition 4.14.1. Let f(\u03b80, \u03b81) := sin 2(3\u03b80) sin 2(3\u03b81) be a function such that sin 2(\u03b8i) = pi/2 for i \u2208 {0, 1} and max{|p0 \u2212 1/2|, |p1 \u2212 1/2|} \u2265 \u03b5/2, then f(\u03b80, \u03b81) \u2264 1\u2212 \u03b52/4.\nConsequently, we finish the analysis by noticing pyes = f(\u03b80, \u03b81) \u2264 1\u2212 \u03b52/4 = 1\u2212 \u03b12/16.\nNow we analyze the complexity of Algorithm 3. Following Lemma 4.7, we can compute x00, x01, x10, x11 in BQL. The quantum circuit that computes x00, x01, x10, x11 takes O(d\n2 log d) = O\u0303(22r/\u03b12) queries to Q0 and Q1, and its circuit description can be computed in deterministic time O\u0303(d9/2/\u03b1) = O\u0303(24.5r/\u03b15.5). Finally, we conclude the coRQUL containment of CertQSDlog by applying error reduction for coRQUL(Corollary 3.19) to Algorithm 3.\n4.4.2 CertQHSlog is in coRQUL\nOur algorithm in Theorem 4.15 is based on the observation that by expressing HS2(\u03c10, \u03c11) as a summation of 12Tr(\u03c1 2 0), 1 2Tr(\u03c1 2 1), and \u2212Tr(\u03c10\u03c11), we can devise a hybrid algorithm with two random coins using the SWAP test. However, to ensure unitary, we design another algorithm employing the LCU technique, which serves as the unitary of interest with the desired property.\nTheorem 4.15. For any deterministic logspace computation function \u03b1(n) \u2265 1/poly(n), we have that CertQHSlog[\u03b1(n)] is in coRQUL.\nProof. We first provide a formal algorithm in Algorithm 4.\n35This inequality is because |p0 \u2212 p1| \u2265 td(\u03c10, \u03c11)\u2212 \u03b5 \u2265 2\u03b5\u2212 \u03b5 = \u03b5.\nAlgorithm 4: Space-efficient algorithm for CertQHSlog.\nInput : Quantum circuits Qi that prepares the purification of \u03c1i for i \u2208 {0, 1}. Output: Return \u201cyes\u201d if \u03c10 = \u03c11, and \u201cno\u201d otherwise. 1. Construct subroutines Tij := SWAP(\u03c1i, \u03c1j) for (i, j) \u2208 {(0, 0), (1, 1), (0, 1)}, which output 0 with probability pij. The subroutine SWAP(\u03c1i, \u03c1j) involves applying Qi and Qj to prepare quantum states \u03c1i and \u03c1j, respectively, and then employing the SWAP test (Lemma 2.12) on these states \u03c1i and \u03c1j; 2. Construct a block-encoding of \u033a ( 1 2 + HS2(\u03c10,\u03c11) 4 ) where \u033a(p) := p|0\u3009\u30080| + (1\u2212 p)|1\u3009\u30081|,\ndenoted by U , using O(1) queries to T00, T11, and T01 by Lemma 3.14;\n3. Let G := \u2212U(I \u2212 2|0\u0304\u3009\u30080\u0304|)U \u2020(I \u2212 2|0\u0304\u3009\u30080\u0304|); 4. Measure all qubits of GU |0\u0304\u3009 in the computational basis. Return \u201cyes\u201d if the measurement outcome is an all-zero string, and \u201cno\u201d otherwise.\nConstructing the unitary of interest via the SWAP test. We consider the setting with s(n) = \u0398(s(n)). Our main building block is the circuit implementation of the SWAP test (Lemma 2.12). Specifically, we utilize the subroutine SWAP(\u03c1i, \u03c1j) for i, j \u2208 {0, 1}, which involves applying Qi and Qj to prepare quantum states \u03c1i and \u03c1j , respectively, and then employing the SWAP test on these states \u03c1i and \u03c1j . We denote by pij the probability that SWAP(\u03c1i, \u03c1j) outputs 0 based on the measurement outcome of the control qubit in the SWAP test. Following Lemma 2.12, we have pij = 1 2 ( 1 + Tr(\u03c1i\u03c1j) ) for i, j \u2208 {0, 1}.\nWe define Tij := SWAP(\u03c1i, \u03c1j) for (i, j) \u2208 I := {(0, 0), 1, 1, 0, 1}, with the control qubit in SWAP(\u03c1i, \u03c1j) serving as the output qubit of Tij . By introducing another ancillary qubit, we construct T \u2032ij := CNOT(I \u2297 Tij) for (i, j) \u2208 I , where CNOT is controlled by the output qubit of Tij and targets on the new ancillary qubit. It is effortless to see that T \u2032 ij prepares the purification of \u033a(pij) with \u033a(pij) := pij|0\u3009\u30080| + (1\u2212 pij)|1\u3009\u30081| for (i, j) \u2208 I . By applying Lemma 4.8, we can construct quantum circuits T \u2032\u2032ij for (i, j) \u2208 I that serve as (1, O(s), 0)-block-encoding of \u033a(pij), using O(1) queries to T \u2032 ij and O(1) one- and two-qubit quantum gates. Notably, (X \u2297 I)T \u2032\u203201, with X acting on the qubit of \u033a(p2), prepares the purification of X\u033a(p01)X \u2020 = p01|1\u3009\u30081| + (1\u2212 p01)|0\u3009\u30080| = \u033a(1\u2212 p01), leading to the equality:\n\u033a(\u03c10, \u03c11) := 1\n4 \u033a(p00) +\n1 4 \u033a(p11) + 1 2 \u033a(1\u2212 p01) = \u033a\n( 1\n2 +\nHS2(\u03c10, \u03c11)\n4\n) .\nConsequently, we employ Lemma 3.14 to construct a unitary quantum circuit U that is a\n(1,m, 0)-block-encoding of \u033a ( 1 2 + HS2(\u03c10,\u03c11) 4 ) using O(1) queries to T \u2032\u203200, T \u2032\u2032 11, (X\u2297I)T \u2032\u203201, and O(1) one- and two-qubit quantum gates, where m := O(s). The construction ensures the following:\nU |0\u3009|0\u3009\u2297m = ( 1\n2 +\nHS2(\u03c10, \u03c11)\n4\n)\n\ufe38 \ufe37\ufe37 \ufe38 sin(\u03b8)\n|0\u3009|0\u3009\u2297m + cos(\u03b8)|\u22a5\u3009, where \u30080|\u30080|\u2297m|\u22a5\u3009 = 0. (4.5)\nMaking the error one-sided. Let us consider the Grover operator G := \u2212U(I\u22122|0\u0304\u3009\u30080\u0304|)U \u2020(I\u2212 2|0\u0304\u3009\u30080\u0304|). By applying Lemma 4.13, we derive that GU |0\u3009|0\u3009\u2297m = sin(3\u03b8)|0\u3009|0\u3009\u2297m + cos(3\u03b8)|\u22a5\u3009. Subsequently, we measure all qubits of GU |0\u3009|0\u3009\u2297m in the computational basis, represented as x \u2208 {0, 1}m+1. Hence, Algorithm 4 returns \u201cyes\u201d if the outcome x is 0m+1 and \u201cno\u201d otherwise. Algorithm 4 accepts with probability sin2(3\u03b8). Now we analyze the correctness of the algorithm:\n\u2022 For yes instances (\u03c10 = \u03c11), we have HS 2(\u03c10, \u03c11) = 0. Following Equation (4.5), we obtain\nsin(\u03b8) = 1/2 and thus sin2(3\u03b8) = 1. We conclude that Algorithm 4 will always return \u201cyes\u201d.\n\u2022 For no instances, we have HS2(\u03c10, \u03c11) \u2265 \u03b1. According to Equation (4.5), we derive that:\nsin(\u03b8)= 1 2 + HS2(\u03c10,\u03c11) 4 \u2265 1 2 + \u03b1 4 and 1 4 \u2264 sin2(\u03b8)= (1 2 + HS2(\u03c10,\u03c11) 4 )2 \u2264 (1 2 + 1 4 )2 = 9 16 . (4.6) As a result, considering the fact that sin2(3\u03b8) = f(sin2(\u03b8)) where f(x) := 16x3\u221224x2+9x, we require Proposition 4.15.1 and the proof is deferred to Appendix B.2:\nProposition 4.15.1. The polynomial function f(x) := 16x3 \u2212 24x2 + 9x is monotonically decreasing in [1/4, 9/16]. Moreover, we have f (( 1 2 + \u03b1 4 )2) \u2264 1\u2212 \u03b122 for any 0 \u2264 \u03b1 \u2264 1.\nCombining Equation (4.6) and Proposition 4.15.1, we have that sin2(3\u03b8) = f(sin2(\u03b8)) \u2264 f ((\n1 2 + \u03b1 4 )2) \u2264 1\u2212 \u03b122 . Hence, Algorithm 4 will return \"no\" with probability at least \u03b12/2. Regarding the computational complexity of Algorithm 4, this algorithm requires O(s(n)) qubits and performs O(1) queries to Q0 and Q1. Finally, we finish the proof by applying error reduction from coRQUL (Corollary 3.19) to Algorithm 3.\n4.5 BQL- and coRQUL-hardness for space-bounded state testing problems\nWe will prove that space-bounded state testing problems mentioned in Theorem 4.6 are BQUL-hard, which implies their BQL-hardness since BQL=BQUL [FR21]. Similarly, all spacebounded state certification problems mentioned in Theorem 4.5 are coRQUL-hard.\n4.5.1 Hardness results for GapQSDlog, GapQHSlog, and their certification version\nEmploying analogous constructions, we can establish the BQUL-hardness of both GapQSDlog and GapQHSlog. The former involves a single-qubit pure state and a single-qubit mixed state, while the latter involves two pure states.\nLemma 4.16 (GapQSDlog is BQUL-hard). For any deterministic logspace computable functions a(n) and b(n) such that a(n)\u2212b(n) \u2265 1/poly(n), we have that GapQSDlog[1\u2212 \u221a a(n), \u221a 1\u2212 b(n)] is BQUL[a(n), b(n)]-hard.\nProof. Consider a promise problem (Lyes,Lno) \u2208 BQUL[a(n), b(n)], then we know that the acceptance probability Pr[Cx accepts] \u2265 a(n) if x \u2208 Lyes, whereas Pr[Cx accepts] \u2264 b(n) if x \u2208 Lno. Now we notice that the acceptance probability is the fidelity between a single-qubit pure state \u03c10 and a single-qubit mixed state \u03c11 that generates by two logarithmic-qubit quantum circuits Q0 and Q1, respectively:\nPr[Cx accepts] = \u2016|1\u3009\u30081|outCx|0\u0304\u3009\u201622 =Tr ( |1\u3009\u30081|outTrout ( Cx|0\u0304\u3009\u30080\u0304|C\u2020x ))\n=F2 ( |1\u3009\u30081|out,Trout ( Cx|0\u0304\u3009\u30080\u0304|C\u2020x ))\n:=F2(\u03c10, \u03c11).\n(4.7)\nIn particular, the corresponding Q0 is simply flipping the designated output qubit, as well as the corresponding Q1 is exactly the circuit Cx, then we prepare \u03c10 and \u03c11 by tracing out all non-output qubits. By utilizing Lemma 2.2, we have derived that:\n\u2022 For yes instances, F2(\u03c10, \u03c11) \u2265 a(n) deduces that td(\u03c10, \u03c11) \u2264 1\u2212 \u221a a(n); \u2022 For no instances, F2(\u03c10, \u03c11) \u2264 b(n) yields that td(\u03c10, \u03c11) \u2265 \u221a\n1\u2212 b(n) Therefore, we demonstrate that GapQSDlog[1\u2212 \u221a a(n), \u221a 1\u2212 b(n)] is BQL[a(n), b(n)]-hard.\nTo construct pure states, adapted from the construction in Lemma 4.16, we replace the final measurement in the BQL circuit Cx with a quantum gate (CNOT) and design a new algorithm based on Cx with the final measurement on all qubits in the computational basis.\nLemma 4.17 (GapQHSlog is BQUL-hard). For any deterministic logspace computable functions a(n) and b(n) such that a(n)\u2212 b(n) \u2265 1/poly(n), we have that GapQHSlog[1\u2212a2(n), 1\u2212 b2(n)] is BQUL[a(n), b(n)]-hard.\nProof. For any promise problem (Lyes,Lno) \u2208 BQUL[a(n), b(n)], we have that the acceptance probability Pr[Cx accepts] \u2265 a(n) if x \u2208 Lyes, whereas Pr[Cx accepts] \u2264 b(n) if x \u2208 Lno. For convenience, let the output qubit be the register O. Now we construct a new quantum circuit C \u2032x with an additional ancillary qubit on the register F initialized to zero:\nC \u2032x := C \u2020 xX \u2020 O CNOTO\u2192FXOCx.\nAnd we say that C \u2032x accepts if the measurement outcome of all qubits (namely the working qubit of Cx and F) are all zero. Through a direct calculation, we obtain:\nPr [ C \u2032x accepts ] = \u2225\u2225(|0\u0304\u3009\u30080\u0304| \u2297 |0\u3009\u30080|F)C\u2020xXOCNOTO\u2192FXOCx(|0\u0304\u3009 \u2297 |0\u3009F) \u2225\u22252 2\n= \u2223\u2223(\u30080\u0304| \u2297 \u30080|F)C\u2020x(|1\u3009\u30081|O \u2297 IF + |0\u3009\u30080|O \u2297XF)Cx(|0\u0304\u3009 \u2297 |0\u3009F) \u2223\u22232 = \u2223\u2223\u30080\u0304|C\u2020x|1\u3009\u30081|OCx|0\u0304\u3009 \u2223\u22232 = Pr2 [Cx accepts] .\n(4.8)\nHere, the second line owes to CNOTO\u2192F = |0\u3009\u30080|O \u2297 IF + |1\u3009\u30081|O \u2297 XF, and the last line is because of Equation (4.7). Interestingly, by defining two pure states \u03c10 := |0\u0304\u3009\u30080\u0304| \u2297 |0\u3009\u30080|F and \u03c11 := C \u2032 x(|0\u0304\u3009\u30080\u0304|\u2297 |0\u3009\u30080|F)C \u2032\u2020x corresponding to Q0 = I and Q1 = C \u2032x, respectively, we deduce the following from Equation (4.8):\nPr [ C \u2032x accepts ] = Tr(\u03c10\u03c11) = 1\u2212HS2(\u03c10, \u03c11). (4.9)\nCombining Equation (4.8) and Equation (4.9), we conclude that:\n\u2022 For yes instances, Pr[Cx accepts] \u2265 a(n) implies that HS2(\u03c10, \u03c11) \u2264 1\u2212 a2(n);\n\u2022 For no instances, Pr[Cx accepts] \u2264 b(n) yields that HS2(\u03c10, \u03c11) \u2265 1\u2212 b2(n). We thus complete the proof of GapQHSlog[1\u2212 a2(n), 1 \u2212 b2(n)] is BQUL[a(n), b(n)]-hard.\nOur constructions in the proof of Lemma 4.16 and Lemma 4.17 are somewhat analogous to Theorem 12 and Theorem 13 in [RASW23]. Then we proceed with a few direct corollaries of Lemma 4.16 and Lemma 4.17.\nCorollary 4.18 (BQUL- and coRQUL-hardness). For any functions a(n) and b(n) are computable in deterministic logspace such that a(n) \u2212 b(n) \u2265 1/poly(n), the following holds for some polynomial p(n) which can be computed in deterministic logspace:\n(1) GapQSDlog[\u03b1(n), \u03b2(n)] is BQUL-hard for \u03b1 \u2264 1\u2212 1/p(n) and \u03b2 \u2265 1/p(n);\n(2) CertQSDlog[\u03b3(n)] is coRQUL-hard for \u03b3 \u2264 1\u2212 1/p(n);\n(3) GapQHSlog[\u03b1(n), \u03b2(n)] is BQUL-hard for \u03b1 \u2264 1\u2212 1/p(n) and \u03b2 \u2265 1/p(n);\n(4) CertQHSlog[\u03b3(n)] is coRQUL-hard for \u03b3 \u2264 1\u2212 1/p(n).\nProof. Firstly, it is important to note that BQUL is closed under complement, as demonstrated in [Wat99, Corollary 4.8]. By combining error reduction for BQUL (Corollary 3.19) and Lemma 4.16 (resp., Lemma 4.17), we can derive the first statement (resp., the third statement).\nMoreover, to obtain the second statement (resp., the fourth statement), we can utilize error reduction for coRQUL (Corollary 3.19) and set a = 1 in Lemma 4.16 (resp., Lemma 4.17).\n4.5.2 Hardness results for GapQJSlog and GapQEDlog\nWe demonstrate the BQUL-hardness of GapQJSlog by reducing GapQSDlog to GapQJSlog, following a similar approach as shown in [Liu23, Lemma 4.11].\nLemma 4.19 (GapQJSlog is BQUL-hard). For any functions \u03b1(n) and \u03b2(n) are computable in deterministic logspace, we have GapQJSlog[\u03b1(n), \u03b2(n)] is BQUL-hard for \u03b1(n) \u2264 1\u2212 \u221a 2/ \u221a p(n) and \u03b2(n) \u2265 1/p(n), where p(n) is some deterministic logspace computable polynomial.\nProof. By employing Corollary 4.18, it suffices to reduce GapQSDlog[1 \u2212 1/p(n), 1/p(n)] to GapQJSlog[\u03b1(n), \u03b2(n)]. Consider logarithmic-qubit quantum circuits Q0 and Q1, which is an instance of GapQSDlog. We will obtain \u03c1k by performing Qk on |0n\u3009 and tracing out the non-output qubits for k \u2208 {0, 1}. We then have the following:\n\u2022 If td(\u03c10, \u03c11) \u2265 1\u2212 1/p(n), then Lemma 2.4 yields that\nQJS2(\u03c10, \u03c11) \u2265 1\u2212H2 ( 1\u2212td(\u03c10,\u03c11)\n2\n) \u2265 1\u2212H2 ( 1\n2p(n)\n) \u2265 1\u2212 \u221a 2\u221a\np(n) \u2265 \u03b1(n),\nwhere the third inequality owing to H2(x) \u2264 2 \u221a x for all x \u2208 [0, 1].\n\u2022 If td(\u03c10, \u03c11) \u2264 1/p(n), then Lemma 2.4 indicates that QJS2(\u03c10, \u03c11) \u2264 td(\u03c10, \u03c11) \u2264 1p(n) \u2264 \u03b2(n).\nTherefore, we can utilize the same quantum circuits Q0 and Q1, along with their corresponding quantum states \u03c10 and \u03c11, respectively, to establish a logspace Karp reduction from GapQSDlog[1\u2212 1/p(n), 1/p(n)] to GapQJSlog[\u03b1(n), \u03b2(n)], as required.\nBy combining the reduction from GapQSDlog to GapQJSlog (Lemma 4.19) and the reduction from GapQJSlog to GapQEDlog (Corollary 4.12), we will demonstrate that the BQULhardness for GapQEDlog through reducing GapQSDlog to GapQEDlog.\nCorollary 4.20 (GapQEDlog is BQUL-hard). For any function g(n) are computable in deterministic logspace, we have GapQEDlog[g(n)] is BQUL-hard for g(n) \u2264 ln 22 ( 1\u2212 \u221a 2\u221a p(n\u22121) \u2212 1p(n\u22121) ) , where p(n) is some polynomial that can be computed in deterministic logspace.\nProof. By combining Corollary 4.18 and Lemma 4.19, we establish that GapQJSlog[\u03b1(n), \u03b2(n)]\nis BQUL-hard for \u03b1(n) \u2264 1 \u2212 \u221a 2/ \u221a p(n) and \u03b2(n) \u2265 1/p(n), where p(n) is some deterministic logspace computable polynomial. The hard instances specified in Corollary 4.18 consist of s(n)qubit quantum circuits Q0 and Q1 that prepares a purification of r(n)-qubit (mixed) quantum states \u03c10 and \u03c11, respectively, where 1 \u2264 r(n) \u2264 s(n) = \u0398(log n).\nSubsequently, by employing Corollary 4.12, we construct (s + 1)-qubit quantum circuits Q\u20320 and Q \u2032 1 that prepares a purification of (r + 1)-qubit quantum states \u03c1 \u2032 0 = ( p|0\u3009\u30080| + (1 \u2212\np)|1\u3009\u30081| ) \u2297(12\u03c10+ 12\u03c11) satisfying H2(p) = 1\u2212 12 ( \u03b1(n)+\u03b2(n) ) and \u03c1\u20321 = 1 2 |0\u3009\u30080|\u2297\u03c10+ 12 |1\u3009\u30081|\u2297\u03c11, respectively. Following Corollary 4.12, GapQEDlog[g(n)] is BQUL-hard as long as\ng(n) = ln 22 ( \u03b1(n\u2212 1)\u2212 \u03b2(n\u2212 1) ) \u2264 ln 22 ( 1\u2212 \u221a 2\u221a p(n\u22121) \u2212 1p(n\u22121) ) .\nTherefore, GapQSDs(n)[\u03b1(n), \u03b2(n)] is logspace Karp reducible to GapQEDs+1[g(n)] by mapping (Q0, Q1) to (Q \u2032 0, Q \u2032 1)."
        },
        {
            "heading": "Acknowledgments",
            "text": "This work was partially supported by MEXT Q-LEAP grant No. JPMXS0120319794. FLG was also supported by JSPS KAKENHI grants Nos. JP19H04066, JP20H05966, JP20H00579, JP20H04139, and JP21H04879. YL was also supported by JST, the establishment of University\nfellowships towards the creation of science technology innovation, Grant No. JPMJFS2125. We express our gratitude to anonymous reviewers for providing detailed suggestions on the spaceefficient quantum singular value transformation and for suggesting to add discussion on spacebounded distribution testing. Circuit diagrams were drawn by the Quantikz package [Kay18]."
        },
        {
            "heading": "A Omitted proofs in space-efficient QSVT",
            "text": "In this section, we will present all Omitted proofs in Section 3.\nA.1 Space-efficient bounded polynomial approximations\nA.1.1 Omitted proofs in Corollary 3.7\nFact 3.7.2. Let Fk(\u03b8) := erf(\u03ba cos \u03b8) cos(k\u03b8), max 0\u2264k\u2264d max \u03be\u2208[\u2212\u03c0,0]\n|F \u2032\u2032k (\u03be)| \u2264 2\u221a\u03c0\u03ba+k 2+ 4\u221a \u03c0 \u03ba3+ 4\u221a \u03c0 k\u03ba.\nProof. Through a straightforward calculation, we have derived that\n|F \u2032\u2032k (\u03b8)| = 2\u221a \u03c0\n\u2223\u2223\u03ba exp(\u2212\u03ba2 cos2 \u03b8) cos \u03b8 cos(\u03ba\u03b8) \u2223\u2223+ \u2223\u2223k2 cos(k\u03b8) erf(\u03ba cos(\u03b8)) \u2223\u2223\n+ 4\u221a \u03c0\n\u2223\u2223\u03ba3 exp(\u2212\u03ba2 cos2 \u03b8) cos \u03b8 cos(k\u03b8) sin2 \u03b8 \u2223\u2223\n+ 4\u221a \u03c0\n\u2223\u2223k\u03ba exp(\u2212\u03ba2 cos2 \u03b8) sin \u03b8 sin(k\u03b8) \u2223\u2223\n\u2264 2\u221a \u03c0 \u03ba+ k2 + 4\u221a \u03c0 \u03ba3 + 4\u221a \u03c0 k\u03ba.\n(A.1)\nHere the last line owes to the facts that | erf(x)| \u2264 1, exp(\u2212x2) \u2264 1, | sinx| \u2264 1, and | cos x| \u2264 1 for any x. We thus complete the proof by noting that Equation (A.1) holds for any 0 \u2264 k \u2264 d.\nFact 3.7.3 (Implicit in [MY23, Lemma 2.10]). For the coefficient vector c\u0303sgn corresponding to a degree-d polynomial P\u0303 sgnd , we have \u2016c\u0303sgn\u20161 \u2264 C\u0302sgn log d where C\u0302sgn is a universal constant. Proof. Consider c\u2032k := \u3008Tk, sgn\u3009, and a direct integration yields c\u2032k = (\u22121)(k\u22121)/2 4\u03c0k for odd k which implies that \u2016c\u2032\u20161 = \u22112l\u2264d+1 l=1 |c\u20322l\u22121| = O(log d), as per the Euler\u2013Maclaurin formula. By observing that | erf(\u03bax) \u2212 sgn(x)| \u2264 1 on the interval [\u2212\u03b4, \u03b4], and | erf(\u03bax) \u2212 sgn(x)| \u2264 \u01eb elsewhere, it follows that |c\u0303k \u2212 c\u2032k| \u2264 O(max{\u03b4, \u01eb}). This observation leads us to the conclusion that |\u2016c\u0303\u20161 \u2212 \u2016c\u2032\u20161| \u2264 O(dmax{\u03b4, \u01eb}), which implies that \u2016c\u0303\u20161 \u2264 C\u0302sgn log d for some universal constant C\u0302sgn.\nA.1.2 Omitted proofs in Lemma 3.9 Proposition 3.9.1 (First approximation). Let f\u03021(x) := \u2211K k=0 akx k such that \u2016f \u2212 f\u03021\u2016\u221e \u2264 \u01eb/4. Then we know that f\u03021(x) = \u2211K k=0 ak \u2211\u221e l=0 b (k) l sin l ( x\u03c0 2 ) where the coefficients b (k) l satisfy that\nb (k+1) l =\nl\u2211\nl\u2032=0\nb (k) l\u2032 b (1) l\u2212l\u2032 where b (1) l = { 0 if l is even,(l\u22121\nl\u22121 2\n) 2\u2212l+1\nl \u00b7 2\u03c0 if l is odd. (3.3)\nFurthermore, the coefficients {b(k)l } satisfies the following: (1) \u2016b(k)\u20161 = 1 for all k \u2265 1; (2) b(k) is entry-wise non-negative for all k \u2265 1; (3) b(k)l = 0 if l and k have different parities.\nProof. We construct a Fourier series by a linear combination of the power of sines. We first note that x = 2\u03c0 \u00b7 arcsin ( sin ( x\u03c0 2 )) for all x \u2208 [\u22121, 1], and plug it into f\u03021(x) := \u2211K k=0 akx k, which\ndeduces that \u2016f \u2212 f\u03021\u2016 \u2264 \u01eb/4 by the assumption. Let b(k) be the coefficients of ( arcsin y \u03c0/2 )k = \u2211\u221e l=0 b (k) l y\nl for all y \u2208 [\u22121, 1], then we result in our first approximation. Moreover, we observe that \u03c02 \u00b7b(1) is exactly the Taylor series of arcsin, whereas we know that ( arcsin y \u03c0/2 )k+1 = ( arcsin y \u03c0/2 )k \u00b7 (\u2211\u221e l=0 b (1) l y l ) for k > 1, which derives Equation (3.3) by comparing the coefficients. In addition, notice that \u2016b(k)\u20161 = \u2211\u221e l=0 b (k) l 1 l = ( arcsin 1 \u03c0/2 )k = 1, together with straightforward reasoning follows from Equation (3.3), we deduce the desired property for {b(k)l }. Proposition 3.9.2 (Second approximation). Let f\u03022(x) := \u2211K k=0 ak \u2211L l=0 b (k) l sin l ( x\u03c0 2 ) where L := \u2308\u03b4\u22122 ln(4\u2016a\u20161\u01eb\u22121)\u2309, then we have that \u2016f\u03021 \u2212 f\u03022\u2016\u221e \u2264 \u01eb/4.\nProof. We truncate the summation over l in f1(x) at l = L, and it suffices to bound the truncation error. For all k \u2208 N and x \u2208 [\u22121 + \u03b4, 1 \u2212 \u03b4], we obtain the error bound: \u2223\u2223\u2223\u2223\u2223 \u221e\u2211\nl=\u230aL\u230b b (k) l sin\nl ( x\u03c0 2 ) \u2223\u2223\u2223\u2223\u2223\u2264 \u221e\u2211\nl=\u230aL\u230b b (k) l\n\u2223\u2223\u2223 sinl ( x\u03c0 2 ) \u2223\u2223\u2223\u2264 \u221e\u2211\nl=\u230aL\u230b b (k) l |1\u2212 \u03b42|l \u2264 (1\u2212 \u03b42)L\n\u221e\u2211\nl=\u230aL\u230b b (k) l \u2264 (1\u2212 \u03b42)L.\nHere, the second inequality owing to \u2200\u03b4 \u2208 [0, 1], sin ( (1\u2212 \u03b4)\u03c02 ) \u2264 1\u2212 \u03b42, and the last inequality is due to\u2016b(k)\u20161 = 1 in Proposition 3.9.1. By appropriately choosing L := \u03b4\u22122 ln(4\u2016a\u20161\u01eb\u22121), we obtain that \u2016f\u03021 \u2212 f\u03022\u2016\u221e \u2264 \u2211K k=0 ak(1\u2212 \u03b42)L \u2264 \u2016a\u20161 \u00b7 exp(\u2212\u03b42L) \u2264 \u01eb/4.\nProposition 3.9.3 (Third approximation). Let f\u03023(x) be polynomial approximations of f that depends on the parity of f such that \u2016f\u03022\u2212f\u03023\u2016\u2264\u01eb/2 and M=\u230a\u03b4\u22121 ln(4\u2016a\u20161\u01eb\u22121)\u230b, then we have\nf\u0302 (even) 3 (x) := K\u2211 k=0 ak L/2\u2211\nl\u0302=0\n(\u22121)l\u03022\u22122l\u0302b(k) 2l\u0302\nl\u0302+M\u2211\nm\u2032=l\u0302\u2212M (\u22121)m\u2032\n( 2l\u0302 m\u2032 ) cos(\u03c0x(m\u2032 \u2212 l\u0302)),\nf\u0302 (odd) 3 (x) := K\u2211 k=0 ak (L\u22121)/2\u2211\nl\u0302=0\n(\u22121)l\u0302+12\u22122l\u0302\u22121b(k) 2l\u0302+1\nl\u0302+1+M\u2211\nm\u2032=l\u0302+1\u2212M (\u22121)m\u2032\n( 2l\u0302+1 m\u2032 ) sin ( \u03c0x ( m\u2032 \u2212 l\u0302 \u2212 12 )) .\nTherefore, we have that f\u03023(x) := f\u0302 (even) 3 (x) if f is even, whereas f\u03023(x) := f\u0302 (odd) 3 (x) if f is odd. In addition, if f is neither even or odd, then f\u03023(x) := f\u0302 (even) 3 (x) + f\u0302 (odd) 3 (x).\nProof. We upper-bound sinl(x) in f\u03022(x) defined in Proposition 3.9.2 using a tail bound of binomial coefficients. We obtain that sinl(z) = ( e\u2212iz\u2212eiz \u22122i )l = ( i 2 )l \u2211l m=0 exp(iz(2m \u2212 l)) by a direct calculation, which implies the counterpart for real-valued functions:\nsinl(z) =\n{ 2\u2212l(\u22121)(l+1)/2 \u2211l m\u2032=0(\u22121)m \u2032( l m\u2032 ) sin(z(2m\u2032 \u2212 l)), if l is odd;\n2\u2212l(\u22121)l/2 \u2211lm\u2032=0(\u22121)m \u2032( l m\u2032 ) cos(z(2m\u2032 \u2212 l)), if l is even.\n(A.2)\nRecall that the Chernoff bound (e.g., Corollary A.1.7 [AS16]) which corresponds a tail bound of binomial coefficients, and assume that l \u2264 L, we have derived that:\n\u230al/2\u230b\u2212M\u2211\nm\u2032=0\n2\u2212l ( l\nm\u2032\n) =\nl\u2211\nm\u2032=\u2308l/2\u2309+M 2\u2212l\n( l\nm\u2032\n) \u2264 e\u2212 2M 2 l \u2264 e\u2212 2M 2 L \u2264 ( \u01eb 4\u2016a\u20161 )2 \u2264 \u01eb 4\u2016a\u20161 . (A.3)\nHere, we choose M = \u2308\u03b4\u22121 ln(4\u2016a\u20161\u01eb\u22121)\u2309, and the last inequality is because of the assumption \u01eb \u2264 2\u2016a\u20161. As stated in Proposition 3.9.1, b(k)l = 0 if k and l have different parities. Consequently, we only need to consider all odd (resp., even) l \u2264 L for odd (resp., even) functions. If the function f is neither even nor odd, we must consider all l \u2264 L. Plugging Equation A.3 into Equation A.2, we can derive that:\nIf l is odd, \u2225\u2225\u2225 sinl(z) \u2212 2\u2212l(\u22121)(l+1)/2 (l+1)/2+M\u2211\nm\u2032=(l+1)/2\u2212M (\u22121)m\u2032\n( l m\u2032 ) sin(z(2m\u2032 \u2212 l)) \u2225\u2225\u2225 \u221e \u2264 \u01eb 2\u2016a\u20161 ;\nIf l is even, \u2225\u2225\u2225 sinl(z)\u2212 2\u2212l(\u22121)l/2 l/2+M\u2211\nm\u2032=l/2\u2212M (\u22121)m\u2032\n( l m\u2032 ) cos(z(2m\u2032 \u2212 l)) \u2225\u2225\u2225 \u221e \u2264 \u01eb 2\u2016a\u20161 ;\n(A.4)\nPlugging Equation (A.4) into f\u03022(x), and substituting z = x\u03c0/2, this equation leads to\nf\u03023(x) as desired. In addition, combining \u2211K k=0 |ak| \u2211\u230aL\u230b l=0 |b (k) l | \u2264 \u2211K k=0 |ak| = \u2016a\u20161 with Equation (A.4), we achieve that \u2016f\u03022 \u2212 f\u03023\u2016\u221e \u2264 \u01eb/2.\nA.1.3 Omitted proof in Theorem 3.8 Fact 3.8.2. Consider the integrand Fk(\u03b8)= \u2211M m=\u2212M cm 2 ( H (+) k,m\u2212H (\u2212) k,m ) for any function f which is either even or odd. If f is even, we have that cm = c (even) m defined in Lemma 3.9, and\nH (\u00b1) k,m(\u03b8) := cos\n( \u03c0m (cos \u03b8 \u2212 x0 r + \u03b4 )) \u00b7 cos(k\u03b8) \u00b7 erf ( \u03ba ( cos \u03b8 \u2212 x0 \u00b1 r \u00b1 \u03b4 4 )) . (3.8)\nLikewise, if f is odd, we know that cm = c (odd) m defined in Lemma 3.9, and\nH (\u00b1) k,m(\u03b8) := sin\n( \u03c0 ( m+ 1\n2 )(cos \u03b8 \u2212 x0 r + \u03b4 )) \u00b7 cos(k\u03b8) \u00b7 erf ( \u03ba ( cos \u03b8 \u2212 x0 \u00b1 r \u00b1 \u03b4 4 )) . (3.9)\nMoreover, the integrand is Fk(\u03b8)= \u2211M\nm=\u2212M ( c (even) m 2 ( H\u0302 (+) k,m\u2212H\u0302 (\u2212) k,m ) + c (odd) m 2 ( H\u0303 (+) k,m\u2212H\u0303 (\u2212) k,m )) when f\nis neither even nor odd, where H\u0302 (\u00b1) k,m and H\u0303 (\u00b1) k,m follow from Equation (3.8) and Equation (3.9), respectively. Regardless of the parity of f , we have that the second derivative F \u2032\u2032k (\u03b8) \u2264 O(Bd3).\nProof. We begin by deriving an upper bound of the second derivative of the integrand Fk(\u03b8):\n|F \u2032\u2032k (\u03b8)|\u2264 M\u2211\nm=\u2212M\ncm 2 \u2223\u2223\u2223 d2d\u03b82H (+) k,m(\u03b8)\u2212 d 2 d\u03b82H (\u2212) k,m(\u03b8) \u2223\u2223\u2223\u2264 \u2016c\u20162 max\u2212\u03c0\u2264\u03b8\u22640 (\u2223\u2223\u2223 d2d\u03b82H (+) k,m(\u03b8) \u2223\u2223\u2223+ \u2223\u2223\u2223 d2d\u03b82H (\u2212) k,m(\u03b8) \u2223\u2223\u2223 ) . (A.5)\nBy a straightforward calculation, we have the second derivatives of H\u00b1k,m(\u03b8) if f is even:\nd2\nd\u03b82 H (\u00b1) k,m(\u03b8)=\u2212 k2 cos(k\u03b8) cos (\u03c0m(cos \u03b8\u2212x0) \u03b4+r ) erf ( \u03ba ( cos \u03b8 \u2212 x0 \u2213 r \u2213 \u03b44 ))\n\u2212 \u03c02m2 (\u03b4+r)2\nsin2(\u03b8) cos(k\u03b8) cos (\u03c0m(cos \u03b8\u2212x0)\n\u03b4+r\n) erf ( \u03ba ( cos \u03b8 \u2212 x0 \u2213 r \u2213 \u03b44 ))\n+ \u03c0m\u03b4+r cos \u03b8 cos(k\u03b8) sin (\u03c0m(cos \u03b8\u2212x0) \u03b4+r ) erf ( \u03ba ( cos \u03b8 \u2212 x0 \u2213 r \u2213 \u03b44 )) \u2212 2\u03c0km\u03b4+r sin(\u03b8) sin(k\u03b8) sin (\u03c0m(cos \u03b8\u2212x0) \u03b4+r ) erf ( \u03ba ( cos \u03b8 \u2212 x0 \u2213 r \u2213 \u03b44 ))\n\u2212 2\u03ba\u221a \u03c0 cos \u03b8 cos(k\u03b8) cos (\u03c0m(cos \u03b8\u2212x0) \u03b4+r ) e\u2212\u03ba\n2 ( cos \u03b8\u2212x0\u2213r\u2213 \u03b44 )2\n\u2212 4 \u221a \u03c0\u03bam\n\u03b4+r sin 2(\u03b8) cos(k\u03b8) sin (\u03c0m(cos \u03b8\u2212x0) \u03b4+r ) e\u2212\u03ba\n2 ( cos \u03b8\u2212x0\u2213r\u2213 \u03b44 )2\n+ 4\u03bak\u221a \u03c0 sin(\u03b8) sin(k\u03b8) cos (\u03c0m(cos \u03b8\u2212x0) \u03b4+r ) e\u2212\u03ba\n2 ( cos \u03b8\u2212x0\u2213r\u2213 \u03b44 )2\n\u2212 4\u03ba3\u221a \u03c0 sin2(\u03b8) cos(k\u03b8) cos (\u03c0m(cos \u03b8\u2212x0) \u03b4+r )( cos \u03b8 \u2212 x0 \u2213 r \u2213 \u03b4\n4\n) e\u2212\u03ba 2 ( cos \u03b8\u2212x0\u2213r\u2213 \u03b44 )2 .\nNote that all functions appear in d 2\nd\u03b82 H (\u00b1) k,m(\u03b8), viz. sinx, cos x, exp(\u2212x2), and erf(x), are at\nmost 1, as well as |x0 \u00b1 r \u00b1 \u03b4/4| \u2264 7/2, then we obtain that \u2223\u2223 d2 d\u03b82 H (\u00b1) k,m(\u03b8) \u2223\u2223 \u2264 k2 + 2\u03ba\u221a \u03c0 + 4\u03bak\u221a \u03c0 + 18\u03ba 3\u221a \u03c0 +m \u00b7 ( \u03c0 \u03b4+r + 2\u03c0k \u03b4+r + 4 \u221a \u03c0\u03ba \u03b4+r ) +m2 \u00b7 \u03c02 (\u03b4+r)2\n\u2264 d2 +O(d) +O(d2) +O(d3) + M\u03b4+r \u00b7 (O(1) +O(d) +O(d)) +M 2 \u00b7 O(1) (\u03b4+r)2 = O(d3). (A.6)\nHere, the second line according to k \u2264 d and \u03ba \u2264 O(d), also the last line is due to facts that M \u2264 O(rd) and 1/2 \u2264 r/(\u03b4 + r) \u2264 1 if 0 < \u03b4 \u2264 r and 0 < r \u2264 2. Additionally, a similar argument shows that the upper bound in Equation (A.6) applies to odd functions and functions that are neither even nor odd as well. This is because a direct computation yields the second\nderivatives of H (\u00b1) k,m(\u03b8) when f is odd:\nd2\nd\u03b82 H (\u00b1) k,m(\u03b8)=\u2212 k2 cos(kx) sin\n(\u03c0 ( m+\n1 2 ) (cos(x)\u2212x0) \u03b4+r ) erf ( \u03ba ( cos(x)\u2212 x0 \u2213 r \u2213 \u03b44 ))\n\u2212 \u03c0 ( m+ 1 2 ) \u03b4+r cos(x) cos(kx) cos (\u03c0 ( m+ 1 2 ) (cos(x)\u2212x0) \u03b4+r ) erf ( \u03ba ( cos(x)\u2212 x0 \u2213 r \u2213 \u03b44 )) \u2212 \u03c0 2 ( m+ 1 2 )2 (\u03b4+r)2 sin2(x) cos(kx) sin (\u03c0 ( m+ 1 2 ) (cos(x)\u2212x0) \u03b4+r ) erf ( \u03ba ( cos(x)\u2212 x0 \u2213 r \u2213 \u03b44 ))\n+ 2\u03c0k\n( m+\n1 2\n)\n\u03b4+r sin(x) sin(kx) cos (\u03c0\n( m+\n1 2 ) (cos(x)\u2212x0) \u03b4+r ) erf ( \u03ba ( cos(x)\u2212 x0 \u2213 r \u2213 \u03b44 ))\n+ 4 \u221a \u03c0\u03ba ( m+ 1 2 )\n\u03b4+r sin 2(x) cos(kx) cos\n(\u03c0 ( m+\n1 2 ) (cos(x)\u2212x0) \u03b4+r ) e\u2212\u03ba 2 ( cos(x)\u2212x0\u2213r\u2213 \u03b44 )2\n\u2212 2\u03ba\u221a \u03c0 cos(x) cos(kx) sin\n(\u03c0 ( m+\n1 2 ) (cos(x)\u2212x0) \u03b4+r ) e\u2212\u03ba 2 ( cos(x)\u2212x0\u2213r\u2213 \u03b44 )2\n+ 4\u03bak\u221a \u03c0 sin(x) sin(kx) sin\n(\u03c0 ( m+\n1 2 ) (cos(x)\u2212x0) \u03b4+r ) e\u2212\u03ba 2 ( cos(x)\u2212x0\u2213r\u2213 \u03b44 )2\n\u2212 4\u03ba3\u221a \u03c0 sin2(x) cos(kx) ( cos(x)\u2212x0\u2213r\u2213 \u03b44 ) sin\n(\u03c0 ( m+\n1 2 ) (cos(x)\u2212x0) \u03b4+r ) e\u2212\u03ba 2 ( cos(x)\u2212x0\u2213r\u2213 \u03b44 )2 .\nSubstituting Equation (A.6) into Equation (A.5), and noticing that the coefficient vector \u2016c(even) + c(odd)\u20161 \u2264 B regardless of the parity of f , we conclude that |F \u2032\u2032k (\u03b8)| \u2264 O(Bd3).\nA.2 Applying arbitrary polynomials of bitstring indexed encodings\nProposition 3.14.1 (Space-efficient state preparation, adapted from [Zal98, KM01, GR02]). Given an l-qubit quantum state |\u03c8\u3009 := \u2211mi=1 \u221a y\u0302i|i\u3009, where l = \u2308logm\u2309 and y\u0302i are real amplitudes associated with an evaluation oracle Eval(i, \u03b5) that returns y\u0302i up to accuracy \u03b5 we can prepare |\u03c8\u3009 up to accuracy \u01eb in deterministic time O\u0303(m2 log(m/\u01eb)) and space O(log(m/\u01eb2)), together with m2 evaluation oracle calls with precision \u03b5 := O(\u01eb2/m).\nProof. We follow the analysis presented in [MP16, Section III.A], with a particular focus on the classical computational complexity required for this state preparation procedure. The algorithm for preparing the state |\u03c8\u3009 expresses the weight Wx as a telescoping product, given by\n\u2200x \u2208 {0, 1}l, Wx =Wx1 \u00b7 Wx1x2 Wx1 \u00b7 Wx1x2x3Wx1x2 \u00b7 \u00b7 \u00b7 Wx Wx1\u00b7\u00b7\u00b7xn\u22121 where Wx :=\n\u2211 y\u2208{0,1}l\u2212|x| |\u3008xy|\u03c8\u3009|2.\n(A.7) To estimate |\u03c8\u3009 up to accuracy \u01eb in the \u21132 norm, it suffices to approximate each weight Wx up to additive error \u03b5 := O(\u01eb2/m), as indicated in [MP16, Section III.A]. To compute Wx\u2032 , we need 2l\u2212|x\n\u2032| oracle calls to Eval(\u00b7, \u03b5). Evaluating all terms in Equation (A.7) requires computing Wx1 ,Wx1x2 , \u00b7 \u00b7 \u00b7 ,Wx for any x \u2208 {0, 1}l, which can be achieved by 2l\u22121 + 2l\u22122 + \u00b7 \u00b7 \u00b7 + 1 = 2l oracle calls to Eval(\u00b7, \u03b5). As we need to compute Equation (A.7) for all x \u2208 {0, 1}l , the overall number of oracle calls to Eval(\u00b7, \u03b5) is 22l = m2. The remaining computation can be achieved in deterministic time O\u0303(m2 log(m/\u01eb)) and space O(log(m/\u01eb)) where the time complexity is because of the iterated integer multiplication.\nLemma 3.15 (Renormalizing bitstring indexed encoding). Let U be an (\u03b1, a, \u01eb)-bitstring indexed encoding of A, where \u03b1 > 1 and 0 < \u01eb < 1, and A is a linear operator acting on s(n) qubits. We can implement a quantum circuit V , serving as a normalization of U , such that V is a (1, a + 2, 36\u01eb)-bitstring indexed encoding of A. This implementation requires O(\u03b1) uses of U , U \u2020, C\u03a0NOT, C\u03a0\u0303NOT, and O(\u03b1) single-qubit gates. Moreover, the description of the resulting quantum circuit can be computed in deterministic time O(\u03b1) and space O(s).\nProof. Following Definition 3.1, we have \u2016A\u2212\u03b1\u03a0\u0303U\u03a0\u2016 \u2264 \u01eb, where \u03a0\u0303 and \u03a0 are the corresponding orthogonal projectors. Because U is a (1, a, \u01eb/\u03b1)-bitstring indexed encoding A/\u03b1, we obtain that \u2016A/\u03b1\u2016 \u2264 \u2016U\u2016+ \u01eb/\u03b1 = 1 + \u01eb/\u03b1, equivalently \u2016A\u2016 \u2264 \u03b1+ \u01eb.\nAdjusting the encoding through a single-qubit rotation. Consider an odd integer k := 2\u2308\u03c0(\u03b1 + 1)/2\u2309 + 1 \u2264 9\u03b1 = O(\u03b1) and \u03b3 := (\u03b1 + \u01eb) sin(\u03c0/2k) \u2264 1. We define new orthogonal projectors \u03a0\u0303\u2032 := \u03a0\u0303 \u2297 |0\u3009\u30080| and \u03a0\u2032 := \u03a0 \u2297 |0\u3009\u30080|, and combine them with U \u2032 = U \u2297 R\u03b3 , where R\u03b3 = ( \u03b3 \u2212 \u221a 1\u2212\u03b32\u221a\n1\u2212\u03b32 \u03b3\n) . By noting that \u03a0\u0303\u2032U \u2032\u03a0\u2032 = \u03b3\u03a0\u0303U\u03a0 \u2297 |0\u3009\u30080|, we deduce that\nU \u2032 is a (1, a + 1, \u03b3\u01eb/\u03b1)-bitstring indexed encoding of \u03b3A/\u03b1 \u2297 |0\u3009\u30080|, which is consequently a (1, a+ 1, 2\u03b3\u01eb/\u03b1)-bitstring indexed encoding of sin(2\u03c0/k) \u00b7 (A\u2297 |0\u3009\u30080|). An error bound follows:\n\u2225\u2225\u2225 \u03b3\n\u03b1 A\u2212 sin ( \u03c0 2k ) A \u2225\u2225\u2225 = \u2225\u2225\u2225 \u01eb \u03b1 sin ( \u03c0 2k ) A \u2225\u2225\u2225 \u2264 \u01eb \u03b1 sin ( \u03c0 2k ) (\u03b1+ \u01eb) = \u03b3\u01eb \u03b1 .\nRenormalizing the encoding via robust oblivious amplitude amplification. We follow the construction in [GSLW18, Theorem 28], full version of [GSLW19], and perform a meticulous analysis on the computational resources. We observe that it suffices to consider k \u2265 3, as for U \u2032 is already a (1, a+1, 2\u03b3\u01eb/\u03b1)-bitstring indexed encoding of A\u2297|0\u3009\u30080| when k = 1. Let \u03b5 := 2\u03b3\u01eb/\u03b1, and for simplicity, we first start by considering the case with \u03b5 = 0. By Definition 3.1, we have \u03a0\u0303\u2032U \u2032\u03a0\u2032 = \u03b1 sin ( \u03c0 2k ) \u03a0\u0303U\u03a0 \u2297 |0\u3009\u30080|. Let Tk \u2208 R[x] be the degree-k Chebyshev polynomial (of the first kind). By employing Lemma 3.13, we can apply the QSVT associated with Tk to the bitstring indexed encoding U \u2032, yielding:\n\u03a0\u0303\u2032T (SV)k (U \u2032)\u03a0\u2032 = \u03b1Tk\n( sin ( \u03c0 2k )) \u03a0\u0303U\u03a0\u2297 |0\u3009\u30080| = cos (k \u2212 1 2 \u03c0 ) A\u2297 |0\u3009\u30080| = A\u2297 |0\u3009\u30080|.\nHere, the second equality is due to Tk ( sin ( \u03c0 2k )) = Tk ( cos ( \u03c0 2 \u2212 \u03c02k )) = cos ( k\u22121 2 \u03c0 ) , and the last equality holds because k is odd. Next, we move on the case with \u03b5 > 0 and restrict it to \u03b5 \u2264 1/3.36 Let A\u2032 := \u03a0\u0303\u2032U \u2032\u03a0\u2032 and A\u0302 := \u03b3A \u2297 |0\u3009\u30080|, then we have \u2016A\u2032 \u2212 A\u0302\u2016 \u2264 \u03b5, indicating that \u2225\u2225A\u2032+A\u0302\n2 \u2225\u22252 \u2264 49 := \u03b637 and \u2016A\u2032\u2212 A\u0302\u2016+ \u2225\u2225A\u2032+A\u0302 2 \u2225\u22252 \u2264 13 + 49 < 1. By employing Lemma 3.13, as well as the facts that \u221a 2\u221a 1\u2212\u03b6 < 2 and 2k\u03b5 = 4k\u03b3\u01eb/\u03b1 \u2264 36\u01eb, we can construct a (1, a + 2, 36\u01eb)-bitstring indexed encoding of A, denoted by V .\nFinally, we provide the computational resources required for implementing V . As shown in Lemma 3.13, the implementation of V requires O(\u03b1) uses of U , U \u2020, C\u03a0NOT, C\u03a0\u0303NOT, and O(\u03b1) single-qubit gates. Furthermore, the description of the resulting quantum circuit can be computed in deterministic time O(\u03b1) and space O(s).\nA.3 Application: space-efficient error reduction for unitary quantum com-\nputations\nLemma 3.20 (Space-efficient singular value discrimination). Let 0 \u2264 \u03b1 < \u03b2 \u2264 1 and A := \u03a0\u0303U\u03a0 be a (1, 0, 0)-bitstring indexed encoding where U acts on s qubits and s(n) \u2265 \u2126(log n). Consider an unknown quantum state |\u03c8\u3009, with the promise that it is a right singular vector of A with a singular value either above \u03b1 or below \u03b2. We can distinguish the two cases with error probability at most \u03b5 := O(\u01eb log d) using a degree-d quantum singular value transformation where d = log 1/\u01eb max{\u03b2\u2212\u03b1, \u221a 1\u2212\u03b12\u2212 \u221a 1\u2212\u03b22} . Moreover, we can make the error one-sided if \u03b1 = 0 or \u03b2 = 1. In particular, the implementation requires O(d2 log d) uses of U , U \u2020, C\u03a0NOT, C\u03a0\u0303NOT, and O(d2 log d) multi-controlled single-qubit gates. Also, we can compute the description of the implementation in deterministic time O\u0303(\u03b5\u22121d9/2) and space O(s(n)).\nProof of Lemma 3.20. Given a (1, 0, 0)-bitstring indexed encoding \u03a0\u0303U\u03a0 with a singular value decomposition W\u03a3V \u2020. Utilizing Corollary 3.16, it suffices to construct an even polynomial P\n36If \u03b5 > 1/3, then \u2016\u03a0\u0303\u2032U \u2032\u03a0\u2032\u2212A\u2297 |0\u3009\u30080|\u2016 \u2264 2 = 2 \u00b7 3 \u00b7 1 3 always holds, implying that we can directly use U \u2032 as V. 37This is because \u2016A\u2032 + A\u0302\u2016 \u2264 \u2016A\u2032\u2016+ \u2016A\u2032\u2016+ \u2016A\u2032 \u2212 A\u0302\u2016 \u2264 2 sin(\u03c0/2k) + \u03b5 \u2264 2 sin(\u03c0/6) + 1/3 = 4/3.\nassociated a (1, \u01eb)-bitstring indexed encoding UP such that\u2225\u2225\u2225\u03a0\u2032\u2265t+\u03b4UP\u03a0\u2265t+\u03b4\u2212I \u2297 \u2211\ni:\u03c3i\u2265t+\u03b4 |\u03c8\u0303i\u3009\u3008\u03c8i| \u2225\u2225\u2225 \u2264 \u01eb \u2225\u2225(\u3008+| \u2297\u03a0\u2032\u2264t\u2212\u03b4)UP (|+\u3009 \u2297\u03a0\u2264t\u2212\u03b4)\u2212 0 \u2225\u2225 \u2264 \u01eb. where \u03a0\u2032 := { \u03a0\u0303, if \u03b2\u2212\u03b1\u2265 \u221a 1\u2212\u03b12\u2212 \u221a 1\u2212\u03b22\nI \u2212 \u03a0\u0303, otherwise. (A.8)\nHere singular value threshold projectors are defined as \u03a0\u2265\u03b4 := \u03a0V \u03a3\u2265\u03b4V \u2020\u03a0, so does \u03a0\u2264\u03b4. Likewise, \u03a0\u2032\u2265\u03b4 := \u03a0\u2032U\u03c3\u2265\u03b4U \u2020\u03a0\u2032 and so does \u03a0\u2032\u2264\u03b4. In addition, the definition of \u03a0\u2032 in Equation (A.8) in accordance with the proof presented in [GSLW19, Theorem 20].38\nWith the construction of the resulting bitstring indexed encoding \u03a0\u2032UP\u03a0 for an odd polynomial P , we then apply an \u01eb-approximate singular value projector by choosing t = (\u03b1 + \u03b2)/2 and \u03b4 = (\u03b2 \u2212 \u03b1)/2. Then, we measure |+\u3009\u3008+| \u2297 \u03a0\u2032: If the final state is in Img(|+\u3009\u3008+| \u2297 \u03a0\u2032), there exists a singular value \u03c3i above \u03b1 (resp., \u221a 1\u2212 \u03b22); Otherwise, all singular value \u03c3i must\nbe below \u03b2 (resp., \u221a 1\u2212 \u03b12). Furthermore, we make the error one-sided since an odd quantum singular value transformation always preserves 0 singular values. It is left to implement singular value threshold projectors for an odd polynomial P .\nImplementing singular value threshold projectors. We begin by constructing an odd polynomial P \u2208 R[x] of degree m = O(\u03b4\u22121 log \u01eb\u22122), which approximates an odd function Q(x) := 1 2 [(1\u2212\u01eb)\u00b7sgn(x+t)+(1\u2212\u01eb)\u00b7sgn(x\u2212t)+2\u01eb\u00b7sgn(x)] on the interval [\u22121, 1]\\(\u2212t\u2212\u03b4,\u2212t+\u03b4)\u222a(t\u2212\u03b4, t+\u03b4) with \u01eb2/4 precision. By leveraging the space-efficient odd degree-d polynomial approximation P sgnd (x) of the sign function, as specified in Corollary 3.7, we then obtain:\nP (x) = 12 [ (1\u2212 \u01eb) \u00b7 P sgnd (x+ t) + (1\u2212 \u01eb) \u00b7 P sgn d (x\u2212 t) + 2\u01eb \u00b7 P sgn d (x) ] . (A.9)\nHence, we ensure that |P (x)| \u2264 1 for any \u22121 \u2264 x \u2264 1, and (\u22121)zP (x) \u2208 [0, \u01eb] if (\u22121)zx \u2208 [0, t \u2212 \u03b4], as well as (\u22121)zP (x) \u2208 [1 \u2212 \u01eb, 1] if (\u22121)z \u2208 [t + \u03b4, 1] for z \u2208 {0, 1}. To achieve the resulting bitstring indexed encoding UP of P\n(SV )(\u03a0\u0303U\u03a0) with the desired precision, we apply Corollary 3.16 to P (x) described in Equation (A.9). And then the implementation error of UP is evidently upper-bounded by \u03b5 = O(\u01eb log d)."
        },
        {
            "heading": "B Omitted proofs in space-bounded quantum state testing",
            "text": "Theorem B.1. For any functions \u03b1(n) and \u03b2(n) that can be computed in deterministic logspace and satisfy \u03b1(n)\u2212 \u03b2(n) \u2265 1/poly(n), we have that GapQHSlog[\u03b1(n), \u03b2(n)] is in BQL.\nProof. Note that HS2(\u03c10, \u03c11) = 1 2 ( Tr(\u03c120) + Tr(\u03c1 2 1) ) \u2212Tr(\u03c10\u03c11). Let \u03b5 := (\u03b1\u2212\u03b2)/100. According to Lemma 2.12, we can use the SWAP test to estimate Tr(\u03c120), Tr(\u03c1 2 1), and Tr(\u03c10\u03c11), and hence HS2(\u03c10, \u03c11), within additive error \u03b5 with high probability by performing O(1/\u03b5 2) sequential repetitions. Therefore, we can conclude that GapQHSlog[\u03b1(n), \u03b2(n)] is in BQL.\nB.1 Omitted proofs in BQL containments Proposition 4.10.1. Pr [ |x\u2212 td(\u03c10, \u03c11)| \u2264 C\u0302sgn\u01eb log d+ \u01ebH + 2Csgn\u01eb log d+ 2r+1\u03b4 ] > 0.8.\nProof of Proposition 4.10.1. By applying the triangle inequality, we have obtained the following\n38By applying [GSLW18, Definition 12] (the full version of [GSLW19]) to \u03a0\u2032 := I \u2212 \u03a0\u0303, we know that |\u03c8\u3009 is a singular vector of \u03a0\u2032U\u03a0 with a singular value of at least \u221a 1\u2212 a2 in the first case, or with a singular value of at most \u221a 1\u2212 b2 in the second case. Additionally, in one-sided error scenarios, if a = 0, then b \u2212 a = b \u2265 1\u2212 \u221a 1\u2212 b2 = \u221a 1\u2212 a2 \u2212 \u221a 1\u2212 b2; while if b = 1, then b\u2212 a = 1\u2212 a \u2264 \u221a 1\u2212 a2 = \u221a 1\u2212 a2 \u2212 \u221a 1\u2212 b2.\ninequality from Equation (4.1), which holds with probability at least 0.92 > 0.8: \u2223\u2223\u2223\u2223 x0 \u2212 x1\n2 \u2212 td(\u03c10, \u03c11)\n\u2223\u2223\u2223\u2223 = \u2223\u2223\u2223\u2223 x0 \u2212 x1\n2 \u2212 Tr (\u03c10 \u2212 \u03c11 2 sgn (\u03c10 \u2212 \u03c11 2 ))\u2223\u2223\u2223\u2223\n\u2264 \u2223\u2223\u2223\u2223 x0 \u2212 x1\n2 \u2212 Tr (\u03c10 \u2212 \u03c11 2 P sgnd (\u03c10 \u2212 \u03c11 2 ))\u2223\u2223\u2223\u2223\n+ \u2223\u2223\u2223\u2223Tr (\u03c10 \u2212 \u03c11\n2 P sgnd (\u03c10 \u2212 \u03c11 2 )) \u2212 Tr (\u03c10 \u2212 \u03c11 2 sgn (\u03c10 \u2212 \u03c11 2 ))\u2223\u2223\u2223\u2223 .\nFor the first term, by noting the QSVT implementation error in Corollary 3.16, we know that \u2223\u2223\u2223\u2223 x0 \u2212 x1\n2 \u2212 Tr (\u03c10 \u2212 \u03c11 2 P sgnd (\u03c10 \u2212 \u03c11 2 ))\u2223\u2223\u2223\u2223 \u2264 C\u0302sgn\u01eb log d+ \u01ebH . (B.1)\nFor the second term, let \u03c10\u2212\u03c112 = \u2211\nj \u03bbj |\u03c8j\u3009\u3008\u03c8j |, where {|\u03c8j\u3009} is an orthonormal basis. Then,\u2223\u2223\u2223\u2223Tr (\u03c10\u2212\u03c11\n2 P sgnd (\u03c10\u2212\u03c11 2 )) \u2212 Tr (\u03c10\u2212\u03c11 2 sgn (\u03c10\u2212\u03c11 2 ))\u2223\u2223\u2223\u2223 \u2264 \u2211\nj\n\u2223\u2223\u03bbjP sgnd (\u03bbj)\u2212\u03bbjsgn(\u03bbj) \u2223\u2223 . (B.2)\nWe split the summation over j into three separate summations: \u2211 j = \u2211 \u03bbj<\u2212\u03b4 + \u2211 \u03bbj>\u03b4 + \u2211 \u2212\u03b4\u2264\u03bbj\u2264\u03b4 . By noticing the approximation error of P sgnd in Corollary 3.7, we can then obtain the following results for each of the three summations:\n\u2211\n\u03bb>\u03b4\n\u2223\u2223\u03bbjP sgnd (\u03bbj)\u2212 \u03bbjsgn(\u03bbj) \u2223\u2223 = \u2211\n\u03bb>\u03b4\n|\u03bbj | \u2223\u2223P sgnd (\u03bbj)\u2212 1 \u2223\u2223 \u2264 \u2211\n\u03bb>\u03b4\n|\u03bbj |Csgn\u01eb log d \u2264 Csgn\u01eb log d,\n\u2211\n\u03bb<\u2212\u03b4\n\u2223\u2223\u03bbjP sgnd (\u03bbj)\u2212 \u03bbjsgn(\u03bbj) \u2223\u2223 = \u2211\n\u03bb<\u2212\u03b4 |\u03bbj |\n\u2223\u2223P sgnd (\u03bbj) + 1 \u2223\u2223 \u2264 \u2211\n\u03bb<\u2212\u03b4 |\u03bbj |Csgn\u01eb log d \u2264 Csgn\u01eb log d,\n\u2211\n\u2212\u03b4\u2264\u03bbj\u2264\u03b4\n\u2223\u2223\u03bbjP sgnd (\u03bbj)\u2212 \u03bbjsgn(\u03bbj) \u2223\u2223 \u2264 \u2211\n\u2212\u03b4\u2264\u03bbj\u2264\u03b4 2|\u03bbj | \u2264 2r+1\u03b4.\nHence, we derive the following inequality by summing over the aforementioned three inequalities: \u2211\nj\n\u2223\u2223\u03bbjP sgnd (\u03bbj)\u2212 \u03bbjsgn(\u03bbj) \u2223\u2223 \u2264 2r+1\u03b4 + 2Csgn\u01eb log d. (B.3)\nBy combining Equation (B.1), Equation (B.2), and Equation (B.3), we conclude that \u2223\u2223\u2223\u2223 x0 \u2212 x1\n2 \u2212 td(\u03c10, \u03c11)\n\u2223\u2223\u2223\u2223 \u2264 C\u0302sgn\u01eb log d+ \u01ebH + 2Csgn\u01eb log d+ 2 r+1\u03b4.\nProposition 4.11.1. The following inequality holds for i \u2208 {0, 1}:\nPr [ |xi ln ( 2 \u03b2 ) \u2212 S(\u03c1i)| \u2264 2 ln ( 1 \u03b2 )( C\u0302ln\u01ebd+ \u01ebH + Cln\u01eb log d+ 2 r+1\u03b2 ) ] \u2265 910 .\nProof of Proposition 4.11.1. We only prove the case with i = 0 while the case with i = 1 follows straightforwardly. By applying the triangle inequality on Equation (4.2) with i = 0, we have: |x0 ln(2/\u03b2) \u2212 S(\u03c10)| = \u2223\u2223\u2223x0 ln(2/\u03b2) \u2212 ln(2/\u03b2)Tr ( P lnd (\u03c10) \u03c10 )\u2223\u2223\u2223+ \u2223\u2223\u2223ln(2/\u03b2)Tr ( P lnd (\u03c10) \u03c10 ) \u2212 S(\u03c10) \u2223\u2223\u2223 .\nFor the first term, by noting the QSVT implementation error in Corollary 3.17, we have \u2223\u2223\u2223x0 ln(2/\u03b2) \u2212 ln(2/\u03b2)Tr ( P lnd (\u03c10) \u03c10 )\u2223\u2223\u2223 \u2264 2 ln(1/\u03b2) ( C\u0302ln\u01ebd+ \u01ebH ) . (B.4) For the second term, let \u03c10 = \u2211\nj \u03bbj |\u03c8j\u3009\u3008\u03c8j |, where {|\u03c8j\u3009} is an orthonormal basis. Then,\u2223\u2223\u2223ln(2/\u03b2)Tr ( P lnd (\u03c10) \u03c10 ) \u2212 S(\u03c10) \u2223\u2223\u2223 \u2264 \u2211\nj\n\u2223\u2223\u2223\u03bbjP lnd (\u03bbj) ln(2/\u03b2) \u2212 \u03bbj ln(1/\u03bbj) \u2223\u2223\u2223 . (B.5)\nWe split the summation over j into two separate summations: \u2211 j = \u2211 \u03bbj>\u03b4 + \u2211 \u03bb\u2264\u03b4 . By noticing the approximation error of P lnd in Corollary 3.10, e can then obtain the following results for each\nof the two summations: \u2211\n\u03bbj>\u03b4\n\u2223\u2223\u2223\u03bbjP lnd (\u03bbj) ln(2/\u03b2) \u2212 \u03bbj ln(1/\u03bbj) \u2223\u2223\u2223 = \u2211\n\u03bbj>\u03b4\n|\u03bbj | \u2223\u2223\u2223P lnd (\u03bbj) ln(2/\u03b2) \u2212 ln(1/\u03bbj) \u2223\u2223\u2223\n\u2264 \u2211\n\u03bbj>\u03b4\n|\u03bbj |Cln\u01eb log d ln(2/\u03b2)\n\u2264 2Cln\u01eb log d ln(1/\u03b2), \u2211\n\u03bbj\u2264\u03b4\n\u2223\u2223\u2223\u03bbjP lnd (\u03bbj) ln(2/\u03b2) \u2212 \u03bbj ln(1/\u03bbj) \u2223\u2223\u2223 \u2264 \u2211\n\u03bbj\u2264\u03b4 (|\u03bbj| ln(2/\u03b2) + |\u03bbj| ln(1/\u03b2)) \u2264 2r+2\u03b4 ln(1/\u03b2).\nHence, we have derived the following inequality by summing over the aforementioned inequalities: \u2211\nj\n\u2223\u2223\u2223\u03bbjP lnd (\u03bbj) ln(2/\u03b2) \u2212 \u03bbj ln(1/\u03bbj) \u2223\u2223\u2223 \u2264 2Cln\u01eb log d ln(1/\u03b2) + 2r+2\u03b4 ln(1/\u03b2). (B.6)\nBy combining Equation (B.4), Equation (B.5), and Equation (B.6), we conclude that\n|x0 ln(2/\u03b2) \u2212 S(\u03c10)| \u2264 2 ln(1/\u03b2) ( C\u0302ln\u01ebd+ \u01ebH + Cln\u01eb log d+ 2 r+1\u03b2 ) .\nB.2 Omitted proofs in coRQUL containments\nProposition 4.14.1. Let f(\u03b80, \u03b81) := sin 2(3\u03b80) sin 2(3\u03b81) be a function such that sin 2(\u03b8i) = pi/2 for i \u2208 {0, 1} and max{|p0 \u2212 1/2|, |p1 \u2212 1/2|} \u2265 \u03b5/2, then f(\u03b80, \u03b81) \u2264 1\u2212 \u03b52/4.\nProof. We begin by stating the facts that sin2(\u03b8i) = pi/2 for i \u2208 {0, 1} and sin2(3\u03b8) = sin6(\u03b8)\u2212 6 cos2(\u03b8) sin4(\u03b8) + 9 cos4(\u03b8) sin2(\u03b8). Then we notice that 0 \u2264 p0, p1 \u2264 1 and complete the proof by a direct calculation:\nf(\u03b80, \u03b81) = ( 2p30 \u2212 6p20 + 92p0 ) ( 2p31 \u2212 6p21 + 92p1 )\n\u2264 ( 1\u2212 ( p0 \u2212 12 )2)( 1\u2212 ( p1 \u2212 12 )2) \u2264 1\u2212 ( max {\u2223\u2223p0 \u2212 12 \u2223\u2223 , \u2223\u2223p1 \u2212 12 \u2223\u2223})2 \u2264 1\u2212 \u03b524 .\nProposition 4.15.1. The polynomial function f(x) := 16x3 \u2212 24x2 + 9x is monotonically decreasing in [1/4, 9/16]. Moreover, we have f (( 1 2 + \u03b1 4 )2) \u2264 1\u2212 \u03b122 for any 0 \u2264 \u03b1 \u2264 1.\nProof. Through a direct calculation, we have f \u2032(x) = 48x2\u221248x+9 \u2264 0 for x \u2208 [1/4, 3/4], then f(x) is monotonically decreasing in [1/4, 9/16] \u2286 [1/4, 3/4]. Moreover, it is left to show that:\nf ((\n1 2 + \u03b1 4\n)2) = \u03b1 6\n256 + 3\u03b15 64 + 9\u03b14 64 \u2212 \u03b1 3 8 \u2212 3\u03b1 2 4 + 1 \u2264 1\u2212 \u03b1 2 2 .\nEquivalently, it suffices to show that g(x):=\u2212 x4256 \u2212 3x 3 64 \u2212 9x 2 64 + x 8 + 1 4 \u2265 0 for 0 \u2264 x \u2264 1. We first compute the first derivative of g(x), which is g\u2032(x) = \u2212x364 \u2212 9x 2\n64 \u2212 9x32 + 18 . Setting g\u2032(x) equal to zero, we obtain three roots: x1 = \u22124, x2 = 12(\u2212 \u221a 33\u2212 5) < 0, and x3 = 12 ( \u221a 33\u2212 5) \u2208 (0, 1).\nSince g\u2032(0) = 1/8 > 0 and g\u2032(1) = \u22125/16 < 0, we conclude that g(x) is monotonically increasing in [0, x3] and monotonically decreasing in [x3, 1]. Therefore, we can determine the minimum value of g(x) by evaluating g(0) = 14 and g(1) = 47 256 . Since both values are greater\nthan zero, we conclude that min{g(0), g(1)} = { 1 4 , 47 256 } > 0, as desired."
        }
    ],
    "year": 2023
}