{
    "abstractText": "There are many techniques and tools for termination of C programs, but up to now they were not very powerful for termination proofs of programs whose termination depends on recursive data structures like lists. We present the first approach that extends powerful techniques for termination analysis of C programs (with memory allocation and explicit pointer arithmetic) to lists. 2012 ACM Subject Classification Theory of computation \u2192 Logic and verification; Theory of computation \u2192 Program analysis; Software and its engineering \u2192 Data types and structures",
    "authors": [
        {
            "affiliations": [],
            "name": "Jera Hensel"
        },
        {
            "affiliations": [],
            "name": "J\u00fcrgen Giesl"
        }
    ],
    "id": "SP:9923f16d0e46279ec0b3989ca1adf7fb11470e0f",
    "references": [
        {
            "authors": [
                "J. Berdine",
                "B. Cook",
                "D. Distefano",
                "P.W. O\u2019Hearn"
            ],
            "title": "Automatic termination proofs for programs with shape-shifting heaps",
            "venue": "In Proc. CAV \u201906,",
            "year": 2006
        },
        {
            "authors": [
                "M. Bozga",
                "R. Iosif",
                "S. Perarnau"
            ],
            "title": "Quantitative separation logic and programs with lists",
            "venue": "J. Aut. Reasoning,",
            "year": 2010
        },
        {
            "authors": [
                "M. Brockschmidt",
                "C. Otto",
                "J. Giesl"
            ],
            "title": "Modular termination proofs of recursive Java Bytecode programs by term rewriting",
            "venue": "In Proc. RTA \u201911,",
            "year": 2011
        },
        {
            "authors": [
                "M. Brockschmidt",
                "R. Musiol",
                "C. Otto",
                "J. Giesl"
            ],
            "title": "Automated termination proofs for Java programs with cyclic data",
            "venue": "In Proc. CAV \u201912,",
            "year": 2012
        },
        {
            "authors": [
                "C. Calcagno",
                "D. Distefano",
                "P.W.\u2019 O\u2019Hearn",
                "H. Yang"
            ],
            "title": "Beyond reachability: Shape abstraction in the presence of pointer arithmetic",
            "venue": "In Proc. SAS \u201906,",
            "year": 2006
        },
        {
            "authors": [
                "C. David",
                "D. Kroening",
                "M. Lewis",
                "J. Vitek"
            ],
            "title": "Propositional reasoning about safety and termination of heap-manipulating programs",
            "venue": "In Proc. ESOP \u201915,",
            "year": 2015
        },
        {
            "authors": [
                "K. Dudka",
                "P. Peringer",
                "T. Vojnar"
            ],
            "title": "Predator: A practical tool for checking manipulation of dynamic data structures using separation logic",
            "venue": "In Proc. CAV \u201911,",
            "year": 2011
        },
        {
            "authors": [
                "F. Emrich",
                "J. Hensel",
                "J. Giesl"
            ],
            "title": "AProVE: Modular termination analysis of memorymanipulating",
            "venue": "C programs. CoRR,",
            "year": 2023
        },
        {
            "authors": [
                "J. Giesl",
                "C. Aschermann",
                "M. Brockschmidt",
                "F. Emmes",
                "F. Frohn",
                "C. Fuhs",
                "C. Otto",
                "M. Pl\u00fccker",
                "P. Schneider-Kamp",
                "T. Str\u00f6der",
                "S. Swiderski",
                "R. Thiemann"
            ],
            "title": "Analyzing program termination and complexity automatically with AProVE",
            "venue": "J. Aut. Reasoning,",
            "year": 2017
        },
        {
            "authors": [
                "J. Hensel",
                "J. Giesl",
                "F. Frohn",
                "T. Str\u00f6der"
            ],
            "title": "Termination and complexity analysis for programs with bitvector arithmetic by symbolic execution",
            "venue": "J. Log. Alg. Meth. Prog.,",
            "year": 2018
        },
        {
            "authors": [
                "J. Hensel",
                "J. Giesl"
            ],
            "title": "Proving termination of C programs with lists",
            "venue": "In Proc. CADE \u201923,",
            "year": 2023
        },
        {
            "authors": [
                "T.C. Le",
                "S. Qin",
                "W. Chin"
            ],
            "title": "Termination and non-termination specification inference",
            "venue": "In Proc. PLDI",
            "year": 2015
        },
        {
            "authors": [
                "V. Mal\u00edk",
                "\u0160. Marti\u010dek",
                "P. Schrammel",
                "M. Srivas",
                "T. Vojnar"
            ],
            "title": "Wahlang. 2LS: Memory safety and non-termination",
            "venue": "In Proc. TACAS \u201918,",
            "year": 2018
        },
        {
            "authors": [
                "C. Otto",
                "M. Brockschmidt",
                "C. von Essen",
                "J. Giesl"
            ],
            "title": "Automated termination analysis of Java Bytecode by term rewriting",
            "venue": "In Proc. RTA \u201910,",
            "year": 2010
        },
        {
            "authors": [
                "R.N.S. Rowe",
                "J. Brotherston"
            ],
            "title": "Automatic cyclic termination proofs for recursive procedures in separation logic",
            "venue": "In Proc. CPP \u201917,",
            "year": 2017
        },
        {
            "authors": [
                "T. Str\u00f6der",
                "J. Giesl",
                "M. Brockschmidt",
                "F. Frohn",
                "C. Fuhs",
                "J. Hensel",
                "P. Schneider-Kamp",
                "C. Aschermann"
            ],
            "title": "Automatically proving termination and memory safety for programs with pointer arithmetic",
            "venue": "J. Aut. Reasoning,",
            "year": 2017
        }
    ],
    "sections": [
        {
            "text": "2012 ACM Subject Classification Theory of computation \u2192 Logic and verification; Theory of computation \u2192 Program analysis; Software and its engineering \u2192 Data types and structures Keywords and phrases Termination Analysis, C Programs, Lists, Symbolic Execution Related Version See [11]. Full version, including all proofs: https://arxiv.org/abs/2305.12159\nFunding funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) - 235950644 (Project GI 274/6-2)\n1 Introduction\nIn [8, 10, 16], we introduced an approach for termination analysis of C that also handles programs whose termination relies on the relation between allocated memory and the data stored at such addresses. This approach is implemented in our tool AProVE [9]. Instead of analyzing C directly, AProVE compiles the program to LLVM. Then it constructs a (finite) symbolic execution graph (SEG) such that every program run corresponds to a path through the SEG. AProVE proves memory safety during the construction of the SEG to ensure absence of undefined behavior (which would also allow non-termination). Afterwards, the SEG is transformed into an integer transition system (ITS) such that all paths through the SEG (and hence, the C program) are terminating if the ITS is terminating. To analyze termination of ITSs, AProVE applies standard techniques and tools. However, like other termination tools for C, up to now AProVE supported dynamic data structures only in a very restricted way.\nstruct list { unsigned int value; struct list* next; };\nint main() { // initialize length unsigned int n = nondet_uint(); // initialize list of length n struct list* tail = NULL; struct list* curr; for (unsigned int k = 0; k < n; k++) {\ncurr = malloc(sizeof(struct list)); curr->value = nondet_uint(); curr->next = tail; tail = curr; }\n// traverse list struct list* ptr = tail; while(ptr != NULL) {\nptr = *((struct list**)((void*)ptr + offsetof(struct list, next)));}}\nIn the program on the side, nondet_uint returns a random unsigned integer. The for loop creates a list of n random numbers if n > 0 and the while loop traverses this list via pointer arithmetic. We introduce a novel technique which can analyze termination of such C programs on lists, i.e., it can both handle the access by curr->next (when initializing the list) and by pointer arithmetic (when traversing the list).\nOur technique infers list invariants via symbolic execution. These invariants express all properties that are crucial for memory safety and termination. In our example, the list invariant contains the information that dereferencing the next pointer in the while loop is safe and that one finally reaches the null pointer.\nar X\niv :2\n30 7.\n11 02\n4v 1\n[ cs\n.L O\n] 2\n0 Ju\nl 2 02\n3\nTo ease the presentation, in this paper we treat integer types as unbounded. Moreover, we assume that a program consists of a single non-recursive function and that values may be stored at any address. Our approach can also deal with bitvectors, data alignments, and programs with arbitrary many (possibly recursive) functions, see [8, 10, 16] for details. However, so far only lists without sharing can be handled by our new technique. Extending it to more general recursive data structures is one of the main challenges for future work.\n2 Abstract States for Symbolic Execution\nlist = type { i32, list* }\ndefine i32 @main() { ... cmpF:\nk < n 0: k = load i32, i32* k_ad 1: kltn = icmp ult i32 k, n 2: br i1 kltn, label bodyF, label initPtr\nbodyF: curr = malloc(sizeof(struct list));\n0: mem = call i8* @malloc(i64 16) 1: curr = bitcast i8* mem to list* curr->value = nondet_uint(); 2: nondet = call i32 @nondet_uint() 3: curr_val = getelementptr list, list* curr, i32 0, i32 0 4: store i32 nondet, i32* curr_val curr->next = tail; 5: tail = load list*, list** tail_ptr 6: curr_next = getelementptr list, list* curr, i32 0, i32 1 7: store list* tail, list** curr_next tail = curr; 8: store list* curr, list** tail_ptr k++ 9: kinc = add i32 k, 1 10:store i32 kinc, i32* k_ad 11:br label cmpF ... }\nThe LLVM code for the for loop is given on the side. To ease readability, we omitted instructions and keywords that are irrelevant for our presentation, renamed variables, and wrote list instead of struct.list. The code consists of several basic blocks including cmpF and bodyF (for the comparison and the body of the for loop).\nWe now recapitulate the abstract states of [16] used for symbolic execution and extend them by a component LI for list invariants. The first component is a program position (b, i), indicating that instruction i of block b is executed next.\nThe second component is a partial injective function LV \u2236VP \u21c0 Vsym , which maps local program variables VP of the program P to an infinite set Vsym of symbolic variables with Vsym \u2229 VP = \u2205.\nThe third component is a set AL of allocations Jv1, v2K with v1, v2 \u2208 Vsym, indicating that v1 \u2264 v2 and all addresses between v1 and v2 are allocated.\nThe fourth and fifth components PT and LI model the memory. PT contains \u201cpoints-to\u201d entries v1 \u21aaty v2 where v1, v2 \u2208 Vsym and ty is an LLVM type, meaning that the address v1 of type ty points to v2. The set LI of list invariants (which is new compared to [16]) contains invariants vad v\u2113 \u21aa\u00d0\u2192ty [(off i \u2236 tyi \u2236 vi..v\u0302i)]mi=1 where m\u2208N>0, vad , v\u2113, vi, v\u0302i \u2208 Vsym , off i \u2208 N for all 1 \u2264 i \u2264 m, ty and tyi are LLVM types for all 1 \u2264 i \u2264 m, and there is exactly one \u201crecursive field\u201d 1 \u2264 j \u2264m such that tyj = ty*. Such an invariant represents a struct ty with m fields that corresponds to a recursively defined list of length v\u2113. Here, vad points to the first list element, the i-th field starts at address vad + off i and has type tyi, and the values of the i-th fields of the first and last list element are vi and v\u0302i, respectively. For example, the list invariant (1) represents all lists of length x\u2113 and type list whose elements store a 32-bit integer in their first field and the pointer to the next element in their second field with offset 8. The first list element starts at address xmem, the second starts at address xnext, and the last element contains the null pointer. Moreover, the first element stores the integer value xnd and the last list element stores the integer x\u0302nd.\nxmem x\u2113 \u21aa\u00d0\u2192list [(0 \u2236 i32 \u2236 xnd..x\u0302nd), (8 \u2236 list* \u2236 xnext..0)] (1)\nThe last component is a knowledge base KB of formulas that express arithmetic properties of Vsym. A special state ERR is reached if we cannot prove absence of undefined behavior.\nAs an example, the abstract state (2) represents concrete states at the beginning of the block cmpF, where the program variable curr is assigned the symbolic variable xmem, the\nallocation Jxk_ad, xendk_adK consisting of 4 bytes stores the value xkinc, and xmem points to the first element of a list of length x\u2113 (equal to xkinc) that satisfies the list invariant (1). (This state will later be obtained during the symbolic execution, see State O in Fig. 3.)\n(cmpF, 0), {curr = xmem, kinc = xkinc, ...}, {Jxk_ad, xendk_adK, ...}, {xk_ad \u21aai32 xkinc, ...}, {xmem x\u2113 \u21aa\u00d0\u2192list [(0 \u2236 i32 \u2236 xnd..x\u0302nd), (8 \u2236 list* \u2236 xnext..0)]}, {xendk_ad = xk_ad + 3, x\u2113 = xkinc, ...}\n(2)\n3 Symbolic Execution with List Invariants\nSymbolic execution starts with a state A at the first instruction of the first block (entry in our example), see Fig. 1. Dotted arrows indicate that we omitted some steps. For every state, we perform symbolic execution by applying the corresponding inference rule to compute its successor(s) and repeat this until all paths end in return states. Such an SEG is complete.\nIn our example, the entry block comprises the first three lines of the C program and the initialization of the pointer to the loop variable k: First, a non-deterministic integer is assigned to n, i.e., (n = vn) \u2208 LV B, where vn is not restricted. Moreover, memory for the pointers tail_ptr and k_ad is allocated and they point to tail = NULL and k = 0, respectively (tail_ptr = vtp and k_ad = vk_ad with (vtp \u21aalist* 0), (vk_ad \u21aai32 0) \u2208 PTB). For simplicity, in Fig. 1 we use concrete values directly instead of introducing fresh variables for them.\nState C results from B by evaluating the load instruction at (cmpF, 0), where the value 0 stored at vk_ad is loaded to the program variable k. The next instruction is an integer comparison which checks whether the unsigned value of k is less than the one of n. If we cannot decide a comparison, we refine the state into two successor states like D and E (with (vn > 0) \u2208 KBD and (vn \u2264 0) \u2208 KBE). Evaluating D yields kltn = 1 in F . Therefore, the branch instruction leads to the block bodyF in State G. State E is evaluated to a state with kltn = 0. This path branches to the block initPtr and terminates as tail_ptr points to an empty list.\nThe instruction at (bodyF, 0) allocates 16 bytes of memory starting at vmem in State H. Next, the pointer to the allocation is cast from i8* to list* and assigned to curr. Now the allocated area can be treated as a list element. Then nondet_uint() assigns a 32-bit integer to nondet. The getelementptr instruction computes the address of the integer field of the\nlist element by indexing this field (the second i32 0) based on the start address (curr). Since the address of this integer value coincides with the start address of the list element, this instruction assigns vmem to curr_val. Afterwards, the value of nondet is stored at curr_val (vmem \u21aai32 vnd), the value 0 stored at vtp is loaded to tail, and a second getelementptr instruction computes the address of the recursive field of the current list element (vcn = vmem+8) and assigns it to curr_next, leading to State J . In the path to K, the values of tail and curr are stored at curr_next and tail_ptr, respectively (vcn \u21aalist* 0, vtp \u21aalist* vmem). Finally, the incremented value of k is assigned to kinc and stored at k_ad (vk_ad \u21aai32 1).\nTo ensure a finite graph construction, when a program position is reached for the second time, we try to merge the states at this position to a generalized state. However, this is only meaningful if the domains of the LV functions of the two states coincide (i.e., the states consider the same program variables). Therefore, after the branch from the loop body back to cmpF (State L in Fig. 2), we evaluate the loop a second time and reach M . Here, a second\nL \u2236 vmem vnd 0 value next\nM \u2236 wmem wnd vnd 0 value next value next list element with value wnd and a next pointer wcn pointing to vmem has been stored at a new allocation Jwmem, wendmem K. Now, curr points to the new element and k has been incremented again, so k_ad points to 2.\nWe want to merge L and M to a more general state O that represents all states which are represented by L or M . The challenging part during generalization is to find loop invariants that provide sufficient information to prove termination of the loop. For O, we can neither use that curr points to a struct whose next field contains the null pointer (as in L), nor that its next field points to another struct whose next field contains the null pointer (as in M).\nWe solve this problem by introducing list invariants. In our example, we will infer an invariant stating that curr points to a list of length x\u2113 \u2265 1. This invariant also implies that all struct fields are allocated and that there is no sharing.\nTo merge two states s and s\u2032 at the same program position with domain(LV s) = domain(LV s\u2032), we introduce a fresh symbolic variable xvar for each program variable var and use instantiations \u00b5s and \u00b5s\u2032 which map xvar to the corresponding symbolic variables of s and s\u2032. For the merged state s, we set LV s(var) = xvar. Moreover, we identify corresponding variables that only occur in the memory components and extend \u00b5s and \u00b5s\u2032 accordingly. In a second step, we check which constraints from the memory components and the knowledge base hold in both states in order to find invariants that we can add to the memory components and the knowledge base of s. For example, if J\u00b5s(x), \u00b5s(xend)K \u2208 ALs and J\u00b5s\u2032(x), \u00b5s\u2032(xend)K \u2208 ALs \u2032\nfor x, xend \u2208 Vsym , then Jx, xendK is added to ALs. To extend this heuristic to lists, we have to regard several memory entries together. If there is an ad \u2208 VP such that \u00b5s(xad) and \u00b5s\u2032(xad) both point to lists of type ty but of different lengths \u2113s \u2260 \u2113s\u2032 with \u2113s, \u2113s\u2032 \u2265 1, then we create a list invariant.\nIn our example, L and M contain lists of length \u2113L = 1 and \u2113M = 2. Thus, when merging L and M to a new state O (see Fig. 3), the lists are merged to a list invariant of variable\nlength x\u2113 and our technique adds the formulas 1 \u2264 x\u2113 and x\u2113 = xkinc to KBO. Moreover, the i32 value of the first element is identified with xnd, since \u00b5L(xnd) is equal to the first value of the first list element in L and \u00b5M(xnd) is equal to the first value of the first list element in M . Similarly, the values of the last list elements are identified with 0, as in L and M .\nAfter merging s and s\u2032, we continue symbolic execution from the generalized state s. The next time we reach the same program position, we might have to merge the corresponding states again. As described in [16], we use a heuristic which ensures that after a finite number of iterations, a state is reached that is represented by an already existing state in the SEG. Then symbolic execution can continue from this more general state instead. So the construction always ends in a complete SEG or an SEG containing the state ERR.\nTo prove termination of a program P, as in [16] the cycles of the SEG are translated to an ITS whose termination implies termination of P. In our example, the first cycle of the SEG (corresponding to the for loop of the C program) yields transitions which terminate since k is increased until it reaches n. The second cycle (corresponding to the while loop) terminates since the length of the list decreases. Although there is no program variable for the length, due to our list invariants the states of the SEG contain variables for this length, which are also passed to the ITS. Thus, the resulting transitions clearly terminate.\n4 Conclusion and Evaluation\nWe presented a new approach for proving memory safety and termination of C programs on lists. The main idea is to extend the states in the SEG by list invariants. We developed techniques to infer and modify list invariants automatically during the symbolic execution.\nList invariants abstract from a concrete number of memory allocations to a list of allocations of variable length while preserving knowledge about some of the contents and the list shape. They also contain information on the memory arrangement of the list fields which is needed to prove memory safety for programs that access fields via pointer arithmetic. The symbolic variables for the list length and the first and last values of list elements are preserved when generating an ITS from the SEG. Thus, they can be used in its termination proof.\nIn [3, 4, 14] we developed a technique for termination analysis of Java, based on a program transformation to integer term rewrite systems instead of ITSs. This approach does not require specific list invariants as recursive data structures on the heap are abstracted to terms. However, these terms are unsuitable for C, since they cannot express memory allocations and the connection to their contents.\nFor every abstract state, we define a corresponding separation logic formula to define which concrete states are represented by the abstract state, see [11]. To extend this formula to list invariants, we use a fragment similar to quantitative separation logic [2], extending conventional separation logic by list predicates. Based on separation logic with inductive predicates, [7] also uses a representation of lists with offsets which is similar to our list invariants, and [5] presents an abstract domain to represent lists in the presence of pointer arithmetic. However, in contrast to our work, [5, 7] are not concerned with termination analysis.\nSeparation logic predicates for termination of list programs were also used in [1], but\ntheir list predicates only consider the list length and the recursive field, but no other fields or offsets. The tools Cyclist [15] and HipTNT+ [12] are integrated in separation logic systems which also allow to define heap predicates. However, they require annotations and hints which parameters of the list predicates are needed as a termination measure. The tool 2LS [13] also provides basic support for dynamic data structures. But all these approaches are not suitable if termination depends on the contents or the shape of data structures combined with pointer arithmetic. In [6], programs can be annotated with arithmetic and structural properties to reason about termination. In contrast, our approach does not need hints or annotations, but finds termination arguments fully automatically.\nWe implemented our approach in AProVE [16]. Since existing tools can hardly prove termination of C programs with lists, the current benchmarks for termination analysis contain almost no list programs. In 2017, a set of 18 C programs on lists was added to the Termination category of the Competition on Software Verification (SV-COMP),1 where nine of them are terminating. Two of these nine programs do not need list invariants, because they just create a list without operating on it afterwards. The remaining seven terminating programs create a list and then traverse it, search for a value, or append lists and compute the length afterwards. Our new version of AProVE is the only termination prover that succeeds for five of these seven programs, since here termination depends on the shape or contents of a list after its creation.\nFor the Termination Competition 2022,2 we submitted 18 terminating C programs on lists (different from the ones at SV-COMP), where AProVE succeeds on 17 of them. Two of these programs just create a list. Three traverse it afterwards (by a loop or recursion), and ten search for a value, where for nine, also the list contents are relevant for termination. Three programs perform common operations like inserting or deleting an element.\nWithout list invariants, in each collection AProVE only proves termination of two examples that just create a list without traversing it afterwards, and non-termination for one example in the SV-COMP collection. AProVE and UAutomizer were the most powerful C termination tools in SV-COMP and the Termination Competition 2022, with UAutomizer winning the former\nSV-C T. SV-C Non-T. TermCmp T. AProVE 7 (of 9) 5 (of 9) 17 (of 18)\nUAutomizer 2 (of 9) 7 (of 9) 1 (of 18) and AProVE winning the latter. To download AProVE, its web interface, and details on our experiments, see https://aprove-developers.github.io/recursive_structs.\nReferences 1 J. Berdine, B. Cook, D. Distefano, and P. W. O\u2019Hearn. Automatic termination proofs for\nprograms with shape-shifting heaps. In Proc. CAV \u201906, LNCS 4144, pages 386\u2013400, 2006. 2 M. Bozga, R. Iosif, and S. Perarnau. Quantitative separation logic and programs with lists. J.\nAut. Reasoning, 45(2):131\u2013156, 2010. 3 M. Brockschmidt, C. Otto, and J. Giesl. Modular termination proofs of recursive Java Bytecode\nprograms by term rewriting. In Proc. RTA \u201911, LIPIcs 10, pages 155\u2013170, 2011. 4 M. Brockschmidt, R. Musiol, C. Otto, and J. Giesl. Automated termination proofs for Java\nprograms with cyclic data. In Proc. CAV \u201912, LNCS 7358, pages 105\u2013122, 2012. 5 C. Calcagno, D. Distefano, P. W.\u2019 O\u2019Hearn, and H. Yang. Beyond reachability: Shape\nabstraction in the presence of pointer arithmetic. In Proc. SAS \u201906, LNCS 4134, pages 182\u2013203, 2006.\n1 https://sv-comp.sosy-lab.org/2022/ 2 https://termination-portal.org/wiki/Termination_Competition_2022\n6 C. David, D. Kroening, M. Lewis, and J. Vitek. Propositional reasoning about safety and termination of heap-manipulating programs. In Proc. ESOP \u201915, LNCS 9032, pages 661\u2013684, 2015. 7 K. Dudka, P. Peringer, and T. Vojnar. Predator: A practical tool for checking manipulation of dynamic data structures using separation logic. In Proc. CAV \u201911, LNCS 6806, pages 372\u2013378, 2011. 8 F. Emrich, J. Hensel, and J. Giesl. AProVE: Modular termination analysis of memorymanipulating C programs. CoRR, abs/2302.02382, 2023. 9 J. Giesl, C. Aschermann, M. Brockschmidt, F. Emmes, F. Frohn, C. Fuhs, C. Otto, M. Pl\u00fccker, P. Schneider-Kamp, T. Str\u00f6der, S. Swiderski, and R. Thiemann. Analyzing program termination and complexity automatically with AProVE. J. Aut. Reasoning, 58(1):3\u201331, 2017. 10 J. Hensel, J. Giesl, F. Frohn, and T. Str\u00f6der. Termination and complexity analysis for programs with bitvector arithmetic by symbolic execution. J. Log. Alg. Meth. Prog., 97:105\u2013130, 2018. 11 J. Hensel and J. Giesl. Proving termination of C programs with lists. In Proc. CADE \u201923, LNCS, 2023. To appear. Full version appeared in CoRR, abs/2305.12159. 12 T. C. Le, S. Qin, and W. Chin. Termination and non-termination specification inference. In Proc. PLDI \u201915, pages 489\u2013498, 2015. 13 V. Mal\u00edk, \u0160. Marti\u010dek, P. Schrammel, M. Srivas, T. Vojnar, and J. Wahlang. 2LS: Memory safety and non-termination. In Proc. TACAS \u201918, LNCS 10806, pages 417\u2013421, 2018. 14 C. Otto, M. Brockschmidt, C. von Essen, and J. Giesl. Automated termination analysis of Java Bytecode by term rewriting. In Proc. RTA \u201910, LIPIcs 6, pages 259\u2013276, 2010. 15 R. N. S. Rowe and J. Brotherston. Automatic cyclic termination proofs for recursive procedures in separation logic. In Proc. CPP \u201917, pages 53\u201365, 2017. 16 T. Str\u00f6der, J. Giesl, M. Brockschmidt, F. Frohn, C. Fuhs, J. Hensel, P. Schneider-Kamp, and C. Aschermann. Automatically proving termination and memory safety for programs with pointer arithmetic. J. Aut. Reasoning, 58(1):33\u201365, 2017."
        }
    ],
    "title": "Automated Termination Proofs for C Programs with Lists(Short WST Version)",
    "year": 2023
}