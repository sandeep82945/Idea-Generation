Many Big Data applications include the processing of data streams on semi-structured data formats such as JSON. A disadvantage of such formats is that an application may spend a significant amount of processing time just on unselectively parsing all data. To relax this issue, the concept of raw filtering is proposed with the idea to remove data from a stream prior to the costly parsing stage. However, as accurate filtering of raw data is often only possible after the data has been parsed, raw filters are designed to be approximate in the sense of allowing false-positives in order to be implemented efficiently. Contrary to previously proposed CPU-based raw filtering techniques that are restricted to string matching, we present FPGA-based primitives for filtering strings, numbers and also number ranges. In addition, a primitive respecting the basic structure of JSON data is proposed that can be used to further increase the accuracy of introduced raw filters. The proposed raw filter primitives are designed to allow for their composition according to a given filter expression of a query. Thus, complex raw filters can be created for FPGAs which enable a drastical decrease in the amount of generated false-positives, particularly for IoT workload. As there exists a trade-off between accuracy and resource consumption, we evaluate primitives as well as composed raw filters using different queries from the RiotBench benchmark. Our results show that up to 94.3% of the raw data can be filtered without producing any observed false-positives using only a few hundred LUTs. q0 := $.e[? (@.n=="temperature" & @.v ≥ 0.7 & @.v ≤ 35.1)]
Listing 2: Running Example - JSONPath Query
of the given query to further accelerate JSON parsing. Filter predicates are translated into so-called Raw Filters (RFs), which are inspecting the raw byte stream in a structureagnostic fashion. Listing 2 presents a query on a stream of IoT records as illustrated in Listing 1 as a motivational example. Here, all records containing a ”temperature” sensor measure which lies in the range of [0.7, 35.1] are queried. RFs proposed by [10] are restricted to string comparisons. The ”temperature” string would thus be a possible RF to be searched in the byte stream regardless of any structure. If the string is found at least once in a record, the record is accepted. If no occurrences of the string can be identified, the record is dropped and the parser doesn’t have to deal with it. While this approach may produce some false-positives (e.g., records where the temperature value doesn’t lie within the range), it guarantees that no false-negatives are created (i.e., no records are filtered out that contain temperature measures). The false-positives, on the contrary, are not affecting the end result, as the CPU parser will accurately filter the remaining records. Accordingly, falsepositives only reduce the achievable speedup gained from the filter selectivity. However, the restriction to string matching poses an issue. Many applications, especially from the IoT domain, are gaining their selectivity from filtering numbers, timestamps, or number ranges as exemplified in Listing 2. In this paper, we investigate raw filtering on FPGAs. Particularly, we introduce FPGA-based concepts for string matching and filtering number ranges in byte streams. Such raw filters can be combined to create more complex and ideally more selective filters, e.g., a conjunctive (AND) combination of string matching (s(”temperature”)) and a value range filter (0.7 ≤ v ≤ 35.1) for the query in Listing 2. However, filters built by conjunction and disjunction of filter predicates might not always result in improved selectivity. For example, the record in Listing 1 contains the ”temperature” string and numbers (”12”, ”20”) which lie in the given value range. However, the temperature value itself (”35.2”) exceeds it. Thus, the described raw filter would generate a false-positive. We therefore additionally
present a technique which is able to extract structural information while scanning the byte stream. By using this technique, filter predicates can be combined such that their results are only combined if found in the correct structural context. The contributions of this paper can be summarized as follows:
1) FPGA-based raw filtering concepts: primitives optimized for FPGA-based RFs: (a) An approximate string matcher. (b) An approximate number range matcher. Extracting structural information and building raw filters by conjunctive and disjunctive combination of filter primitives depending on structural context. 2) Raw filter evaluation: query-specifc raw filter configurations: tradeoffs between resource requirements
and false-positive rates
3) FPGA hardware architecture and implementation for raw filtering: Filtering data streams at 10 GBit/s (line rate), i.e., no negative effect on performance of
overall system. Tailored to filter the data stream directly between the data source (e.g., Ethernet, SSD) and CPU (SmartNIC, etc.). The remaining paper is organized as follows: In Section III, concepts and techniques for different raw filtering primitives are introduced and their composition into a complex raw filter is discussed. In Section IV, the proposed filters are evaluated with the RiotBench Benchmark. Finally, the paper finishes in Section V with a conclusion and an outlook for future work. ii. related work There has been a lot of research to accelerate parsing recently [6, 7]. Those implementations rely on SIMDinstructions and can scan documents at a speed of over 2 GB/s. One of these Parsers is Mison [7] presented by Li et al.. Mison uses SIMD-instructions to build a structural index of a record. Queried Fields are then parsed on demand by speculatively jumping to the beforehand indexed attribute positions. Sparser [10] was the first to approximately pre-filter records using SIMD-based string comparisons on raw data, to reduce the parsing workload itself. Sparser’s RFs are based on two filtering primitives. The main primitive is a substring search, that inspects the input byte stream for 2-, 4- and 8-byte long substrings. The second primitive is used for key-value search and can filter co-occurrences of substrings. One major drawback of Sparser is the limitation to filter only based on string comparisons. Many applications, however, especially those in the IoT domain, are gaining their selectivity from filtering numbers or timestamps. In other scenarios, it’s necessary to have at least a small degree of structural awareness, which is except for the key-value search not possible with Sparser. The concept of raw filtering has been adopted for programmable switches, too [5]. Here, strings are searched by several small cascaded DFAs. Nevertheless, programmable switches have limited resources and packets need to be recirculated through the switch, to filter complex expressions, therefore implying bandwidth limitations. There have been several stream processing Query Compilers for FPGAs [8, 9, 11]. But these compilers solely work on binary data, not considering that the input data might have to be parsed before processing. The Fleet [13] framework can push arbitrary Stream operations, like JSON Parsing,
onto the FPGA by introducing a new DSL. However, their presented PUs can’t process one character per cycle and must be replicated extensively to achieve a high throughput, hence requiring a lot of resources. ACCORDA [3] tries to improve the processing of raw unstructured data with dedicated Hardware Accelerators. The authors show that their unstructured data processor can parse and filter JSON data for all common predicates, but is in return again very resource intensive. The presented FPGA prototype requires 295K LUTs. Moreover, regular expression matching has already been investigated for FPGAs heavily. Woods et al. [14] suggest regular expression matching with an FPGA located between NIC and CPU, for complex event detection in data streams. As regular expressions can get arbitrarily complex and FPGA resources are limited, Becher et al. [1] propose a optimistic regex evaluation. Compared to our raw filters, this approach enables similar tradeoffs between resource consumption and the accuracy of the filter. Nevertheless, we only used regular expressions for building our value range filter, as the resource consumption can be further reduced by using the other presented primitives. iii. raw filtering primitives & composition In this section, we present FPGA filter primitives for string matching and for detecting values and value ranges. We furthermore propose a technique to extract some information of the JSON structure from the byte stream and describe how to compose these primitives to build query-specific selective raw filters. a. string search The original idea of raw filtering is to find a string anywhere in a given byte stream regardless of any structure. In the following, we investigate three techniques to implement string matching on FPGAs. Let the search string have a size of N Bytes. (i) The string can be matched with a state machine accepting the search string with N states, which transitions with one character every cycle. (ii) Another option would be to buffer the last N Bytes of the byte stream and compare them to the full N -Byte search string every cycle. While these solutions exactly match a given search string, we want to introduce a more resource-saving approximate option that allows rare false-positives to occur. (iii) Instead of buffering the full length of the search string, we only buffer the last block length (B) Bytes of the input byte stream. This buffer is compared to all possible substrings of a size of B Bytes of the search string. The results of these comparators are then or-reduced and fed into a counter, which is incremented with each match and reset when no comparator matches. The filter
emits a ’1’ if the counter value is equal to N −B +1. As an example, Table IV shows all substrings of the search string ”temperature” for different block lengths B. Figure 1 presents a schematic of our concept for search string ”temperature” and block length B = 2. In the remainder of this paper, searching a string str with block length B is denoted as sB(str). In the following, these three techniques will be evaluated in terms of false-positive rate (FPR) and resource costs (LUTs). For this purpose, the strings used in RiotBench [12] are examined with their associated datasets. As these measurement lists aren’t containing many strings, which might cause false-positives, we additionally evaluated a more diverse Twitter dataset [4]. The results can be seen in Tables I to III. While for the exact solutions (i, ii) the required LUTs increase rapidly with the length of the string, only slightly more resources are required for longer strings for the substring search (iii). This is due to the or-reduction of the many comparisons, which ensures that the entire logic can be combined in one LUT. This large LUT can be mapped effectively to hardware primitives by the synthesis tool. In the comparison of the exact methods (i, ii), the full-length comparison (ii) turns out to be advantageous for shorter strings, since no states have to be encoded. However, as the length of the strings increases, the amount of logic required to process several chars in parallel increases significantly. In contrast, the DFA-based solution (i) only requires one char to be processed per cycle, while the number of bits required to encode the states increases only approximately logarithmically. With respect to the required LUTs, the presented subset matcher with B = 1 turns out to be superior in all cases. But especially for longer strings, where even for B = 1 an FPR of 0 is achieved. For shorter strings, however, an FPR of 0 is only achieved for B = 2, whereby the full-length comparisons in these cases partially require fewer LUTs. In rare cases, with a B = 1, even longer strings can be completely confused with other regularly occurring strings, as can be seen for the string s1(”tolls amount”), which contains the same letters as the string ”total amount”. Here, however, a favorable solution can be found with a B = 2. All in all, there are three interesting variants for our RFs. For long strings, an FPR of 0 can usually be achieved for B = 1 with a minimum of resources. For all other cases B = 2 is usually advantageous, but in some cases a full length comparison is also preferable. Accordingly, the search space for following evaluations of the RiotBench concentrates on B ∈ {1, 2, N}, where B = N corresponds to string matching option (ii). b. number range filtering For scanning a byte stream to contain specific integer, float, or time stamp values or even value ranges, we propose to filter the stream with deterministic finite automatas (DFAs). For this, a regular expression for the value (range) is first derived and then converted into a DFA to be synthesized for the FPGA. Figure 2 illustrates the process for detecting integers greater or equal to 35 (i ≥ 35) in a byte stream. The same approach is used for deriving a regex for upper bounds (e.g., i ≤ 35). The comparison against a range of values, i.e. with an upper and a lower bound, can still be performed with only one automaton, which can later be optimized better than two separate automata and thus requires fewer resources overall. Building these DFAs for floating-point numbers is done similarly. After the decimal point, we just continue to check the given bounds for the decimal places. Nevertheless, there is one major difference between floats and integers which can’t be mapped into DFAs easily. The JSON specification allows an exponent format (e.g., 2.1e3), which is virtually impossible to match via state machines. That’s because of the almost unlimited possibilities to format the same number (e.g., 1e+1, 10, 100e-1, . . . ). As a remedy, we accept any number, including at least one digit followed by an ’e’ or an ’E’. In such a case, the raw filter primitive might create a false-positive, but at least no false-negative. In step 2 the regular expression is converted into a DFA and minimized.Methods to achieve this are already well known and won’t be explained here. The DFA is evaluated every time a non-numeric (including ’+’, ’-’, ’.’, ’e’) character is seen, as it has to mark the end of the number. At this point, the value filter omits a ’1’ if the last state was an accepted state, or a ’0’ if the last state wasn’t accepted. The DFA is then reseted and starts over from state s0. The shown method is not only valid for numerical filters, but can also be used for date formats or any other filter which can be represented using regular expressions. A number matcher for an integer i or a float f with a lower bound ℓ and an upper bound u is denoted in the following as ℓ ≤ i ≤ u or ℓ ≤ f ≤ u, respectively. c. structural awareness In many scenarios, applications require some degree of structural awareness. However, this doesn’t mean that we have to parse the full structure of a given record. Instead, we propose to observe only those elements which help us the most with reducing the number of false-positives. As already shown in the introductory example, it can be advantageous to observe object structures, especially for filtering IoT data, since sensor values are commonly stored together with metadata in an object. This is also evident for the Sensor Measurement Lists (SenML) standard used in running example (Listing 1), where a JSON record is defined over an array of sensor measurements. Since such sensor-
measurement objects usually contain the same attributes for all objects, key-value relationships are hardly relevant for filtering (see Listing 1 where the keys ”v”, ”u”, and ”n” appear in all objects of the record). For more conventional JSON data, such as statistics gathered from web service APIs (e.g., Twitter2), key-value relationships are much more important, since the keys are usually only represented once in the entire record and can thus be used as a unique identifier. This sensitivity for nesting levels is achieved by incrementing a counter with every ’[’,’{’and decrementing it with every ’}’,’]’. As this counter has to be consistent at any time, it’s necessary to detect if a bracket is part of a string and should therefore not be used to alter the nesting level. Detecting strings, however, requires checking if a quote ” is escaped by a ’\’ character. And \can again be escaped by \\. This information can then be used to build a string mask and consequently to correctly determine the nesting levels. Detecting key-value pairs can be done using the same method. Instead of tracking the nesting levels we just need to check that the key RF and the value RF both appear before the same unescaped comma. Two RFs (RF1, RF2) appearing on the same nesting level are denoted as {RF1 & RF2} in the following. d. design flow The design flow for generating an optimized raw filter for a given query can be broken down into four steps. i) Extract search strings and value ranges from the query. ii) Select corresponding primitives and their parameters that should be tested (in our case: values for block length B). iii) Determine possible combinations that constitute the design space: (a) Primitives that appear in the same context could be combined via structural-aware filtering or without. (b) Primitives in and-clauses can be omitted to reduce the raw filter size as long as one primitive remains. For or-clauses, however, all input expressions must be considered, to prohibit false-negatives. Finally, iv) the design space is explored to determine design points that are optimal, e.g., with respect to FPR and resource requirements. Section IV exemplifies the design flow for an IoT benchmark. iv. raw filter evaluation In the following, we evaluate the most interesting design points for three different queries and present an example system that implements the best implementation for one of these queries. a. analysis of the design space For our evaluations, we used three different queries operating on two different datasets, from the RiotBench. The queries QS0 & QS1 run on a SmartCity dataset, composed of different sensor measurements (e.g., temperature, humidity). The third Query QT uses a Taxi dataset, where each record corresponds to one Taxi trip (containing attributes like trip distance, fare amount). The queries are shown in Table VIII. Following the design flow from Section III-D, we extracted all primitives; i.e., five string matchers (each with the option to be implemented with B ∈ {1, 2, N}) and five number
2https://developer.twitter.com/en/docs/twitter-api
range checks. Additionally, the information which RFs could utilize information about the structure is extracted. All possible configurations are then generated and individually evaluated with respect to resource requirements (LUTs on the FPGA) and FPR over the complete data set. The tested design points are illustrated in Figure 3. Tables V to VII provide the found pareto-optima. For QS1 and QT, we can see that filtering for only 1-2 attributes already achieves a very low FPR, as our queries are more selective over certain attributes. Since all attribute filters here are connected by an and, all but one filter may be omitted, as can be seen for the configurations obtained. For IoT-Data it’s quite common that some attributes highly correlate with each other. E.g., in the taxi dataset the attributes trip time in secs and fare amount are highly dependent on the attribute trip distance. Hence, it’s sufficient to filter only one of these attributes. In other cases, we observed that value distributions of some attributes do not overlap with those of the other attributes. This can be seen for the ”light” attribute, where the light values are mostly > 1000, while the other attributes are mostly < 1000. Accordingly, it can be sufficient to only filter the value range without checking the attributes name. This can be seen for the second Pareto point in QS1 which already obtains a low FPR without searching for the search string ”light”. If we look at the Pareto points independently of the underlying configurations, we notice that the FPRs and the LUTs cannot be mapped linearly to each other. Especially at the ends of the tables, strong deviations can be seen. For example, for QS1, a minimally higher FPR of 0.008 compared to 0.0 requires less than half the resources (103 instead of 223 LUTs). Accordingly, it may be worthwhile to allow a low FPR to save resources. TABLE VIII: RiotBench queries as used in the evalution. Query Name Filter expression Selectivity (%)
SmartCity 0 (QS0)
(0.7 ≤ "temperature" ≤ 35.1) AND (20.3 ≤ "humidity" ≤ 69.1) AND (0 ≤ "light" ≤ 5153) AND (83.36 ≤ "dust" ≤ 3322.67) AND (12 ≤ "airquality_raw" ≤ 49)
63.9
SmartCity 1 (QS1)
(-12.5 ≤ "temperature" ≤ 43.1) AND (10.7 ≤ "humidity" ≤ 95.2) AND (1345 ≤ "light" ≤ 26282) AND (186.61 ≤ "dust" ≤ 5188.21) AND (17 ≤ "airquality_raw" ≤ 363)
5.4
Taxi (QT) (140 ≤ "trip_time_in_secs" ≤ 3155) AND (0.65 ≤ "tip_amount" ≤ 38.55) AND (6.00 ≤ "fare_amount" ≤ 201.00) AND (2.50 ≤ "tolls_amount" ≤ 18.00) AND (1.37 ≤ "trip_distance" ≤ 29.86) 5.7
Network interface
RF RF
RF RF
RF RF
RF
Raw filters
DMA
Programmable Logic
PCIe
RAM
Core Core
CPU System
Fig. 4: Overview of the proposed architecture for filtering raw byte streams. b. system architecture The RFs have been evaluated on a Xilinx ZC706 Zynq-7000 SoC. Figure 4 depicts the architecture of our system, based on [2], consisting of a tightly coupled processor system (PS) and programmable logic (PL). We built 7 parallel pipelined RFs, each processing one byte per cycle, leading to a theoretical bandwidth of 1.4 GB/s at a clock rate of 200 MHz. In our experiment, 44 MB of inflated JSON data from the RiotBench was preloaded into the RAM and transferred to the RFs using DMA. The results, containing only the match signals, were again written back to the RAM using DMA. In the experiment a data rate of 1.33 GB/s could be achieved, which is sufficient to process incoming data from a 10 GBit/s network interface at line rate. Accordingly, our system would also be suitable for passing the ingress data from a network interface directly to the RFs. The filtered data can then be transferred with the DMA into the RAM, in order to process the data directly on the on-chip ARM CPU. Such a setup could be used, for example, as an IoT gateway that directly performs pre-processing of the received data. Alternatively, a SmartNIC can be implemented by forwarding the filtered data to a host CPU via PCIe. Thus, the RFs can significantly increase the achieved data rate or relieve the host CPU without a risk of performance degradation. Since the presented RFs require only a small amount of resources, even more RFs can be used to process multiple data streams in parallel. Furthermore, the programmable logic can be reconfigured, allowing the RFs to be replaced when a new query is to be executed. v. conclusion and future work Raw filters have the potential to relieve the CPU workload and create a potential speedup for CPU-bound stream processing applications. Even for I/O-bound applications, it may be possible to free up CPU cycles. Unlike CPU-based solutions, our versatile primitives allow us to filter a variety of different data sets. Moreover, the RFs can be configured
in such a way that the best possible FPR is achieved for a given resource requirement. Currently, the RFs are created manually by brute force searching for Pareto points.