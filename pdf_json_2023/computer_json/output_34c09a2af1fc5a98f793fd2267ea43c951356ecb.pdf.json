{
    "abstractText": "In this paper, we study the concurrent composition of interactive mechanisms with adaptively chosen privacy-loss parameters. In this setting, the adversary can interleave queries to existing interactive mechanisms, as well as create new ones. We prove that every valid privacy filter and odometer for noninteractive mechanisms extends to the concurrent composition of interactive mechanisms if privacy loss is measured using (\u03b5, \u03b4)-DP, f -DP, or R\u00e9nyi DP of fixed order. Our results offer strong theoretical foundations for enabling full adaptivity in composing differentially private interactive mechanisms, showing that concurrency does not affect the privacy guarantees. We also provide an implementation for users to deploy in practice.",
    "authors": [
        {
            "affiliations": [],
            "name": "Samuel Haney"
        },
        {
            "affiliations": [],
            "name": "Michael Shoemate"
        },
        {
            "affiliations": [],
            "name": "Grace Tian"
        },
        {
            "affiliations": [],
            "name": "Salil Vadhan"
        },
        {
            "affiliations": [],
            "name": "Andrew Vyrros"
        },
        {
            "affiliations": [],
            "name": "Vicki Xu"
        },
        {
            "affiliations": [],
            "name": "Wanrong Zhang"
        }
    ],
    "id": "SP:b7ab9e814748706f82d0ee9725102db5a86d89c7",
    "references": [
        {
            "authors": [
                "Skye Berghel",
                "Philip Bohannon",
                "Damien Desfontaines",
                "Charles Estes",
                "Sam Haney",
                "Luke Hartman",
                "Michael Hay",
                "Ashwin Machanavajjhala",
                "Tom Magerlein",
                "Gerome Miklau",
                "Amritha Pai",
                "William Sexton",
                "Ruchit Shrestha"
            ],
            "title": "Tumult Analytics: a robust, easy-to-use, scalable, and expressive framework for differential privacy",
            "venue": "arXiv preprint arXiv:2212.04133",
            "year": 2022
        },
        {
            "authors": [
                "Mark Bun",
                "Thomas Steinke"
            ],
            "title": "Concentrated differential privacy: Simplifications, extensions, and lower bounds",
            "venue": "In Theory of Cryptography Conference",
            "year": 2016
        },
        {
            "authors": [
                "Cynthia Dwork",
                "Krishnaram Kenthapadi",
                "Frank McSherry",
                "Ilya Mironov",
                "Moni Naor"
            ],
            "title": "Our data, ourselves: Privacy via distributed noise generation",
            "venue": "In Annual international conference on the theory and applications of cryptographic techniques",
            "year": 2006
        },
        {
            "authors": [
                "Cynthia Dwork",
                "Moni Naor",
                "Toniann Pitassi",
                "Guy N. Rothblum"
            ],
            "title": "Differential privacy under continual observation",
            "venue": "In Proceedings of the 42nd ACM Symposium on Theory of Computing (STOC",
            "year": 2010
        },
        {
            "authors": [
                "Cynthia Dwork",
                "Moni Naor",
                "Omer Reingold",
                "Guy N. Rothblum",
                "Salil P. Vadhan"
            ],
            "title": "On the complexity of differentially private data release: efficient algorithms and hardness results",
            "venue": "In Proceedings of the 41st ACM Symposium on Theory of Computing (STOC",
            "year": 2009
        },
        {
            "authors": [
                "Cynthia Dwork",
                "Aaron Roth"
            ],
            "title": "The algorithmic foundations of differential privacy",
            "venue": "Foundations and Trends in Theoretical Computer Science 9,",
            "year": 2014
        },
        {
            "authors": [
                "Cynthia Dwork",
                "Guy N Rothblum"
            ],
            "title": "Concentrated differential privacy",
            "venue": "arXiv preprint arXiv:1603.01887",
            "year": 2016
        },
        {
            "authors": [
                "Cynthia Dwork",
                "Guy N Rothblum",
                "Salil Vadhan"
            ],
            "title": "Boosting and differential privacy",
            "venue": "In 2010 IEEE 51st Annual Symposium on Foundations of Computer Science",
            "year": 2010
        },
        {
            "authors": [
                "Vitaly Feldman",
                "Tijana Zrnic"
            ],
            "title": "Individual Privacy Accounting via a Renyi Filter",
            "venue": "arXiv preprint arXiv:2008.11193",
            "year": 2022
        },
        {
            "authors": [
                "Marco Gaboardi",
                "Michael Hay",
                "Salil Vadhan"
            ],
            "title": "A programming framework for opendp",
            "year": 2020
        },
        {
            "authors": [
                "Moritz Hardt",
                "Guy N Rothblum"
            ],
            "title": "A multiplicative weights mechanism for privacy-preserving data analysis",
            "venue": "In 2010 IEEE 51st annual symposium on foundations of computer science",
            "year": 2010
        },
        {
            "authors": [
                "Peter Kairouz",
                "Sewoong Oh",
                "Pramod Viswanath"
            ],
            "title": "The composition theorem for differential privacy",
            "venue": "In International conference on machine learning",
            "year": 2015
        },
        {
            "authors": [
                "Mathias L\u00e9cuyer"
            ],
            "title": "Practical Privacy Filters and Odometers with R\\\u2019enyi Differential Privacy and Applications to Differentially Private Deep Learning",
            "venue": "arXiv preprint",
            "year": 2021
        },
        {
            "authors": [
                "Xin Lyu"
            ],
            "title": "Composition Theorems for Interactive Differential Privacy",
            "venue": "In Thirty-sixth Conference on Neural Information Processing Systems",
            "year": 2022
        },
        {
            "authors": [
                "Ilya Mironov"
            ],
            "title": "R\u00e9nyi differential privacy",
            "venue": "IEEE 30th Computer Security Foundations Symposium (CSF)",
            "year": 2017
        },
        {
            "authors": [
                "Jack Murtagh",
                "Salil Vadhan"
            ],
            "title": "The complexity of computing the optimal composition of differential privacy",
            "venue": "In Theory of Cryptography",
            "year": 2016
        },
        {
            "authors": [
                "Ryan Rogers",
                "Aaron Roth",
                "Jonathan Ullman",
                "Salil Vadhan"
            ],
            "title": "Privacy Odometers and Filters: Pay-as-you-Go Composition",
            "year": 2021
        },
        {
            "authors": [
                "Salil Vadhan",
                "Tianhao Wang"
            ],
            "title": "Concurrent Composition of Differential Privacy",
            "venue": "In Theory of Cryptography Conference",
            "year": 2021
        },
        {
            "authors": [
                "Salil Vadhan",
                "Wanrong Zhang"
            ],
            "title": "Concurrent Composition Theorems for Differential Privacy",
            "venue": "In 55th Annual ACM Symposium on Theory of Computing",
            "year": 2023
        },
        {
            "authors": [
                "Tim Van Erven",
                "Peter Harremos"
            ],
            "title": "R\u00e9nyi divergence and Kullback-Leibler divergence",
            "venue": "IEEE Transactions on Information Theory 60,",
            "year": 2014
        }
    ],
    "sections": [
        {
            "text": "CCS CONCEPTS \u2022 Theory of computation\u2192 Interactive computation;Concurrent algorithms; \u2022 Security and privacy\u2192 Privacy-preserving protocols; Privacy protections.\nKEYWORDS Differential Privacy, Interactive Mechanisms, Concurrent Composition, Adaptivity\nACM Reference Format: Samuel Haney, Michael Shoemate, Grace Tian, Salil Vadhan, Andrew Vyrros, Vicki Xu, and Wanrong Zhang. 2023. Concurrent Composition for Interactive Differential Privacy with Adaptive Privacy-Loss Parameters. In Proceedings of the 2023 ACM SIGSAC Conference on Computer and Communications\nPermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. CCS \u201923, November 26\u201330, 2023, Copenhagen, Denmark \u00a9 2023 Copyright held by the owner/author(s). Publication rights licensed to ACM. ACM ISBN 979-8-4007-0050-7/23/11. . . $15.00 https://doi.org/10.1145/3576915.3623128\nSecurity (CCS \u201923), November 26\u201330, 2023, Copenhagen, Denmark. ACM, New York, NY, USA, 19 pages. https://doi.org/10.1145/3576915.3623128"
        },
        {
            "heading": "1 INTRODUCTION",
            "text": ""
        },
        {
            "heading": "1.1 Differential Privacy",
            "text": "Differential privacy is a framework for protecting the privacy of individuals when analyzing data. It is a mathematical definition of privacy that that ensures that the results of an analysis do not reveal too much information about any individual in the dataset. Because of its powerful worst-case guarantee, differential privacy has become a leading approach in privacy-preserving data analysis, where it is used to enable the analysis of sensitive data while preserving the privacy of individuals.\nDifferential privacy can be defined in terms of a general database space X and a binary neighboring relation on X. For example, if databases contain an ordered and known number \ud835\udc5b of real-valued entries, then X = R\ud835\udc5b . The binary relation on X specifies which datasets are neighboring, meaning that they differ on one individual\u2019s data. For example, if \ud835\udc65 = R\ud835\udc5b , then \ud835\udc65, \ud835\udc65 \u2032 \u2208 X are neighboring if they differ on one coordinate. Differential privacy requires that the output distributions should be roughly the same on the two neighboring datasets.\nDefinition 1.1 (Differential Privacy). A randomized mechanismM : X \u2192 R is (\ud835\udf16, \ud835\udeff)-differentially private if for every pair of neighboring datasets \ud835\udc65, \ud835\udc65 \u2032 \u2208 X, and for every subset of possible outputs S \u2286 R,\n\ud835\udc43\ud835\udc5f [M(\ud835\udc65) \u2208 S] \u2264 exp(\ud835\udf16) \u00b7 \ud835\udc43\ud835\udc5f [M(\ud835\udc65 \u2032) \u2208 S] + \ud835\udeff.\nBy requiring that an analysis be robust to changes in neighboring datasets, differential privacy provides a guarantee that the privacy of individuals in the dataset is protected, regardless of what other data might be included or excluded.\nIn recent years, other forms of differential privacy have enjoyed use to address various shortcomings of (\ud835\udf16, \ud835\udeff)-DP (also known as approximate-DP) regarding composition. Some standard variants include R\u00e9nyi DP (RDP) [17], \ud835\udc53 -DP [3] (the formal definition is given\nar X\niv :2\n30 9.\n05 90\n1v 1\n[ cs\n.C R\n] 1\nin Section 3), and zero-concentrated differential privacy (zCDP) [2, 8].\nDefinition 1.2 (R\u00e9nyi divergence [19]). For two probability distributions \ud835\udc43 and \ud835\udc44 , the R\u00e9nyi divergence of order \ud835\udefc > 1 is\n\ud835\udc37\ud835\udefc (\ud835\udc43 | |\ud835\udc44) = 1 \ud835\udefc \u2212 1 log E\ud835\udc65\u223c\ud835\udc44 [ \ud835\udc43 (\ud835\udc65) \ud835\udc44 (\ud835\udc65) ]\ud835\udefc .\nDefinition 1.3 (R\u00e9nyi DP [17]). A randomized mechanismM is (\ud835\udefc, \ud835\udf16)-R\u00e9nyi differentially private (\ud835\udf16-RDP\ud835\udefc ) if for all every two neighboring datasets \ud835\udc65 and \ud835\udc65 \u2032,\n\ud835\udc37\ud835\udefc (M(\ud835\udc65) | |M(\ud835\udc65 \u2032)) \u2264 \ud835\udf16"
        },
        {
            "heading": "1.2 Composition of Differentially Private Mechanisms",
            "text": "A fundamental question in differential privacy concerns how privacy degrades under multiple mechanisms run on the same database.\n1.2.1 Composition Theorems for Noninteractive Mechanisms. Definition 1.1 defines differential privacy for noninteractive mechanisms M. Composition for such noninteractive mechanisms has been extensively studied in the literature. We will denote the (noninteractive, non-adaptive) composition of \ud835\udc58 noninteractive mechanisms M1, . . . ,M\ud835\udc58 on a dataset \ud835\udc65 asM := \ud835\udc36\ud835\udc5c\ud835\udc5a\ud835\udc5d (M1, . . . ,M\ud835\udc58 ), where M(\ud835\udc65) returnsM1 (\ud835\udc65), . . . ,M\ud835\udc58 (\ud835\udc65), with eachM \ud835\udc57 executed independently on its own random coins.\nBasic composition of (\ud835\udf16, \ud835\udeff)-differential privacy [4] finds that the privacy-loss parameters scale at most linearly with the number of mechanisms composed. Advanced composition [9] provides a tighter bound where the parameters scale sublinearly with the number of mechanisms, and optimal composition [13, 18] provides an exact guarantee of this composition. DP variants such as R\u00e9nyi DP, \ud835\udc53 -DP, and \ud835\udc67-CDP can provide tighter composition bounds by capturing more information about the mechanismsM\ud835\udc56 being composed than just the two parameters \ud835\udf16\ud835\udc56 and \ud835\udeff\ud835\udc56 .\n1.2.2 Composition Theorems for Interactive Mechanisms. While many differential privacy mechanisms are noninteractive, some mechanisms are expressly desired to be interactive, receiving and responding to adaptive queries from analysts. Examples include adaptive composition procedures [9], the Sparse Vector Technique [5\u20137], and Private Multiplicative Weights [12]. Thus, interactive mechanisms have been used as the basic abstraction in the programming frameworks of the open-source software project OpenDP [11] as well as the Tumult Analytics platform [14] [1]. An interactive mechanismM is a party interacting with an analyst adversary in an interactive protocol, wherein each party has its random coin, which captures the randomness used by the mechanism.\nDefinition 1.4 (Interactive Algorithms). An interactive algorithm, also known as a randomized state machine, consists of a randomized algorithm M : {0, 1}\u2217 \u00d7 {0, 1}\u2217 \u2192 {0, 1}\u2217 \u00d7 {0, 1}\u2217 that takes the current state \ud835\udc60 \u2208 {0, 1}\u2217, a query \ud835\udc5e \u2208 {0, 1}\u2217, and returns a new state \ud835\udc60\u2032 \u2208 {0, 1}\u2217 and an answer \ud835\udc4e \u2208 {0, 1}\u2217, written (\ud835\udc60\u2032, \ud835\udc4e) = M(\ud835\udc60, \ud835\udc5e). When we wish to make the randomness \ud835\udc5f ofM more explicit, we write (\ud835\udc60\u2032, \ud835\udc4e) =M(\ud835\udc60, \ud835\udc5e; \ud835\udc5f ).\nAn interactive algorithm interacts with an analyst or adversary A as follows.\nDefinition 1.5 (Interaction between two mechanisms). For two interactive algorithmsM and A, the interaction betweenM and A on an input \ud835\udc65 \u2208 {0, 1}\u2217 toM is the following random process (denoted (A \u2194M(\ud835\udc65))):\n(1) Initialize \ud835\udc60M1 := \ud835\udc65 , \ud835\udc5a0 = \ud835\udf06, \ud835\udc60 A 1 = \ud835\udf06, where \ud835\udf06 is the empty\nstring. (2) Repeat the following for \ud835\udc56 = 1, 2, . . .. (a) If \ud835\udc56 is odd, let (\ud835\udc60M\n\ud835\udc56+1,\ud835\udc5a\ud835\udc56 ) =M(\ud835\udc60 M \ud835\udc56 ,\ud835\udc5a\ud835\udc56\u22121) and \ud835\udc60A\ud835\udc56+1 = \ud835\udc60 A \ud835\udc56 .\n(b) If \ud835\udc56 is even, let (\ud835\udc60A \ud835\udc56+1,\ud835\udc5a\ud835\udc56 ) = A(\ud835\udc60 A \ud835\udc56 ,\ud835\udc5a\ud835\udc56\u22121) and \ud835\udc60M\ud835\udc56+1 = \ud835\udc60 M \ud835\udc56\n. (c) if\ud835\udc5a\ud835\udc56 = halt, then exit loop.\nIn the context of DP, think of the input \ud835\udc65 as a sensitive dataset that needs to be protected. In this context, an interactive mechanism is a randomized state machine whose input space upon initialization is the space of datasets X, and takes in a database \ud835\udc65 \u2208 X. An adversary is a randomized state machine that takes in an empty string. The view of an adversary captures everything the adversary receives during the execution.\nDefinition 1.6 (View of the adversary in an interactive mechanism). Let M be an interactive mechanism and A be an adversary interacting with the mechanism. A\u2019s view of (A,M(\ud835\udc65)) is the tuple ViewA (A \u2194M(\ud835\udc65)) = (\ud835\udc5f0,\ud835\udc5a1, \ud835\udc5f2,\ud835\udc5a3, \ud835\udc5f4, . . .) consisting of all the messages\ud835\udc5a\ud835\udc56 received by A fromM together with random coins \ud835\udc5f\ud835\udc56 thatA tosses when computing\ud835\udc5a\ud835\udc56 (i.e. for even \ud835\udc56 , (\ud835\udc60\ud835\udc56+1,\ud835\udc5a\ud835\udc56 ) = A(\ud835\udc60A\n\ud835\udc56 ,\ud835\udc5a\ud835\udc56\u22121; \ud835\udc5f\ud835\udc56 )).\nFor shorthand, we will drop the subscript A when referring to View for the rest of this paper, because future references to View in the rest of this paper always concern the adversary\u2019s view.\nWe can define interactive differential privacy based onmeasuring the same (\ud835\udf16, \ud835\udeff)-closeness, as in noninteractive differential privacy, between the views of the adversary on two neighboring datasets.\nDefinition 1.7 ((\ud835\udf16, \ud835\udeff)-DP interactive mechanisms). An interactive mechanismM is an (\ud835\udf16, \ud835\udeff)-differentially private interactive mechanism, or I.M. for short, if for every pair of neighboring datasets \ud835\udc65, \ud835\udc65 \u2032 \u2208 X, every interactive adversary algorithmA, and every subset of possible views S \u2286 Range(View) we have \ud835\udc43\ud835\udc5f [View(A \u2194M(\ud835\udc65)] \u2208 S) \u2264 \ud835\udc52\ud835\udf16\ud835\udc43\ud835\udc5f [View(A \u2194M(\ud835\udc65 \u2032)) \u2208 S]+\ud835\udeff.\nTo capture variants such as R\u00e9nyi DP and \ud835\udc53 -DP, we will define a broader version of I.M.s based on a generalized notion of differential privacy in Section 2.\nWhen we consider the composition of interactive mechanisms, it is straightforward to extend the composition theorems for noninteractive mechanisms to the sequential composition of interactive mechanisms. A subtler case is the concurrent composition, in which an adversary can interleave queries to multiple mechanisms concurrently, first studied by Vadhan and Wang [21]. The queries can therefore depend on the answers received from other mechanisms. This is useful in many practical settings. For example, an analyst may run data analyses using multiple interactive analyses on the same dataset simultaneously and the queries in multiple analyses might be correlated. Concurrent composition, formally defined in Section 2.1, maintains \ud835\udc58 interactive mechanismsM1, . . . ,M\ud835\udc58 . It is\nitself an interactive mechanism and the query it received from an adversary is of the form of ( \ud835\udc57, \ud835\udc5e), meaning it issues a standard query \ud835\udc5e toM \ud835\udc57 . Concurrent composition theorems allow us to understand the privacy guarantee of the overall analysis given the privacy guarantees for each interactive analysis when they are executed independently.\nPrevious work provides concurrent composition theorems for several different types of differential privacy. Vadhan and Wang [21] shows that every composition theorem for noninteractive \ud835\udf16- DP mechanisms extends to concurrent composition for interactive \ud835\udf16-DP mechanisms. Lyu [16] and Vadhan and Zhang [22] generalize this result to (\ud835\udf16, \ud835\udeff)-DP when \ud835\udeff > 0.\nTheorem 1.8 ([16, 22]). Suppose that for all noninteractive mechanisms M1, . . . ,M\ud835\udc58 such that M\ud835\udc56 is (\ud835\udf16\ud835\udc56 , \ud835\udeff\ud835\udc56 )-DP for \ud835\udc56 = 1, . . . , \ud835\udc58 , their composition Comp(M1, . . . ,M\ud835\udc58 ) is (\ud835\udf16, \ud835\udeff)-DP. Then for all interactive mechanismsM1, . . . ,M\ud835\udc58 with finite communication1 such thatM\ud835\udc56 is (\ud835\udf16\ud835\udc56 , \ud835\udeff\ud835\udc56 )-DP for \ud835\udc56 = 1, . . . , \ud835\udc58 , their concurrent composition ConComp(M1, . . . ,M\ud835\udc58 ) is (\ud835\udf16, \ud835\udeff)-DP.\nThis composition theorem also extends to \ud835\udc53 -DP [22]. Moreover, Lyu [16] shows that the privacy adds up under concurrent composition for any fixed order of \ud835\udefc > 1 for R\u00e9nyi DP (RDP).\nTheorem 1.9 ([16]). For all \ud835\udefc > 1, \ud835\udc58 \u2208 N, \ud835\udf161, . . . , \ud835\udf16\ud835\udc58 > 0, and all interactive mechanismsM1, . . . ,M\ud835\udc58 such thatM\ud835\udc56 is (\ud835\udefc, \ud835\udf16\ud835\udc56 )-RDP for \ud835\udc56 = 1, 2 . . . , \ud835\udc58 , their concurrent composition ConComp(M1, . . . ,M\ud835\udc58 ) is (\ud835\udefc,\u2211\ud835\udc58\ud835\udc56=1 \ud835\udf16\ud835\udc56 )-RDP.\nIn all of the above cases, privacy-loss parameters are set upfront prior to data analysis and are fixed for all queries or computations performed on the data. However, in practice, data analysts may not know in advance what they want to do with the data and may want to adaptively choose the privacy-loss parameters of subsequent mechanisms as they go along. This can lead to more efficient use of privacy resources. For example, we may wish to spend more privacy-loss budget on fine-grained analysis, and less privacy-loss budget on exploratory analysis. Therefore, allowing full adaptivity where not only the mechanisms, but also the privacyloss parameters themselves and the length of the composition can be chosen adaptively as a function of intermediate analyses, is important in practice. This consideration motivates the study of privacy filters and odometers, which we discuss in the following section."
        },
        {
            "heading": "1.3 Odometers and Filters",
            "text": "Rogers, Roth, Ullman, and Vadhan [20] define two primitives for the adaptive composition of DP mechanisms, privacy filters and privacy odometers, to allow for the ability to track privacy loss during an interaction. Their definitions were given specifically for (\ud835\udf16, \ud835\udeff)-DP; here we follow L\u00e9cuyer [15] and work with a more general formalism that applies to arbitrary privacy measures, including \ud835\udc53 -DP and R\u00e9nyi-DP.\nA privacy filter is a mechanism that halts computation on a dataset once a preset privacy-loss budget is exceeded. It takes a global privacy-loss budget as an input and is equipped with a continuation rule that halts computation whenever the budget is exceeded. 1Their proof relies on an induction argument on the number of messages exchanged, which requires an assumption of finite communication.\nAt each round, the continuation rule takes all privacy-loss parameters up to the current round, and outputs either continue or halt. If continue, the mechanism answers the query with the current privacy parameter. Once the mechanism outputs halt, no further computation is allowed. (An equivalent alternative is to refuse to answer the correct query, but allow the analyst to try again with new queries. However, the halt formulation is more convenient for presentation in this paper. For notational convenience in this paper, our algorithm pseudocode will have the filter go into a looping state that always returns the same state and a dummy message once halt is reached.) The filter guarantees that the interaction is differentially private according to the desired privacy-loss budget.\nDefinition 1.10 (F -filtered composition of noninteractive (\ud835\udf16, \ud835\udeff)-DP mechanisms (F -Filt(NIM))). Let F be a continuation rule that takes in a sequence of privacy-loss parameters (\ud835\udf161, \ud835\udeff1), . . . , and a target privacy-loss budget (\ud835\udf16, \ud835\udeff), and maps to a binary decision: F : R\u2217\u22650\u00d7R \u2217 \u22650\u00d7R\u22650\u00d7R\u22650 \u2192 {0, 1}, where 1means continue and 0 means halt, and R\u2217\u22650 = \u222a \u221e \ud835\udc58=0R\n\ud835\udc58 . The F -filtered composition of noninteractivemechanisms, denoted asF -Filt(NIM), is an interactive mechanism. At the (\ud835\udc58 + 1)th round, F (\u00b7; (\ud835\udf16, \ud835\udeff))-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40) (\ud835\udc60,\ud835\udc5a) is executed as follows:\n(1) If\ud835\udc5a = \ud835\udf06, initialize \ud835\udc60 = (\ud835\udc60, []), where [] is an empty list. Return (\ud835\udc60, \ud835\udf06), where \ud835\udf06 is an empty string. (2) Parse \ud835\udc60 = (\ud835\udc65, [(M1, (\ud835\udf161, \ud835\udeff1)), . . . , (M\ud835\udc58\u22121, (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 ))]) (3) IfM\ud835\udc58+1 is (\ud835\udf16\ud835\udc58+1, \ud835\udeff\ud835\udc58+1)-DP andF ((\ud835\udf161, \ud835\udeff1), . . . , (\ud835\udf16\ud835\udc58+1, \ud835\udeff\ud835\udc58+1); (\ud835\udf16, \ud835\udeff)) =\n1: (a) Let \ud835\udc60\u2032 = (\ud835\udc65, [(M1, (\ud835\udf161, \ud835\udeff1)), . . . , (M\ud835\udc58+1, (\ud835\udf16\ud835\udc58+1, \ud835\udeff\ud835\udc58+1))]) (b) Let\ud835\udc5a\u2032 =M\ud835\udc58+1 (\ud835\udc65)\n(4) Else, let \ud835\udc60\u2032 = \ud835\udc60 ,\ud835\udc5a\u2032 = halt\nNote that at each round \ud835\udc58 of computation, whether the mechanismM\ud835\udc58 is (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 )-DP is something the implementation needs to be able to verify, e.g. by having verified privacy-loss parameters attached to every mechanism.\nDefinition 1.11 (Valid (\ud835\udf16, \ud835\udeff)-DP filter for noninteractive mechanisms). We say a continuation rule F is a valid (\ud835\udf16, \ud835\udeff)-DP NIM-filter for noninteractive mechanisms if for every pair of (\ud835\udf16, \ud835\udeff), F (\u00b7; (\ud835\udf16, \ud835\udeff))-Filt(NIM)(\u00b7) is an (\ud835\udf16, \ud835\udeff)-DP interactive mechanism.\nA privacy odometer is a mechanism that allows the analyst to keep track of the privacy loss at each step of computation. It is equipped with a privacy-loss accumulator G, which gives an upper bound on the accumulated privacy loss at each step. We note that our terminology is slightly different from previous work by Rogers et al. [20], where they refer to the privacy-loss accumulator as the odometer, whereas our odometer is a mechanism that has a specially-designated privacy loss query. When posing this query, the mechanism outputs the current privacy loss up to that point.\nprivacy_loss queries are deterministic and do not change the state of the odometer. We will stipulate that they are encoded as binary strings in a fixed and recognizable way, such as using all strings that begin with a 1 to be privacy_loss queries, and all strings that begin with a 0 to be ordinary queries that can then be further parsed.\nDefinition 1.12 (G-odometer for composition of noninteractive mechanisms (G-Odom(NIM))). Let G be a privacy-loss\naccumulator that takes privacy-loss parameters (\ud835\udf161, \ud835\udeff1), . . . , (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 ) in a sequence, and maps to a global privacy loss (\ud835\udf16, \ud835\udeff), so G : R\ud835\udc58\u22650 \u00d7 R\ud835\udc58\u22650 \u2192 R\u22650 \u00d7 R\u22650, for every \ud835\udc58 = 1, 2, . . .. A G-odometer for composition of noninteractive mechanisms is denoted as G-Odom(NIM). G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a(\ud835\udc41\ud835\udc3c\ud835\udc40) (\ud835\udc60,\ud835\udc5a) is executed as follows:\n(1) If\ud835\udc5a = \ud835\udf06, initialize \ud835\udc60 = (\ud835\udc65, []), where [] is an empty list, and return (\ud835\udc60, \ud835\udf06) (2) Parse \ud835\udc60 = (\ud835\udc65, [(M1, (\ud835\udf161, \ud835\udeff1), . . . , (M\ud835\udc58 , (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 ))]) (3) If\ud835\udc5a = (M\ud835\udc58+1, (\ud835\udf16\ud835\udc58+1, \ud835\udeff\ud835\udc58+1)) andM\ud835\udc58+1 is (\ud835\udf16\ud835\udc58+1, \ud835\udeff\ud835\udc58+1)-DP: (a) Let \ud835\udc60\u2032 = (\ud835\udc65, [(M1, (\ud835\udf161, \ud835\udeff1), . . . , (M\ud835\udc58+1, (\ud835\udf16\ud835\udc58+1, \ud835\udeff\ud835\udc58+1))]) (b) Let\ud835\udc5a\u2032 =M\ud835\udc58+1 (\ud835\udc65) (4) If\ud835\udc5a = privacy_loss, then return G((\ud835\udf161, \ud835\udeff1), . . . , (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 )).\nTo measure the privacy loss at each round, we use truncated view of an adversary A interacting with G-Odom(NIM) as defined in Definition 1.13.\nDefinition 1.13 (View between adversary A with approximate-DP odometer O truncated at (\ud835\udf16, \ud835\udeff)). Given a privacy-loss parameter (\ud835\udf16, \ud835\udeff), an adversary A, and approximate-DP odometer O, Trunc(\ud835\udf16,\ud835\udeff ) (View(A \u2194 O(\ud835\udc65)) is constructed as follows:\n(1) Initialize \ud835\udc60M1 := \ud835\udc65 , \ud835\udc5a0 = \ud835\udf06, \ud835\udc60 A 1 = \ud835\udf06, where \ud835\udf06 is the empty\nstring. (2) Repeat the following for \ud835\udc56 = 1, 2, . . .. (a) If \ud835\udc56 is odd, let (\ud835\udc60M\n\ud835\udc56+1, \ud835\udc4e\ud835\udc56 ) := O(\ud835\udc60 M \ud835\udc56 , \ud835\udc5e\ud835\udc56\u22121), and let (\ud835\udc60M\ud835\udc56 , (\ud835\udf16\ud835\udc56 , \ud835\udeff\ud835\udc56 )) =\nO(\ud835\udc60M \ud835\udc56 , privacy-loss), \ud835\udc60A \ud835\udc56+1 = \ud835\udc60 A \ud835\udc56 .\n(b) If \ud835\udc56 is even, let (\ud835\udc60A \ud835\udc56+1, \ud835\udc5e\ud835\udc56 ) := A(\ud835\udc60 A \ud835\udc56 , \ud835\udc4e\ud835\udc56\u22121; \ud835\udc5fA\ud835\udc56 ) and \ud835\udc60 M \ud835\udc56+1 = \ud835\udc60 M \ud835\udc56\n. (c) If \ud835\udf16\ud835\udc56 \u2265 \ud835\udf16 or \ud835\udeff\ud835\udc56 \u2265 \ud835\udeff , then exit loop. (d) If \ud835\udc4e\ud835\udc56 = halt, then exit loop.\n(3) Return Trunc(\ud835\udf16,\ud835\udeff ) (View(A \u2194 O(\ud835\udc65)) = (\ud835\udc5fA0 , \ud835\udc4e1, . . . , \ud835\udc5f A \ud835\udc56\u22122, \ud835\udc4e\ud835\udc56\u22121).\nUsing truncated view for analyzing odometers is first introduced by L\u00e9cuyer [15] for RDP. We extend their definition to a general notion of truncated view, which allows us to quantify privacy loss with all other DP variants, where we can simply replace (\ud835\udf16, \ud835\udeff) with other privacy-loss parameters for other DP variants. In contrast, the previous definition of odometer in Rogers et al. [20] only holds for (\ud835\udf16, \ud835\udeff)-DP.\nThen the privacy guarantee of an odometer is defined as measuring the closeness between the distributions of the truncated views of an adversary.\nDefinition 1.14 (Valid approximate-DP privacy-loss accumulator for noninteractive mechanisms). We say G is a valid approximate-DP NIM-privacy-loss accumulator if G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a(\ud835\udc41\ud835\udc3c\ud835\udc40) is a valid approximate-DP odometer.\nDefinition 1.15 (Valid approximate-DP odometer for noninteractive mechanisms). We say O is a valid approximate-DP odometer if for every pair of (\ud835\udf16, \ud835\udeff), every adversary A, and every pair of adjacent datasets \ud835\udc65, \ud835\udc65 \u2032,\n\ud835\udc37 (Trunc(\ud835\udf16,\ud835\udeff ) (View(A \u2194 O(\ud835\udc65))) | | Trunc(\ud835\udf16,\ud835\udeff ) (View(A \u2194 O(\ud835\udc65 \u2032)))) \u2aaf (\ud835\udf16, \ud835\udeff),\nwhere \u2aaf is a partial order and (\ud835\udf161, \ud835\udeff1) \u2aaf (\ud835\udf161, \ud835\udeff1) iff \ud835\udf161 \u2264 \ud835\udf162 and \ud835\udeff1 \u2264 \ud835\udeff2.\nA number of previous works construct privacy filters and odometers for noninteractive mechanisms. The original odometer definition proposed by Rogers et al. [20] was defined specifically for (\ud835\udf16, \ud835\udeff)-DP and requires a simultaneous guarantee about the privacy loss being bounded at all points in time when composing with adaptive privacy-loss parameters. Specifically, the privacy loss is defined as Loss(\ud835\udc63) = log ( Pr[View(A\u2194O(\ud835\udc65 ) )=\ud835\udc63 ] Pr[View(A\u2194O(\ud835\udc65 \u2032 ) )=\ud835\udc63 ] ) , and the odometer is defined as follows.\nDefinition 1.16 (Odometer in [20]). We say G is a valid approximate DP odometer if for every adversary A in \ud835\udc58-fold composition with adaptive privacy-loss parameters, and every pair of adjacent datasets \ud835\udc65, \ud835\udc65 \u2032, the following holds with probability at most \ud835\udeff\ud835\udc54 over \ud835\udc63 \u2190 View(A \u2194 O(\ud835\udc65))\n|Loss(\ud835\udc63) | > G(\ud835\udf161, \ud835\udeff1, . . . , \ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 ) . Note that this definition yields a form of approximate DP in its final guarantee, because there is always a \ud835\udeff\ud835\udc54 probability of failure. Whitehouse, Ramdas, Rogers, and Wu [24] gave constructions of odometers and filters that quantitatively improve on the results presented in Rogers et al [20], including when the composed mechanisms satisfy zCDP or R\u00e9nyi DP (but their odometer only guarantees the same, (\ud835\udf16, \ud835\udeff) property of Definition 1.16). For providing R\u00e9nyi DP guarantees when composing R\u00e9nyi DP mechanisms, Feldman and Zrnic [10] constructed privacy filters. Definitions and constructions of privacy odometers for R\u00e9nyi DP were given by L\u00e9cuyer [15]. Our general definition of odometers follows L\u00e9cuyer\u2019s, which we find more natural and general, since it is applicable to all forms of DP. This definition can be thought of as being in analogy to the definition of a \ud835\udc5d-value in statistics. A \ud835\udc5d-value has an interpretation if we set a significance level \ud835\udefc before we observe our random events, and then reject the null hypothesis if the \ud835\udc5d-value is larger than \ud835\udefc . Similarly the privacy-loss reported by our odometer definition has an interpretation if we set a privacy-loss threshold (\ud835\udf16, \ud835\udeff) before the mechanism is executed and halt when the odometer\u2019s privacy-loss query is not going to be smaller than (\ud835\udf16, \ud835\udeff)."
        },
        {
            "heading": "1.4 Our Results on Concurrent Filters and Odometers",
            "text": "In this paper, we consider privacy filters and odometers for composing interactive mechanisms. We analogously define F -filtered sequential composition of interactive mechanisms, or F -FiltSeq(IM) for short, and F -filtered concurrent composition of interactive mechanisms, or F -FiltCon(IM) for short. The continuation rule F here determines whether the adversary can create new interactive mechanisms with adaptively-chosen privacy-loss parameters. Similarly, we define G-odometer for the sequential composition of interactive mechanisms, or G-OdomSeq(IM) for short, and Godometer for the concurrent composition of interactive mechanisms, or G-OdomCon(IM) for short. It should be noted that in both our filters and odometers, the \u201cprivacy-loss budget\" is paid at the launch of each additional interactive mechanism. In particular, any privacy_loss queries asked to the odometer between mechanism launches will return the same value.\nAs composition theorems for noninteractive mechanisms typically can be easily extended to the sequential composition of interactive mechanisms, we focus on the case of concurrent composition,\nas defined formally in Definition 2.4. In this setting, the adversary can interleave queries to existing interactive mechanisms. In the filter and odometer case, the adversary can also create new interactive mechanisms with adaptively-chosen privacy-loss parameters (for filters, with the added stiuplation that the privacy loss with the new interactive mechanism added does not exceed the privacy budget). The complex dependence between the adversary\u2019s interacting with the different mechanisms makes it non-trivial to extend filters and odometers to this case. Nevertheless, we prove that every valid privacy filter and odometer for noninteractive mechanisms extends to a privacy filter and odometer for interactive mechanisms for (\ud835\udf16, \ud835\udeff)-DP, \ud835\udc53 -DP, and RDP.\nDefinition 1.17 (Valid (\ud835\udf16, \ud835\udeff)-DP filter for interactive mechanisms). We say a continuation rule F is a valid (\ud835\udf16, \ud835\udeff)-DP IM-filter for interactive mechanisms if F (\u00b7; (\ud835\udf16, \ud835\udeff))-FiltCon(IM) is an (\ud835\udf16, \ud835\udeff)-DP interactive mechanism.\nDefinition 1.18 (Valid (\ud835\udf16, \ud835\udeff)-DP privacy-loss accumulator for interactive mechanisms). We say G is a valid approx-DP IMprivacy-loss accumulator if G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is a valid approx-DP odometer.\nTheorem 1.19 ((\ud835\udf16, \ud835\udeff)-DP filters and privacy-loss accumulators).\n(1) F is a valid (\ud835\udf16, \ud835\udeff)-DP NIM-filter if and only if F is a valid (\ud835\udf16, \ud835\udeff)-DP IM-filter. (2) G is a valid (\ud835\udf16, \ud835\udeff)-DP NIM-privacy-loss accumulator if and only if G is a valid (\ud835\udf16, \ud835\udeff)-DP IM-privacy-loss accumulator.\nTheorem 1.20 (\ud835\udc53 -DP filters and privacy-loss accumulators).\n(1) F is a valid \ud835\udc53 -DP NIM-filter if and only if F is a valid \ud835\udc53 -DP IM-filter. (2) G is a valid \ud835\udc53 -DP NIM-privacy-loss accumulator if and only if G is a valid \ud835\udc53 -DP IM-privacy-loss accumulator.\nTheorem 1.21 (RDP filters and privacy-loss accumulators). (1) F (\ud835\udf161, \ud835\udf162, . . . ; \ud835\udf16) = I( \u2211 \ud835\udc56 \ud835\udf16\ud835\udc56 \u2264 \ud835\udf16) is a valid (\ud835\udefc, \ud835\udf16)-RDP IM-filter\nfor every fixed order of \ud835\udefc > 1. (2) G(\ud835\udf161, . . . , \ud835\udf16\ud835\udc56 ) = \u2211\ud835\udc56 \ud835\udc56=1 \ud835\udf16\ud835\udc56 is a valid (\ud835\udefc, \ud835\udf16)-RDP IM-privacy loss\naccumulator for every fixed order of \ud835\udefc > 1.\nThese theorems offer strong theoretical foundations for enabling full adaptivity in composing differentially private interactive mechanisms. Firstly, they allow data analysts to adaptively choose privacy loss parameters as well as the subsequent interactive analyses. By adjusting the strength of the privacy guarantee to reflect the actual needs of the analysis as they go along, this important feature allows us to optimize the trade-off between privacy and utility. Second, our results are particularly useful for DP libraries. For example, OpenDP2 and Tumult Labs3 have interactive mechanisms as a core abstraction. Prior to our work, supporting adaptive selection of privacy-loss parameters has necessitated enforcing sequentiality on the use of interactive mechanisms. This restriction makes the libraries less user-friendly, as we cannot allow analysts or even DP 2https://opendp.org 3https://www.tmlt.io\nprograms interact with multiple interactive mechanisms simultaneously. Therefore, there is a gap between the existing and desired functionality. It also increases complexity in the libraries, necessitating a control system to prevent interleaving queries. Given the results in our paper, we can now remove this interleaving restriction, while maintaining the full adaptivity feature. We provide further discussion and our implementation for privacy filters and odometers for interactive mechanisms in Section 5."
        },
        {
            "heading": "1.5 Proof Strategy",
            "text": "In this section, we explain our proof strategy, and we defer the detailed proof to Section 3 and Section 4.\nTo prove the above theorems, our strategy is to leverage interactive postprocessing from interactive mechanisms to interactive mechanisms. We note that previous work [22] only considers interactive postprocessing from non-interactive mechanisms to interactive mechanisms. Here, we provide a general formulation called \u201cperson-in-the-middle\u201d, which is formally defined in Definition 2.15.\nA person-in-the-middle (PIM) mechanism is a randomized mechanism that acts as an interlocutor between two interacting mechanisms A andM. When A attempts to send a message toM, the PIM mechanism can undergo an interaction with A until finally passing on themessage at the end of this interaction toM. Similarly, whenM attempts to send a message toA, the PIM mechanism can interact withM to modify the message before passing it to A.\nThis construction of the postprocessing by PIM mechanism allows us the following theorem.\nTheorem 1.22 (Privacy preserved under postprocessing PIM mechanism, informally stated). If P is an interactive postprocessing mechanism andM is a differentially-private interactive mechanism with respect to any privacy measure (such as (\ud835\udf16, \ud835\udeff)-DP, \ud835\udc53 -DP, and R\u00e9nyi-DP), then P \u25e6 M is also differentially-private with the same privacy-loss parameters.\nA useful corollary follows from Theorem 1.22.\nCorollary 1.23. Suppose N is an interactive mechanism over database space X such that for every pair of neighboring datasets \ud835\udc65, \ud835\udc65 \u2032 and every deterministic adversary A, there exists an (\ud835\udf16, \ud835\udeff)-DP I.M.M and an interactive postprocessing P such that\nView(A \u2194 N(\ud835\udc65)) \u2261 View(A \u2194 P(M(\ud835\udc65))) View(A \u2194 N(\ud835\udc65 \u2032)) \u2261 View(A \u2194 P(M(\ud835\udc65 \u2032)))\nThen N is (\ud835\udf16, \ud835\udeff)-DP. We will use this corollary to prove Theorem 1.20. Our proof also relies on the following reduction theorem [22] showing that every interactive \ud835\udc53 -DP mechanism can be simulated by an interactive postprocessing of a noninteractive mechanism, for a fixed pair of neighboring datasets \ud835\udc65, \ud835\udc65 \u2032.\nTheorem 1.24 ([22]). For every trade-off function \ud835\udc53 , every interactive \ud835\udc53 -DP mechanismM with finite communication, and every pair of neighboring datasets \ud835\udc65, \ud835\udc65 \u2032, there exists a noninteractive \ud835\udc53 -DP mechanism N and a randomized interactive postprocessing mechanism P such that for every adversary A, we have\nView(A \u2194M(\ud835\udc65)) \u2261 View(A \u2194 P(N(\ud835\udc65))) View(A \u2194M(\ud835\udc65 \u2032)) \u2261 View(A \u2194 P(N(\ud835\udc65 \u2032)))\nTheorem 1.24 allows us to reduce the composition of interactive mechanismsM to the composition of noninteractive mechanisms N , as needed to prove Theorem 1.20. Fixing adjacent datasets \ud835\udc65, \ud835\udc65 \u2032, we can then define an interactive postprocessing P such that for every deterministic adversaryA, View(A \u2194 P\u25e6F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40)) \u2261 View(A \u2194 F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40)) on any database \ud835\udc65 . Therefore we can use composition theorems for noninteractive \ud835\udc53 -DP mechanisms to construct concurrent \ud835\udc53 -DP filters. Theorem 1.19 follows directly from Theorem 1.20, as \ud835\udc53 -DP captures (\ud835\udf16, \ud835\udeff)-DP as a special case. In fact, the special case of of Theorem 1.24 for (\ud835\udf16, \ud835\udeff)-DP was shown independently by Lyu [16].\nOur proof of Theorem 1.21 for RDP follows a different approach. Our proof relies on the concurrent composition theorem in Theorem 1.9 for two interactive RDPmechanisms, and our strategy is to apply induction on the number of mechanisms being composed.\nWhen composing two mechanisms (i.e. \ud835\udc3e = 2 in Theorem 1.21), by the concurrent composition theorem in Theorem 1.9, an adversary can only start a second mechanismM2 afterM1 if and only if its privacy-loss parameter \ud835\udf162 is at most \ud835\udf16 \u2212 \ud835\udf161, where \ud835\udf16 is the target privacy-loss budget and \ud835\udf161 is the privacy-loss parameter forM1. We define the following filter\nF2 (\ud835\udf161, . . . , \ud835\udf16\ud835\udc58 ; \ud835\udf16) = { I(\u2211\ud835\udc58\ud835\udc56=1 \ud835\udf16\ud835\udc56 \u2264 \ud835\udf16) if \ud835\udc58 \u2264 2 0 otherwise.\nF2 is a valid (\ud835\udefc, \ud835\udf16)-RDP IM-filter for composing two mechanisms. This is because if we fix a deterministic adversary A as Lemma 2.3 allows us to do, then M1, \ud835\udf161 are predetermined adaptively, which means that the adversary interacting with F2-FiltCon(IM) is equivalent to the adversary interacting with ConComp(M1,U2), whereU2 is a universal (\ud835\udefc, \ud835\udf16 \u2212 \ud835\udf161)-RDP mechanism, and the adversary\u2019s first query to U2 is an (\ud835\udefc, \ud835\udf162)-RDP mechanismM2. Upon verifying \ud835\udf162 \u2264 \ud835\udf16 \u2212 \ud835\udf161, U2 interacts with the adversary just as M2 (\ud835\udc65) does. We then apply an induction argument on the number of mechanisms being composed. For \ud835\udc3e > 2, we consider F\ud835\udc3e - \ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), which is a filter for composing up to \ud835\udc3e interactive mechanisms rather than two mechanisms. Assuming the privacy of F\ud835\udc3e\u22121-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), we argue that we can construct a postprocessing P interacting with F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) such that an adversary\u2019s interaction with P \u25e6 F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is equivalent to interacting with F\ud835\udc3e -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), allowing us to proceed by induction on \ud835\udc3e .\nCrucially, the proof for R\u00e9nyi DP uses the fact that R\u00e9nyi DP of a fixed order \ud835\udefc is measured by a single real number \ud835\udf16 , and the optimal composition theorem is additive, i.e. \ud835\udf16 = \ud835\udf161 + \u00b7 \u00b7 \u00b7 + \ud835\udf16\ud835\udc3e . This is not satisfied in (\ud835\udf16, \ud835\udeff)-DP or \ud835\udc53 -DP, hence we use a different strategy in Theorem 1.20, as discussed above.\nFeldman and Zrnic [10] prove that F (\ud835\udf161, \ud835\udf162, . . . ; \ud835\udf16) = I( \u2211 \ud835\udc56 \ud835\udf16\ud835\udc56 \u2264 \ud835\udf16) is a valid RDP NIM-filter for every fixed order of \ud835\udefc > 1. They construct a supermartingale for the privacy loss, and then apply the optional stopping theorem to bound the overall privacy loss when the algorithm halts. The main idea of our proof strategy is to leverage interactivity, which allows us to proceed by induction, describing F\ud835\udc58 in terms of F\ud835\udc58\u22121. This strategy can significantly simplify the proof in [10] of the privacy filter for even noninteractive RDP mechanisms, by similarly doing induction that uses the sequential composition of two interactive RDP mechanisms.\nWe then can convert this privacy filter to a valid RDP IM-privacy loss accumulator based on the following lemma.\nLemma 1.25. A function G is a valid RDP IM-privacy loss accumulator if and only if F (\u00b7; \ud835\udf16) = \ud835\udc3c (G(\u00b7) \u2264 \ud835\udf16) is a valid RDP IM-filter.\nWe give a generalized version of Lemma 1.25 in Section 2, meaning that an analogue of Lemma 1.25 also holds for all other variants of DP."
        },
        {
            "heading": "2 CONCURRENT FILTER AND ODOMETER",
            "text": ""
        },
        {
            "heading": "2.1 Preliminaries",
            "text": "Vadhan and Zhang [22] define the generalized notion of privacy, termed D DP, based on the following generalized probability distance. The distance is defined on a partially ordered set, which allows us to compare privacy guarantees at different protection levels. It should enjoy the postprocessing and joint convexity properties.\nDefinition 2.1 (Generalized probability distance [22]). A generalized probability distance measure is a tuple (D, \u2aaf, \ud835\udc37) such that\n(1) (D, \u2aaf) is a partially ordered set (poset). (2) \ud835\udc37 is a mapping that takes any two random variables \ud835\udc4b,\ud835\udc4b \u2032\nover the same measurable space to an element \ud835\udc37 (\ud835\udc4b,\ud835\udc4b \u2032) of D. (3) (Postprocessing.) The generalized distance mapping \ud835\udc37 is closed\nunder postprocessing, meaning that for every measurable function \ud835\udc54, \ud835\udc37 (\ud835\udc54(\ud835\udc4b ), \ud835\udc54(\ud835\udc4b \u2032)) \u2aaf \ud835\udc37 (\ud835\udc4b,\ud835\udc4b \u2032).\n(4) (Joint Convexity.) Suppose we have a collection of random variables (\ud835\udc4b\ud835\udc56 , \ud835\udc4b \u2032\ud835\udc56 )\ud835\udc56\u2208I and a random variable \ud835\udc3c distributed on I. If \ud835\udc37 (\ud835\udc4b\ud835\udc56 , \ud835\udc4b \u2032\ud835\udc56 ) \u2aaf \ud835\udc51 for all \ud835\udc56 \u2208 I, then \ud835\udc37 (\ud835\udc4b\ud835\udc3c , \ud835\udc4b \u2032 \ud835\udc3c ) \u2aaf \ud835\udc51 .\nWith this definition, the difficulty of distinguishing two neighboring datasets is measured by the generalized distance between the distributions of an adversary\u2019s views.\nDefinition 2.2 (D DP [22]). Let (D, \u2aaf, \ud835\udc37) be a generalized probability distance. For \ud835\udc51 \u2208 D, we call an interactive mechanismM \ud835\udc51-D DP if for every interactive algorithmA and every pair of neighboring datasets \ud835\udc65, \ud835\udc65 \u2032, we have\n\ud835\udc37 (View(A \u2194M(\ud835\udc65)), View(A \u2194M(\ud835\udc65 \u2032))) \u2aaf \ud835\udc51.\nA convenient property of D DP is that it suffices to consider deterministic adversaries. Since the filters and odometers we define will be D DP, we will only consider deterministic adversaries in this paper.\nLemma 2.3 (Deterministic adversaries for \ud835\udc51-D DP [21][22]). An interactive mechanism M is \ud835\udc51-D DP, if and only if for every pair of neighboring datasets \ud835\udc65, \ud835\udc65 \u2032, for every deterministic adversary A,\n\ud835\udc37 (View(A \u2194M(\ud835\udc65)) | |View(A \u2194M(\ud835\udc65 \u2032))) \u2aaf \ud835\udc51. For the rest of this paper, we will notate D\u2217 = \u22c3\u221e \ud835\udc58=0D\n\ud835\udc58 . Finally, we define concurrent composition formally. In this setting, the adversary can arbitrarily and adaptively interleave queries between several differentially-private mechanisms, meaning that the queries can be dependent.\nDefinition 2.4 (Concurrent composition of interactive mechanisms [21]). LetM1, . . . ,M\ud835\udc58 be interactive mechanisms taking private datasets \ud835\udc651, . . . , \ud835\udc65\ud835\udc58 respectively. The concurrent composition of M1, . . . ,M\ud835\udc58 , denoted M = ConComp(M1, . . . ,M\ud835\udc58 ), is defined as in Algorithm 1.\nAlgorithm 1 Concurrent composition of interactive mechanisms\nprocedureM(\ud835\udc60,\ud835\udc5a): if \ud835\udc5a = \ud835\udf06 then \ud835\udc60 \u2190 (\ud835\udc65, [(M1, \ud835\udc601), . . . , (M\ud835\udc58 , \ud835\udc60\ud835\udc58 )]) \u22b2 initialize \ud835\udc58 mechanisms\nreturn (\ud835\udc60, \ud835\udf06) end if Parse \ud835\udc60 = (\ud835\udc65, [(M1, \ud835\udc601), . . . , (M\ud835\udc58 , \ud835\udc60\ud835\udc58 )]) Parse\ud835\udc5a if \ud835\udc5a = ( \ud835\udc57, \ud835\udc5e) where \ud835\udc57 = 1, . . . , \ud835\udc58 and \ud835\udc5e is a query toM \ud835\udc57 then (\ud835\udc60\u2032 \ud835\udc57 ,\ud835\udc5a\u2032) \u2190 M \ud835\udc57 (\ud835\udc60 \ud835\udc57 , \ud835\udc5e)\n\ud835\udc60\u2032 \u2190 (\ud835\udc65, [(M1, \ud835\udc601), . . . , (M \ud835\udc57 , \ud835\udc60\u2032\ud835\udc57 ), . . . , (M\ud835\udc58 , \ud835\udc60\ud835\udc58 )]) else if \ud835\udc5a cannot be parsed correctly then\n\ud835\udc60\u2032 \u2190 \ud835\udc60 ,\ud835\udc5a\u2032 \u2190 invalid query end if return (\ud835\udc60\u2032,\ud835\udc5a\u2032)\nend procedure"
        },
        {
            "heading": "2.2 Filters",
            "text": "We can now define a generalization of the privacy filter for the composition of noninteractive mechanisms as introduced in Section 1.3. Recall that filters are based on continuation rules. In line with the fully-adaptive setting, the number of interactive mechanisms need not be specified beforehand.\nDefinition 2.5 (F -filtered composition of D DP noninteractive mechanisms (F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40))). Let F (\u00b7;\ud835\udc51) : D\u2217 \u00d7 D \u2192 {1, 0}. The F -filtered composition of D DP noninteractive mechanisms, denoted as F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40), is an interactive mechanism executed in Algorithm 2.\nIf there is a finite maximum \ud835\udc3e of noninteractive privacy-loss parameters \ud835\udc511, \ud835\udc512, . . . , \ud835\udc51\ud835\udc3e to take in, we denote the continuation rule F\ud835\udc3e (\u00b7;\ud835\udc51) : D\u2264\ud835\udc3e \u00d7 D \u2192 {1, 0}, where \ud835\udc51 is the target privacy budget.\nDefinition 2.6 (ValidD DP filter for noninteractive mechanisms). Let F be a continuation rule F : D\u2217\u00d7D \u2192 {0, 1}. We say F is a valid D DP NIM-filter for noninteractive mechanisms if for every \ud835\udc51 \u2208 D, F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40) is a \ud835\udc51-D DP interactive mechanism.\nWe can now similarly define the privacy filter for concurrent composition of interactive mechanisms.\nDefinition 2.7 (F -filtered concurrent composition of D DP interactive mechanisms). The F -filtered concurrent composition of D DP interactive mechanisms, denoted as F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), is an interactive mechanism as executed in Algorithm 3.\nAlgorithm 2 F -filtered composition ofD DP noninteractive mechanisms (F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40)), for F : D\u2264\ud835\udc3e \u2192 D, where \ud835\udc3e could be\u221e.\nprocedure F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40)(\ud835\udc60,\ud835\udc5a): if \ud835\udc5a = \ud835\udf06 then \u22b2 initialize filter\n\ud835\udc60\u2032 \u2190 (\ud835\udc60, []), where [] is an empty list return (\ud835\udc60\u2032, \ud835\udf06)\nend if Parse \ud835\udc60 as \ud835\udc60 = (\ud835\udc65, [(M1, \ud835\udc511), (M2, \ud835\udc512), . . . , (M\ud835\udc58 , \ud835\udc51\ud835\udc58 )]) Parse\ud835\udc5a if \ud835\udc5a = (M\u2032, \ud835\udc51\u2032) then\nifM\u2032 is \ud835\udc51\u2032-D DP then M\ud835\udc58+1 \u2190M\u2032 \ud835\udc51\ud835\udc58+1 \u2190 \ud835\udc51\u2032 if F (\ud835\udc511, . . . , \ud835\udc51\ud835\udc58+1) \u2260 1 then\n\ud835\udc5a\u2032 \u2190 insufficient budget, \ud835\udc60\u2032 \u2190 Halt else\nRandom sample \ud835\udc5f\ud835\udc58+1 := coin toss forM\ud835\udc58+1 \ud835\udc60\u2032 \u2190 (\ud835\udc65, [(M1, \ud835\udc511), . . . , (M\ud835\udc58+1, \ud835\udc51\ud835\udc58+1)]) \ud835\udc5a\u2032 \u2190M\ud835\udc58+1 (\ud835\udc65 ; \ud835\udc5f\ud835\udc58+1)\nend if end if\nelse if \ud835\udc5a cannot be parsed correctly then \ud835\udc60\u2032 \u2190 \ud835\udc60 ,\ud835\udc5a\u2032 \u2190 invalid query\nend if return (\ud835\udc60\u2032,\ud835\udc5a\u2032)\nend procedure\nAlgorithm 3 F -filtered concurrent composition of D DP interactive mechanisms (F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40)), for F : D\u2264\ud835\udc3e \u2192 D, where \ud835\udc3e could be\u221e.\nprocedure F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40)(\ud835\udc60,\ud835\udc5a): if \ud835\udc5a = \ud835\udf06 then \u22b2 initialize filter\n\ud835\udc60\u2032 \u2190 (\ud835\udc60, []), where [] is an empty list return (\ud835\udc60\u2032, \ud835\udf06)\nend if Parse \ud835\udc60 as \ud835\udc60 = (\ud835\udc65, [(M1, \ud835\udc511, \ud835\udc601), . . . , (M\ud835\udc58 , \ud835\udc51\ud835\udc58 , \ud835\udc60\ud835\udc58 )]) Parse\ud835\udc5a if \ud835\udc5a = (M\u2032, \ud835\udc51\u2032) then\nifM\u2032 is \ud835\udc51\u2032-D DP then M\ud835\udc58+1 \u2190M\u2032 \ud835\udc51\ud835\udc58+1 \u2190 \ud835\udc51\u2032 if F (\ud835\udc511, . . . , \ud835\udc51\ud835\udc58+1) \u2260 1 then\n\ud835\udc60\u2032 \u2190 Halt,\ud835\udc5a\u2032 \u2190 insufficient budget else (\ud835\udc60\ud835\udc58+1,\ud835\udc5a) \u2190 M\ud835\udc58+1 (\ud835\udc65, \ud835\udf06) \ud835\udc60\u2032 \u2190 (\ud835\udc65, \ud835\udc51, [(M1, \ud835\udc511, \ud835\udc601), . . . , (M\ud835\udc58+1, \ud835\udc51\ud835\udc58+1, \ud835\udc60\ud835\udc58+1)]) \ud835\udc5a\u2032 \u2190 yes\nend if end if\nelse if\ud835\udc5a = ( \ud835\udc57, \ud835\udc5e) where \ud835\udc57 = 1, . . . , \ud835\udc58 and \ud835\udc5e is a query toM \ud835\udc57 then (\ud835\udc60\u2032 \ud835\udc57 ,\ud835\udc5a\ud835\udc56+1) \u2190 M \ud835\udc57 (\ud835\udc60 \ud835\udc57 , \ud835\udc5e)\n\ud835\udc60\u2032 \u2190 (\ud835\udc65, \ud835\udc51, [((M1, \ud835\udc511, \ud835\udc60\u20321), . . . , (M \ud835\udc57 , \ud835\udc51 \ud835\udc57 , \ud835\udc60 \u2032 \ud835\udc57 ), . . . ), . . . , (M\ud835\udc58 , \ud835\udc51\ud835\udc58 , \ud835\udc60\u2032\ud835\udc58 )])\nelse if \ud835\udc5a\ud835\udc56 cannot be parsed correctly then \ud835\udc60\u2032 \u2190 \ud835\udc60 ,\ud835\udc5a\u2032 \u2190 invalid query\nend if return (\ud835\udc60\u2032,\ud835\udc5a\u2032)\nend procedure\nA privacy filter is one in which Definition 2.7 holds for all distances \ud835\udc51 \u2208 D.\nDefinition 2.8 (Valid D DP filter for interactive mechanisms). Let F be a continuation rule F : D\u2217 \u00d7 D \u2192 {0, 1}, where D\u2217 = \u22c3\u221e\n\ud835\udc58=0D \ud835\udc58 . We say F is a valid D DP concurrent IM-filter\nif for every \ud835\udc51 \u2208 D, F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is a \ud835\udc51-D DP interactive mechanism."
        },
        {
            "heading": "2.3 Odometer",
            "text": "We can similarly generalize our definition for privacy odometers to D DP.\nDefinition 2.9 (G-odometer for composition of noninteractive mechanisms (G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a(\ud835\udc41\ud835\udc3c\ud835\udc40))). A G-odometer for the composition of noninteractiveD DPmechanisms, denoted asG-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a(\ud835\udc41\ud835\udc3c\ud835\udc40), is executed as in Algorithm 4.\nAlgorithm 4 G-odometer for composition of noninteractive mechanisms (G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a(\ud835\udc41\ud835\udc3c\ud835\udc40)) .\nprocedure G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a(\ud835\udc41\ud835\udc3c\ud835\udc40)(\ud835\udc60,\ud835\udc5a): if \ud835\udc5a = \ud835\udf06 then\n\ud835\udc60\u2032 \u2190 (\ud835\udc60, []), where [] is an empty list return (\ud835\udc60\u2032, \ud835\udf06)\nend if Parse \ud835\udc60 as \ud835\udc60 = (\ud835\udc65, [(M1, \ud835\udc511), (M2, \ud835\udc512), . . . , (M\ud835\udc58 , \ud835\udc51\ud835\udc58 )]) Parse\ud835\udc5a if \ud835\udc5a = (M\u2032, \ud835\udc51\u2032) then\nifM\u2032 is \ud835\udc51\u2032-D DP then M\ud835\udc58+1 \u2190M\u2032 \ud835\udc51\ud835\udc58+1 \u2190 \ud835\udc51\u2032 \ud835\udc60\u2032 \u2190 (\ud835\udc65, [(M1, \ud835\udc511), . . . , (M\ud835\udc58+1, \ud835\udc51\ud835\udc58+1)]) Random sample \ud835\udc5f\ud835\udc58+1 := coin toss forM\ud835\udc58+1 \ud835\udc5a\u2032 \u2190M\ud835\udc58+1 (\ud835\udc65 ; \ud835\udc5f\ud835\udc58+1) else \ud835\udc60\u2032 \u2190 \ud835\udc60\ud835\udc56 ,\ud835\udc5a\u2032 \u2190 Divergence cannot be parsed\nend if else if \ud835\udc5a = privacy_loss then\n\ud835\udc60\u2032 \u2190 \ud835\udc60,\ud835\udc5a\u2032 \u2190 G(\ud835\udc511, . . . , \ud835\udc51\ud835\udc58 ) else if \ud835\udc5a cannot be parsed correctly then\n\ud835\udc60\u2032 \u2190 \ud835\udc60 ,\ud835\udc5a\u2032 \u2190 invalid query end if return (\ud835\udc60\u2032,\ud835\udc5a\u2032)\nend procedure\nOdometers comewith a per-mechanism privacy guarantee, meaning that the divergence between the views after each new mechanism is started should be at most some set distance \ud835\udc51 \u2208 D apart. Because the odometer can receive a privacy_loss query at any point in computation, a notion that captures the during-computation guarantee is necessary. The generalized truncated view of the adversary up to the \ud835\udc5b-th round of interaction to an odometer equipped with continuation rule G is defined as in Algorithm 5.\nDefinition 2.10 (Truncated view for odometers [15]). For a deterministic adversary A and odometer O on dataset \ud835\udc65 , define the\ntruncated view\nTrunc\ud835\udc51 (View(A \u2194 O(\ud835\udc65)))\nas the return value including the randomness and query answers of Algorithm 5.\nAlgorithm 5 Truncated view of adversary interacting with odometer O given input \ud835\udc51\nInitialize \ud835\udc60M1 \u2190 \ud835\udc65 ,\ud835\udc5a0 \u2190 \ud835\udf06, \ud835\udc60 A 1 \u2190 \ud835\udf06 for \ud835\udc56 = 1, 2, . . . do if \ud835\udc56 is odd then (\ud835\udc60M \ud835\udc56+1, \ud835\udc4e\ud835\udc56 ) \u2190 O(\ud835\udc60 M \ud835\udc56 , \ud835\udc5e\ud835\udc56\u22121)\n(\ud835\udc60M \ud835\udc56 , \ud835\udc51\ud835\udc56 ) = O(\ud835\udc60M\ud835\udc56 , privacy_loss) \ud835\udc60A \ud835\udc56+1 \u2190 \ud835\udc60 A \ud835\udc56 if \ud835\udc51\ud835\udc56 \u2aaf\u0338 \ud835\udc51 then Exit loop\nend if else if \ud835\udc56 is even then (\ud835\udc60A \ud835\udc56+1, \ud835\udc5e\ud835\udc56 ) \u2190 A(\ud835\udc60 A \ud835\udc56 , \ud835\udc4e\ud835\udc56\u22121; \ud835\udc5fA\ud835\udc56 )\n\ud835\udc60M \ud835\udc56+1 \u2190 \ud835\udc60 M \ud835\udc56\nend if if \ud835\udc4e\ud835\udc56 = halt then\nExit loop end if\nend for return Trunc\ud835\udc51 (View(A \u2194 O(\ud835\udc65))) = (\ud835\udc5fA0 , \ud835\udc4e1, . . . , \ud835\udc5f A \ud835\udc56\u22122, \ud835\udc4e\ud835\udc56\u22121)\nHaving generalized truncated view to D DP, we can now define a valid D DP odometer, and a valid privacy-loss accumulator for an odometer of noninteractive mechanisms.\nDefinition 2.11 (Valid D-DP odometer). We say O is a valid D DP odometer if for every \ud835\udc51 \u2208 D, adversary A, and every pair of adjacent datasets \ud835\udc65, \ud835\udc65 \u2032,\n\ud835\udc37 (Trunc\ud835\udc51 (View(A \u2194 O(\ud835\udc65))) | |Trunc\ud835\udc51 (View(A \u2194 O(\ud835\udc65 \u2032)))) \u2aaf \ud835\udc51\nDefinition 2.12 (Valid D-DP privacy-loss accumulator for noninteractive mechanisms). Let G : D\u2217 \u2192 D. We say G is a valid D DP NIM-privacy-loss accumulator if for every \ud835\udc51 \u2208 D, G(\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40) is a valid \ud835\udc51-D DP odometer.\nWe now define the privacy odometer that allows us to keep track of the total privacy loss across multiple interactive mechanisms, where the adversary can interleave queries to existing interactive mechanisms, as well as create new interactive mechanisms with privacy-loss budgets chosen adaptively. Crucially, our construction of odometers have a specially-designated privacy-loss query, which outputs a conservative upper bound on the privacy loss for the interaction up to that point. It should be noted that this odometer model for I.M.s does not define a per-query privacy loss as in the odometer for noninteractive mechanisms. Instead, the \u201cprivacyloss budget\" is paid at the launch of each additional interactive mechanism. Any privacy_loss queries asked between mechanism launches will return the same value.\nDefinition 2.13 (G-odometer for concurrent composition of interactive mechanisms (G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40))). A G-odometer for the concurrent composition of interactive mechanisms, denoted as G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), is executed as in Algorithm 6.\nAlgorithm6G-odometer for concurrent composition of interactive mechanisms (G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40)).\nprocedure G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40)(\ud835\udc60,\ud835\udc5a): if \ud835\udc5a = \ud835\udf06 then\n\ud835\udc60\u2032 \u2190 (\ud835\udc60, []), where [] is an empty list return (\ud835\udc60\u2032, \ud835\udf06)\nend if Parse \ud835\udc60 = (\ud835\udc65, (M1, \ud835\udc511, \ud835\udc601), (M2, \ud835\udc512, \ud835\udc602), . . . , (M\ud835\udc58 , \ud835\udc51\ud835\udc58 , \ud835\udc60\ud835\udc58 ))) Parse\ud835\udc5a if \ud835\udc5a = (M\u2032, \ud835\udc51\u2032) then\nifM\u2032 is \ud835\udc51\u2032-D DP then M\ud835\udc58+1 \u2190M\u2032 \ud835\udc51\ud835\udc58+1 \u2190 \ud835\udc51\u2032 (\ud835\udc60\ud835\udc58+1,\ud835\udc5a) \u2190 M\ud835\udc58+1 (\ud835\udc65, \ud835\udf06) \ud835\udc60\u2032 \u2190 (\ud835\udc65, [(M1, \ud835\udc511, \ud835\udc601), . . . , (M\ud835\udc58+1, \ud835\udc51\ud835\udc58+1, \ud835\udc60\ud835\udc58+1)]) \ud835\udc5a\u2032 \u2190 yes\nelse \ud835\udc60\u2032 \u2190 \ud835\udc60 ,\ud835\udc5a\u2032 \u2190 \u201cDivergence cannot be parsed\"\nend if else if \ud835\udc5a = ( \ud835\udc57, \ud835\udc5e) where \ud835\udc57 = 1, . . . , \ud835\udc58 and \ud835\udc5e is a query toM \ud835\udc57\nthen (\ud835\udc60\u2032 \ud835\udc57 ,\ud835\udc5a\u2032) \u2190 M \ud835\udc57 (\ud835\udc60 \ud835\udc57 , \ud835\udc5e)\n\ud835\udc60\u2032 \u2190 (\ud835\udc65, [(. . . , (M \ud835\udc57 , \ud835\udc51 \ud835\udc57 , \ud835\udc60\u2032\ud835\udc57 ), . . . )]) else if \ud835\udc5a\ud835\udc56 = privacy_loss then\n\ud835\udc60\u2032 \u2190 \ud835\udc60,\ud835\udc5a\u2032 \u2190 G(\ud835\udc511, . . . , \ud835\udc51\ud835\udc58 ) else if \ud835\udc5a cannot be parsed correctly then\n\ud835\udc60\u2032 \u2190 \ud835\udc60 ,\ud835\udc5a\u2032 \u2190 invalid query end if return (\ud835\udc60\u2032,\ud835\udc5a\u2032)\nend procedure\nWe are now ready to define the notion of a valid D DP privacyloss accumulator.\nDefinition 2.14 (Valid D DP privacy-loss accumulator for interactive mechanisms). We say G is a valid D DP concurrent IM-privacy-loss accumulator if for every\ud835\udc51 \u2208 D,G(\u00b7;\ud835\udc51)-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is a valid \ud835\udc51-D DP odometer."
        },
        {
            "heading": "2.4 I.M.-to-I.M. Interactive Postprocessing",
            "text": "Before we move on to defining concurrent filters and odometers, we will formulate interactive postprocessing in terms of state machines, which will become a helpful tool for us to prove important theorems related to concurrent filters and odometers for \ud835\udc53 -DP and R\u00e9nyi-DP mechanisms. We will first give a formal definition of person-in-themiddle mechanisms.\nDefinition 2.15 (Person-in-the-middle mechanism). An interactive postprocessing mechanism (or \u2018PIM mechanism\u2019 for \u2018personin-the-middle\u2019) is a randomized mechanism P : {0, 1}\u2217 \u00d7 {\ud835\udc44,\ud835\udc34} \u00d7 {0, 1}\u2217 \u2192 {0, 1}\u2217 \u00d7 {\ud835\udc44,\ud835\udc34} \u00d7 {0, 1}\u2217. P takes its current state \ud835\udc60 \u2208\n{0, 1}\u2217, a value \ud835\udc63 \u2208 {\ud835\udc44,\ud835\udc34} to indicate whether it is receiving a query (from an analyst or adversary) or an answer (from the mechanism it is postprocessing), and a message\ud835\udc5a (which is either a query or an answer) and returns a new state \ud835\udc60\u2032 \u2208 {0, 1}\u2217, a value \ud835\udc63 \u2032 \u2208 {\ud835\udc44,\ud835\udc34} to indicate whether it is asking a query (of the mechanism it is postprocessing) or providing an answer (if it is answering a query) and message \ud835\udc5a\u2032 (which is either a query or an answer), denoted (\ud835\udc60\u2032, \ud835\udc63 \u2032,\ud835\udc5a\u2032) = P(\ud835\udc60, \ud835\udc63,\ud835\udc5a).\nWith the PIM primitive, we can now more precisely define a postprocessed interactive mechanism.\nDefinition 2.16 (Postprocessed interactive mechanism). LetM be an interactive mechanism and P be an interactive postprocessing. Then the postprocessing ofM by a PIM algorithm P, denoted P \u25e6M, is the interactive mechanism defined in Algorithm 7.\nAlgorithm 7 Postprocessing ofM by PIM algorithm P, denoted P \u25e6M. procedure P \u25e6M(\ud835\udc60,\ud835\udc5a):\nif \ud835\udc5a = \ud835\udf06 then \ud835\udc60M \u2190 \ud835\udc65 , \ud835\udc60P \u2190 \ud835\udf06,\ud835\udc5a \u2190 \ud835\udf06, \ud835\udc63 \u2190 \ud835\udc34 \u22b2 initializeM and P\nelse Parse \ud835\udc60 as \ud835\udc60 = (\ud835\udc60M , \ud835\udc60P ), and let \ud835\udc63 = \ud835\udc44 .\nend if while \ud835\udc63 = \ud835\udc44 do \u22b2 while P is equipped to interact withM,\nconduct interaction (\ud835\udc60M ,\ud835\udc5a) \u2190 M(\ud835\udc60M ,\ud835\udc5a) (\ud835\udc60P , \ud835\udc63,\ud835\udc5a) = P(\ud835\udc60P , \ud835\udc34,\ud835\udc5a)\nend while return ((\ud835\udc60M , \ud835\udc60P ),\ud835\udc5a)\nend procedure\nTheorem 2.17 (Privacy holds under I.M.-to-I.M. postprocessing). If P : {0, 1}\u2217 \u00d7 {\ud835\udc44,\ud835\udc34} \u00d7 {0, 1}\u2217 \u2192 {0, 1}\u2217 \u00d7 {\ud835\udc44,\ud835\udc34} \u00d7 {0, 1}\u2217 is an interactive postprocessing algorithm andM is a \ud835\udc51-D DP interactive mechanism, then P \u25e6M is \ud835\udc51-D DP.\nProof. Let A be the deterministic adversary against P \u25e6 M. By Definition 1.6, View(A \u2194 P \u25e6M(\ud835\udc65)) = (\ud835\udc5f0,\ud835\udc5a1, \ud835\udc5f2,\ud835\udc5a3, \ud835\udc5f4, . . . ), where \ud835\udc5f\ud835\udc56 are the random coins thatA tosses and\ud835\udc5a\ud835\udc56 are themessages received by A. Define an adversary A\u2032 that maintains the states of A and P as submachines, constructed as in Algorithm 8.\nInformally, Algorithm 8 says that whenA\u2032 is to generate a query (determined by \ud835\udc63 = \ud835\udc44), it will run A with P to generate a query. When A\u2032 is to receive an answer (determined by \ud835\udc63 = \ud835\udc34), it will run P to first check if P wants to interactively process it withM first. If so, the interaction between P andM would proceed until P determines that the answer is in a state to be passed to A, done by checking the output value \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 of P given the state, the value \ud835\udc34, and the message as inputs at that round.\nBecauseM is\ud835\udc51-D DP, the interaction betweenA\u2032 andM is\ud835\udc51-D DP. Define a noninteractive postprocessing function \ud835\udc54 that transforms View(A\u2032 \u2194M(\ud835\udc65)) = (\ud835\udc5f \u20320,\ud835\udc5a \u2032 1, \ud835\udc5f \u2032 2,\ud835\udc5a \u2032 3, . . . ) on any dataset \ud835\udc65 as in Algorithm 9. Informally, the new view object generated by Algorithm 9 makes visible the submachine interaction between A and P in the operation of A\u2032, and snips the interaction between\nAlgorithm 8 Adversary A\u2032 that maintains the states of A and P as submachines.\nprocedure A\u2032(\ud835\udc60,\ud835\udc5a): if \ud835\udc60 = \ud835\udf06 then \u22b2 need to initialize A\u2032 (\ud835\udc60A ,\ud835\udc5a0) \u2190 A(\ud835\udf06, \ud835\udf06) \u22b2 initialize adversary submachine (\ud835\udc60P , \ud835\udc63,\ud835\udc5a\u2032) \u2190 P(\ud835\udf06,\ud835\udc34,\ud835\udc5a0) \u22b2 initialize PIM submachine return ((\ud835\udc60A , \ud835\udc60P ),\ud835\udc5a\u2032)\nend if Parse \ud835\udc60 = (\ud835\udc60A , \ud835\udc60P ) \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 \u2190 \ud835\udc34 \u22b2 initialize \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 if \ud835\udc63 = \ud835\udc44 then\n\ud835\udc57 \u2190 1 \u22b2 \ud835\udc57 indexes the internal communication A \u2194 P while \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 = \ud835\udc34 do\nLet (\ud835\udc60A \ud835\udc57+1,\ud835\udc5a \ud835\udc57 ) = A(\ud835\udc60 A \ud835\udc57 ,\ud835\udc5a) Let (\ud835\udc60P \ud835\udc57+1, \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 ,\ud835\udc5a \u2032 \ud835\udc57 ) = P(\ud835\udc60P\n\ud835\udc57+1, \ud835\udc63,\ud835\udc5a \ud835\udc57 ) \ud835\udc57 \u2190 \ud835\udc57 + 1\nend while \ud835\udc5a\u2032 \u2190\ud835\udc5a\u2032\n\ud835\udc57\n\ud835\udc60\u2032 \u2190 (\ud835\udc60A \ud835\udc57 , \ud835\udc60P \ud835\udc57 )\n\ud835\udc63 \u2190 \ud835\udc34 else if \ud835\udc63 = \ud835\udc34 then (\ud835\udc60P , \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 ,\ud835\udc5a\u2032) \u2190 P(\ud835\udc60P , \ud835\udc63,\ud835\udc5a) \ud835\udc60\u2032 \u2190 (\ud835\udc60A , \ud835\udc60P ) if \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 = \ud835\udc34 then \u22b2 P will provide an answer to A\n\ud835\udc63 \u2190 \ud835\udc44 \u22b2 prime A to ask a query end if\nend if return (\ud835\udc60\u2032,\ud835\udc5a\u2032)\nend procedure\nA\u2032 andM such that if there is an extended sequence betweenM and submachine P of A, only the only the final answer fromM before P and A begin interacting will be included. Since noninteractive postprocessing preserves privacy properties by Definition 2.1 (3), we know that \ud835\udc37 (\ud835\udc54(View(A\u2032 \u2194 M)(\ud835\udc65)) | |\ud835\udc54(View(A\u2032 \u2194 M)(\ud835\udc65 \u2032))) \u2aaf \ud835\udc37 (View(A\u2032 \u2194M)(\ud835\udc65) | |View(A\u2032 \u2194M)(\ud835\udc65 \u2032)) \u2aaf \ud835\udc51 .\nThe view ofA against P \u25e6M on any dataset \ud835\udc65 can be computed by postprocessing the view ofA\u2032 againstM on \ud835\udc65 using \ud835\udc54; in other words, View(A \u2194 P\u25e6M) \u2261 \ud835\udc54(View(A\u2032 \u2194M)) on any dataset \ud835\udc65 . Therefore,\ud835\udc37 (View(A \u2194 P\u25e6M)(\ud835\udc65) | |View(A \u2194 P\u25e6M)(\ud835\udc65 \u2032)) \u2aaf \ud835\udc51 . This means P \u25e6M is also \ud835\udc51-D DP. \u25a1\nA useful corollary follows directly from Theorem 2.17.\nCorollary 2.18. Suppose N is an interactive mechanism over database space X such that for every pair of neighboring datasets \ud835\udc65, \ud835\udc65 \u2032 and every deterministic adversary A, there exists a \ud835\udc51-D DPM and an interactive postprocessing P such that\nView(A \u2194 N(\ud835\udc65)) \u2261 View(A \u2194 P \u25e6M(\ud835\udc65)) View(A \u2194 N(\ud835\udc65 \u2032)) \u2261 View(A \u2194 P \u25e6M(\ud835\udc65 \u2032)).\nThen N is \ud835\udc51-D DP.\nProof. By Theorem 2.17, P\u25e6M is \ud835\udc51-D DP, which means for every pairs of datasets\ud835\udc65, \ud835\udc65 \u2032, every adversaryA, we have\ud835\udc37 (View(A \u2194\nAlgorithm 9 Noninteractive postprocessing \ud835\udc54 that transforms View(A\u2032 \u2194M(\ud835\udc65)) to View(A \u2194 P \u25e6M(\ud835\udc65))\nprocedure \ud835\udc54(View(A\u2032 \u2194M(\ud835\udc65))) \ud835\udc56 \u2190 1 \u22b2 \ud835\udc56 indexes input \ud835\udc57 \u2190 0 \u22b2 \ud835\udc57 indexes output Parse View(A\u2032 \u2194M(\ud835\udc65)) as (\ud835\udc5f \u20320,\ud835\udc5a \u2032 1, \ud835\udc5f \u2032 2,\ud835\udc5a \u2032 3, . . . )\n\ud835\udc63,\u2190 \ud835\udc44, \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 \u2190 \ud835\udc34 while\ud835\udc5a\ud835\udc56 do\nif \ud835\udc63 = \ud835\udc44 then \u22b2 adding interaction A \u2194 P Store (\ud835\udc60A ,\ud835\udc5aA ) \u2190 (\ud835\udc60A\n\ud835\udc56 ,\ud835\udc5a\u2032 \ud835\udc56 ) as temporary variable\n(\ud835\udc60P , \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 ,\ud835\udc5aP ) \u2190 (\ud835\udc60P\ud835\udc56 , \ud835\udc63, \ud835\udf06) while \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 \u2260 \ud835\udc44 do \u22b2 simulate interaction of A and\nP on the message Let (\ud835\udc60A ,\ud835\udc5aA ) = A(\ud835\udc60A ,\ud835\udc5aA ; \ud835\udc5fA\n\ud835\udc57 )\nLet (\ud835\udc60P , \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 ,\ud835\udc5aP ) = P(\ud835\udc60P , \ud835\udc63,\ud835\udc5aA ; \ud835\udc5f P\ud835\udc57 ) \u22b2 using the randomness of P to get the new state \ud835\udc5a \ud835\udc57+1 \u2190\ud835\udc5aP \u22b2 record message A receives from P\n\ud835\udc57 \u2190 \ud835\udc57 + 2 end while \ud835\udc63 \u2190 \ud835\udc34\nelse if \ud835\udc63 = \ud835\udc34 then \u22b2 abbreviating interaction P \u2194M (\ud835\udc60P , \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 ,\ud835\udc5a) \u2190 P(\ud835\udc60P\ud835\udc56 , \ud835\udc63,\ud835\udc5a \u2032 \ud835\udc56 ; \ud835\udc5f P \ud835\udc57 )\nif \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 = \ud835\udc44 then \ud835\udc63 \u2190 \ud835\udc34 else if \ud835\udc63\ud835\udc5c\ud835\udc62\ud835\udc61 = \ud835\udc34 then \u22b2 record the history \ud835\udc5a \ud835\udc57+1 \u2190\ud835\udc5a \ud835\udc63 \u2190 \ud835\udc44 \ud835\udc57 \u2190 \ud835\udc57 + 2\nend if end if \ud835\udc56 \u2190 \ud835\udc56 + 2\nend while return (\ud835\udc5fA0 ,\ud835\udc5a1, \ud835\udc5f A 2 ,\ud835\udc5a3, . . . , \ud835\udc5f A \ud835\udc57 ,\ud835\udc5a \ud835\udc57+1, . . . )\nend procedure\nN(\ud835\udc65)) | |View(A \u2194 N(\ud835\udc65 \u2032))) = \ud835\udc37 (View(A \u2194 P\u25e6M(\ud835\udc65)) | |View(A \u2194 P \u25e6M(\ud835\udc65 \u2032))) \u2aaf \ud835\udc51 . Therefore, N is also \ud835\udc51-D DP. \u25a1\nA particularly convenient property of privacy-loss accumulators and privacy filters is that a valid privacy-loss accumulator can be converted into a valid privacy filter, and vice versa. This bijective property allows us to use a filter to build an odometer, and an odometer to build a filter of the form I(G(\u00b7) \u2aaf \ud835\udc51). Any nice properties of one would hold for the other.\nLemma 2.19. (1) A function G : D\u2217 \u2192 D, where D\u2217 =\u22c3\u221e \ud835\udc58=0D\n\ud835\udc58 , is a valid NIM-privacy-loss accumulator if and only if F : D\u2217 \u00d7 D \u2192 {0, 1} constructed from G(\u00b7) such that F (\u00b7;\ud835\udc51) = I(G(\u00b7) \u2aaf \ud835\udc51) is a valid D-DP NIM-filter.\n(2) A function G : D\u2217 \u2192 D, where D\u2217 = \u22c3\u221e \ud835\udc58=0D\n\ud835\udc58 , is a valid concurrent IM-privacy-loss accumulator if and only if F : D\u2217 \u00d7 D \u2192 {0, 1} constructed from G(\u00b7) such that F (\u00b7;\ud835\udc51) = I(G(\u00b7) \u2aaf \ud835\udc51) is a valid D-DP concurrent IM-filter.\nThe full proof of this theorem is enclosed in Appendix B.1. The approach is to first define an I.M.M that such that for any adversary A and dataset \ud835\udc65 , View(A \u2194 M(\ud835\udc65)) is exactly the same as Trunc\ud835\udc51 (View(A \u2194 G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65, \u00b7))). Then, using Theorem 2.17, we can show thatM is an interactive post-processing of F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40)."
        },
        {
            "heading": "3 CONCURRENT FILTER & ODOMETER FOR \ud835\udc53 -DP",
            "text": "\ud835\udc53 -DP is based on a hypothesis testing interpretation of differential privacy. Consider a hypothesis testing problem that attempts to quantify the difficulty of measuring the output of a mechanism on two adjacent datasets:\n\ud835\udc3b0: the dataset is \ud835\udc65 versus \ud835\udc3b1: the dataset is \ud835\udc65 \u2032\nLet \ud835\udc4c := M(\ud835\udc65) and \ud835\udc4c \u2032 := M(\ud835\udc65 \u2032) be the output distributions of mechanismM on neighboring datasets \ud835\udc65, \ud835\udc65 \u2032. For a given rejection rule \ud835\udf19 , the type I error \ud835\udefc\ud835\udf19 = E[\ud835\udf19 (\ud835\udc4c )] is the probability of rejecting \ud835\udc3b0 when \ud835\udc3b0 is true, while the type II error \ud835\udefd\ud835\udf19 = 1 \u2212 E[\ud835\udf19 (\ud835\udc4c \u2032)] is the probability of failing to reject \ud835\udc3b0 when \ud835\udc3b1 is true.\nThe trade-off function characterizes the optimal boundary between achievable type I and type II errors, which in our case is calculated by finding the minimal achievable type II error after fixing the type I error at any level.\nDefinition 3.1 (Trade-off function [3]). For any two probability distributions \ud835\udc4c and \ud835\udc4c \u2032 on the same space, the trade-off function \ud835\udc47 (\ud835\udc4c,\ud835\udc4c \u2032) : [0, 1] \u2192 [0, 1] is defined as\n\ud835\udc47 (\ud835\udc4c,\ud835\udc4c \u2032) (\ud835\udefc) = inf{\ud835\udefd\ud835\udf19 : \ud835\udefc\ud835\udf19 < \ud835\udefc}, where the infimum is taken over all measurable rejection rules \ud835\udf19 .\nDefinition 3.2 (\ud835\udc53 -DP [3]). Let \ud835\udc53 be a tradeoff function. A mechanismM : X \u2192 R is \ud835\udc53 -differentially private if for every pair of neighboring datasets \ud835\udc65, \ud835\udc65 \u2032 \u2208 X, we have\n\ud835\udc47 (M(\ud835\udc65),M(\ud835\udc65 \u2032)) \u2265 \ud835\udc53 .\nIn our generalized DP framework in Definition 2.1, the probability distance measure for \ud835\udc53 -DP is (\ud835\udc46, \u2aaf,\ud835\udc47 ). The distance mapping is the trade-off function \ud835\udc47 in Definition 3.2. The partially ordered set (\ud835\udc46, \u2aaf) consists of the set \ud835\udc46 of all trade-off functions \ud835\udc54 : [0, 1] \u2192 [0, 1] such that\ud835\udc54 is convex, continuous, non-increasing, and \ud835\udc54(\ud835\udc65) \u2264 1 \u2212 \ud835\udc65 for \ud835\udc65 \u2208 [0, 1]. The partial ordering is defined as \ud835\udc531 \u2aaf \ud835\udc532 if \ud835\udc531 (\ud835\udefc) \u2265 \ud835\udc532 (\ud835\udefc) holds for all \ud835\udefc \u2208 [0, 1]. A larger trade-off function means less privacy loss.\nThe recent result of Vadhan and Zhang [22] shows that every interactive \ud835\udc53 -DP mechanism can be simulated by an interactive postprocessing of a noninteractive \ud835\udc53 -DP mechanism.\nTheorem 3.3 (Reduction of \ud835\udc53 -DP to noninteractive mechanism [22]). For every \ud835\udc53 \u2208 F and every interactive \ud835\udc53 -DP mechanism M with finite communication complexity, and every pair of neighboring datasets \ud835\udc65 and \ud835\udc65 \u2032, there exists a pair of random variables\ud835\udc4c,\ud835\udc4c \u2032 and a randomized interactive mechanism P, which we call an interactive postprocessing, such that \ud835\udc37 (\ud835\udc4c,\ud835\udc4c \u2032) \u2aaf \ud835\udc53 , and for every deterministic adversary A, we have\nView(A \u2194M(\ud835\udc65)) \u2261 View(A \u2194 P(\ud835\udc4c )) (1) View(A \u2194M(\ud835\udc65 \u2032)) \u2261 View(A \u2194 P(\ud835\udc4c \u2032)) . (2)\nEssentially, the interactive postprocessing function in Theorem 3.3 takes the output of the non-interactive mechanism as the input, and interacts with the adversary just as the interactive mechanism does. It will use the output of the non-interactive mechanism to simulate all the answers to the adversary. This result is useful because it implies that for any fixed pair of datasets \ud835\udc65, \ud835\udc65 \u2032, to analyze the concurrent composition of interactive mechanismsM\ud835\udc56 , it suffices to consider the composition of their noninteractive versions N\ud835\udc56 . As a result, composition theorems for noninteractive mechanisms extend to the concurrent composition of interactive \ud835\udc53 -DP mechanisms.\nSince (\ud835\udf16, \ud835\udeff)-DP is a specific case of \ud835\udc53 -DP [3], where \ud835\udc53\ud835\udf16,\ud835\udeff = max{0, 1 \u2212 \ud835\udeff \u2212 exp(\ud835\udf16)\ud835\udefc, exp(\u2212\ud835\udf16) (1 \u2212 \ud835\udeff \u2212 \ud835\udefc)}, a corollary of this result is that an interactive (\ud835\udf16, \ud835\udeff)-DP mechanism can be postprocessed to a noninteractive (\ud835\udf16, \ud835\udeff)-DP mechanism, a result shown independently by Lyu [16]."
        },
        {
            "heading": "3.1 Concurrent Filter for \ud835\udc53 -DP",
            "text": "Using Theorem 3.3, we derive a concurrent \ud835\udc53 -DP filter from an \ud835\udc53 -DP filter for noninteractive mechanisms.\nTheorem 3.4 (Concurrent \ud835\udc53 -DP Filter). Suppose that F : D\u2217 \u2192 {1, 0} is a valid \ud835\udc53 -DP continuation rule for noninteractive mechanisms. Then F is a valid \ud835\udc53 -DP continuation rule for interactive mechanisms with finite communication.\nProof. Fix a pair of adjacent datasets \ud835\udc65, \ud835\udc65 \u2032. For any such pair, we can define the I.M.-to-I.M. postprocessingP that takesF -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40) to F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40). For simplicity, we will assume that A is deterministic, as Lemma 2.3 allows us to do. By the postprocessing property of \ud835\udc53 -DP IMs given in Theorem 3.3, we know that an \ud835\udc53\ud835\udc57 -DP mechanismM\ud835\udc56 can be simulated by an interactive postprocessing P\ud835\udc57 of a noninteractive \ud835\udc53\ud835\udc57 -DP mechanism N\ud835\udc57 . P is constructed as follows. P depends on whether it is primed to receive a query \ud835\udc63 = \ud835\udc44 from the adversary or an answer \ud835\udc63 = \ud835\udc34 from the mechanism, to pass to the other party. If the adversary asks to start a new interactive mechanism, P will make note of the corresponding noninteractive mechanism and the noninteractive-tointeractive postprocessing and pass the request onF -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc46\ud835\udc52\ud835\udc5e(\ud835\udc41\ud835\udc3c\ud835\udc40). Otherwise, if the adversary queries an existing interactive mechanismM \ud835\udc57 , P will use the corresponding interactive postprocessing P\ud835\udc57 to answer the query instead of passing the message forward to M. The only time P will interact withM is to start a new mechanism and to pass back the confirmation that a new mechanism has begun to A. The algorithmic pseudocode of P is in the appendix in Algorithm 10.\nNote that this algorithm only interacts with F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc46\ud835\udc52\ud835\udc5e(\ud835\udc41\ud835\udc3c\ud835\udc40) in starting a new mechanism. For the rest of the interactive queries, the algorithm directly uses the interactive postprocessing of the corresponding noninteractive mechanism in question to answer the queries. By Theorem 3.3, we know that for every deterministic adversaryA, there exists anF -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40) that is \ud835\udc53 -DP and an interactive postprocessing P such that View(A \u2194 P\u25e6F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40)) \u2261 View(A \u2194 F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40)) on any database\ud835\udc65 . BecauseF -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40) is \ud835\udc53 -DP, by Theorem 2.17, F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is \ud835\udc53 -DP. \u25a1\nAn analogue of Theorem 3.4 holds for (\ud835\udf16, \ud835\udeff)-DP.\nCorollary 3.5 (Concurrent (\ud835\udf16, \ud835\udeff) Filter). Every filter for noninteractive (\ud835\udf16, \ud835\udeff)-DP mechanisms is also a concurrent filter of interactive (\ud835\udf16, \ud835\udeff)-DP mechanisms.\nConcurrent \ud835\udc53 -DP odometers can be defined similarly from \ud835\udc53 -DP odometers for noninteractive mechanisms.\nTheorem 3.6 (Concurrent \ud835\udc53 -DP odometer). Suppose that G : D\u2217 \u2192 D is a valid \ud835\udc53 -DP privacy-loss accumulator for noninteractive mechanisms. Then G is a valid \ud835\udc53 -DP privacy-loss accumulator for interactive mechanisms with finite communication.\nProof. By Lemma 2.19, if G is a valid \ud835\udc53 -DP privacy-loss accumulator, then F (\u00b7; \ud835\udc53 ) = \ud835\udc3c (G(\u00b7) \u2aaf \ud835\udc53 ) is a valid \ud835\udc53 -DP filter for noninteractive mechanisms. By Theorem 3.4, if F is an \ud835\udc53 -DP filter for noninteractive mechanisms, then F will be an \ud835\udc53 -DP concurrent filter for interactive mechanisms. Applying Lemma 2.19 again, G will be a valid \ud835\udc53 -DP privacy-loss accumulator for interactive mechanisms, and G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is an \ud835\udc53 -DP interactive mechanism. \u25a1\nNow we give an example of how to construct a valid (\ud835\udf16, \ud835\udeff)-DP privacy filter and odometer.\nTheorem 3.7 ((\ud835\udf16, \ud835\udeff)-DP privacy filter [24]). For every \ud835\udeff \u2032 > 0,\nF ((\ud835\udf161, \ud835\udeff1), . . . , (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 ); (\ud835\udf16, \ud835\udeff))\n= I \u00a9\u00ab\ud835\udf16 \u2264\n\u221a 2 log ( 1 \ud835\udeff \u2032 ) \u2211\ufe01 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf162\ud835\udc5a + 1 2 \u2211\ufe01 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf162\ud835\udc5a \u00aa\u00ae\u00ac \u00b7 I ( \ud835\udeff \u2032 + \u2211\ufe01 \ud835\udc5a\u2264\ud835\udc58 \ud835\udeff\ud835\udc58 \u2264 \ud835\udeff )\nis a valid approx-DP continuation rule for noninteractive mechanisms and interactive mechanisms.\nTheorem 3.8 ((\ud835\udf16, \ud835\udeff)-DP privacy odometer). Let \ud835\udeff = \ud835\udeff \u2032 + \ud835\udeff \u2032\u2032 be a target approximation parameter such that \ud835\udeff \u2032 > 0, \ud835\udeff \u2032\u2032 \u2265 0. Then\nG((\ud835\udf161, \ud835\udeff1), . . . , (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 ))\n=  (\u221a\ufe02 2 log ( 1 \ud835\udeff \u2032 ) \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf16 2 \ud835\udc5a + 12 \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf16 2 \ud835\udc5a, \ud835\udeff ) if \ud835\udeff \u2032 +\u2211\ud835\udc5a\u2264\ud835\udc58 \ud835\udeff\ud835\udc5a \u2264 \ud835\udeff (\u221e,\u221e) otherwise\nis a valid approx-DP privacy-loss accumulator for noninteractive and interactive mechanisms."
        },
        {
            "heading": "4 CONCURRENT FILTER & ODOMETER FOR",
            "text": "R\u00c9NYI-DP\nR\u00e9nyi DP is a relaxation of DP based on R\u00e9nyi divergences. In this section, we show that privacy loss adds up for R\u00e9nyi DP, in the setting of concurrent composition with adaptive privacy-loss parameters. This bound matches naturally with the previous concurrent composition result where all privacy-loss parameters are fixed upfront.\nDefinition 4.1 (R\u00e9nyi divergence [19]). For two probability distributions \ud835\udc43 and \ud835\udc44 , the R\u00e9nyi divergence of order \ud835\udefc > 1 is\n\ud835\udc37\ud835\udefc (\ud835\udc43 | |\ud835\udc44) = 1 \ud835\udefc \u2212 1 log E\ud835\udc65\u223c\ud835\udc44 [ \ud835\udc43 (\ud835\udc65) \ud835\udc44 (\ud835\udc65) ]\ud835\udefc .\nDefinition 4.2 (R\u00e9nyi DP [17]). A randomized mechanismM is (\ud835\udefc, \ud835\udf16)-R\u00e9nyi differentially private (\ud835\udf16-RDP\ud835\udefc ) if for all every two neighboring datasets \ud835\udc65 and \ud835\udc65 \u2032,\n\ud835\udc37\ud835\udefc (M(\ud835\udc65) | |M(\ud835\udc65 \u2032)) \u2264 \ud835\udf16\nIn our generalized DP framework in Definition 2.1, for R\u00e9nyi DP of order \ud835\udefc , the partially ordered set D is ((R\u22650) \u222a {\u221e}, \u2264). The distance mapping is \ud835\udefc-R\u00e9nyi divergence for \ud835\udefc \u2208 (1,\u221e). R\u00e9nyi divergence is also closed under postprocessing due to the dataprocessing inequality, and it satisfies the joint convexity. We will notate RDP\ud835\udefc as the family of distance measures corresponding to RDP, where D = (\ud835\udefc, \u00b7)-RDP = RDP\ud835\udefc .\nOur proof leverages the\ud835\udc3e = 2 case of the concurrent composition theorem proved by Lyu [16], where the privacy-loss parameters are specified unfront.\nTheorem 4.3 (Concurrent composition of R\u00e9nyi-DP mechanisms [16]). For all \ud835\udefc > 1, \ud835\udc58 \u2208 N, \ud835\udf161, . . . , \ud835\udf16\ud835\udc58 > 0, and all interactive mechanismsM1, . . . ,M\ud835\udc58 such thatM\ud835\udc56 is \ud835\udf16\ud835\udc56 -RDP\ud835\udefc , the concurrent composition ConComp(M1, . . . ,M\ud835\udc58 ) is \u2211\ud835\udc58 \ud835\udc56=1 \ud835\udf16\ud835\udc56 -RDP\ud835\udefc ."
        },
        {
            "heading": "4.1 Concurrent Filter for R\u00e9nyi-DP",
            "text": "Theorem 4.4 (Theorem 1.21 restated). An RDP filter with the\ncontinuation rule F (\ud835\udf161, \ud835\udf162, . . . ; \ud835\udf16) = I( \u2211 \ud835\udc56 \ud835\udf16\ud835\udc56 \u2264 \ud835\udf16) is a valid RDP IM-filter for every fixed order of \ud835\udefc > 1.\nThough generalized probability distance also covers RDP, the reduction in Theorem 3.3 holds only if the probability distance also satisfies properties of coupling and chain rule [22], which RDP does not. Therefore, we use a different strategy to prove 4.4. We prove this theorem by inducting on a finite number of mechanisms being maintained by the F -filtered concurrent composition of interactive mechanisms F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), and then taking the limit of those mechanisms. To do so, we first consider F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) maintains up to \ud835\udc3e mechanisms.\nLemma 4.5. Let \ud835\udefc > 1 and define F\ud835\udc3e (\ud835\udf161, \ud835\udf162, . . . , \ud835\udf16\ud835\udc58 ; \ud835\udf16) = { I(\u2211\ud835\udc58\ud835\udc56=1 \ud835\udf16\ud835\udc56 \u2264 \ud835\udf16) if \ud835\udc58 \u2264 \ud835\udc3e 0 otherwise\nThen F\ud835\udc3e is a valid RDP\ud835\udefc IM-filter.\nProof. We prove this by inducting on the maximum number \ud835\udc3e of mechanisms that F\ud835\udc3e -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) maintains. Fix a pair of\ndatasets \ud835\udc65, \ud835\udc65 \u2032. By Lemma 2.3, it suffices to consider a deterministic adversary to prove this theorem.\nBase case: \ud835\udc3e = 2. Intuitively, with two mechanisms, the budget partition is determined before any mechanisms are queried, so we can reduce the problem to concurrent RDP composition. Suppose the adversary starts a \ud835\udf161-RDP\ud835\udefc mechanismM1 through F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40). By the constraints of F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), the second mechanism M2 it is able to start must have privacy parameter \ud835\udf162 \u2264 \ud835\udf16 \u2212 \ud835\udf161. The adversary can adaptively interleave queries betweenM1 andM2.\nWe will first define the notion of a universal mechanism to help us with the reduction. Informally, a \u201cuniversal\u201d mechanism can be any mechanism with the privacy loss bounded by the preset privacy loss budget. The universal mechanism will first verify if a M attempted by an adversary to start satisfies the given privacy loss parameter guarantee as well as if the given privacy loss parameter does not exceed the preset privacy loss budget. Upon verifying this, it will interact with the adversary asM. Given a preset privacy budget \ud835\udf16 for an RDP\ud835\udefc universal mechanismU(\ud835\udc60,\ud835\udc5a) would operate as follows:\n(1) If\ud835\udc5a = \ud835\udf06, initialize \ud835\udc60 = (\ud835\udc65, ()) and return (\ud835\udc60, \ud835\udf06) (2) If\ud835\udc5a = (M, \ud835\udf161), whereM is an RDP\ud835\udefc mechanism: (a) If \ud835\udc60 = (\ud835\udc65, ()) and \ud835\udf161 \u2264 \ud835\udf16 , let \ud835\udc60\u2032 = (\ud835\udc65, (M, \ud835\udf161, \ud835\udc60M )) and\n\ud835\udc5a\u2032 = yes (b) Else let \ud835\udc60\u2032 = \ud835\udc60 and\ud835\udc5a\u2032 = invalid query\n(3) If\ud835\udc5a = \ud835\udc5e, where \ud835\udc5e is a query: (a) If \ud835\udc60 = (\ud835\udc65, ()), let \ud835\udc60\u2032 = \ud835\udc60 and\ud835\udc5a\u2032 = no mechanism to query (b) Else parse \ud835\udc60 = (\ud835\udc65, (M, \ud835\udf161, \ud835\udc60M )):\n(i) Let (\ud835\udc60\u2032M ,\ud835\udc5a \u2032) =M(\ud835\udc60M , \ud835\udc5e)\n(ii) Let \ud835\udc60\u2032 = (\ud835\udc65, (M, \ud835\udf161, \ud835\udc60\u2032M )) (4) Return (\ud835\udc60\u2032,\ud835\udc5a\u2032) Given an adversary A and an interaction between A and F2\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), we will construct an adversary A\u2032 that interacts with ConComp(M1,U2), whereU2 is a universal (\ud835\udf16 \u2212 \ud835\udf161)-RDP\ud835\udefc mechanism, and the adversary\u2019s first query toU2 is an \ud835\udf162-RDP\ud835\udefc mechanismM2. For each queryA makes to F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) prior to startingM2, A\u2032 will make a query toM1. When A startsM2, A\u2032 will make its first query toU2. Upon verifying \ud835\udf162 \u2264 \ud835\udf16 \u2212 \ud835\udf161,U2 interacts with the adversary just asM2 does. Afterward, A\u2032 can interleave queries at will betweenM1 andM2, interacting with ConComp(M1,U2) just as A does with F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40).\nNotice that in this case, View(A\u2032 \u2194 ConComp(M1,U2) (\ud835\udc65)) \u2261 View(A\u2032 \u2194 ConComp(M1,M2) (\ud835\udc65)), and the same holds for the computation on\ud835\udc65 \u2032. By Theorem 4.3, ConComp(M1,M2) is \ud835\udf16-RDP\ud835\udefc , which means F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) an \ud835\udf16-RDP\ud835\udefc I.M. By Definition 2.8, F2 (\u00b7; \ud835\udf16) is a valid RDP\ud835\udefc IM-filter.\nInduction on \ud835\udc3e .We assume that F\ud835\udc3e\u22121-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is differentially private. We define the postprocessing P interacting with F2\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) so that for any\ud835\udc3e > 1 and dataset\ud835\udc65 , View(A \u2194 P\u25e6F2\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65)) \u2261 View(A \u2194 F\ud835\udc3e -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65)). The algorithmic pseudocode of P is in the Appendix in Algorithm 11.\nGiven a privacy-loss budget \ud835\udf16 , suppose the adversary starts a \ud835\udf161-RDP\ud835\udefc mechanismM1 with \ud835\udf161 \u2264 \ud835\udf16 . Inductively assume F\ud835\udc3e\u22121\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40)\ud835\udefc,\ud835\udf16\u2212\ud835\udf161 (\ud835\udc65, \u00b7) is an (\ud835\udf16 \u2212 \ud835\udf161)-RDP\ud835\udefc I.M. As soon asM1 gets created, P will feed inM1 to F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40). Upon receiving confirmation that M1 has properly started, P will then feed in\n\ud835\udc39\ud835\udc58\u22121 to F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) with an \ud835\udf16 \u2212 \ud835\udf161 budget. We don\u2019t need to handle the parsing in the \ud835\udc63 = \ud835\udc44 section because P will always start two mechanisms at once. We can view F\ud835\udc3e\u22121-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) as the first query toU2.\nIf the adversary attempts to query mechanismM \ud835\udc57 where \ud835\udc57 > 1, then P will parse the query as a query to the ( \ud835\udc57 \u22121)st mechanism of F\ud835\udc3e\u22121-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), which is the second mechanism maintained by F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40). (Concretely, if the adversary thinks it\u2019s interacting concurrently with F4-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) maintainingM1,M2,M3,M4, thenM2,M3,M4 would be underF3-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) asM1,M2,M3 respectively, and we\u2019ve assumed by induction that F3-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is R\u00e9nyi-differentially private.)\nBy construction, for any deterministic adversary A and dataset \ud835\udc65 , View(A \u2194 P \u25e6 F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65)) is identically distributed as View(A \u2194 F\ud835\udc3e -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65)). By Theorem 2.17, P \u25e6 F2\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is an \ud835\udf16-RDP\ud835\udefc I.M., which means F\ud835\udc3e -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is \ud835\udf16-RDP\ud835\udefc I.M. By Definition 2.8, F\ud835\udc3e is a valid RDP\ud835\udefc IM-filter. \u25a1\nTo show that the filter works with an unbounded number of mechanisms, we examine the behavior as \ud835\udc3e \u2192 \u221e. We define a sequence of measurable spaces that are well-behaved in that we can marginalize out distributions even when the sequence is not finite. Suppose (\u03a9\u221e, \u0393\u221e) is the direct product of an infinite sequence of measurable spaces (\u03a91, \u03931), (\u03a92, \u03932), . . . , i.e.\u03a9\u221e = \u03a91\u00d7\u03a92\u00d7. . . and \u0393\u221e is the smallest \ud835\udf0e-algebra containing all cylinder sets \ud835\udc46\ud835\udc5b (\ud835\udc34) = {\ud835\udc65\u221e \u2208 \u03a9\u221e | \ud835\udc651, \ud835\udc652, . . . , \ud835\udc65\ud835\udc5b \u2208 \ud835\udc34}, \ud835\udc34 \u2208 \u0393\ud835\udc5b , for \ud835\udc5b = 1, 2, . . . and \u0393\ud835\udc5b = \u03931\u2297\u03932\u2297\u00b7 \u00b7 \u00b7\u2297\u0393\ud835\udc5b . We call a sequence of probability distributions \ud835\udc431, \ud835\udc432, . . . consistent if \ud835\udc43\ud835\udc5b is a distribution on\u03a9\ud835\udc5b = \u03a91\u00d7\u03a92\u00d7\u00b7 \u00b7 \u00b7\u00d7\u03a9\ud835\udc5b and \ud835\udc43\ud835\udc56+1 (\ud835\udc34 \u00d7 \u03a9\ud835\udc56+1) = \ud835\udc43\ud835\udc56 (\ud835\udc34) for \ud835\udc34 \u2208 \u0393\ud835\udc56 , \ud835\udc56 = 1, . . . , \ud835\udc5b.\nFor any such sequence there exists a distribution \ud835\udc43\u221e on (\u03a9\u221e, \u0393\u221e) such that its marginal distribution on \u03a9\ud835\udc5b is \ud835\udc43\ud835\udc5b , in the sense that \ud835\udc43\u221e (\ud835\udc46\ud835\udc5b (\ud835\udc34)) = \ud835\udc43\ud835\udc5b (\ud835\udc34), \ud835\udc34 \u2208 \u0393\ud835\udc5b .\nLemma 4.6 ([23]). Let \ud835\udc431, \ud835\udc432, . . . and \ud835\udc441, \ud835\udc442, . . . be consistent sequences of probability distributions on (\u03a91, \u03931), (\u03a92, \u03932), . . . , where, for \ud835\udc5b = 1, 2, . . . ,\u221e, (\u03a9\ud835\udc5b, \u0393\ud835\udc5b) is the direct product of the first \ud835\udc5b measurable spaces in the infinite sequence (\u03a91, \u03931), (\u03a92, \u03932), . . . . Then for any \ud835\udc4e \u2208 (0,\u221e]\nlim \ud835\udc5b\u2192\u221e\n\ud835\udc37\ud835\udefc (\ud835\udc43\ud835\udc5b | |\ud835\udc44\ud835\udc5b) = \ud835\udc37\ud835\udefc (\ud835\udc43\u221e | |\ud835\udc44\u221e).\nProof of Theorem 4.4. Fix a pair of datasets \ud835\udc65, \ud835\udc65 \u2032 and a divergence parameter \ud835\udefc > 1. Consider a F\ud835\udc58 (\u00b7; \ud835\udf16)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) with exactly \ud835\udc58 queries in its View. (Note that this implies the adversary interacts with\ud835\udc58 queries atmaximum, keepingwithin the constraints\nof the concurrent filter.) Let \ud835\udc5e\ud835\udc56 denote the adversary\u2019s \ud835\udc56th query and \ud835\udc4e\ud835\udc56 denote the answer to the adversary\u2019s \ud835\udc56th query.\nDefine sequences of random variables \ud835\udc4b1, . . . , \ud835\udc4b\ud835\udc58 and \ud835\udc4c1, . . . , \ud835\udc4c\ud835\udc58 where \ud835\udc4b\ud835\udc56 := (\ud835\udc5e1, \ud835\udc4e1, . . . , \ud835\udc5e\ud835\udc56 , \ud835\udc4e\ud835\udc56 ) on \ud835\udc65 and \ud835\udc4c\ud835\udc56 := (\ud835\udc5e1, \ud835\udc4e1, . . . , \ud835\udc5e\ud835\udc56 , \ud835\udc4e\ud835\udc56 ) on \ud835\udc65 \u2032. The corresponding distributions for\ud835\udc4b\ud835\udc56 , \ud835\udc4c\ud835\udc56 are\ud835\udc4b \ud835\udc56 , \ud835\udc4c \ud835\udc56 respectively. By construction, both the sequences of \ud835\udc4b\ud835\udc56 and \ud835\udc4c\ud835\udc56 are consistent.\nBy Theorem 4.3, for every \ud835\udc58 = 1, 2, . . . and \ud835\udefc > 1, we have \ud835\udc37\ud835\udefc (\ud835\udc4b\ud835\udc58 | |\ud835\udc4c\ud835\udc58 ) \u2264 \u2211\ud835\udc58 \ud835\udc56=1 \ud835\udf16\ud835\udc56 , where equality holds if each query starts\na new mechanism. By construction, \u2211\ud835\udc58 \ud835\udc56=1 \ud835\udf16\ud835\udc56 \u2264 \ud835\udf16 . Then, invoking Lemma 4.6,\n\ud835\udc37\ud835\udefc (\ud835\udc4b\u221e | |\ud835\udc4c\u221e) = lim \ud835\udc58\u2192\u221e \ud835\udc37\ud835\udefc (\ud835\udc4b\ud835\udc58 | |\ud835\udc4c\ud835\udc58 ) \u2264 \ud835\udf16,\nwhere the last inequality is because the sequence of \ud835\udc37\ud835\udefc (\ud835\udc4b\ud835\udc58 | |\ud835\udc4c\ud835\udc58 ) monotonically increases as \ud835\udc58 \u2192\u221e, and is bounded above by \ud835\udf16 . \u25a1\nOur approach can be used to simplify the proof in [10] for the bounds on privacy filters for sequentially-composed noninteractive DP mechanisms. They identify the sequence of losses incurred for each query \u2013 in this case the invocation of a noninteractive mechanism and the reception of its answers \u2013 as a supermartingale. They then apply the optional stopping theorem for martingales to bound the divergence between adjacent datasets and verify the validity of the filter.\nThe basis for our proof is that concurrent composition of two interactive RDPmechanisms implies a fully adaptive F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40). Having interactivity allows us to proceed by induction in the proof of Lemma 4.5, describing F\ud835\udc58 in terms of F\ud835\udc58\u22121. We could do the same for the sequential composition since induction preserves sequentiality. Then by Lemma 4.5, F\ud835\udc58 -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc46\ud835\udc52\ud835\udc5e(\ud835\udc3c\ud835\udc40) is an \ud835\udf16-RDP\ud835\udefc I.M. Thus, the sequential composition of two interactive R\u00e9nyi DPmechanisms of order \ud835\udefc implies a fully adaptive filter for sequential composition of RDP mechanisms of order \ud835\udefc ."
        },
        {
            "heading": "4.2 Concurrent Odometer for R\u00e9nyi-DP",
            "text": "Because of the bijective relationship between valid continuation rules and privacy-loss accumulators, we are able to define an additive relationship for concurrent odometers of R\u00e9nyi mechanisms as well.\nTheorem 4.7 (Valid \ud835\udf16-RDP\ud835\udefc odometer for concurrently\u2013 composed interactive mechanisms). Let \ud835\udefc > 1. Let G : D\u2217 \u2192 D be a relation. IfG(\ud835\udf161, . . . , \ud835\udf16\ud835\udc3e ) = \u2211\ud835\udc3e \ud835\udc56=1 \ud835\udf16\ud835\udc56 , thenG is a valid privacy-loss accumulator for the concurrent composition of a sequence of mechanismsM1,M2, . . . , whereM\ud835\udc56 is an \ud835\udf16\ud835\udc56 -RDP\ud835\udefc interactive mechanism.\nProof. Define a relation F (\ud835\udf161, . . . , \ud835\udf16\ud835\udc3e ; \ud835\udf16) : D\u2217 \u00d7 D \u2192 D such that F (\ud835\udf161, . . . , \ud835\udf16\ud835\udc3e ; \ud835\udf16) = I(G(\ud835\udf161, . . . , \ud835\udf16\ud835\udc3e \u2264 \ud835\udf16). By Theorem 4.4, F is a valid RDP\ud835\udefc filter. By Lemma 2.19, G is a valid privacy-loss accumulator for R\u00e9nyi mechanisms of order \ud835\udefc . \u25a1"
        },
        {
            "heading": "5 IMPLEMENTATION",
            "text": "In this section, we provide an overview of the implementation of differentially private mechanisms in the open-source software project OpenDP and the Tumult Analytics platform.We then discuss the implications of our results on the two platforms."
        },
        {
            "heading": "5.1 Practical Application in the OpenDP Library",
            "text": "The OpenDP Library [11] is a modular collection of statistical algorithms used to build differentially private computations. The OpenDP Library represents differentially private computations with measurements and odometers. Measurements and odometers fully characterize the privacy guarantees they give in terms of an input domain, input metric, and privacy measure. They both contain a function to make a differentially private release and a privacy map to reason about the privacy spend of a release. A privacy map is a function that takes in a bound on the distance between adjacent inputs/datasets (\ud835\udc51\ud835\udc56\ud835\udc5b), and translates it to a bound on the distance between respective outputs (\ud835\udc51\ud835\udc5c\ud835\udc62\ud835\udc61 , a privacy parameter). From the perspective of the library, an interactive measurement is simply a measurement for which the function emits a queryable (Figure 3), OpenDP terminology for an object that implements an interactive mechanism. A queryable is modeled as an opaque state machine, consisting of an internal state value and a transition function. When an analyst passes a query into the queryable, the state is updated, and an answer is returned.\nAll interactivity in the OpenDP Library uses queryables, and the privacy guarantee of an interactive measurement is defined exactly as in Definitions 1.7 and 2.2, quantitatively for all possible adversary\u2019s strategies A.\nInteractive measurements are well-suited to capture interactive composition when the desired privacy parameters for each query are known up-front. For example, the internal state of a compositor queryable consists of the dataset and per-query privacy parameters. Each time a query \ud835\udc5e\ud835\udc56 (which may itself be a measurement) is passed to the compositor queryable, a privacy parameter (like \ud835\udf16\ud835\udc56 ) is popped off of its internal state. Unlike measurements, odometers always emit a queryable from their function, and the privacy map is maintained inside the queryable. OpenDP\u2019s implementation of odometers differs from the pseudocode in this paper, in that the input distance is not fixed up-front: the privacy_loss query also holds a \ud835\udc51\ud835\udc56\ud835\udc5b . Thus, queryables spawned by odometers can be queried with a bound on the distance between adjacent input datasets \ud835\udc51\ud835\udc56\ud835\udc5b , which returns the current corresponding privacy spend \ud835\udc51\ud835\udc5c\ud835\udc62\ud835\udc61 .\nThe state of odometer queryables in OpenDP consist of the dataset and a vector of privacy maps (one from each query). When the odometer queryable is passed a privacy-loss query, the queryable passes \ud835\udc51\ud835\udc56\ud835\udc5b from the query into each of the child privacy maps stored in its state, which emit the \ud835\udc51\ud835\udc56 used in Algorithms 4 and 6. The privacy loss returned is the composition of these privacy loss parameters.\nA filter is an instance of an interactive measurement. Any odometer can be converted into a filter IM by fixing an upper bound on\nthe privacy parameters, as in Lemma 2.19. That is, any queryable spawned by the filter IM will refuse to answer any queries that would exceed the configured privacy parameters.\nThe OpenDP Library uses \u201cwrapping\u201d to handle situations where a queryable must influence the behavior of queryables it spawns in order to uphold its privacy guarantees. For example, a sequential composition queryable must wrap any queryables it spawns in a logic that first asks the sequential compositor queryable for permission to execute (which allows the sequential compositor to maintain sequentiality), executes the query, and then recursively wraps any queryable in the answer with the same logic.\nConcurrent composition improves upon sequential composition in that concurrent composition does not need to influence the behavior of child queryables. Thus, concurrent compositors, odometers, and filters benefit from a simple implementation, in that they do not need to implement complicated sequentiality constraints via \u201cwrapping\u201d. More specifically, implementing any composition primitive for interactive mechanisms is more complex than for noninteractive mechanisms, as the composition primitive needs to provide the analyst/adversary access to many interactive mechanisms (in such a way that the only access to the sensitive data is through queries, and in particular ensuring that the private internal state of the mechanisms cannot be inspected directly), in contrast to simply sending the analyst the results of noninteractive mechanisms. In the case of sequential composition, the compositor implementation had to be even more complex in order to enforce sequentiality; our work removes the need for this additional complexity.\nConcurrent composition also allows the analyst to work in a more exploratory fashion. By allowing non-sequential access to mechanisms, the analyst is free to sequence their queries arbitrarily. Analysts may also return to previous (un-exhausted) mechanisms without incurring additional privacy penalties for burn-in. This will also allow analysts to interact with multiple mechanisms simultaneously in settings where computational concurrency may make sequencing ambiguous. Our filter and odometer theorems also allow analysts to choose privacy parameters adaptively, and partition their privacy budget across different mechanisms, providing added flexibility.\nWe provide our implementation of concurrent composition based on the OpenDP Library on Github at https://github.com/concurrentcomposition/concurrent-composition."
        },
        {
            "heading": "5.2 Practical Application in the Tumult Framework",
            "text": "Tumult Analytics [14] [1] is an open-source framework for releasing aggregate information from sensitive datasets with differential privacy. Analytics queries are evaluated using differentially private mechanisms in the context of a Tumult Analytics session, which is essentially a privacy filter. Analytics is written on top of Tumult Core, a framework for constructing differentially private mechanisms with automated privacy guarantees. Interactive mechanisms are the basic abstraction for interactivity in Tumult Core (an interactive mechanism is called a queryable in Tumult Core). Tumult Core currently restricts interleaving queries to the composition of queryables to prevent concurrent composition. For example, suppose we start with a privacy filter queryable, and our first query\nspawns a new queryable using some portion of the budget. Tumult Core requires that the user finish interacting with this spawned queryable before asking a new query to the parent privacy filter, otherwise we may (adaptively) spawn a second queryable and concurrently ask queries of both spawned queryables. Note that while certain concurrent composition results are known from prior work, Tumult Core currently does not allow concurrent composition under any circumstances to reduce code complexity and maintain UX consistency. The results in this paper allows for removing this restriction.\nAlthough spawning queryables within queryables may seem niche, one common application in Tumult Analytics is with parallel composition. Parallel composition in differential privacy says that if we partition a dataset and run DP queries on each subset in the partition, the overall privacy loss is the maximum privacy loss across the mechanisms. In Tumult Analytics, the mechanisms the user runs on each subset of the partitioned data can be interactive. Under the hood, this is implemented as follows: the top level privacy filter spawns a new interactive mechanism, consisting of multiple privacy filters (one for each subset in the partition). To prevent concurrent composition where it is not allowed, we require that the user finish interacting with this parallel composition interactive mechanism before they can ask any more queries of the top-level privacy filter, or spawn a new parallel composition mechanism from the top-level privacy filter.\nThe results in this paper allow for removing the restrictions on concurrent composition, and thereby improve the existing system in two ways. First, it reduces code complexity and improves auditablility. The privacy guarantee of an interactive mechanism is contingent on the promise that there will be no concurrent composition in scenarios where it is not allowed. This property is more challenging to verify than other properties of the system that contribute to the privacy guarantee required, which tend to be localized and easy to verify in isolation.\nSecond, removing restrictions on concurrent composition improves the UX of Tumult Analytics. As mentioned previously, users of Analytics must finish interacting with one queryable before they start interacting with a subsequent queryable, and this multiqueryable scenario happens frequently when using parallel composition. This has the potential to cause issues:\n\u2022 It a possible a user could have a reason for wanting to interleave queries to two or more queryables. \u2022 Even if interleaving queries isn\u2019t required, the usermay structure their code such that queries to multiple queryables are interleaved. This would cause the user to see an unfamiliar error, and require them to restructure their code.\nBoth of these issues would be solved if restrictions on concurrent composition for privacy filters was removed, which the results of our paper can enable."
        },
        {
            "heading": "ACKNOWLEDGMENTS",
            "text": "S.V. is supported by a gift from Apple, NSF grant BCS-2218803, a grant from the Sloan Foundation and a Simons Investigator Award. V.X. is supported in part by NSF grant BCS-2218803. W.Z. is supported in part by a Computing Innovation Fellowship from the\nComputing Research Association (CRA) and the Computing Community Consortium (CCC), and the BU Census grant."
        },
        {
            "heading": "A ALGORITHMS A.1 Algorithm for proof of Theorem 3.4",
            "text": "In this section, we enclose the IM-to-IM postprocessing algorithm P for the proof of Theorem 3.4. P will interact with F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40) only to initialize and return F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40)\u2019s response for a new\nnoninteractive \ud835\udc53 -DP mechanism, if an adversary asks to start an interactive \ud835\udc53 -DP mechanism. Otherwise, for a query to mechanismM \ud835\udc57 , P will use the NIM-to-IM postprocessing ofM \ud835\udc57 , P\ud835\udc57 , to answer the query. This allows any adversary A to interact with F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40) as if it were interacting with F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40).\nAlgorithm 10 Interactive postprocessing P that transforms \ud835\udc53 -DP F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40) into F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40). procedure P(\ud835\udc60, \ud835\udc63,\ud835\udc5a; \ud835\udc5f ):\n\ud835\udc58 \u2190 number of mechanisms (started or attempting to start) if \ud835\udc5a = \ud835\udf06 then \u22b2 initialize P\n\ud835\udc60\u2032 \u2190 \ud835\udf06, \ud835\udc63 \u2190 \ud835\udc34 return (\ud835\udc60\u2032, \ud835\udc63, \ud835\udf06)\nend if if \ud835\udc63 = \ud835\udc44 then \u22b2 P accepting queries\nif \ud835\udc5a = (M\u2032, \ud835\udc53 \u2032) then \u22b2 A starts a new mechanism Let P\ud835\udc58+1 be the interactive postprocessing for nonin-\nteractive mechanism N\ud835\udc58+1 so that P\ud835\udc58+1 (N\ud835\udc58+1) \u2261 M\ud835\udc58+1 Parse \ud835\udc60P as ((P1, \ud835\udc60P1 , \ud835\udc531), . . . , (P\ud835\udc58 , \ud835\udc60P\ud835\udc58 , \ud835\udc53\ud835\udc58 )) \ud835\udc60P \u2032 \u2190 ((P1, \ud835\udc60P1 , \ud835\udc531), . . . , (P\ud835\udc58+1, pending, \ud835\udc53\ud835\udc58+1))\n\ud835\udc5a\u2032 \u2190 (N\ud835\udc58+1, \ud835\udc53\ud835\udc58+1) else if \ud835\udc5a = ( \ud835\udc57, \ud835\udc5e) where \ud835\udc57 = 1, . . . , \ud835\udc58 and \ud835\udc5e is a query to\nM \ud835\udc57 then \u22b2 A queries an old mechanism Parse \ud835\udc60P as ((P1, \ud835\udc60P1 , \ud835\udc531), . . . , (P\ud835\udc58 , \ud835\udc60P\ud835\udc58 , \ud835\udc53\ud835\udc58 )) (\ud835\udc60P \u2032 \ud835\udc57 ,\ud835\udc5a\ud835\udc56+1) \u2190 P\ud835\udc57 (\ud835\udc60P\ud835\udc57 , \ud835\udc5e)\n\ud835\udc60P \u2032 \u2190 ((P1, \ud835\udc60P1 , \ud835\udc531), . . . , (P\ud835\udc57 , \ud835\udc60P \u2032 \ud835\udc57 , \ud835\udc53\ud835\udc57 ), . . . (P\ud835\udc58 , \ud835\udc60P\ud835\udc58 , \ud835\udc53\ud835\udc58 ))\nend if return (\ud835\udc60P\u2032 , \ud835\udc34,\ud835\udc5a\u2032)\nelse if \ud835\udc63 = \ud835\udc34 then \u22b2 P accepting answers if \ud835\udc5a = no then \u22b2 did not successfully start a new\nmechanism \ud835\udc60P \u2032 \u2190 ((P1, \ud835\udc60P1 , \ud835\udc531), . . . , (P\ud835\udc58 , \ud835\udc60P\ud835\udc58 , \ud835\udc53\ud835\udc58 ))\n\ud835\udc5a\u2032 \u2190\ud835\udc5a else\u22b2 noninteractive output to starting a new mechanism\nParse \ud835\udc60P as ((P1, \ud835\udc60P1 , \ud835\udc531), . . . , (P\ud835\udc58 , pending, \ud835\udc53\ud835\udc58 )) (\ud835\udc60P\ud835\udc58 ,\ud835\udc5a\u2032) \u2190 P(\ud835\udf06,\ud835\udc34,\ud835\udc5a) \u22b2 set up new interactive\npostprocessor\u2019s state \ud835\udc60P \u2032 \u2190 ((P1, \ud835\udc60P1 , \ud835\udc531), . . . , (P\ud835\udc58 , \ud835\udc60P\ud835\udc58 , \ud835\udc53\ud835\udc58 ))\n\ud835\udc63 \u2190 \ud835\udc44 \u22b2 update \ud835\udc63 to be accepting queries end if return (\ud835\udc60P\u2032 , \ud835\udc34,\ud835\udc5a\u2032)\nend if end procedure\nA.2 Algorithm for proof of Lemma 4.5 In this section, we enclose the algorithm IM-to-IM postprocessing algorithm P for the proof of Lemma 4.5. This algorithm assumes inductively that F\ud835\udc3e\u22121-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is a valid RDP\ud835\udefc filter. For any adversary, when receiving the adversary\u2019s request to startM1 and verifying the privacy loss is within budget, P will start bothM1 and F\ud835\udc3e\u22121-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) in F2-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40). P will directly pass on queries toM1. For queries \ud835\udc5e toM \ud835\udc57 where \ud835\udc57 > 1 (in the form ( \ud835\udc57, \ud835\udc5e)), P will postprocess the message as (2, ( \ud835\udc57 \u2212 1), \ud835\udc5e), indicating that P is passing \ud835\udc5e on to the ( \ud835\udc57 \u2212 1)th mechanism of F\ud835\udc3e\u22121-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40).\nAlgorithm 11 Interactive postprocessing P that transforms F2\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) into F\ud835\udc3e -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40).\nprocedure P(\ud835\udc60, \ud835\udc63,\ud835\udc5a; \ud835\udc5f ): \ud835\udc58 \u2190 number of mechanisms (started or attempting to start) \ud835\udc3e \u2190 maximum number of mechanisms if \ud835\udc5a = \ud835\udf06 then \u22b2 initialize P\n\ud835\udc60\u2032 \u2190 \ud835\udf06, \ud835\udc63 \u2190 \ud835\udc34 return (\ud835\udc60\u2032, \ud835\udc63, \ud835\udf06)\nend if if \ud835\udc63 = \ud835\udc44 then \u22b2 P accepting queries\nif \ud835\udc5a = (M\u2032, (\ud835\udefc, \ud835\udf16\u2032)) then \u22b2 A starts a new mechanism if \ud835\udc58 = 0 then \u22b2 currently maintaining no\nmechanisms M1 \u2190M\u2032, \ud835\udf161 \u2190 \ud835\udf16\u2032 \ud835\udc4f1 \u2190 no \u22b2 \ud835\udc4f1 is the boolean keeping track of whetherM1 has successfully started \ud835\udc60P \u2032 \u2190 ((M1, (\ud835\udefc, \ud835\udf161), \ud835\udc4f1))\nelse \ud835\udc60P \u2032 \u2190 \ud835\udc60P\nend if \ud835\udc5a\u2032 \u2190\ud835\udc5a \u22b2 pass on the query; the filter will handle\nany rejections else if \ud835\udc5a = ( \ud835\udc57, \ud835\udc5e) where \ud835\udc57 = 1, . . . , \ud835\udc3e and \ud835\udc5e is a query to M \ud835\udc57 then \u22b2 A queries an old mechanism if \ud835\udc57 = 1 then \u22b2 queryingM1\n\ud835\udc60P \u2032 \u2190 \ud835\udc60P ,\ud835\udc5a\u2032 \u2190\ud835\udc5a\nelse \u22b2 querying anything other thanM1 \ud835\udc5a\u2032 \u2190 (2, ( \ud835\udc57 \u2212 1, \ud835\udc5e)) \ud835\udc60P \u2032 \u2190 \ud835\udc60P ,\ud835\udc5a\u2032 \u2190\ud835\udc5a\nend if end if \ud835\udc63 \u2190 \ud835\udc34 \u22b2 we will be talking to the mechanism next return (\ud835\udc60P\u2032 , \ud835\udc44,\ud835\udc5a\u2032) else if \ud835\udc63 = \ud835\udc34 then \u22b2 P accepting answers if \ud835\udc5a = yes and \ud835\udc58 = 1 then \u22b2 successfully startedM1\n\ud835\udc4f1 \u2190 yes \ud835\udc5a\u2032 \u2190 (F\ud835\udc3e\u22121-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), (\ud835\udefc, \ud835\udf16 \u2212 \ud835\udf161)) \ud835\udc60P \u2032 \u2190 ((M1, (\ud835\udefc, \ud835\udf161), \ud835\udc4f1), (F\ud835\udc3e\u22121-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), (\ud835\udefc, \ud835\udf16\u2212\n\ud835\udf161), no)) \u22b2 start F\ud835\udc3e\u22121-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) immediately return (\ud835\udc60P\u2032 , \ud835\udc44,\ud835\udc5a\u2032) \u22b2 pass on the query\nelse \ud835\udc60P \u2032 \u2190 \ud835\udc60P , \ud835\udc63 \u2190 \ud835\udc44,\ud835\udc5a\u2032 \u2190\ud835\udc5a\nreturn (\ud835\udc60P\u2032 , \ud835\udc34,\ud835\udc5a\u2032) end if\nend if end procedure"
        },
        {
            "heading": "B PROOFS B.1 Proof of Lemma 2.19",
            "text": "In this section, we enclose the full proof of Lemma 2.19.\nLemma B.1 (Lemma 2.19 restated). (1) A functionG : D\u2217 \u2192 D, where D\u2217 = \u22c3\u221e\n\ud835\udc58=0D \ud835\udc58 , is a valid NIM-privacy-loss accu-\nmulator if and only if F : D\u2217 \u00d7 D \u2192 {0, 1} constructed\nfrom G(\u00b7) such that F (\u00b7;\ud835\udc51) = I(G(\u00b7) \u2aaf \ud835\udc51) is a valid D-DP NIM-filter. (2) A function G : D\u2217 \u2192 D, where D\u2217 = \u22c3\u221e \ud835\udc58=0D\n\ud835\udc58 , is a valid concurrent IM-privacy-loss accumulator if and only if F : D\u2217 \u00d7 D \u2192 {0, 1} constructed from G(\u00b7) such that F (\u00b7;\ud835\udc51) = I(G(\u00b7) \u2aaf \ud835\udc51) is a valid D-DP concurrent IM-filter.\nProof. We will prove the bijection relation for IM, as the proof for NIM holds similarly. Fix a pair of datasets \ud835\udc65, \ud835\udc65 \u2032.\n(1) \u21d0= Suppose that F (\u00b7;\ud835\udc51) = I(G(\u00b7) \u2aaf \ud835\udc51) is a validD DP concurrent IM-filter. Then byDefinition 2.8,F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is a \ud835\udc51-D DP interactive mechanism for every \ud835\udc51 \u2208 D. Because the continuation rule is F (\u00b7;\ud835\udc51) = I(G(\u00b7) \u2aaf \ud835\udc51), F (\u00b7;\ud835\udc51)- \ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) involves truncation the sameway the truncated view does in Algorithm 5. Thus, for an adversaryA interacting with G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), we can construct an interactive mechanismM that will behave exactly likeG-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) as in Algorithm 6, but on every round of operation also checks if G(\u00b7) \u2aaf\u0338 \ud835\udc51 , in which caseM will maintain its previous state and output halt message. It is easy to see that View(A \u2194M(\ud835\udc65)) is exactly the same as Trunc\ud835\udc51 (View(A \u2194 G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65))) for any database \ud835\udc65 . We now prove thatM is an interactive postprocessing of F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40). Define a postprocessing P as in Algorithm 12. This mechanism allowsM to behave the same as F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40), just adding additional support for the deterministic privacy_loss queries, which do not change the state of the odometer and therefore do not affect divergence. Therefore,\n\ud835\udc37 (Trunc\ud835\udc51 (View(A \u2194 G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65))) | | Trunc\ud835\udc51 (View(A \u2194 G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65 \u2032))))\n= \ud835\udc37 (View(A \u2194M(\ud835\udc65)) | |View(A \u2194M(\ud835\udc65 \u2032))) = \ud835\udc37 (View(A \u2194 P \u25e6 F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65) | |\nView(A \u2194 P \u25e6 F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65 \u2032))) \u2aaf \ud835\udc37 (View(A \u2194 F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65)) | |\nView(A \u2194 F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65 \u2032))) (3) \u2aaf \ud835\udc51,\nwhere (3) follows from Theorem 2.17. By Definition 2.14, G : D\u2217 \u2192 D is a valid D DP privacy-loss accumulator.\n(2) =\u21d2 Suppose thatG : D\u2217 \u2192 D is a validD DP privacy-loss accumulator. For every \ud835\udc51 \u2208 D, again, because the continuation rule is F (\u00b7;\ud835\udc51) = I(G(\u00b7) \u2aaf \ud835\udc51), F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) involves truncation the same way the truncated view does in Algorithm 5, i.e., halts when G(\u00b7) \u2aaf\u0338 \ud835\udc51 . We can use the same M as in the previous direction that is constructed such that, for an adversaryA and database \ud835\udc65 , View(A \u2194M(\ud835\udc65)) is exactly the same as Trunc\ud835\udc51 (View(A \u2194 G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65))). We now define an interactive postprocessing P that transformsM into F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) in Algorithm 13, which removes support for privacy_loss queries since F (\u00b7;\ud835\udc51)- \ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) would not support that. Other interaction is essentially preserved, sinceM and F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) will both halt when G(\u00b7) \u2aaf\u0338 \ud835\udc51 .\nAgain, because privacy_loss queries do not affect divergence, we have\n\ud835\udc37 (View(A \u2194 F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65) | | View(A \u2194 F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) (\ud835\udc65 \u2032)))\n= \ud835\udc37 (View(A \u2194 P \u25e6M(\ud835\udc65) | |View(A \u2194 P \u25e6M(\ud835\udc65 \u2032))) \u2aaf \ud835\udc37 (View(A \u2194M(\ud835\udc65)) | |View(A \u2194M(\ud835\udc65 \u2032))) (4) = \ud835\udc37 (Trunc\ud835\udc51 (View(A \u2194 G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40)) (\ud835\udc65) | |\nTrunc\ud835\udc51 (View(A \u2194 G-\ud835\udc42\ud835\udc51\ud835\udc5c\ud835\udc5a\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40)) (\ud835\udc65 \u2032))) \u2aaf \ud835\udc51, where (4) follows from Theorem 2.17. Thus, F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) is a \ud835\udc51-D DP interactive mechanism. By Definition 2.8, since this is true for arbitrary \ud835\udc51 , F is a valid D DP filter.\n\u25a1\nAlgorithm 12 Interactive postprocessing P that transforms F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40) intoM procedure P(\ud835\udc60, \ud835\udc63,\ud835\udc5a):\n\ud835\udc58 \u2190 number of mechanisms (started or attempting to start) if \ud835\udc5a = \ud835\udf06 then \u22b2 initialize P\n\ud835\udc60\u2032 \u2190 (G(\u00b7), []), \ud835\udc63 \u2190 \ud835\udc34, where [] is an empty list return (\ud835\udc60\u2032, \ud835\udc63, \ud835\udf06)\nend if if \ud835\udc63 = \ud835\udc44 then \u22b2 accepting queries from adversary\nif \ud835\udc5a = (M\u2032, \ud835\udc51\u2032) then Parse \ud835\udc60 as (G(\u00b7), [M1, . . . ,M\ud835\udc58 ]) \ud835\udc60\u2032 \u2190 (G(\u00b7), [M1, . . . ,M\ud835\udc58 , (M\ud835\udc58+1, pending)])\nelse if \ud835\udc5a = ( \ud835\udc57, \ud835\udc5e) where \ud835\udc57 = 1, . . . , \ud835\udc58 and \ud835\udc5e is a query to M \ud835\udc57 then\n\ud835\udc60\u2032 \u2190 \ud835\udc60 else if \ud835\udc5a = privacy_loss then\n\ud835\udc5a\u2032 \u2190 G(\u00b7) return (\ud835\udc60\u2032, \ud835\udc34,\ud835\udc5a\u2032)\nend if \ud835\udc5a\u2032 \u2190\ud835\udc5a \ud835\udc63 \u2032 \u2190 \ud835\udc44 , \ud835\udc63 \u2190 \ud835\udc34 \u22b2 pass query on to mechanism else if \ud835\udc63 = \ud835\udc34 then \u22b2 accepting answers from filter if \ud835\udc5a = yes then \u22b2 successfully started new mechanism\nParse \ud835\udc60 as (G(\u00b7), [M1, . . . , (M\ud835\udc58 , pending)]) \ud835\udc60\u2032 \u2190 (G(\u00b7), [M1, . . . ,M\ud835\udc58 ]) else if \ud835\udc5a = no then Parse \ud835\udc60 as (G(\u00b7), [M1, . . . , (M\ud835\udc58 , pending)]) \ud835\udc60\u2032 \u2190 (G(\u00b7), [M1, . . . ,M\ud835\udc58\u22121]) else \ud835\udc60\u2032 \u2190 \ud835\udc60\nend if \ud835\udc5a\u2032 \u2190\ud835\udc5a, \ud835\udc63 \u2032 \u2190 \ud835\udc34, \ud835\udc63 \u2190 \ud835\udc44 \u22b2 pass query on to adversary\nend if return (\ud835\udc60\u2032, \ud835\udc63 \u2032,\ud835\udc5a\u2032)\nend procedure\nAlgorithm 13 Interactive postprocessing P that transformsM into F (\u00b7;\ud835\udc51)-\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61\ud835\udc36\ud835\udc5c\ud835\udc5b(\ud835\udc3c\ud835\udc40)\nprocedure P(\ud835\udc60, \ud835\udc63,\ud835\udc5a): \ud835\udc58 \u2190 number of mechanisms (started or attempting to start) if \ud835\udc5a = \ud835\udf06 then \u22b2 initialize P\n\ud835\udc60\u2032 \u2190 (G(\u00b7), []), \ud835\udc63 \u2190 \ud835\udc34, where [] is an empty list return (\ud835\udc60\u2032, \ud835\udc63, \ud835\udf06)\nend if if \ud835\udc63 = \ud835\udc44 then \u22b2 accepting queries from adversary\nif \ud835\udc5a = (M\u2032, \ud835\udc51\u2032) then Parse \ud835\udc60 as (G(\u00b7), [M1, . . . ,M\ud835\udc58 ]) \ud835\udc60\u2032 \u2190 (G(\u00b7), [M1, . . . ,M\ud835\udc58 , (M\ud835\udc58+1, pending)])\nelse if \ud835\udc5a = ( \ud835\udc57, \ud835\udc5e) where \ud835\udc57 = 1, . . . , \ud835\udc58 and \ud835\udc5e is a query to M \ud835\udc57 then\n\ud835\udc60\u2032 \u2190 \ud835\udc60 else if \ud835\udc5a = privacy_loss then \u22b2 remove support for\nprivacy loss queries \ud835\udc5a\u2032 \u2190 invalid query return (\ud835\udc60\u2032, \ud835\udc34,\ud835\udc5a\u2032)\nend if \ud835\udc5a\u2032 \u2190\ud835\udc5a \ud835\udc63 \u2032 \u2190 \ud835\udc44 , \ud835\udc63 \u2190 \ud835\udc34 \u22b2 pass query on to mechanism else if \ud835\udc63 = \ud835\udc34 then \u22b2 accepting answers from filter if \ud835\udc5a = yes then \u22b2 successfully started new mechanism\nParse \ud835\udc60 as (G(\u00b7), [M1, . . . , (M\ud835\udc58 , pending)]) \ud835\udc60\u2032 \u2190 (G(\u00b7), [M1, . . . ,M\ud835\udc58 ]) else if \ud835\udc5a = no then Parse \ud835\udc60 as (G(\u00b7), [M1, . . . , (M\ud835\udc58 , pending)]) \ud835\udc60\u2032 \u2190 (G(\u00b7), [M1, . . . ,M\ud835\udc58\u22121]) else \ud835\udc60\u2032 \u2190 \ud835\udc60\nend if \ud835\udc5a\u2032 \u2190\ud835\udc5a, \ud835\udc63 \u2032 \u2190 \ud835\udc34, \ud835\udc63 \u2190 \ud835\udc44 \u22b2 pass query on to adversary\nend if return (\ud835\udc60\u2032, \ud835\udc63 \u2032,\ud835\udc5a\u2032)\nend procedure\nB.2 Proof of Example 3.7 ((\ud835\udf16, \ud835\udeff)-DP filter) In this section, we demonstrate how the (\ud835\udf16, \ud835\udeff)-DP filter and odometer for noninteractive mechanisms defined in [24] correspond to the filter and odometer we construct in Algorithm 2 and Algorithm 4, respectively.\nExample B.2 (Example 3.7 restated). For every \ud835\udeff \u2032 > 0,\nF ((\ud835\udf161, \ud835\udeff1), . . . , (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 ); (\ud835\udf16, \ud835\udeff)) = I \u00a9\u00ab\ud835\udf16 \u2264 \u221a 2 log ( 1 \ud835\udeff \u2032 ) \u2211\ufe01 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf162\ud835\udc5a + 1 2 \u2211\ufe01 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf162\ud835\udc5a \u00aa\u00ae\u00ac \u00b7 I ( \ud835\udeff \u2032 + \u2211\ufe01 \ud835\udc5a\u2264\ud835\udc58 \u2264 \ud835\udeff )\nis a valid (\ud835\udf16, \ud835\udeff)-DP privacy filter.\nProof. This filter is translated from the following theorem from [24], who define an (\ud835\udf16, \ud835\udeff)-DP privacy filter in their notation as follows:\nTheoremB.3 ((\ud835\udf16, \ud835\udeff)-DP privacy filter [24]). SupposeM1,M2, . . . is a sequence of mechanisms such that, for any \ud835\udc58 \u2265 1,M\ud835\udc58 is (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 )- DP conditioned onM1, . . . ,M\ud835\udc58\u22121. Let \ud835\udf16 > 0 and \ud835\udeff = \ud835\udeff \u2032+\ud835\udeff \u2032\u2032 be a target approximation parameter such that \ud835\udeff \u2032 > 0, \ud835\udeff \u2032\u2032 \u2265 0. Define \ud835\udc41 :=\n\ud835\udc41 ((\ud835\udf161, \ud835\udeff1), (\ud835\udf162, \ud835\udeff2), . . . ) := inf{\ud835\udc58 \u2208 N : \ud835\udf16 < \u221a\ufe02 2 log ( 1 \ud835\udeff \u2032 ) \u2211 \ud835\udc5a\u2264\ud835\udc58+1 \ud835\udf16 2 \ud835\udc5a+\n1 2 \u2211 \ud835\udc5a\u2264\ud835\udc58+1 \ud835\udf16 2 \ud835\udc5a or \ud835\udeff \u2032\u2032 < \u2211 \ud835\udc5a\u2264\ud835\udc58+1 \ud835\udeff\ud835\udc5a}. Then the composition of these mechanisms \ud835\udc36\ud835\udc5c\ud835\udc5a\ud835\udc5d (M1, . . . ,M\ud835\udc41 ( \u00b7) ) is (\ud835\udf16, \ud835\udeff)-DP.\nM\ud835\udc58 being (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 )-DP conditioned on the previous mechanisms means the privacy-loss parameters are chosen adaptively. This is analogous to our setting for filters as defined in Algorithm 2, in which the adversary can send in a query that decomposes into a mechanism and distance, a signal to the filter to start a new mechanism. Since the query could depend on the history of interaction, the new mechanism\u2019s parameters are adaptively chosen.\nWe define F : D\u2217 \u2192 {1, 0} as F ((\ud835\udf161, \ud835\udeff1), . . . , (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 ); (\ud835\udf16, \ud835\udeff))\n= I \u00a9\u00ab \u221a 2 log ( 1 \ud835\udeff \u2032 ) \u2211\ufe01 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf162\ud835\udc5a + 1 2 \u2211\ufe01 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf162\ud835\udc5a \u2264 \ud835\udf16 \u00aa\u00ae\u00ac \u00b7 I ( \ud835\udeff \u2032 + \u2211\ufe01 \ud835\udc5a\u2264\ud835\udc58 \ud835\udeff\ud835\udc5a \u2264 \ud835\udeff ) ,\nmeaning that a mechanism equipped with F will continue until for some \ud835\udc58 , \u221a\ufe02 2 log ( 1 \ud835\udeff \u2032 ) \u2211 \ud835\udc5a\u2264\ud835\udc58+1 \ud835\udf16 2 \ud835\udc5a + 12 \u2211 \ud835\udc5a\u2264\ud835\udc58+1 \ud835\udf16\n2 \ud835\udc5a > \ud835\udf16 or\u2211\n\ud835\udc5a\u2264\ud835\udc58+1 \ud835\udeff\ud835\udc5a > \ud835\udeff \u2032\u2032. This is equivalent to [24]\u2019s notion of \ud835\udc41 (\u00b7). Both the condition on \ud835\udf16 and the condition on \ud835\udeff \u2032\u2032 are increasing in the number of mechanisms being composed. The difference is that in Whitehouse et al.\u2019s [24] setting, the number of mechanisms being composed \ud835\udc41 (\u00b7) is the smallest number for adding another mecha-\nnism will cause \u221a\ufe02 2 log ( 1 \ud835\udeff \u2032 ) \u2211 \ud835\udc5a\u2264\ud835\udc41 ( \u00b7)+1 \ud835\udf16 2 \ud835\udc5a + 12 \u2211 \ud835\udc5a\u2264\ud835\udc41 ( \u00b7)+1 \ud835\udf16 2 \ud835\udc5a to exceed \ud835\udf16 , or in other words, \ud835\udc41 (\u00b7) is the largest number for which\u221a\ufe02 2 log ( 1 \ud835\udeff \u2032 ) \u2211 \ud835\udc5a\u2264\ud835\udc41 ( \u00b7) \ud835\udf16 2 \ud835\udc5a+ 12 \u2211 \ud835\udc5a\u2264\ud835\udc41 ( \u00b7) \ud835\udf16 2 \ud835\udc5a \u2264 \ud835\udf16 . Since we define our\nfilter in terms of a bound on the privacy parameter instead of a bound on the number of mechanisms, this is equivalent to checking that for \ud835\udc58 mechanisms being composed, \u221a\ufe02 2 log ( 1 \ud835\udeff \u2032 ) \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf16 2 \ud835\udc5a +\n1 2 \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf16 2 \ud835\udc5a \u2264 \ud835\udf16 . The same holds for the \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udeff\ud835\udc5a \u2264 \ud835\udeff \u2032\u2032 term. Since\n\ud835\udeff \u2032 is already set, we fold the \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udeff\ud835\udc5a \u2264 \ud835\udeff \u2032\u2032 requirement into the\n\ud835\udeff \u2032+\ud835\udeff \u2032\u2032 \u2264 \ud835\udeff requirement to get the condition \ud835\udeff \u2032+\u2211\ud835\udc5a\u2264\ud835\udc58 \ud835\udeff\ud835\udc5a \u2264 \ud835\udeff . Taking the lower bound of the\ud835\udc58 that satisfies either \u221a\ufe02 2 log ( 1 \ud835\udeff \u2032 ) \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf16 2 \ud835\udc5a+\n1 2 \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf16 2 \ud835\udc5a \u2264 \ud835\udf16 or \ud835\udeff \u2032 + \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udeff\ud835\udc5a \u2264 \ud835\udeff is equivalent to finding the \ud835\udc58 that satisfies both conditions. With fully adaptive composition of noninteractive mechanisms, the mechanism will only halt if starting a new mechanism would exceed its privacy-loss budget. Since \ud835\udc41 (\u00b7) mechanisms composed are (\ud835\udf16, \ud835\udeff)-DP in [24]\u2019s setting, we know that a mechanism equipped with F that has not yet halted will be (\ud835\udf16, \ud835\udeff)-DP as well.\nThen by Definition 2.6, F -\ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc61 (\ud835\udc41\ud835\udc3c\ud835\udc40) is an (\ud835\udf16, \ud835\udeff)-DP interactive mechanism, meaning that F is a valid (\ud835\udf16, \ud835\udeff)-DP for the sequence of (\ud835\udf16\ud835\udc56 , \ud835\udeff\ud835\udc56 )-DP noninteractive mechanisms as defined above. \u25a1\nTo define a concurrent privacy odometer, we make use of Lemma 1.25.\nTheorem B.4 ((\ud835\udf16, \ud835\udeff)-DP privacy odometer). Let \ud835\udeff = \ud835\udeff \u2032 + \ud835\udeff \u2032\u2032 be a target approximation parameter such that \ud835\udeff \u2032 > 0, \ud835\udeff \u2032\u2032 \u2265 0. Then G((\ud835\udf161, \ud835\udeff1), . . . , (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 ))\n=  (\u221a\ufe02 2 log ( 1 \ud835\udeff \u2032 ) \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf16 2 \ud835\udc5a + 12 \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf16 2 \ud835\udc5a, \ud835\udeff ) \ud835\udeff \u2032 +\u2211\ud835\udc5a\u2264\ud835\udc58 \ud835\udeff\ud835\udc5a \u2264 \ud835\udeff\n(\u221e,\u221e) otherwise is a valid (\ud835\udf16, \ud835\udeff)-DP privacy-loss accumulator for noninteractive\nmechanisms, where \ud835\udf16 = \u221a\ufe02 2 log ( 1 \ud835\udeff \u2032 ) \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf16 2 \ud835\udc5a + 12 \u2211 \ud835\udc5a\u2264\ud835\udc58 \ud835\udf16 2 \ud835\udc5a .\nProof. Note that\nF ((\ud835\udf161, \ud835\udeff1), . . . , (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 ); (\ud835\udf16, \ud835\udeff)) = I(G((\ud835\udf161, \ud835\udeff1), . . . , (\ud835\udf16\ud835\udc58 , \ud835\udeff\ud835\udc58 ) \u2264 (\ud835\udf16, \ud835\udeff)) .\nBy Lemma 1.25, G is a valid (\ud835\udf16, \ud835\udeff)-DP privacy-loss accumulator. \u25a1"
        }
    ],
    "title": "Concurrent Composition for Interactive Differential Privacy with Adaptive Privacy-Loss Parameters",
    "year": 2023
}