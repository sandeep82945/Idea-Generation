{
    "abstractText": "Graphical methods for categorical variables are not well developed when compared with visualizations for numeric data. One method available for multidimensional categorical data visualizations is mosaic plots. Mosaic plots are an easy and powerful option for identifying relationships between multiple categorical variables. Although various packages have implemented mosaic plots, no implementation within the grammar of graphics supports mosaic plots. We present a new implementation of mosaic plots in R, ggmosaic, that implements a custom ggplot2 geom designed for generalized mosaic plots. Equipped with the functionality and flexibility of ggplot2, ggmosaic introduces new features not previously available for mosaic plots, including a novel method of incorporating a rendering of the underlying density via jittering. This paper provides an overview of the implementation and examples that highlight the versatility and ease of use of ggmosaic while demonstrating the practicality of mosaic plots.",
    "authors": [
        {
            "affiliations": [],
            "name": "Haley Jeppson"
        },
        {
            "affiliations": [],
            "name": "Heike Hofmann"
        }
    ],
    "id": "SP:e7f0b435e1dd05195a0dfa63bb188a727e63eda9",
    "references": [
        {
            "authors": [
                "McPherson",
                "Alan Dipert",
                "Barbara Borges"
            ],
            "title": "Shiny: Web Application Framework for r",
            "year": 2021
        },
        {
            "authors": [
                "R. McGill"
            ],
            "title": "Graphical Perception: Theory, Experimentation and Applica",
            "year": 1984
        },
        {
            "authors": [
                "John A",
                "Beat Kleiner"
            ],
            "title": "Mosaics for Contingency Tables.",
            "year": 1981
        },
        {
            "authors": [
                "Heike"
            ],
            "title": "Constructing and Reading Mosaicplots.",
            "venue": "Computational Statistics and Data",
            "year": 2003
        },
        {
            "authors": [
                "B. Kleiner",
                "J.A. Hartigan"
            ],
            "title": "Representing Points in Many Dimensions by Trees and Castles.",
            "year": 1981
        },
        {
            "authors": [
                "10477638. Kuhn",
                "Max",
                "Davis Vaughan",
                "Emil Hvitfeldt"
            ],
            "title": "Yardstick: Tidy Characterizations of Model",
            "year": 2022
        },
        {
            "authors": [
                "David",
                "Achim Zeileis",
                "Kurt Hornik"
            ],
            "title": "Vcd: Visualizing Categorical Data",
            "year": 2020
        },
        {
            "authors": [
                "Wayne",
                "Erle Holgersen",
                "Ben Lafreniere",
                "Tianlu Zhu"
            ],
            "title": "Eikosograms: The Picture",
            "year": 2018
        },
        {
            "authors": [
                "William",
                "Howard Wainer",
                "Ian Spence"
            ],
            "title": "Playfair\u2019s Commercial and Political Atlas",
            "year": 2005
        },
        {
            "authors": [
                "Statistical Breviary. Cambridge University Press. Sarkar",
                "Deepayan."
            ],
            "title": "Lattice: Trellis Graphics for r",
            "venue": "https://CRAN.R-project.org/package=lattice. Sarkar, Deepayan, and Felix Andrews. 2016. latticeExtra: Extra Graphical Utilities Based on Lattice.",
            "year": 2020
        },
        {
            "authors": [
                "Carson"
            ],
            "title": "Interactive Web-Based Data Visualization with R, Plotly, and Shiny",
            "year": 2020
        },
        {
            "authors": [
                "Pedro Despouy"
            ],
            "title": "Plotly: Create Interactive Web Graphics via \u2019Plotly.js",
            "year": 2016
        },
        {
            "authors": [
                "Kamil"
            ],
            "title": "Ggrepel: Automatically Position Non-Overlapping Text Labels with \u2019Ggplot2",
            "year": 2021
        },
        {
            "authors": [
                "Martin",
                "Simon Urbanek"
            ],
            "title": "Interactive Graphics for Data Analysis: Principles and Examples",
            "year": 2009
        },
        {
            "authors": [
                "Wilke",
                "Kara Woo",
                "Hiroaki Yutani",
                "Dewey Dunnington"
            ],
            "title": "Ggplot2: Create Elegant Data",
            "year": 2020
        },
        {
            "authors": [
                "Wickham",
                "Hadley",
                "Heike Hofmann"
            ],
            "title": "Visualisations Using the Grammar of Graphics",
            "venue": "IEEE Transactions on Visualization and The R Journal Vol",
            "year": 2011
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "Graphical methods for categorical variables are not as thoroughly developed when compared with what is available for numeric variables. Categorical variables in scientific publications often appear in the form of bar charts (first published in the Commercial and Political Atlas by William Playfair in 1789, re-edited by Playfair, Wainer, and Spence (2005)) and spine plots (Hummel 1996).\nBeyond those visualizations, categorical variables with a low number of levels are often incorporated in visualizations in the form of aesthetics such as color and shape. However, these indirect methods of visualizing categorical information are better suited as supplemental information and not as the primary source of information due to the associated loss of accuracy in retrieving the corresponding information (Cleveland and McGill 1984).\nMosaic plots provide a direct method of visualizing multidimensional categorical data; they are similar to a stacked bar chart but include the marginal distribution in addition to the conditional distribution, can be extended beyond two variables, and provide additional flexibility. Modern mosaic plots are usually attributed to Hartigan and Kleiner (Hartigan and Kleiner 1981, 1984; Kleiner and Hartigan 1981), but historical versions of mosaic plots can be found as far back as the late 1800s. The first mosaic plot is often attributed to Georg von Mayr (Friendly 2002); however, the mosaic plots in the Statistical Atlas of the 1870 Decennial Census (United States Census office. 9th census, 1870 and Walker 1874) pre-dates Mayr\u2019s by a few years. Mosaic plots may also be identified as Marimekko charts (mainly in the InfoVis world) or Eikosograms (Oldford et al. 2018).\nIn R, mosaic plots have been implemented in a variety of packages. Base R is equipped with the function mosaicplot() from the graphics package based on code by Emerson (1998) adapted by Kurt Hornik. The base R generic function plot() contains a method for table objects and produces a mosaic plot from a contingency table using the mosaicplot() function. Similarly, the yardstick package (Kuhn, Vaughan, and Hvitfeldt 2022) provides a method for the ggplot2 (Wickham et al. 2020) function autoplot() to visualize confusion matrices, with one of the options being a mosaic plot.\nThe vcd package (Meyer, Zeileis, and Hornik 2020), influenced by Michael Friendly\u2019s \u201cVisualizing Categorical Data,\u201d provides the functions mosaic() and strucplot() which allow for expanded versions of the original mosaic plot (Hartigan and Kleiner 1981). The eikosogram package (Oldford et al. 2018) is another R package capable of producing mosaic plots. The function tileplot() in the latticeExtra package (Sarkar and Andrews 2016) provides functionality to create mosaic plots in the lattice framework (Sarkar 2020).\nThe productplots package (Wickham and Hofmann 2016) provides a wrapper of ggplot2 functionality but does not provide universal access to all aspects of the ggplot2 framework like a geom does. The left plot in Figure 1 is an example of a mosaic plot created with the productplots package. While the default plot can be annotated with additional aesthetics, labels, themes, and color schemes, we can not add layers to this plot, and faceting is unavailable. A preview of the relevant code follows the next paragraph.\nWe present a new implementation of mosaic plots in R, ggmosaic, that implements a ggplot2 geom for mosaic plots. While several other packages are available for constructing mosaic plots, ggmosaic allows users to fully leverage the widely used ggplot2 framework resulting in a flexible package for generalized mosaic plots. More noteworthy, ggmosaic introduces several new features not previously\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\navailable for mosaic plots, including a novel method of incorporating a rendering of the underlying density via jittering. ggmosaic includes a Shiny app to preview plots interactively and allow for model exploration. Many of the features we describe are possible because ggmosaic is implemented within the architecture defined by ggplot2. A preview of the syntax used in ggmosaic is shown below compared to that of the productplots package. The resulting plot is the right plot of Figure 1.\n# productplots productplots::prodplot(flights, ~do_you_recline + rude_to_recline, mosaic()) + aes(fill = do_you_recline)\n## ggmosaic ggplot(data = flights) +\ngeom_mosaic(aes(x = product(do_you_recline, rude_to_recline), fill = do_you_recline))\nIn this paper, we motivate the ggmosaic implementation and introduce it with examples demonstrating the versatility and ease of use of ggmosaic. Next, we describe new features available in the latest release of ggmosaic, version 0.3.3, and discuss how these features can enhance the data visualizations made with ggmosaic. Finally, we conclude with a preview of a shiny application (Chang et al. 2021) designed for an exploratory model framework of logistic regression and loglinear models. The Shiny application is included in the development version of ggmosaic available from https://github.com/hjeppson/ggmosaic."
        },
        {
            "heading": "2 ggmosaic: A ggplot2 implementation of mosaic plots",
            "text": "ggplot2 implements an adaptation of the grammar of graphics (Wilkinson 1999), a layered grammar (Wickham 2010). Because of its flexibility and ease of use, ggplot2 has become one of the most popular plotting packages available in the R ecosystem. Version 2.0.0 of ggplot2 introduced a method for other R packages to implement custom geometries, or \u201cgeoms\u201d, allowing for an expansion of the utility of ggplot2. In turn, the increasingly popular package has continued to appeal to a more extensive user base.\nIn creating a ggplot2 geom for mosaic plots, we seek to appeal to this user base and leverage the robust framework of the grammar of graphics. Having mosaic plots in the ggplot2 framework makes creating mosaic plots more accessible as it is more straightforward for the novice user to create mosaic plots for data exploration purposes. For many users, having mosaic plots function as a true ggplot2 geom reduces the amount of syntax required, eliminates the need for prior calculations, and provides complete access to additional benefits of ggplot2, allowing for highly customized generalized mosaic plots.\nWith the R package ggmosaic, a custom ggplot2 geom designed for generalized mosaic plots is implemented. ggmosaic makes mosaic plots compatible with ggplot2 and creates a flexible method\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nto generate a wide variety of categorical data visualizations. The remainder of the paper presents a thorough description of the ggmosaic package featuring examples that go beyond how to use ggmosaic and demonstrate how to make more informed decisions about how to use mosaic plots to answer various questions.\nWe begin with an introduction to the package with examples of the flexible framework that ggmosaic offers. The following three sections illustrate how to use ggmosaic. First, we address the data structures required for constructing mosaic plots and which structures are compatible with ggmosaic. Next, we demonstrate how ggmosaic fits mosaic plots into the ggplot2 framework and how to define the aesthetic mappings to construct the desired plot from the variables in the data. Lastly, we provide examples of mosaic plots customized with parameters unique to ggmosaic.\nThe remaining half of the paper presents the new features included in version 0.3.3 of ggmosaic. Frist, we introduce geom_mosaic_text(), designed to place text, or labels, in the center of each tile, followed by geom_mosaic_jitter(), a geom for jittered points designed to be superimposed on the mosaic plot and with multiple proposed applications. Next, we present theme_mosaic(), a theme for mosaic plots to remove items from the background of the plot. We conclude with an overview of an interactive Shiny app for exploratory data analysis (EDA) of high-dimensional categorical data using mosaic plots.\nMany of the features we describe are possible because ggmosaic is implemented within the ggplot2 framework. While other packages are available for constructing mosaic plots, ggmosaic allows users to leverage the widely used ggplot2 infrastructure to create highly customized generalized mosaic plots. Most notably, ggmosaic introduces several new features not previously available for mosaic plots. In total, ggmosaic offers users a way to make mosaic plots with ggplot2 to visualize and explore categorical data more effectively."
        },
        {
            "heading": "3 The ggmosaic package",
            "text": "The R package ggmosaic implements a custom ggplot2 geom, geom_mosaic(), designed to offer a flexible framework for visualizing categorical data. The geom for mosaic plots was created using the productplots package and ggplot2\u2019s custom object-oriented system and extension mechanism, ggproto. A stable version of ggmosaic is available on CRAN, and a development version is available at https://github.com/hjeppson/ggmosaic. This section provides a brief description of the package, the methods used in its implementation, and an example that showcases the flexibility that ggmosaic offers.\nDesigned to create visualizations of categorical data, geom_mosaic() has the capability to produce bar charts, stacked bar charts, mosaic plots, and double-decker plots and therefore offers a wide range of potential plots. Figures 2, 3, and 4 highlight the package\u2019s versatility. The code for these examples is provided below and can be summarized as consisting of the following components. First, the mosaic plot is created by adding a mosaic geom. The x aesthetic takes one or more variables wrapped in the product() function, and the fill aesthetic determines the fill color of the rectangles. An optional divider parameter determines the partitioning strategy for the rectangles. The code will be explained in greater detail in the subsequent sections.\n# one-dimensional examples: # spine plot ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline),\nfill = do_you_recline))\n# bar chart ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline),\nfill = do_you_recline), divider = \"hbar\")\n# two-dimensional examples: # mosaic plot (2 variables) ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, rude_to_recline),\nfill = do_you_recline))\n# stacked bar chart\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nSpine Plot\nBar Chart\nggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, rude_to_recline),\nfill = do_you_recline), divider = c(\"vspine\", \"hbar\"))\nMosaic Plot (2 variables)\nStacked Bar Chart\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\n# three-dimensional examples: # mosaic plot (3 variables) ggplot(data = flights) + geom_mosaic(aes(x = product(eliminate_reclining, do_you_recline,\nrude_to_recline), fill = do_you_recline, alpha = eliminate_reclining))\n# double-decker plot ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, eliminate_reclining,\nrude_to_recline), fill = do_you_recline, alpha = eliminate_reclining),\ndivider = ddecker())\nMosaic Plot (3 variables)\nDouble\u2212Decker Plot\nFurthermore, ggmosaic allows various features to be customized:\n\u2022 the type of data structure,\n\u2022 the order of the variables (Figure 6),\n\u2022 the formula setup of the plot (Figure 7),\n\u2022 faceting (Figure 7),\n\u2022 the type of partition (Figure 10 and Figure 11), and\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\n\u2022 the space between the categories (Figure 12).\nThe following sections will discuss these features and provide examples of their use."
        },
        {
            "heading": "Data structure",
            "text": "The first step to creating a mosaic plot with ggmosaic is to ensure the data are in a supported format. There are three data structures to consider (Friendly 2016), and two of the three data structures are compatible with ggmosaic. The structure of the data impacts the use of geom_mosaic(), so the user must understand their data\u2019s structure. This section provides an example of each of the three data structures and highlights the essential differences.\nThe data set used for these examples, and all examples in this paper, is from a SurveyMonkey Audience poll conducted by FiveThirtyEight for two days in August of 2014. The survey asked twenty-six questions ranging from background information regarding the respondent to feelings on potentially aggravating behavior one might encounter on an airplane (Hickey 2014). The survey had 1,040 respondents (874 of whom had flown) aged 18-60+ from across the United States. The data set is available from FiveThirtyEight\u2019s data GitHub repository, and a cleaned version of it is one of the three data sets included in the ggmosaic package.\nHere, we will use three variables do_you_recline, rude_to_recline, and eliminate_reclining from the fly data. For this paper, we made the following adjustments: remove all non-responses and collapse the variable do_you_recline from a factor with five levels (always, usually, about half the time, once in a while, and never) to a factor with three levels (usually, sometimes, never). Incidentally, by removing all non-responses, we also remove responses from those that have never flown. The code below completes the necessary modifications to the data.\n# A few modifications to data flights <- fly %>% select(do_you_recline, rude_to_recline, eliminate_reclining) %>% filter(!is.na(do_you_recline), !is.na(rude_to_recline)) %>% mutate(do_you_recline = do_you_recline %>%\nforcats::fct_collapse( usually = c(\"always\", \"usually\"), sometimes = c(\"about half the time\", \"once in a while\"), never = \"never\") %>%\nforcats::fct_relevel(\"never\", \"sometimes\", \"usually\") )\n# Summary of the modified data flights %>% summary()\n#> do_you_recline rude_to_recline eliminate_reclining #> never :170 no :502 no :595 #> sometimes:373 somewhat:281 yes:259 #> usually :311 yes : 71\nTo simplify the examples of the three data structures, we will focus on the two variables do_you_recline and rude_to_recline from the flights data. The following code creates the desired subset:\nflights_examp <- flights %>% select(do_you_recline, rude_to_recline) names(flights_examp)\n#> [1] \"do_you_recline\" \"rude_to_recline\"\nThe example data, flights_examp, contains the individual observations from the survey. Each row accounts for one survey response to each of the questions, and there are two columns, one for do_you_recline and one for rude_to_recline. This is the first of the three types of data structure.\nglimpse(flights_examp)\n#> Rows: 854 #> Columns: 2 #> $ do_you_recline <fct> sometimes, usually, usually, sometimes, usually, somet~ #> $ rude_to_recline <fct> somewhat, no, no, no, no, somewhat, no, no, yes, no, n~\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nThe second data structure is a summary of the first data structure. This format consists of a data frame where each row is one of the possible combinations of levels of the categorical variables. In this structure, there is an additional column for the variable freq that supplies the number of observations in the first data structure with the row\u2019s particular combination of levels.\nflights_examp %>% count(do_you_recline, rude_to_recline, name = \"freq\") %>% glimpse()\n#> Rows: 9 #> Columns: 3 #> $ do_you_recline <fct> never, never, never, sometimes, sometimes, sometimes, ~ #> $ rude_to_recline <fct> no, somewhat, yes, no, somewhat, yes, no, somewhat, yes #> $ freq <int> 35, 81, 54, 198, 164, 11, 269, 36, 6\nThe second data structure also occurs with weighted data. In which case, rather than a variable representing the counts or frequencies, a variable represents the weights. A typical example of weighted data is census data, where a weighting variable is used to compensate for a representation differential.\nThe final data structure summarizes the second data structure: it is the contingency table format. This data structure is not supported by ggmosaic and needs to be transformed into data structure one or two. Both as.data.frame() and as_tibble() provide a method for tables that converts this format into the summary format of data structure two.\nflights_examp %>% table()\n#> rude_to_recline #> do_you_recline no somewhat yes #> never 35 81 54 #> sometimes 198 164 11 #> usually 269 36 6\nWhile the contingency table data structure is incompatible with ggmosaic, or ggplot2, either the first or second structure is acceptable, and neither is preferable to the other. The data structure will affect the set of mappings constructed from the variables to the aesthetics, the topic of the next section."
        },
        {
            "heading": "Aesthetics",
            "text": "To fit ggmosaic within the ggplot2 infrastructure, we must create the desired plot from the variables in the data. The first step, defining the aesthetic mappings, requires specifications of how variables in the data will be mapped to the visual properties of the plot. In ggmosaic, the aesthetic mappings are transformed into a model formula using the R formula notation with the ~ operator. The formula then determines what is represented in the mosaic plot, or how the joint distribution of the variables is broken down into the marginal distribution and conditional distribution(s). Understanding how the aesthetics translate into the model formula helps a user specify the correct aesthetics for the desired plot. This section describes each of the aesthetics used in geom_mosaic(), some of which are unique to ggmosaic, describes how the aesthetics are translated into the model formula, and provides examples of the impact changes in the aesthetic mappings have on the final plot.\nConflicting with the infrastructure provided by ggplot2, mosaic plots do not have a one-to-one mapping between a variable and the x or y axis. Instead, the grammar of graphics defines the coordinate system of mosaic plots as a system based on recursive partitioning that can integrate several variables (Wilkinson 1999). To accommodate the variable number of variables, the mapping to x is created by the product() function. For example, the variables var1 and var2 are read in as x = product(var1, var2). However, if only one variable is to be included, it does not need to be wrapped in product(), and can be read in simply as x = var1. The product() function alludes to ggmosaic\u2019s predecessor productplots and to the joint distribution as the product of the conditional and marginal distributions. The product function creates a special type of list that is evaluated internally and is what allows us to integrate multiple variables into the mosaic plot.\nIn order to include a variable in the mosaic plot, it must be specified as an aesthetic. In geom_mosaic(), the following aesthetics can be specified:\n\u2022 x: select variables to add to the formula\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\n\u2013 declared as x = product(var1, var2, ...)\n\u2022 alpha: add an alpha transparency to the rectangles of the selected variable\n\u2013 unless the variable is already part of the formula, it is added explicitly in the formula in the first position.\n\u2022 fill: select a variable to determine the fill color of the rectangles\n\u2013 unless the variable is already part of the formula, it is added explicitly in the formula in the first position after the optional alpha variable.\n\u2022 conds: select a variable to condition on\n\u2013 declared as conds = product(cond1, cond2, ...)\n\u2022 weight: select a weighting variable\nThe specified aesthetics are then translated into the formula, weight ~ alpha + fill + x | conds, which determines what is to be represented in the mosaic plot and how to calculate the size of the corresponding tiles and determine their placement. Understanding the ordering of the specified aesthetics in the translation helps a user specify the correct aesthetics for the desired plot.\nThe minimal required aesthetics to create a mosaic plot is one variable mapped to the x aesthetic, wrapped in the product() function. Without a defined weight aesthetic, all observations are assumed to have equal weights, a weight of 1. In this minimal scenario, the resulting formula is 1 ~ x.\nThe weight aesthetic\nA mosaic plot is constructed such that the area of each rectangle is proportional to the number of observations that the tile represents. Without weighting, each row of a data set represents one observation. Alternatively, the aesthetic weight is available to modify the interpretation of each row of the data. For example, the weight aesthetic will need to be used with data that contains a variable that supplies the number of observations for each row\u2019s particular combination of levels. In this case, if the weight aesthetic is left unused, the resulting mosaic plot will resemble the case of equal probabilities, as can be seen in Figure 5.\n# unweighted plot flights_examp %>% count(do_you_recline, rude_to_recline, name = \"freq\") %>% ggplot() + geom_mosaic(aes(x = product(rude_to_recline),\nfill = do_you_recline))\n# weighted plot flights_examp %>% count(do_you_recline, rude_to_recline, name = \"freq\") %>% ggplot() + geom_mosaic(aes(weight = freq,\nx = product(rude_to_recline), fill = do_you_recline))\nThe weight aesthetic is also necessary with weighted data, such as weighted surveys. Otherwise, the resulting mosaic plot may not be a faithful representation of the relationship in the data. Here, weights serve to correct imbalances between the sample and the population."
        },
        {
            "heading": "The ordering of the variables",
            "text": "Because of a mosaic plot\u2019s hierarchical construction, the ordering of the variables in the formula is vital. While any order of the variables ultimately represents the same data, different variable orders may better support different comparisons. Ideally, the comparison of interest is positioned along a common scale, an easier perceptual task than comparing areas (Cleveland and McGill 1984). In the simple case of two variables, with one an explanatory variable and the other considered the response, the explanatory variable is best placed on the first split of the mosaic and the response variable as the last split, those that occur within each of the tiles created by the first split. The code below and corresponding mosaic plots in Figure 6 illustrate the change that occurs when the variables in the formula are swapped.\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nUnweighted\nWeighted\n# original order ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, rude_to_recline),\nfill = do_you_recline))\n# order reversed ggplot(data = flights) + geom_mosaic(aes(x = product(rude_to_recline, do_you_recline),\nfill = do_you_recline))\nThe mosaic plots in Figure 6 represent the same joint distribution but are composed differently. The original order, the plot on the left, shows that most of those who believe it is rude to recline never recline their own seat. With the reversed order, we can see that of those who never recline their seats, a roughly equal proportion consider reclining rude as those that do not. The difference highlights how mosaic plots are more than a visualization of the joint distribution; mosaic plots are a visualization of the product of the conditional distribution and marginal distribution, which results in the joint distribution.\nIn the original order, x = product(do_you_recline, rude_to_recline), the joint distribution is the product of the conditional distribution of do_you_recline given rude_to_recline and the marginal distribution of rude_to_recline. With this order, we can address questions regarding the marginal distribution of rude_to_recline, such as \u201cwhat proportion of respondents believe it is rude to recline?\u201d, and questions regarding the conditional distribution of do_you_recline given each response to rude_to_recline, such as \u201cIs there an association between a passenger\u2019s reclining tendencies and their opinion reclining.\nIn contrast, x = product(rude_to_recline, do_you_recline), while resulting in the same joint distribution, is the product of the conditional distribution of rude_to_recline given do_you_recline and the marginal distribution of do_you_recline. Here, we can compare the responses to rude_to_recline within each response to do_you_recline, which reveals an interesting relationship between a passenger\u2019s perceived rudeness given their own inclination to recline. We can see that those that usually recline their seats are more likely to not find reclining to be a rude behavior. Those that never recline their seats, however, are evenly divided with their opinions on reclining. While it is easier to estimate the proportion that never reclines in the reversed order, it is more challenging to decipher what proportion of the respondents believe it is rude to recline, an artifact of the plot representing rude_to_recline only through its conditional distribution given the responses to do_you_recline.\nUltimately, the preferred order of the variables depends on the comparisons of interest. To (re)arrange the categories within a variable, the levels of the factor variable must be reordered before using ggmosaic.\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nOriginal Order\nOrder Reversed\nThe conds aesthetic\nThe formula setup of the plot can be further altered by electing to view a conditional distribution rather than the full joint distribution. Conditioning can be used to better focus on the comparison of interest either by removing relationships that are not of interest or positioning the comparison of interest along a common scale (Wickham and Hofmann 2011; Cleveland and McGill 1984). When a variable is mapped to the conds aesthetic, the mosaic plot is no longer represents the joint distribution, but instead maps the conditional distribution.\nFaceting splits the data into subsets and generates a plot for each subset. Faceting therefore provides another method to accomplish conditioning. The result is the same as with the conds aesthetic, but the formatting is altered. The formatting difference will be discussed in more detail later. Figure 7 contains an example of each method of conditioning and is based on the code below.\n# not conditioned ggplot(data = flights) + geom_mosaic(aes(x = product(rude_to_recline),\nfill = do_you_recline))\n# conditioned with aesthetic mapping ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline),\nfill = do_you_recline, conds = product(rude_to_recline)))\n# conditioned with facets ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline),\nfill = do_you_recline)) + facet_grid(cols = vars(rude_to_recline))\nFor two variables, as in Figure 7, the difference between conditioning and not conditioning amounts to the difference between a mosaic plot and a stacked bar chart with a standardized height of 1. That is, when conditioning on rude_to_recline, the plot no longer represents the marginal distribution of rude_to_recline. Instead, as in a stacked bar chart, the plot only represents the conditional distribution of do_you_recline given the responses to rude_to_recline.\nIn the case of three variables, relationships can be removed via conditioning to focus on one relationship in particular and position that relationship along a common scale (Wickham and Hofmann 2011). Figure 8 provides an example of conditioning used to focus on the conditional distribution of eliminate_reclining by removing the joint distribution of do_you_recline and rude_to_recline. The example is based on the code below.\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nNot Conditioned\nConditioned via Aesthetic Mapping\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\n# not conditioned ggplot(flights) + geom_mosaic(aes(x = product(eliminate_reclining, do_you_recline,\nrude_to_recline), fill = do_you_recline, alpha = eliminate_reclining))\n# conditioned ggplot(data = flights) + geom_mosaic(aes(x = product(eliminate_reclining),\nconds = product(do_you_recline, rude_to_recline), fill = do_you_recline, alpha = eliminate_reclining))\nThe conditioning completed in Figure 8 provides a better view of how responses to eliminate_reclining relate to do_you_recline and rude_to_recline responses. We can see that desires to eliminate reclining are less likely when the respondent reclines their seat. eliminate_reclining may have a stronger association with responses to rude_to_recline, but that comparison is more difficult to make since it is comparing areas rather than positions along a common scale.\nWhen conditioning on multiple variables, it is again important to consider how the variables\u2019 order impacts the plot. The two mosaic plots in Figure 9 display the same data, but the direction of the final split is different. The orientation of the final split determines which comparisons are positioned along a common scale.\n# conditioned order 1 ggplot(data = flights) + geom_mosaic(aes(x = product(eliminate_reclining),\nconds = product(do_you_recline, rude_to_recline), fill = do_you_recline, alpha = eliminate_reclining))\n# conditioned order 2 ggplot(data = flights) + geom_mosaic(aes(x = product(eliminate_reclining),\nconds = product(rude_to_recline, do_you_recline), fill = do_you_recline,\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nalpha = eliminate_reclining)) + coord_flip()\nFigure 9 rearranges the conditioned variables\u2019 order to gauge the strength of the relationship between eliminate_reclining and rude_to_recline. For a fixed level of do_you_recline, the desire to eliminate reclining correlates with an increasingly hostile stance on reclining. While this example flips the orders of the conditioned variables and then uses coord_flip(), ggmosaic provides additional methods of manually modifying the directions of the splits in the mosaic plot, which will be discussed in the next section.\nThe defined set of aesthetic mappings impacts more than the look of the final graphic; it impacts the analysis and the inquiries the plot can support. ggmosaic requires the x and cond aesthetics to be defined using the product() function to accommodate a variable number of variables. The defined set of aesthetic mappings will result in a model formula that will determine which of the potentially numerous ways the mosaic plot will represent the decomposition of the joint distribution."
        },
        {
            "heading": "Parameters",
            "text": "Easy customization is necessary for mosaic plots to be effective. Additional aspects of the mosaic plot that can be modified include the strategy used to partition the area into the tiles and the width of the spacing between the tiles. ggmosaic provides the parameters divider and offset to facilitate adjustments to the partitioning strategy and the spacing. This section demonstrates how to create generalized mosaic plots modified by these parameters and how they can be used to highlight different aspects of the data.\nIn ggmosaic, the desired type of partition is specified with the divider parameter (by setting divider = \" \"). The area of a mosaic plot can be partitioned into bars or spines, and partitions can be added horizontally or vertically, as shown in Figure 10 and the code below. When the area is partitioned into bars, the height is proportional to value, and the width equally divides the space. Bars can be arranged horizontally (\"hbar\") or vertically (\"vbar\"). Alternatively, space can be partitioned into spines, where the section\u2019s width is proportional to the value, and the height occupies full range. Spines are space-filling and can be arranged horizontally (\"hspine\") or vertically (\"vspine\"). The default divider for a single variable is \"hspine\".\n# default / hspine ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline),\nfill = do_you_recline))\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\n# vspine ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline),\nfill = do_you_recline), divider = \"vspine\")\n# hbar ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline),\nfill = do_you_recline), divider = \"hbar\")\n# vbar ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline),\nfill = do_you_recline), divider = \"vbar\")\nIn the case of multiple variables, a type of partition must be defined for each variable. The default divider (divider = mosaic()) and the double-decker divider (divider = ddecker()) automatically select a pre-defined pattern for the partitions. For example, if three variables are plotted, the default, divider = mosaic(), partitions the plot with spines in alternating directions, beginning with a horizontal spine, i.e. divider = c(\"hspine\", \"vspine\", \"hspine\"). Alternatively, we can declare the type of partition for each variable, e.g. divider = c(\"hbar\", \"vspine\", \"vspine\"). The first partition declared in the vector will be used last in the plot. As mentioned above, an unspecified divider leads to the default divider = mosaic(), and the partition begins with a horizontal spine and alternate directions for each subsequent variable. To begin with a vertical spine and alternate directions from there, use divider = mosaic(direction = \"v\"). A preview of these options is available in Figure 11, and the associated code is below.\n# default / mosaic(\"h\") ggplot(data = flights) + geom_mosaic(aes(x = product(eliminate_reclining, do_you_recline,\nrude_to_recline), fill = do_you_recline, alpha = eliminate_reclining))\n# mosaic(\"v\") ggplot(data = flights) + geom_mosaic(aes(x = product(eliminate_reclining, do_you_recline,\nrude_to_recline), fill = do_you_recline, alpha = eliminate_reclining),\ndivider = mosaic(direction = \"v\"))\n# ddecker\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, eliminate_reclining,\nrude_to_recline), fill = do_you_recline, alpha = eliminate_reclining),\ndivider = ddecker())\n# c(\"hbar\", \"hbar\", \"vspine\") ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, rude_to_recline,\neliminate_reclining), fill = do_you_recline, alpha = eliminate_reclining),\ndivider = c(\"hbar\", \"hbar\", \"vspine\"))\nThe divider parameter provides an additional mechanism for modifying the plot\u2019s arrangement to focus on a particular relationship by enabling a user to modify any dimension of the divider to position the comparison of interest along a common scale. For instance, the double-decker plot in Figure 11 helps compare the effects changes in eliminate_reclining and rude_to_recline have on the responses to do_you_recline and how the relationship between do_you_recline and eliminate_reclining differs for different levels of rude_to_recline.\nggmosaic adopts the procedure followed by Hartigan and Kleiner (1981), Friendly (2002), Theus and Urbanek (2009), and Hofmann (2003), where an amount of space is allocated for each of the splits, with subsequent divisions receiving a smaller amount of space. The splits between the categories of the first variable are the widest and the splits decrease in width with each additional variable. Decreasing the widths of the splits with each additional variable allows the categories to group together according to the recursive strategy (Theus and Urbanek 2009) and the created spaces preserve the impact of small counts (Friendly 2002). The effect becomes apparent when an empty group is included. In this case, the spaces between the empty categories create a gap equal to the amount of space that is between non-empty categories.\nFor variables with many categories, it may be of interest to decrease the size of the spacing between the spines. The parameter offset can widen or shrink the size of the spacing between the categories of the first variable and the subsequent splits then gradually decrease in width with each additional variable. The default setting of this parameter is offset = 0.01, equivalent to 1% of the width of the plotting area. The code below and the corresponding mosaic plots in Figure 12 demonstrate how to use the offset parameter.\n# increased spacing ggplot(data = flights) + geom_mosaic(aes(x = product(rude_to_recline),\nfill = do_you_recline),\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nIncreased spacing\nDecreased spacing\noffset = 0.03)\n# decreased spacing ggplot(data = flights) + geom_mosaic(aes(x = product(rude_to_recline),\nfill = do_you_recline), offset = 0)\n# default spacing ggplot(data = flights) + geom_mosaic(aes(x = product(rude_to_recline),\nfill = do_you_recline))\nWhile the examples so far include up to three variables, there is no technical limit to the number of variables in a mosaic plot. However, when many categorical variables are present, mosaic plots can quickly become cluttered and difficult to interpret, and a judgment call must be made on the practical limit to the number of variables included in the mosaic plot. This practical limit could depend on many factors, including the number of categories within each variable, the viewing size of the result mosaic plot, and the viewer\u2019s familiarity with the data.\nThe customization offered via the ggmosaic parameters allows users to easily make complex generalized mosaic plots that are more readable and simpler to interpret. The parameters provide additional dimensions of freedom with the ability to switch between bars and spines and allow users to highlight different aspects of high-dimensional categorical data to identify and communicate interesting patterns.\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859"
        },
        {
            "heading": "Interactivity",
            "text": "Having a geom designed for generalized mosaic plots allows for a ggplotly() hook to create interactive mosaic plots with the plotly package, version 4.9.3 (Sievert et al. 2016). The ggplotly() function translates most of the basic geoms bundled with the ggplot2 package. To expand the functionality to custom geoms, we make use of the infrastructure provided in the plotly package that allows for a translation. In ggplot2, many geoms are special cases of other geoms. For example, geom_line() is equivalent to geom_path() once the data is sorted by the x variable. Because GeomMosaic can be reduced to the lower-level geom GeomRect, we were able to write a method for the to_basic() generic function in plotly (Sievert 2020). Figure 13 features an example of an interactive mosaic plot created with ggplotly() and the corresponding code is below.\np1 <- ggplot(data = flights) + geom_mosaic(aes(x = product(rude_to_recline),\nfill = do_you_recline))\nplotly::ggplotly(p1)"
        },
        {
            "heading": "4 New features in ggmosaic version 0.3.3",
            "text": "The layered grammar implemented by ggplot2 provides a means to add additional layers (typically resulting in additional geometric objects) to a graphic. The unique scale system in ggmosaic, however, makes a correct placement of items in additional layers tricky. The x and y scales in a mosaic plot are both numeric and categorical; the numeric scale determines the placement of additional objects on a range between 0 and 1. Thus, to place an object in the center of each tile, it is necessary to know the numeric values for the corners of each of the tiles. Version 0.3.3 of ggmosaic introduced two additional geoms designed to build on stat_mosaic() and geom_mosaic() that bypass these calculations.\nThe two geoms, geom_mosaic_text() and geom_mosaic_jitter(), are provided to further enhance the generalized mosaic plots created with ggmosaic. These features are designed to add labels to the mosaic plot tiles and to view the tiles\u2019 density via jittered points, and are implemented as additional geom items that can layer on top of the original mosaic geom. Lastly, we also provide a new minimal theme, theme_mosaic(), designed for mosaic plots. The theme removes items from the plot background in order to reduce clutter and increase readability. Together, these features add\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nnew functionality to mosaic plots to increase their usability and facilitate more profound insights into high-dimensional categorical data."
        },
        {
            "heading": "A labeling geom",
            "text": "The flexibility of generalized mosaic plots can lead to inadequate space around the perimeter of the plot to label each of the categories for the variables displayed, making labeling a challenge. To ease the burden on the axis labels, geom_mosaic_text() applies labels to the tiles. This section introduces geom_mosaic_text(), its parameters, and its customization options with sample code and graphics.\nOne aspect of mosaic plots is that while the text and tick marks on the axes may be aligned with the correct category levels on one side of the plot, the alignments may not be appropriate for category levels on the opposite side of the plot. Thus, it may be advantageous to label the tiles to ensure the group identities are apparent to a viewer. geom_mosaic_text() provides the means to place text, or labels, in each of the tiles. geom_mosaic_text() has its counterpart, stat_mosaic_text(), perform the necessary mapping calculations to place each tile\u2019s label in the center of the tile. Figure 14 features an example created with geom_mosaic() with geom_mosaic_text() added to place text in each of the tiles corresponding to the tiles\u2019 combination of categories. The associated code is below.\nggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, rude_to_recline),\nfill = do_you_recline)) + geom_mosaic_text(aes(x = product(do_you_recline, rude_to_recline)))\nAs a default, the label text contains the combinations of category levels the tile represents. Alternative labels may be desired and are achievable through the label aesthetic. For example, to label the tiles of a mosaic with counts, that variable can be mapped to the label aesthetic. The counts, however, need not be contained in the underlying data before plotting; the function after_stat() supports aesthetic mappings of variables calculated by the stat, in this case, the variable .wt calculated in stat_mosaic_label() (see Figure 15 and the code below).\nggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, rude_to_recline),\nfill = do_you_recline)) + geom_mosaic_text(aes(x = product(do_you_recline, rude_to_recline),\nlabel = after_stat(.wt)))\nTo help label the areas of the plots where labels may be densely packed and overlapping, ggmosaic uses the ggplot2 extension package, ggrepel (Slowikowski 2021). The geoms provided by ggrepel help ensure the text is readable by repelling the labels away from each other, data points, and edges of the plot panel. In addition to the standard \"Text\" and \"Label\" geoms, ggmosaic\u2019s use of ggrepel allows\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\n\u2018label = after_stat(.wt)\u2018\nthe use of the \"TextRepel\" and \"LabelRepel\" geoms within mosaic plots. Thus, geom_mosaic_text() provides access to the features of four geoms. To access these four geoms, the parameters as.label and repel are introduced; their use is demonstrated in Figure 16, and the code is below. Furthermore, the parameter repel_params is available to use with either of the ggrepel options, and the parameter check_overlap is available to use with the \"Text\" geom.\n# default / text ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, rude_to_recline),\nfill = do_you_recline)) + geom_mosaic_text(aes(x = product(do_you_recline, rude_to_recline)))\n# label ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, rude_to_recline),\nfill = do_you_recline)) + geom_mosaic_text(aes(x = product(do_you_recline, rude_to_recline)),\nas.label = TRUE)\n# repel text ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, rude_to_recline),\nfill = do_you_recline)) + geom_mosaic_text(aes(x = product(do_you_recline, rude_to_recline)),\nrepel = TRUE)\n# repel label ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline, rude_to_recline),\nfill = do_you_recline)) + geom_mosaic_text(aes(x = product(do_you_recline, rude_to_recline)),\nrepel = TRUE, as.label = TRUE)\nMosaic plots with many categories can quickly become unreadable, geom_mosaic_text() helps alleviate congestion-related confusion by providing quick and effective labeling in various formats. The parameters repel and as.label provide access to three additional geoms. The geom geom_mosaic_text() can add the text geom, the label geom, the ggrepel text geom, or the ggrepel label geom. The parameters repel_params and check_overlap provide access to the parameters native to the ggrepel geoms and label geoms, respectively. Labels add value to the mosaic plot as they ensure easy and correct identification of the tiles, which, in turn, eases the visual analysis.\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859"
        },
        {
            "heading": "A jittering geom",
            "text": "In constructing of a mosaic plot, the tile area is proportional to the number of observations that the tile represents. In other words, the density of each tile in a mosaic plot is constant throughout the plot. While the number of observations, or density, is typically masked in a mosaic plot, a user can visualize these individual data points with geom_mosaic_jitter(). This added layer of visualization unlocks a range of applications, from adding additional aesthetic mappings, both included in the formula and not, to model diagnosis. Research suggests visualizations that incorporate individuals in charts allow viewers to digest and understand probabilities and risks involved more easily (Galesic, Garcia-Retamero, and Gigerenzer 2009; Ancker et al. 2006). These features further extend the ability of generalized mosaic plots to communicate interesting features of high-dimensional categorical data.\nWhen used in conjunction with geom_mosaic(), geom_mosaic_jitter() adds a layer of jittered points superimposed on the mosaic plot. The number of points in each rectangle is equal to the number of observations that the rectangle represents. The result is an even dispersal of points throughout the one-by-one square mosaic plot.\nWhen conditioning on a variable, geom_mosaic_jitter() provides a visual representation of the differences between the conditional probability and the joint probability; the spread of the points throughout the mosaic plot can help decipher a conditioning variable\u2019s effect on a mosaic plot\u2019s construction. In Figure 17, conditioning on the variable rude_to_recline causes a change in the density of the jittered points. The visual difference serves as an effective tool for teaching the concept. The plots are based on the following lines of code:\n# not conditioned ggplot(data = flights) + geom_mosaic(aes(x = product(rude_to_recline),\nfill = do_you_recline), alpha = 0.3) +\ngeom_mosaic_jitter(aes(x = product(rude_to_recline), color = do_you_recline))\n# conditioned ggplot(data = flights) + geom_mosaic(aes(x = product(do_you_recline),\nconds = product(rude_to_recline), fill = do_you_recline),\nalpha = 0.3) + geom_mosaic_jitter(aes(x = product(do_you_recline),\nconds = product(rude_to_recline), color = do_you_recline))\nIncluding the jittered points generates an awareness of the size of the data, something customarily masked in a mosaic plot. For smaller data sets such as the titanic data set, using geom_mosaic_jitter() may encourage engagement as the points connect with the individuals in the data. This connection may provide a more compelling and profound visual impact.\ngeom_mosaic_jitter() is more effective when the alpha argument is used in both geom_mosaic_jitter() and geom_mosaic() to create semi-transparent jittered points and semi-transparent rectangles. An alpha value of 0.3 for geom_mosaic() and an alpha value of 0.7 for geom_mosaic_jitter() is aesthetically pleasing.\ngeom_mosaic_jitter() introduces an additional parameter, drop_level. The drop_level parameter controls which level defines the color of the generated points. In other words, if a color aesthetic is defined, should that variable be included in the formula? If the formula includes the color aesthetic, drop_level = FALSE, the colored points are at the top level. If the formula does not include the color aesthetic, drop_level = TRUE, color is added to the points one level down. Figure 18 provides an example of these two options.\n# drop level ggplot(data = flights) + geom_mosaic(aes(x = product(rude_to_recline)),\nalpha = 0.1) + geom_mosaic_jitter(aes(x = product(rude_to_recline),\ncolor = do_you_recline), drop_level = TRUE)\n# do not drop level\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nNot conditioned\nConditioned\nggplot(data = flights) + geom_mosaic(aes(x = product(rude_to_recline)),\nalpha = 0.1) + geom_mosaic_jitter(aes(x = product(rude_to_recline),\ncolor = do_you_recline), drop_level = FALSE)\nAn additional aesthetic, weight2, is implemented in geom_mosaic_jitter(). The weight2 aesthetic allows the number of points generated within each tile to be different from the number of points the cell represents.\nWhile mosaic plots are typically drawn according to the observed values, they can be drawn according to the model\u2019s expected values.\nflights_model %>% glimpse()\n#> Rows: 9 #> Columns: 4 #> $ do_you_recline <fct> never, never, never, sometimes, sometimes, sometimes, ~ #> $ rude_to_recline <fct> no, somewhat, yes, no, somewhat, yes, no, somewhat, yes #> $ Observed <int> 35, 81, 54, 198, 164, 11, 269, 36, 6 #> $ Expected <dbl> 100, 56, 14, 219, 123, 31, 183, 102, 26\nFigure 19 displays the observed values on the left and the expected values from the independence model on the right. The difference between the two plots represents the lack of fit. The plot is based on the following lines of code:\nflights_model %>% gather(\"wt_type\", \"wt\", Expected:Observed) %>% ggplot() + geom_mosaic(aes(weight = wt,\nx = product(rude_to_recline), fill = do_you_recline)) +\nfacet_wrap(vars(wt_type))\nIn Figure 19, the mosaic plot drawn according to the observed values represents the data space, whereas the mosaic plot drawn according to the expected values represents the model space. Rather than requiring two plots, jittering connects in one plot both the data space with the model space highlighting the differences between the two.\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\n\u2018drop_level = TRUE\u2018\n\u2018drop_level = FLASE\u2018\nIn Figure 20, the jittered points represent the observed values, while the tiles\u2019 size represents the expected values. We can evaluate the fit of the model according to how evenly the points spread throughout the plot. For example, the overcrowded points seen in the leftmost bottom tile communicate that the independence model underestimates the number of respondents that think it is rude to recline and never recline their seats.\nggplot(flights_model) + geom_mosaic(aes(weight = Expected,\nx = product(do_you_recline, rude_to_recline)), alpha = .2) +\ngeom_mosaic_jitter(aes(weight2 = Observed, weight = Expected, x = product(do_you_recline, rude_to_recline)))\nThe jitter geom, with its additional aesthetic mappings, provides a convenient visual aide that can help solidify what the mosaic plot represents and help communicate the differences between conditional and joint probabilities. The implementation of the jitter geom allows the user to extend the functionality of mosaic plots beyond what has previously been available."
        },
        {
            "heading": "A custom theme",
            "text": "Mosaic plots have two main characteristics that set mosaic plots apart from other graphics. First, at its foundation, a mosaic plot is a one-by-one square, and the area of each tile in the mosaic plot is proportional to the frequency of the combination of categories that the tile represents. Second, mosaic plots do not have a standard coordinate system. Rather, mosaic plots have a coordinate system based on recursive partitioning that can integrate several variables. These two characteristics clash with the default ggplot2 theme. For this reason, version 0.3.3 of ggmosaic includes a custom theme for mosaic plots, theme_mosaic(), that can be added to the plot in the same manner as any other ggplot2 theme. (Figure 21)\nThe plot grid lines suffer from the same issue as the axis labels; while the grid lines may be aligned with the correct category levels on one side of the plot, the alignments may not be appropriate for category levels on the opposite side of the plot. theme_mosaic() removes all grid lines but does not remove the axis labels and ticks.\nSeeking a more faithful representation of a mosaic plot, theme_mosaic() enforces a fixed aspect ratio of 1. When faceting, the aspect ratio should be modified according to the number of panels and the direction of the faceting. For example, in Figure 22, the faceting represents the responses to do_you_recline conditioned on the responses to rude_to_recline. The conditioning variable,\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nrude_to_recline, contains three categories, and the faceting represents a horizontal spine. Hence, the aspect ratio is modified from 1 (the default) to 3.\nThe custom theme, theme_mosaic(), seeks to help a viewer extract the correct information from the plot by providing a more suitable default aspect ratio and removing the axes lines that are not always appropriate across the entire plot. As with any theme, however, theme_mosaic() is merely a suggestion of a starting-off point, and it can be modified as seen fit for each individual plot."
        },
        {
            "heading": "5 Interactive exploratory mosaic plot building",
            "text": "Mosaic plots help identify interesting relationships in high-dimensional categorical data and are an influential tool for exploratory data analysis (EDA). Because of the complexities that arise from comparing many categories, it is often necessary to iterate through many of the potential mosaic plots and obtain many views on the data. The addition of interactivity to the generation of mosaic plots can ease this process and help mosaic plots become more valuable and insightful (Hofmann 2003).\nTo facilitate exploring data with mosaic plots, ggmosaic version 0.3.4 includes a Shiny application that can be launched with the function ggmosaic_app() (Figure 23). This app accommodates structural changes to the mosaic plot with the press of certain keystrokes or buttons provided in the side panel. The app enables quick iterations between visualizations, providing a mechanism for discoveries and achieving more profound insight.\nThe app is organized into two tabs (Figure 23), \u201cMOSAIC PLOT\u201d and \u201cDATA\u201d, setting the stage for data set and variable selection. Creating a mosaic plot consists of several steps. Using the drop-down menu provided on the left-hand side, the user first selects from one of the three data sets exported with ggmosaic, the titanic data set, the happy data set, or the fly data set (the default selection). After the data set is selected, the user can create mosaic plots by selecting various variables to include and different dividers to be used, all completed with keystrokes or a set of buttons in the side panel.\nThe arrow keys (up, down, left, right) add, remove, or switch variables. The ordering of the variables can be quickly modified, allowing the user to find a sensible order for the variables in a streamlined manner. Additionally, the \u2018h\u2019, \u2018v\u2019, \u2018s\u2019, and \u2018b\u2019 keys switch the type of divider. The \u2018h\u2019 and \u2018v\u2019 keys switch between horizontal and vertical spines or bars, switching between \u2018hspine\u2019 and \u2018vpsine\u2019 or \u2018hbar\u2019 and \u2018vbar\u2019. Similarly, the \u2018s\u2019 and \u2018b\u2019 keys can be used to select to split the categories into spines or bars, switching between \u2018hspine\u2019 and \u2018hbar\u2019 or \u2018vspine\u2019 and \u2018vbar\u2019. If the user does not press the \u2018h\u2019, \u2018v\u2019, \u2018s\u2019, or \u2018b\u2019 keys, the \u2018mosaic()\u2019 divider is the default, corresponding to the default divider in geom_mosaic(). The \u2018h\u2019, \u2018v\u2019, \u2018s\u2019, or \u2018b\u2019 keystrokes and buttons will only affect the top-level variable. To modify the divider used on a lower-level variable, the user must backtrack via the down arrow key.\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859\nThe Shiny app accommodates a better understanding of the myriad of possible forms a mosaic plot can take by accommodating a thorough search through the variables and structural changes to the mosaic plot with the simple press of certain keystrokes. The app provides an exploratory setting for visualizing many mosaic plots, and provide the user with the code necessary to recreate the selected mosaic plot."
        },
        {
            "heading": "6 Summary",
            "text": "By bringing mosaic plots into the ggplot2 infrastructure, ggmosaic provides a highly customizable framework for generalized mosaic plots with a familiar syntax. The latest release of ggmosaic introduces novel uses of mosaic plots and exemplifies the opportunity the methods of visualizing multidimensional categorical data have for growth.\nThis manuscript is based on version 0.3.3 of the ggmosaic package. It can be installed from CRAN. The development version is available from the GitHub repository.\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859"
        },
        {
            "heading": "Haley Jeppson Department of Statistics Iowa State University",
            "text": "2438 Osborn Dr Ames, IA 50011 ORCiD: 0000-0003-2524-4063 hjeppson@iastate.edu\nHeike Hofmann Department of Statistics Center for Statistics and Applications in Forensic Evidence Iowa State University 2438 Osborn Dr Ames, IA 50011 ORCiD: 0000-0001-6216-5183 hofmann@iastate.edu\nThe R Journal Vol. 14/4, December 2022 ISSN 2073-4859"
        }
    ],
    "title": "Generalized Mosaic Plots in the ggplot2 Framework",
    "year": 2023
}