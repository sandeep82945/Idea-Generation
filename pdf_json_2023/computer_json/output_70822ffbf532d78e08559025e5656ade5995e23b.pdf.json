{
    "abstractText": "Many applications in practice involve the search for a shortest path in a network by optimizing two conflicting objective functions. Such problems often are referred to as biobjective optimization problems. Their goal is to find special optimal paths that are nondominated and are also known in the specialized literature as to as Pareto optimal. While most of the existing methods aim to find the minimum complete set of Pareto optimal paths, we propose an approach that is able to generate a list of all Pareto optimal solutions in a given network. The described method solves the biobjective optimization problem in the case in which the first objective function is a linear (MINSUM), while the second objective function is from the \u201cbottleneck\u201d type (MAXMIN). The presented approach is based on two modifications of the Dijkstra\u2019s shortest path algorithm that solve the MINSUM and the MAXMIN problems respectively. We prove the correctness and the computational complexity of the presented algorithms. Also, we provide detailed numerical examples that illustrate their execution.",
    "authors": [
        {
            "affiliations": [],
            "name": "Lasko M. Laskov"
        },
        {
            "affiliations": [],
            "name": "Marin L. Marinov"
        }
    ],
    "id": "SP:4e883016770a48fd0b10abec22bc082465ac6819",
    "references": [
        {
            "authors": [
                "R. Beier",
                "H. R\u00f6glin",
                "C. R\u00f6sner",
                "B. V\u00f6cking"
            ],
            "title": "The smoothed number of pareto-optimal solutions in bicriteria integer optimization",
            "venue": "Mathematical Programming, vol. 200, pp. 319\u2013355, September 2022. doi: 10.1007/s10107-022-01885-6",
            "year": 2022
        },
        {
            "authors": [
                "J.C. Namorado Climaco",
                "E. Queir\u00f3s Vieira Martins"
            ],
            "title": "A bicriterion shortest path algorithm",
            "venue": "European Journal of Operational Research, vol. 11, no. 4, pp. 399\u2013404, 1982. doi: 10.1016/0377-2217(82)90205-3",
            "year": 1982
        },
        {
            "authors": [
                "P. Hansen"
            ],
            "title": "Bicriterion path problems",
            "venue": "Multiple Criteria Decision Making Theory and Application, pp. 109\u2013127, 1980. doi: 10.1016/S1097- 2765(03)00225-9",
            "year": 1980
        },
        {
            "authors": [
                "X. Gandibleux",
                "F. Beugnies",
                "S. Randriamasy"
            ],
            "title": "Martins\u2019 algorithm revisited for multi-objective shortest path problems with a maxmin cost function",
            "venue": "4OR, vol. 4, no. 1, pp. 47\u201359, 2006. doi: 10.1007/s10288- 005-0074-x",
            "year": 2006
        },
        {
            "authors": [
                "E.Q.V. Martins"
            ],
            "title": "On a multicriteria shortest path problem",
            "venue": "European Journal of Operational Research, vol. 16, no. 2, pp. 236\u2013245, 1984. doi: 10.1016/0377-2217(84)90077-8",
            "year": 1984
        },
        {
            "authors": [
                "J. Brumbaugh-Smith",
                "D. Shier"
            ],
            "title": "An empirical investigation of some bicriterion shortest path algorithms",
            "venue": "European Journal of Operational Research, vol. 43, no. 2, pp. 216\u2013224, 1989. doi: 10.1016/0377- 2217(89)90215-4",
            "year": 1989
        },
        {
            "authors": [
                "A. Skriver",
                "K. Andersen"
            ],
            "title": "A label correcting approach for solving bicriterion shortest-path problems",
            "venue": "Computers & Operations Research, vol. 27, no. 6, pp. 507\u2013524, 2000. doi: 10.1016/S0305-0548(99)00037-4",
            "year": 2000
        },
        {
            "authors": [
                "A. Sede\u00f1o-noda",
                "M. Colebrook"
            ],
            "title": "A biobjective dijkstra algorithm",
            "venue": "European Journal of Operational Research, vol. 276, no. 1, pp. 106\u2013118, 2019. doi: 10.1016/j.ejor.2019.01.007 612 PROCEEDINGS OF THE FEDCSIS. WARSAW, POLAND, 2023",
            "year": 2019
        },
        {
            "authors": [
                "M. Minoux"
            ],
            "title": "Solving combinatorial problems with combined minmax-min-sum objective and applications",
            "venue": "Mathematical Programming, vol. 45, no. 1-3, pp. 361\u2013372, 1989. doi: 10.1007/bf01589111",
            "year": 1989
        },
        {
            "authors": [
                "A.P. Punnen"
            ],
            "title": "On combined minmax-minsum optimization",
            "venue": "Computers & Operations Research, vol. 21, no. 6, pp. 707\u2013716, 1994. doi: 10.1016/0305-0548(94)90084-1",
            "year": 1994
        },
        {
            "authors": [
                "P. Dell\u2019Olmo",
                "M. Gentili",
                "A. Scozzari"
            ],
            "title": "On finding dissimilar paretooptimal paths",
            "venue": "European Journal of Operational Research, vol. 162, no. 1, pp. 70\u201382, 2005. doi: 10.1016/j.ejor.2003.10.033",
            "year": 2005
        },
        {
            "authors": [
                "F. Guerriero",
                "R. Musmanno"
            ],
            "title": "Label correcting methods to solve multicriteria shortest path problems",
            "venue": "Journal of Optimization Theory and Applications, vol. 111, no. 3, pp. 589\u2013613, 2001. doi: 10.1023/A:1012602011914",
            "year": 2001
        },
        {
            "authors": [
                "C. Mohamed",
                "J. Bassem",
                "L. Taicir"
            ],
            "title": "A genetic algorithms to solve the bicriteria shortest path problem",
            "venue": "Electronic Notes in Discrete Mathematics, vol. 4, no. 1, pp. 851\u2013858, 2010. doi: 10.1016/j.endm.2010.05.108",
            "year": 2010
        },
        {
            "authors": [
                "S. Fidanova",
                "M. Ganzha",
                "O. Roeva"
            ],
            "title": "Intercriteria analyzis of hybrid ant colony optimization algorithm for multiple knapsack problem",
            "venue": "2021 16th Conference on Computer Science and Intelligence Systems (FedCSIS), 2021. doi: 10.15439/2021F22 pp. 173\u2013180.",
            "year": 2021
        },
        {
            "authors": [
                "A. Cassia",
                "O. Jabali",
                "F. Malucelli",
                "M. Pascoal"
            ],
            "title": "The electric vehicle shortest path problem with time windows and prize collection",
            "venue": "2022 17th Conference on Computer Science and Intelligence Systems (FedCSIS), 2022. doi: 10.15439/2022F186 pp. 313\u2013322.",
            "year": 2022
        },
        {
            "authors": [
                "E.W. Dijkstra"
            ],
            "title": "A note on two problems in connexion with graphs",
            "venue": "Numerische Mathematik, vol. 1, no. 1, pp. 269\u2013271, 1959. doi: 10.1007/bf01386390",
            "year": 1959
        },
        {
            "authors": [
                "R. Diestel"
            ],
            "title": "Graph Theory, 5th ed",
            "venue": "ISBN 3662536218",
            "year": 2017
        },
        {
            "authors": [
                "T.H. Cormen",
                "C.E. Leiserson",
                "R.L. Rivest",
                "C. Stein"
            ],
            "title": "Introduction to algorithms, 3rd ed",
            "year": 2009
        },
        {
            "authors": [
                "M.L. Fredman",
                "R.E. Tarjan"
            ],
            "title": "Fibonacci heaps and their uses in improved network optimization algorithms",
            "venue": "Journal of the ACM, vol. 34, no. 3, pp. 596\u2013615, July 1987. doi: 10.1145/28869.28874",
            "year": 1987
        },
        {
            "authors": [
                "M. M\u00fcller-Hannemann",
                "K. Weihe"
            ],
            "title": "Pareto shortest paths is often feasible in practice",
            "venue": "Algorithm Engineering, pp. 185\u2013197, 2001. doi: 10.1007/3-540-44688-5_15 LASKO LASKOV, MARIN MARINOV: LIST OF PARETO OPTIMAL SOLUTIONS OF A BIOBJECTIVE SHORTEST PATH PROBLEM 613",
            "year": 2001
        }
    ],
    "sections": [
        {
            "text": "The described method solves the biobjective optimization problem in the case in which the first objective function is a linear (MINSUM), while the second objective function is from the \u201cbottleneck\u201d type (MAXMIN). The presented approach is based on two modifications of the Dijkstra\u2019s shortest path algorithm that solve the MINSUM and the MAXMIN problems respectively.\nWe prove the correctness and the computational complexity of the presented algorithms. Also, we provide detailed numerical examples that illustrate their execution.\nI. INTRODUCTION\nP ARETO optimal solutions of biobjective (bicriterion) optimization problems are a subject of extensive research in combinatorial optimization and operation research disciplines, and in particular the biobjective shortest path problems [1]. These special type of shortest path problems can arise in numerous applications in practice including transportation problems, computer networking, robot motion, and many others.\nThe search of biobjective Pareto optimal solutions in a shortest path problem is an optimization problem that is a subject of two objective functions, lets say f and g. The Pareto optimal paths (also called nondominated) are a set of paths, such that for any path \u03b1 in it, it is impossible to improve either f or g criterion, without getting worse the other [2].\nBy determining the objective functions f and g, different types of bicriterion path problems can be defined. The first notable work that examines these types of problems is [3] in which Hansen defines ten types of bicriterion path problems, and also introduces their abbreviations. In particular, the MINSUM-MAXMIN problem is solved with an algorithm with a polynomial complexity O(m2 log n), where n is the number of vertices of the network, and m is the number of directed edges. In the MINSUM-MAXMIN problem the first\nobjective function is a liner one, while the second objective function is from the bottleneck type.\nIn the literature actually there are quite few works that focus on the solution of the MINSUM-MAXMIN problem. One of them is [4] which proposes an extension of the Martin\u2019s algorithm [5] for a multiobjective shortest path problem with a MAXMIN objective function. Most of the methods that can be found in the literature focus on the combination of two linear functions, for example [2], [6], [7], [8] solve the MINSUM-MINSUM bicriteria path problem. Other works focus on MINMAX-MINSUM problem (see [9] and [10]), however in their case the authors do not consider the Pareto optimality, rather they aim to define a singe objective function by combining the MINMAX and MINSUM criteria.\nAnother subject that is rarely considered in the literature is the calculation of all Pareto optimal paths from a source vertex v0 and a destination (target, terminal) vertex vt. Most of the existing algorithms aim to find the minimal complete set of Pareto optimal paths, which means that from each equivalent set of Pareto optimal paths a single path is discovered (see [3]). In [11] the authors look for a set of alternative Pareto optimal paths in a method that solves a concrete practical problem for routing of Hazardous materials and propose shortest path algorithm on a network with two criteria: one that corresponds to road length, and the other that corresponds to a risk measure.\nThe work [2] is one of the few in the literature that pays special attention to the calculation of all Pareto optimal paths. The authors propose two algorithms depending whether the paths may contain or may not contain loops, both of them based on k shortest paths algorithms in graphs. However, as mentioned above, in this work the two objective functions are linear, and the algorithms do not cover the case in which one of the functions is a bottleneck function.\nThe exact methods that are present in the literature, are generally classified into labeling and ranking paths algorithms [12]. Labeling algorithms can be split into two categories: label setting [3], [5], [8]; and label correcting [6], [7], [11]. In the category ranking paths we can classify methods that are based on the k shortest paths algorithms, for example [2]. The other major branch of methods are based on heuristics approaches. For example, in [13] the authors propose a so-\nIEEE Catalog Number: CFP2385N-ART \u00a92023, PTI 603 Thematic track: Computational Optimization\nlution to the biobjective shortest path problem that is based on a genetic algorithm for which the authors report to find the Pareto optimal set in 77% of the instances. Also, the probabilistic technique ant colony optimization (ACO) and its modifications are adopted in the solution of various complex combinatorial problems (see for example [14]). Heuristic methods often are adopted in various practical problems, like electric vehicle shortest path problem [15].\nIn this paper we propose an exact method for calculation of all Pareto optimal paths for the MINSUM-MAXMIN problem in a network. We define two helper problems, MINSUM list and MAXMIN list, and we provide two algorithms that solve them, which are based on generalization of the Dijkstra\u2019s algorithm [16]. We use the solutions of the two helper problems to formulate the method for general problem solution. The correctness of all algorithms is proved, and their computational complexity is shown. Also, we illustrate the algorithms with detailed examples that show their execution.\nThe paper is organized as follows. In Sec. II we introduce the notations and problems formulation. In Sec. III we describe the two algorithms that solve the two helper problems. In Sec. IV we show how the Pareto optimal solutions list is constructed based on the solution of the two helper problems. Finally, Sec. V contains conclusions and discussions."
        },
        {
            "heading": "II. PROBLEM FORMULATION",
            "text": ""
        },
        {
            "heading": "A. Notations",
            "text": "Let G = (V,E) is a directed graph (digraph) with n = |V | number of vertices and m = |E| number of directed edges. Without loss of generality we will assume that V = {1, 2, . . . , n} and E \u2286 V 2.\nWe define the following two functions on the set of edges of the digraph, f : E \u2192 R+ and g : E \u2192 R+. The function f assigns to each edge (i, j) \u2208 E the positive number f(i, j), which we call the length of the edge e = (i, j). The function g assigns to each edge (i, j) \u2208 E:\ng(i, j) = { +\u221e, if (i, j) \u2208 E has no restriction gij > 0, if (i, j) \u2208 E has a restriction\nFor convenience, we will call the value g(i, j) the capacity of the edge e = (i, j).\nThe digraph G together with the functions f and g defines the network G = (V,E, f, g) (see [17]). The network is represented by the adjacency list of the outgoing neighbors [18] that is augmented with the length and capacity of the edges in the following way:\nAdj = {Adj(1), . . . , Adj(i), . . . , Adj(n)}, (1)\nwhere Adj(i) = {(j, f(i, j), g(i, j)) : (i, j) \u2208 E}, \u2200i \u2208 V . In this way, if q = Adj(i, k) for some i \u2208 V , and a positive integer k, q(1) will denote the k-th outgoing neighbor of the vertex i, q(2) will denote the length of the edge (i, q(1)), and q(3) will denote the capacity of the edge. To denote the adjacency list of outgoing neighbors of a given network G, we will use the notation G.Adj.\nPath in the network G is the finite sequence of the type\nv0, e1, v1, e2, . . . , v(t\u22121), et, vt, (2)\nwhere vj \u2208 V, \u2200j \u2208 {0, 1, . . . , t} are distinct vertices, and ei is an edge with starting vertex v(i\u22121) and ending vertex vi, that belongs to E for all i \u2208 {1, 2, . . . , t}. The path consists of (t+ 1) vertices and t edges, the vertex v0 is the source of the path, and the vertex vt is the destination of the path.\nThe path (2) with a source v0 and a destination vt connects v0 with vt and is called a (v1, vt)-path, which we will denote with an ordered sequence \u03b1 of vertices:\n\u03b1 = (v0, v1, . . . , vt). (3)\nFor each path \u03b1 = (v0, v1, . . . , vt) we define two functions:\nx(\u03b1) = t\u2211\nj=1\nf(vj\u22121, vj) (4)\ny(\u03b1) = min j\u2208{1,...,t} {g(vj\u22121, vj)} (5)\nWe will call the number x(\u03b1) the length of the path, and the number y(\u03b1) the capacity of the path \u03b1. Both functions x(\u03b1) and y(\u03b1) define the objective functions of the problems that we will discuss.\nWe denote all (1, j)-paths with the shorter Wj . Then, we will call the number\nrj = min \u03b1\u2208Wj {x(\u03b1)} (6)\na distance between the vertex 1 and the vertex j. Also, we will call the number\ncj = max \u03b1\u2208Wj {y(\u03b1)} (7)\nthe capacity of the vertex j. For each Wj the term Pareto optimal path is defined as follows.\nDefinition 1. We call the path \u03b1 \u2208 Wj Pareto optimal when there does not exist another path \u03b2 \u2208 Wj , for which any of the following two conditions is fulfilled:\n\u2022 x(\u03b2) < x(\u03b1) and y(\u03b2) \u2265 y(\u03b1); \u2022 x(\u03b2) \u2264 x(\u03b1) and y(\u03b2) > y(\u03b1).\nWe say that \u03b1 and \u03b2 are equivalent (\u03b1 \u223c \u03b2), when x(\u03b1) = x(\u03b2) and y(\u03b1) = y(\u03b2).\nThe path \u03b2 is dominated by the path \u03b1, when x(\u03b1) < x(\u03b2) and y(\u03b1) \u2265 y(\u03b2) or x(\u03b1) \u2264 x(\u03b2) and y(\u03b1) > y(\u03b2).\nBesides that, we will denote the distance from vertex 1 to any vertex v with r(v)."
        },
        {
            "heading": "B. Problems formulation",
            "text": "Based on the above definitions, we formulate the main\nproblem considered in this paper:\nProblem 1 (List of Pareto optimal solutions). Compute a list of all Pareto optimal solutions for Wn.\nTo solve the List of Pareto optimal solutions problem, we\nwill use the solutions of the following two helper problems.\nThe solution of the first helper problem requires the definition of a function minsum(G.Adj) that computes a list of all shortest paths in the network.\nProblem 2 (MINSUM list). Compute a list of all (1, n)-paths with minimal length, given by:\nSx = {\u03b1 \u2208Wn : x(\u03b1) \u2264 x(\u03b2), \u2200\u03b2 \u2208Wn}. (8)\nThe solution of the second helper problem requires the definition of a function maxmin(G.Adj), and it is a version of the first helper problem that computes a list of all maximum capacity paths in the network.\nProblem 3 (MAXMIN list). Compute a list of all (1, n)-paths with maximal capacity, given by:\nSy = {\u03b1 \u2208Wn : y(\u03b1) \u2265 y(\u03b2), \u2200\u03b2 \u2208Wn}. (9)"
        },
        {
            "heading": "III. SOLUTION OF THE TWO HELPER PROBLEMS",
            "text": "To solve the two helper problems we propose two modifications of the Dijkstra\u2019s algorithm [16], in which the results hold as well in the case in which the source vertex is selected i0 \u0338= 1. In both modifications we assume that the network G = (V,E, f, g) is defined using the adjacency list of the outgoing neighbors.\nIn the computer program implementation of the modified versions of Dijkstra\u2019s algorithm we apply the Fibonacci heap data structure [19] for all priority queue operations. Even though the relative complexity of its implementation, this advanced data structure introduces a significant speedup of the algorithm to O(n log n + m), which is proved based on amortized analysis [18]."
        },
        {
            "heading": "A. List of all shortest paths",
            "text": "We will solve the problem of computing of a list of all (1, n)- shortest paths by finding the subnetwork G\u0302 = (V, E\u0302, f, g) of the shortest paths.\nDefinition 2. We will say that G\u0302 = (V, E\u0302, f, g) is a subnetwork of the shortest paths in the network G = (V,E, f, g), if the following two properties hold:\n1) Every (1, n)- shortest path in G is also a (1, n)-path in G\u0302. 2) Every (1, n)-path in G\u0302 is a (1, n)- shortest path in G.\nThe solution of the MINSUM list helper problem is given by the definition of a function minsum(G.Adj) (Alg. 2), which for a given network G calculates the adjacency list of the outgoing neighbors of the shortest paths subnetwork G\u0302. The implementation of the minsum(G.Adj) function is based on a modification of the Dijkstra\u2019s algorithm [16], as follows.\nThe algorithm splits the set of network vertices in into subsets. The first subset V0 denotes the vertices that are not yet traversed by the algorithm. The second subset U = V \\V0\nAlgorithm 1 Function relaxS(u, v, d, pr)\nInput: vertices u, v, and vectors d, pr Output: vectors d, pr\nq \u2208 G.Adj(u), such that q(1) = v 2: r \u2190 d(u) + q(2)\nif d(v) > r then 4: d(v)\u2190 r pr(v)\u2190 {u} 6: else if d(v) = r then pushback(pr(v), u) 8: end if\nreturn {d, pr}\nstores the traversed vertices. The procedure that traverses the network guarantees that\nr(v) \u2265 r(u), (10)\nfor each vertex v \u2208 V0 and each vertex u \u2208 U . Initially, V0 = V and U = \u2205. In each of n consecutive iterations of execution the function minsum(G.Adj) a selected vertex is transferred from V0 into U .\nThe algorithm uses two vectors d and pr, both of them with n components. Initially, d(1) = 0, and all other components of d are \u221e. The initial values of pr are equal to the empty set \u2205. After the completion of the algorithm, d will store the distances from the source vertex to each of the other vertices in the network, in other words d(j) = r(j), \u2200j \u2208 V , and pr will store the adjacency list of the ingoing neighbors of the digraph (V, E\u0302). The last step of the minsum(G.Adj) function composes the adjacency list of the outgoing neighbors of the shortest paths subnetwork G\u0302. In the proposed variant of the Dijkstra\u2019s algorithm that solves Prob. 2, the function that implements the relaxation procedure is modified. We define the function relaxS(u, v, d, pr) that performs relaxation of the edge (u, v) by changing the current state of d and pr, as it is given in Alg. 1.\nWe use two more helper functions in our modified Dijkstra\u2019s implementation of the minsum(G.Adj) procedure: extract(V0) and outadj(pr,G.Adj).\nThe input of extract(V0) is the subset V0 \u2282 V , and the output is {v1, V1}, where v1 \u2208 V0, V1 = V0\\{v1} and d(v1) = min v\u2208V0 {d(v)}.\nThe purpose of the outadj(pr,G.Adj) function is to build the adjacency list of the outgoing neighbors of the network G\u0302 out of the digraph presented by the adjacency list of the ingoing neighbors pr. The function composes each edge e = (i, j) from the digraph given by pr, and takes the corresponding edge length f(i, j) and capacity g(i, j) from the outgoing adjacency list of the original input network G.Adj.\nProposition 1. The function minsum(G.Adj) is correctly defined.\nProof: The proof of the correctness of the function minsum(G.Adj) is analogous to the proof of the Dijkstra\u2019s\nAlgorithm 2 Function minsum(G.Adj)\nInput: G.Adj Output: distance d0 to vertex n, and G\u0302.Adj\nV0 \u2190 {1, 2, . . . , n} 2: d\u2190 (0,\u221e, . . . ,\u221e)\nwhile V0 \u0338= \u2205 do 4: {u, V0} \u2190 extract(V0) for each q \u2208 G.Adj(u) do 6: {d, pr} \u2190 relaxS(u, q(1), d, pr)\nend for\n8: end while\nG\u0302.Adj \u2190 outadj(pr,G.Adj) 10: return {d(n), G\u0302.Adj}\nalgorithm (see [18]). We will only note that after the each iteration of the while loop the following properties hold for each vertex v \u2208 V0:\n1) d(v) \u2265 r(v); 2) pr(v) is the set of all vertices u \u2208 U for which\nthere exists a path \u03b1 = (i0, i1, . . . , ik, u, v) with length x(\u03b1) = d(v).\nBesides that, when v1 \u2208 V0 and d(v1) = min v\u2208V0 {d(v)}, then following the proof of the Dijkstra\u2019s algorithm, we find out that d(v1) = r(v1). Then in the set V0 does not exist a vertex that is the one before the last one in a (i0, v1)-path with length d(v1). In fact, if we assume that for the path \u03b1 = (i0, i1, . . . , ik, v1) holds ik \u2208 V0 and x(\u03b1) = d(v1), we reach contradiction because\nr(v1) = d(v1) = k\u2211\ns=1\nf(is\u22121, is)+f(ik, v1) \u2265 r(ik)+f(ik, v)\nand using the inequality (10), we get r(v1) \u2265 r(v1)+f(ik, v).\nThe while loop of the algorithm stops when V0 = \u2205, and then d(j) = r(j), \u2200j \u2208 V .\nWe define the network G\u0302 = (V, E\u0302, f, g), where E\u0302 = {(i, j) \u2208 E : i \u2208 pr(j)}. In this way, G\u0302 is the shortest paths subnetwork of the network G, and pr is the adjacency list of the ingoing neighbors of the digraph (V, E\u0302), which is verified directly, by using the fact that pr(v) is the set of those vertices u \u2208 V for which there exists a path \u03b1 = (i0, i1, . . . , u, v) such that x(\u03b1) = r(v).\nIt is clear that using the adjacency list G\u0302.Adj, it is easy to compose the list of all (1, n)- shortest paths. The following example illustrates this observation.\nExample 1. Let G1 is the network given on the Figure 1. We will find all (1, 5)- shortest paths in G1.\nSolution: The outgoing adjacency list of G1 is given by:\nG1.Adj = {{(2, 2, 4), (3, 5, 3)},\n{(3, 3, 5), (4, 6, 4), (5, 5, 3)},\n{(4, 3, 6), (5, 1, 1)}, {(5, 1, 7)}, {}}.\n(11)\nThe function minsum(G1.Adj) produces the following result:\n{d0, G\u03021.Adj} \u2190 minsum(G1.Adj), (12)\nwhere G\u03021.Adj = {{(2, 2, 4), (3, 5, 3)}, {(3, 3, 5), (4, 6, 4)}, {(4, 3, 6), (5, 1, 1)}, {}, {}} and d0 = 6.\nThe network with outgoing adjacency list G\u03021.Adj has exactly two (1, 5)-paths\n\u03b1 = (1, 3, 5) and \u03b2 = (1, 2, 3, 5).\nObviously, x(\u03b1) = x(\u03b2) = 6 = d0.\nProposition 2. The function minsum(G.Adj) has computational complexity O(n log n+m).\nThe proof follows directly from the computational complexity of the Dijkstra\u2019s algorithm, in the case in which the Fibonacci heap data structure is used for the implementation of the priority queue operations (refer to [18])."
        },
        {
            "heading": "B. List of all maximum capacity paths",
            "text": "We denote the capacity of each vertex of the network v \u2208 V with c(v).\nDefinition 3. We say that G\u0303 = (V, E\u0303) is a maximal capacity digraph of the network G = (V,E, f, g), if the following two properties hold:\n1) Every (1, n)- maximal capacity path in G is also a (1, n)-path in G\u0303. 2) Every (1, n)-path in G\u0303 is also a (1, n)- maximal capacity path in G.\nIn this section we will define the function maxmin(G.Adj) which calculates the adjacency list of the outgoing neighbors G\u0303.Adj of the maximal capacity graph G\u0303 = (V, E\u0303). For its implementation, first we will formulate the function capacity(G.Adj) (Alg. 3) which calculates the capacity of a vertex n in the network G, again following the Dijkstra\u2019s algorithm.\nWe denote with d a vector of n components that initially has all its elements equal to \u2212\u221e, except the first element d(1) = \u221e. During the calculations of the function capacity(G.Adj) the components of d are growing, and when the function\nAlgorithm 3 Function capacity(G.Adj)\nInput: G.Adj Output: the capacity cn of the vertex n\nV0 \u2190 {1, 2, . . . , n} 2: d\u2190 (\u221e,\u2212\u221e, . . . ,\u2212\u221e)\nwhile V0 \u0338= 0 do 4: {u, V0} \u2190 extract(V0, d) for each q \u2208 G.Adj(u) do 6: relax(u, q(1), G.Adj, d)\nend for\n8: end while\nreturn d(n)\ncompletes, the j-th component of d stores the capacity of the vertex j, or in other words d(j) = c(j). Note that by definition c(1) =\u221e.\nWe will use the following helper functions in the implementation of capacity(G.Adj). The function extract(V0, d) for an arbitrary subset V0 = {j1, j2, . . . , jk} \u2286 V and using the vector d, calculates the pair {js, V1}, where\njs \u2208 V0, d(js) = max jp\u2208V0 {d(jp)} and V1 = V0 \\ {js}. (13)\nThe function relax(i, j, G.Adj, d) for each two vertices i and j, and based on G.Adj and d, performs the following calculations:\n1) Defines r = min{d(i), g(i, j)}. 2) If d(j) < r, it sets d(j) = r.\nProposition 3. The function capacity(G.Adj) is correctly defined.\nProof: Let 1 \u2264 k < n. We assume that after k iterations of the while loop (see Alg. 3), from the initial set V0 = V = {1, 2, . . . , n} are excluded k number of vertices us, and for the resulting set V0 = V \\ {u1, . . . , uk} the following properties hold:\n1) For each u \u2208 U = {u1, . . . , uk} it holds that d(u) = c(u). 2) For each u \u2208 U and each v \u2208 V0 it hods that d(u) \u2265 d(v). 3) Let vk \u2208 V0 and d(vk) \u2265 d(v) for each v \u2208 V0. Then d(vk) = c(vk). The above three properties are true for k = 1. After the (k + 1)-st iteration of the while loop, the vertex vk is excluded from v0 and we get V \u2032 0 = V0 \\ {vk}. We will prove that the three properties hold for the set V \u20320 . From the definition of vk and the fact that the three properties hold for V0, it follows directly that properties 1) and 2) are fulfilled for V \u20320 .\nNow, let vk+1 \u2208 V \u2032 0 and d(vk+1) \u2265 d(v) for each v \u2208 V \u2032 0 . We denote U \u2032 = U\u222a{vk} = V \\V \u2032 0 . Also, let \u03b1 be an arbitrary (1, vk+1)-path and\n\u03b1 = (1, u1, . . . , us, vj1 , . . . , vjr , vk+1),\nAlgorithm 4 Function maxmin(G.Adj)\nInput: G.Adj Output: the capacity c of the vertex n and G\u0303.Adj\nc\u2190 capacity(G.Adj) 2: for i\u2190 1 to n do for each q \u2208 Adj(i) do 4: if q(3) \u2265 c then pushback(G\u0303.Adj, q(1)) 6: end if\nend for\n8: end for\nreturn {c, G\u0303.Adj}\nwhere ui \u2208 U \u2032, \u2200i \u2208 {1, . . . , s} and vj1 \u2208 V \u2032 0 .\nFrom the definition of d(vj1) it follows that for the capacity y(\u03b2) of the path \u03b2 = (1, u1, . . . , us, vj1) it is fulfilled that y(\u03b2) \u2264 d(j1). Then, for that capacity y(\u03b1) of the path \u03b1 we have that\ny(\u03b1) \u2264 y(\u03b2) \u2264 d(vj1) \u2264 d(vk+1),\nwhich proves that d(vk+1) = c(vk+1). Having the function capacity(G.Adj), we can define the function maxmin(G.Adj), given in Alg. 4.\nProposition 4. The function maxmin(G.Adj) is correctly defined.\nProof: Since the function capcity(G.Adj) that is triggered on the first line of the Alg. 4 is correct, it follows that c is the capacity of the vertex n. The outer for loop on the line 2 defines that adjacency list G\u0303.Adj of the graph G\u0303 = (V, E\u0303), where E\u0303 = {(i, j) \u2208 E : g(i, j) \u2265 c}. Now we will prove that the graph G\u0303 = (V, E\u0303) is the maximum capacity graph.\nIf \u03b1 is a (1, n)-path in the network G with capacity y(\u03b1) = c, then for each edge (i, j) of \u03b1 it holds that g(i, j) \u2265 c, and hence, (i, j) \u2208 E\u0303. This shows that \u03b1 is a (1, n)-path of G\u0303.\nNow, let \u03b2 is a (1, n)-path in G\u0303. This means that \u03b2 is a (1, n)-path in the network G, and for each its edge (i, j) it is fulfilled that g(i, j) \u2265 c. From here it follows that y(\u03b2) \u2265 c. However, since c is the capacity of the vertex n, then y(\u03b2) = c.\nProposition 5. The computational complexity of the function maxmin(G.Adj) is O(n log n+m).\nThe proof follows directly from the complexity of the Dijkstra\u2019s algorithm implemented with Fibonacci heap, since the function capacity(G.Adj) repeats exactly it steps. We will introduce the function list(m, G\u0303.Adj) that will help us to clarify the following examples. The argument of the function m is a natural number or\u221e. The function maps a list S of (1, n)-paths in G\u0303 that satisfies the following properties:\n1) If m =\u221e, the list S contains all (1, n)-paths of G\u0303. 2) If m is a natural number, S contains all (1, n)-paths of\nG\u0303 if their number is not greater than m. Otherwise, S contains m number of all (1, n)-paths of G\u0303.\nExample 2. For the network G1 (see Fig. 1) we will compose the list Sy (9) of all (1, 5)-paths with maximal capacity.\nSolution: The solution is composed by the following two\nsteps:\n1) {c, G\u03031.Adj} \u2190 maxmin(G1.Adj). 2) Sy \u2190 list(\u221e, G\u03031.Adj).\nOn the first step, using the function maxmin(G1.Adj), we calculate that:\nc = 4 and G\u03031.Adj = {{2}, {3, 4}, {4}, {5}, {}}.\nOn the second step, the function list(\u221e, G\u03031.Adj) calculates the list\nSy = {(1, 2, 4, 5), (1, 2, 3, 4, 5)}.\nThen, it is directly verified that\ny((1, 2, 4, 5)) = y((1, 2, 3, 4, 5)) = 4 = c."
        },
        {
            "heading": "IV. PARETO OPTIMAL SOLUTIONS SET",
            "text": "We denote with P the set of Pareto optimal paths in the network G = (V, V, f, g). It is clear that\nP =\nk0\u22c3\ni=1\nPi, (14)\nwhere Pi are the classes of Pareto equivalent paths. We will find the set P by composing a list Q of all classes of Pareto equivalent paths Pi. We will compose the list Q using the following procedure, which we will call Pareto Optimal Paths (POP):\n1) Set W = Wn. 2) Calculate d = min\n\u03b2\u2208W {x(\u03b2)} and define X = {\u03b1 \u2208 W :\nx(\u03b1) = d}. 3) Calculate c = max\n\u03b2\u2208X {y(\u03b2)} and define P0 = {\u03b1 \u2208 X :\ny(\u03b1) = c}. Store P0 into the list Q. 4) Define Y = {\u03b2 \u2208W : y(\u03b2) > c}. 5) Define Z = W \\ (Y \u222a P0). 6) If Y = \u2205, then end. Otherwise, set W = Y and go back\nto step 2.\nLemma 1. The POP procedure correctly composes the list Q.\nProof: We will prove the correctness of the POP proce-\ndure by induction.\nBase case. The first iteration of POP defines:\nd1 = min \u03b2\u2208Wn {x(\u03b2)}, X1 = {\u03b1 \u2208Wn : x(\u03b1) = d1},\nc1 = max \u03b2\u2208X1 {y(\u03b2)}, P1 = {\u03b1 \u2208 X1 : y(\u03b1) = c1}, Q = {P1},\nY1 = {\u03b2 \u2208Wn : y(\u03b2) > c1}, Z1 = Wn \\ (Y1 \u222a P1).\nThe following properties hold:\n1) From the definitions of the sets P1, Y1 and Z1 it follows:\nWn = Z1 \u222a P1 \u222a Y1, Z1 \u2229 P1 = \u2205,\nZ1 \u2229 Y1 = \u2205, Y1 \u2229 P1 = \u2205.\n2) If \u03b1 \u2208 P1, then by the definition of P1 the equalities x(\u03b1) = d1 and y(\u03b1) = c1 hold. Hence, the paths that belong to P1 are equivalent. 3) If Z1 \u0338= \u2205 and \u03b2 \u2208 Z1, then from step 5 it follows that one of the following two statements is fulfilled:\na) y(\u03b2) < c1 and x(\u03b2) \u2265 d1, or b) y(\u03b2) = c1 and x(\u03b2) > d1.\nHence, \u03b2 is dominated by each \u03b1 \u2208 P1.\nIf Y1 = \u2205, then Wn = P1 \u222aZ1 and P1 is the set of Pareto optimal paths. This means that in (14) the constant k0 = 1, and the calculations of the POP procedure will stop.\nIf Y1 \u0338= \u2205, then the constant k0 > 1. In this case, for each \u03b2 \u2208 Y1 the inequalities are fulfilled:\nc1 < y(\u03b2) and d1 < x(\u03b2). (15)\nAs a result, also in this case P1 is a set of equivalent Pareto optimal paths \u03b1, and it is correctly included in the list Q. Here, we set W = Y1, and we go back to step 2 of the second iteration of the procedure.\nThe second iteration of the POP procedure defines:\nd2 = min \u03b2\u2208Y1 {x(\u03b2)}, X2 = {\u03b1 \u2208 Y1 : x(\u03b1) = d2},\nc2 = max \u03b2\u2208X2 {y(\u03b2)}, P2 = {\u03b1 \u2208 X2 : y(\u03b1) = c2},\nQ = {P1, P2}, Y2 = {\u03b2 \u2208 Y1 : y(\u03b2) > c2},\nZ2 = Y1 \\ (Y2 \u222a P2).\nIn analogy with the first iteration of POP, the following properties are proved.\n1) From the definitions of the sets P2, Y2 and Z2 it follows:\nY1 = Z2 \u222a P2 \u222a Y2, Z2 \u2229 P2 = \u2205,\nZ2 \u2229 Y2 = \u2205, Y2 \u2229 P2 = \u2205 (16)\n2) If \u03b1 \u2208 P2, then by the definition of P2 the equalities x(\u03b1) = d2 and y(\u03b1) = c2 hold, and hence the paths that belong to P2 are equivalent. Besides that, from (15) follows that d1 < d2 and c1 < c2.\nIf Z2 \u0338= \u2205, then for each path \u03b2 \u2208 Z2 holds that x(\u03b2) \u2265 d2 because \u03b2 \u2208 Y1. Besides that, y(\u03b2) \u2264 c2, because \u03b2 /\u2208 Y2. Then, for \u03b2 one of the following statements hold:\n\u2022 y(\u03b2) < c2 and x(\u03b2) \u2265 d2, or \u2022 y(\u03b2) = c2 and x(\u03b2) > d2, because \u03b2 /\u2208 P2.\nTherefore, each path \u03b2 \u2208 Z2 is dominated by any path from P2.\nLet \u03b1 \u2208 P2, and \u03b2 is such a (1, n)-path, so that \u03b2 /\u2208 Y1. Then y(\u03b2) \u2264 c1 < y(\u03b1). The following two cases are possible:\n\u2022 x(\u03b2) \u2265 d2 = x(\u03b1). In this case \u03b1 dominates \u03b2. \u2022 x(\u03b2) < d2 = x(\u03b1). In this case \u03b1 and \u03b2 cannot be\ncompared.\nThat proves that if Y2 = \u2205, then the elements of P2 are Pareto optimal and the equation (14) has the form P = P1 \u222a P2, in other words, k0 = 2. From here it follows that P2 is correctly included in the list Q, and the termination of the computation of POP procedure is correct.\nIf Y2 \u0338= \u2205, then k0 > 2. In this case, for each \u03b2 \u2208 Y2 the following inequalities are fulfilled.\nc2 < y(\u03b2) and d2 < x(\u03b2) (17)\nThe first inequality follows from the definition of Y2, and the second one \u2013 from the definition of d2 and c2.\nTherefore, also in the case in which Y2 \u0338= \u2205, the set P2 is a set of Pareto optimal paths, and it is correctly included in the list Q. In this case, we set W = Y2 and we go back to step 2 in the procedure to start its third iteration.\nIt is clear that in the third iteration of the procedure Wn = Z1 \u222a P1 \u222a Z2 \u222a P2 \u222a Y2.\nInductive step. We assume that after k \u2265 2 iterations of the POP procedure, the following components are defined.\n\u2022 The sets Pi, Zi, Yk, i \u2208 {1, 2, . . . , k}, that have no common elements. \u2022 The numbers di and ci i \u2208 {1, 2, . . . , k}, for which the following five properties are fulfilled.\n1) Wn = k\u22c3\ni=1\n(Zi \u222a Pi) \u22c3 Yk.\n2) P1, P2, . . . , Pk are sets of equivalent Pareto optimal paths, for which\na) di = x(\u03b1) and ci = y(\u03b1), \u2200\u03b1 \u2208 Pi and \u2200i \u2208 {1, 2, . . . , k}; b) di < di+1 and ci < ci+1, \u2200i \u2208 {1, 2, . . . , (k \u2212 1)}.\n3) Every path \u03b2 \u2208 Zi is dominated by every path \u03b1 \u2208 Pi. 4) For every \u03b2 \u2208 Yk the inequalities hold:\nck < y(\u03b2) and dk < x(\u03b2). (18)\n5) Q = {P1, P2, . . . , Pk}.\nThese five properties follow directly from the proof of the second iteration of the procedure.\nIt is clear that if Yk = \u2205, then Wn = k\u22c3\ni=1\n(Zi \u222a Pi) and the\nlist Q is correctly composed. If Yk \u0338= \u2205, we implement the (k + 1)-st iteration of the POP procedure. Using steps from 2 to 5, we define:\ndk+1 = min \u03b2\u2208Yk {x(\u03b2)}, Xk+1 = {\u03b1 \u2208 Yk : x(\u03b1) = dk+1},\nck+1 = max \u03b2\u2208Xk+1 {y(\u03b2)},\nPk+1 = {\u03b1 \u2208 Xk+1 : y(\u03b1) = ck+1},\nQ = {P1, P2, . . . , Pk+1}, Yk+1 = {\u03b2 \u2208 Yk : y(\u03b2) > c2},\nZk+1 = Yk \\ (Yk+1 \u222a Pk+1).\nRepeating the proof of the second iteration, we find out that for\n\u2022 sets Pi, Zi, Yk+1, i \u2208 {1, 2, . . . , k, (k + 1)}, and \u2022 numbers di and ci i \u2208 {1, 2, . . . , k, (k + 1)}\nthe five properties are fulfilled.\nSince Wn has finite number of elements and Pi \u0338= \u2205, \u2200i, then after a finite number of k0 iterations the procedure POP stops, and we prove that:\n1) Wn = k0\u22c3 i=1 (Zi \u222a Pi); 2) P1, P2, . . . , Pk0 are sets of equivalent Pareto optimal paths for which\na) di = x(\u03b1) and ci = y(\u03b1), \u2200\u03b1 \u2208 Pi and \u2200i \u2208 {1, 2, . . . , k0}; b) di < di+1 and ci < ci+1, \u2200i \u2208 {1, 2, . . . , (k0\u22121)}.\n3) Every path \u03b2 \u2208 Zi is dominated by every path \u03b1 \u2208 Pi. 4) Q = {P1, P2, . . . , Pk0}.\nCorollary 1. For the classes Pi of Pareto optimal paths the following holds\nPi = {\u03b1 \u2208Wn : x(\u03b1) = di and y(\u03b1) = ci},\nfor each i \u2208 {1, 2, . . . , k0}.\nCorollary 2. For Pk0 the following equality hods:\nPk0 = {\u03b1 \u2208 X \u2032 1 : x(\u03b1) = d \u2032 1},\nwhere X \u20321 = {\u03b1 \u2208 Wn : y(\u03b1) = max \u03b2\u2208Wn {y(\u03b2)} and d\u20321 = min \u03b2\u2208X\u2032\n1\n{x(\u03b2)}.\nRemark 1. The list Q can be composed by: first apply the Corollary 2 to separate the set Pk0 ; after that, consecutively separate the sets Pk0\u22121, Pk0\u22122, and so on, until P1 is separated.\nEvery subset Pi turns out to be a set of all (1, n)-paths in a special digraph Gi. The algorithm that finds a List of Pareto Optimal Paths which we will call LPOP (given in Alg. 5), composes a list S of the adjacency lists Gi.Adj for each i \u2208 {1, 2, . . . , k0} by implementing the POP procedure.\nWe will note that once we have the list S, we can easily obtain a list P \u2032 of Pareto optimal solutions by taking predefined number of elements for each class Pi, as well we can obtain a list P of all optimal solutions.\nBesides the previously defined functions minsum(G.Adj), maxmin(G.Adj) and capacity(G.Adj), in the formulation of the LPOP algorithm (Alg. 5), we will use the function restrict(G.Adj, c), that is defined as follows. The function restrict(G.Adj, c) takes as an input the outgoing adjacency list G.Adj and the number c. It calculates the adjacency list of those edges (i, j) from G.Adj, for which g(i, j) > c.\nTheorem 1. The LPOP algorithm (Alg. 5) is correct.\nProof: The correctness of the Alg. 5 follows from the correctness of the functions capacity(G.Adj), minsum(G.Adj), maxmin(G.Adj), and from Lemma 1. It is easily verified by proving that the while loop of the lpop(G.Adj) function implements the POP procedure using these functions.\nWe will examine the first iteration of the while loop. The\nfunction minsum(G.Adj) calculates d0 = min \u03b2\u2208Wn {x(\u03b2)} and defines the adjacency list G\u0302.Adj of the shortest paths subnetwork G\u0302. From the correctness of the function minsum(Adj)\nAlgorithm 5 Function lpop(G.Adj)\nInput: G.Adj Output: the list S with k0 number of elements\nRAdj \u2190 G.Adj 2: c0 \u2190 capacity(G.Adj)\nmore\u2190 true 4: while more = true do {d0, G.Adj} \u2190 minsum(G.Adj) 6: if d0 =\u221e then more\u2190 false 8: else\n{c1, G\u0303.Adj} \u2190 maxmin(G.Adj) 10: pushback(S, G\u0303.Adj) if c1 = c0 then 12: more\u2190 false\nelse\n14: RAdj \u2190 restrict(RAdj, c1) end if 16: G.Adj \u2190 RAdj end if 18: end while\nreturn S\nwe know that \u03b1 is a (1, n)-path in G\u0302, exactly when \u03b1 is a (1, n)-path in the network G and x(\u03b1) = d0. Hence, the set X from the POP procedure is the set of all (1, n)-paths of the subnetwork, defined by the adjacency list G.Adj.\nBy using the definition of the function maxmin(G.Adj), we will prove that its function call implements step 3 of the POP procedure.\nIndeed, when applied on the adjacency list of the subnetwork G\u0302, the function maxmin(Adj) calculates the maximal capacity c1 of a (1, n)-path in G\u0302, and defines the adjacency list G\u0302.Adj of the maximal capacity digraph G\u0303 of the subnetwork G\u0302. This means that \u03b1 is a (1, n)-path in the digraph G\u0303, if and only if it is a (1, n)-path in the network G\u0302 and y(\u03b2) = c1. In the notations of the POP procedure, this means that c1 = max\n\u03b2\u2208X {y(\u03b2)} and \u03b1 is a (1, n)-path in the digraph\nG\u0303 if and only if \u03b1 \u2208 P0. For that reason the adjacency list G\u0303.Adj is included in the list S (line 10 of Alg. 5).\nThe step 6 from the POP procedure is implemented in the alternative branch of the if statement which verifies whether the set Y , defined by the step 4 of the procedure, is the empty set. If c0 = c1, then Y = \u2205, and the algorithm is terminated. Otherwise, we define the adjacency list RAdj of the subnetwork for which \u03b2 is a (1, n)-path if and only if it is a (1, n)-path in G, and y(\u03b2) > c1.\nWe will illustrate the above proof with the following exam-\nple.\nExample 3. For the input network G1, given on Fig. 1, we will trace how the algorithm LPOP (Alg. 5) implements the\nPOP procedure.\nSolution: Initially, the algorithm stores a copy of the ad-\njacency list in the variable RAdj, which will be modified in the body of the while loop. On line 2, the capacity(G.Adj) function calculates that the capacity of the vertex 5 is c0 = 4.\nFirst iteration. The minsum(G.Adj) function calculates the distance d0 = 6 to the vertex 5, and the adjacency list of the subnetwork G\u0302:\nG\u0302.Adj = {{(2, 2, 4), (3, 5, 3)}, {(3, 3, 5), (4, 6, 4)},\n{(4, 3, 6), (5, 1, 1)}, {}, {}}.\nIt is apparent that the above defined subnetwork G\u0302 has exactly two (1, 5)-paths: \u03b11 = (1, 3, 5) and \u03b21 = (1, 2, 3, 5). Besides that, x(\u03b11) = x(\u03b21) = 6. Since the set of all (1, 5)-paths in G1 is W = {(1, 2, 5), (1, 3, 5), (1, 2, 3, 5), (1, 2, 4, 5), (1, 3, 4, 5), (1, 2, 3, 4, 5)}, it is directly verified that \u03b11 and \u03b21 are the only (1, 5)-paths with length d0 = 6 in the network G1. The latter follows from the correctness of the function minsum(G.Adj). In the procedure POP the set {\u03b11, \u03b21} is denoted by X .\nSince d0 = 6 \u0338=\u221e the algorithm enters the body of the else statement on line 8. The function maxmin(G.Adj) calculates that in the subnetwork G\u0302 the capacity of the vertex 5 is c1 = 1, and:\nG\u0303.Adj = {{2, 3}, {3, 4}, {4, 5}, {}, {}}.\nThe outgoing adjacency list G\u0303.Adj defines the maximal capacity digraph G\u0303 of the subnetwork G\u0302. It is apparent that G\u0303 has exactly two (1, 5)-paths. In this case these are \u03b11 = (1, 3, 5) and \u03b21 = (1, 2, 3, 5). Also, y(\u03b11) = y(\u03b21) = 1. In the procedure POP we denote the set {\u03b11, \u03b21} by P0. From Lemma 1 it follows that P0 = {\u03b11, \u03b21} is the first class of equivalent Pareto optimal solutions. For that reason the algorithm includes G\u0303.Adj in the list S. Since c1 = 1 \u0338= c0 = 4, the function restrict(RAdj, c1) modifies the adjacency list RAdj by removing all edges with capacity not greater than c1. The new adjacency list is:\nRAdj = {{(2, 2, 4), (3, 5, 3)}, {(3, 3, 5), (4, 6, 4), (5, 5, 3)},\n{(4, 3, 6)}, {(5, 1, 7)}, {}}.\nIt is directly verified that the set Y1 of all (1, 5)-paths in the network defined by RAdj is the set of all (1, 5)-paths in the network G1 with capacity bigger than c1 = 1, which is verified by Theorem 1. In the procedure POP Y1 is denoted by Y and is defined in the step 4 of the procedure.\nSetting G.Adj = RAdj the LPOP algorithm moves to the next iteration. In the procedure POP, it corresponds to the assignment W = Y , and the start of the new iteration by transition to the step 2.\nSecond iteration. The minsum(G.Adj) function calculates d0 = 7 and\nG\u0302Adj = {{(2, 2, 4), (3, 5, 3)}, {(3, 3, 5), (4, 6, 4), (5, 5, 3)},\n{(4, 3, 6)}, {}, {}}.\nThe resulting subnetwork G\u0302 has a single (1, 5)-path \u03b12 = {1, 2, 5}. The length of the path \u03b12 is x(\u03b12) = 7. In this case X = {\u03b12}.\nThe result of the function maxmin(G.Adj) is:\n\u2022 the capacity of the vertex 5 in the network G\u0302 is c1 = 3, and \u2022 the digraph G\u0303 of the maximal capacity has adjacency list\nG\u0303.Adj = {{2, 3}, {3, 4, 5}, {4}, {}, {}}.\nThe above verifies the fact that in this case P0 = {\u03b12} is the second class of equivalent Pareto optimal solutions. For that reason G\u0303.Adj is included as second element in the list S. Since the condition for the loop stop is not fulfilled,\nRAdj = {{(2, 2, 4)}, {(3, 3, 5), (4, 6, 4)}, {(4, 3, 6)},\n{(5, 1, 7)}, {}}.\nIt is immediately apparent that the set Y2 of all (1, 5)-paths in the network defined by RAdj is the set of (1, 5)-paths of G1, that have capacities grater than c1 = 3.\nThird iteration. The minsum(G.Adj) function calculates that this time the distance to the vertex 5 is d0 = 9, and the new minimal paths subnetwork has adjacency list:\nG\u0302Adj = {{(2, 2, 4)}, {(3, 3, 5), (4, 6, 4)}, {(4, 3, 6)},\n{(5, 1, 7)}, {}}.\nIn this case the set of all (1, 5)-paths in G\u0302 is X = {(1, 2, 4, 5), (1, 2, 3, 4, 5)}, and these are all (1, 5)-paths of Y2 with length d0 = 9.\nUsing the maxmin(G.Adj) function, we find out that in the network G\u0302 the vertex 5 has capacity c1 = 4, and the maximal capacity digraph G\u0303 of the subnetwork G\u0302 has adjacency list G\u0303.Adj = {{2}, {3, 4}, {4}, {5}, {}}.\nApparently, the digraph G\u0303 has exactly two (1, 5)-paths \u03b13 = (1, 2, 4, 5) and \u03b23 = (1, 2, 3, 4, 5). According to Lemma 1, the set P0 = {\u03b13, \u03b23} is the third class of equivalent Pareto optimal paths. In this case x(\u03b13) = x(\u03b23) = 9 and y(\u03b13) = y(\u03b23) = 4. G\u0303.Adj is included as third element in the list S.\nThe condition of the if statement on line 11 c0 = c1 will be evaluated to true. This means that there does not exist a (1, 5)- path with a capacity greater than the current c1. As a result, the while loop is terminated. In the procedure POP this means that Y3 = {\u03b2 \u2208W : y(\u03b2) > 4} = \u2205, and the procedure stops. After the end of the calculations\nS = {{{2, 3}, {3, 4}, {4, 5}, {}, {}},\n{{2, 3}, {3, 4, 5}, {4}, {}, {}},\n{{2}, {3, 4}, {4}, {5}, {}}},\nwhere each element of S determines one class of Pareto optimal paths:\n\u2022 S(1) = {{2, 3}, {3, 4}, {4, 5}, {}, {}} defines the class P1 = {(1, 3, 5), (1, 2, 3, 5)}; \u2022 S(2) = {{2, 3}, {3, 4, 5}, {4}, {}, {}} defines the class P2 = {{1, 2, 5}}; and \u2022 S(3) = {{{2}, {3, 4}, {4}, {5}, {}}} defines the class P3 = {(1, 2, 4, 5), (1, 2, 3, 4, 5)}. The network G1 has the set of Pareto optimal paths P = P1 \u222a P2 \u222a P3.\nTheorem 2. The LPOP algorithm (Alg. 5) has computational complexity k0O(n log n + m), where k0 is the number of classes of Pareto equivalent paths.\nThe proof follows from Prop. 2 and Prop. 5. It is enough to note that on line 2 of Alg. 5 the call to the function capacity(G.Adj) has complexity O(n log n + m), and the while loop has k0 number of iterations, where k0 is the number of classes of Pareto equivalent classes (14). Each iteration involves a single call to the functions minsum(G.Adj) and maxmin(G.Adj), where both have complexity O(n log n + m). Besides that, the function restrict(R.Adj, c1) has computational complexity that is lower than O(n log n+m).\nExample 4. Let the network G2 be defined with the adjacency list\nG2.Adj = {{(2, 1, 17), (3, 1, 20), (4, 1, 19)},\n{(5, 1, 7), (6, 15, 15), (7, 1, 12)},\n{(6, 1, 9), (7, 1, 18), (8, 1, 19), (4, 1, 15)},\n{(5, 14, 15), (6, 1, 12), (7, 1, 12), (8, 1, 9),\n(10, 1, 2)}, {(9, 10, 22), (10, 1, 2), (6, 1, 2)},\n{(11, 1, 4), (9, 14, 20), (10, 1, 6), (7, 1, 3)},\n{(8, 1, 11), (10, 2, 7), (5, 8, 15)},\n{(10, 7, 10), (11, 10, 11)},\n{(11, 8, 19), (10, 1, 20)}, {(11, 3, 21)}, {}}.\n(19)\nWe will find the list of all Pareto optimal solutions using the\nLPOP algorithm.\nSolution: Using the LPOP algorithm, we calculate the list\nS = {{{2, 3, 4}, {5, 7}, {6, 7, 8}, {6, 7, 8}, {9},\n{11}, {}, {}, {}, {}, {}},\n{{2, 3, 4}, {5, 7}, {6, 7, 8}, {6, 7, 8}, {9}, {10},\n{}, {}, {}, {11}, {}},\n{{2, 3, 4}, {5, 7}, {6, 7, 8}, {6, 7, 8}, {9}, {},\n{10}, {}, {}, {11}, {}},\n{{2, 3, 4}, {7}, {7, 8}, {6, 7}, {}, {9}, {5},\n{11}, {}, {11}, {}},\n{{2, 3, 4}, {7}, {7, 8}, {6, 7}, {}, {9}, {5},\n{}, {10}, {11}, {}},\n{{2, 3, 4}, {6}, {7, 8}, {}, {9}, {}, {5}, {},\n{10}, {11}, {}}}.\n(20)\nEvery element of S defines a class of equivalent Pareto optimal paths. Using the function list(m, G\u0303.Adj) we get the Pareto optimal paths as a sequence of vertices. For example, the first element of S defines the class P1, that contains two equivalent Pareto optimal paths \u03b11 = (1, 3, 6, 11) and \u03b21 = (1, 4, 6, 11).\nTo each (1, 11)-path in \u03b1 we will map a point\nA\u03b1(x(\u03b1), y(\u03b1)) (21)\nThe points defined in this way are plotted on Fig. 2. For example, to \u03b11 and \u03b21 we map a single point A1(3, 4), because\nx(\u03b11) = x(\u03b21) = 3 and y(\u03b11) = y(\u03b21) = 4. Following this scheme, by using consecutively the elements Sj of the list S, we calculate the remaining classes Pj and we map the point Aj defined by (21), for each j \u2208 {2, 3, 4, 5, 6}. The results are given in Tab. I.\nTherefore, in example (20) the set of all Pareto optimal\npaths is\nP = P1 \u222a P2 \u222a P3 \u222a P4 \u222a P5 \u222a P6.\nThe network G2 has 10 Pareto optimal paths, distributed in 6 classes of equivalent paths. To illustrate graphically the result in Fig. 2, we define the set P of all (1, 11) paths in digraph G2. In the example (20) there are 118 such paths. In this case we obtain 71 points. If the point A\u03b1 illustrates the path \u03b1 that is not a Pareto optimal, we plot it in black. The points given in Tab. I are plotted in white, and they represent the Pareto optimal paths. Each point Aj is a vertex of an angle \u03b3j with rays given in dashed lines. Let \u03b1j be a (1, 11)-path that is represented by the point Aj . Inside the angle \u03b3j lie all points that illustrate paths that are dominated by \u03b1j . The vert. opp. angle of \u03b3j is plotted in gray color, and inside it might lie points that illustrate paths that dominate \u03b1j . As we may expect, such points does not exist."
        },
        {
            "heading": "V. CONCLUSION",
            "text": "In [3] Hansen solves the MAXSUM-MAXMIN shortest path problem by presenting an algorithm that discovers a special subset of the Pareto optimal solutions, called \u201cminimal complete set of efficient paths (MCS)\u201d. The list S that is composed by the LPOP algorithm presented in this paper, gives a more complete information for the Pareto optimal solutions. It is enough to select just one (1, n)-path from each element of S to obtain a MCS. For example, using the list S that we get for (11) that defines the network G1, we get the following MCS: P (1) = {(1, 3, 5), (1, 2, 5), (1, 2, 4, 5)}. Besides that,\napparently for the network G1 three more different MCS can be composed.\nHansen proves that the number of Pareto optimal solutions grows exponentially with the increasing of the number of vertices in the network. However, it has been shown that in various real practical applications this number can be much smaller [20]. In the latter work authors discover key characteristics in the input data that lead to a number of Pareto optimal solutions on each vertex that is restricted by a small constant. In our case, this leads to the restriction of the constant k0 in Theorem 2.\nIn Sec. III-A we solve the MINSUM list problem. We prove the correctness of minsum(G.Adj) function (Alg. 2) that helps us to describe all shortest paths by calculation of the shortest paths subnetwork. We prove that its computational complexity is O(n log n+m).\nIn Sec. III-B we solve the MAXMIN list problem with Alg. 3 that allows us to calculate the capacity of a vertex with computational complexity O(n log n + m). Based on it, we define the function maxmin(G.Adj) (Alg. 4) that describes all maximum capacity paths by defining the maximum capacity digraph of the network G. The complexity of the algorithm is again shown to be O(n log n+m).\nBesides the solution of the corresponding MINSUM list and MAXMIN list problems, the two functions minsum(G.Adj) and maxmin(G.Adj) using Alg. 5 allow the solution of Prob. 1. The resulting description of all Pareto optimal solutions separates the classes of Pareto equivalent paths, and allows to visualize a predefined number of elements from each class of Pareto equivalent paths. The correctness of the algorithm is proved (Th. 1), and also its computational complexity is proved to be k0O(n log n+m) (Th. 2)."
        }
    ],
    "title": "List Of Pareto Optimal Solutions of a Biobjective Shortest Path Problem",
    "year": 2023
}