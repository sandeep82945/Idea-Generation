{
    "abstractText": "COPYRIGHT \u00a9 2023 Sch\u00f6pping, Kenneweg, Hesse and R\u00fcckert. This is an open-access article distributed under the terms of the Creative Commons Attribution License (CC BY). The use, distribution or reproduction in other forums is permitted, provided the original author(s) and the copyright owner(s) are credited and that the original publication in this journal is cited, in accordance with accepted academic practice. No use, distribution or reproduction is permitted which does not comply with these terms. \u03bcRT: A lightweight real-time middleware with integrated validation of timing constraints",
    "authors": [
        {
            "affiliations": [],
            "name": "Jose Luis Sanchez-Lopez"
        },
        {
            "affiliations": [],
            "name": "Stefan Kowalewski"
        },
        {
            "affiliations": [],
            "name": "Thomas Sch\u00f6pping"
        },
        {
            "affiliations": [],
            "name": "Svenja Kenneweg"
        },
        {
            "affiliations": [],
            "name": "Ulrich R\u00fcckert"
        }
    ],
    "id": "SP:7a2e7e564bb969fad09b414275c87765f3d26e1a",
    "references": [
        {
            "authors": [
                "A.L. Ananda",
                "B. Tay",
                "Koh",
                "E.-K."
            ],
            "title": "A survey of asynchronous remote procedure calls",
            "venue": "ACM SIGOPS Oper. Syst. Rev. 26, 92\u2013109. doi:10.1145/142111.142121",
            "year": 1992
        },
        {
            "authors": [
                "J.H. Anderson",
                "S. Ramamurthy",
                "K. Jeffay"
            ],
            "title": "Real-time computing with lock-free shared objects",
            "venue": "ACM Trans. Comput. Syst. (TOCS) 15, 134\u2013165. doi:10.1145/253145.253159",
            "year": 1997
        },
        {
            "authors": [
                "H. Bruyninckx",
                "M. Klotzb\u00fccher",
                "N. Hochgeschwender",
                "G. Kraetzschmar",
                "L. Gherardi",
                "D. Brugali"
            ],
            "title": "The BRICS component model: A model-based development paradigm for complex robotics software systems,",
            "venue": "Proceedings of the 28th Annual ACM Symposium on Applied Computing,",
            "year": 2013
        },
        {
            "authors": [
                "H. Bruyninckx"
            ],
            "title": "Open robot control software: The OROCOS project,\u201d in Proceedings 2001 ICRA",
            "venue": "IEEE International Conference on Robotics and Automation (IEEE), 2523\u20132528.",
            "year": 2001
        },
        {
            "authors": [
                "D. Caromel"
            ],
            "title": "Toward a method of object-oriented concurrent programming",
            "venue": "Commun. ACM 36, 90\u2013102. doi:10.1145/162685.162711",
            "year": 1993
        },
        {
            "authors": [
                "M. Di Natale",
                "J.A. Stankovic"
            ],
            "title": "Scheduling distributed real-time tasks with minimum jitter",
            "venue": "IEEE Trans. Comput. 49, 303\u2013316. doi:10.1109/12.844344",
            "year": 2000
        },
        {
            "authors": [
                "G. di Sirio"
            ],
            "title": "ChibiOS/RT the ultimate guide (giovanni di Sirio). Available at: https://www.chibios.org/dokuwiki/ doku.php?id=chibios:documentation:books:rt:start",
            "year": 2020
        },
        {
            "authors": [
                "P.T. Eugster",
                "P.A. Felber",
                "R. Guerraoui",
                "Kermarrec",
                "A.-M."
            ],
            "title": "The many faces of publish/subscribe",
            "venue": "ACM Comput. Surv. (CSUR) 35, 114\u2013131. doi:10.1145/857076.857078",
            "year": 2003
        },
        {
            "authors": [
                "J. Faust"
            ],
            "title": "Rosrt",
            "venue": "Available at: https://wiki.ros.org/rosrt.",
            "year": 2022
        },
        {
            "authors": [
                "V. Fay-Wolfe",
                "L.C. DiPippo",
                "G. Cooper",
                "R. Johnson",
                "P. Kortmann",
                "B. Thuraisingham"
            ],
            "title": "Real-time CORBA",
            "venue": "IEEE Trans. Parallel Distributed Syst. 11, 1073\u20131089. doi:10.1109/71.888646",
            "year": 2000
        },
        {
            "authors": [
                "D. Grisby"
            ],
            "title": "omniORB",
            "venue": "Available at: https://omniorb.sourceforge.io/.",
            "year": 2022
        },
        {
            "authors": [
                "M. Henning"
            ],
            "title": "The rise and fall of CORBA",
            "venue": "Queue 4, 28\u201334. doi:10.1145/1142031.1142044",
            "year": 2006
        },
        {
            "authors": [
                "S. Herbrechtsmeier",
                "T. Korthals",
                "T. Sch\u00f6pping",
                "U. R\u00fcckert"
            ],
            "title": "AMiRo: A modular & customizable open-source mini robot platform,",
            "venue": "in 2016 20th International Conference on System Theory, Control and Computing (ICSTCC)IEEE),",
            "year": 2016
        },
        {
            "authors": [
                "S. Herbrechtsmeier"
            ],
            "title": "Modell eines agilen Leiterplattenentwurfsprozesses basierend auf der interdisziplin\u00e4ren Entwicklung eines modularen autonomen Miniroboters",
            "venue": "Ph.D. thesis. Bielefeld (Germany): Bielefeld University.",
            "year": 2017
        },
        {
            "authors": [
                "A.S. Huang",
                "E. Olson",
                "D.C. Moore"
            ],
            "title": "Lcm: Lightweight communications and marshalling in 2010",
            "venue": "IEEE/RSJ International Conference on Intelligent Robots and Systems (IEEE),",
            "year": 2010
        },
        {
            "authors": [
                "U. Jahn"
            ],
            "title": "Verteilte Systemarchitektur f\u00fcr mobile roboter",
            "venue": "Ph.D. thesis. Bielefeld (Germany): Bielefeld University.",
            "year": 2021
        },
        {
            "authors": [
                "J. Kay",
                "A.R. Tsouroukdissian"
            ],
            "title": "Real-time control in ROS and ROS 2.0",
            "year": 2015
        },
        {
            "authors": [
                "T. Korthals",
                "D. Wolf",
                "D. Rudolph",
                "U. R\u00fcckert"
            ],
            "title": "Fiducial marker based extrinsic camera calibration for robot experiment platforms,",
            "venue": "European Conference on Mobile Robots (ECMR),",
            "year": 2019
        },
        {
            "authors": [
                "A.M. Lund"
            ],
            "title": "Measuring usability with the use questionnaire",
            "venue": "Usability interface 8, 3\u20136.",
            "year": 2001
        },
        {
            "authors": [
                "S. Macenski",
                "T. Foote",
                "B. Gerkey",
                "C. Lalancette",
                "W. Woodall"
            ],
            "title": "Robot operating system 2:Design, architecture, and uses in thewild",
            "venue": "Sci. Robotics 7, eabm6074. doi:10.1126/scirobotics.abm6074",
            "year": 2022
        },
        {
            "authors": [
                "A. Mallet",
                "C. Pasteur",
                "M. Herrb",
                "S. Lemaignan",
                "F. Ingrand"
            ],
            "title": "GenoM3: Building middleware-independent robotic components,",
            "venue": "IEEE International Conference on Robotics and Automation (IEEE),",
            "year": 2010
        },
        {
            "authors": [
                "Y. Maruyama",
                "S. Kato",
                "T. andAzumi"
            ],
            "title": "Exploring the performance of ROS2,",
            "venue": "Proceedings of the 13th International Conference on Embedded Software (NewYork, NY: EMSOFT),",
            "year": 2016
        },
        {
            "authors": [
                "M. Matteucci",
                "M. Migliavacca",
                "A. Bonarini"
            ],
            "title": "Practical applications of theR2P embedded framework for robot rapid development,",
            "venue": "IEEE International Conference on Technologies for Practical Robot Applications (TePRA (IEEE),",
            "year": 2015
        },
        {
            "authors": [
                "M. Migliavacca",
                "A. Bonarini",
                "M. andMatteucci"
            ],
            "title": "RTCAN-A real-timeCANbus protocol for robotic applications",
            "venue": "ICINCO",
            "year": 2013
        },
        {
            "authors": [
                "M. Migliavacca"
            ],
            "title": "Rapid robot prototyping",
            "venue": "Available at: https://github.com/ r2p.",
            "year": 2016
        },
        {
            "authors": [
                "M. Migliavacca"
            ],
            "title": "The R2P framework for robot prototyping: Methodological approach, hardware modules, and software components",
            "venue": "Ph.D. thesis. Politecnico di Milano.",
            "year": 2013
        },
        {
            "authors": [
                "R. Oshana"
            ],
            "title": "2 - overview of embedded systems and real-time systems,\u201d in DSP software development techniques for embedded and real-time systems",
            "venue": "Editor R. Oshana (Burlington: Newnes: Embedded Technology), 19\u201334. doi:10.1016/B978075067759-2/50004-1",
            "year": 2006
        },
        {
            "authors": [
                "M. Quigley",
                "K. Conley",
                "B. Gerkey",
                "J. Faust",
                "T. Foote",
                "J Leibs"
            ],
            "title": "Ros: An open-source robot operating system,",
            "venue": "ICRA workshop on open source software (Kobe, Japan),",
            "year": 2009
        },
        {
            "authors": [
                "M. Quigley"
            ],
            "title": "ROS2 on \u201dsmall\u201d embedded systems",
            "venue": "Available at: https:// roscon.ros.org/2015/presentations/ros2_on_small_embedded_systems.pdf.",
            "year": 2015
        },
        {
            "authors": [
                "I.T. Remedy"
            ],
            "title": "TAOX11",
            "venue": "Available at: https://www.taox11.org/.",
            "year": 2019
        },
        {
            "authors": [
                "D.C. Schmidt",
                "D.L. Levine",
                "S. Mungee"
            ],
            "title": "The design of the TAO real-time object request broker",
            "venue": "Comput. Commun. 21, 294\u2013324. doi:10.1016/s01403664(97)00165-5",
            "year": 1998
        },
        {
            "authors": [
                "T. Sch\u00f6pping",
                "S. Kenneweg"
            ],
            "title": "AMiRo-Apps",
            "venue": "Available at: https:// gitlab.ub.uni-bielefeld.de/AMiRo/AMiRo-Apps.",
            "year": 2022
        },
        {
            "authors": [
                "T. Sch\u00f6pping",
                "S. Kenneweg"
            ],
            "title": "\u03bcRT",
            "venue": "doi:10.4119/unibi/2966336",
            "year": 2022
        },
        {
            "authors": [
                "T. Sch\u00f6pping",
                "T. Korthals",
                "S. Herbrechtsmeier",
                "U. R\u00fcckert"
            ],
            "title": "AMiRo: A mini robot for scientific applications,",
            "venue": "in International Work-Conference on Artificial Neural Networks (Springer),",
            "year": 2015
        },
        {
            "authors": [
                "T. Sch\u00f6pping",
                "T. Korthals",
                "M. Hesse",
                "U. R\u00fcckert"
            ],
            "title": "AMiRo: Amini robot as versatile teaching platform,",
            "venue": "in International Conference on Robotics and Education RiE",
            "year": 2018
        },
        {
            "authors": [
                "M. Schulze"
            ],
            "title": "FAMOUSO\u2013Eine adaptierbare Publish/Subscribe Middleware f\u00fcr ressourcenbeschr\u00e4nkte Systeme",
            "venue": "Electron. Commun. EASST 17.",
            "year": 2009
        },
        {
            "authors": [
                "M. Schulze",
                "S. Zug"
            ],
            "title": "A middleware based framework for multi-robot development,\u201d in Proceedings of the 3rd",
            "venue": "IEEE European Conference on Smart Sensing and Context (EuroSSC), 29\u201331.",
            "year": 2008
        },
        {
            "authors": [
                "K.G. Shin",
                "P. Ramanathan"
            ],
            "title": "Real-time computing: A new discipline of computer science and engineering",
            "venue": "Proc. IEEE 82, 6\u201324. doi:10.1109/5. 259423",
            "year": 1994
        },
        {
            "authors": [
                "A. Stanford-Clark",
                "U. Hunkeler"
            ],
            "title": "MQ telemetry transport (MQTT)",
            "venue": "Available at: https://mqtt.org.",
            "year": 1999
        },
        {
            "authors": [
                "J.A. Stankovic"
            ],
            "title": "Misconceptions about real-time computing: A serious problem for next-generation systems",
            "venue": "Computer 21, 10\u201319. doi:10.1109/2.7053",
            "year": 1988
        },
        {
            "authors": [
                "H. Wei",
                "Z. Shao",
                "Z. Huang",
                "R. Chen",
                "Y. Guan",
                "J Tan"
            ],
            "title": "RT-ROS: A real-time ROS architecture on multi-core processors",
            "venue": "Future Gener. Comput. Syst",
            "year": 2016
        },
        {
            "authors": [
                "J. Wienke",
                "S. Wrede"
            ],
            "title": "A middleware for collaborative research in experimental robotics,",
            "venue": "IEEE/SICE International Symposium on System Integration (SII) (IEEE),",
            "year": 2011
        },
        {
            "authors": [
                "H. W\u00f6rn"
            ],
            "title": "Echtzeitsysteme: Grundlagen, funktionsweisen, anwendungen",
            "venue": "Springer-Verlag.",
            "year": 2006
        },
        {
            "authors": [
                "Z. Yang",
                "K. andDuddy"
            ],
            "title": "Corba: A platform for distributed object computing",
            "venue": "ACM SIGOPS Oper. Syst. Rev. 30,",
            "year": 1996
        },
        {
            "authors": [
                "R. Zurawski"
            ],
            "title": "Embedded systems handbook",
            "venue": "Boca Raton, FL: CRC Press.",
            "year": 2006
        }
    ],
    "sections": [
        {
            "text": "TYPE Technology and Code PUBLISHED 21 March 2023 DOI 10.3389/frobt.2023.1081875\nOPEN ACCESS\nEDITED BY Jose Luis Sanchez-Lopez, University of Luxembourg, Luxembourg\nREVIEWED BY Stefan Kowalewski, RWTH Aachen University, Germany Nico Hochgeschwender, Hochschule Bonn-Rhein-Sieg (H-BRS), Germany\n*CORRESPONDENCE Thomas Sch\u00f6pping, tschoepp@techfak.uni-bielefeld.de Marc Hesse, mhesse@techfak.uni-bielefeld.de\nSPECIALTY SECTION This article was submitted to Robotic Control Systems, a section of the journal Frontiers in Robotics and AI\nRECEIVED 27 October 2022 ACCEPTED 30 January 2023 PUBLISHED 21 March 2023\nCITATION Sch\u00f6pping T, Kenneweg S, Hesse M and R\u00fcckert U (2023), \u00b5RT: A lightweight real-time middleware with integrated validation of timing constraints. Front. Robot. AI 10:1081875. doi: 10.3389/frobt.2023.1081875\nCOPYRIGHT \u00a9 2023 Sch\u00f6pping, Kenneweg, Hesse and R\u00fcckert. This is an open-access article distributed under the terms of the Creative Commons Attribution License (CC BY). The use, distribution or reproduction in other forums is permitted, provided the original author(s) and the copyright owner(s) are credited and that the original publication in this journal is cited, in accordance with accepted academic practice. No use, distribution or reproduction is permitted which does not comply with these terms.\n\u00b5RT: A lightweight real-time middleware with integrated validation of timing constraints\nThomas Sch\u00f6pping*, Svenja Kenneweg, Marc Hesse* and Ulrich R\u00fcckert\nCognitronics and Sensor Systems Group, Faculty of Technology, Bielefeld University, Bielefeld, Germany\nMiddlewares are standard tools for modern software development in many areas, especially in robotics. Although such have become common for highlevel applications, there is little support for real-time systems and low-level control. Therefore, \u00b5RT provides a lightweight solution for resource-constrained embedded systems, such as microcontrollers. It features publish\u2013subscribe communication and remote procedure calls (RPCs) and can validate timing constraints at runtime. In contrast to other middlewares, \u00b5RT does not rely on specific transports for communication but can be used with any technology. Empirical results prove the small memory footprint, consistent temporal behavior, and predominantly linear scaling. The usability of \u00b5RT was found to be competitive with state-of-the-art solutions by means of a study.\nKEYWORDS\nmiddleware, real-time computing, distributed computing, embedded, microcontroller, publish\u2013subscribe, remote procedure call, prevention through design\n1 Introduction\nFor sophisticated software architectures, middlewares have become important tools to facilitate modular systems, which\u2014despite their complexity\u2014are easy to maintain and can be extended with minimal effort. Although numerous solutions have been developed in the last decades, only a few consider real-time computing. Regarding robotic systems, which interact with their environment on a physical level, this paradigm of computer science is inevitable, though, as it is a vital requirement for safe operation. In contrast to other domains that require real-time processing, modern robotic platforms need high modularity and complete determinism regarding execution and reaction times to be adaptable and extensible but also safe (Stankovic, 1988; Shin and Ramanathan, 1994; Oshana, 2006; W\u00f6rn, 2006; Zurawski, 2006; Jahn, 2021).\nThe novel middleware presented in this work has its roots in just this challenge to combine both worlds in a single system. When working with the AMiRo platform (Herbrechtsmeier\u00a0et\u00a0al., 2016; Herbrechtsmeier, 2017), which features a heterogeneous, distributed real-time architecture, the application development became disproportionally difficult as complexity increased. The monolithic software design did not resemble the modular hardware, nor could it satisfy fundamental use cases for the robot. AMiRo features multiple microcontrollers (MCUs), which form a loosely coupled real-time system, but each of which is responsible for multiple tasks, such as power management, motor control, sensor fusion, wireless communication, and behavioral applications (Sch\u00f6pping\u00a0et\u00a0al., 2015; Sch\u00f6pping\u00a0et\u00a0al., 2018; Korthals\u00a0et\u00a0al., 2019; Sch\u00f6pping andKenneweg, 2022a; cf. Figure\u00a012).\nFrontiers in Robotics and AI 01 frontiersin.org\nBy introducing a communication middleware to the real-time level of the platform, these issues should be resolved, and several existing solutions have been evaluated. Unfortunately, none could satisfy all requirements, which eventually led to the decision to develop a completely new system: \u00b5RT (pronounced like \u201cMarty\u201d: [m\u00e1:rti]).\nBefore \u00b5RT is described in detail in section\u00a02, several types of existing middlewares and fundamental concepts are presented in this section (cf. sections\u00a01.1 and 1.2). In section\u00a03, \u00b5RT is evaluated thoroughly in three aspects: feature set (cf. section\u00a03.1), performance (cf. section\u00a03.2), and usability for software developers (cf. section\u00a03.3). The findings are briefly discussed in section\u00a04 before conclusions about \u00b5RT are drawn in section\u00a04.1, and future enhancements are proposed in section\u00a04.2."
        },
        {
            "heading": "1.1 Related work",
            "text": "Today, it is very common to usemiddlewares for communication in modular architectures. During the last decades, a great number of middlewares have been developed, with CORBA (Yang and Duddy, 1996), MQTT (Stanford-Clark and Hunkeler, 1999), and ROS (Quigley\u00a0et\u00a0al., 2009; Macenski\u00a0et\u00a0al., 2022) being some of the most popular ones. Using such tools has numerous advantages:\n\u2022 Compatible applications can be executed on any system that runs the according middleware, allowing for high code portability. \u2022 Existing software can be reused and integrated with minimal\neffort. \u2022 Realization of further applications is simplified due to uniform\ninterfaces and additional debugging and profiling tools most solutions provide, leading to high-quality code while minimizing development time.\nOne major issue with existing middlewares is that only very few consider real-time computing. Thus, most cannot be used for such use cases. There are exceptions to this rule, such as realtime CORBA (Fay-Wolfe\u00a0et\u00a0al., 2000), Orocos (Bruyninckx, 2001), R2P (Migliavacca, 2013; Matteucci\u00a0et\u00a0al., 2015; Migliavacca, 2016), and ROS 2 (Macenski\u00a0et\u00a0al., 2022), although those have other disadvantages. Notably, neither of the aforementioned solutions features actual validation of timing constraints at runtime. However, for large, potentially harmful, or even lethal platforms, the detection of real-time violations is a crucial requirement for safe operation. Even though static scheduling techniques exist to determine a valid task execution sequence and prevent timing violations at runtime, methods and solutions become much more complex for distributed systems and require a high level of control over individual components (Di\u00a0Natale and Stankovic, 2000; Zurawski, 2006)."
        },
        {
            "heading": "1.1.1 Real-time CORBA",
            "text": "Although CORBA is actually an open standard defined by the Object Management Group (OMG, 2021), it contains several design flaws, which are consequently inherited by all implementations, such as TAO (Schmidt\u00a0et\u00a0al., 1998), TAOX11 (Remedy\u00a0IT, 2019), or omniORB (Grisby, 2022). Due to its design by committee,\nit suffers from several issues regarding complexity, redundancy, and missing features (Henning, 2006). Because real-time CORBA is a modification of the original specification (OMG, 2005), it incorporates the same issues, rendering it a suboptimal solution. Especially when targeting resource-constrained platforms such as MCUs, the high complexity of CORBA inevitably results in high resource requirements, which such devices can rarely (and if so, just barely) satisfy. As a result, all implementations of newer versions of the CORBA specifications only support sophisticated operating systems, such as Linux or Windows, but are not designed to be deployed on MCUs."
        },
        {
            "heading": "1.1.2 Orocos",
            "text": "Originally developed by Bruyninckx (2001), the Orocos project is a collection of libraries and tools for the efficient development of robotics software, which is portable and has high runtime performance, with real-time support being one of its core aspects. Moreover, it can be combined with other middlewares if desired. For certain communication schemes, Orocos employs CORBA (cf. section\u00a01.1.1; optional for local, non-distributed setups), and it can also be integrated with ROS (Quigley\u00a0et\u00a0al., 2009) and ROS 2 (Macenski\u00a0et\u00a0al., 2022). However, Orocos is not designed to be deployed on MCUs and does not feature validation of timing constraints at runtime."
        },
        {
            "heading": "1.1.3 R2P",
            "text": "R2P has been developed by Migliavacca (2013) as an alternative to ROS (Quigley\u00a0et\u00a0al., 2009), LCM (Huang\u00a0et\u00a0al., 2010), and FAMOUSO (Schulze and Zug, 2008; Schulze, 2009) with improved support for hard real-time systems. It is focused to be used on MCUs, which communicate via a controller area network (CAN), specifically the RTCAN protocol (Migliavacca\u00a0et\u00a0al., 2013). As such, it seemed appropriate for the AMiRo platform at first glance, as it is also based on ChibiOS (di\u00a0Sirio, 2020, 2022), just like AMiRo-OS (Sch\u00f6pping\u00a0et\u00a0al., 2016), the real-time operating system (RTOS) of AMiRo. Unfortunately, R2P relies on dynamic memory allocation as it employs memory pools. Therefore, complete determinism cannot be guaranteed. Because the development of the project ceased in 2016, there was no support to implement the according modifications, and there is little detailed documentation about the project to be found."
        },
        {
            "heading": "1.1.4 ROS 2",
            "text": "The arguably most popular solution in robotics is ROS, which introduced real-time support with ROS 2 (Quigley, 2015; Macenski\u00a0et\u00a0al., 2022) and its extensions, micro-ROS (OSRF, 2022a) and RT-ROS (Wei\u00a0et\u00a0al., 2016; Faust, 2022), respectively. However, the overall performance of ROS 2 strongly depends on the utilized data distribution service (DDS; OMG, 2015) implementation (Maruyama\u00a0et\u00a0al., 2016). Regarding MCUs and micro-ROS, DDS for eXtremely Resource Constrained Environments (DDS-XRCE; OMG, 2019) must be employed, which specifies a centralized communication topology with multiple clients interacting with a single server\u2014an undesired architecture for distributed systems composed of equal participants. Because its popularity makes it the de facto standard solution in robotics, ROS 2 has been evaluated to a particular extent.\nFrontiers in Robotics and AI 02 frontiersin.org\nFIGURE 1 ROS 2 \u201cpendulum demo\u201d benchmark results. While the system1 was only running the \u201cpendulum demo\u201d for the left histogram (A), additional stress was put on the CPU for the right-hand results (B). Although the results presented by Kay and Tsouroukdissian (2015) are reproduced very well, logarithmic scaling of the frequency axis reveals a significant number of samples with high latency.\nAlthough the ROS ecosystem is generally very powerful, there are indications that the real-time capabilities of ROS 2 are still not optimal. First, Kay and Tsouroukdissian (2015) presented empirical results of the official ROS 2 demo application for real-time use cases \u201cpendulum demo,\u201d which were promising overall. However, they showed occasional latency spikes, especially when the CPU was put under load. Because these benchmarks are rather dated and real-time capabilities might have been optimized since, another set of benchmarks was conducted,1 which still confirms the limited suitability of ROS 2 for hard real-time applications. The results of these benchmarks are depicted in Figure\u00a01 and reveal two important findings.The histograms show the results of the same benchmarks as presented byKay andTsouroukdissian (2015), and the original result data is resembled verywell. However, no \u201coutliers\u201d were visible in the presentation due to the linear scaling of the frequency axis.When the CPU is put under load, these \u201coutliers\u201d become even more frequent and resemble a Gaussian distribution. This is problematic regarding real-time systems because latency is not limited by an upper bound. The issue becomes even more evident when considering the goal of a jitter of fewer than 30 \u00b5s (3% of 1\u00a0ms period), as defined by Kay andTsouroukdissian (2015). For the benchmarkwith additional CPU load, almost 25% of all data points violate that constraint. Although the cause for the worse performance, despite process priorities configured in favor of the \u201cpendulum demo\u201d (real-time vs. nice),may be rooted in theOS rather thanROS 2, there are obviously no mechanisms in place to limit execution times or at least notify about high latencies.\nFurther evidence of the limited real-time capabilities of ROS 2 can be found in the performance analyses by Maruyama\u00a0et\u00a0al. (2016). The data reveal that ROS 2 scales worse than linear in many\n1 CPU: Intel Core i7-7567U (2 cores) locked at 3.5\u00a0GHz and hyper-threading disabled; OS: Ubuntu 22.04 with real-time kernel (Linux 5.15.0\u20131016-realtime x86_64); ROS: \u201cHumble Hawksbill\u201d\nsituations. Hence, strict timing constraints become exponentially more difficult to meet when system complexity increases. The data also show strong latency variations, even exceeding 10% of the median for data sizes of 1\u00a0MB and more. Overall, the real-time capabilities of ROS 2 remain insufficient for scenarios where timing constraints are critical and must be respected and its high resource requirements render it unsuitable for MCUs without sacrificing decentralization."
        },
        {
            "heading": "1.2 Interaction concepts",
            "text": "When designing a new midleware, several alternate paradigms can be followed. Eugster\u00a0et\u00a0al. (2003) gave a comprehensive overview, and the most important concepts are summarized as follows."
        },
        {
            "heading": "1.2.1 Decoupling",
            "text": "One of the most important characteristics of any distributed communication framework is decoupling. Participants can be coupled in three domains, all of which should be omitted:\n\u2022 space: If participants must know each other in order to exchange information, they are coupled in space. \u2022 time: In case producers and consumers both have to be active\nand connected when data is transmitted, they are coupled in time. \u2022 synchronization: For systems coupled in this domain,\nexecution is blocked when sending or receiving data."
        },
        {
            "heading": "1.2.2 Interaction",
            "text": "Furthermore, Eugster\u00a0et\u00a0al. (2003) described six fundamental concepts of interaction and how communication between participants is realized. The publish\u2013subscribe paradigm eventually achieves decoupling in all three domains and thus is the most\nFrontiers in Robotics and AI 03 frontiersin.org\npowerful technique in this regard. Another very popular concept is remote procedure calls (RPCs), tightly coupled according to Eugster\u00a0et\u00a0al. (2003), but allowing for \u201cpulling\u201d communication, whereas information can only be \u201cpushed\u201d with publish\u2013subscribe. Fortunately, the coupling can be relaxed by an extension of RPC, called \u201cfuture\u201d (Ananda\u00a0et\u00a0al., 1992) or \u201cwait-by-necessity\u201d (Caromel, 1993; cf. Eugster\u00a0et\u00a0al., 2003)."
        },
        {
            "heading": "1.2.3 Addressing",
            "text": "In order to establish communication between producers and consumers in a decoupled manner, addressing information needs to be abstracted. There are several approaches to how this can be realized (Eugster\u00a0et\u00a0al., 2003).\n\u2022 topic/service-based: Producers provide information via a certain topic or service, usually identified by a name. Consumers can declare interest in specific information by such identifiers and will eventually receive all data provided via the according topic/service. \u2022 content-based: Consumers can define a set of rules (or filters)\non whether they will receive new data. Only if the content of a message meets these rules, it (the message) is delivered to the consumer. \u2022 type-based: When a producer emits a message with a complex\ndata type as payload, a consumer might be interested but in a subset of that data. Hence, only this part of the original message is delivered to that specific consumer.\nHybrid techniques are also possible, such as the scope-based approach of Robotics Service Bus (RSB) (Wienke and Wrede, 2011). It employs a URI format for scope names, introducing a hierarchy and filtering capabilities without defining any requirements on the actual information payload."
        },
        {
            "heading": "1.2.4 Quality of Service",
            "text": "Quality of service (QoS) is typically used to track information such as latencies and the number of delivered and discarded messages. However, timing constraints are of major importance to guarantee system stability and safety regarding real-time systems. Therefore, the according mechanisms can prioritize important communication and preempt others. Furthermore, the system can be monitored to detect critical failures (i.e., timing violations) as soon as possible and initiate an appropriate reaction. Hence, when timing constraints are not met, temporal behavior tracking and execution of defined routines are also part of QoS in the nomenclature of this work.\n2 \u00b5RT\nAlthough the original motivation for the development of a new middleware was the modularization of the software running on the MCUs of AMiRo (Herbrechtsmeier\u00a0et\u00a0al., 2016; Herbrechtsmeier, 2017), several additional goals were specified to make the resulting system applicable for a wide range of other devices with very strict real-time requirements:\n1. Memory footprint small enough for mainstream and ultra-lowpower MCUs. 2. Throughout real-time capability per completely deterministic and very consistent behavior at runtime. 3. At most linear scaling with increasing system complexity (e.g., number of participants). 4. Validation of timing constraints at runtime. 5. Support of periodic/time-based and event-based communication\nschemes. 6. Easy-to-use interfaces that help developers create correct and\nefficient code. 7. Interoperability with existing middleware. 8. High configurability to adapt the system to any specific use case.\nThe proposed solution to that challenge\u2014\u00b5RT\u2014is an entirely event-based system, featuring a lowmemory footprint, full real-time capabilities, and built-in validation of timing constraints at runtime. It features a topic-based publish\u2013subscribe architecture and future RPCs (cf. section\u00a01.2). It is implemented2 in C (Sch\u00f6pping and Kenneweg, 2022a) and declares all interface functions to external components by its operating system abstraction layer (OSAL), as described in section\u00a02.4. The implementation is highly configurable at compile time through a comprehensive set of feature flags, which allow disabling entire subsystems (e.g., publish\u2013subscribe or RPC) to reduce memory footprint and improve performance. An overview of the \u00b5RT architecture is depicted in Figure\u00a02. Before the several components are described in detail in sections\u00a02.5\u20132.7, some basic concepts about its realtime classes and constraints and the fundamental approach of \u00b5RT are presented in sections\u00a02.1\u20132.3. Finally, the interface-agnostic approach to interacting with other components (e.g., foreign middlewares) in sophisticated, complex systems is described in section\u00a02.8."
        },
        {
            "heading": "2.1 Types of constraints",
            "text": "\u00b5RT defines three types of timing constraints: latency, synchronicity, and rate. If a constraint is met, its validation function results to 1, whereas a value of 0 indicates a timing violation."
        },
        {
            "heading": "2.1.1 Latency",
            "text": "Often referred to as \u201cdeadline,\u201d a maximum expected latency \u03c4 for information propagation can be specified. It is defined as a function l(\u03c4,\u0394t) with \u0394t the duration of an operation so far:\nl (\u03c4,\u0394t) = {{ {{ { 1, if \u0394t \u2264 \u03c4 0, otherwise (1)"
        },
        {
            "heading": "2.1.2 Synchronicity",
            "text": "For periodic tasks, it is often required that all iterations take similarly long and execution time varies as little as possible. For realtime systems, this \u201cjitter\u201d must be limited by an upper bound \u03b4. By\n2 https://gitlab.ub.uni-bielefeld.de/AMiRo/uRtWare; licensed under LGPL 3\nFrontiers in Robotics and AI 04 frontiersin.org\nFIGURE 2 \u00b5RT architecture overview. While the thread type is defined by the underlying operating system via OSAL and payload are individual types for each topic and request, all other components are specified by \u00b5RT.\ntracking theminimum andmaximum iteration times (tmin and tmax) during system operation, the validity of the synchronicity constraint s(\u03b4, tmin, tmax) can be calculated by\ns(\u03b4, tmin, tmax) = {{ {{ { 1, if tmax \u2212 tmin \u2264 \u03b4 0, otherwise (2)"
        },
        {
            "heading": "2.1.3 Rate",
            "text": "Although this constraint is not considered at all bymost authors, it is crucial to detect the complete failure of individual components in an event-driven system at runtime. If a data source does not provide any further information, no data processing pipeline will be triggered, and neither latency nor synchronicity constraints will ever be violated. A possible solution to this challenge is the implementation of a dead man\u2019s switch, which is monitored and checked for regular activation by another component. Alternatively, rate constraints can be validated without the need for a dedicated monitor by introducing a maximum period \u03f5 between subsequent data points and comparison of the current time t and the time of the latest data point ti\u22121:\nr(\u03f5, ti\u22121, t) = {{ {{ { 1, if t\u2212 ti\u22121 \u2264 \u03f5 0, otherwise (3)"
        },
        {
            "heading": "2.2 Real-time classes",
            "text": "\u00b5RT distinguishes four classes of real time: hard, firm, soft, and non-real-time. Most authors consider only two classes\u2014hard and soft\u2014because the other definitions are special cases of the latter (Oshana, 2006; W\u00f6rn, 2006). However, from an implementation point of view, it makes sense to consider all four cases. The common ground for all classes is that usefulness u \u2208 [0,1] is calculated so that the major differences are further restrictions in the mapping functions and interpretation of u."
        },
        {
            "heading": "2.2.1 Non-real-time (NRT)",
            "text": "This trivial class has no real-time constraints at all. As a result, u = 1 always holds."
        },
        {
            "heading": "2.2.2 Soft real-time (SRT)",
            "text": "As the most general class, the mapping \u0394t\u21a6 u can be of any form for SRT. Each component may define an individual mapping function to calculateu in order to assess the quality of eachdata point during operation. While monotonic decreasing functions are most common, partial functions can be used to model desired temporal frames (i.e., to represent jitter constraints). Most notably, the NRT and FRT classes are, in fact, special cases of SRT."
        },
        {
            "heading": "2.2.3 Firm real-time (FRT)",
            "text": "This class further restricts u to be either 1 or 0 (\u201cvalid\u201d or \u201cinvalid\u201d). Such a distinction makes sense from an implementation perspective for two reasons. Calculations and representations do not require \u201csophisticated\u201d data types, such as float. Because many MCUs do not feature an FPU (floating-point unit), emulation of such types is computationally expensive and may result in temporal inconsistency. Furthermore, this allows for a general calculation of u, depending on constraints for latency, synchronicity, and rate:\nu = l (\u03c4,\u0394t) \u22c5 s(\u03b4, tmin, tmax) \u22c5 r(\u03f5, ti\u22121, t) (4)\nNote that each factor can be \u201cdeactivated\u201d by setting its parameter (\u03c4, \u03b4, or \u03f5, respectively) to\u221e."
        },
        {
            "heading": "2.2.4 Hard real-time (HRT)",
            "text": "Similar to FRT, the usefulness u is interpreted more strictly for this class. Violations of hard real-time constraints (u = 0) are considered severe incidents. The system is assumed to be in an undefined state. It may even be dangerous to itself and its environment. Such events must be detected and handled as quickly as possible to restore a stable situation and prevent any harm. This detection of violations is a key feature of \u00b5RT and is implemented using timers, which will trigger either a recovery attempt (can be defined for each component individually) or a systempanic (systemwide default) exactly when a violation occurs.\nFurthermore, \u00b5RT forbids HRT transmissions to be \u201coverwritten,\u201d which might result in the loss of a vital data point. As a result, further communication may be blocked as long as one\nFrontiers in Robotics and AI 05 frontiersin.org\nor more HRT consumers have not processed previous messages yet (cf. section\u00a02.6)."
        },
        {
            "heading": "2.3 Design concepts",
            "text": "Now that the fundamental definitions of constraints and real-time classes have been presented, several particularities remain about how \u00b5RT achieves its real-time characteristics. Most importantly, \u00b5RT uses a sophisticated approach to track communication timestamps to detect violations of real-time constraints, which is detailed in section\u00a02.3.2."
        },
        {
            "heading": "2.3.1 Event-driven system design",
            "text": "\u00b5RT fully embraces the paradigm of event-driven architectures and avoids any periodic polling. This ensures that all events are handled as soon as possible with minimal latency and task prioritization and preemption are left to the scheduler of the underlying RTOS. Due to the absence of periodic \u201csynchronization points,\u201d jitter may increase, though, if the runtime complexity of some components varies greatly during operation. However, realtime software, in general, should be designed to exhibit consistent processing time in the first place. As a result, systems using \u00b5RT are more sensitive to bad implementations (concerning real-time characteristics), so developers will be encouraged to optimize such a code. Nevertheless, periodic execution of tasks with a given frequency remains desired in many situations, such as reading sensor data. With \u00b5RT, such behavior can be realized by means of periodic timers, which regularly fire with a specified frequency and emit events that eventually trigger task execution. This method is more elaborate as it involves an additional component (the timer) to achieve the time-triggered operation of the event-driven system, but that is actually intended. Because event-triggered task execution should be preferred in most situations, \u00b5RT deliberately encourages developers to follow this software design paradigm."
        },
        {
            "heading": "2.3.2 Validation of timing constraints",
            "text": "Another important aspect of \u00b5RT is its approach to tracking latencies and validation of timing constraints at runtime, which are not defined per data point (e.g., sensor data have to be processed within a certain time frame), but by individual participants in the system (e.g., information must be received before it is older than \u03c4). This approach effectively results in usability values per data point and consumer, so each participant can define and validate its individual timing constraints independently. Especially if additional stages are added to a data processing pipeline, making it more expensive regarding computation time, constraints of later stages remain valid and require no adjustment.\nA crucial detail for this approach to work is correct tracking of the origin times of information, which is not the same as when the data are being transmitted within a system. While that data contains information, the latter emerges as soon as an event or state is observed and not only when it is encoded into some form of data structure, such that\ntinfo \u2264 tdata (5)\nholds. This definition is particularly important with regard to data processing pipelines, in which multiple components are arranged\nin a chain. After each stage in that pipeline, data is transmitted to the following component, and tdata,i increases continuously, whereas tinfo,i remains unchanged.3 The benefits of this approach become obvious when analyzing the opposite case. If each component k \u2208 {2,\u2026,n} in a data processing pipeline of length n would define its own relative deadline \u03c4k > 0 regarding its preceding stage, the overall deadline of the entire pipeline \u03c4\u2032 would be defined by\n\u03c4\u2032 \u2264 n\n\u2211 k=2 \u03c4k (6)\nThe edge case of an equilibrium would only occur if all components fully exhaust their time budget: \u0394tk = \u03c4k\u2200k. As soon as any component requires less time (\u0394tk < \u03c4k), the overall time budget \u03c4\u2032 is also reduced by that difference: \u03c4\u2032 \u2190 \u03c4\u2032 \u2212 (\u03c4k \u2212\u0394tk). As a result, pipelines might miss \u03c4\u2032 because individual components are too fast, or all \u03c4k need to be increased to compensate for this effect, resulting in an overly optimistic initial value of \u03c4\u2032, which is no longer related to the actual use case. By referencing all timing constraints to the absolute origin time of information tinfo, the constraints of the entire pipeline are defined exactly by the last component, and each previous component defines the timing constraints of the pipeline up to that stage.\n\u00b5RT specifies an information time tinfo,i per data point i and validation of all timing constraints always refer to this value. For latency constraints, the point in time tl,i at which the deadline \u03c4 is missed is hence defined by\ntl,i = tinfo,i + \u03c4 (7)\nand \u00b5RT can thus arm a timer to trigger as soon as tl,i has elapsed, indicating a timing violation.The two critical times for synchronicity constraints, tsmin,i and tsmax,i, are likewise defined by\ntsmin,i = tmax \u2212 \u03b4 and (8) tsmax,i = tmin + \u03b4 (9)\nWhile tsmax,i is validated by means of a timer as well (actually only a single timer is required for latency and synchronicity validation; cf. Equation\u00a012; sections\u00a02.6 and 2.7), tsmin,i is checked whenever data is retrieved by the consumer. If it was fetched too early, a timing violation has occurred. Regarding the rate, only the most critical constraint \u03f5\u2032 among all n consumers of a data source needs to be considered for the definition of the critical time tr,i+1:\ntr,i+1 = tinfo,i + \u03f5\u2032 with (10)\n\u03f5\u2032 =min({\u03f51,\u2026, \u03f5n}) (11)\nHence, validation of \u03f5\u2032 is not performed every time data is fetched by a consumer, but only when it is provided by the producer. Therefore, rate validation does not require another timer for each consumer but only one per producer (at most; cf. section\u00a02.6).\nDue to these mechanics, some possible side effects should be kept in mind when working with \u00b5RT. When data is provided by a producer, the contained information might already violate the latency or synchronicity constraints of consumers:\ntdata,i >min(tl,i, tsmax,i) (12)\n3 Modification of tinfo,i is possible if desired\nFrontiers in Robotics and AI 06 frontiersin.org\nA similar effect occurs whenever the difference between tinfo,i and tdata,i exceeds a rate constraint:\ntdata,i \u2212 tinfo,i > \u03f5\u2032 \u21d4tdata,i > tinfo,i + \u03f5\u2032\n\u21d4tdata,i > tr,i+1 (13)\nAs a result, a timing violation is detected as soon as the data is committed. Strictly speaking, this is already too late because, in both cases, the critical point in time has already elapsed. For \u00b5RT\u2019s validation mechanisms, there is obviously no way of knowing about such data before it exists. Although detection of timing violations might be delayed in such situations, \u00b5RT still acts as quickly as possible.\nThere is yet another possible edge case that should be considered when specifying the rate constraints of consumers. Because of Equation\u00a05, \u00b5RT might detect a rate violation, although future data would provide valid information:\ntinfo,i+1 < tr,i+1 < tdata,i+1 (14)\nTherefore, rate checks in \u00b5RT are rather conservative, and constraints \u03f5 should be specified with this in mind.\nFinally, a last particularity of \u00b5RT\u2019s timing validation mechanics is worth pointing out. As already mentioned, all constraints are defined by consumers, so in a sequential data processing pipeline, there are two steps for which no constraints can be defined: the observation, which initiates the pipeline, and the ultimate action at its end. In the former case, latency and jitter do not apply, and the rate can be validated by the subsequent component. However, for the latter case, the timing of the final action can only be validated by yet another consumer. The component that executes the action needs to provide information to confirm that the action has been conducted, and the additional component\u2014also calledmonitor\u2014consumes this information and validates its real-time behavior. While the use of such monitors seems complicated and inefficient at first glance, a single component can monitor all pipelines in a system, resulting in only minimal overhead."
        },
        {
            "heading": "2.3.3 Concurrency and mutual exclusion",
            "text": "For control of concurrent access to shared data structures, \u00b5RT relies on mutex locks and condition variables. Although lockfree methods are generally to be preferred for real-time systems (Anderson\u00a0et\u00a0al., 1997), they are difficult to realize for many aspects of \u00b5RT, in particular without the C concurrency support library (stdatomic.h), which was only introduced with C11 (ISO, 2011) and would make \u00b5RT unusable for projects that do not support this version of the C standard. Especially in the context of MCUs, more conservative standards are often preferred (even Linux was only recently lifted to C11 from C89; Torvalds\u00a0et\u00a0al., 2022). Conversely, most MCUs feature only a single core anyway, such that the benefits of a lock-free implementation are rather limited."
        },
        {
            "heading": "2.3.4 Configurability",
            "text": "In order to adapt \u00b5RT to the specific requirements of individual use cases, multiple feature flags and settings are provided to configure the implementation at compile time. First and foremost, the three subsystems\u2014synchronization, publish\u2013subscribe, and\nRPC (cf. Figure\u00a02)\u2014can each be enabled or disabled as required, and another global flag selects between debug and release builds. These settings are particularly useful if code size needs to be reduced to reduce ROM utilization. Selecting a release build also disables many sanity checks and improves performance tremendously.\nThere are several more settings regarding the two communication subsystems. On the one hand, tracking of profiling information can be enabled or disabled for each of the two subsystems. While such information can help track down bottlenecks, the logic obviously requires additional resources in ROM, RAM, and CPU time. On the other hand, the validation of timing constraints can be enabled or disabled as required via a total of five flags; for publish\u2013subscribe validation of latency, synchronicity and rate constraints can be selected individually, and the same applies for latency and synchronicity constraints for RPC interaction. Even with all validation logic disabled, \u00b5RT still distinguishes the four real-time classes (cf. section\u00a02.2), which is a perfectly legitimate use case. Once again, disabling these components saves resources in all three domains.\nFurther settings allow fine-tuning \u00b5RT even further by setting the sizes (i.e., number of bits) for several frequently used data types, such as temporal delays4 and identifiers for topics and services (cf. sections\u00a02.6 and 2.7). There are also flags to select alternative algorithms for selected components of \u00b5RT, although these are not recommended for most scenarios and therefore are not discussed in this work. Finally, more settings allow configuring and interfacing OSAL, the abstraction layer for interaction with the operating system (cf. section\u00a02.4)."
        },
        {
            "heading": "2.4 Operating system abstraction layer",
            "text": "\u00b5RT defines its own abstraction layer to interface the underlying OS and event system. For applications using this middleware, it is recommended to stick to this API as well to ensure portability. The following features must be made available to \u00b5RT by mapping the according functions to OSAL.\n\u2022 unique timestamps: Hardware timers in many MCUs feature only limited ranges (i.e., 16 or 32 bits) and tend to overflow frequently when setting the frequency to high values (e.g., 1\u00a0MHz). By definition, \u00b5RT uses timestamps at 1 \u00b5s resolution and requires the RTOS to provide an according accumulated system time or map a lower resolution time to \u00b5s equivalents. \u2022 mutex locks and condition variables: Concurrent access\nto several components of \u00b5RT is prevented via mutex locks. Condition variables are used to inform nodes asynchronously about released locks. \u2022 timers: \u00b5RT makes extensive use of timers to detect timing\nviolations. Preferably the RTOS uses actual hardware timers so that violations result in the execution of an interrupt service routine (ISR) and according reactions are triggered as soon as possible.\n4 While timestamps are defined by \u00b5RT to be 64-bit wide, delays may be represented by a smaller type\nFrontiers in Robotics and AI 07 frontiersin.org\n\u2022 threads: OSAL defines a set of functions to control thread execution. Although thread handling may differ significantly between individual RTOSes, only very common functions are required by \u00b5RT. \u2022 event system: \u00b5RT does not implement its own event system\nbut relies on an externally provided implementation. Such can be part of the RTOS (as is the case for ChibiOS; di\u00a0Sirio, 2020, 2022), or another system can bemapped toOSAL. \u00b5RT requires events to be emitted via broadcasts, and threads can be signaled individually. \u2022 output: In order to printmessages to output and error streams,\nthe according functions must be provided. While in most cases, these will be aliases to the standard C function fprintf(), there are exceptions where this is not available (as is the case with AMiRo-OS). \u2022 assert: When built with debug flags enabled, \u00b5RT performs\nmany sanity checks in the form of assertions. As with the output functions, the OSAL assertion can be mapped directly to the standard C assert(). When further code (e.g., to stop a motor) shall be executed, such can be easily induced at this point."
        },
        {
            "heading": "2.5 Core components",
            "text": "As shown in Figure\u00a02, the fundamental components of \u00b5RT comprise the core and nodes as well as an optional mechanism to synchronize nodes. As a central entity, the core is a static data structure, which exists exactly once and is globally available within a \u00b5RT context. It holds lists of all nodes, topics, and services and offers methods to control execution flow on a top level.\nNodes define the interface for the actual participants in the system. Each node is executed in its individual thread but may control further threads. The main() function for each node thread is part of the \u00b5RT implementation and subdivides the lifespan of each node into three phases, each of which can be interfaced via a custom callback function.\n1. startup: This initialization phase is individual to each node. Before execution proceeds to the next stage, all nodes are synchronized by the core. 2. operation: Since \u00b5RT follows a strictly event-based approach, actions will only be performed if the node thread is triggered by some event source. Such triggers can be anything (e.g., communication, timers, or hardware interrupts) and are fully customizable. The only mandatory event belongs to the core in case of a shutdown request or a system panic. 3. shutdown: As soon as a node is requested to stop, it enters this final phase. The reason for the shutdown is propagated to all nodes, so appropriate actions can be executed.\nIn many situations, it is useful to synchronize multiple threads. This behavior is not trivial to realize by events only as each involved thread would require information about the others, resulting in a violation of the decoupling requirements (cf. section\u00a01.2.1). To this end, \u00b5RT features syncgroups that can hold an arbitrary number\nof syncnodes5 to be synchronized. Each thread that has joined a syncgroup can call a non-blocking synchronize() method at some point in time. If the result of that function call indicates that some syncnodes of the syncgroup have not synchronized yet, the calling thread has to wait for a synchronization event. As soon as the final syncnode executes that method, this event is emitted to the entire syncgroup, except for the calling thread, which receives an according return value. For use caseswhere the \u00b5RT synchronization mechanism is not desired, it can be disabled entirely via a feature flag. If a system comprises multiple \u00b5RT contexts (cf. section\u00a02.8), these mechanics can also be employed to synchronize all nodes in the entire system.This is done once by default tomake all nodes enter the operation phase simultaneously."
        },
        {
            "heading": "2.6 Publish\u2013subscribe",
            "text": "For unidirectional communication, publishers provide information anonymously through topics, which act as mediators and inform all registered subscribers (cf. Figure\u00a03). In order to retrieve a topic by its identifier (\u00b5RT uses no strings but numerical values to identify topics), the core provides the according methods to search among all available topics.6 While publishers are registered to a topic at initialization, subscribers can subscribe and unsubscribe dynamically during operation. Every topic holds one or more messages in a ring buffer, each of which holds a custom payload structure to carry data. This buffer is implemented as a distributed list instead of a contiguous array. Therefore, further elements can be added by any component at any point in time.\nThe timestamp of each message is of major importance. As described in section\u00a02.3.2, it does not describe the point in time when the message was published (tdata), but the origin time of the contained information (tinfo). Due to this differentiation, themessage buffer of each topic is not ordered by tdata but by tinfo, so that the latest element in the buffer will always be themessage with the latest information. Conversely, when a new message that carries older information is published, it is not appended but rather enqueued according to its tinfo value.\nWhenever information is published, several steps are executed by \u00b5RT:\n1. The publisher requests a message from the topic. If no message is available due to pending HRT subscribers (cf. section\u00a02.2) or if the oldest element in the buffer already holds more recent information, the publish attempt fails. Otherwise, the metadata of the message, such as information time, is updated, and payload data is copied to its buffer. After that, the message is enqueued again in the topic\u2019s buffer, according to its tinfo. 2. Metadata at the topic is updated. If the published message is the latest one in the buffer, the topic\u2019s rate timer is re-armed according to the timestamp of the new message and the most critical rate constraint among all registeredHRT subscribers \u03f5\u2032. Each topic also holds a list of all registered HRT subscribers, so their timers to\n5 Although it is recommended to synchronize nodes, the implementation actually works on a thread level\n6 Retrieval of a topic by its identifier has linear runtime complexity: O(#topics)\nFrontiers in Robotics and AI 08 frontiersin.org\nFIGURE 3 Visualization of a publish\u2013subscribe interaction in \u00b5RT. Information is provided by an arbitrary number of publishers and passed via a topic to an arbitrary number of subscribers ( ). represent aggregations (i.e., pointers in C). Data are buffered by the topic in a ring buffer of messages of arbitrary size \u22651. Each message holds a counter of remaining HRT subscribers, so the topic will only reuse a message if its counter is 0. While each subscriber class holds different members, all track the last message consumed. HRT subscribers are also arranged in a list, starting at the topic and ordered by their rate constraints. In the depicted situation, only one more message can be published before the upper HRT subscriber has to fetch the lowermost message.\ndetect latency or jitter violations are updated as well. Finally, an event is emitted to inform all registered subscribers about the new message. 3. A registered subscriber can fetch the next message from the buffer and copy its payload. In case multiple messages have been published since the last iteration of this subscriber, those can either be fetched subsequently, or the subscriber can fetch the latest message directly. For HRT subscribers, the timer is updated or deactivated if there are no further pending messages. SRT\nsubscribers and FRT subscribers can calculate the usefulness u of the fetched message (cf. section\u00a02.2).\nEach HRT subscriber only needs to validate latency and synchronicity constraints individually, whereas rate constraints are validated by the topic for all registered HRT subscribers.\nThe described approach completely omits dynamic memory allocation, as all buffers are static. While this is beneficial for temporal consistency, each information transfer requires the\nFrontiers in Robotics and AI 09 frontiersin.org\nFIGURE 4 Visualization of an RPC interaction in \u00b5RT. Information is passed from request to service on submission and vice versa on response ( ). represent aggregations (i.e., pointers in C). An arbitrary number of requests may be submitted to a service, which buffers those in a queue, ordered by real-time class and constraints. The servicing thread dispatches one request at a time from the front of that queue, processes it, and returns a response (by reusing the original request instance). In the depicted situation, four requests are already enqueued at the service, whereas another HRT request is available but currently not in use.\ndata to be copied two times. First, the publisher writes to the message payload. Second, each subscriber has to copy that buffer when fetching the message. Although this will have a significant performance impact for increasing amounts of data, this approach optimizes \u00b5RT for determinism and predictability. Computational complexity scales linearly with the number ofmessages in the buffer m, the payload p, and the number ofHRT subscribers sHRT registered to the topic:\nO (\u03b1 \u22c5m+ \u03b2 \u22c5 2p+ \u03b3 \u22c5 sHRT) (15)\nThe weight factors \u03b1, \u03b2, and \u03b3 are unknown but will be relevant for performance evaluation in section\u00a03.2.2. Finally, producers and consumers are decoupled in space, time, and synchronization."
        },
        {
            "heading": "2.7 Remote procedure calls",
            "text": "The basic idea of RPCs is to trigger an action similar to a local function call but remotely at another component in the system architecture. Although this behavior can be achieved via publish\u2013subscribe using a \u201crequest topic\u201d and another \u201cresponse topic,\u201d this approach is inefficient because two m-to-n communication channels are used to emulate a single 1-to-1 interaction, and services would have no priority information\nabout requests. Therefore, the RPC subsystem of \u00b5RT implements request queues at the service, which are ordered by real-time class and timing constraints (cf. Figure\u00a04). Like topics, services are identified by numerical values and can be retrieved via the core.7 \u00b5RT employs a combination of locking and ownership mechanics to acquire requests and pass thembetween requesting and servicing threads. Each interaction is again subdivided into several steps:\n1. A request must be acquired to be used for only one RPC interaction at a time. After a successful acquisition, the request is \u201clocked\u201d and \u201cowned\u201d by the requesting thread. Similar to publish\u2013subscribe, metadata is updated and argument data is copied to the payload buffer. 2. The request is submitted to the service, and an event is specified to inform the requesting thread of completion. As part of the submission procedure, ownership is handed over to the service, and the request is enqueued at the service according to its real-time class and constraints. Eventually, the thread providing the service is informed via an event.\n7 Retrieval of a service by its identifier has linear runtime complexity: O(#services)\nFrontiers in Robotics and AI 10 frontiersin.org\n3. The servicing thread dispatches one request at a time from the service\u2019s queue, thereby copying argument data and releasing its locked state. 4. As soon as the service is done, it tries to re-acquire the dispatched request.On success, it is locked again, any return values are copied to its payload buffer, and the requesting thread is informed via the previously specified event. 5. The requesting thread can retrieve the request and take over ownership again. For SRT requests and FRT requests, the usefulness u can be calculated at this point (cf. section\u00a02.2). 6. As soon as all return data has been processed or copied, the request has to be released to finalize the interaction. Afterward, the request is unlocked and not owned by anyone anymore and hence is available again for further interactions.\nThe interplay of locking and ownership mechanisms plays a key role in this procedure. In contrast to messages, requests are not associated with a service for the lifetime of the latter but only during an ongoing interaction. This allows using a single request for interaction with multiple services. The downside of this approach is that a request could \u201cget stuck\u201d in the queue of a service, not being served for a long time and thus not being available for other, potentially more important interactions, which might compromise the responsiveness of a system and hence its real-time capability. In order to solve this issue, the twomechanics have been employed, and the following rules apply for handling requests.\n\u2022 A request is available if it has no owner and is not locked. \u2022 A service may only act on a request if it is locked and owned by\nthe service. \u2022 The requesting thread may retrieve a previously submitted request at any time, as long as it is not locked (by the service).\nAs a result, a submitted request can be aborted anytime and reused if needed. Although the servicing thread is not notified about this termination and will keep processing an already dispatched request, re-acquisition to return a response will fail. Because the canceled request might be used for the same service again and services cannot distinguish whether a request has already been dispatched or was just submitted but not dispatched yet, just checking ownership and lock state does not suffice. Therefore, the request\u2019s submission time is saved on dispatch and used for comparison during re-acquisition before returning a response. If the timestamps do not match, re-acquisition fails, results are discarded, and no response event is emitted. However, it is often the case that neither return data nor a notification on completion is desired by the requesting thread in the first place. To this end, requests can be flagged as \u201cfire-and-forget\u201d by not specifying a response event on submission.\nIn contrast to the publish\u2013subscribe interaction, there are no rate constraints for RPCs, so each HRT request validates its individual latency and synchronicity constraints by itself. Moreover, the timestamp each request holds describes the time when it was submitted to the service and is not related to the content of the payload as was the case for messages, so tinfo = tdata always holds. The rationale behind these design choices is that RPCs should not be used for periodic communication within data processing pipelines but rather for sporadic or regular events to interact with\nsuch pipelines (cf. Figure\u00a012). As mentioned previously, the request queue of each service is ordered and therefore subdivided into three parts.HRT requests are always inserted in the front part of the queue, ordered by their timing constraints, such that the most critical HRT request is served first. FRT and SRT requests are placed in themiddle part of the queue, following the \u201cfirst come, first serve\u201d principle.The same applies toNRT requests, which are always appended at the very end of the queue.\nOnce again, all involved data structures are static, and no dynamic memory allocation is required. As with publish\u2013subscribe, the downside is multiple copy operations. However, this approach allows all involved threads to be responsive to other events at all times and thus prevents stalling (i.e., deadlocks) by design. Computational complexity scales linearly with the queue length q, the payload p, and the number of enqueued HRT requests rHRT:\nO (\u03b1 \u22c5 q+ \u03b2 \u22c5 4p+ \u03b3 \u22c5 (rHRT \u2212 1)) (16)\nAs with publish\u2013subscribe, the weight factors \u03b1, \u03b2, and \u03b3 are unknown. rHRT is reduced by 1 because the case to \u201cenqueue\u201d a singleHRT request is trivial, so this term is only relevant for rHRT > 1. Requesting and servicing threads are decoupled in space, time, and synchronization."
        },
        {
            "heading": "2.8 Platform-level interaction",
            "text": "All concepts of \u00b5RT so far only apply locally within a single process. On the one hand, this approach allows for fast information transfer via shared memory and simplifies several aspects, as details such as endianness and (de)serialization of data are of no concern. Especially in the context of MCUs, this is sufficient because many RTOSes do not feature strictly separated processes, and most MCUs do not even host an MPU (memory protection unit), which is fundamentally required to (efficiently) facilitate separated regions in memory.On the other hand, network communication is essential for modular systems and thus has to be considered.Themajor challenge in this regard is the vast variety of transports (e.g., Ethernet, SPI, UART, CAN, or FlexRay); protocols (e.g., TCP for Ethernet or TTCAN for CAN); and higher-level data distribution services (DDS). Hence, many solutions, such as ROS, ROS 2, MQTT, and RSB, only support selected interfaces (Stanford-Clark andHunkeler, 1999; Quigley\u00a0et\u00a0al., 2009; Wienke and Wrede, 2011; OSRF, 2020; OSRF, 2022b) and may have even further restrictions (e.g., DDSes supported by ROS 2).\n\u00b5RT approaches this challenge by not supporting any transport out-of-the-box but commits these tasks to bridge nodes. Such nodes can implement any transport and protocol and even filter messages if bandwidth is too limited to communicate all information. This method allows for integrating \u00b5RT in existing platforms, which already employ othermiddlewares, as depicted inFigure\u00a05, and even further transports can also be supported.\nThere are two reasons for this design choice. First, several established solutions are available, and there is no need to develop yet another one. Instead, \u00b5RT aims to be used alongside traditional middlewares to enable the modularization of the real-time software of a system. Second, while TCP and UDP have been established as the de facto standard protocols for most communication in modern applications, there is no common standard for embedded\nFrontiers in Robotics and AI 11 frontiersin.org\nFIGURE 5 Example setup in a complex system with multiple hardware modules and various middlewares (only the most relevant interactions are depicted). Publish\u2013subscribe interaction is indicated by , represent RPC interactions, and depict network and inter-process communication. \u00b5RT\u2019s transport agnostic communication is realized by bridge nodes, such as \u201cnetwork bridge\u201d and \u201cROS 2 adapter\u201d in the figure. While the former has to (de)serialize messages and requests from/to a common format as defined for that network channel, the latter needs to translate them according to the employed DDS. The bridge nodes can provide an arbitrary subset of the remote/foreign topics and services they connect with to the local \u00b5RT instance and vice versa. If the network supports real-time communication (e.g., CAN), all modules running \u00b5RT form a distributed, real-time capable union in which network communication is completely transparent to all nodes (except bridge nodes, of course).\ndesigns and MCUs. Such devices are typically not powerful enough for these protocols, so less demanding technologies are employed, which are numerous and have differing properties. A limitation to a subset of these interfaces and protocols would therewith render \u00b5RT unsuitable for many use cases. As every module in a system may host different hardware with different capabilities and real-time requirements also vary significantly between use cases, \u00b5RT opts for this more general method.\nThe benefits of this approach are its flexibility and technology independence. Therefore, \u00b5RT can interface any communication channel. Moreover, as long as such an interface supports real-time communication, multiple \u00b5RT instances can form a distributed union in which all topics and services are accessible by all nodes, making the entire network effectively a single virtual \u00b5RT instance. This method has some drawbacks, as the additional work required to develop bridge nodes is less convenient and presents an initial hurdle. However, the intention is as follows: once a bridge node for an interface has been developed, it can be provided to the community and other developers can henceforth utilize it with minimal effort and enhance it as required.\nAnother potential pitfall when combining \u00b5RT with other middlewares is the absence of any discovery and advertising mechanisms. Such interaction schemes are commonly employed by other solutions to inform the system about newly created topics and services. Due to the strict real-time requirements of \u00b5RT, all such objects must be available as soon as system initialization is completed and may not be removed until shutdown. This may result in situations where a remote topic or service is available on the \u00b5RT side, although it has not been initialized yet (or has been removed again) within the foreign middleware, thus violating assumptions\nabout the state of the communication network. Bridge nodes can solve this issue to some degree by providing a topic or service only after the advertising message has been received. The opposite case, which is removing a topic or service, is not possible, though."
        },
        {
            "heading": "3 Evaluation",
            "text": "\u00b5RT has been evaluated in three ways to compare it to existing middlewares. First, a qualitative comparison of features is given with respect to R2P and ROS 2 (cf. section\u00a03.1), and performance data are presented thereafter in section\u00a03.2. Because middlewares are fundamentally only ameans to an end to ease software development, usability for developers is an essential aspect. Therefore, a study has been conducted and described in detail, and results are presented in section\u00a03.3."
        },
        {
            "heading": "3.1 Features",
            "text": "For a qualitative comparison of features, the twomost important competitors among the plethora of existing middlewares have been selected: ROS 2 due to its popularity in robotics and its ambitions to support real-time computing andR2Pbecause it had beendeveloped with similar goals in mind as for \u00b5RT. Table 1 lists ten important middleware aspects concerning the target application of \u00b5RT.\nFirst, while R2P supports publish\u2013subscribe interaction only, ROS 2 not only offers RPCs like \u00b5RT but also provides an additional \u201cactions\u201d interaction scheme. Actions are similar to RPCs but intended for long-running tasks. In short, an action is initiated by\nFrontiers in Robotics and AI 12 frontiersin.org\na client and the action server provides periodic feedback until the goal has been reached. Because such use cases should not require real-time capabilities in itself (underlying processes might, though), supporting actions was no goal for \u00b5RT. If such behavior is desired, it can still be realized using a service to initiate execution and a topic to provide periodic feedback or another service to provide feedback on demand.8 Concerning decoupling, all three middlewares are decoupled in all three domains.\n8 In fact, actions in ROS 2 are composed of multiple topics and services as well\nHowever, when it comes to real-time capabilities, it is obvious that complete real-time support is not the primary focus of ROS 2. It cannot provide stricter than soft real-time and does not differentiate real-time levels at all. Conversely, R2P and \u00b5RT allow for systemwide hard real-time constraints and definemultiple real-time classes with \u00b5RT even specifying an additional fourth class. Probably, the most distinguishing feature of \u00b5RT is its capability to validate realtime constraints at runtime. To the best of our knowledge, ROS 2 and R2P do not offer this functionality, nor does any other middleware.\nAn important aspect of real-time capabilities is memory management, more precisely, the absence of dynamic allocation. R2P still relies on memory pools, which are an optimized form of dynamic memory management but still include dynamic allocation.\nFrontiers in Robotics and AI 13 frontiersin.org\nTherefore, only \u00b5RT manages to completely omit dynamic memory. The downside of this approach is that interaction in \u00b5RT involves payload data being copied multiple times. Conversely, ROS 2 and R2P allow for zero-copy communication.\nFinally, ROS 2 and \u00b5RT provide QoS statistics, whereas R2P does not. Although ROS 2 can be used on MCUs, doing so comes with several limitations (cf. section\u00a01.1.4). Hence, only R2P and \u00b5RT are considered suitable for such restricted platforms. The different focus on target platforms also shows in the (primarily) supported programming languages. \u00b5RT is completely written in C and only supports this language so far.9 For R2P, it is the same, but with C++ instead of C. ROS 2, however, provides APIs for multiple languages (first and foremost C++ and Python but also C) and thus offers the highest flexibility for developers.\nOverall, this comparison shows the different focus areas of the three middlewares. Although ROS 2 primarily focuses on high-level software and offers many conveniences for developers of such but supports real-time computing andMCUs only subordinate, R2P and \u00b5RT aim at exactly these use cases. Again, \u00b5RT surpasses R2P in almost every aspect, except for zero-copy communication, in which \u00b5RT trades for uncompromising real-time capability."
        },
        {
            "heading": "3.2 Performance",
            "text": "Theperformance of \u00b5RT has been evaluated in terms ofmemory requirements and runtime performance scaling. Results regarding the former are presented in section\u00a03.2.1, and scaling benchmarks are presented in section\u00a03.2.2."
        },
        {
            "heading": "3.2.1 Memory utilization",
            "text": "The memory footprint of \u00b5RT is of major importance as the middleware is targeted to be used on (32-bit) MCUs, for which available resources are very limited. The sizes of the integrated flash memory of such devices typically range from 16\u00a0to 1,024\u00a0kB, so compiled images need to be rather compact. System memory is even more scarce, with entry-level products featuring no more than\n9 Due to the wide support of C by most programming languages, additional interface layers can be added to ease development (cf. section\u00a04.2)\n10 STM32F1 (Cortex-M3), STM32F4 (Cortex-M4), STM32F7 (Cortex-M7), STM32G0 (Cortex-M0+), and STM32-L4 (Cortex-M4)\n8\u00a0kB of RAM and only the most powerful devices exceeding 256\u00a0kB. Therefore, it is a crucial requirement for \u00b5RT to exhibit a small footprint in both regards. Therefore, it can be deployed on a wide range of MCUs.\nTable\u00a02 shows the sizes of all major components of \u00b5RT in system memory and compares them to R2P, as presented by Migliavacca (2013). Most noticeably, many rows in the table contain no values for R2P at all due to the lack of such components because R2P does feature neither synchronization mechanisms nor RPC interaction. Compared to \u00b5RT, it also omits a core component. Because there is only a single core per instance, these 37 bytes should be negligible in most scenarios. Other than that, nodes are about 50% larger for \u00b5RT, which is a significant increase, but with an absolute value of 56 B, the footprint is still considered reasonable. Both components of the synchronization subsystem are acceptably small, with no more than 32\u00a0B. Publishers are much smaller for \u00b5RT and require only 4\u00a0B (25% compared to R2P), as they essentially hold just a pointer to the topic. Topics are also larger for \u00b5RT than they are with R2P. Especially when QoS is enabled, the memory footprint is 157% larger, but even without QoS, the increase is still 57%. It should be noted that each topic in \u00b5RT already holds a message, so those 32\u00a0B need to be subtracted for an apples-to-apples comparison, resulting in a somewhat smaller increase of 100% with QoS enabled and even the same 56\u00a0B as for R2P with QoS disabled. The size of subscribers in \u00b5RT depends on their real-time class (cf. section\u00a02.2) but is estimated in Table\u00a02 with the upper bounds. While they are slightly smaller when QoS is disabled (92%), size increases by a factor of 2 when enabled. Finally, the footprints of RPC components are similar to those of the publish\u2013subscribe subsystem. Requests are again much larger when QoS is enabled, with an even starker difference of 88\u00a0B (157%). Conversely, services are of constant size, with 48\u00a0B acceptably small. Overall, the memory footprints of \u00b5RT\u2019s components are about 50%\u2013150% larger than their pendants in R2P, but absolute values remain small enough to be reasonable even for entry-level MCUs.\nWhen considering the required amount of flash memory, \u00b5RT can scale from a modest 2.2\u00a0kB to 18.2\u00a0kB due to its high configurability (cf. section\u00a02.3.4). Unfortunately, a direct comparison with R2P is difficult to achieve because Migliavacca (2013) only stated values, including the RTOS; hence, such was not conducted for this work. Absolute footprint sizes of \u00b5RT\u2019s core, the three subsystems, and a complete configuration are given in Table\u00a03 and represent the worst-case scenario among all evaluated MCUs.10\nFrontiers in Robotics and AI 14 frontiersin.org\nWhen comparing memory footprints in the binary image, the publish\u2013subscribe subsystem is themost expensive component, with RPC close behind. Conversely, synchronization functionality has a minor impact of no more than 1\u00a0kB, even for debug builds. When comparing release and debug scenarios, footprints increase between 49% and 95% for the latter (67% on average). Enabling QoS is less expensive, with only 13%\u201350% larger footprints (29%on average). In both cases, impacts are most pronounced for the publish\u2013subscribe subsystem. Considering the required flashmemory exceeding 16\u00a0kB with everything enabled and considering that a sophisticated RTOS is required, \u00b5RT is hardly a viable option for MCUs with 32\u00a0kB of flash or even less. Based on our experience, a minimum of 128\u00a0kB is recommended for development (debug builds) and 64\u00a0kB for deployment (release builds), even with optimizations (i.e., garbage collection and link time optimization) enabled."
        },
        {
            "heading": "3.2.2 Runtime performance and scaling",
            "text": "In order to evaluate the runtime performance of \u00b5RT, an extensive set of benchmarks has been conducted.11 These benchmarks have been designed in a way that scaling effects for each middleware component can be assessed, as well as differences between real-time classes. Therefore, scenarios have been implemented carefully to represent worst-case situations. Thread priorities were set in a way that nodes would constantly block each other, and the MCUs were continuously stressed by an additional low-priority thread. Moreover, each benchmark was repeated 1,000 times, so meaningful minimum and maximum values could be obtained to assess synchronicity performance.\nThe graphs in this section depict only the results of the worstperforming component (e.g., the node with the highest latency). Note that each graph consists of a line and a shaded area \u201changing\u201d below. Although the former represents the largest measured values, the latter depicts the range between the lowest and highest values in the result data. However, for most graphs, the shaded area is barely visible. Except for the data shown in Figure\u00a06A, all results were obtained using an STM32L476RG (Cortex-M4 @ 80\u00a0MHz).\nFirst, performance scales linearly with the number of nodes in a system, as shown in Figure\u00a06A. For this benchmark, a single timer triggered all nodes, which just measured the latency until the event was eventually processed. As expected, absolute performance varies significantly between different MCUs. Although most MCUs demonstrate consistent performance, the STM32G0 exhibits significant temporal variance, which is most probably caused by its Cortex-M0+ core.\nFigure\u00a06B depicts performance scaling for publish\u2013subscribe and RPC interaction with increasing payload sizes. Again, performance scales linearly, as expected. More interestingly, the first communication of an RPC interaction (until the service dispatched the request) is significantly faster than publish\u2013subscribe, although the return communication (until the answered request is retrieved\n11 Software environment: AMiRo-OS version 2.3 (Sch\u00f6pping\u00a0et\u00a0al., 2016), which incorporates ChibiOS version 21.11 (di\u00a0Sirio, 2022); cf. Sch\u00f6pping and Kenneweg, 2022b, commit e8ddcd253bb5996509cb82adde700b0fec7798f1\nagain) takes longer overall. This finding indicates that fire-andforget requests should be used whenever possible. The graphs also show the potential performance gains if zero-copy communication was possible with \u00b5RT. Especially when comparing the time scales with Figures\u00a07, 8, copy operations have only a minor impact on the overall performance.\nFor benchmark results of the publish\u2013subscribe subsystem, as depicted in Figure\u00a07, two striking features catch the eye. First, for an increasing number of communication hops, topics and (HRT) subscribers, synchronicity characteristics deteriorate. A closer look at the data reveals that only the very first interaction is significantly faster (by 13.2% for topics), and excluding this data point results in a jitter of 1.2% instead of 12.2% regarding topics. Second, performance graphs of communication hops and topics do not scale linearly but slightly exponentially. Again, this is only the case for HRT interaction, whereas performance scales linearly for all other real-time classes. When recalling the estimated complexity of publish\u2013subscribe interaction from Equation\u00a015, the reason becomes obvious. Neither the number of hops nor the number of topics can be increasedwithout increasing the number of subscribers sHRT. Doing so effectively results in a complexity multiplied by sHRT and, therefore, a quadratic increase in latency because validation timers of all HRT subscribers need to be updated with every interaction:\nsHRT \u22c5O (\u03b1 \u22c5m+ \u03b2 \u22c5 2p+ \u03b3 \u22c5 sHRT) =O (sHRT \u22c5 (\u03b1 \u22c5m+ \u03b2 \u22c5 2p+ \u03b3 \u22c5 sHRT)) =O (\u03b1 \u22c5m \u22c5 sHRT + \u03b2 \u22c5 2p \u22c5 sHRT + \u03b3 \u22c5 s2HRT) (17)\nNonlinear performance scaling for HRT communication is an accepted trade-off made by \u00b5RT, though, in order to validate timing constraints for such critical components. Moreover, the rather low expression of exponential scaling in the data suggests that the corresponding weight \u03b3 is rather small compared to \u03b1 and \u03b2. Figure\u00a07A shows constant performance for an increasing number of messages. This benchmark does not represent the worst-case scenario, as tinfo increased with every interaction, so messages did not have to be enqueued (general case; linear complexity) but could just be appended (constant complexity). With this in mind, the presented graph must be interpreted as typical performance rather than worst-case performance, which scales linearly.\nA similar picture emerges for the RPC subsystem. Performance evaluation, as presented in Figure\u00a08, apparently shows the same effects as the publish\u2013subscribe, but more pronounced. Again, recalling the complexity estimation from Equation\u00a016 reveals the cause. As with HRT subscribers for publish\u2013subscribe interaction, increasing the number of HRT requests rHRT effectively results in quadratic scaling regarding this factor:\nrHRT \u22c5O (\u03b1 \u22c5 q+ \u03b2 \u22c5 4p+ \u03b3 \u22c5 (rHRT \u2212 1)) =O (rHRT \u22c5 (\u03b1 \u22c5 q+ \u03b2 \u22c5 4p+ \u03b3 \u22c5 (rHRT \u2212 1))) =O (\u03b1 \u22c5 q \u22c5 rHRT + \u03b2 \u22c5 4p \u22c5 rHRT + \u03b3 \u22c5 (r2HRT \u2212 rHRT)) (18)\nNotably, performance does not scale exponentially when increasing number of communication hops this time because there is only a single request per hop (rHRT = 1), so the hindmost term has no effect in this case. Although exponential effects\nFrontiers in Robotics and AI 15 frontiersin.org\nFIGURE 6 General performance measurements of \u00b5RT. On the left-hand side (A), performance scaling when increasing the total number of nodes in a system is depicted, thereby comparing different MCUs. On the right-hand side (B), the performance impact of payload sizes is shown for both communication schemes supported by \u00b5RT.\nFIGURE 7 In-depth performance analysis of the publish\u2013subscribe subsystem. On the left-hand side (A), performance scaling when increasing the number of components in a system is depicted. On the right-hand side (B), the performance of the four real-time classes is compared for increasing number of topics.\nare much more pronounced for RPC than was the case for publish\u2013subscribe, the weighting factor \u03b3 remains relatively small.\nOverall, performance figures confirm the overall linear scaling of \u00b5RT, although some scenarios exhibit exponential latency increase. However, this is only the case for HRT communication, and even then, nonlinearity is little pronounced for scales reasonable for MCUs. Especially when considering the findings concerning RPC interaction, request queues with lots of HRT requests should be avoided in the first place for the sake of a responsive system."
        },
        {
            "heading": "3.3 Usability",
            "text": "In order to assess the usability of \u00b5RT for software developers, a study has been conducted. The goal of this study was not just to evaluate the ease of use of \u00b5RT by itself because this information alone would not be meaningful, but how it fares compared to ROS. It was conducted as part of the exercises for the lecture \u201cAutonomous Systems Engineering\u201d at Bielefeld University and carried out in multiple weekly sessions. This way, a comprehensive set of introductory information, programming tasks, and questionnaires could be used in the study. In section\u00a03.3.1, the\nFrontiers in Robotics and AI 16 frontiersin.org\nFIGURE 8 In-depth performance analysis of the RPC subsystem. On the left-hand side (A), performance scaling when increasing the number of components in a system is depicted. On the right-hand side (B), the performance of the four real-time classes is compared for an increasing number of requests.\nFIGURE 9 Statistical evaluation of the three additional questions of the questionnaires: self-estimated level of completion (A), required time (B), and number of requests for assistance (C). Each pair of box plots depicts results for ROS (left) and \u00b5RT (right), respectively. Each axis shows results for the entire cohort (group A) and only those participants who filled in the questionnaires about ROS and \u00b5RT (group B). Vertical axes are labeled by the options participants had to choose from, as they were available in the questionnaires.\nstudy design and applied methods are described in detail before the results are presented afterward in section\u00a03.3.2."
        },
        {
            "heading": "3.3.1 Study design",
            "text": "First, a within-person designwas chosen for the study, and it was subdivided into four parts, conducted in weekly sessions of 2\u00a0h each.\n1. ex ante: Participants were asked to fill in a questionnaire about demographic information and prior experience in various areas of computer science. For the latter, six-level Likert scales were used with the available options \u201cnone,\u201d \u201cnovice,\u201d \u201cadvanced beginner,\u201d \u201ccompetent,\u201d \u201cproficient,\u201d and \u201cexpert.\u201d 2. ROS line following: In the first session, an introductory lecture was given, explaining fundamental concepts of middlewares in general and specifically ROS. In the second session, participants\nwere given the task of making AMiRo follow a line in a simulation environment using ROS (C++ only), for which they were allowed two sessions to complete. Afterward, participants were asked to complete a questionnaire to assess their experience. 3. \u00b5RT tutorial: This time, no introductory lecture was provided, but participants were instructed to work through a tutorial on \u00b5RT instead and to fill in another questionnaire afterward. Participants were allowed to spend two sessions with this part. 4. \u00b5RT line following: Another task was given to make AMiRo follow a line, but this time using \u00b5RT on a real robot, and again participants were asked to rate their experience thereafter by means of another questionnaire. As with the other tasks, participants could spend two sessions on this one.\nFrontiers in Robotics and AI 17 frontiersin.org\nFIGURE 10 Statistical evaluation of the USE questionnaires. Each pair of box plots depicts results for ROS (left) and \u00b5RT (right), respectively. In the axis on the left-hand side (A), all participants are considered, although only six participants filled in the questionnaire for \u00b5RT while 12 participants did so for ROS. On the right-hand side (B), only five participants who filled in both questionnaires are considered.\nFIGURE 11 Correlation matrices showing the correlation between previous experience in three topics of computer science and the four aspects of the USE questionnaires. The left-hand side (A) depicts the correlation matrix regarding the USE questionnaire of the ROS line-following task (based on 12 data points), whereas the right-hand side (B) relates to \u00b5RT (based on six data points).\nQuestionnaires for the three tasks were identical, each consisting primarily of a USE questionnaire as defined by Lund (2001), but supplemented by three further questions\u2014level of completion (self-estimation), required time, and the number of requests for assistance\u2014as well as corresponding free-text fields to account for qualitative responses. Obviously, the results of those questionnaires are the dependent variables in this study.\nThe independent variable of interest was the employed middleware\u2014ROS versus \u00b5RT\u2014so the two most important parts of the study are the line-following tasks. The decision was made against a between-person design because the scenarios could not match each other exactly. As ROS cannot be run on the MCUs of AMiRo, that task had to be conducted in a simulation environment rather than an actual robot. Conversely, no simulator integration for \u00b5RT exists so far, so these scenario differences were inevitable. Furthermore, the acquisition of participants for a study of this scale is difficult, especially during the COVID-19 pandemic, making those a very scarce \u201cresource.\u201d The information gained\nFrontiers in Robotics and AI 18 frontiersin.org\nFIGURE 12 Example architecture as implemented on the AMiRo platform. Rectangles depict nodes, whereas topics are visualized as diamond shapes. Publish\u2013subscribe interaction is indicated by . and represent complete and \u201cfire-and-forget\u201d RPC interaction, respectively. Various shadings of nodes indicate that those are executed on different MCUs. Communication is hence tunneled over CAN by bridge nodes as required (not depicted).\nper participant hence needed to be maximized. Moreover, the inperson design with this order\u2014ROS first and \u00b5RT thereafter\u2014does not compromise the validity of this study\u2019s results because many software developers in robotics are already experienced with ROS and would use \u00b5RT as supplemental middleware on the real-time level of a system. Hence, the study design represents real use case scenarios very well.\nEach task of this study was designed so it could be completed in about 90\u00a0min, but participants were permitted up to 4\u00a0h. For optimal comparability, both line-following tasks were designed identically: participants had to create a new node, add a subscriber to receive sensor information from a prepared topic, write a simple logic to calculate a two-dimensional motion vector, and interface an existing service to make AMiRo move. The quality of the implemented linefollowing algorithm was of no concern for this study, as the focus was on understanding middleware concepts and the ability to apply these to actual implementation."
        },
        {
            "heading": "3.3.2 Questionnaire results",
            "text": "In total, 21 students in computer science participated in the study. Ages ranged 21\u201328 (median 23.5) years. Of the 21 students, thirteen were male and six were female participants, and two were not specified. All students had a bachelor\u2019s degree except one who had no academic degree yet. Thirteen (62%) participants had already worked with ROS before, and seven (33%) had experience in robotics, although self-assessed skill levels ranged no higher than \u201ccompetent.\u201d The same applies to experience in the two relevant\nprogramming languages, C++ and C, whereby the mean expertise for the former was about 1/2 skill level higher. Notably, experience in Python was much higher, with the median at \u201ccompetent.\u201d This result confirms the decision to restrict the ROS task to C++ because the strongly differing programming skills might have influenced the study results. Finally, although 11 (52%) participants had worked with MCUs before, none stated any expertise with RTOSes, indicating that the previous experiencesweremade in baremetal programming of MCUs instead of using sophisticated RTOS software environments.\nUnfortunately, although all students did work on all tasks, not all questionnaires were completed. Of the 21 participants, only 12 (57%) assessed the ROS line-following task, 10 (48%) submitted valid questionnaires for the \u00b5RT tutorial, and 6 (29%) rated the \u00b5RT line-following task. Moreover, complete data about all three tasks are available for just five students (24%). For this reason, results will be distinguished hereafter by whether they were obtained from the entire cohort or only from the five participants who provided complete information. Those two subsets of the cohort will be referred to as group A and group B.\nBefore examining the results of the USE questionnaires, the evaluation of the three additional questions provides insights into the correlation between participants who only filled in the questionnaires about ROS (group A) and who also provided information about their experience with \u00b5RT (group B). Figure\u00a09 shows that the ROS task completion level varies much more for\nFrontiers in Robotics and AI 19 frontiersin.org\ngroup A, whereas group B performed consistently well. In fact, the level of completion of the ROS task and whether or not a participant filled in the questionnaire about the \u00b5RT task are highly correlated: \u03c1 = 0.678. This finding suggests that many students had issues understanding the concepts of publish\u2013subscribe and RPC interaction in general and could not apply those with either middleware. Although discrepancies between the two groups are not as pronounced for the time required and the number of requests for assistance, where average andmedian values are similar, variances of the answers to these questions are also much higher for group A.\nParticipants, on average, required 1/2 to one more hour to complete the line-following task with \u00b5RT than using ROS. Participants also asked for assistance five times more often when working on the \u00b5RT task. These two findings are again correlated with \u03c1 = 0.746 for ROS and \u03c1 = 0.809 for \u00b5RT. This indicates that participants could have completed the tasks in less time if they had been able to solve them completely on their own. While the overall higher number of requests for assistance for \u00b5RT shows that tutorial and documentation need to be improved, a participant stated for the \u00b5RT tutorial task that two of five requests for assistance were due to hardware issues with the robot rather than about \u00b5RT.This comment indicates that difficulties of understanding are not five times higher for \u00b5RT. However, as such differentiation was not considered in the study design, no definitive statement can be made based on the obtained data.\nResults of the USE questionnaires are depicted in Figure\u00a010 and show strong differences between groups A and B. Although \u00b5RT seems to outperformROS in all four aspectswhen considering group A, results are more heterogeneous for group B. Due to the small size of the latter, the exact values depicted in Figure\u00a010B cannot be considered significant. However, the overall positive trend for all aspects of USE and both middlewares is evident.\nWhen investigating the correlations between previous experience in various areas of computer science and the information given in the USE questionnaires depicted in Figure\u00a011, several further observations were made. First, the results of the USE questionnaire regarding the ROS task are correlated to prior experience in robotics but are uncorrelated to MCUs, both of whichmeet expectations.When investigating the correlationmatrix regarding \u00b5RT, the first thing that stands out is the consistently inverse correlations. In particular, the strong (inverse) correlations with prior experience with MCUs and ROS are noteworthy but difficult to interpret. Either developers without previous knowledge in these topics rate \u00b5RT positively, or those who already have such experience rate \u00b5RT negatively, or both. Again, no clear conclusion can be drawn due to the small sample sizes (12 and 6 participants, respectively), so these findings should be considered and further investigated in future studies.\nFinally, the USE questionnaires also contain qualitative questions, and some answers given by participants are worth mentioning. When asked about the most negative aspects of ROS and \u00b5RT, respectively, many complaints were made about the high complexity of ROS and the insufficient documentation of \u00b5RT. There were also some comments about \u00b5RT not supporting objectoriented programming languages such as C++ and Python. On the contrary, many praised ROS that it supports exactly those languages and that it is an open-source project with a large community\nsupporting it. However, positive mentions about \u00b5RT were its simplicity and that it is \u201cnot overloaded with features.\u201d"
        },
        {
            "heading": "4 Discussion",
            "text": "As mentioned at the very beginning of this work (cf. section\u00a01), \u00b5RT was developed as part of the software ecosystem of the AMiRo platform (Sch\u00f6pping\u00a0et\u00a0al., 2015; Herbrechtsmeier\u00a0et\u00a0al., 2016). In addition to the evaluation results presented in section\u00a03, practical experience was already gained by restructuring the entire real-time software of AMiRo to take advantage of the novel middleware and split the monolithic software into multiple applications (Sch\u00f6pping and Kenneweg, 2022b). The new architecture allows arranging such applications among the several MCUs of AMiRo (cf. Herbrechtsmeier\u00a0et\u00a0al., 2016; Herbrechtsmeier, 2017) by means of configurations. Because all MCUs communicate via a common CAN interface (ISO, 1993), an according bridge node has been implemented and used to combine the individual \u00b5RT instances of all MCUs into a single virtual environment. An example configuration is depicted in Figure\u00a012, which allows a user to select from four modes: idle (no action executed at all), sensor visualization (sensor readings are visualized via LEDs), line following (AMiRo follows a line on the ground), and obstacle avoidance (AMiRo moves forward. However, it avoids any encountered obstacles). Although the motor control loop is entirely processed on the same MCU (cf. right part of Figure\u00a012), control logic, sensor input, and visualization are distributed among the entire robot. In order to change the behavior of AMiRo, many nodes can be reused, whereas others are modified or replaced, or even further nodes are added to the system.12 All in all, \u00b5RT already proved its benefits and effectiveness as it is employed as a standard tool for the productive use of AMiRo in educational and scientific contexts."
        },
        {
            "heading": "4.1 Conclusion",
            "text": "In this work, a novel, real-time, capablemiddleware\u2014\u00b5RT\u2014was presented. In contrast to existing solutions, it is used in resourceconstrained platforms, such as microcontrollers (MCUs), and features validation of timing constraints at runtime. \u00b5RT provides two communication schemes, publish\u2013subscribe and future RPCs, and overall offers a similar feature set to popular middlewares such as ROS 2. This work also presented a thorough evaluation of \u00b5RT, including a feature comparison with existing solutions, an in-depth performance analysis, and a usability study, which assessed the experience software developers hadwith \u00b5RT. Although the middleware showed excellent results overall, some issues and potential areas for improvement were identified. Findings of all analyses regarding \u00b5RT are summarized by recalling the initial goals as defined at the very beginning of section\u00a02.\n12 Actually, several more applications are already implemented for AMiRo (e.g., for power management), which are not depicted in Figure\u00a012.\nFrontiers in Robotics and AI 20 frontiersin.org\n1. While thememory footprint of \u00b5RT is slightly higher than that for existing solutions targeting MCUs, it is still reasonably small. 2. Real-time capabilities were suitable for even hard real-time use cases with strict timing constraints. 3. Performance of \u00b5RT scales linearly in most regards, but some aspects concerning hard real-time interaction exhibit slightly exponential scaling. 4. \u00b5RT allows validating real-time constraints at runtime, a unique feature among all middlewares to our knowledge. 5. Topic-based publish\u2013subscribe interaction is provided for periodic/time-based communication, and RPCs allow for event-based interaction. 6. While the usability study proved the effectiveness of \u00b5RT for developers, current API documentation is lacking. 7. \u00b5RT can interact with other middlewares by means of dedicated bridge nodes. 8. Depending on the requirements of individual use cases, the feature set and performance characteristics of \u00b5RT can be optimized by its fine-grained configurability."
        },
        {
            "heading": "4.2 Future prospect",
            "text": "The most pressing drawback of \u00b5RT is its lacking documentation. Although a tutorial exists and HTML-based documentation of the entire API is provided, the usability study revealed that both are insufficient in their current state (cf. section\u00a03.3.2). Another complaint of participants in the study was the missing support of popular object-oriented programming languages, such as C++ and Python. This demand was already considered with the design of \u00b5RT, so that the according wrappers of its API and integration in further tools, such asGenoM (Mallet\u00a0et\u00a0al., 2010) or BRICS (Bruyninckx\u00a0et\u00a0al., 2013), can be realized with relative ease. This study also revealed several aspects which should be investigated further, as no clear conclusions could be drawn from the data obtained so far because of the study design and sample size. Another lacking feature of \u00b5RT, or more precisely the ecosystem on top, is bridge nodes interfacing other popular middlewares such as ROS 2 or MQTT (cf. section\u00a02.8). Although those are not part of \u00b5RT itself, the availability of such interface nodes would most probably benefit its adoption for other platforms. Due to its focus on real-time capability and validation of timing constraints at runtime, some compromises were made with the design of \u00b5RT. First, its current implementation makes extensive use of mutex locks but does not feature preferable lock-free methods. Whether such are actually possible and what benefits this would bring for \u00b5RT need further investigation. Moreover, performance analyses showed nonlinear scaling in some situations (cf. section\u00a03.2.2). As this can become an issue for large, highly complex systems, performance in this regard needs to be further improved. Finally, some proposed enhancements include providing a fallback event system if no external implementation is mapped to its operating system abstraction layer (OSAL; cf. section\u00a02.4).\nAs \u00b5RT has already matured to the point that it has become a core component of the AMiRo software habitat, many of these issues and requested features will be addressed in the future. By the regular employment of the platform for teaching, user feedback on changes\nmade to the system can be obtained quickly, and \u00b5RT will be refined in the upcoming years. Assuming that \u00b5RT will be accepted by the robotics community and adopted to further platforms, development could be accelerated thanks to its open-source approach.\nData availability statement\nThe datasets presented in this study can be found in online repositories. The names of the repository/repositories and accession number(s) can be found at: https://gitlab.ub.unibielefeld.de/uRT-evaluation-data/ROS-2-pendulum-demo https:// gitlab.ub.uni-bielefeld.de/uRT-evaluation-data/uRT-performancebenchmark https://gitlab.ub.uni-bielefeld.de/uRT-evaluation-data/ uRT-usability-study.\nEthics statement\nThe studies involving human participants were reviewed and approved by the Ethics Committee of Bielefeld University (EUB). The patients/participants provided their written informed consent to participate in this study.\nAuthor contributions\nTS contributed to the conception of \u00b5RT, its implementation, and integration in the AMiRo software habitat. TS designed and conducted all experiments and evaluated the resulting data. SK contributed to the implementation of \u00b5RT and the development of further applications using it (most notably the CANBridge transport application) and thus greatly helped optimize and fix the code. This manuscript was primarily written by TSwith contributions from SK. MH and UR supervised the project and helped enhance and refine the manuscript.\nFunding\nThis research was funded under Grant no. 1807ow003a by the Ministry of Economic Affairs, Innovation, Digitalisation and Energy (MWIDE) of the State of North Rhine-Westphalia within the Leading-Edge Cluster Intelligent Technical Systems OstWestfalenLippe (it\u2019s OWL)."
        },
        {
            "heading": "Acknowledgments",
            "text": "We acknowledge the financial support of the German Research Foundation (DFG) and the Open Access Publication Fund of Bielefeld University for the article processing charge. Many thanks to the numerous students who helped develop \u00b5RT (and its rather unsuccessful prototype) and especially to the participants of the usability study. Special thanks go to Kathrin Krieger, who greatly helped us with her expertise in designing and evaluating the study and interpreting the results. Further thanks to all other people\nFrontiers in Robotics and AI 21 frontiersin.org\ninvolved in the AMiRo project for their patience as the development of \u00b5RT took much longer than expected.\nConflict of interest\nThe authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.\nPublisher\u2019s note\nAll claims expressed in this article are solely those of the authors and do not necessarily represent those of their affiliated organizations or those of the publisher, the editors, and the reviewers. Any product that may be evaluated in this article, or claim that may be made by its manufacturer, is not guaranteed or endorsed by the publisher."
        }
    ],
    "title": "\u03bcRT: A lightweight real-time middleware with integrated validation of timing constraints",
    "year": 2023
}