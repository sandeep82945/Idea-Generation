{
    "abstractText": "The abstract should briefly summarize the contents of the paper in 150\u2013250 words.",
    "authors": [],
    "id": "SP:863cdbf4bd372867dd891a26be183ed577446694",
    "references": [
        {
            "authors": [
                "H. Abbas",
                "A. Rodionova",
                "E. Bartocci",
                "S.A. Smolka",
                "R. Grosu"
            ],
            "title": "Quantitative regular expressions for arrhythmia detection algorithms",
            "venue": "Computational Methods in Systems Biology. pp. 23\u201339. Springer",
            "year": 2017
        },
        {
            "authors": [
                "H. Abbas",
                "A. Rodionova",
                "K. Mamouras",
                "E. Bartocci",
                "S.A. Smolka",
                "R. Grosu"
            ],
            "title": "Quantitative regular expressions for arrhythmia detection",
            "venue": "IEEE/ACM Trans. Comput. Biol. Bioinformatics 16(5), 1586\u20131597",
            "year": 2019
        },
        {
            "authors": [
                "R. Alur",
                "K. Mamouras",
                "C. Stanford"
            ],
            "title": "Modular quantitative monitoring",
            "venue": "Proc. ACM Program. Lang. 3(POPL)",
            "year": 2019
        },
        {
            "authors": [
                "P. Balbiani",
                "J.F. Condotta"
            ],
            "title": "Computational complexity of propositional linear temporal logics based on qualitative spatial or temporal reasoning",
            "venue": "FroCoS. p. 162\u2013176. Springer-Verlag, Berlin, Heidelberg",
            "year": 2002
        },
        {
            "authors": [
                "E.F. Codd"
            ],
            "title": "Relational completeness of data base sublanguages",
            "venue": "Database Systems. pp. 65\u201398. Prentice-Hall",
            "year": 1972
        },
        {
            "authors": [
                "G. Cugola",
                "A. Margara"
            ],
            "title": "Processing flows of information: From data stream to complex event processing",
            "venue": "ACM Comput. Surv. 44(3)",
            "year": 2012
        },
        {
            "authors": [
                "L. D\u2019Antoni",
                "M. Veanes"
            ],
            "title": "Monadic second-order logic on finite sequences",
            "venue": "SIGPLAN Not. 52(1), 232\u2013245",
            "year": 2017
        },
        {
            "authors": [
                "L. D\u2019Antoni",
                "M. Veanes"
            ],
            "title": "The power of symbolic automata and transducers",
            "venue": "Computer Aided Verification. pp. 47\u201367. Springer",
            "year": 2017
        },
        {
            "authors": [
                "S. Demri",
                "D. D\u2019Souza"
            ],
            "title": "An automata-theoretic approach to constraint ltl",
            "venue": "Information and Computation 205(3), 380\u2013415",
            "year": 2007
        },
        {
            "authors": [
                "L. D\u2019antoni",
                "M. Veanes"
            ],
            "title": "Extended symbolic finite automata and transducers",
            "venue": "Formal Methods in System Design 47(1), 93\u2013119",
            "year": 2015
        },
        {
            "authors": [
                "A. Grez",
                "C. Riveros",
                "M. Ugarte"
            ],
            "title": "A Formal Framework for Complex Event Processing",
            "venue": "ICDT. LIPIcs, vol. 127, pp. 5:1\u20135:18. Schloss Dagstuhl, Dagstuhl, Germany",
            "year": 2019
        },
        {
            "authors": [
                "J. Li",
                "D. Maier",
                "K. Tufte",
                "V. Papadimos",
                "P.A. Tucker"
            ],
            "title": "No pane, no gain: Efficient evaluation of sliding-window aggregates over data streams",
            "venue": "SIGMOD Rec. 34(1), 39\u201344",
            "year": 2005
        },
        {
            "authors": [
                "K. Mamouras",
                "M. Raghothaman",
                "R. Alur",
                "Z.G. Ives",
                "S. Khanna"
            ],
            "title": "StreamQRE: Modular specification and efficient evaluation of quantitative queries over streaming data",
            "venue": "PLDI. p. 693\u2013708. ACM, New York, NY, USA",
            "year": 2017
        },
        {
            "authors": [
                "P. Melsted",
                "B.V. Halld\u00f3rsson"
            ],
            "title": "KmerStream: streaming algorithms for k -mer abundance estimation",
            "venue": "Bioinformatics 30(24), 3541\u20133547",
            "year": 2014
        },
        {
            "authors": [
                "K. Patroumpas",
                "T. Sellis"
            ],
            "title": "Window specification over data streams",
            "venue": "EDBT. pp. 445\u2013464. Springer",
            "year": 2006
        },
        {
            "authors": [
                "S. Perera",
                "S. Suhothayan"
            ],
            "title": "Solution patterns for realtime streaming analytics",
            "venue": "Proceedings of the 9th ACM International Conference on Distributed Event-Based Systems. pp. 247\u2013255. DEBS \u201915, ACM",
            "year": 2015
        },
        {
            "authors": [
                "L. Petit",
                "C. Labb\u00e9",
                "C.L. Roncancio"
            ],
            "title": "An algebric window model for data stream management",
            "venue": "Proceedings of the Ninth ACM International Workshop on Data Engineering for Wireless and Mobile Access. pp. 17\u201324. ACM",
            "year": 2010
        },
        {
            "authors": [
                "M.Y. Vardi"
            ],
            "title": "The rise and fall of LTL",
            "venue": "GandALF",
            "year": 2011
        },
        {
            "authors": [
                "M. Veanes",
                "P. de Halleux",
                "N. Tillmann"
            ],
            "title": "Rex: Symbolic regular expression explorer",
            "venue": "2010 Third International Conference on Software Testing, Verification and Validation. pp. 498\u2013507",
            "year": 2010
        },
        {
            "authors": [
                "F. Wang",
                "P. Liu"
            ],
            "title": "Temporal management of RFID data",
            "venue": "Proceedings of the 31st International Conference on Very Large Data Bases. pp. 1128\u20131139. VLDB \u201905, VLDB Endowment",
            "year": 2005
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n20 9.\n04 24\n4v 1\n[ cs\n.F L\n] 9\nKeywords: First keyword \u00b7 Second keyword \u00b7 Another keyword."
        },
        {
            "heading": "1 First Section",
            "text": ""
        },
        {
            "heading": "1.1 A Subsection Sample",
            "text": "Please note that the first paragraph of a section or subsection is not indented. The first paragraph that follows a table, figure, equation etc. does not need an indent, either.\nSubsequent paragraphs, however, are indented.\nSample Heading (Third Level) Only two levels of headings should be numbered. Lower level headings remain unnumbered; they are formatted as run-in headings.\nSample Heading (Fourth Level) The contribution should contain no more than four levels of headings. Table 1 gives a summary of all heading levels.\nDisplayed equations are centered and set on a separate line.\nx+ y = z (1)\nPlease try to avoid rasterized images for line-art diagrams and schemas. Whenever possible, use vector graphics instead (see Fig. 1).\nTheorem 1. This is a sample theorem. The run-in heading is set in bold, while the following text appears in italics. Definitions, lemmas, propositions, and corollaries are styled the same way.\nProof. Proofs, examples, and remarks have the initial word in italics, while the following text appears in normal font.\nFor citations of references, we prefer the use of square brackets and consecutive numbers. Citations using labels or the author/year convention are also acceptable. The following bibliography provides a sample reference list with entries for journal articles [1], an LNCS chapter [2], a book [3], proceedings without editors [4], and a homepage [5]. Multiple citations are grouped [1,2,3], [1,3,4,5].\nAcknowledgements Please place your acknowledgments at the end of the paper, preceded by an unnumbered run-in heading (i.e. 3rd-level heading)."
        },
        {
            "heading": "3. Author, F., Author, S., Author, T.: Book title. 2nd edn. Publisher, Location (1999)",
            "text": ""
        },
        {
            "heading": "4. Author, A.-B.: Contribution title. In: 9th International Proceedings on Proceedings, pp. 1\u20132. Publisher, Location (2010)",
            "text": "5. LNCS Homepage, http://www.springer.com/lncs. Last accessed 4 Oct 2017\nar X\niv :2\n20 9.\n04 24\n4v 1\n[ cs\n.F L\n] 9\nS ep\n2 02\n2\nWindow Expressions for Stream Data Processing\nM. Praveen1[0000\u22120002\u22125734\u22127115] and S. Hitarth2[0000\u22120001\u22127419\u22123560]\n1 Chennai Mathematical Institute, Chennai, India praveenm@cmi.ac.in\n2 Hong Kong University of Science and Technology, HKSAR hsinghab@connect.ust.hk\nAbstract. Traditional ways of storing and querying data do not work well in scenarios where data is being generated continuously and quick decisions need to be taken. E.g., in hospital intensive care units, signals from multiple devices need to be monitored and occurrence of any anomaly should raise alarms immediately. A typical design would take the average from a window of say 10 seconds (time based) or 10 successive (count based) readings and look for sudden deviations. More sophisticated window definitions may be desired. E.g., we may want to select windows in which the maximum value of a field is greater than a fixed threshold. Existing stream processing systems either restrict to time or count based windows, or let users define customised windows in imperative programming languages. These are subject to the implementers\u2019 interpretation of what is desired and hard to understand for others. We introduce a formalism for specifying windows based on Monadic Second Order logic. It offers several advantages over adhoc definitions written in imperative languages. We demonstrate four such advantages. First, we illustrate how practical streaming data queries can be easily written with precise semantics. Second, we get different formalisms (but that are expressively equivalent) for defining windows. We use one of them (regular expressions) to design an end-user friendly language for defining windows. Third, we use another expressively equivalent formalism (automata) to design a processor that automatically generates windows according to specifications. The fourth advantage we demonstrate is more sophisticated. Some window definitions have the problem of too many windows overlapping with each other, overwhelming the processing engine. This is handled in different ways by different engines, but all the options are about what to do when this happens at runtime. We study this as a static analysis question and prove that it is undecidable to check whether such a scenario can ever arise for a given window definition. We identify a fragment for which the problem is decidable.\nKeywords: Streaming Data, Window Definitions, Regular Expressions, Automata based approach"
        },
        {
            "heading": "1 Introduction",
            "text": "Streaming applications are programs that consume and produce streams of data. They are applied in many areas, ranging from detecting who is controlling the\nball in soccer matches [18] to detecting irregularities in heartbeat rhythms in implantable cardioverter defibrillators (ICDs) [2] and continuous analysis of RFID readings to track valid paths of shipments in inventory management systems [22]. One common aspect is that they produce output within a bounded amount of time, during which they can only read a bounded portion of the input. Windows define a span of positions along a stream that the program can use as a unit to perform computations on, and are fundamental to stream processors. Not all of them allow end users to define customized windows though. The survey [6, Table IV] mentions thirty four processors, of which six allow user defined windows. Four of them allow only time based or count based windows. The other two (Esper [11] and IBM System S [13]) allow customizable windows based on other criteria, but they have to be written in imperative programming languages.\nThe syntax of many languages used in stream processors extend data base query languages. Relational database query processing arguably derives a significant portion of its robustness from the fact that it is based on relational algebra that is expressively equivalent to first-order logic [5]. But for processing streaming data, the fundamental linear order of arrival is not part of the syntax. This may not be important for all applications, but we demonstrate many real world streaming data queries that are simplified when written using the linear order.\nWe introduce a way of defining windows based on Monadic Second Order (MSO) logic of one successor, which includes the linear order of arrival as a basic building block. Apart from easily expressing practical queries, we get other advantages from concepts and constructs in formal language theory. The equivalence with regular expressions allows us to design a language for defining windows that is easier to understand for end users compared to logic based syntax [20]. The equivalence with automata allows us to design a procedure that automatically produces windows from a data stream according to specifications.\nIt is possible that a window specification results in a large number of windows overlapping at the same position of a data stream, overwhelming the stream processor. This is usually handled by engines using load shedding \u2014 dropping of information items from the stream at runtime when load becomes too high. This may be acceptable if it is caused by high input rate, but not if there is a design fault in the window definition. We study the problem of checking whether the number of windows overlapping at a single position is potentially unbounded for a given window definition. We show that this is decidable for finite alphabets, using combinatorial tools to prove that unboundedness implies that there will be a detectable pattern in the states of the automata defining the windows. This problem is undecidable in general for infinite alphabets.\nData elements in a stream are usually numerical or similar values from an infinite domain. Symbolic MSO [7] is meant to deal with infinite alphabets. The atomic formulas of this logic can check properties of input symbols using predicates over the infinite alphabet. This also has automata counterparts, called symbolic automata [8] and symbolic regular expressions [21]. These advantages outweigh the disadvantage of unboundedness being undecidable. We identify a fragment for which it is decidable, even for symbolic automata.\nRelated works Regular expressions are extended in [15] with operators to handle quantitative data for processing data streams. Defining windows is a basic construct in our formalism, but in [15], windows have to be defined as derived operators or written in external code. A model called data transducers is used in [3] for implementing data stream processors, but again windows are not part of the core specification language. In [12], a formal framework based on models of computation is developed for complex event processing. They also work on data streams, but windows as we consider here are not of particular interest there. Algebraic systems for generating windows from streams are considered in [17,19], and they study properties of window definitions that are useful for query optimization and related static analysis tasks. Their goal is not to integrate window definitions in the syntax of query languages, which we do here."
        },
        {
            "heading": "2 Symbolic Automata, Expressions and MSO",
            "text": "We assume that data streams are infinite sequences of letters from an infinite alphabet \u03a3. Given a word w \u2208 \u03a3\u2217 and i, j \u2208 N, w[i : j] represents the contiguous substring of w starting from ith index to jth index, both inclusive. We start indexing from 0. Let w[i] = w[i : i] and w[: k] be the suffix of w of length k.\nWe use symbolic automata and MSO. The results given in this section are already known, or easy adaptations of similar results for finite alphabets. Proofs and some details are moved to the appendix due to space constraints. We refer to [8,7,21] for details. In standard automata and MSO, transitions and atomic formulas can check that the symbol at a position is equal to some particular letter in a finite alphabet. In Symbolic automata and MSO, we can instead check that the symbol at a position satisfies some property specified in first-order logic. For example, an atomic formula of symbolic MSO can check that the input symbol is an even number, which can be specified in first order logic over N with addition.\nDefinition 1. An alphabet theory is a tuple A = (\u03a3, V, \u03a8V ) such that \u03a3 is an infinite alphabet and \u03a8V is a set of first-order formulas with free variables V closed under boolean connectives {\u2228,\u2227,\u00ac} with \u22a5,\u22a4 \u2208 \u03a8V . Given \u03c8 \u2208 \u03a8V and a valuation \u03bd : V \u2192 \u03a3, it should be decidable to check whether \u03bd |=A \u03c8.\nWe use |=A to denote the models relation in the alphabet theory, to distinguish it from models relation in other logics. We use a variation of symbolic automata that can read symbols in the previous k positions, for a fixed k, in addition to the current symbol. They are called k-symbolic lookback automata (k-SLA), similar to k-symbolic lookback transducers introduced in [10].\nDefinition 2. A k-SLA is a tuple S = (A, Q, q0, F, \u03b4) where A = (\u03a3, V, \u03a8V ) is an alphabet theory with V = (x\u2212k, . . . , x0) as a set of k + 1 lookback variables, Q is a finite set of states, q0 \u2208 Q is the initial state, F \u2286 Q is the set of final states, and \u03b4 : Q\u00d7Q\u2192 \u03a8V is the transition function.\nGiven a word w of length |w| = k + 1, vV (w) denotes the valuation such that vV (w)(x\u2212j) = w[k \u2212 j] for all j \u2208 [0, k]. We define the run of S on a word\nw \u2208 \u03a3\u2217 of length n \u2265 k + 1 to be a sequence (q0, q1, . . . , qn\u2212k\u22121) of states such that it starts from the initial state q0, and for all i \u2208 [k, n \u2212 1] we have vV (w[i\u2212k : i]) |=A \u03b4(qi\u2212k, qi\u2212k+1). If qn\u2212k\u22121 \u2208 F , then the run is accepting, and the word is accepted by S. Otherwise, the word is rejected. Run is not defined for words of length less than k + 1, which are rejected by all k-SLA.\nIf \u03b4(qi, qj) = \u03d5, then \u03d5 is called the guard of the transition qi \u03d5 \u2212\u2192 qj . A k-SLA is deterministic if for every q, q\u2032, q\u2032\u2032 \u2208 Q with q\u2032 6= q\u2032\u2032, \u03b4(q, q\u2032)\u2227 \u03b4(q, q\u2032\u2032) is unsatisfiable. We say a k-SLA is clean if every \u03b4(q, q\u2032) is either \u22a5 or is satisfiable. We can easily construct an equivalent clean k-SLA for any k-SLA by replacing all the unsatisfiable guards by \u22a5. The language accepted by S is L(S) = {w \u2208 \u03a3\u2217 | w is accepted by S}. The usual closure properties are satisfied by k-SLA.\nLemma 3 (Determinization). Given a k-SLA S = (A, Q, q0, F, \u03b4), we can construct a deterministic k-SLA S\u2032 = (A, Q\u2032, q\u20320, F \u2032, \u03b4\u2032) such that L(S) = L(S\u2032).\nWe complement languages of k-SLAs with respect to strings of length at least k+1: L(S) = (\u03a3k+1 \u00b7\u03a3\u2217) \\L(S). The following result follows from the previous one.\nLemma 4 (Complementation). Given a k-SLA S, we can construct a k-SLA S\u2032 such that L(S\u2032) = L(S).\nProduct construction works on k-SLA as usual. Given two k-SLA S1 = (A, Q1, q 1 0 , F1, \u03b41) and S2 = (A, Q2, q 2 0 , F2, \u03b42), the product of S1 and S2 is S = (A, Q \u00d7 Q\u2032, (q0, q \u2032 0), F, \u03b4) where F = {(q, q \u2032) | q \u2208 F1 and q \u2032 \u2208 F2} and \u03b4((q1, q2), (q \u2032 1, q \u2032 2)) = \u03b41(q1, q \u2032 1) \u2227 \u03b4(q2, q \u2032 2) for all q1, q \u2032 1 \u2208 Q and q2, q \u2032 2 \u2208 Q2.\nLemma 5 (Intersection). Given two k-SLA S1 = (A, Q1, q 1 0 , F1, \u03b41) and S2 = (A, Q2, q 2 0 , F2, \u03b42), let the product of S1 and S2 be S. Then, L(S) = L(S1)\u2229L(S2).\nThe languages of k-SLA are also closed under union, which can be proved as usual by taking disjoint union of two automata. We use a variant of concatenation, k-concatenation, denoted by \u00b7k. Given two strings w1 = wv and w2 = vw \u2032 with w,w\u2032 6= \u01eb and |v| = k, we define w1 \u00b7kw2 = wvw \u2032. If the last k letters of w1 do not exactly match with first k letters of w2, or length of either word is less than k+1, then the concatenation is undefined. The k-concatenation of two languages L1 and L2 is defined as L1 \u00b7kL2 = {wvw \u2032 \u2208 \u03a3\u2217 | wv \u2208 L1, vw \u2032 \u2208 L2 and |v| = k}.\nLemma 6. The languages of k-SLA are closed under k-concatenation.\nSymbolic regular expressions are regular expressions over infinite alphabets.\nDefinition 7. Given an alphabet theory A = (\u03a3 \u222a {\u03b5}, V, \u03a8V ), the set of Symbolic Regular Expressions (SRE) is defined by the following grammar: R ::= \u03d5 | R+R | R \u00b7k R | R \u2217, where \u03d5 \u2208 \u03a8V .\nThe semantics of SRE are defined as follows: L(\u03d5) := {w | |w| = k+1, vV (w) |=A \u03d5}, L(R1 +R2) := L(R1)\u222aL(R2), L(R1 \u00b7k R2) := L(R1) \u00b7k L(R2) and L(R\n\u2217) := \u22c3\nn\u2208N\nL(Rn).\nUsing the same constructions as those used for finite alphabets, we can prove that symbolic regular expressions and k-SLA are equally expressive.\nWe recall Symbolic Monadic Second Order (S-MSO) logic from [7].\nDefinition 8. Given an alphabet theory A = (\u03a3, V, \u03a8V ), The syntax of S-MSO over A is defined by the following grammar: \u03c6 ::= [\u03d5](x) | x < y | X(x) | \u00ac\u03c6 | \u03c6\u2227 \u03c6 | \u2203x \u03c6 | \u2203X \u03c6, where \u03d5 \u2208 \u03a6V , lower case letters x, y, z are first-order variables and upper case letters X,Y, Z are second order variables.\nLet \u03c6 be an S-MSO formula with free variables FV (\u03c6). Consider a word w \u2208 \u03a3\u2217 with |w| \u2265 k and a map \u03b8 : FV (\u03c6) \u2192 [k\u22121, |w|\u22121]\u222a2[k\u22121,|w|\u22121], where the first order variables are mapped to [k\u2212 1, |w|\u2212 1] and second order variables are mapped to 2[k\u22121,|w|\u22121]. Given a w_block = a0 . . . ak of size k + 1, we define \u03bd[w_block] to be a map with \u03bd[w_block](xi) = ai for all i. If w_block = \u01eb, then we define \u03bd[\u01eb](xi) = \u01eb. The semantics of S-MSO with k-lookback is as follows. For atomic formulas [\u03d5](x), w, \u03b8 |= [\u03d5](x) \u21d4 vV (w[\u03b8(x) \u2212 k : \u03b8(x)]) |=A \u03d5. The semantics is extended to the rest of the syntax as usual, the details of which can be found in the appendix. To prove that k-SLA and S-MSO are equally expressive, the following extension of alphabet theories are helpful.\nDefinition 9. The extension of an alphabet theory A = (\u03a3, V, \u03a8V ) with a boolean variable x is a new alphabet theory Ax = (\u03a3 \u00d7 {0, 1}, V, \u03a8V \u00d7 {x = 0, x = 1}) such that for any a \u2208 \u03a3 and b, b\u2032 \u2208 {0, 1}, (a, b) |= (\u03d5, x = b\u2032) if and only if a |=A \u03d5 and b = b\n\u2032. We denote the extension by n boolean variables x1, x2, . . . , xn by A(x1,x2,...,xn).\nGiven a word w and a map \u03b8, let us define w\u03b8 \u2208 (\u03a3 \u00d7 {0, 1} n+m)\u2217 as\nw\u03b8[i] = (w[i], e1(\u03b8(x1), i), . . . , e1(\u03b8(xn), i), e2(\u03b8(X1), i), . . . e2(\u03b8(Xm), i)),\nwhere e1(n, i) = 1 if n = i else 0, and e2(I, i) = 1 if i \u2208 I else 0. Let \u03c6(x1, . . . , xn, X1, . . . , Xm) be a S-MSO formula with first order free variables {x1, . . . , xn} and second order free variables {X1, . . . , Xn}. A construction similar to that of MSO over finite alphabets will give a k-SLA S over the extended alphabet theory A(x1,...,xn,X1,...,Xm), such that w, \u03b8 |= \u03c6 if and only if the word w\u03b8 \u2208 (\u03a3 \u00d7 {0, 1} n+m)\u2217 is accepted by S.\nConversely, given a k-SLA over the alphabet theory A = (\u03a3, V, \u03a8V ), we can construct a S-MSO formula \u03c6 over A with no free variables such that w \u2208 \u03a3\u2217 is accepted by S if and only if w |= \u03c6 using the standard automata to MSO construction and replacing the letters with predicates \u03d5 \u2208 \u03a6V .\nThe expressive power of symbolic lookback automata and symbolic MSO are useful for designing parsing algorithms and specification languages as we will see subsequently. But the expressive power is enough to simulate Turing machines and static analysis problems are undecidable.\nTheorem 10. The problems of checking non-emptiness of languages of k-SLAs and satisfiability of S-MSO formulas are undecidable.\nProof (sketch). The automata work over infinite domains and transitions can relate values at a position with previous values. This can be used to simulate counter machines. The domain is the set N of natural numbers and the counters are simulated by numerical fields in the input stream. An incrementing transition of the counter machine can be simulated by a transition of a k-SLA, by requiring that the next value of the corresponding field is one more than the previous one. Decrementing and zero testing transitions can be similarly simulated. This is a standard trick used for models dealing with infinite domains, e.g., [10,9]. \u2293\u2294"
        },
        {
            "heading": "3 Defining Windows with S-MSO",
            "text": "A window in a data stream is a pair (ib, ie) of indices that indicate where the window begins and ends. In this section, we explain how windows can be defined with S-MSO over an alphabet theory A, and also show an expressively equivalent representation using symbolic regular expressions. Some proofs have been moved to the appendix due to space constraints.\nWe designate first-order variables xb, xe for denoting the beginning and ending indices of windows. We use S-MSO formulas to specify which indices can begin and end windows. The end of a window should be detected as soon as it arrives in the stream, so the decision about whether a position is the end of a window should be made based only on the stream data that has been read so far. We enforce this in S-MSO formulas by guarding the quantifiers.\n\u03c6 := [\u03d5](x) | x < x\u2032 | X(x) | \u00ac\u03c6 | \u03c6 \u2228 \u03c6 | \u2203x \u2264 xe \u03c6 | \u2203X \u2286 [0, xe] \u03c6 (1)\nThe above sytax is a guarded fragment of S-MSO \u2014 \u2203x \u2264 xe \u03c6 is syntactic sugar for \u2203x(x \u2264 xe \u2227 \u03c6) and \u2203X \u2286 [0, xe] \u03c6 is syntactic sugar for \u2203X(\u2200y(X(y) \u21d2 y \u2264 xe) \u2227 \u03c6).\nDefinition 11. Let xb \u2264 xe \u2227 \u03c6(xb, xe) be a S-MSO formula in the guarded fragment given in (1), with xb and xe being free variables. A pair (ib, ie) of indices of a word w is said to be a window recognized by xb \u2264 xe \u2227 \u03c6(xb, xe) if ib \u2264 ie and w |= \u03c6(ib, ie) 3.\nTo reduce clutter, we don\u2019t explicitly write the condition xb \u2264 xe but assume that it is present in all window specifications. Whether a pair (ib, ie) is recognized as a window by \u03c6(x, y) in a word w depends only on the word w[0 : ie].\nEnd users of streaming data processors may not be familiar with logic based languages. It has been observed [20] that specifications based on regular expressions are easier to understand compared to those based on logic. Next we give a way of defining windows based on symbolic regular expressions, that is expressively equivalent to the one above based on S-MSO.\nDefinition 12. A window expression is a set R = {(r1, r \u2032 1), . . . (rl, r \u2032 l)}. For every i, ri, r \u2032 i are symbolic regular expressions over an alphabet theory A.\n3 The authors thank an anonymous referee for suggesting this way of defining windows, and its equivalence with union of pairs of regular expressions.\nGiven a word w \u2208 \u03a3\u2217, a pair (ib, ie) \u2208 [k, |w| \u2212 1] 2 is said to be recognized as a window by R if there exists (r, r\u2032) \u2208 R such that w[0 : ib \u2212 1] \u2208 L(r) and w[ib \u2212 k : ie] \u2208 L(r \u2032).\nLemma 13. Given a S-MSO formula \u03c6(xb, xe) in the guarded fragment given in (1), we can effectively construct a window expression R = {(r1, r \u2032 1), . . . , (rl, r \u2032 l)} such that for every word w, the set of windows recognized by \u03c6(xb, xe) is same as that recognized by R.\nProof (Sketch). We take the automaton corresponding to the S-MSO formula \u03c6 and split it at a transition that reads the symbol at position xb. Each such split results in a pair of expressions. \u2293\u2294\nLemma 14. Given a window expression R = {(r1, r \u2032 1), . . . , (rl, r \u2032 l)} over A, we can effectively construct a S-MSO formula \u03c6(xb, xe) in the guarded fragment given in (1) such that, for every word w, the set of windows recognized by R is same as that recognized by \u03c6(xb, xe)."
        },
        {
            "heading": "4 Stream Processor for Window Expressions",
            "text": "In this section, we show a skeleton stream processor that takes window expressions and incoming streaming data and produces windows as specified in the expressions. For modeling purposes, we treat a stream as an infinite string in \u03a3\u03c9. The data present in a window is usually processed to produce an aggregate value, such as the average of some field, sum of all entries in a window etc. If some positions of the stream belong to multiple windows, performing the same computation multiple times is inefficient. One way to avoid this is to sub-divide windows into panes [14] and then aggregate the values of those panes that make up a window. For example, suppose the average of a numerical field is to be computed for every window. If within the span of a window, other windows start, then the window is sub-divided into panes as shown below.\nFor each pane, the average and number of entries in the tuple is computed and stored. When the window ends, these can be used to compute the average of the\nwhole window. The exact computation to be performed in panes is application dependent. We assume that a class is provided to do that computation. In our skeleton processor, we ensure that the class methods are called at the correct positions in the stream.\nThe skeleton processor is shown in Algorithm 1. For simplicity of presentation, we show the processor for one pair of expressions (r, r\u2032). We further assume that the pair has been converted to a pair (PA,WA) of prefix and window k-SLA, both deterministic. It is routine to extend the processor to handle multiple pairs. The variable PrefixState stores the current state of the prefix automaton PA. The variable WindowStartIndices stores a mapping WindowStartIndices : Q \u2192 2N, which tracks multiple copies of the window automaton WA, as explained next. A copy of WA is started at any position of the input stream that is potentially a start position of a window. If such a copy started at position x is currently in state q, then x \u2208 WindowStartIndices(q). In other words, all the copies of WA that are currently in state q are tracked by storing their starting positions in WindowStartIndices(q). The formal proof of correctness of the processor is established in the following two results.\nLemma 15 (Main loop invariant). The following hold at the start of every iteration of the main loop of the processor (line 9), where n is the position of the last symbol read from the input channel I :\n1. PrefixState stores the state of PA after reading w[0 : n]. 2. For every position i < n such that PA reaches a final state on reading\nw[0 : i], if initWA w[i+1:n] \u2212\u2212\u2212\u2212\u2212\u2212\u2192 q and q is not a dead-state, then i + 1 \u2208 WindowStartIndices(q).\nCorollary 16. The processor shown in Algorithm 1, given the input pair (PA,WA) and the stream w, will add (x + 1, y) to the output stream iff w[0 : x] \u2208 L(PA) and w[x + 1 : y] \u2208 L(WA)."
        },
        {
            "heading": "5 Examples from Practical Applications",
            "text": "In this section, we give some examples from practical applications of stream data processing, to illustrate how S-MSO or symbolic regular expressions can express queries with clearly specified semantics. 1. Genome Sequencing: As the size of data involved in analyzing DNA sequences is increasing, recently there has been interest in employing streaming algorithms [16]. A fundamental object in genome sequence analysis is k-mer. We next explain what they are and how they can be naturally modeled as windows. We first present the definition in words, as they are usually presented:\n1. We have a set of DNA fragments, where each fragment is called a read. Each read is a string of \u2018A\u2019, \u2018T\u2019, \u2018C\u2019, and \u2018G\u2019. 2. A k-mer is a contiguous substring of length k of a read. 3. The p-minimizer of a k-mer is the lexicographically smallest substring in the k-mer with length p.\nInput : A pair of k-SLAs R = (PA,WA), channels I,O for input, output Result: Stream from I decomposed into windows according to R and output into O Nomenclature: Q,Q\u2032: set of states of PA,WA Function main is\nPrefixState := q0 ; /* q0 is the initial state of PA */ WindowStartIndices(q\u2032) := \u2205 for all q\u2032 \u2208 Q\u2032; w_block := read first k elements of I; x := k \u2212 1; p := new Pane(StartIndex = 0, EndIndex = k \u2212 1); Update value of p to the aggregate of w_block; P := {p} ; /* P is the set of Panes */\n9 while input stream I is live do\n\u03c3 := next item in I ; w_block := w_block[\u2212k + 1 : 0] \u00b7 \u03c3; startNewPane := False; if PrefixState is a final state of PA then\n14 Add the index (x+ 1) to WindowStartIndices(initWA) (initWA is the initial sate of WA);\nstartNewPane := True;\nend foreach\n{qf \u2208 Q \u2032 | qf is a final state of WA,WindowStartIndices(qf ) 6= \u2205} do\n18 Add (x\u2032, x) to the output stream O for each index x\u2032 \u2208 WindowStartIndices(qf ), along with the aggregate of those panes in P that are between x\u2032 and x;\nstartNewPane := True;\nend foreach {qd \u2208 Q \u2032 | qd is a dead state of WA} do\nWindowStartIndices(qd) := \u2205; end if startNewPane == True then p.EndIndex = x; p = newPane(); P .add(p); end p.add_element(\u03c3) ; /* update the current pane with the newly read symbol */ Let xmin be the minimum of the indices in the range of WindowStartIndices ; From P , delete those panes that end before xmin; Update PrefixState to new state of PA by reading w_block; foreach {q \u2208 Q\u2032} do\nQpred = {q \u2032 \u2208 Q\u2032 | q is the w_block successor of q\u2032 in WA};\n33 WindowStartIndices \u2032(q) = \u222aq\u2032\u2208QpredWindowStartIndices(q \u2032);\nend\n35 WindowStartIndices := WindowStartIndices \u2032 ; /* simultaneous update */\nx += 1;\nend\nend\nAlgorithm 1: Skeleton stream processor to extract windows from a stream\n4. A supermer is the merge of all the consecutive k-mers that have same pminimizer.\nGiven a string m = m1m2 . . .mp, we can convert it into an integer using 2-bit compression. Let \u03a3\u2032 = {00, 01, 10, 11}. We define the 2-bit compression via a monoid homomorphism f : \u03a3\u2217 \u2192 \u03a3\u2032\u2217 defined as f(A) \u2192 00, C \u2192 01, G \u2192 10, and T \u2192 11. The string m will be mapped to a 2m bit sized binary string f(m), which we interpret as an integer. We reserve the variable k as we use it for k-SLA, and use the term t-mer instead. We will now describe the window expression that can be used to capture t-mers and supermers in our formalism:\n1. A read is a string w \u2208 \u03a3\u03c9, where \u03a3 = {A, T,C,G} from the input stream I. 2. We apply the window expression (True)\u2217, (True)p on I and pass on the out-\nput to OMIN . We also output an aggregate function for the windows, which will be the application of 2-bit compression f . We put this in a new integer field x in the output stream, which will carry the lexicographic index of the substring in the last p positions. 3. Let k = t be the number of lookback variables, and define the notation min (x[a, b]) := min (xa, xa+1, . . . , xb) where \u2212t \u2264 a < b \u2264 0. We apply the window expression (PA2,WA2) on OMIN and pass on the output to OKMER_MIN , where PA2 = True + ((True)\n\u2217 \u00b7k (min(x[\u2212k + p,\u22121] 6= min[x[\u2212k + p + 1, 0])) and WA2 = (min(x[\u2212k + p,\u22121] = min[x[\u2212k + p + 1, 0])\u2217 \u00b7k (min(x[\u2212k + p,\u22121] 6= min[x[\u2212k + p+ 1, 0]). 4. As we can only decide if the minimizer of two consecutive t-mers are different by reading to the point where the minimizers change, we will have to postprocess the output stream OKMER_MIN as follows: for each window (x, y) \u2208 OKMER_MIN , the window (x\u2212 1, y \u2212 1) is passed to the output stream O.\nThe final output stream O gives us all the supermers w.r.t to the t-mers and the p-minimizers. 2. Arrhythmia Detection: Implantable Cardioverter Defibrillator (ICD) is a battery powered device that delivers an electric shock to restore normal heartbeat if it detects abnormal heart rhythm, called arrhythmia. One of the algorithms used in ICDs is Wavelet Peak Maxima (WPM), which we write using window expressions here. The medical background needed to understand this algorithm can be found in [1], which also explains the structure of the data stream fed to the WPM algorithm. Explaining that structure is beyond the scope of this paper; for our purposes, it is enough to assume that the data stream is a sequence of pairs (t, r) where t represents time and r is a real number representing the value of some spectrogram at time t. In a stream (t1, r1), (t2, r2), . . ., a pair (ti, ri) is said to be peaking if ri \u2265 max(ri\u22121, ri+1) (i.e., ri is a local maximum) and ri \u2265 p for some pre-defined threshold p.\n1. The first step in WPM is to check whether a pair is peaking or not. This can be done by using the theory of reals as alphabet theory with three lookback variables V = {x\u22122, x\u22121, x0}. Given an element a = (t, r), let us define T (a) = t and R(a) = r. Let OPEAK be the output stream on\nprocessing the input stream with the window expression R = (PA,WA), where PA = (True)\u2217 and WA = (True) \u00b7k (R(x\u22121) > R(x\u22122) \u2227 R(x\u22121) > R(x0) \u2227R(x\u22121) > p). 2. The second step is to find the time difference between two consecutive peaks. Note that each element of the stream OPEAK is a window wi = (t, r)(t\n\u2032, r\u2032), such that the first pair (t, r) is peaking. Let us denote the first pair of this window by wi[0]. We process this stream with the window expression (PA\u2032,WA\u2032) where PA\u2032 = (True)\u2217 and WA\u2032 = (True)2, and the aggregate function of the pane handler, given the new window wi \u00b7wi+1, which is concatenation of two consecutive windows obtained in previous step, outputs T (wi+1[0])\u2212 T (wi[0]).\nThe full implementation of WPM involves some more details but these two are the main steps. 3. Trends in stock markets: Sequence of stock prices as they are traded in the market is a natural data stream. Detecting trends in such streams is widely used in both stock markets and algorithmic trading [18]. Suppose p1, p2, . . . is a sequence of prices of a stock being traded. Suppose one wishes to check whether the current price has gone up compared to the previous one. This can be done by using the theory of reals with one lookback variable V = {x\u22121} as the alphabet theory. We use the window expression (PA,WA) where PA = True\u2217 and WA = (x0 > x\u22121). If one wishes to check whether the price have gone up consecutively k times, k lookback variables can be used with a similar expression. One can write quite complicated patterns by using appropriate window expressions."
        },
        {
            "heading": "6 Memory Requirement",
            "text": "In the skeleton processor shown in Algorithm 1, WindowStartIndices and P are variables that store starting positions of windows and panes respectively. If the number of starting positions or the number of panes is too big, the memory required to store them will also be large. Here we address the question of whether the memory requirement can be unbounded. The answer to this depends on whether the input data stream follows any pattern in relation to the window expressions. For example, let \u03a3 = {a, b} and consider the window expression (a+ b)\u2217, a\u2217b. A window can start at any position and ends at the letter b. If this is applied to the input stream a\u03c9, an instance of the window automaton WA will be started at every position, but none of them will be ever removed, because b never occurs. This will cause unboundedness. However, the same expression will be bounded if we apply it to a stream in which we know that ac is not an infix, for some constant c.\nIf we want to use automata to specify what input streams are expected, those automata will have a particular structure. Suppose a processor has read an input stream up to some position and the question is whether it should be deemed acceptable according to the specification of what input streams are expected. The answer would be \u201cyes\u201d if it is possible to extend the stream so\nthat the resulting string is accepted by the specifying automaton. Hence, any prefix of an acceptable string is also acceptable. So the specifying automaton is prefix closed. Any state from which an accepting state can be reached is also an accepting state. If the automaton reaches a non-accepting state, it will never reach an accepting state again. We can think of a specifying automaton S as being in \u201caccepting zone\u201d or in \u201crejecting zone\u201d, it starts in accepting zone and switches to rejecting zone at most once. We call such automata input specifiers. A stream is said to conform to an input specifier if it never enters the rejecting zone while reading the stream.\nGiven a window expression and an input specifier, we address the question of whether an input stream that conforms to the input specifier can potentially cause the stream processor to require unbounded memory.\nDefinition 17 (Bounded memory). A window expression given in the form of a pair (PA,WA) of k-SLAs is said to process any input stream conforming to a given input specifier S within bounded memory, if the size of WindowStartIndices and the set of panes P in Algorithm 1 are bounded by some numbers N1, N2 \u2208 N respectively, while processing any stream that conforms to S.\nChecking the bounded memory property is undecidable, just like the problem of checking non-emptiness of languages of k-SLAs. We identify a fragment for which it is decidable. We consider alphabet theories (\u03a3, V, \u03a8V ) in which \u03a8V is restricted to having only Boolean combinations of atomic formulas of the form R(x1, . . . , xl), where R is a relation symbol. Even under this restriction, checking non-emptiness of the languages of k-SLAs is undecidable, if the equality relation and one more relation symbol are present (see [9, Theorem 10.1]).\nWe further restrict alphabet theories by adapting the concept of completion property [9, Section 4]. Suppose \u03a6 is a set of atomic formulas over the set of variables V , V \u2032 \u2286 V and \u03a6 \u21be V \u2032 \u2286 \u03a6 is the set of those formulas in \u03a6 that only use variables in V \u2032. An alphabet theory is said to have the completion property if for every satisfiable set of formulas \u03a6, for every subset V \u2032 \u2286 V and every partial valuation v\u2032 : V \u2032 \u2192 \u03a3 that satisfies all the constraints in \u03a6 \u21be V \u2032, there exists an extension v : V \u2192 \u03a3 of v\u2032 that satisfies all the constraints in \u03a6. The theory of integers with the binary relation < does not satisfy the completion property. Consider the set of formulas {x < y, x < z, z < y} and a partial valuation v\u2032 : {x 7\u2192 1, y 7\u2192 2}. It satisfies x < y, but it cannot be extended to include a mapping for z such that x < z and z < y (i.e., z is strictly between x and y), since there is no integer strictly between 1 and 2. The theory of rational or real numbers with < satisfy the completion property. For theories with linear orders, completion property is closely related to denseness of the domain [9, Lemma 5.3].\nNow we give a characterization in terms of automata for checking the bounded memory property.\nLemma 18. Fix an alphabet theory having the completion property. Given a window expression in the form of a pair (PA,WA) of deterministic k-SLAs and an input specifier S, the size of WindowStartIndices and the set of panes P in Algorithm 1 will be unbounded on processing streams conforming to S iff there exist words w1, w2, w3 and a state q of WA such that\n1. There is a path from q to a final state via a path in which no transition has the guard \u22a5 (we say that q is not a dead state in this case), 2. in the input specifier S, initS w1\u2212\u2192 s w2\u2212\u2192 s w3\u2212\u2192 s, such that s is an accepting\nstate, 3. initPA w1\u2212\u2192 p w2\u2212\u2192 p w3\u2212\u2192 p, where p is a final state of PA, 4. initWA w1[:k]w2 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 q, q w1[:k]w2 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 q w3\u2212\u2192 q and 5. the runs s w1[:k]w2 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 s w3\u2212\u2192 s, p w1[:k]w2 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 p w3\u2212\u2192 p, q w1[:k]w2 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 q\nw3\u2212\u2192 q satisfy the following: the sequence of transitions used while reading the first k letters of w2 is the same sequence used for reading the first k letters of w3.\nProof. (\u21d2) Let wn be a stream conforming with S for which the processor adds at least n indices in the WindowStartIndices map. There must exist an increasing sequence of positions (or time instants) (ti)i such that on processing wn[0 : ti], the processor adds a position to WindowStartIndices(initWA) for the i\nth time that will not be removed from the map on further processing, at least till the nth position is added.\nLetQPA, QWA, QS be the set of states in PA,WA, S respectively. Let TPA, TWA and TS be the set of k-tuples of transitions in PA,WA and S respectively. Let T be the set of all functions of the form QWA \u2192 TWA. We will use the set of colors C = T \u00d7 2QWA\u00d7QWA to color the edges of a graph we define later. Let r be the Ramsey number R(n1, n2, . . . , n|C|), where n1 = n2 = . . . = n|C| = 2|QPA||QS ||TPA||TS|+ 1. We set n = r and construct a complete graph G with the set {ti} as vertices. For every two instants ti, tj with i < j, we add an edge with color (Ti, {(q1, q2) | q1, q2 \u2208 QWA, q1 wn[ti+1\u2212k:tj ] \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 q2}), where Ti \u2208 T is the function such that Ti(q) is the sequence of k transitions executed in WA if it starts at the instant ti in state q. We infer from Ramsey\u2019s theorem that the graph G will have a monochromatic clique of size 2|QPA||QS ||TPA||TS |+ 1. We infer from Pigeon Hole Principle that this monochromatic clique contains at least three time instants, say ti < tj < tl, in which PA, S are in the same pair of states, say p, s, which are accepting states of PA, S. Also, the sequence of k transitions executed in PA (resp. S) from ti, tj, tl are same. Now, consider the instances of window automata WA initiated at the instants ti, tj and tl. Let initWA wn[ti+1\u2212k:tj ] \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 q for some state q. Since the edges between ti, tj , tl all have the same color, initWA wn[ti+1\u2212k:tl] \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 q. Since WA is deterministic and ti < tj < tl, we can split initWA wn[ti+1\u2212k:tl] \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 q into initWA wn[ti+1\u2212k:tj ] \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 q and q wn[tj+1\u2212k:tl] \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 q. Since (ti, tj) and (tj , tl) have the same colour, we infer that q wn[ti+1\u2212k:tj ] \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 q. Let w1 = wn[0 : ti], w2 = wn[ti+1 : tj ] and w3 = wn[tj+1 : tl]. We have initPA w1\u2212\u2192 p w2\u2212\u2192 p w3\u2212\u2192 p, initS w1\u2212\u2192 s w2\u2212\u2192 s w3\u2212\u2192 s, p (resp. s) is accepting in PA (resp. S), initWA w1[:k]w2 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 q, q w1[:k]w2 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 q w3\u2212\u2192 q and the runs s w1[:k]w2 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 s w3\u2212\u2192 s, p w1[:k]w2 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 p w3\u2212\u2192 p, q w1[:k]w2 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 q\nw3\u2212\u2192 q satisfy the following: the sequence of transitions used while reading the first k letters of w2 is the same sequence used for reading the first k letters of w3.\n(\u21d0) We will prove that for every i \u2265 0, there is a word wi2 satisfying the following properties. Let wi = w1 \u00b7 w 0 2 \u00b7 \u00b7 \u00b7w i 2. We will prove that for all i \u2265 0, initS wi \u2212\u2192 s, initPA wi \u2212\u2192 p and initWA w02\u2212\u2192 q w12\u2212\u2192 \u00b7 \u00b7 \u00b7 q wi2\u2212\u2192 q. For every i, the processor will add the index |w1| + |w 0 2 \u00b7 \u00b7 \u00b7w i 2| to WindowStartIndices(initWA). The state initWA will be updated to q after reading w i+1 2 and keeps coming back to q after reading wj2 for j > i + 1. None of these added indices will be removed, since q is not a dead state. Therefore, there will be n indices in the map WindowStartIndices after reading w1 \u00b7w 0 2 \u00b7 \u00b7 \u00b7w n+1 2 . All w i 2 will be built from w2 using the completion property, ensuring that wi+12 makes the automata behave exactly like wi2 did. We will do this with an inductive construction, for which we need to introduce some terminology.\nSuppose w is a stream. Consider the substring of w between positions i\u2212 k to i. We would like to capture the constraints put on this substring by some transition \u03c4 executed by an automaton at the (i + j)th position, where j \u2208 [0, k]. For that transition, the values for lookback variables x\u2212k, . . . , x\u2212j are given by w[i \u2212 k + j], . . . , w[i] respectively. For a transition \u03c4 and j \u2208 [0, k], let \u03a6(\u03c4) \u21be j be the set of all atomic formulas \u03c6 occurring in the guard of \u03c4 such that only the lookback variables x\u2212k, . . . , x\u2212j are used in \u03c6. For such an atomic formula \u03c6, let \u03c6[\u2192 j] be the formula obtained from \u03c6 by replacing every lookback variable x\u2212l by x\u2212l+j (this results in the values for lookback variables x\u2212k+j , . . . , x0 of \u03c6[\u2192 j] being given by w[i\u2212k+ j], . . . , w[i] respectively). In the run initS w1\u2212\u2192 s w2\u2212\u2192 s w3\u2212\u2192 s, let \u03c4i be the transition executed while reading the ith letter of w2w3. For i \u2208 [0, |w2| \u2212 1], the constraints satisfied by the substring w1w2[|w1| + i \u2212 k : |w1| + i] for this run is \u222aj\u2208[0,k]{\u03c6[\u2192 j] | \u03c6 \u2208 \u03a6(\u03c4i+j) \u21be j, vV (w1w2[|w1|+ i\u2212 k : |w1|+ i]) |= \u03c6[\u2192 j]} \u222a \u222aj\u2208[0,k]{\u00ac\u03c6[\u2192 j] | \u03c6 \u2208 \u03a6(\u03c4i+j) \u21be j, vV (w1w2[|w1|+i\u2212k : |w1|+i]) 6|= \u03c6[\u2192 j]}. Let us call this set \u0393 S i . We similarly define the set \u0393Pi for the run initPA w1\u2212\u2192 p w2\u2212\u2192 p w3\u2212\u2192 p. In the run q w1[:k]w2 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 q w3\u2212\u2192 q\u2032, let \u03c4i be the transition executed while reading the i\nth letter of w2w3. For i \u2208 [0, |w2|\u22121], the constraints satisfied by the substring (w1[: k]w2)[i : i+k] for this run is \u222aj\u2208[0,k]{\u03c6[\u2192 j] | \u03c6 \u2208 \u03a6(\u03c4i+j) \u21be j, vV ((w1[: k]w2)[i : i : k]) |= \u03c6[\u2192 j]} \u222a \u222aj\u2208[0,k]{\u00ac\u03c6[\u2192 j] | \u03c6 \u2208 \u03a6(\u03c4i+j) \u21be j, vV ((w1[: k]w2)[i : i+ k]) 6|= \u03c6[\u2192 j]}. Let us call this set \u0393Wi .\nWe claim that for every i \u2265 0, there exists string wi2 such that |w i 2| = |w2|\nand the following property is satisfied. Recall that we defined wi = w1 \u00b7w 0 2 \u00b7 \u00b7 \u00b7w i 2. We let w\u22121 = w1 for convenience. For every i \u2265 0 and every j \u2208 [0, |w2| \u2212 1], we claim that vV (w\ni[|wi\u22121| + j \u2212 k : |wi\u22121| + j]) satisfies all the constraints in \u0393Sj \u222a \u0393 P j \u222a \u0393 W j . This is sufficient to establish the result, since all the automata S,PA,WA can repeat the same sequence of transitions for wi+12 as the sequence for wi2. We will prove the claim by induction on i. For the base case i = 0, we set w02 = w2 and the claim is satisfied by definition. For the induction step, suppose we have defined up to wi2 as claimed. We define w i+1 2 [j] for every j \u2208 [0, |w2| \u2212 1] by secondary induction on j. For the base case, j = 0. By the primary induction hypothesis, vV (w\ni[: k + 1]) satisfies all the constraints in \u0393S|w2|\u22121 \u222a \u0393 P |w2|\u22121 \u222a \u0393W|w2|\u22121. Let V \u2032 = V \\ {x0}. Since the first k transitions for\nw3 are same as the first k transitions for w2, we infer that vV \u2032(w i[: k]) satisfies those formulas in \u0393S0 \u222a\u0393 P 0 \u222a\u0393 W 0 that don\u2019t use x0. By the completion property, vV \u2032(w i[: k]) can be extended to include a valuation for x0 so that the resulting valuation satisfies all the formulas in \u0393S0 \u222a \u0393 P 0 \u222a \u0393 W 0 . This new valuation for x0 is the value we set for w i+1 2 [0]. The induction step for j + 1 is similar. This completes the induction step and hence establishes the result. \u2293\u2294\nThe above characterization can be used to obtain a decision procedure for checking the bounded memory property, provided the alphabet theory itself is decidable. This involves checking that there exist words w1, w2, w3 as claimed above and can be done using symbolic models, which decompose the problem into an automata theoretic problem over finite alphabets and satisfiability of formulas in the alphabet theory. A full description of this method is beyond the scope of this paper. We mention that we can prove decidability for bounded memory property for decidable alphabet theories that have the completion property by using techniques similar to those of [9, Theorem 4.4] (attributed originally to [4]), which when converted to terminology used in this paper, states that checking non-emptiness of the language of a k-SLA has the same complexity as checking satisfiability of a finite set of formulas in the alphabet theory, provided it has the completion property."
        },
        {
            "heading": "7 Discussion and Future Work",
            "text": "A commonly used feature is to consider data from multiple streams simultaneously to perform computations. It would be interesting to explore how to integrate this feature into the formal framework. Another question is what fragments have decidable bounded memory problem, besides the completion property. It would also be interesting to find the complexity of this problem and heuristics and algorithms that can perform well in practice."
        },
        {
            "heading": "A Proofs from Section 2",
            "text": "Proof (Lemma 3). We can assume, WLOG, that S is clean. Let q \u2208 Q and q \u2286 Q. We will first define the following useful notation.\n\u03b4S(q) = {(q, \u03b4(q, q \u2032), q\u2032) 6= \u22a5 | q\u2032 \u2208 Q}\n\u03b4S(q) = \u222aq\u2208q\u03b4S(q)\nTarget(t) = {q\u2032 | (q, \u03d5, q\u2032) \u2208 t}\nCond((q, \u03d5, q\u2032)) = \u03d5\nLet Q\u2032 = 2Q. To define the transition function \u03b4\u2032, we will define the outgoing transition from each q \u2286 Q. For each subset t \u2286 \u03b4S(q) let\n\u03d5t = ( \u2227\nt\u2208t\nCond(t)) \u2227 ( \u2227\nt\u2208\u03b4S(q)\\t\n\u00acCond(t))\n.\nIf \u03d5t is satisfiable, then define \u03b4 \u2032(q, T arget(t)) = \u03d5T , otherwise \u03b4 \u2032(q, T arget(t)) = \u22a5. For all sets q\u2019 \u2286 Q which are not equal to Target(t) for any t \u2286 \u03b4S(q), we define \u03b4\u2032(q,q\u2019)) = \u22a5.\nDefine q\u20320 = {q0} and F \u2032 = {q \u2286 Q | \u2203q \u2208 q.q \u2208 F}.\nTo see that S\u2032 is deterministic, note that for every two outgoing transition from a state q \u2208 Q\u2032 with guard \u03d5t and \u03d5t\u2019 with t 6= t\u2019, \u03d5t \u2227 \u03d5t\u2019 is unsatisfiable. It follows because, WLOG, if t \u2208 t and t /\u2208 t\u2019, then \u03d5t will have the conjunct Cond(t) while \u03d5t\u2019 will have \u00acCond(t).\nIt\u2019s trivial to verify that S\u2032 accepts the same language as S.\nProof (Lemma 4). Let L be any k-SLA-language, and let S = (A, Q, q0, F, \u03b4) be a k-SLA accepting L. Assume, WLOG, that S is deterministic. Define S\u2032 = (A, Q, q0, Q\\F, \u03b4). We claim that S\n\u2032 accepts the language L. Consider any word w \u2208 L. It will have a unique run in S to a final state, and hence it will be rejected by S\u2032. If w /\u2208 L and |w| \u2265 k+1, then it will have a unique run in S to a non-final state, which will be a final state in S\u2032, and hence w will be accepted by S\u2032.\nProof (Lemma 6). Let k-SLA S1 = (A, Q1, q 1 0 , F1, \u03b41) and S2 = (A, Q2, q 2 0 , F2, \u03b42). The construction is similar to that in case of finite automata. Formally, construct a k-SLA S = (A, Q1 \u222aQ2, q 1 0 , F2, \u03b4) with\n\u03b4(q, q\u2032) =\n\n   \n   \n\u03b41(q, q \u2032), if q, q\u2032 \u2208 Q1 \u03b42(q, q \u2032), if q, q\u2032 \u2208 Q2 \u03b42(q 2 0 , q \u2032), if q \u2208 F1, q \u2032 \u2208 Q2 \u22a5, otherwise\nIn the third case above, S non-deterministically switches from S1 t S2. The proof of correctness is routine.\nSemantics of S-MSO\nw, \u03b8 |= [\u03d5](x) \u21d4 vV (w[\u03b8(x) \u2212 k : \u03b8(x)]) |=A \u03d5\nw, \u03b8 |= x < y \u21d4 \u03b8(x) < \u03b8(y)\nw, \u03b8 |= X(x) \u21d4 \u03b8(x) \u2208 \u03b8(X)\nw, \u03b8 |= \u00ac\u03c6 \u21d4 w, \u03b8 6|= \u03c6\nw, \u03b8 |= \u03c61 \u2227 \u03c62 \u21d4 w, \u03b8 |= \u03c61 and w, \u03b8 |= \u03c62\nw, \u03b8 |= \u2203x \u03c6(x) \u21d4 \u2203i \u2208 [k, |w| \u2212 1] such that w, \u03b8[x 7\u2192 i] |= \u03c6(x)\nw, \u03b8 |= \u2203X \u03c6(X) \u21d4 \u2203I \u2208 2[k,|w|\u22121] such that w, \u03b8[X 7\u2192 I] |= \u03c6(X)"
        },
        {
            "heading": "B Details from Section 3",
            "text": "Proof (Proof of Lemma 13). From section 2, given an S-MSO formula \u03c6(xb, xe), we can construct a k-SLA S over the extended alphabet theory A(xb,xe), such that for any word w \u2208 \u03a3k\u03a3\u2217 and any map \u03b8 : {xb, xe} \u2192 [k, |w| \u2212 1], w, \u03b8 |= \u03c6 if and only if the word w\u03b8 \u2208 (\u03a3 \u00d7 {0, 1}\n2)\u2217 is accepted by S. Guards of transitions in S are of the form (\u03d5, xb = \u03b1b, xe = \u03b1e), where \u03d5 is a formula from the alphabet theory and \u03b1b, \u03b1e \u2208 {0, 1}. Let us denote by S \u2193 xb = 0 the k-SLA obtained from S by removing transitions whose guards have xb = 1. Similarly, we define S \u2193 xe = 0. For every pair of transitions (tb, te) in S such that the guard of tb (resp. te) has xb = 1 (resp. xe = 1), we construct the following two k-SLAs:\n1. PA(b,e): We start with the k-SLA S \u2193 xb = 0. Set the initial state to be the same as that of S. Add a new state pf and set it as the only final state. Suppose the transition tb is from state q to p. In PA(b,e), add a transition from q to pf with the same guard as tb. This is intended to accept prefixes of windows. 2. WA(b,e): We start with the k-SLA S \u2193 xe = 0. Set p as the initial state, where p is the target state of tb. Add a new state p \u2032 f and set it as the only final\nstate. Suppose the transition te is from q \u2032 to p\u2032. In WA(b,e), add a transition from q\u2032 to p\u2032f with the same guard as te. This is intended to accept windows.\nWe denote by SRE (S) the symbolic regular expression equivalent to the k-SLA S. Define R = {(SRE(PA(b,e)), SRE(WA(b,e))) | guard of tb has xb = 1, guard of te has xe = 1}. We shall now prove that for all words w \u2208 \u03a3 k\u03a3\u2217, the set of windows recognized in w by \u03c6(x, y) and R are same. \u21d2: Let (ib, ie) be any window recognized by \u03c6(xb, xe) in w, so w[0 : ie], {xb 7\u2192 ib, xe 7\u2192 ie} |= \u03c6(xb, xe). Let w \u2032 = w[0 : ie]. By construction w \u2032 \u03b8 will be accepted by the k-SLA S. Consider an accepting run \u03c1 := q0 (\u2217,0,0) \u2212\u2212\u2212\u2212\u2192 q1 . . . qib (\u2217,1,\u2217) \u2212\u2212\u2212\u2212\u2192 qib+1 . . . qie\u22121 (\u2217,\u2217,1) \u2212\u2212\u2212\u2212\u2192 qie of S on w \u2032 \u03b8. As xb, xe are first-order variables, there would be exactly two positions, ib and ie where they take the value 1 respectively in the word w\u03b8, and elsewhere they would be 0.\nConsider the pair (SRE(PA(b,e)), SRE(WA(b,e))) \u2208 R where tb = qib (\u2217,1,\u2217) \u2212\u2212\u2212\u2212\u2192\nqib+1 and t \u2032 = qie\u22121 (\u2217,\u2217,1) \u2212\u2212\u2212\u2212\u2192 qie . It follows by construction that PA(b,e) accepts w[0 : ib \u2212 1] and WA(b,e) accepts w[ib \u2212 k : ie].\n\u21d0: Let (ib, ie) be a window accepted by the pair (SRE(PA(b,e)), SRE(WA(b,e))) \u2208\nR with tb := q (\u2217,1,0) \u2212\u2212\u2212\u2212\u2192 p and te = q \u2032 (\u2217,0,1)\u2212\u2212\u2212\u2212\u2192 p\u2032. Therefore, we have w[0 : ib\u22121] \u2208 L(PA(b,e)) and w[ib\u2212k : ie] \u2208 L(WA(b,e)). Let \u03c11 = q0 (\u2217,0,0) \u2212\u2212\u2212\u2212\u2192 q1 . . . qib\u22121 (\u2217,1,\u2217) \u2212\u2212\u2212\u2212\u2192 qib = pf and \u03c12 = qib \u2212\u2192 qib+1 . . . (\u2217,\u2217,1) \u2212\u2212\u2212\u2212\u2192 qie = p \u2032 f be the accepting runs of the k-SLAs PA(b,e),WA(b,e) on w[0 : ib \u2212 1], w[ib \u2212 k : ie] respectively. We can combine the runs \u03c11 and \u03c12 by replacing the last transition in the runs with tb, te respectively and merging the runs to get a run \u03c1 in S for the word w[0 : ie]\u03b8 with \u03b8 := {x\u2192 ib, y \u2192 ie}. \u2293\u2294\nProof (Proof of Lemma 14). Consider a pair (r, r\u2032) \u2208 R. Let \u03c8, \u03c8\u2032 be the S-MSO sentences corresponding to r, r\u2032 respectively. The sentence \u03c8 partitions the set of positions of a word into multiple parts, each part corresponding to a state of the automaton for the expression r. The sentence \u03c8 further verifies that the partition forms a valid run according to the transition rules of the automaton. We modify \u03c8 to partition the set of postions [0, xb \u2212 1] instead and verify the validity of the partition. Let us call this modified formula \u03c8 \u21be xb. It is routine to verify that \u03c8 \u21be xb can be written in the guarded fragment described above. Similarly, \u03c8\u2032 \u21be [xb : xe] will partition and verify the positions in [xb, xe]. The required formula \u03c6(xb, xe) for (r, r \u2032) is (xb \u2264 xe)\u2227 (\u03c8 \u21be xb)\u2227 (\u03c8 \u2032 \u21be [xb : xe]). The required formula is the disjunction of all such formulas for all the pairs in R. \u2293\u2294"
        },
        {
            "heading": "C Details from Section 4",
            "text": "Proof (Proof of Lemma 15). We prove this by induction on n. Before starting to read symbols from I, 1 and 2 hold due to the initializations done before entering the main loop at line 9. Assuming that they hold at the start of the loop after reading n symbols, we will prove that after execution of the loop, the invariants would still hold.\nIn the loop, if PrefixState is final in PA, then we add the next position to WindowStartIndices(initWA) in line 14. Also, all the states already in WindowStartIndices are updated according to the transition relation in lines 33 and 35. Hence, the invariants continue to hold after updating the position variable x in the line following 35. \u2293\u2294\nProof (Proof of Corollary 16). Suppose (x, y) is added to the output, then using Lemma 15 (main loop invariant), we get w[0 : x \u2212 1] \u2208 L(PA) and w[x : y] \u2208 L(WA). Conversely, suppose w[0 : x \u2212 1] \u2208 L(PA) and w[x : y] \u2208 L(WA). Then Lemma 15 implies that PrefixState stores the state of PA after reading w[0 : x \u2212 1], which must be a final state, and hence we would have added x to WindowStartIndices(initWA) in line 14. Now, on reading up to the position y,\nwe will have x \u2208 WindowStateIndices(q) such that q is the state of WA after reading the word w[x : y], as implied by Lemma 15.\nSince w[x : y] \u2208 L(WA), q would be a final state in WA, and hence the processor must add (x, y) in the output stream O in line 18. \u2293\u2294"
        }
    ],
    "year": 2022
}