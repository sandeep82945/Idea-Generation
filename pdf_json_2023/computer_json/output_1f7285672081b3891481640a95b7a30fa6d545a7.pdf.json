{
    "abstractText": "We propose an approach formodular verification of programswritten in an object-oriented language where, like in C++, the same virtual method call is bound to different methods at different points during the construction or destruction of an object. Our separation logic combines Parkinson and Bierman\u2019s abstract predicate families with essentially explicitly tracking each subobject\u2019s vtable pointer. Our logic supports polymorphic destruction. Virtual inheritance is not yet supported.We formalised our approach and implemented it in our VeriFast tool for semi-automated modular formal verification of C++ programs.",
    "authors": [
        {
            "affiliations": [],
            "name": "Niels Mommen"
        },
        {
            "affiliations": [],
            "name": "Bart Jacobs"
        }
    ],
    "id": "SP:340ce56e06b2521230fa56d0b669f8b6c5f14844",
    "references": [
        {
            "authors": [
                "Francesco Dagnino"
            ],
            "title": "A Meta-Theory for Big-Step Semantics",
            "venue": "ACM Trans. Comput. Logic",
            "year": 2022
        },
        {
            "authors": [
                "C.A.R. Hoare"
            ],
            "title": "An Axiomatic Basis for Computer Programming",
            "venue": "Commun. ACM 12,",
            "year": 1969
        },
        {
            "authors": [
                "Ralf Jung",
                "Robbert Krebbers",
                "Jacques-Henri Jourdan",
                "Ale\u0161 Bizjak",
                "Lars Birkedal",
                "Derek Dreyer"
            ],
            "title": "Iris from the ground up: A modular foundation for higher-order concurrent separation logic",
            "venue": "Journal of Functional Programming",
            "year": 2018
        },
        {
            "authors": [
                "Florent Kirchner",
                "Nikolai Kosmatov",
                "Virgile Prevosto",
                "Julien Signoles",
                "Boris Yakobowski"
            ],
            "title": "Frama-C: A software analysis perspective",
            "venue": "Formal aspects of computing 27,",
            "year": 2015
        },
        {
            "authors": [
                "Niels Mommen"
            ],
            "title": "VeriFast C++ tests. https://github.com/verifast/verifast/tree/master/tests/cxx Verifying C++ Dynamic Binding",
            "year": 2023
        },
        {
            "authors": [
                "Matthew Parkinson",
                "Gavin Bierman"
            ],
            "title": "Separation logic and abstraction",
            "venue": "SIGPLAN notices 40,",
            "year": 2005
        },
        {
            "authors": [
                "Matthew J. Parkinson",
                "GavinM. Bierman"
            ],
            "title": "Separation logic, abstraction and inheritance",
            "venue": "SIGPLAN notices 43,",
            "year": 2008
        },
        {
            "authors": [
                "Tahina Ramananandro",
                "Gabriel Dos Reis",
                "Xavier Leroy"
            ],
            "title": "AMechanized Semantics for C++ Object Construction and Destruction, with Applications to Resource Management",
            "venue": "SIGPLAN notices 47,",
            "year": 2012
        },
        {
            "authors": [
                "J.C. Reynolds"
            ],
            "title": "Separation logic: a logic for shared mutable data structures",
            "venue": "In Proceedings - Symposium on Logic in Computer Science",
            "year": 2002
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n30 6.\n02 07\n3v 2\n[ cs\n.P L\n] 1\n4 Ju\nl 2 02\n3\nWe propose an approach formodular verification of programswritten in an object-oriented language where, like in C++, the same virtual method call is bound to different methods at different points during the construction or destruction of an object. Our separation logic combines Parkinson and Bierman\u2019s abstract predicate families with essentially explicitly tracking each subobject\u2019s vtable pointer. Our logic supports polymorphic destruction. Virtual inheritance is not yet supported.We formalised our approach and implemented it in our VeriFast tool for semi-automated modular formal verification of C++ programs.\n1 INTRODUCTION\nDespite the rise of safer alternatives like Rust, C++ is still an extremely widely-used language, often for code that is safety- or security-critical [1, 3, 5]. Modular formal verification can be a powerful tool for gaining assurance that programs satisfy critical safety or security requirements; however, so far no modular formal verification approaches have been proposed for C++ programs. There has been much work on modular verification of C programs, and onmodular verification of object-oriented languages, including languages with multiple inheritance. However, these are not directly applicable to C++, in large part due to its peculiar semantics of dynamic binding during object construction and destruction. In this paper, we propose what we believe to be the first Hoare logic [4] for an object-oriented language that reflects C++\u2019s semantics of dynamic binding in the presence of constructors and destructors. Our separation logic [12] combines Parkinson and Bierman\u2019s abstract predicate families [9, 10] with essentially explicitly tracking each subobject\u2019s vtable pointer. Our logic also supports polymorphic destruction (applying the delete operator to an expression whose static type is a supertype of its dynamic type). Virtual inheritance, however, is not yet supported.\nThe remainder of this paper is structured as follows. In \u00a72 we introduce the syntax and operational semantics of the minimal C++like language that we will use to present our approach. In \u00a73 we introduce our separation logic. In \u00a74 we illustrate an example annotated with a proof outline of our program logic. We end with a discussion of related work (\u00a75) and a conclusion (\u00a76).\n2 A MINIMAL C++-LIKE LANGUAGE\nThe syntax of our minimal object-oriented programming language is shown in Fig. 1.We assume infinite disjoint sets C of class names, M of method names, F of field names, and X of variable names, ranged over by symbols , <, 5 , and G , respectively. We assume this \u2208 X. For now, we also assume a set A of assertions, ranged over by % and & . We will define the syntax of assertions in \u00a73.\nA program consists of a sequence of class definitions, followed by a command that gets executed when the program starts. For the remainder of the formal treatment, we fix a program ?A>6. Whenever we use a class 2;0BB as a proposition, we mean 2;0BB \u2208 ?A>6. For all , we define the set 10B4B ( ) as the set of all direct base classes of :\nclass : { \u00b7 \u00b7 \u00b7 } \u21d2 10B4B ( ) = { }\nAn object pointer > \u2208 O is either an allocation pointer of the form (83 : \u2217) where 83 \u2208 N is an allocation identifier, or a subobject pointer of the form > where > is an object pointer:\n> \u2208 O F (83 : \u2217) | >\nWe use notation > :st to denote the object pointed to by > has\nstatic type :\n> :st \u21d4 (\u220383 . > = (83 : \u2217)) \u2228 (\u2203> \u2032 . > = >\u2032 )\nNotice that for simplicity, the values of our language are only the object pointers and the null value. Furthermore, fields and other variables are untyped and hold scalar values only. That is, objects never appear on the stack or as (non-base) subobjects of other objects.\nWe define a heap, ranged over by \u210e, as a finite set of resources.\nResources, ranged over by U , are defined as follows:\nU F alloc(83) | cted(>) | >\u2192 5 \u21a6\u2192 E | > :dyn\nwhere alloc(83) means that an object with allocation identifier 83 has been allocated, cted(>) means that the object pointed to by > (always an allocation pointer) has been fully constructed and is not yet being destructed. Resource >\u2192 5 \u21a6\u2192 E means that field 5 of the object pointed to by > has value E , and > :dyn means that\nthe dynamic type of the object pointed to by > (always a leaf object, whose class has no bases)1 is .\nWe define 3C~?4 (>, ) as the set of all :dyn resources of its leaf base objects, or its own :dyn resource when it does not have any base objects, given that > :st \u2032:\n3C~?4 (>, ) def =\n{ {> :dyn } 10B4B (\n\u2032) = \u2205\u22c3 1\u22648\u2264= 3C~?4 (> 8 , ) 10B4B ( \u2032) = 1 . . . =\nWe say an object pointed to by > has dynamic type in a heap \u210e if and only if 3C~?4 (>, ) \u2286 \u210e. Notice that a non-leaf object has dynamic type if and only if all of its bases have dynamic type\n. As we will see, dynamically dispatched calls on an object > are dispatched to the dynamic type of >. If an object > has no dynamic type in our language, dynamically dispatched calls get stuck. As we will also see, an object > has no dynamic type while its bases are being constructed or destructed, nor while unrelated (i.e. neither enclosed nor enclosing) subobjects of the allocation are being constructed or destructed. It has a dynamic type only while its own constructor\u2019s or destructor\u2019s body, or the body of an enclosing object\u2019s constructor or destructor is executing, and between the point where its enclosing allocation is fully constructed and the point where it starts being destructed.\nWe use > \u2193 (> downcast to ) to denote the pointer to the enclosing object of class of the object pointed to by >:\n> :st\n> \u2193 = >\n> \u2193 = >\u2032\n> \u2032 \u2193 = > \u2032\nWe use \u210e,4 \u21d3 \u210e\u2032, E to denote that when evaluated in heap \u210e, expression 4 evaluates to value E and post-heap \u210e\u2032. Similarly, we use \u210e, 2 \u21d3 \u210e\u2032 and \u210e, >\u2192 (4) \u21d3 \u210e\u2032 and \u210e,>\u2192 ~ () \u21d3 \u210e\u2032 to denote that command 2 , constructor call > \u2192 (4), and destructor call >\u2192 ~ (), when executed in heap \u210e, terminate with post-heap \u210e\u2032, respectively. These judgments are defined bymutual induction; we show selected rules in Fig. 2. (The complete set of rules can be found in the appendix.)\nNotice, first of all, that a statically dispatched call 4\u2192 ::< (4) gets stuck if class does not declare a method<, even if some base does declare such a method: in our minimal language, classes do not inherit methods from their bases. The same holds for dynamically dispatched calls.2\nEvaluation of new (4) picks an unused allocation identifier 83 and produces (i.e. adds to the heap) alloc(83) to mark it as used, then executes the constructor call, and finally produces cted(>) to mark > as fully constructed.\nExecuting a constructor call >\u2192 (4) is somewhat involved. If has no bases, the argument expressions are evaluated, the fields are produced, > :dyn is produced, and the constructor body is executed. Considered together with ODynamicDispatch, this means that dynamically dispatched calls on this in the constructor body\n1This corresponds to the fact that in C++, objects that have polymorphic base subobjects can reuse the (first) polymorphic base subobject\u2019s vtable pointer. Note: in this paper, for simplicity we do not consider non-polymorphic classes, i.e. classes that do not declare or inherit any virtual members. 2Of course, a program that does rely on method inheritance can be trivially translated into our minimal language by inserting overrides that simply delegate to the appropriate base. Importantly, however, those overrides will have to be verified as part of the correctness proof (see \u00a73); their correctness does not hold automatically.\nare dispatched to class itself, even if is not the most derived class of the allocation.\nNow consider the case where does have bases. Executing constructor call >\u2192 (4) evaluates the argument expressions and then executes each base class\u2019 constructor on the corresponding base subobject.After executing the constructor for base 8 ,3C~?4 (> 8 , 8) is consumed (i.e. removed from the heap); after all base subobjects have been initialized, 3C~?4 (>, ) is produced. This means that, during execution of the body of the constructor of class , dynamically dispatched calls on > or on any base subobject of > are dispatched to class . After an allocation of class is fully constructed, and until it starts being destructed, its dynamic type (and that of all of its subobjects) is .\nExecution of a destructor call > \u2192 ~ () performs the exact reverse process: it executes the destructor body, consumes3C~?4 (>, ) and the fields, and destructs the base subobjects. Before destructing the subobject for base 8 , 3C~?4 ($ 8 , 8) is produced, so that during execution of the body of the destructor of an object > of class , dynamically dispatched calls on > are dispatched to class\n. After destruction of an allocation completes, only the alloc resource remains, to ensure that no future allocation is assigned the same identifier.3\nDeleting an object gets stuck unless its enclosing allocation is fully constructed and is not yet being destructed, as indicated by the presence of the cted resource. Since this resource always holds an allocation pointer, it is always the entire allocation that is destroyed, even if the argument to delete is a pointer to a subobject.\nWe use judgments \u210e, 4 div and \u210e, 2 div and \u210e, >\u2192 (4) div and \u210e,>\u2192~ () div to denote that an expression, command, constructor call, or destructor call diverges (i.e. runs forever without terminating or getting stuck), respectively. These judgments\u2019 definitions can be derived mechanically [2] from the definitions of the termination judgments and are therefore elided.\n3 A PROGRAM LOGIC FOR C++ DYNAMIC\nBINDING\nA class definition in our language includes a list of abstract predicates. A predicate declaration in a class defines its entry for the corresponding predicate family, i.e., a class defines its own definition for the abstract predicate, which can be overridden by derived classes. As we will see, predicate assertions involve a class index to refer to the definition of the predicate declared in that class.\nWe use a context \u0393, which is a sequence of class definitions.\n3.1 Assertions\nPredicate definitions, method specifications, constructor specifications, and destructor specifications consist of assertions, ranged over by % and & :\n%,& F true | false | % \u2227& | % \u2228& | % \u2217& | \u2203G. % | Y\u2192 5 \u21a6\u2192 Y | Y\u2192?Y (Y) | cted(Y, Y) | Y :dyn Y\na F E | Y F G | a\n3This reflects the fact that pointers in C++ become invalid permanently after the allocation they point to is deallocated, even if some future allocation happens to reuse the same address.\nwhere % \u2217 & is the separating conjunction of assertions % and & , which informally means that assertion % and& must be satisfied in disjoint portions of the heap. Assertion Y\u2192 ?Y\u2032 (Y\u2032\u2032) is a predicate assertion ? with class index Y\u2032 on the target object pointed to by Y .\nWe show the semantics of the most interesting assertions:\n, \u210e >\u2192? (a) \u21d4 \u2203> \u2032 . > \u2193 = >\u2032 \u2227 (\u210e,>\u2032, ?, , a) \u2208 , \u210e cted(>, ) \u21d4 \u2203>\u2032 . > \u2193 = >\u2032 \u2227 cted(>\u2032) \u2208 \u210e , \u210e > :dyn \u21d4 3C~?4 (>, ) \u2286 \u210e , \u210e >\u2192 5 \u21a6\u2192 E \u21d4 >\u2192 5 \u21a6\u2192 E \u2208 \u210e\nwhere , \u210e % means that assertion % is satisfied, given heap \u210e and interpretation of predicates . An interpretation of predicates is the least fixpoint of the program\u2019s predicate definitions considered together.\nWe define the assertion weakening relation \u0393 \u22a2 % \u21d20 & by induction, where every judgment % \u21d20 & should be read as \u0393 \u22a2 % \u21d20 & : ADyntype\n> :st 10B4B ( ) = 1 . . . = = > 0 > :dyn \u2032 \u21d40 > 1 :dyn \u2032 \u2217 . . . \u2217 > = :dyn \u2032\nAFrame\n% \u21d20 % \u2032\n% \u2217& \u21d20 % \u2032 \u2217&\nATrans % \u21d20 % \u2032 % \u2032 \u21d20 % \u2032\u2032\n% \u21d20 % \u2032\u2032\nAMoveCted\n> :st\n\u2032 \u2208 10B4B ( ) \u2032 \u2260 \u2032\u2032\ncted(>, \u2032\u2032) \u21d40 cted(> \u2032 , \u2032\u2032)\nAImply \u2200 ,\u210e. , \u210e % \u21d2 , \u210e % \u2032\n% \u21d20 % \u2032\nAMovePred\n> :st\n\u2032 \u2208 10B4B ( ) \u2032 \u2260 \u2032\u2032\n>\u2192? \u2032\u2032 (a) \u21d40 > \u2032 \u2192? \u2032\u2032 (a)\nAPredDef > :st class \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 pred ? (G) = % \u00b7 \u00b7 \u00b7 } \u2208 \u0393\n>\u2192? (a) \u21d40 % [>/this, a/G]\nWeakening rule APredDef allows to switch between a predicate assertion and the definition of the predicate corresponding to the class index. The class index must be a class name declared in the program.\nAMovePred and AMoveCted allow to transfer predicate and cted assertions between base and derived objects. It is not possible to transfer such an assertion to an object whose dynamic type is a subtype of the predicate index and allocation class, respectively.\nWeakening rule ADyntype states that the dynamic type assertion of a non-leaf object can be exchanged for all dynamic type assertions of its direct base objects. This means that the dynamic type of a base object can be retrieved if the dynamic type of its direct derived object is known. The other way around, it is possible to derive the dynamic type of a derived object if the dynamic type of all its direct base classes is known.\n3.2 Expression and command verification\nThe verification rules for themost interesting expressions and commands are listed in Fig. 3, together with the verification rules for constructor and destructor invocations. These rules are related to object allocation and deallocation, and static and dynamic dispatching. (The complete set of verification rules can be found in the appendix).\nIn method and destructor specifications, we use special variable \\ to refer to the class of the target object of the call. This variable is assumed to be equal to the containing class during verification of the method or destructor. This is sound, because we require that a class overrides all methods of all its direct base classes, as we will later see. Hence when a call is dynamically dispatched, it will always be bound to themethod declared in the class corresponding with the dynamic type of the target object.\nVariable \\ is substituted with the dynamic type of the target object and the static type of the target object during verification\nof dynamically dispatched calls and statically dispatched calls, respectively. This mechanism allows to use the specification for the method or destructor in the class corresponding to the static type of the method or destructor target.\n3.3 Constructor verification\nThe verification rule for constructors follows OConstruct from our operational semantics: the direct base constructor invocations are verified in order of inheritance, prior to initializing the fields of the object and verifying the command in the constructor\u2019s body. Virtual calls are always dispatched to the (sub)object under construction.\n\u2200> :st , E . % [E/G ] = %0\n{%0} > 1 \u2192 1 (41 [>/this, E/G]) {%1 \u2217 > 1 :dyn 1} . . .\n{%=\u22121} > = \u2192 = (4= [>/this, E/G]) {%= \u2217 > = :dyn =}\n{%= \u2217 >\u2192 5 \u21a6\u2192 null \u2217 > :dyn } 2 [>/this, E/G] {& [>/this, E/G]}\n\u0393 \u22a2 (G) req % ens & : 1 (41) . . . = (4=) {2} correct in\n3.4 Behavioral subtyping\nWe followParkinson and Bierman\u2019s approach [10] to checkwhether specifications of overriding methods satisfy behavioral subtyping. A specification {% }_{& } of an overriding method in derived class implies a specification {% }_{& } of a method in base class , if for all commands 2 , values E and object pointers > :st with a well-defined downcast>\u2032 = > \u2193 that satisfy {% [( ]} 2 {& [( ]}, it holds that {% [( ]} 2 {& [( ]} is also satisfied, with( = >/this, /\\, E/G and ( = >\n\u2032/this, /\\, E/G . This holds when a proof tree exists using the structural rules of Hoare and Separation logic, with leaves \u0393 \u22a2 {% [( ]}_{& [( ]} and root \u0393 \u22a2 {% [( ]}_{& [( ]}:\n\u0393 \u22a2 {% [( ]}_{& [( ]}\n...\n\u0393 \u22a2 {% [( ]}_{& [( ]}\nWe use notation \u0393 \u22a2 {% }_{& } \u21d2 {% }_{& } to denote that such a proof exists.\n3.5 Method verification\nThe verification rule for correctly overriding a method checks that (1) the specification for method < in derived class satisfies behavioral subtyping for base class \u2032 which also declares<, and (2) recursively checks this condition for all direct base classes of \u2032. We use<4C\u210e>3B ( ) to denote all methods declared in class .\nclass \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual< (G) req % ens & \u00b7 \u00b7 \u00b7 } \u2208 \u0393 class \u2032 \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual< (G) req % \u2032 ens &\u2032 \u00b7 \u00b7 \u00b7 } \u2208 \u0393\n\u0393 \u22a2 {%}_{&} \u21d2 \u2032 {% \u2032}_{&\u2032}\n\u2200 \u2032\u2032 \u2208 10B4B ( \u2032).< \u2208 <4C\u210e>3B ( \u2032\u2032) \u21d2 \u0393 \u22a2 override of< in \u2032\u2032 correct in C\n\u0393 \u22a2 override of< in \u2032 correct in\nMethod< in class is correct if (1) the override check for all base classes of that declare< succeeds and (2) the method body satisfies its specification given that the target class type is .\n\u2200 \u2032 \u2208 10B4B ( ).< \u2208 <4C\u210e>3B ( \u2032) \u21d2 \u0393 \u22a2 override of< in \u2032 correct in C\n\u2200> :st , E . {% [>/this, /\\, E/G]} 2 [>/this, E/G ] {& [>/this, /\\, E/G]}\n\u0393 \u22a2< (G) req % ens & {2} correct in\n3.6 Destructor verification\nThe verification rule for correctly overriding a destructor is similar to the verification rule for correctly overriding a method. The difference is that it recursively checks the rule for all bases because every class must declare a destructor in our language.\nThe verification rule for destructors again resembles the operational semantics and follows the reverse process of its corresponding constructor. The command of the body is first verified, followed by the removal of the object\u2019s fields and verification of the direct base destructor invocations in reverse order of inheritance. Virtual member invocations are dispatched to the (sub)object under destruction.\n\u2200 \u2032 \u2208 10B4B ( ). \u0393 \u22a2 override of destructor in \u2032 correct in \u2200> :st .\n10B4B ( ) = 1 . . . = %0 = &\n{% [>/this, /\\]} 2 [>/this] {%= \u2217 >\u2192 5 \u21a6\u2192 _ \u2217 > :dyn } {%= \u2217 > = :dyn =} > = \u2192~ = () {%=\u22121}\n. . .\n{%1 \u2217 > 1 :dyn 1} > 1 \u2192~ 1 () {%0}\n\u0393 \u22a2 ~ () req % ens & {2} correct in\n3.7 Program verification\nVerification of a class succeeds if verification for its constructor, destructor, and methods succeeds. We additionally require that a derived class overrides all methods declared in its base classes. This requirement renders our assumption sound that the dynamic type of the target object during verification of a destructor or method is the class type of the enclosing class it is declared in.\nA program is correct if verification of all its classes succeeds,\nand its main command is verifiable given an empty heap.\n?A>6 = 2;0BB 2 \u22a2 2;0BB correct \u22a2 {true} 2 {true}\n\u22a2 program correct\nTheorem 1 (Soundness). Given that the program is correct, the main command, when executed in the empty heap, does not get stuck (i.e. it either terminates or diverges):\n\u22a2 program correct \u2227 ?A>6 = 2;0BB 2 \u21d2 \u2205, 2 \u21d3 _ \u2228 \u2205, 2 div\n4 EXAMPLE PROOF OUTLINE\nThis section shows an example in our formal language, annotated with its proof outline. It illustrates a node class N which inherits from both a target class T and source class S. A target and source can have a source and target, respectively. A node is initially its own target and source.\nThe example illustrates dynamic dispatch during construction and shows that our program logic is applicable in the presence of multiple inheritance. The main command shows how our proof system can handle polymorphic deletion of objects. The proof outline for T is symmetric to the one shown in S, and is therefore omitted. Empty bodies implicitly contain a skip command.\nclass S {\nt := null;\npred (>: () = \u2203C . C\u210e8B\u2192C \u21a6\u2192 C ; pred B3~= (3C ) = C\u210e8B :dyn 3C ;\nS() req true ens C\u210e8B\u2192B3~=S (S) \u2217 C\u210e8B\u2192(>:S () {\n{true \u2217 C\u210e8B\u2192C \u21a6\u2192 null \u2217 C\u210e8B :dyn S} {C\u210e8B\u2192B3~=S (S) \u2217 C\u210e8B\u2192(>:S () }\n}\nvirtual ~S() req C\u210e8B\u2192B3~=\\ (\\ ) \u2217 C\u210e8B\u2192(>:\\ () ens true {\n{C\u210e8B :dyn S \u2217 \u2203C . C\u210e8B\u2192C \u21a6\u2192 C }\n}\nvirtual setTarget(t) req C\u210e8B\u2192(>:\\ () ens C\u210e8B\u2192(>:\\ () {\n{\u2203;C . C\u210e8B\u2192C \u21a6\u2192 ;C }\n{C\u210e8B\u2192C \u21a6\u2192 ;C } this\u2192t := t {C\u210e8B\u2192C \u21a6\u2192 C }\n{\u2203;C . C\u210e8B\u2192C \u21a6\u2192 ;C }\n}\n};\nclass T {\ns := null; pred )>: () = \u2203B. C\u210e8B\u2192B \u21a6\u2192 B ; pred C3~= (3C ) = C\u210e8B :dyn 3C ; T() {}\nvirtual ~T() {} virtual setSource(s) { this\u2192s := s }\n};\nclass N : S, T {\npred (>: () = C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () ; pred B3~= (3C ) = C\u210e8BS\u2192B3~=S (3C ) \u2217 C\u210e8BT\u2192C3~=T (3C ) ; pred )>: () = C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () ; pred C3~= (3C ) = C\u210e8BS\u2192B3~=S (3C ) \u2217 C\u210e8BT\u2192C3~=T (3C ) ;\nN() req true ens C\u210e8B\u2192B3~=N (N) \u2217 C\u210e8B\u2192(>:N () :\n{true}\n{true} S() {C\u210e8BS\u2192B3~=S (S) \u2217 C\u210e8BS\u2192(>:S () }\n{C\u210e8BS\u2192(>:S () \u2217 C\u210e8BS :dyn S} , {C\u210e8BS\u2192(>:S () }\n{true} T() {C\u210e8BT\u2192C3~=T (T) \u2217 C\u210e8BT\u2192)>:T () }\n{C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () \u2217 C\u210e8BT :dyn T}\n{\n{C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () \u2217 C\u210e8B :dyn N} {C\u210e8B :dyn N \u2217 C\u210e8B\u2192(>:N () }\n{\u2203 . C\u210e8B :dyn \u2217 C\u210e8B\u2192(>: () } this\u2192setTarget((T \u2217) this); {C\u210e8B :dyn \u2217 C\u210e8B\u2192(>: () }\n{C\u210e8B :dyn N \u2217 C\u210e8B\u2192(>:N () } {C\u210e8B :dyn N \u2217 C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () } {C\u210e8B :dyn N \u2217 C\u210e8B\u2192)>:N () }\n{\u2203 . C\u210e8B :dyn \u2217 C\u210e8B\u2192)>: () } this\u2192setSource((S \u2217) this) {C\u210e8B :dyn \u2217 C\u210e8B\u2192)>: () }\n{C\u210e8B :dyn N \u2217 C\u210e8B\u2192)>:N () } {C\u210e8B :dyn N \u2217 C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () } {C\u210e8B :dyn N \u2217 C\u210e8B\u2192(>:N () } {C\u210e8BS :dyn N \u2217 C\u210e8BT :dyn N \u2217 C\u210e8B\u2192(>:N () } {C\u210e8BS\u2192B3~=S (S) \u2217 C\u210e8BT\u2192C3~=T (T) \u2217 C\u210e8B\u2192(>:N () } {C\u210e8B\u2192B3~=N (N) \u2217 C\u210e8B\u2192(>:N () }\n}\nvirtual ~N() req C\u210e8B\u2192B3~=\\ (\\ ) \u2217 C\u210e8B\u2192(>:\\ () ens true {\n{C\u210e8BS\u2192B3~=S (N) \u2217 C\u210e8BT\u2192C3~=T (N) \u2217 C\u210e8B\u2192(>:N () } {C\u210e8BS :dyn N \u2217 C\u210e8BT :dyn N \u2217 C\u210e8B\u2192(>:N () } {C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () \u2217 C\u210e8B :dyn N}\n}\n{C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () \u2217 C\u210e8BT :dyn T} {C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () \u2217 C\u210e8BT\u2192C3~=T (T) }\n{C\u210e8BT\u2192C3~=T (T) \u2217 C\u210e8BT\u2192)>:T () } C\u210e8BT\u2192~T() {true}\n{C\u210e8BS\u2192(>:S () } , {C\u210e8BS\u2192(>:S () \u2217 C\u210e8BS :dyn S} {C\u210e8BS\u2192B3~=S (S) \u2217 C\u210e8BS\u2192(>:S () }\n{C\u210e8BS\u2192B3~=S (S) \u2217 C\u210e8BS\u2192(>:S () } C\u210e8BS\u2192~S() {true}\n{true}\nvirtual setTarget(t) req C\u210e8B\u2192(>:\\ () ens C\u210e8B\u2192(>:\\ () {\n{C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () }\n{C\u210e8BS\u2192(>:S () } this\u2192S::setTarget(t) {C\u210e8BS\u2192(>:S () }\n{C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () }\n}\nvirtual setSource(s) req C\u210e8B\u2192)>:\\ () ens C\u210e8B\u2192)>:\\ () {\n{C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () }\n{C\u210e8BT\u2192)>:T () } this\u2192T::setSource(s) {C\u210e8BT\u2192)>:T () }\n{C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T () }\n}\n};\n{true}\n{true} let n := new N() in {=\u2192B3~=N (N) \u2217 =\u2192(>:N () \u2217 cted(=, N) } let s := (S\u2217) n in {B\u2192B3~=N (N) \u2217 B\u2192(>:N () \u2217 cted(B, N) }\n{\u2203 . cted(B, ) \u2217 B\u2192B3~= ( ) \u2217 B\u2192(>:C () } delete s {true}\n{true}\n{true}\nThe proof that the specification of ~N implies the specification of ~T, can be constructed as follows:\n{C\u210e8B\u2192B3~=N(N) \u2217 C\u210e8B\u2192(>:N ()}_{true}{ C\u210e8Bs\u2192B3~=S(N) \u2217 C\u210e8BT\u2192C3~=T(N)\n\u2217 C\u210e8BS\u2192(>:S () \u2217 C\u210e8BT\u2192)>:T ()\n} _{true} APredDef\n{C\u210e8B\u2192C3~=N(N) \u2217 C\u210e8B\u2192)>:N ()}_{true} APredDef\n{C\u210e8BT\u2192C3~=N(N) \u2217 C\u210e8BT\u2192)>:N ()}_{true} AMovePred\nThe behavioral suptyping proofs for the specifications of setSource and setTarget, and the proof that the specification of ~N implies the specification of ~S, can be established trivially using assertion weakening rule AMovePred.\n5 RELATED WORK\nParkinson and Bierman\u2019s work [9, 10] introduces abstract predicate families. Their proof system allows a derived class to extend a base class, restrict the behavior of its base class, and alter the behavior of the base class while preserving behavioral subtyping. Method specifications consist of a dynamic and static specification, used for dynamically and statically dispatched calls, respectively. We derive these specifications from the same specification, using special variable \\ . Their proof system only accounts for single inheritance without the presence of virtual destructors.\nRamananandro et al. [11] define operational semantics for a subset of C++, including construction and destruction in the presence of multiple inheritance and virtual methods that are dynamically dispatched. Their semantics encode the evolution of an object\u2019s dynamic type during construction and destruction. However, they only consider stack-allocated objects. This means that the concrete dynamic type of an object is always statically known at the point of its destruction.\nVan Staden and Calcagno [14] extend the work of Parkinson and Bierman to a separation logic for object-oriented programs\nwithmultiple inheritance and virtual methods calls that are dynamically dispatched. They only consider virtual inheritance, which means that an object cannot have two base subobjects of the same class type. Furthermore, their logic does not support destructors, so polymorphic deletion is not considered. In their proof system, the dynamic type of an object is fixed after allocation, whereas we model the evolution of the dynamic type of an object during its construction and destruction.\nBRiCk [13], built upon the separation logic of Iris [6], is a program logic for C++. The Frama-Clang plugin of Frama-C [7] enables analysis of C++ programs, supporting the ACSL specification language. Both tools support dynamic dispatching and model the evolution of an object\u2019s dynamic type through its construction and destruction. However, at the time of writing, no literature on these tools\u2019 approaches has appeared.\n6 CONCLUSION\nIn this paper we proposed a separation logic for modular verification of programs where virtual method calls are bound to different methods at different points during the construction and destruction of objects. Additionally, we support polymorphic destruction where the static type of an object is a supertype of its dynamic type.\nWe defined the operational semantics of our language related to allocation and deallocation, construction and destruction, and method dispatching, and listed the corresponding proof rules for verification.\nNext, we illustrated an example program annotatedwith a proof outline, to support our verification approach. This example indicates that our separation logic can be used to verify C++ dynamic binding in the presence of multiple inheritance. To our knowledge, we are the first to define a Hoare logic which reflects C++\u2019s semantics of dynamic binding in the presence of constructors an destructors.\nWe implemented our approach [8] as part of our effort to extend our VeriFast tool for semi-automated modular formal verification of C and Java programs with support for C++. The implementation in VeriFast additionally supports bases that are non-polymorphic. One limitation is that our current operational semantics and separation logic does not consider virtual inheritance.\nREFERENCES [1] OpenJDK Community. 2023. OpenJDK. https://github.com/openjdk/jdk [2] Francesco Dagnino. 2022. A Meta-Theory for Big-Step Semantics.\nACM Trans. Comput. Logic 23, 3, Article 20 (apr 2022), 50 pages. https://doi.org/10.1145/3522729 [3] .NET Foundation and Contributors. 2023. .NET CLR. https://github.com/dotnet/runtime/tree/main/src/coreclr [4] C. A. R. Hoare. 1969. An Axiomatic Basis for Computer Programming. Commun. ACM 12, 10 (1969), 576\u2013580. https://doi.org/10.1145/363235.363259 [5] Google Inc., The Chromium Authors, The Chromium OS Authors, The Go Authors, and Samsung Inc. 2023. Fuchsia. https://github.com/vsrinivas/fuchsia [6] Ralf Jung, Robbert Krebbers, Jacques-Henri Jourdan, Ale\u0161 Bizjak, Lars Birkedal, and Derek Dreyer. 2018. Iris from the ground up: A modular foundation for higher-order concurrent separation logic. Journal of Functional Programming 28 (2018), e20. [7] Florent Kirchner, Nikolai Kosmatov, Virgile Prevosto, Julien Signoles, and Boris Yakobowski. 2015. Frama-C: A software analysis perspective. Formal aspects of computing 27, 3 (2015), 573\u2013609. [8] Niels Mommen. 2023. VeriFast C++ tests. https://github.com/verifast/verifast/tree/master/tests/cxx\n[9] Matthew Parkinson and Gavin Bierman. 2005. Separation logic and abstraction. SIGPLAN notices 40, 1 (2005), 247\u2013258. [10] Matthew J. Parkinson and GavinM. Bierman. 2008. Separation logic, abstraction and inheritance. SIGPLAN notices 43, 1 (2008), 75\u201386. [11] Tahina Ramananandro, Gabriel Dos Reis, and Xavier Leroy. 2012. AMechanized Semantics for C++ Object Construction and Destruction, with Applications to Resource Management. SIGPLAN notices 47, 1 (2012), 521\u2013532. [12] J.C. Reynolds. 2002. Separation logic: a logic for shared mutable data structures. In Proceedings - Symposium on Logic in Computer Science. IEEE, Los Alamitos CA, 55\u201374. [13] BedRock systems. 2023. BRiCk. https://github.com/bedrocksystems/BRiCk [14] Stephan Van Staden and Cristiano Calcagno. 2009. Separation, abstraction, mul-\ntiple inheritance and view shifting. Technical report 655 (2009).\nA OPERATIONAL SEMANTICS\nThe operational semantics of expressions, commands, and constructor and destructor invocations are defined by mutual induction:\nOLookup\n\u210e,4 \u21d3 \u210e\u2032 \u228e {[>\u2192 5 \u21a6\u2192 E]}, >\n\u210e, 4\u2192 5 \u21d3 \u210e\u2032 \u228e {[>\u2192 5 \u21a6\u2192 E]}, E\nODeleteNull\n\u210e,4 \u21d3 \u210e\u2032, null\n\u210e, delete(4) \u21d3 \u210e\u2032\nOVal \u210e, E \u21d3 \u210e, E\nOUpdate \u210e,4 \u21d3 \u210e\u2032, > \u210e\u2032, 4\u2032 \u21d3 \u210e\u2032\u2032 \u228e {[>\u2192 5 \u21a6\u2192 E]}, E\u2032\n\u210e,4\u2192 5 \u2254 4\u2032 \u21d3 \u210e\u2032\u2032 \u228e {[>\u2192 5 \u21a6\u2192 E\u2032]}\nOLet \u210e, 4 \u21d3 \u210e\u2032, E \u210e\u2032, 2 [E/G] \u21d3 \u210e\u2032\u2032\n\u210e, let G \u2254 4 in 2 \u21d3 \u210e\u2032\u2032\nOSeq \u210e, 2 \u21d3 \u210e\u2032 \u210e\u2032, 2\u2032 \u21d3 \u210e\u2032\u2032\n\u210e, 2; 2\u2032 \u21d3 \u210e\u2032\u2032\nOSkip \u210e, skip \u21d3 \u210e\nOUpcast \u210e,4 \u21d3 \u210e\u2032, > > :st \u2032 \u2208 10B4B ( )\n\u210e, ( \u2032\u2217) 4 \u21d3 \u210e\u2032, > \u2032\nOStaticDispatch class \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual< (G){2} \u00b7 \u00b7 \u00b7 } \u210e,4 \u21d3 \u210e\u2032, > > :st \u210e \u2032, 4 \u21d3 \u210e\u2032\u2032, E \u210e\u2032\u2032, 2 [>/this, E/G ] \u21d3 \u210e\u2032\u2032\u2032\n\u210e, 4\u2192 ::< (4) \u21d3 \u210e\u2032\u2032\u2032\nODynamicDispatch\nclass \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual< (G){2} \u00b7 \u00b7 \u00b7 } \u210e, 4 \u21d3 \u210e\u2032, > \u210e\u2032, 4 \u21d3 \u210e\u2032\u2032, E\n3C~?4 (>, ) \u2286 \u210e\u2032\u2032 >\u2032 = > \u2193 \u210e\u2032\u2032, 2 [>\u2032/this, E/G ] \u21d3 \u210e\u2032\u2032\u2032\n\u210e, 4\u2192< (4) \u21d3 \u210e\u2032\u2032\u2032\nOConstruct class : 1 . . . ={5 \u2254 null; \u00b7 \u00b7 \u00b7 (G) : 1(41) . . . = (4=){2} \u00b7 \u00b7 \u00b7 } \u210e,4 \u21d3 \u210e0, E\n\u210e0, > 1 \u2192 1 (41 [>/this, E/G]) \u21d3 \u210e1 \u228e 3C~?4 (> 1, 1) ...\n\u210e=\u22121, > = \u2192 = (4= [>/this, E/G]) \u21d3 \u210e= \u228e 3C~?4 (> = , =) \u210e= \u228e {[>\u2192 5 \u21a6\u2192 null]} \u228e 3C~?4 (>, ), 2 [>/this, E/G] \u21d3 \u210e \u2032\n\u210e,>\u2192 (4) \u21d3 \u210e\u2032\nONew > = (83 : \u2217) alloc(83) \u2209 \u210e \u210e \u228e {[alloc(83)]}, >\u2192 (4) \u21d3 \u210e\u2032\n\u210e, new (4) \u21d3 \u210e\u2032 \u228e {[cted(>, )]}, >\nODestruct class : 1 . . . ={5 \u2254 null; \u00b7 \u00b7 \u00b7 virtual ~ (){2} \u00b7 \u00b7 \u00b7 }\n\u210e, 2 [>/this] \u21d3 \u210e= \u228e 3C~?4 (>, ) \u228e {[>\u2192 5 \u21a6\u2192 E]} \u210e= \u228e 3C~?4 (> = , =), > = \u2192~ = () \u21d3 \u210e=\u22121\n...\n\u210e1 \u228e 3C~?4 (> 1, 1), > 1 \u2192~ 1() \u21d3 \u210e0\n\u210e,>\u2192~ () \u21d3 \u210e0\nODelete >\u2032 = > \u2193 \u210e,4 \u21d3 \u210e\u2032 \u228e {[cted(>\u2032, )]}, > \u210e\u2032, >\u2032\u2192~ () \u21d3 \u210e\u2032\u2032\n\u210e, delete(4) \u21d3 \u210e\u2032\u2032\nB ASSERTION SEMANTICS\nThe semantics of assertions are defined as follows:\n,\u210e 1 \u21d4 1 = true ,\u210e % \u2217& \u21d4 \u2203\u210e1, \u210e2.\u210e = \u210e1 \u228e \u210e2 \u2227 ,\u210e1 % \u2227 ,\u210e2 & ,\u210e % \u2227& \u21d4 ,\u210e % \u2227 ,\u210e & ,\u210e % \u2228& \u21d4 ,\u210e % \u2228 ,\u210e & ,\u210e \u2203G. % \u21d4 \u2203a. ,\u210e % [a/G] ,\u210e >\u2192? ( ,a) \u21d4 \u2203>\u2032 . > \u2193 = >\u2032 \u2227 (\u210e,>\u2032, ?, ,a) \u2208 ,\u210e cted(>, ) \u21d4 \u2203>\u2032 . > \u2193 = >\u2032 \u2227 cted(>\u2032, ) \u2208 \u210e ,\u210e > :dyn \u21d4 3C~?4 (>, ) \u2286 \u210e ,\u210e >\u2192 5 \u21a6\u2192 E \u21d4 >\u2192 5 \u21a6\u2192 E \u2208 \u210e\nwhere ,\u210e % means that assertion % is satisfied, given heap \u210e and interpretation of predicates . Cases not listed are false.\nC PROOF RULES\nWe define evaluation contexts for expressions and commands as follows:\n4 F \u2022 | 4\u2192 5 | new (E 4 4) | ( \u2217) 4\n2 F \u2022 | delete 4 | 4\u2192 5 \u2254 4 | >\u2192 5 \u2254 4 | 4\u2192 ::< (4)\n| >\u2192 ::< (E 4 4) | 4\u2192< (4) | >\u2192< (E 4 4)\nWe use the notation [4] to denote the context with expression 4 substituted for the hole \u2022.\nHFrame\n{%} 2 {&}\n{% \u2217 '} 2 {& \u2217 '}\nHConseq % \u21d20 % \u2032 {% \u2032} 2 {&\u2032} &\u2032 \u21d20 &\n{%} 2 {&}\nHNull {true} null {result = null} HPointer {true} > {result = >}\nHLookup {>\u2192 5 \u21a6\u2192 E} >\u2192 5 {>\u2192 5 \u21a6\u2192 E \u2227 result = E}\nHUpdate {>\u2192 5 \u21a6\u2192 _} >\u2192 5 \u2254 E {>\u2192 5 \u21a6\u2192 E}\nHLet {%} 4 {&} \u2200E. {& [E/result]} 2 [E/G] {'}\n{%} let G \u2254 4 in 2 {'}\nHSeq {%} 2 {&} {&} 2\u2032 {'}\n{%} 2; 2\u2032 {'}\nHSkip {%} skip {%}\nHContext {%} 4 {&} \u2200E. {& [E/result]} [E] {'}\n{%} [4] {'}\nHConsContext {%} 4 {&} \u2200E. {& [E/result]} >\u2192 (E E 4) {'}\n{%} >\u2192 (E 4 4) {'}\nHConstruct class \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 (G) req % ens & \u00b7 \u00b7 \u00b7 } \u2208 \u0393\n{% [E/G ])} >\u2192 (E) {& [E/G, >/this]}\nHNew\nclass \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 (G) req % ens & \u00b7 \u00b7 \u00b7 } \u2208 \u0393\n{% [E/G]} new (E) {& [E/G, result/this] \u2217 cted(result, )}\nHDestruct class \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual ~ () req % ens & \u00b7 \u00b7 \u00b7 } \u2208 \u0393\n{% [>/this, /\\]} >\u2192~ () {&}\nHDeleteNull {true} delete(null) {true}\nHDelete class \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual ~ () req % ens & \u00b7 \u00b7 \u00b7 } \u2208 \u0393 > :st\n{cted(>, \u2032) \u2217 % [>/this, \u2032/\\]} delete(>) {&}\nHStaticDispatch class \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual< (G) req % ens & \u00b7 \u00b7 \u00b7 } \u2208 \u0393 > :st\n{% [>/this, /\\, E/G]} >\u2192 ::< (E) {& [>/this, /\\, E/G]}\nHDynamicDispatch\nclass \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual< (G) req % ens & \u00b7 \u00b7 \u00b7 } \u2208 \u0393 > :st\n{> :dyn \u2032 \u2227 % [>/this, \u2032/\\, E/G ]} >\u2192< (E) {& [>/this, \u2032/\\, E/G]}\nHExists \u2200E. {% [E/G]} 2 {&}\n{\u2203G. %} 2 {&}\nHUpcast\n> :st \u2208 10B4B ( \u2032)\n{% [> /result]} ( \u2217) > {%}\nC.1 Destructor override check\nclass \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual ~ () req % ens & \u00b7 \u00b7 \u00b7 } \u2208 \u0393 class \u2032 \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual ~ \u2032 () req % \u2032 ens &\u2032 \u00b7 \u00b7 \u00b7 } \u2208 \u0393\n\u0393 \u22a2 {%}_{&} \u21d2 \u2032 {% \u2032}_{&\u2032}\n\u2200 \u2032\u2032 \u2208 10B4B ( \u2032). \u0393 \u22a2 override of destructor in \u2032\u2032 correct in C\n\u0393 \u22a2 override of destructor in \u2032 correct in\nC.2 Class verification\n2;0BB = class \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 2C>A 3C>A <4C\u210e } \u0393 \u22a2 2C>A correct in\n\u0393 \u22a2 3C>A correct in \u0393 \u22a2<4C\u210e correct in\n\u0393 \u22a2 2;0BB correct\nD SOUNDNESS\nDue to the fact that our assertion language does not allow predicate assertions in negative positions (i.e. under negation or on the lefthand side of implication), we have the following property:\nLemma 1. The semantics of assertions is monotonic in the predi-\ncate interpretation :\n\u2286 \u2032 \u2227 , \u210e % \u21d2 \u2032, \u210e %\nProof. By induction on the structure of % .\nWe define a function on predicate interpretations as follows:\n( ) = { (\u210e, >, ?, , E) class \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 pred ? (G) = % ; \u00b7 \u00b7 \u00b7 }\u2227 ,\u210e % [>/this, E/G] }\nWe define the program\u2019s predicate interpretation program by program = \u22c2 { | ( ) \u2286 }. By the Knaster-Tarski theorem, program\nis a fixpoint of : ( program) = program. 4 We use notation \u210e % to mean program, \u210e % .\nLemma 2 (Soundness of assertion weakening).\n% \u21d20 & \u2227 \u210e % \u21d2 \u210e &\nProof. By induction on the derivation of % \u21d20 & .\nWe define semantic counterparts of the correctness judgments\nof our proof system as follows:\n{%} 4 {&} \u21d4\n\u00a9 \u00ab \u2200\u210e,\u210ef. \u210e % \u21d2 \u210e \u228e \u210ef, 4 div \u2228 \u2203\u210e\u2032, E . \u210e \u228e \u210ef, 4 \u21d3 \u210e \u2032 \u228e \u210ef, E \u2227\u210e\u2032 & [E/result] \u00aa\u00ae \u00ac\n{%} 2 {&} \u21d4( \u2200\u210e,\u210ef. \u210e % \u21d2\n\u210e \u228e \u210ef, 2 div \u2228 \u2203\u210e\u2032 . \u210e \u228e \u210ef, 2 \u21d3 \u210e \u2032 \u228e \u210ef \u2227 \u210e \u2032 &\n)\n{%} >\u2192 (4) {&} \u21d4( \u2200\u210e,\u210ef. \u210e % \u21d2\n\u210e \u228e \u210ef, >\u2192 (4) div \u2228 \u2203\u210e\u2032 . \u210e \u228e \u210ef, >\u2192 (4) \u21d3 \u210e \u2032 \u228e \u210ef \u2227 \u210e \u2032 &\n)\n{%} >\u2192~ () {&} \u21d4( \u2200\u210e,\u210ef. \u210e % \u21d2\n\u210e \u228e \u210ef, >\u2192~ () div \u2228 \u2203\u210e\u2032 . \u210e \u228e \u210ef, >\u2192~ () \u21d3 \u210e \u2032 \u228e \u210ef \u2227 \u210e \u2032 &\n)\nLemma 3. Soundness of HContext If {%} 4 {&} and \u2200E. {& [E/result]} [E] {'} then {%} [4] {'}.\nProof. By induction on the structure of .\nAssumption 1. The program is correct:\n\u22a2 program correct\n4It is in fact the least fixpoint.\nLemma 4 (Main Soundness Lemma).\n\u2200\u210e,\u210ef, %,&. \u210e % \u21d2\n(\u22004 . {%} 4 {&} \u2227 ( \u210e\u2032, E . \u210e \u228e \u210ef, 4 \u21d3 \u210e \u2032 \u228e \u210ef, E \u2227 \u210e \u2032 & [E/result]) \u21d2\n\u210e \u228e \u210ef, 4 div) \u2227\n(\u22002. {%} 2 {&} \u2227 ( \u210e\u2032. \u210e \u228e \u210ef, 2 \u21d3 \u210e \u2032 \u228e \u210ef \u2227 \u210e \u2032 &) \u21d2\n\u210e \u228e \u210ef, 2 div) \u2227\n(\u2200>, , 4 . {%} >\u2192 (4) {&} \u2227 ( \u210e\u2032. \u210e \u228e \u210ef, >\u2192 (4) \u21d3 \u210e \u2032 \u228e \u210ef \u2227 \u210e \u2032 &) \u21d2\n\u210e \u228e \u210ef, >\u2192 (4) div) \u2227 (\u2200>, . {%} >\u2192~ () {&} \u2227 ( \u210e\u2032. \u210e \u228e \u210ef, >\u2192 (4) \u21d3 \u210e \u2032 \u228e \u210ef \u2227 \u210e \u2032 &) \u21d2\n\u210e \u228e \u210ef, >\u2192~ () div)\nProof. By mutual co-induction and, nested inside of it, induction on the derivation of the correctness judgment. We elaborate a few cases:\n\u2022 Case HDynamicDispatch. Assume the following:\n2 = >\u2192< (E) > :st\nclass \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual< (G) req % ens & \u00b7 \u00b7 \u00b7 } % = > :dyn \u2227 % [>/this, /\\, E/G ]\n& = & [>/this, /\\, E/G] class \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual< (G) req % ens & {2<} \u00b7 \u00b7 \u00b7 }\nBy\u210e % , we have3C~?4 (>, ) \u2286 \u210e and\u210e % [>/this, /\\, E/G ]. Let >\u2032 = > \u2193 . By the correctness of method< in class , we have\n{% [> \u2032/this, /\\, E/G]}\n2< [> \u2032/this, E/G]\n{& [> \u2032/this, /\\, E/G ]}\nBy the fact that< in correctly overrides< in , we have\n{% }_{& } \u21d2 {% }_{& }\nIt follows that\n{% [>/this, /\\, E/G]} 2< [>\n\u2032/this, E/G] {& [>/this, /\\, E/G ]}\nThe relevant inference rule for divergence of dynamically dispatched method calls is as follows:\nODynamicDispatchDiv3\nclass \u00b7 \u00b7 \u00b7 { \u00b7 \u00b7 \u00b7 virtual< (G){2} \u00b7 \u00b7 \u00b7 } \u210e, 4 \u21d3 \u210e\u2032, > >\u2032 = > \u2193\n\u210e\u2032, 4 \u21d3 \u210e\u2032\u2032, E 3C~?4 (>, ) \u2286 \u210e\u2032\u2032 \u210e\u2032\u2032, 2 [>\u2032/this, E/G ] div\n\u210e,4\u2192< (4) div\nWe apply this rule to the goal, which reduces the goal to \u210e, 2< [> \u2032/this, E/G] div. We now apply the coinduction hypothesis. We are now left with the job of proving that the body does not terminate, assuming that the call does not terminate. Instead, we prove that the call terminates, assuming that the body terminates. We conclude that proof by applying ODynamicDispatch.\n\u2022 CaseHConsContext. Assume a constructor argument list E 4 4 . By the induction hypothesis corresponding to the first\npremise of HConsContext, we have that evaluation of 4 either terminates or diverges.\n\u2013 Assume 4 terminates with a value E . By the induction\nhypothesis corresponding to the second premise of HConsContext, we have that >\u2192 (E E 4) either terminates or diverges.\n\u2217 Assume > \u2192 (E E 4) terminates. This must be by an application of OConstruct. Therefore,\nit must be that 4 all terminate. It follows that\n>\u2192 (E 4 4) terminates. \u2217 Assume >\u2192 (E E 4) diverges. Given that 4 ter-\nminates, we can easily prove that > \u2192 (E 4 4) diverges.\n\u2013 Assume 4 diverges. Then >\u2192 (E, 4, 4) diverges. \u2022 CaseHContext.We apply Lemma 3 and use the induction\nhypotheses to discharge the resulting subgoals.5\n5To see that this preserves productivity of the coinductive proof, notice that Lemma 3 is size-preserving: given approximations up to depth 3 of the proof trees for the lemma\u2019s premises, the lemma produces a proof tree of depth at least 3 ."
        }
    ],
    "title": "Verifying C++ Dynamic Binding",
    "year": 2023
}