{
    "abstractText": "The concept of must testing is naturally parametrised with a chosen completeness criterion or fairness assumption. When taking weak fairness as used in I/O automata, I show that it characterises exactly the fair preorder on I/O automata as defined by Lynch & Tuttle.",
    "authors": [
        {
            "affiliations": [],
            "name": "Rob van Glabbeek"
        },
        {
            "affiliations": [],
            "name": "R.J. van Glabbeek"
        }
    ],
    "id": "SP:89be84904ba77e3e2a008b54583ab8acf677ac94",
    "references": [
        {
            "authors": [
                "E. Brinksma",
                "A. Rensin"
            ],
            "title": " W",
            "venue": "Vogler (1995): Fair Testing. In I. Lee & S.A. Smolka, editors: Proceedings 6th International Conference on Concurrency Theory, (CONCUR\u201995), Philadelphia, PA, USA, August",
            "year": 1995
        },
        {
            "authors": [
                "R. De Nicola",
                "M. Hennessy"
            ],
            "title": "Testing equivalences for processes",
            "venue": "Theoretical Computer Science",
            "year": 1984
        },
        {
            "authors": [
                "Y. Deng",
                "R.J. van Glabbeek",
                "C.C.M. Hennessy"
            ],
            "title": "Characterising Testing Preorders for Finite Probabilistic Processes",
            "venue": "Logical Methods in Computer Science",
            "year": 2008
        },
        {
            "authors": [
                "R.J. van Glabbeek"
            ],
            "title": "Justness: A Completeness Criterion for Capturing Liveness Properties (extended abstract)",
            "venue": "editors: Proceedings 22st International Conference on Foundations of Software Science and Computation Structures (FoSSaCS\u201919); held as part of the European Joint Conferences on Theory and Practice of Software (ETAPS\u201919),",
            "year": 2019
        },
        {
            "authors": [
                "R.J. van Glabbeek"
            ],
            "title": "Reward Testing Equivalences for Processes",
            "venue": "Dedicated to Rocco De Nicola on the Occasion of His 65th Birthday,",
            "year": 2019
        },
        {
            "authors": [
                "V. Nataraja"
            ],
            "title": " R",
            "venue": "Cleaveland (1995): Divergence and Fair Testing. In Z. F\u00fcl\u00f6p & F. G\u00e9cseg, editors: Proceedings 22nd International Colloquium on Automata, Languages and Programming (ICALP\u201995), Szeged, Hungary, July",
            "year": 1995
        },
        {
            "authors": [
                "R. Segal"
            ],
            "title": "1996): Testing Probabilistic Automata",
            "venue": "In U. Montanari & V. Sassone, editors: Proceedings of the 7th International Conference on Concurrency Theory, CONCUR\u201996, Pisa, Italy, August 1996, LNCS",
            "year": 1119
        },
        {
            "authors": [
                "R. Segala"
            ],
            "title": "Quiescence, Fairness, Testing, and the Notion of Implementation",
            "venue": "Information and Computation",
            "year": 1997
        },
        {
            "authors": [
                "F.W. Vaandrage"
            ],
            "title": "1991): On the Relationship Between Process Algebra and Input/Output Automata",
            "venue": "Proceedings of the Sixth Annual Symposium on Logic in Computer Science (LICS \u201991), Amsterdam, The Netherlands, July 15-18,",
            "year": 1991
        }
    ],
    "sections": [
        {
            "text": "Keywords: I/O automata \u00b7 Must testing \u00b7 Fairness.\nThis paper is dedicated to Frits Vaandrager at the occasion of his 60th birthday. I fondly remember my days at CWI as a starting computer scientist, sharing an office with Frits. Here I had the rare privilege of sharing all my ideas with Frits at the time they were formed, and receiving instantaneous meaningful feedback. This feedback has had a great impact on my work.\nI take the opportunity to also pass best wishes and warmest thoughts to Frits from Ursula Goltz, whom I am visiting while finishing this paper. My joint work with Ursula was inspired by my work with Frits on connecting Petri nets and process algebra."
        },
        {
            "heading": "1 Introduction",
            "text": "May- and must-testing was proposed by De Nicola & Hennessy in [2]. It yields semantic equivalences where two processes or automata are distinguished if and only if they react differently on certain tests. The tests are processes that additionally feature success states. Such a test T is applied to a process A by taking the CCS parallel composition T |A, and implicitly applying a CCS restriction operator to it that removes the remnants of uncompleted communication attempts. The outcome of applying T to A is deemed successful if and only if this composition yields a process that may, respectively must, reach a success state. It is trivial to recast this definition of may- and must-testing equivalence using the CSP parallel composition } [8] instead of the one from CCS.\nI/O automata [9] are a model of concurrency that distinguishes output actions, which are under the control of a given automaton, from input actions, which are stimuli from the environment on which an automaton might react. The parallel composition } of I/O automata, exactly like the one of CSP, imposes synchronisation on actions the composed automata have in common. However, it allows forming the composition A}B only when A and B have no output actions\nar X\niv :2\n21 2.\n11 24\n8v 1\n[ cs\n.L O\n] 2\nin common. This makes it impossible to synchronise on actions c where both A and B have the option not to allow c in certain states.\nMust testing equivalence for CCS and CSP partially discerns branching time, in the sense that is distinguishes the processes \u03c4.pa`bq and \u03c4.a`\u03c4.b displayed in Figure 1. This is not the case for I/O automata, as the synchronisations between test and tested automaton that are necessary to make such distinctions are ruled out by the restriction described above.\nIt is not a priori clear how a given process or automaton must reach a success state. For all we know it might stay in its initial state and never take any transition leading to this success state. To this end one must employ an assumption saying that under appropriate circumstances certain enabled transitions will indeed be taken. Such an assumption is called a completeness criterion [5]. The theory of testing from [2] implicitly employs a default completeness criterion that in [7] is called progress. However, one can parameterise the notion of must testing by the choice of any completeness criterion, such as the many notions of fairness classified in [7].\nLynch & Tuttle [9] defined a trace and a fair preorder on I/O automata, which were meant to reason about safety and liveness properties, respectively, just like the may- and must testing preorders of [2]. Unsurprisingly, as formally shown in Section 5 of this paper, the trace preorder on I/O automata is characterised exactly by may testing. Segala [12] has studied must-testing on I/O automata, employing the default completeness criterion, and found that on a large class of I/O automata it characterises the quiescent trace preorder of Vaandrager [13]. It does not exactly characterise the fair preorder, however.\nIn my analysis this is due to the choice of progress as the completeness criterion employed for must testing, whereas the fair preorder of I/O automata is based on a form of weak fairness. In this work I study must testing on I/O automata based on the same form of weak fairness, and find that it characterises the fair preorder exactly.\nAlthough I refer to must-testing with fairness as the chosen completeness criterion as fair must testing, it should not be confused with the notion of fair testing employed in [1,10]. The latter is also known as should testing. It incorporates a concept of fairness that is much stronger than the notion of fairness from I/O automata, called full fairness in [7].\nIn [6] another mode of testing was proposed, called reward testing. Rewardtesting equivalence combines the distinguishing power of may as well as must testing, and additionally makes some useful distinctions between processes that are missed by both may and must testing [6]. As for must testing, its definition is naturally parametrised by a completeness criterion. When applied to I/O automata, using as completeness criterion the form of fairness that is native to I/O automata, it turns out that reward testing is not stronger than must testing, and also characterises the fair preorder."
        },
        {
            "heading": "2 I/O automata",
            "text": "An I/O automaton is a labelled transition system equipped with a nonempty set of start states, with each action that may appear as transition label classified as an input, an output or an internal action. Input actions are under the control of the environment of the automaton, whereas output and internal actions, together called locally-controlled actions, are under the control of the automaton itself. I/O automata are input enabled, meaning that in each state each input action of the automaton can be performed. This indicates that the environment may perform such actions regardless of the state of the automaton; an input transition merely indicates how the automaton reacts on such an event. To model that certain input actions have no effect in certain states, one uses self-loops.\nI/O automata employ a partition of the locally-controlled actions into tasks to indicate which sequences of transitions denote fair runs. A run is fair unless it has a suffix on which some task is enabled in every state, yet never taken.\nDefinition 1 An input/output automaton (or I/O automaton) A is a tuple pactspAq, statespAq, startpAq, stepspAq, partpAqq with \u2013 actspAq a set of actions, partitioned into three sets inpAq, outpAq and intpAq\nof input actions, output actions and internal actions, respectively, \u2013 statespAq a set of states, \u2013 startpAq \u010e statespAq a nonempty set of start states, \u2013 stepspAq \u010e statespAq \u02c6 actspAq \u02c6 statespAq a transition relation with the\nproperty that @s P statespAq. @a P inpAq. Dps, a, s1q P stepspAq, and \u2013 partpAq \u010ePplocalpAqq a partition of the set localpAq :\u201c outpAq Y intpAq of\nlocally-controlled actions of A into tasks.\nLet extpAq :\u201c inpAq Y outpAq be the set of external actions of A.\nAn action a P actspAq is enabled in a state s P statespAq if Dps, a, s1q P stepspAq. A task T P partpAq is enabled in s if some action a P T is enabled is s.\nDefinition 2 An execution of an I/O automaton A is an alternating sequence \u03b1 \u201c s0, a1, s1, a2, . . . of states and actions, either being infinite or ending with a state, such that s0 P startpAq and psi, ai`1, si`1q P stepspAq for all i \u0103 lengthp\u03b1q. Here lengthp\u03b1q P IN Y t8u denotes the number of action occurrences in \u03b1. The sequence a1, a2, . . . obtained by dropping all states from \u03b1 is called schedp\u03b1q. An execution \u03b1 of A is fair if, for each suffix \u03b11 \u201c sk, ak`1, sk`1, ak`2, . . . of \u03b1 (with k P IN^ k \u010f lengthp\u03b1q) and each task T P partpAq, if T is enabled in each state of \u03b11, then \u03b11 contains an action from T .\nIn [9] two semantic preorders are defined on I/O automata, here called \u010eT and \u010eF , the trace and the fair preorder. In [9] S \u010eT I and S \u010eF I are denoted \u201cI implements S\u201d and \u201cI solves S\u201d, respectively. Here S is an I/O automaton that is (a step closer to) the specification of a problem, and I one that is (a step closer to) its implementation. The preorder \u010eT is meant to reason about safety properties: if S \u010eT I then I has any safety property that S has. In the same way, \u010eF is for reasoning about liveness properties. In [12] and much subsequent\nwork S \u010eF I is written as I \u010eF S. Here I put I on the right, so as to orient the refinement symbol \u010e in the way used in CSP [8], and in the theory of testing [2].\nI/O automata are a typed model of concurrency, in the sense that two automata will be compared only when they have the same input and output actions.\nDefinition 3 Let tracep\u03b1q be the finite or infinite sequence of external actions resulting from dropping all internal actions in schedp\u03b1q, and let fintracespAq be the set ttracep\u03b1q | \u03b1 is a finite execution of Au. Likewise fairtracespAq :\u201c ttracep\u03b1q | \u03b1 is a fair execution of Au. Now\nS \u010eT I :\u00f4 inpSq \u201c inpIq ^ outpSq \u201c outpIq^ fintracespIq \u010e fintracespSq S \u010eF I :\u00f4 inpSq \u201c inpIq ^ outpSq \u201c outpIq^fairtracespIq \u010e fairtracespSq .\nOne writes A \u201dT B if A \u010eT B ^B \u010eT A, and similarly for \u201dF .\nBy [7, Thm. 6.1] each finite execution can be extended into a fair execution. As a consequence, A \u010eF B \u00f1 A \u010eT B.\nThe parallel composition of I/O automata [9] is similar to the one of CSP [8]: participating automata Ai and Aj synchronise on actions in actspAiqXactspAjq, while for the rest allowing arbitrary interleaving. However, it is defined only when the participating automata have no output actions in common.\nDefinition 4 A collection tAiuiPI of I/O automata is strongly compatible if \u2013 intpAiq X actspAjq \u201c H for all i, j P I with i \u2030 j, and \u2013 outpAiq X outpAjq \u201c H for all i, j P I with i \u2030 j, \u2013 no action is contained in infinitely many sets actspAiq.\nThe composition A \u201c \u015b iPI Ai of a countable collection tAiuiPI of strongly compatible I/O automata is defined by \u2013 intpAq :\u201c \u0164\niPI intpAiq, \u2013 outpAq :\u201c \u0164\niPI outpAiq, \u2013 inpAq :\u201c \u0164\niPI inpAiq \u00b4 outpAq, \u2013 statespAq :\u201c \u015b\niPI statespAiq, \u2013 startpAq :\u201c \u015b\niPI startpAiq, \u2013 stepspAq is the set of triples p~s1, a, ~s2q such that, for all i P I, if a P actspAiq\nthen p~s1ris, a, ~s2risq P stepspAiq, and if a R actspAiq then ~s1ris \u201c ~s2ris, and \u2013 partpAq :\u201c \u0164\niPI partpAiq.\nClearly, composition of I/O automata is associative: when writing A1}A2 for \u015b\niPt1,2uAi then pA}Bq}C \u2013 A}pB}Cq, for some notion of isomorphism \u2013, included in \u201dT and \u201dF . Moreover, as shown in [9], composition is monotone for \u010eT and \u010eF , or in other words, \u010eT and \u010eF are precongruences for composition:\nif Ai \u010eT Bi for all i P I, then \u015b iPI Ai \u010eT \u015b iPI Bi , and if Ai \u010eF Bi for all i P I, then \u015b iPI Ai \u010eF \u015b iPI Bi .\nThe first condition of strong compatibility is not a limitation of generality. Each I/O automaton is \u201dT and \u201dF -equivalent to the result of bijectively renaming its internal actions. Hence, prior to composing a collection of automata, one could rename their internal actions to ensure that this condition is met. Up to \u201dT and \u201dF the composition would be independent on the choice of these renamings."
        },
        {
            "heading": "3 Testing preorders",
            "text": "Testing preorders [2] are defined between automata A, defined as in Def. 1, but without the partition partpAq and without the distinction between input and output actions, and therefore also without the input enabling requirement from Item 4. The parallel composition of automata is as in Def. 4, but without the requirement that the participating automata have no output actions in common.\nDefinition 5 An automaton A is a tuple pactspAq, statespAq, startpAq, stepspAqq with\n\u2013 actspAq a set of actions, partitioned into two sets extpAq and intpAq of external actions and internal actions, respectively, \u2013 statespAq a set of states, \u2013 startpAq \u010e statespAq a nonempty set of start states, and \u2013 stepspAq \u010e statespAq \u02c6 actspAq \u02c6 statespAq a transition relation.\nA collection tAiuiPI of I/O automata is compatible if\n\u2013 intpAiq X actspAjq \u201c H for all i, j P I with i \u2030 j, and \u2013 no action is contained in infinitely many sets actspAiq.\nThe composition A \u201c \u015b iPI Ai of a countable collection tAiuiPI of compatible I/O automata is defined by\n\u2013 intpAq :\u201c \u0164 iPI intpAiq, \u2013 extpAq :\u201c \u0164\niPI extpAiq, \u2013 statespAq :\u201c \u015b\niPI statespAiq, \u2013 startpAq :\u201c \u015b\niPI startpAiq, and \u2013 stepspAq is the set of triples p~s1, a, ~s2q such that, for all i P I, if a P actspAiq\nthen p~s1ris, a, ~s2risq P stepspAiq, and if a R actspAiq then ~s1ris \u201c ~s2ris.\nA test is such an automaton, but featuring a special external action w, not used elsewhere. This action is used to mark success states: those in which w is enabled. The parallel composition T }A of a test T and an automaton A, if it exists, is itself a test, and rT }As denotes the result of reclassifying all its non-w actions as internal. An execution of rT }As is successful iff it contains a success state.\nDefinition 6 An automaton A may pass a test T , notation A may T , if rT }As has a successful execution. It must pass T , notation A must T , if each complete execution1 of rT }As is successful. It should pass T , notation A should T , if each finite execution of rT }As can be extended into a successful execution.\nWrite A \u010emay B if extpAq \u201c extpBq and A may T implies B may T for each test T that is compatible with A and B. The preorders \u010emust and \u010eshould are defined similarly.\n1 The original work on must testing [2] defined an execution to be complete if it either is infinite, of ends in a state without outgoing transitions. Here I will consider the concept of a complete execution as a parameter in the definition of must testing.\nThe may- and must-testing preorders stem from [2], whereas should-testing was added independently in [1] and [10]. I have added the condition extpAq \u201c extpBq to obtain preorders that respect the types of automata. A fourth mode of testing, called reward testing, was contributed in [6]. It has no notion of success state, and no action w; instead, each transition of a test T is tagged with a real number, the reward of taking that transition. A negative reward can be seen as a penalty. Each transition ps, a, s1q of rT }As with a P actspT q inherits its reward from the unique transition of T it projects to; in case a R actspT q it has reward 0. The reward rewardp\u03b1q of an execution \u03b1 is the sum of the rewards of the actions in \u03b1.2 Now A \u010ereward B if extpAq \u201c extpBq and for each test T that is compatible with A and B and for each complete execution \u03b2 of rT }Bs there exists a complete execution \u03b1 of rT }As such that rewardp\u03b1q \u010f rewardp\u03b2q.\nIn the original work on testing [2,6] the CCS parallel composition T |A was used instead of the CSP parallel composition T }A; moreover, only those executions consisting solely of internal actions mattered for the definitions of passing a test. The present approach is equivalent, in the sense that it trivially gives rise to the same testing preorders.\nThe may-testing preorder can be regarded as pointing in the opposite direction as the others. Using CCS notation, one has \u03c4.P \u0139may \u03c4.P ` \u03c4.Q, yet \u03c4.P ` \u03c4.Q \u0139must \u03c4.P , \u03c4.P ` \u03c4.Q \u0139should \u03c4.P and \u03c4.P ` \u03c4.Q \u0139reward \u03c4.P . The inverse of the may-testing preorder can be characterised as survival testing. Here a state in which w is enabled is seen as a failure state rather than a success state, and automaton A survives test T , notation A surv T , if no execution of rT }As passes through a failure state. Write A \u010esurv B if extpAq \u201c extpBq and A surv T implies B surv T for each test T that is compatible with A and B. By definition, A \u010esurv B iff B \u010emay A.\nThe only implications between reward, must and may/survival testing are\nA \u010ereward B \u00f1 A \u010emust B and A \u010ereward B \u00f1 A \u010esurv B .\nNamely, any must test T witnessing A \u0118must B can be coded as a reward test by assigning a reward `1 to all transitions of T leading to a success state (and 0 to all other transitions). Likewise any survival test T witnessing A \u0118surv B can be coded as a reward test by assigning a reward \u00b41 to all transitions of T leading to a failure state.\nThe notions of may- and should-testing are unambiguously defined above, whereas the notions of must- and reward testing depend on the definition of a complete execution. In [5] I posed that transition systems or automata constitute a good model of distributed systems only in combination with a completeness criterion: a selection of a subset of all executions as complete executions, modelling complete runs of the represented system.\nThe default completeness criterion, employed in [2,6] for the definition of must- and reward testing, deems an execution complete if it either is infinite, of ends in deadlock, a state without outgoing transitions. Other completeness\n2 If \u03b1 is infinite, its reward can be `8 or \u00b48; see [6] for a precise definition.\ncriteria either classify certain finite executions that do not end in deadlock as complete, or certain infinite executions as incomplete.\nThe first possibility was explored in [5,7] by considering a set B of actions that might be blocked by the environment in which an automaton is running. Now a finite execution can be deemed complete if all transitions enabled in its last state have labels from B. The system might stop at such a state if indeed the environment blocks all those actions. Since in the application to must- and reward testing, all non-w transitions in rT }As are labelled with internal actions, which cannot be blocked by the environment, the above possibility of increasing the set of finite complete executions does not apply.\nThe second possibility was extensively explored in [7], where a multitude of completeness criteria was defined. Most of those can be used as a parameter in the definition of must- and reward testing. So far, the resulting testing preorders have not been explored.3"
        },
        {
            "heading": "4 Testing preorders for I/O automata",
            "text": "Since I/O automata can be seen as special cases of the automata from Section 3, the definitions of Section 3 also apply to I/O automata. The condition extpAq \u201c extpBq should then be read as inpAq \u201c inpBq^outpAq \u201c outpBq. The only place where it makes an essential difference whether one works with I/O automata or general automata is in judging compatibility between automata and tests. Given two I/O automata A and B, let A \u010eLTSmust B be defined by first seeing A and B as general automata (by dropping the partitions partpAq and partpBq), and then applying the definitions of Section 3, using the default completeness criterion. In contrast, let A \u010ePrmust B be defined as Section 3, but only allowing tests that are themselves I/O automata (seeing the special action w as an output action), and that are strongly compatible with A and B. The superscript Pr stands for \u201cprogress\u201d, the name given in [7] to the default completeness criterion. The difference between \u010eLTSmust and \u010ePrmust is illustrated in Figure 1.\n3 The paper [4] explores these testing preorders; it was written after the present paper.\nHere A and B are automata with actspAq \u201c actspBq \u201c t\u03c4, a, bu, and T is a test with actspT q \u201c ta, b, wu. The short arrows point to start states. Test T witnesses that A \u0118LTSmust B, for A must T , yet pB must T q. Here it is crucial that a P actspT q, even though this action labels no transition of T , for otherwise the a-transition of A would return in rT }As and one would not obtain A must T. To see A, B and T as I/O automata, one needs to take inpAq \u201c inpBq \u201c inpT q \u201c H, and thus a, b P outpAq X outpBq X outpT q. However, this violates the strong compatibility of T with A and B, so that T is disqualified as an appropriate test. There is no variant of T that is strongly compatible with A and B and yields the same result; in fact A \u201dPrmust B."
        },
        {
            "heading": "5 May testing",
            "text": "For may-testing on I/O automata there is no difference between \u010eLTSmay\u2014allowing any test that is compatible with A and B\u2014and \u010emay\u2014allowing only tests that are strongly compatible with A and B. These preorders both coincide with the trace preorder \u011aT .\nTheorem 1 A \u010eLTSmay B iff A \u010emay B iff B \u010eT A.\nProof. Suppose B \u010eT A, i.e., inpAq\u201cinpBq^outpAq\u201coutpBq and fintracespAq \u010e fintracespBq, and let T be any test compatible with A and B. The automaton T need not be an I/O automaton, and even if it is, it need not be strongly compatible with A and B. It is well-known that \u010eT is a precongruence for composition [8], so fintracespT }Aq \u010e fintracespT }Bq. Since C may T (for any C) iff w occurs in a trace \u03c3 P fintracespT }Cq, it follows that A may T implies B may T . Thus A \u010eLTSmay B.\nThat A \u010eLTSmay B implies A \u010emay B is trivial. Now suppose A \u010emay B. Then inpAq \u201c inpBq ^ outpAq \u201c outpBq. Let \u03c3 \u201c\na1a2 . . . an P fintracespAq. Let T be the test automaton\nS\n1 2 a1\n3 a2\nn W an\nE w\nwith outpT q :\u201c inpAq Z twu, inpT q :\u201c outpAq and intpT q :\u201c H. To make sure that T is an I/O automaton, the dashed arrows are labelled with all input actions of T , except for ai (if ai P inpT q) for the dashed arrow departing from state i. By construction, T is strongly compatible with A and B. Now C may T (for any C) iff \u03c3 P fintracespCq. Hence A may T , and thus B may T , and therefore \u03c3 P fintracespBq. [\\"
        },
        {
            "heading": "6 Must testing based on progress",
            "text": "Definition 7 An I/O automaton T is complementary to I/O automaton A if outpT q \u201c inpAq Z twu, inpT q \u201c outpAq and intpT q X intpAq \u201c H.\nIn this case T and A are also strongly compatible, so that T }A is defined, and inpT }Aq \u201c H. I now show that for the definition of \u010ePrmust it makes no difference whether one restricts the tests T that may be used to compare two I/O automata A and B to ones that are complementary to A and B.\nFor use in the following proof, define the relation \u201d between I/O automata by C \u201d D iff statespCq \u201c statespDq ^ startpCq \u201c startpDq ^ stepspCq \u201c stepspDq. Note that T }A \u201d T 1}A implies that A must T iff A must T 1.\nProposition 1 A \u010ePrmust B iff inpAq \u201c inpBq ^ outpAq \u201c outpBq and A must T implies B must T for each test T that is complementary to A and B.\nProof. Suppose A \u010ePrmust B. Then inpAq\u201cinpBq^outpAq\u201coutpBq and A must T implies B must T for each test T that is strongly compatible with A and B, and thus certainly for each test T that is complementary to A and B.\nNow suppose inpAq \u201c inpBq ^ outpAq \u201c outpBq but A \u0118Prmust B. Then there is a test T , strongly compatible with A and B, such that A must T , yet pB must T q. It suffices to find a test T 2 with the same properties that is moreover complementary to A and B.\nFirst modify T into T 1 by adding extpAqzextpT q to inpT 1q, while adding a loop ps, a, sq to stepspT 1q for each state s P statespT 1q and each a P extpAqzextpT q. Now T }A \u201c T 1}A and T }B \u201c T 1}B, and thus A must T 1, yet pB must T 1q. Moreover, extpAq \u201c extpBq \u010e extpT 1q.\nModify T 1 further into T 2 by reclassifying any action a P inpT 1q X inpAq as an output action of T 2 and any a P extpT 1qzpextpAqZ twuq as an internal action of T 2. How partpT 2q is defined is immaterial. Then T 1}A \u201d T 2}A and T 1}B \u201d T 2}B, and thus A must T 2, yet pB must T 2q. Now outpT 2q \u201c inpAq Z twu, inpT 2q \u201c outpAq, intpT 2q X intpAq \u201c H and intpT 2q X intpBq \u201c H. [\\\nUsing the characterisation of Prop. 1 as definition, the preorder \u010ePrmust on I/O automata has been studied by Segala [12, Section 7]. There it was related to the quiescent trace preorder \u010eQ defined by Vaandrager [13]. Similar as for the preorders of Section 2, I write S \u010eQ I for what was denoted I \u010eQ S in [12], and I \u010eqT S in [13].\nDefinition 8 An execution \u03b1 is quiescent if it is finite and its last state enables only input actions. Let qtracespAq:\u201cttracep\u03b1q | \u03b1 is a quiescent execution of Au. Now\nS \u010eQ I :\u00f4 S \u010eT I ^ qtracespIq \u010e qtracespSq .\nAn I/O automaton is finitely branching iff each of its states enables finitely many transitions; it is strongly convergent if it has no infinite execution \u03b1 with tracep\u03b1q finite, i.e., no execution with an infinite suffix of only internal actions.\nTheorem 2 ([12, Thm. 7.3]) Let A and B be finitely branching and strongly convergent I/O automata. Then A \u010ePrmust B iff A \u010eQ B.\nNote that an execution is quiescent iff it is fair and finite. By [12, Thm. 5.7], if A is strongly convergent then A \u010eF B implies A \u010eQ B. (For let A \u010eF B. If \u03c3 P qtracespBq, then \u03c3 P fairtracespBq \u010e fairtracespAq so A has a fair execution \u03b1 with tracep\u03b1q \u201c \u03c3. As A is strongly convergent, \u03b1 is finite. Hence \u03c3 P qtracespAq.) This does not hold when dropping the side condition of strong convergence. Take A \u201c and B \u201c \u03c4 with actspAq \u201c H and actspBq \u201c intpBq \u201c t\u03c4u. Then A \u201dF B, yet A \u0118Q B (and A \u0118Prmust B).\nEven restricted to finitely branching and strongly convergent I/O automata, A\u010eQB does not imply A\u010eF B. This is illustrated by [12, Examples 5.1 and 5.2]."
        },
        {
            "heading": "7 Must testing based on fairness",
            "text": "As explained in Section 3, the notion of must testing is naturally parametrised by the choice of a completeness criterion. As I/O automata are already equipped with a completeness criteria, namely the notion of fairness from Def. 2, the most appropriate form of must testing for I/O automata takes this concept of fairness as its parameter, rather than the default completeness criterion used in Section 6.\nA problem in properly defining a must-testing preorder \u010eFmust involves the definition of the operator r s employed in Def. 6. In the context of standard automata, this operator reclassifies all its external actions, except for the success action w, as internal. When applied to I/O automaton A, it is not a priori clear how to define partprAsq, for this is a partition of the set of locally-controlled actions into tasks, and when changing an input action into a locally-controlled action, one lacks guidance on which task to allocate it to. This was a not a problem in Section 6, as there the must-testing preorder \u010ePrmust depends in no way on part .\nBelow I inventorise various solutions to this problem, which gives rise to three possible definitions of \u010eFmust. Then I show in Section 9 that all three resulting preorders coincide, so that it doesn\u2019t matter on which of the definitions one settles. Moreover, these preorders all turn out to coincide with the fair preorder \u010eF that comes with I/O automata.\nMy first (and default) solution is to simply drop the operator r s from Def. 6:\nDefinition 9 An I/O automaton A must pass a test T fairly\u2014A mustF T\u2014if each fair execution of T }A is successful. Write A \u010eFmust B if inpAq \u201c inpBq ^ outpAq \u201c outpBq and A mustF T implies B mustF T for each test T that is strongly compatible with A and B.\nThis is a plausible approach, as none of the testing preorders discussed in Sections 3\u20136 would change at all were the operator r s dropped from Def. 6. This is the case because the set of executions, successful executions and complete executions of an automaton A is independent of the status (input, output or internal) of the actions of A.\nThe above begs the question why I bothered to employ the operator r s in Def. 6 in the first place. The main reason is that the theory of testing [2] was developed in the context of CCS, where each synchronisation of an action from a test with one from a tested process yields an internal action \u03c4 . Def. 6 recreates this theory using the operator } from CSP [8] and I/O automata [9], but as here synchronised actions are not internal, they have to be made internal to obtain the same effect. A second reason concerns the argument used towards the end of Section 3 for not parametrising notions of testing with a set B of actions that can be blocked; this argument hinges on all relevant actions being internal.\nMy second solution is to restrict the set of allowed tests T for comparing I/O automata A and B to those for which inpT }Aq \u201c inpT }Bq \u201c H. This is the case iff inpT q \u010e outpAq and inpAq \u010e outpT q. In that case rT }As and rT }Bs are trivial to define, as the set of locally-controlled actions stays the same. Moreover, it makes no difference whether this operator is included in the definition of must or not, as the set of fair executions of a process is not affected by a reclassification of output actions as internal actions.\nDefinition 10 Write A H\u010eFmust B if inpAq\u201c inpBq^outpAq\u201coutpBq and moreover A mustF T implies B mustF T for each test T that is strongly compatible with A and B, and for which inpT }Aq \u201c inpT }Bq \u201c H.\nA small variation of this idea restricts the set of allowed tests even further, namely to the ones that are complementary to A and B, as defined in Def. 7. This yield a fair version of the must-testing preorder employed in [12].\nDefinition 11 Write A cm\u010eFmust B if inpAq \u201c inpBq ^ outpAq \u201c outpBq and A mustF T implies B mustF T for each T that is complementary to A and B.\nAs a last solution I consider tests T that are not restricted as in Defs. 10 or 11, while looking for elegant ways to define rT }As and rT }Bs. First of all, note that no generality is lost when restricting to tests T such that extpAqp\u201c extpBqq \u010e extpT q, regardless how the operator r s is defined. Namely, employing the first conversion from the proof of Prop. 1, any test T that is strongly compatible with I/O automata A and B can converted into a test T 1 satisfying this requirement, and such that T }A \u201c T 1}A and T }B \u201c T 1}B.\nAn application of r s to T }A consists of reclassifying external actions of T }A as internal actions. However, since for the definition of the testing preorders it makes no difference whether an action in T }A is an internal or an output action, one can just as well use an operator r s1 that merely reclassifies input actions of T }A as output actions. Note that inpT }Aq \u010e inpT q, using that extpAq \u010e extpT q. Let T\u02da be a result of adapting the test T by reclassifying the actions in inpT }Aq from input actions of T into output actions of T ; the test T\u02da is not uniquely defined, as there are various ways to fill in partpT\u02daq.\nObservation 1 Apart from the problematic definition of partprT }As1q, the I/O automaton rT }As1 is the very same as T\u02da}A.\nIn other words, the reclassification of input into output actions can just as well be done on the test, instead of on the composition of test and tested automaton. The advantage of this approach is that the problematic definition of partprT }As1q is moved to the test as well. Now one can use T\u02da}A instead of rT }As1 in the definition of must testing for any desired definition of partpT\u02daq. This amounts to choosing any test T\u02da with inpT\u02da}Aq \u201c H. It makes this solution equivalent to the one of Def. 10."
        },
        {
            "heading": "8 Action-based must testing",
            "text": "The theory of testing from [2] employs the success action w merely to mark success states; an execution is successful iff it contains a state in which w is enabled. In [3] this is dubbed state-based testing. Segala [11] (in a setting with probabilistic automata) uses another mode of testing, called action-based in [3], in which an execution is defined to be successful iff it contains the action w.\nAlthough the state-based and action-based may-testing preorders obviously coincide, the state-based and action-based must-testing preorders do not, at least when employing the default completeness criterion. An example showing the difference is given in [3]. It involves two automata A and B, which can in fact be seen as I/O automata, such that A \u0118Prmust B, yet A ab\u201dPrmust B. Here ab\u201dPrmust is the action-based version of \u201dPrmust. So far I have considered only state-based testing preorders on I/O automata. Let ab\u010eFmust be the action-based version of \u010eFmust. It is defined as in Def. 9, but using mustFab instead of must F . Here A mustFab T holds iff each fair trace of T }A contains the action w. Below I will show that when taking the notion of fairness from [9] as completeness criterion, state-based and action-based must testing yields the same result, i.e.,\nab\u010eFmust equals \u010eFmust. In fact, I need this result in my proof that \u010eFmust coincides with \u010eF ."
        },
        {
            "heading": "9 Fair must testing agrees with the fair traces preorder",
            "text": "The following theorem states that the must-testing preorder on I/O automata based on the completeness criterion of fairness that is native to I/O automata, in each of the four forms discussed in Sections 7 and 8, coincides with the standard preorder of I/O automata based on reverse inclusion of fair traces.\nTheorem 3 A ab\u010eFmustB iff A\u010eFmustB iff A H\u010eFmustB iff A cm\u010eFmustB iff A\u010eF B.\nProof. Suppose A\u010eFB, i.e., inpAq\u201cinpBq^outpAq\u201coutpBq and fairtracespBq\u010e fairtracespAq, and let T be any test that is strongly compatible with A and B. Since \u010eF is a precongruence for composition (cf. Section 2), fairtracespT }Bq \u010e fintracespT }Aq. Since for action-based must testing C mustFab T (for any C) iff w occurs in each fair trace \u03c3 P fairtracespT }Cq, it follows that A mustFab T implies B mustFab T . Thus A ab\u010eFmustB.\nNow suppose A ab\u010eFmustB. In order to show that A \u010eFmust B, suppose that A mustF T , where T is a test that is strongly compatible with A and B. Let the test T\u02da be obtained from T by (i) dropping all transitions ps, a, s1q P stepspT q for s a success state and a \u2030 w, and (ii) adding a loop ps, a, sq for each success state s and a P inpT q. Since for state-based must testing it is irrelevant what happens after encountering a success state, one has\nC mustF T iff C mustF T\u02da (1)\nfor each I/O automaton C. Moreover, I claim that for each C one has\nC mustF T\u02da iff C mustFab T \u02da. (2)\nHere \u201cif\u201d is trivial. For \u201conly if\u201d, let \u03b1 be a fair execution of T\u02da}C, and suppose, towards a contradiction, that \u03b1 contains a success state ps, rq, with s a success state of T\u02da and r a state of C, but does not contain the success action w. Let \u03b11 be the suffix of \u03b1 starting with the first occurrence of ps, rq. Then all states of \u03b11 have the form ps, r1q, and the action w is enabled in each of these states. Let T P partpT\u02da}Cq be the task containing w. Since w is a locally controlled action of T\u02da, by Def. 4 all members of T must be locally controlled actions of T\u02da. No such action can occur in \u03b11. This contradicts the assumption that \u03b1 is fair (cf. Def. 2), and thereby concludes the proof of (2).\nFrom the assumption A mustF T one obtains A mustFab T \u02da by (1) and (2),\nand B mustFab T \u02da by the assumption that A ab\u010eFmustB. Hence B mustF T by (2) and (1). Thus A \u010eFmust B.\nThat A\u010eFmustB implies A H\u010eFmustB is trivial. That A H\u010eFmustB implies A\ncm\u010eFmustB is also trivial. Finally, suppose A\ncm\u010eFmustB. Then inpAq \u201c inpBq ^ outpAq \u201c outpBq. Let \u03c3 \u201c a1a2 . . . an P fairtracespBq. Let T be the test automaton\nW E w\n1\n\u03c4\n2 a1\n\u03c4\n3 a2\n\u03c4\nn\n\u03c4\nS an\nwith outpT q :\u201c inpAq Z twu, inpT q :\u201c outpAq and intpT q :\u201c t\u03c4u. The dashed arrows are labelled with all input actions of T , except for ai (if ai P inpT q) for the dashed arrow departing from state i. By construction, T is complementary to A and B. Now C must T (for any C) iff \u03c3 R fairtracespCq. Hence B may not T , and thus A may not T , and therefore \u03c3 P fairtracespAq.\nThe case that \u03c3 \u201c a1a2 . . . P fairtracespBq is infinite goes likewise, but without the state S in T . Hence A\u010eF B. [\\"
        },
        {
            "heading": "10 Reward testing",
            "text": "The reward testing preorder taking the notion of fairness from Def. 2 as underlying completeness criterion can be defined on I/O automata by analogy of Definitions 9, 10 or 11. Here I take the one that follows Def. 9, as it is clearly the strongest, i.e., with its kernel making the most distinctions.\nDefinition 12 Write A \u010eFreward B if inpAq \u201c inpBq ^ outpAq \u201c outpBq and for each reward test T that is strongly compatible with A and B and for each fair execution \u03b2 of T }B there is a fair execution \u03b1 of T }A with rewardp\u03b1q\u010frewardp\u03b2q.\nWhen taking progress as underlying completeness criterion, reward testing is stronger than must testing; the opening page of [6] shows an example where reward testing makes useful distinctions that are missed by may as well as must testing. When moving to fairness as the underlying completeness criterion, must testing no longer misses that example, and in fact must testing becomes equally strong as reward testing. In order to show this, I will use the following notation.\nDefinition 13 Let A1 and A2 be two strongly compatible I/O automata. A state ~s of A1}A2 is a pair p~s r1s, ~s r2sq with ~s rks P statespAkq for k \u201c 1, 2. Let \u03b1 \u201c ~s0, a1, ~s1, a2, . . . be an execution of A1}A2. The projection \u03b1rks of \u03b1 to the kth component Ak, for k \u201c 1, 2, is obtained from \u03b1 by deleting \u201c, ai, ~si\u201d whenever ai R actspAkq, and replacing the remaining pairs ~si by ~sirks.\nMoreover, if \u03c3 is a sequence of external actions of A1}A2, then \u03c3\u00e6Ak is what is left of \u03c3 after removing all actions outside actspAkq.\nNote that if \u03c3 \u201c tracep\u03b1q, for \u03b1 an execution of A1}A2, then \u03c3\u00e6Ak \u201c tracep\u03b1rksq. Moreover, if \u03b1 is an execution of T }A, were T is a test and A a tested automaton, then all rewards of the actions in \u03b1 are inherited from the ones in \u03b1r1s, so that\nrewardp\u03b1q \u201c rewardp\u03b1r1sq. (3)\nTheorem 4 A\u010eFrewardB iff A\u010eFmustB iff A\u010eF B.\nProof. That A\u010eFrewardB implies A\u010eFmustB has been shown in [6, Thm. 7] and is also justified in Section 3.\nThat A\u010eFmustB implies A\u010eF B has been demonstrated by Thm. 3. Suppose A\u010eF B, i.e., inpAq \u201c inpBq ^ outpAq \u201c outpBq and fairtracespBq \u010e fairtracespAq, and let T be any test that is strongly compatible with A and B. Let \u03b2 be a fair execution of T }B. By [9, Prop. 4], \u03b2r1s is a fair execution of T , and \u03b2r2s is a fair execution of B. Since A \u010eF B, automaton A has a fair execution \u03b3 with tracep\u03b3q \u201c tracep\u03b2r2sq. Let \u03c3 :\u201c tracep\u03b2q. Then \u03c3 is a sequence of external actions of T }A such that \u03c3\u00e6T \u201c tracep\u03b2r1sq and \u03c3\u00e6A \u201c \u03c3\u00e6B \u201c tracep\u03b2r2sq \u201c tracep\u03b3q. By [9, Prop. 5], there exists a fair execution \u03b1 of T }A such that tracep\u03b1q \u201c \u03c3, \u03b1r1s \u201c \u03b2r1s and \u03b1r2s \u201c \u03b3. By (3) one has rewardp\u03b1q \u201c rewardp\u03b1r1sq \u201c rewardp\u03b2r1sq \u201c rewardp\u03b2q. Thus A\u010eFrewardB. [\\"
        },
        {
            "heading": "11 Conclusion",
            "text": "When adapting the concept of a complete execution, which plays a central ro\u0302le in the definition of must testing, to the weakly fair executions of I/O automata, must testing turns out to characterise exactly the fair preorder on I/O automata. Moreover, reward testing, which under the default notion of a complete execution is much more discriminating than must testing, in this setting has the same distinguishing power. Interesting venues for future investigation include extending these connections to timed and probabilistic settings."
        }
    ],
    "title": "Fair Must Testing for I/O Automata",
    "year": 2022
}