{
    "abstractText": "Pairing-friendly curves with odd prime embedding degrees at the 128bit security level, such as BW13-310 and BW19-286, sparked interest in the field of public-key cryptography as small sizes of the prime fields. However, compared to mainstream pairing-friendly curves at the same security level, i.e., BN446 and BLS12-446, the performance of pairing computations on BW13-310 and BW19-286 is usually considered inefficient. In this paper we investigate high performance software implementations of pairing computation on BW13-310 and corresponding building blocks used in pairing-based protocols, including hashing, group exponentiations and membership testings. Firstly, we propose efficient explicit formulas for pairing computation on this curve. Moreover, we also exploit the state-of-art techniques to implement hashing in G1 and G2, group exponentiations and membership testings. In particular, for exponentiations in G2 and GT , we present new optimizations to speed up computational efficiency. Our implementation results on a 64-bit processor show that the gap in the performance of pairing computation between BW13-310 and BN446 (resp. BLS12-446) is only up to 4.9% (resp. 26%). More importantly, compared to BN446 and BLS12-446, BW13-310 is about 109.1% \u2212 227.3%, 100% \u2212 192.6%, 24.5%\u2212108.5% and 68.2%\u2212145.5% faster in terms of hashing to G1, exponentiations in G1 and GT , and membership testing for GT , respectively. These results reveal that BW13-310 would be an interesting candidate in pairing-based cryptographic protocols.",
    "authors": [
        {
            "affiliations": [],
            "name": "Yu Dai"
        },
        {
            "affiliations": [],
            "name": "Fangguo Zhang"
        },
        {
            "affiliations": [],
            "name": "Chang-an Zhao"
        }
    ],
    "id": "SP:9d29a15cab5f20ba60e63a9da0eda6fbc6f4f09c",
    "references": [
        {
            "authors": [
                "Diego F. Aranha",
                "Youssef El Housni",
                "Aurore Guillevic"
            ],
            "title": "A survey of elliptic curves for proof systems",
            "venue": "Designs, Codes and Cryptography,",
            "year": 2022
        },
        {
            "authors": [
                "Diego F. Aranha",
                "Laura Fuentes-Casta\u00f1eda",
                "Edward Knapp",
                "Alfred Menezes",
                "Francisco Rodr\u00edguez-Henr\u00edquez"
            ],
            "title": "Implementing pairings at the 192-bit security level",
            "venue": "Pairing",
            "year": 2012
        },
        {
            "authors": [
                "Reza Azarderakhsh",
                "Dieter Fishbein",
                "Gurleen Grewal",
                "Shi Hu",
                "David Jao",
                "Patrick Longa",
                "Rajeev Verma"
            ],
            "title": "Fast software implementations of bilinear pairings",
            "venue": "IEEE Transactions on Dependable and Secure Computing,",
            "year": 2017
        },
        {
            "authors": [
                "Diego F. Aranha",
                "Koray Karabina",
                "Patrick Longa",
                "Catherine H. Gebotys",
                "Julio L\u00f3pez"
            ],
            "title": "Faster explicit formulas for computing pairings over ordinary curves",
            "venue": "Advances in Cryptology \u2013 EUROCRYPT",
            "year": 2011
        },
        {
            "authors": [
                "Ernie Brickell",
                "Jan Camenisch",
                "Liqun Chen"
            ],
            "title": "Direct anonymous attestation",
            "venue": "In Proceedings of the 11th ACM Conference on Computer and Communications Security,",
            "year": 2004
        },
        {
            "authors": [
                "Wieb Bosma",
                "John Cannon",
                "Catherine Playoust"
            ],
            "title": "The Magma algebra system. I",
            "venue": "The user language. J. Symbolic Comput.,",
            "year": 1997
        },
        {
            "authors": [
                "Razvan Barbulescu",
                "Sylvain Duquesne"
            ],
            "title": "Updating key size estimations for pairings",
            "venue": "Journal of Cryptology,",
            "year": 2019
        },
        {
            "authors": [
                "Razvan Barbulescu",
                "Pierrick Gaudry",
                "Thorsten Kleinjung"
            ],
            "title": "The tower number field sieve",
            "venue": "Advances in Cryptology \u2013 ASIACRYPT",
            "year": 2015
        },
        {
            "authors": [
                "Dan Boneh",
                "Ben Lynn",
                "Hovav Shacham"
            ],
            "title": "Short signatures from the Weil pairing",
            "venue": "Journal of cryptology,",
            "year": 2004
        },
        {
            "authors": [
                "R\u00e9mi Clarisse",
                "Sylvain Duquesne",
                "Olivier Sanders"
            ],
            "title": "Curves with fast computations in the first pairing group",
            "venue": "Cryptology and Network Security,",
            "year": 2020
        },
        {
            "authors": [
                "Liqun Chen",
                "Caroline Kudla"
            ],
            "title": "Identity based authenticated key agreement protocols from pairings",
            "venue": "In 16th IEEE Computer Security Foundations Workshop,",
            "year": 2003
        },
        {
            "authors": [
                "Craig Costello",
                "Patrick Longa"
            ],
            "title": "FourQ: Four-dimensional decompositions on a Q-curve over the mersenne prime",
            "venue": "Advances in Cryptology \u2013 ASIACRYPT",
            "year": 2015
        },
        {
            "authors": [
                "Jorge Chavez-Saab",
                "Francisco Rodr\u00edguez-Henr\u00edquez",
                "Mehdi Tibouchi"
            ],
            "title": "Swiftec: Shallue-van de woestijne indifferentiable function to elliptic curves: Faster indifferentiable hashing to elliptic curves",
            "venue": "In Advances in Cryptology \u2013 ASIACRYPT",
            "year": 2022
        },
        {
            "authors": [
                "Yu Dai",
                "Kaizhan Lin",
                "Chang-An Zhao",
                "Zijian Zhou"
            ],
            "title": "Fast subgroup membership testings for G1, G2 and GT on pairing-friendly curves. Designs, Codes and Cryptography, may 2023",
            "year": 2023
        },
        {
            "authors": [
                "Yu Dai",
                "Fangguo Zhang",
                "Chang-An Zhao"
            ],
            "title": "Fast hashing to G2 in direct anonymous attestation",
            "venue": "Cryptology ePrint Archive, Paper 2022/996,",
            "year": 2022
        },
        {
            "authors": [
                "Yu Dai",
                "Zijian Zhou",
                "Fangguo Zhang",
                "Chang-An Zhao"
            ],
            "title": "Software implementation of optimal pairings on elliptic curves with odd prime embedding degrees",
            "venue": "IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences,",
            "year": 2022
        },
        {
            "authors": [
                "Youssef El Housni",
                "Aurore Guillevic"
            ],
            "title": "Optimized and secure pairing-friendly elliptic curves suitable for one layer proof composition",
            "venue": "Cryptology and Network Security,",
            "year": 2020
        },
        {
            "authors": [
                "Youssef El Housni",
                "Aurore Guillevic"
            ],
            "title": "Families of SNARK-friendly 2chains of elliptic curves",
            "venue": "Advances in Cryptology \u2013 EUROCRYPT",
            "year": 2022
        },
        {
            "authors": [
                "Youssef El Housni",
                "Aurore Guillevic",
                "Thomas Piellard"
            ],
            "title": "Co-factor clearing and subgroup membership testing on pairing-friendly curves",
            "venue": "Lejla Batina and Joan Daemen, editors, Progress in Cryptology \u2013 AFRICACRYPT",
            "year": 2022
        },
        {
            "authors": [
                "Nadia El Mrabet",
                "Marc Joye"
            ],
            "title": "Guide to pairing-based cryptography",
            "year": 2016
        },
        {
            "authors": [
                "Emmanuel Fouotsa",
                "Laurian Azebaze Guimagang",
                "Raoul Ayissi"
            ],
            "title": "xsuperoptimal pairings on elliptic curves with odd prime embedding degrees: BW13-P310 and BW19-P286",
            "venue": "Applicable Algebra in Engineering, Communication and Computing,",
            "year": 2023
        },
        {
            "authors": [
                "Armando Faz-Hern\u00e1ndez",
                "Patrick Longa",
                "Ana H. S\u00e1nchez"
            ],
            "title": "Efficient and secure algorithms for GLV-based scalar multiplication and their implementation on GLV-GLS curves",
            "venue": "In Josh Benaloh, editor, Topics in Cryptology \u2013 CT-RSA",
            "year": 2014
        },
        {
            "authors": [
                "David Freeman",
                "Michael Scott",
                "Edlyn Teske"
            ],
            "title": "A taxonomy of pairingfriendly elliptic curves",
            "venue": "Journal of Cryptology,",
            "year": 2010
        },
        {
            "authors": [
                "Steven Galbraith"
            ],
            "title": "Mathematics of Public Key Cryptography",
            "year": 2018
        },
        {
            "authors": [
                "Steven D. Galbraith",
                "Xibin Lin",
                "Michael Scott"
            ],
            "title": "Endomorphisms for faster elliptic curve cryptography on a large class of curves",
            "venue": "Advances in Cryptology - EUROCRYPT",
            "year": 2009
        },
        {
            "authors": [
                "Robert P. Gallant",
                "Robert J. Lambert",
                "Scott A. Vanstone"
            ],
            "title": "Faster point multiplication on elliptic curves with efficient endomorphisms",
            "venue": "Advances in Cryptology \u2014 CRYPTO",
            "year": 2001
        },
        {
            "authors": [
                "Aurore Guillevic",
                "Simon Masson",
                "Emmanuel Thom\u00e9"
            ],
            "title": "Cocks-pinch curves of embedding degrees five to eight and optimal ate pairing computation",
            "venue": "Designs, Codes and Cryptography,",
            "year": 2020
        },
        {
            "authors": [
                "R Granger",
                "N.P. Smart"
            ],
            "title": "On computing products of pairings",
            "venue": "Cryptology ePrint Archive, Paper 2006/172,",
            "year": 2006
        },
        {
            "authors": [
                "Steven D. Galbraith",
                "Michael Scott"
            ],
            "title": "Exponentiation in pairing-friendly groups using homomorphisms",
            "venue": "Pairing",
            "year": 2008
        },
        {
            "authors": [
                "Robert Granger",
                "Michael Scott"
            ],
            "title": "Faster squaring in the cyclotomic subgroup of sixth degree extensions",
            "venue": "Public Key Cryptography",
            "year": 2010
        },
        {
            "authors": [
                "Aurore Guillevic"
            ],
            "title": "A short-list of pairing-friendly curves resistant to special TNFS at the 128-bit security level",
            "venue": "PKC",
            "year": 2020
        },
        {
            "authors": [
                "F. Hess",
                "N.P. Smart",
                "F. Vercauteren"
            ],
            "title": "The eta pairing revisited",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2006
        },
        {
            "authors": [
                "K. Karabina"
            ],
            "title": "Squaring in cyclotomic subgroups",
            "venue": "Mathematics of Computation,",
            "year": 2012
        },
        {
            "authors": [
                "Taechan Kim",
                "Razvan Barbulescu"
            ],
            "title": "Extended tower number field sieve: A new complexity for the medium prime case",
            "venue": "Advances in Cryptology \u2013 CRYPTO",
            "year": 2016
        },
        {
            "authors": [
                "Taechan Kim",
                "Jinhyuck Jeong"
            ],
            "title": "Extended tower number field sieve with application to finite fields of arbitrary composite extension degree",
            "venue": "PKC",
            "year": 2017
        },
        {
            "authors": [
                "Dmitrii Koshelev"
            ],
            "title": "Subgroup membership testing on elliptic curves via the tate pairing",
            "venue": "Journal of Cryptographic Engineering,",
            "year": 2022
        },
        {
            "authors": [
                "A.K. Lenstra",
                "H.W. Lenstra",
                "L Lov\u00e1sz"
            ],
            "title": "Factoring polynomials with rational coefficients",
            "venue": "Mathematische Annalen,",
            "year": 1982
        },
        {
            "authors": [
                "Patrick Longa"
            ],
            "title": "Efficient algorithms for large prime characteristic fields and their application to bilinear pairings",
            "venue": "IACR Transactions on Cryptographic Hardware and Embedded Systems,",
            "year": 2023
        },
        {
            "authors": [
                "Patrick Longa",
                "Francesco Sica"
            ],
            "title": "Four-dimensional Gallant-LambertVanstone scalar multiplication",
            "venue": "Advances in Cryptology \u2013 ASIACRYPT",
            "year": 2012
        },
        {
            "authors": [
                "Victor S. Miller"
            ],
            "title": "The Weil pairing, and its efficient calculation",
            "venue": "Journal of Cryptology,",
            "year": 2004
        },
        {
            "authors": [
                "Peter L. Montgomery"
            ],
            "title": "Speeding the pollard and elliptic curve methods of factorization",
            "venue": "Mathematics of computation,",
            "year": 1987
        },
        {
            "authors": [
                "J.M. Pollard"
            ],
            "title": "A monte carlo method for factorization",
            "venue": "Bit Numerical Mathematics,",
            "year": 1975
        },
        {
            "authors": [
                "Oliver Schirokauer"
            ],
            "title": "Discrete logarithms and local units",
            "venue": "Philosophical Transactions: Physical Sciences and Engineering,",
            "year": 1993
        },
        {
            "authors": [
                "Michael Scott"
            ],
            "title": "Faster pairings using an elliptic curve with an efficient endomorphism",
            "venue": "Progress in Cryptology - INDOCRYPT",
            "year": 2005
        },
        {
            "authors": [
                "Michael Scott"
            ],
            "title": "On the efficient implementation of pairing-based protocols",
            "venue": "Cryptography and Coding,",
            "year": 2011
        },
        {
            "authors": [
                "Michael Scott"
            ],
            "title": "Unbalancing pairing-based key exchange protocols",
            "venue": "IACR Cryptol. ePrint Arch.,",
            "year": 2013
        },
        {
            "authors": [
                "Andrew Shallue",
                "Christiaan E. van de Woestijne"
            ],
            "title": "Construction of rational points on elliptic curves over finite fields",
            "venue": "Algorithmic Number Theory Symposium\u2013 ANTS",
            "year": 2006
        },
        {
            "authors": [
                "Frederik Vercauteren"
            ],
            "title": "Optimal pairings",
            "venue": "IEEE Transactions on Information Theory,",
            "year": 2009
        },
        {
            "authors": [
                "Kang Yang",
                "Liqun Chen",
                "Zhenfeng Zhang",
                "Christopher JP Newton",
                "Bo Yang",
                "Li Xi"
            ],
            "title": "Direct anonymous attestation with optimal TPM signing efficiency",
            "venue": "IEEE Transactions on Information Forensics and Security,",
            "year": 2021
        },
        {
            "authors": [
                "Xusheng Zhang",
                "Dongdai Lin"
            ],
            "title": "Analysis of optimum pairing products at high security levels",
            "venue": "Progress in Cryptology - INDOCRYPT",
            "year": 2012
        },
        {
            "authors": [
                "Chang-An Zhao",
                "Dongqing Xie",
                "Fangguo Zhang",
                "Jingwei Zhang",
                "BingLong Chen"
            ],
            "title": "Computing bilinear pairings on elliptic curves with automorphisms",
            "venue": "Designs, Codes and Cryptography,",
            "year": 2011
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "A pairing on an elliptic curve E defined over a prime field Fp is a non-degenerate bilinear map of the form e : G1 \u00d7 G2 \u2192 GT , where G1, G2 and GT are three groups with the same order r. The two input groups G1 and G2 lie in E(Fpk ) and the output group GT is a subgroup of F\u2217pk , where k is the smallest positive integer such that r | pk \u2212 1. Taking advantage of the powerful bilinearity property of pairings, a range of cryptographic protocols are designed, such as authenticated key agreements [CK03,Sco13], direct anonymous attestation (DAA) [BCC04, YCZ+21] and Succinct Non-interactive ARguments of Knowledge (SNARKs) [EHG22,EHG20,AEHG22]. Very recently, pairings were also used to speed up group membership testing on several non-pairing-friendly curves [Kos22].\nThe fundamental security of pairing-based protocols depends on the difficulty of solving discrete logarithm problem (DLP) on the three pairing groups. The best-known discrete\nLicensed under Creative Commons License CC-BY 4.0. Received: 2023-04-15 Accepted: 2023-06-15 Published: 2023-08-31\nlogarithm algorithm on elliptic curves is the Pollard\u2019s rho algorithm [Pol75], which requires around \u221a r group operations. It means that the size of r is at least 256-bit to reach the 128-bit security level. On finite fields side, the best attack algorithm is derived from the Number Field Sieve (NFS) family (eg. [Sch93]). Before 2015, a 3072-bit full extension field Fpk was widely believed to be 128-bit secure under the attack of NFS. With a series of new variants of NFS proposed [BGK15,KB16,KJ17], the asymptotic complexity of NFS has decreased significantly. In particular, the special extension tower number field sieve (SexTNFS) [KB16] is tailored to pairing-friendly fields, i.e., the characteristic p can be represented as a tiny-coefficients polynomial of moderate degree. For example, according to the estimate in [BD19,GMT20], the real security level of BN254 is around 100 \u223c 103-bit under the attack of SexTNFS. As a result, parameters of many pairing-friendly curves have to be re-evaluated for achieving the desired security level. In 2021, Guillevic [Gui20] recommended a list of curves at the updated 128-bit security level. In the new estimation, the author found that BN446 and BLS12-446 are best choices for achieving the 128-bit security level in the BN and BLS families, respectively."
        },
        {
            "heading": "1.1 Pairing-friendly curves with fast exponentiation in G1",
            "text": "The development of NFS also affects the selection of pairing-friendly curves in many pairing-based cryptographic protocols. A common scenario is that a protocol is designed to minimize the workload of one party equipped with resource-constrained devices. For example, in the pairing-based DAA scheme the Trusted Platform Module (TPM) is a small discrete chip that is required to perform a few exponentiations in G1. One of challenges in the design of the DAA scheme is to minimize the computational cost of the TPM [YCZ+21]. In this situation, pairing-friendly curves with fast exponentiation in G1 are very attractive. Or equivalently, curves equipped with small size of prime field are well-suited for the DAA scheme. To this aim, Clarisse et al. [CDS20] recommended two 128-bit secure curves: BW13-310 with embedding degree 13 over a 310-bit field, and BW19-286 with embedding degree 19 over a 286-bit field. Besides these, there actually exist other candidates: BLS24-315 and BLS48-286. For these curves, their characteristic p can be represented by five computer words on a 64-bit processor. Among these curves, BW13-310 is competitive because of the small size of the full extension field Fpk . It is worth noting that even compared to BN446 and BLS12-446, BW13-310 also has advantage in terms of the efficiency of full extension field arithmetic. Moreover, the odd prime embedding degree k on BW13-310 also leads to a large value of \u03d5(k), which induces a small number of iterations for both Miller loop of the optimal pairings [Ver09] and the group exponentiations in G2 and GT [GS08]."
        },
        {
            "heading": "1.2 Contributions",
            "text": "In this paper, we give a detailed study of BW13-310. We show that this curve is a powerful candidate in pairing-based protocols at the updated 128-bit security level. Our contributions are summarized as follows:\n\u2022 In Section 3, we propose a new formula for computing the optimal pairing on BW13310. We show that the computational cost of the Miller loop comes mostly from two evaluations at the same Miller function of bit length around log r/(2\u03d5(k)). On this basis, we propose a shared Miller loop such that the two function evaluations can be accomplished simultaneously. In addition, we also give a slight optimization for the final exponentiation. By using these techniques, we also discuss how to compute the products of pairings on this curve in Section 4.\n\u2022 In Section 5, we focus on optimizing group exponentiations in G2 and GT on BW13310. In the case of G2, we show that GLV [GLV01] and GLS [GLS09] methods can\nbe combined to build a 2\u03d5(k)-dimensional decomposition, which means that the number of point doublings is only around log r/(2\u03d5(k)) (\u2248 12). In the case of GT , we develop an all-positive decomposition such that group inversion operation can be avoided.\n\u2022 In Section 6, we provide high performance software implementations of pairing computation, hashing (to G1 and G2), group exponentiations and membership testings over BW13-310 on a 64-bit processor. By means of the RELIC cryptographic toolkit [AG], detailed performance comparisons of all building blocks on BW13-310, BN446 and BLS12-446 are presented.\n- It is surprising to observe that the single pairing computation on BW13-310 is only up to 4.9% and 26% slower than that on BN446 and BLS12-446, respectively. In particular, the computation of the Miller loop on BW13-310 is even up to 48.2% faster than that on BN446. As a result, for the computation of the pairings products, BW13-310 gains an advantage over BN446, while is still slower than BLS12-446.\n- More importantly, compared to BN446 and BLS12-446, BW13-310 is about 109.1%\u2212 227.3%, 100%\u2212 192.6%, 24.5%\u2212 108.5% and 68.2%\u2212 145.5% faster in terms of hashing to G1, exponentiations in G1 and GT , and membership testing for GT , respectively.\n- On the negative side, BW13-310 also pays a penalty in terms of hashing to G2 and exponentiation in G2.\n\u2022 In Section 7, we estimate the performance of the Boneh-Lynn-Shacham (BLS) signature scheme [BLS04] and the unbalanced Chen-Kudla (UCK) key agreement protocol [Sco13] built on different pairing-friendly curves, including BN446, BLS12446 and BW13-310. The results show that\n- the UCK protocol built on BW13-310 is about 125.6% and 40.6% faster than that on BN446 and BLS12-446 for the resource-constrained party (Client), respectively;\n- the BLS signature scheme built on BW13-310 is about both 150% faster than that on BN446 and BLS12-446 for the signer, respectively."
        },
        {
            "heading": "2 Preliminaries",
            "text": "Let p be a large prime, and E an ordinary elliptic curve defined by an equation of the form y2 = x3 + ax+ b where a, b \u2208 Fp are selected such that 4a3 + 27b2 6= 0. The group E(Fp) consists of points (x, y) satisfying the above equation with x, y \u2208 Fp, together with a point at infinity O. Denote by #E(Fp) the order of E(Fp). Then #E(Fp) is precisely p+ 1\u2212 t, where t is the trace of the p-power Frobenius endomorphism \u03c0 : (x, y)\u2192 (xp, yp). Let r be a large prime such that r | #E(Fp). The embedding degree k with respect to r is the smallest positive integer such that r | pk \u2212 1. We use GT to denote the subgroup of order r in F\u2217pk . If k > 1, then the r-torsion group E[r] = {R \u2208 E | [r]R = O} is contained in E(Fpk ). Define G1 and G2 are eigenspaces of \u03c0 acting on E[r] with eigenvalues 1 and p, respectively. Or equivalently, G1 = E(Fp)[r] and G2 = E(Fpk )[r] \u2229Ker(\u03c0-[p])."
        },
        {
            "heading": "2.1 Optimal pairing",
            "text": "For any point R \u2208 E and n \u2208 Z+, we denote fn,R as a normalized rational function with divisor\n(fn,R) = n(R)\u2212 ([n]R)\u2212 (n\u2212 1)(O). (1)\nFor any i, j \u2208 Z+, the functions fi,R, fj,R and fi+j,R satisfy the following relations:\nfi+j,R = fi,R \u00b7 fj,R \u00b7 `[i]R,[j]R\n\u03bd[i+j]R , (2)\nwhere `[i]R,[j]R represents the straight line through [i]R and [j]R, and \u03bd[i+j]R is the vertical line through [i+j]R. Based on Eq.(2), Miller [Mil04] proposed a polynomial time algorithm for computing fn,Q(P ) for any n \u2208 Z+, P \u2208 G1 and Q \u2208 G2, which is described in Alg. 1. Throughout this paper, we call fn,R as Miller function and one execution of the main loop in Alg. 1 as a basic Miller iteration.\nLet m be a multiple of r with m - r2, and write m as \u2211\u03c9 j=0 cip\ni. An optimal pairing [Ver09] on E is defined by\ne : G1 \u00d7G2 \u2192 GT , (P,Q)\u2192 ( \u03c9\u220f\ni=0 fp\ni\nci,Q (P ) \u00b7 \u03c9\u22121\u220f i=0 `[si+1]Q,[cipi]Q(P ) \u03bd[si]Q(P ) )(pk\u22121)/r , (3)\nwhere si = \u2211\u03c9 j=i cjp\nj . Eq. (3) allows pairing evaluation to be accomplished by using around log r/(\u03d5(k)) basic Miller iterations and one exponentiation by (pk \u2212 1)/r.\nAlgorithm 1 Miller\u2019s Algorithm\nInput: P \u2208 G1, Q \u2208 G2, n = L\u2211 i=0 ni2i with ni \u2208 {\u22121, 0, 1} Output: fn,Q(P ) 1: T \u2190 Q, f \u2190 1 2: for i = L\u2212 1 down to 0 do 3: f \u2190 f2 \u00b7 `T,T (P )\u03bd[2]T (P ) , T \u2190\u2212 2T 4: if ni = 1 then 5: f \u2190 f \u00b7 `T,Q(P )\u03bdT +Q(P ) , T \u2190 T +Q 6: end if 7: if ni = \u22121 then 8: f \u2190 f \u00b7 `T,\u2212Q(P )\u03bdT \u2212Q(P ) , T \u2190 T \u2212Q 9: end if 10: end for 11: return f\nFor curves with even embedding degrees, pairing computation benefits from the denominator elimination optimization so that the vertical line in Alg. 1 can be ignored. Unfortunately, this technique does not apply to curves with odd prime embedding degrees. The penalty is slightly made up for by a modified Miller function gm,Q with divisor\n(gm,Q) = m(Q) + (\u2212mQ)\u2212 (m+ 1)(O). (4)\nComparing Eqs. (1) and (4), it is easy to deduce the following relations:\ngm,Q = fm,Q \u00b7 \u03bd[m]Q, (5)\ngm+1,Q = gm,Q \u00b7 `[m]Q,Q\n\u03bd[m]Q , (6)\ng2m+1,Q = g2m,Q `[2m]Q,Q\n`[\u2212m]Q,[\u2212m]Q , (7)\ng4m,Q = g4m,Q `[2m]Q,[2m]Q\n`2[\u2212m]Q,[\u2212m]Q . (8)\nExploiting Eqs. (5)-(8), Dai et al. [DZZZ22] found that the optimal strategy for performing Miller loop is as follows: (1) combining two consecutive doubling steps into one quadrupling step; (2) combining one doubling and one addition steps into one doubling-addition step.\n2.2 A family of curves with embedding degrees k \u2261 1 mod 6 Freeman, Scott and Teske [FST10, Construction 6.6] constructed a family of cyclotomic pairing-friendly curves with embedding degrees k \u2261 1 mod 6, k \u2264 1000 and 18 - k. In particular, the characteristic p, the prime order r and the trace of Frobenius t are parameterized by\nr(z) = \u03a66k(z), p(z) = 13 (z + 1)2(z2k \u2212 zk + 1)\u2212 z2k+1, t(z) = \u2212zk+1 + z + 1,\nwhere \u03a6l(\u00b7) represents l-th cyclotomic polynomial. All members in this family have jinvariant 0 and are defined by an equation of the form y2 = x3 + b for some b \u2208 F\u2217p. Following [CDS20], this family is named as the BW family. By the form of r(z), we have r(z) | (z2k \u2212 zk + 1), which implies that\nz2 \u2212 z \u00b7 p(z) + p2(z) \u2261 z2 + z \u00b7 z2k+1 + z4k+2\n\u2261 z2 \u00b7 (1 + z2k + z4k) \u2261 0 mod r(z).\nThus, one of short vectors (c0, c1, \u00b7 \u00b7 \u00b7 , c\u03c9) for the optimal pairing in this family is given by (z2,\u2212z, 1, 0, \u00b7 \u00b7 \u00b7 , 0). Plugging this vector into Eq. (3), the corresponding formula of the optimal pairing is\ne(P,Q) = (fz2,Q(P ) \u00b7 fp\u2212z,Q(P ) \u00b7 `\u03c02(Q),\u03c0([\u2212z]Q)(P ))(p k\u22121)/r. (9)\nIt is known from [EMJ16, Lemma 3.5] that\nfz2,Q = f\u2212z\u2212z,Q \u00b7 f\u2212z,[\u2212z]Q.\nTherefore, Eq. (9) can be rewritten as\ne(P,Q) = ( f\u2212z+p\u2212z,Q (P ) \u00b7 f\u2212z,[\u2212z]Q(P ) \u00b7 `\u03c02(Q),\u03c0([\u2212z]Q)(P ) )(pk\u22121)/r . (10)\nBW13-310 and BW19-286: In the BW family, BW13-310 and BW19-286 are the two curves defined by setting k = 13 and 19, z = \u22122224 and \u2212145, b = \u221217 and 31, respectively. In particular, the selected prime p on BW13-310 satisfies that p \u2261 1 mod 13, so that the full extension field Fp13 can be represented as Fp[v]/(v13 \u2212 \u03b1) for some \u03b1 \u2208 F\u2217p. Using Magma [BCP97], it is easy to check that the polynomial v13 \u2212 2 is irreducible over Fp, which means that we can select the value of \u03b1 as 2. According to the estimation in [Gui20,CDS20], both curves are 128-bit secure even under the attack of the SexTNFS."
        },
        {
            "heading": "3 Single Pairing Computation on BW13-310",
            "text": "Notations. We denote by a, m, mu, s, su, i and r the computational costs of addition, multiplication, multiplication without reduction, squaring, squaring without reduction, inversion and modular reduction in Fp, respectively. It is obvious that m = mu + r and s = su+r. Likewise, we use a\u0303, m\u0303, m\u0303u s\u0303, s\u0303u, i\u0303, f\u0303, e\u0303 and r\u0303 to represent the computational costs of addition, multiplication, multiplication without reduction, squaring, squaring without reduction, inversion, Frobenius, exponentiation by |z| and modular reduction in Fp13 ,\nrespectively. The cyclotomic group G\u03a613(p) is defined by G\u03a613(p) = {\u03b2 \u2208 Fp13 | \u03b2\u03a613(p) = 1}. We denote by i\u0303c the cost of the inversion in G\u03a613(p). The notation \u00d7 is used to denote field multiplication without reduction. For any point Q, we use (xQ, yQ) to represent the point in affine coordinates, and (XQ, YQ, ZQ) in jacobian coordinates, which means that xQ = XQ/Z2Q and yQ = YQ/Z3Q. Given a vector n = (n0, n1, \u00b7 \u00b7 \u00b7 , nm), the notation \u2016n\u2016\u221e represents max{|n0|, |n1|, \u00b7 \u00b7 \u00b7 , |nm|}.\nIn this section, we propose a new formula for pairing computation in the BW family, and discuss how to apply it to BW13-310 in detail. Since p \u2261 1 mod 3, there exists an endomorphism \u03c6 : (x, y)\u2192 (\u03c9 \u00b7 x, y) such that \u03c6(Q) = [\u03bb]Q for any Q \u2208 G2, where \u03c9 is a cube primitive root of unity in F\u2217p and \u03bb is a root of the quadratic congruence equation x2 + x+ 1 \u2261 0 mod r. Recall that\nz2k \u2212 zk + 1 \u2261 0 mod r,\nwhich implies that \u03bb is \u2212zk or zk \u2212 1. Fix the parameter \u03c9 such that \u03bb = \u2212zk and define \u03c8 = \u03c0 \u25e6 \u03c6. Then, we have\n\u03c8(Q) = [\u03bb]\u03c0(Q) = [\u03bb \u00b7 (t\u2212 1) mod r]Q = [\u2212z]Q. (11)\nBased on this observation, we prove the following theorem.\nTheorem 1. Let notation as above. Then the formula of the optimal pairing in the BW family can be expressed as\ne(Q,P ) = ( f\u2212z+p\u2212z,Q (P ) \u00b7 f p \u2212z,Q(\u03c6\u0302(P )) \u00b7 `\u03c02(Q),\u03c02\u25e6\u03c6(Q)(P ) )(pk\u22121)/r , (12)\nwhere \u03c6\u0302 = \u03c62.\nProof. By [HSV06, Lemma 3] and Eq. (11), it is easy to see that\nf\u2212z,[\u2212z]Q = f\u2212z,\u03c0\u25e6\u03c6(Q) = fp\u2212z,\u03c6(Q). (13)\nBy Eq. (1), we obtain that\n(f\u2212z,\u03c6(Q)) = \u2212z(\u03c6(Q))\u2212 (\u03c6([\u2212z]Q))\u2212 (\u2212z \u2212 1)(O).\nSince \u03c6 is an automorphism on E, we have\n\u03c6\u2217(f\u2212z,\u03c6(Q)) = \u2212z(Q)\u2212 ([\u2212z]Q)\u2212 (\u2212z \u2212 1)(O) = (f\u2212z,Q), (14)\nwhere \u03c6\u2217 is the pullback of \u03c6 [Gal18, Definition 8.3.1]. Furthermore, since\n\u03c6\u2217(f\u2212z,\u03c6(Q)) = (f\u2212z,\u03c6(Q) \u25e6 \u03c6),\nEq. (14) implies that\nf\u2212z,\u03c6(Q) = f\u2212z,\u03c6(Q) \u25e6 \u03c6 \u25e6 \u03c6\u0302 = f\u2212z,Q \u25e6 \u03c6\u0302. (15)\nBy the fact that p \u2261 1 mod 3 and \u03c6\u03023 = 1 we get\n\u03c6\u0302p = \u03c6\u0302. (16)\nCombining Eqs.(13), (15) and (16), it yields\nf\u2212z,[\u2212z]Q = fp\u2212z,\u03c6(Q) = f p \u2212z,Q \u25e6 \u03c6\u0302 p = fp\u2212z,Q \u25e6 \u03c6\u0302. (17)\nInserting Eq. (17) into Eq. (10) and replacing [\u2212z]Q by \u03c8(Q), we complete the proof of this theorem.\nIn Theorem 1, we propose a new formula for computing the optimal pairing in the BW family, which is suitable for BW13-310 and BW19-286. Using the new formula, the number of basic Miller iterations is reduced to blog|z|c \u2248 log r/(2\u03d5(k)). In detail, when performing Miller\u2019s algorithm using Eq. (12), the computational cost largely comes from two evaluations at the same Miller function of length log|z|, i.e., f\u2212z,Q(P ) and f\u2212z,Q(\u03c6\u0302(P )). Recently, Fouotsa et al. [FGA23] proposed the x-superoptimal pairing on BW13-310 and BW19-286, which is expressed as\naxsup(Q,P )= (( f\u2212z,Q(P ) \u00b7 f\u22121\u2212z,Q(\u03c6\u0302(P )) )\u2212z \u00b7 (f\u22121\u2212z,Q(\u03c6\u0302(P )) \u00b7 f\u2212z,Q(\u03c6(P ))p)(p13\u22121)/r. (18) Clearly, Eqs. (12) and (18) require the same number of iterations when performing Miller\u2019s algorithm. But the latter requires three evaluations at the same Miller function of length log|z|, i.e., f\u2212z,Q(P ), f\u2212z,Q(\u03c6(P )) and f\u2212z,Q(\u03c6\u0302(P )). Therefore, compared to the x-superoptimal pairing, our proposed formula would be more efficient. In the following, we investigate how to perform the pairing computation on BW13-310 in detail."
        },
        {
            "heading": "3.1 Shared Miller loop",
            "text": "Computing a single pairing by multiple Miller function evaluations were studied in [Sco05, ZXZ+11,AFCK+13]. This inspires us to consider how to speed up pairing computation on BW13-310 by using Eq. (12), i.e., computing f\u2212z,Q(P ) and f\u2212z,Q(\u03c6\u0302(P )). Since the points P and \u03c6\u0302(P ) have the same y-coordinates, the two Miller function evaluations share a large amount of intermediate values during Miller iteration. Hence, it would be efficient to calculate f\u2212z,Q(P ) and f\u2212z,Q(\u03c6\u0302(P )) simultaneously. In other words, we can accomplish two Miller function evaluations at a shared Miller loop. Recall from Section 2 that the seed z = \u22122224 on BW13-310, and the Miller function f2224,Q can be obtained from f1,Q via the following sequence:\nf1,Q\u2192g1,Q \u2192g4,Q\u2192g16,Q\u2192g17,Q\u2192g68,Q\u2192g69,Q\u2192g139,Q\u2192g556,Q\u2192g2224,Q\u2192f2224,Q. (19)\nFor any i \u2208 Z, we denote by Ni,Q and Di,Q the numerator and denominator of gi,Q, respectively. According to Eq. (5), we have\ng1,Q(x, y) = f1,Q(x, y) \u00b7 \u03bd1,Q(x, y) = x\u2212 xQ\nfor any point (x, y) \u2208 E. Therefore, it is natural to set\nN1,Q(P ) = xP \u2212 xQ, D1,Q(P ) = 1, N1,Q(\u03c6\u0302(P )) = x\u0303P \u2212 xQ, D1,Q(\u03c6\u0302(P )) = 1, (20)\nwhere x\u0303P represents the x-coordinate of \u03c6\u0302(P ). In the following we will discuss how to update the terms Nm,Q(P ), Dm,Q(P ), Nm,Q(\u03c6\u0302(P )) and Dm,Q(\u03c6\u0302(P )) in a shared Miller loop for any m \u2208 Z. Before that, we use T = (XT , YT , ZT ) to denote [m]Q in Jacobian coordinates."
        },
        {
            "heading": "3.1.1 Shared addition step(SADD)",
            "text": "In this subsection we show how to obtain Nm+1,Q(P ), Dm+1,Q(P ), Nm+1,Q(\u03c6\u0302(P )) and Dm+1,Q(\u03c6\u0302(P )) from Nm,Q(P ), Dm,Q(P ), Nm,Q(\u03c6\u0302(P )) and Dm,Q(\u03c6\u0302(P )), respectively. To this end, the point T +Q is first calculated. Since T and Q are represented in Jacobian and affine coordinates respectively, we adopt the mixed addition formula presented in [AFG+17, Section 4.3.2] to compute T +Q, which is given by\n\u03b1T+Q = yQ \u00b7 Z3T \u2212 YT , \u03b2T+Q = xQ \u00b7 Z2T \u2212XT , XT+Q = \u03b12T+Q \u2212 2XT \u00b7 \u03b22T+Q \u2212 \u03b23T+Q, YT+Q = \u03b1T+Q \u00b7 (XT \u00b7 \u03b22T+Q \u2212XT+Q)\u2212 YT \u00b7 \u03b23T+Q, ZT+Q = ZT \u00b7 \u03b2T+Q.\nIt can be done by using the following sequence of operations:\nA = Z2T , B = A\u00b7ZT , C = B \u00b7 yQ \u2212 YT , D = A \u00b7 xQ \u2212XT , E = D2, F = D \u00b7 E,G = XT \u00b7 E, XT+Q = C2 \u2212 2G\u2212 F,U0 = C \u00d7 (G\u2212XT+Q), U1 = YT \u00d7 F, YT+Q = (U0 \u2212 U1) mod p, ZT+Q = ZT \u00b7D.\nThe above calculation comes at a cost of 6m\u0303+2m\u0303u+3s\u0303+ r\u0303+8a\u0303, assuming that computing U0 \u2212 U1 requires 2a\u0303. For any point (x, y), it can be deduced from Eq. (6) that\nNm+ 1, Q(x, y) = Nm,Q(x, y) \u00b7 LT,a,1(x, y), Dm+1,Q(x, y)=Dm,Q(x, y) \u00b7 LT,a,2(x, y),\n(21)\nwhere LT,a,1(x, y) and LT,a,2(x, y) are given by\nLT,a,1(x, y) = \u03b2T+Q \u00b7 (y \u00b7Z3T\u2212YT )\u2212\u03b1T+Q \u00b7 (x \u00b7 Z2T\u2212XT ), LT,a,2(x, y) = ZT+Q \u00b7 (x \u00b7 Z2T \u2212XT ).\nSince \u03b1T+Q, \u03b2T+Q, ZT+Q, Z2T and Z3T have been obtained at the point addition step, we perform the following sequence of operations to compute LT,a,1(P ), LT,a,2(P ), LT,a,1(\u03c6\u0302(P )) and LT,a,2(\u03c6\u0302(P )) which requires 2m\u0303 + 3m\u0303u + 39m + 2r\u0303 + 7a\u0303 as\nA = yP \u00b7 Z3T\u2212YT , B = xP \u00b7 Z2T\u2212XT , C = x\u0303P \u00b7 Z2T\u2212XT , U0 = \u03b2T+Q \u00d7A,U1 = \u03b1T+Q \u00d7B, U2 = \u03b1T+Q \u00d7 C,La,1(P ) = (U0\u2212U1) mod p, LT,a,1(\u03c6\u0302(P )) = (U0\u2212U2) mod p, LT,a,2(P ) = ZT+Q \u00b7B,LT,a,2(\u03c6\u0302(P )) = ZT+Q \u00b7 C.\nOn this basis, we can obtain Nm+1,Q(P ), Dm+1,Q(P ), Nm+1,Q(\u03c6\u0302(P )) and Dm+1,Q(\u03c6\u0302(P )) from Eq. (21) at a cost of 4m\u0303. In summary, the computational cost at the SADD step is\n6m\u0303 + 2m\u0303u + 3s\u0303 + r\u0303 + 8a\u0303\ufe38 \ufe37\ufe37 \ufe38 point addition + 2m\u0303 + 3m\u0303u + 39m + 2r\u0303 + 7a\u0303\ufe38 \ufe37\ufe37 \ufe38 LT,a,1 and LT,a,2 + 4m\u0303\ufe38\ufe37\ufe37\ufe38 the final step\n= 12m\u0303 + 5m\u0303u + 3s\u0303 + 39m + 3r\u0303 + 15a\u0303."
        },
        {
            "heading": "3.1.2 Shared doubling-addition step(SDBLADD)",
            "text": "By combining one doubling and one addition steps in the shared Miller loop, we can efficiently obtain N2m+1,Q(P ), D2m+1,Q(P ), N2m+1,Q(\u03c6\u0302(P )) and D2m+1,Q(\u03c6\u0302(P )) from Nm,Q(P ), Dm,Q(P ), Nm,Q(\u03c6\u0302(P )) and Dm,Q(\u03c6\u0302(P )), respectively. Firstly, using the formula presented in [AFG+17, Section 4.3.1], the point 2T = (X2T , Y2T , Z2T ) is given by\nX2T = 9 4X 4 T \u2212 2XT \u00b7 Y 2T , Y2T = 3 2X 2 T \u00b7 (XT \u00b7 Y 2T \u2212X2T )\u2212 Y 4T , Z2T = YT \u00b7 ZT .\nThus the computation of point doubling requires 2m\u0303 + m\u0303u + 3s\u0303 + s\u0303u + r\u0303 + 7a\u0303 using the following sequence of operations:\nA=X2T , B = A/2, C = A+B,D = C2, E = Y 2T , F = XT \u00b7 E,X2T = D \u2212 2F,G = F \u2212X2T , U0 = C \u00d7G,U1 = E \u00d7 E, Y2T = (U0 \u2212 U1) mod p, Z2T = YT \u00b7 ZT .\nOn this basis, one can obtain the point 2T +Q via one mixed point addition:\n\u03b12T+Q = yQ \u00b7Z32T\u2212Y2T , \u03b22T+Q = xQ \u00b7Z22T\u2212X2T , X2T+Q = \u03b122T+Q\u22122X2T \u00b7\u03b222T+Q\u2212\u03b232T+Q, Y2T+Q = \u03b12T+Q \u00b7 (X2T \u00b7 \u03b222T+Q \u2212X2T+Q)\u2212 Y2T \u00b7 \u03b232T+Q, Z2T+Q = Z2T \u00b7 \u03b22T+Q.\nFrom Eq. (7), we deduce that\nN2m+1,Q(x, y) = N2m,Q(x, y) \u00b7 LT,d,1(x, y), D2m+1,Q(x, y)=D2m,Q(x, y) \u00b7 LT,d,2(x, y).\n(22)\nwhere LT,d,1(x, y) and LT,d,2(x, y) are given by\nLT,d,1(x, y) = \u03b22T+Q \u00b7 (y \u00b7 Z32T \u2212 Y2T )\u2212 \u03b12T+Q \u00b7 (x \u00b7 Z22T \u2212X2T ), LT,d,2(x, y) = \u03b22T+Q \u00b7 (y \u00b7 Z32T \u2212 Y2T ) + 3 2X 2 T \u00b7 \u03b22T+Q \u00b7 (x \u00b7 Z22T \u2212X2T ).\nSince the values of 32X2T , Z22T , Z32T , \u03b12T+Q and \u03b22T+Q have been obtained, the computation of LT,d,1(P ), LT,d,2(P ), LT,d,1(\u03c6\u0302(P )) and LT,d,2(\u03c6\u0302(P )) can be done in m\u0303 + 5m\u0303u + 4r\u0303 + 39m + 11a\u0303 as follows:\nA = yP \u00b7 Z32T \u2212 Y2T , B = xP \u00b7 Z22T \u2212X2T , C = x\u0303P \u00b7 Z22T \u2212X2T , D = 3 2X 2 T \u00b7 \u03b22T+Q, U0 = \u03b22T+Q \u00d7A,U1 = \u03b12T+Q \u00d7B,U2 = \u03b12T+Q \u00d7 C,U3 = D \u00d7B,U4 = D \u00d7 C, LT,d,1(P ) = (U0 \u2212 U1) mod p, LT,d,2(P ) = (U0 + U3) mod p, LT,d,1(\u03c6\u0302(P )) = (U0 \u2212 U2) mod p, LT,d,2(\u03c6\u0302(P )) = (U0 + U4) mod p.\nFinally, it can be seen from Eq. (22) that the computation of N2m+1,Q(P ), D2m+1,Q(P ), N2m+1,Q(\u03c6\u0302(P )) and D2m+1,Q(\u03c6\u0302(P )) requires 4m\u0303 + 4s\u0303. In total, the computational cost at the SDBLADD step is\n2m\u0303 + m\u0303u + 3s\u0303 + s\u0303u + r\u0303 + 7a\u0303\ufe38 \ufe37\ufe37 \ufe38 point doubling + 6m\u0303 + 2m\u0303u + 3s\u0303 + r\u0303 + 8a\u0303\ufe38 \ufe37\ufe37 \ufe38 point addition + m\u0303 + 5m\u0303u + 4r\u0303 + 39m + 11a\u0303\ufe38 \ufe37\ufe37 \ufe38 LT,d,1 and LT,d,2 + 4m\u0303 + 4s\u0303\ufe38 \ufe37\ufe37 \ufe38 the final step\n= 13m\u0303 + 8m\u0303u + 10s\u0303 + s\u0303u + 6r\u0303 + 39m + 26a\u0303."
        },
        {
            "heading": "3.1.3 Shared quadrupling step(SQPL)",
            "text": "By combining two doubling steps into one quadrupling step in the shared Miller loop, we can efficiently perform the following four function updates:\nN4m,Q(P )\u2190 Nm,Q(P ), D4m,Q(P )\u2190 Dm,Q(P ), N4m,Q(\u03c6\u0302(P ))\u2190 Nm,Q(\u03c6\u0302(P )), D4m,Q(\u03c6\u0302(P ))\u2190 Dm,Q(\u03c6\u0302(P )).\nWe first perform two successive point doublings to calculate 4T = (X4T , Y4T , Z4T ). It can be seen from Section 3.1.2 that it costs 4m\u0303 + 2m\u0303u + 6s\u0303 + 2s\u0303u + 2r\u0303 + 14a\u0303. Then, straightforward computation using (8) reveals that\nN4m,Q(x, y) = N4m,Q \u00b7 LT,q,1(x, y), D4m,Q(x, y) = D4m,Q \u00b7 ( LT,q,2(x, y) )2 , (23)\nwhere LT,q,1 and LT,q,2 are given by\nLT,q,1(x, y) = Z4T \u00b7 Z22T \u00b7 ( y \u00b7 Z4T \u00b7 Z22T \u2212\n3 2X 2 2T \u00b7 (x \u00b7 Z22T \u2212X2T )\u2212 Y 22T\n) ,\nLT,q,2(x, y) = y \u00b7 Z4T \u00b7 Z22T + 3 2X 2 T \u00b7 Y2T \u00b7 (x \u00b7 Z22T \u2212X2T )\u2212 Y 22T .\nDuring the procedure of point quadrupling, the values of 32X2T , 3 2X 2 2T and Y 22T can be obtained. Then, we compute LT,q,1(P ), LT,q,2(P ), LT,q,1(\u03c6\u0302(P )) and LT,q,2(\u03c6\u0302(P )) using the following sequence of operations:\nA=Z22T , B=Z4T \u00b7A,C=xP \u00b7A\u2212X2T , D= x\u0303P \u00b7A\u2212X2T , E= 3 2X 2 T \u00b7 Y2T , U0 =yP \u00d7B, U1 = 3 2X 2 T \u00d7 C,U2 = 3 2X 2 T \u00d7D,U3 = C \u00d7 E,U4 = D \u00d7 E,F = (U0 \u2212 U1) mod p, G=(U0\u2212U2) mod p,H=(U0+U3) mod p, I=(U0+U4) mod p, LT,q,1(P ) = B \u00b7 (F\u2212Y 22T ), LT,q,2(P ) = H \u2212 Y 22T , LT,q,1(\u03c6\u0302(P )) = B \u00b7 (G\u2212 Y 22T ), LT,q,2(\u03c6\u0302(P )) = I \u2212 Y 22T .\nThe above computation costs 4m\u0303 + 4m\u0303u + s\u0303 + 4r\u0303 + 26m + 13mu + 14a\u0303. At last, we can obtain N4m,Q(P ), D4m,Q(P ), N4m,Q(\u03c6\u0302(P )) and D4m,Q(\u03c6\u0302(P )) from Eq. (23) at a cost of 4m\u0303 + 8s\u0303. In total, the computational cost at the SQPL step is\n4m\u0303 +2m\u0303u + 6s\u0303 + 2s\u0303u+ 2r\u0303 +14a\u0303\ufe38 \ufe37\ufe37 \ufe38 point quadrupling + 4m\u0303 + 4m\u0303u + s\u0303 + 4r\u0303 + 26m + 13mu + 14a\u0303\ufe38 \ufe37\ufe37 \ufe38 LT,q,1 and LT,q,2 + 4m\u0303 + 8s\u0303\ufe38 \ufe37\ufe37 \ufe38 the final step\n= 12m\u0303 + 6m\u0303u + 15s\u0303 + 2s\u0303u + 6r\u0303 + 26m + 13mu + 28a\u0303.\nIn addition, it can be seen from Eq. (20) that when m = 1, both Dm,Q(P ) and Dm,Q(\u03c6\u0302(P )) are equal to 1, which indicates that two full extension field squarings can be saved."
        },
        {
            "heading": "3.1.4 Function transformation",
            "text": "According to the relation between f\u2212z,Q and g\u2212z,Q, we immediately have\nf\u2212z,Q(P ) = g\u2212z,Q(P ) \u03bd\u03c8(Q)(P ) = N\u2212z,Q(P ) D\u2212z,Q(P ) \u00b7 (xP \u2212 \u03c9 \u00b7 xpQ) ,\nf\u2212z,Q(\u03c6\u0302(P )) = g\u2212z,Q(\u03c6\u0302(P )) \u03bd\u03c8(Q)(\u03c6\u0302(P )) = N\u2212z,Q(\u03c6\u0302(P )) D\u2212z,Q(\u03c6\u0302(P )) \u00b7 (x\u0303P \u2212 \u03c9 \u00b7 xpQ) .\n(24)\nMoreover, the points \u03c02(Q) and \u03c02(\u03c6(Q)) have the same x-coordinates, that is,\n`\u03c02(Q),\u03c02(\u03c6(Q))(P ) = yp \u2212 yp 2 Q . (25)\nPutting Eqs.(24) and (25) together, Eq. (12) can be rewritten as e(P,Q) = (L1L2 ) (p13\u22121)/r, where\nL1 = ( N\u2212z,Q(P ) D\u2212z,Q(P ) \u00b7 (xP \u2212 \u03c9 \u00b7 xpQ) )\u2212z+p \u00b7 ( N\u2212z,Q(\u03c6\u0302(P )) )p \u00b7 (yp \u2212 yp2Q ), L2 = ( D\u2212z,Q(\u03c6\u0302(P )) \u00b7 (x\u0303P \u2212 \u03c9 \u00b7 xpQ) )p .\nOnce the values of N\u2212z,Q(P ), D\u2212z,Q(P ), N\u2212z,Q(\u03c6\u0302(P )) and D\u2212z,Q(\u03c6\u0302(P )) are given, the computation of L1 and L2 can be done at a cost of e\u0303+i\u0303+6m\u0303+13m+5\u0303f+3a\u0303. We will delay the inversion of L2 into the easy part of the final exponentiation such that one inversion can be saved."
        },
        {
            "heading": "3.2 The final exponentiation",
            "text": "An optimized final exponentiation routine is critical for fast pairing computation on BW13-310. The exponent (p13\u22121)/r can be split as\n(p13\u22121)/r = (p\u2212 1)\ufe38 \ufe37\ufe37 \ufe38 easy part \u00b7 (1 + p+ p2 + \u00b7 \u00b7 \u00b7+ p12)/r\ufe38 \ufe37\ufe37 \ufe38 hard part \u00b7\nRaising L1/L2 to the power of p\u2212 1 is easy, which can be done at a cost of i\u0303 + 3m\u0303 + 2\u0303f as follows:\nf = (L1/L2)p\u22121 = Lp1 \u00b7 L2 Lp2 \u00b7 L1 .\nThe bottleneck of the final exponentiation is to raise f to the power of the hard part. In [DZZZ22], the exponent of the hard part can be replaced by\nh = \u03bb0 + 3 \u00b7 p+ ( 3\u2211 i=1 \u03bbi \u00b7 pi\u22121 ) \u00b7 ( 3\u2211 i=0 x3i \u00b7 p10\u22123i ) ,\nwhere x = \u2212z, and \u03bb0, \u03bb1, \u03bb2 and \u03bb3 are given by\n\u03bb0 = \u2212x15 \u2212 2x14 \u2212 2x13 \u2212 x12 \u2212 x2 + 2x+ 2, \u03bb1 = \u2212x18 \u2212 2x17 \u2212 2x16 \u2212 x15 \u2212 x5 + 2x4 + 2x3, \u03bb2 =x16 + x15+ x14 + x4 + 2x3 \u2212 x2 + x, \u03bb3 = x16 + x15 + x14 \u2212 4x2 \u2212 x\u2212 1.\nHowever, unlike the case of even embedding degrees, the cost of the inversion of f is still expensive. In order to avoid this operation as much as possible, we can break \u03bbi as \u03bbi,0 \u2212 \u03bbi,1 for i = 0, 1, 2, 3, where\n\u03bb0,0 = 2x+ 2, \u03bb0,1 = x15 + 2x14 + 2x13 + x12 + x2, \u03bb1,0 = 2x4 + 2x3, \u03bb1,1 = x18 + 2x17 + 2x16 + x15 + x5, \u03bb2,0 = x16 + x15 + x14 + x4 + 2x3 + x, \u03bb2,1 = x2, \u03bb3,0 = x16 + x15 + x14, \u03bb3,1 = 4x2 + x+ 1.\nThe above exponents can be classified by degree into the following two categories:\nlow degrees : \u03bb0,0, \u03bb1,0, \u03bb2,1 and \u03bb3,1; high degrees : \u03bb0,1, \u03bb1,1, \u03bb2,0 and \u03bb3,0.\nFirstly, the values of f\u03bb0,0 , f\u03bb1,0 , f\u03bb2,1 and f\u03bb3,1 can be computed using the following operations:\nf\u2192f3\u2192fx\u2192fx \u00b7f \u2192f2(x+1)\u2192fx 2 \u2192f4x 2 \u00b7fx+1\u2192fx 3 \u2192fx 4 \u2192fx 3 \u00b7 fx 4 \u2192f2(x 3+x4). (26)\nSince only one additional field multiplication is required for obtaining f3 at the process of computing fx, the cost of computing (26) is 4e\u0303 + 4m\u0303 + 4s\u0303. Denote g by f (x12+x13+x14). On the basis of (26), we then compute g with 10e\u0303 + m\u0303:\nfx 5 \u2192 fx 3+x4 \u00b7 fx 5 \u2192 fx 9(x3+x4+x5).\nTo compute f\u03bb0,1 , f\u03bb1,1 , f\u03bb2,0 and f\u03bb3,0 , the following operations are performed:\ng\u2192gx \u2192g \u00b7 gx \u00b7 fx 2 \u2192gx 2 \u2192gx 2 \u00b7fx 3+x4 \u00b7fx 3 \u00b7fx\u2192gx 3 \u2192gx 4 \u2192gx 3 \u00b7gx 4 \u00b7fx 5 . (27)\nThe cost of computing (27) is 4e\u0303 + 7m\u0303. Using the trick of Montgomery\u2019s simultaneous inversion [Mon87], we then can compute the terms f0 = f\u03bb0 and f1 = f\u03bb1+\u03bb2\u00b7p+\u03bb3\u00b7p\n2 as follows:\nf0 = f\u03bb0,0 f\u03bb0,1 = f \u03bb0,0 \u00b7 (f\u03bb1,1 \u00b7 f\u03bb2,1\u00b7p \u00b7 f\u03bb3,1\u00b7p2) f\u03bb0,1 \u00b7 (f\u03bb1,1 \u00b7 f\u03bb2,1\u00b7p \u00b7 f\u03bb3,1\u00b7p2) ,\nf1 = f\u03bb1,0 \u00b7 f\u03bb2,0\u00b7p \u00b7 f\u03bb3,0\u00b7p2\nf\u03bb1,1 \u00b7 f\u03bb2,1\u00b7p \u00b7 f\u03bb3,1\u00b7p2 = f \u03bb0,1 \u00b7 (f\u03bb1,0 \u00b7 f\u03bb2,0\u00b7p \u00b7 f\u03bb3,0\u00b7p2) f\u03bb0,1 \u00b7 (f\u03bb1,1 \u00b7 f\u03bb2,1\u00b7p \u00b7 f\u03bb3,1\u00b7p2) ,\nwhich requires i\u0303c + 9m\u0303 + 4f\u0303. Finally, raising f to the power of h can be expressed as\nf0 \u00b7 f3\u00b7p \u00b7 fp 10+x3\u00b7p7+x6\u00b7p4+x9\u00b7p 1 = f0 \u00b7 (f3 \u00b7 fx 9 1 )p \u00b7 f p10+x3\u00b7p7+x6\u00b7p4 1 . (28)\nSince the value of f3 can be obtained from (26), the computation of (28) requires 9e\u0303 + 5m\u0303 + 4f\u0303."
        },
        {
            "heading": "3.3 Operation counts",
            "text": "Applying the technique of lazy reduction [AKL+11] and Karatsuba algorithm, a detailed description of the finite field arithmetic in Fp13 was given in [DZZZ22]. In Table 1, we summarize the associated operation counts. We now provide detailed operation counts of the pairing computation on BW13-310 by using our algorithms. From (19), the computation of N\u2212z,Q(P ), D\u2212z,Q(P ),N\u2212z,Q(\u03c6\u0302(P )), D\u2212z,Q(\u03c6\u0302(P )) requires executing 5 SQPL, 2 SADD and 1 SDBLADD. Thus, the total number of operations in the Miller loop is\nML = 2a\u0303\ufe38\ufe37\ufe37\ufe38 Eq.(20) + 12m\u0303 + 6m\u0303u + 13s\u0303 + 2s\u0303u + 6r\u0303 + 26m + 13mu + 28a\u0303\ufe38 \ufe37\ufe37 \ufe38 the first QPL +\n4(12m\u0303 + 6m\u0303u + 15s\u0303 + 2s\u0303u + 6r\u0303 + 26m + 13mu + 28a\u0303)\ufe38 \ufe37\ufe37 \ufe38 the last 4 QPL + 2(12m\u0303 + 5m\u0303u + 3s\u0303 + 39m + 3r\u0303 + 15a\u0303)\ufe38 \ufe37\ufe37 \ufe38 2 SADD + 13m\u0303 + 8m\u0303u + 10s\u0303 + s\u0303u + 6r\u0303 + 39m + 26a\u0303\ufe38 \ufe37\ufe37 \ufe38 1 SDBLADD + e\u0303 + i\u0303 + 6m\u0303 + 13m + 5f\u0303 + 3a\u0303\ufe38 \ufe37\ufe37 \ufe38 L1 and L2\n= e\u0303 + i\u0303 + 103m\u0303 + 48m\u0303u + 89s\u0303 + 11s\u0303u + 42r\u0303 + 260m + 65mu + 5f\u0303 + 201a\u0303 = i + 393m + 10506mu + 7326su + 3277r + 131128a.\nIt can be seen from Section 3.2 that the total number of operations in the final exponentiation is\nFE =(\u0303i + 3m\u0303 + 2f\u0303) + (4e\u0303 + 4m\u0303 + 4s\u0303) + (10e\u0303 + m\u0303) + (4e\u0303 + 7m\u0303) + (\u0303ic + 9m\u0303 + 4f\u0303) + (9e\u0303 + 5m\u0303 + 4f\u0303)\n=27e\u0303 + i\u0303 + i\u0303c + 29m\u0303 + 4s\u0303 + 10f\u0303 =i + 253m + 7801mu + 19866su + 5448r + 192605a.\nIn Table 2, we compare the operation counts of ML and FE on BW13-310 to the previous works available in the literature. It should be noted that the estimation in [Gui20] assumes that m\u0303 \u2248 59m, while in [FGA23] assumes that m\u0303 \u2248 66m. Clearly, our algorithms require fewer computational cost as compared to the previous works."
        },
        {
            "heading": "4 Pairings Products Computation on BW13-310",
            "text": "The evaluation of the products of pairings is often required in many pairing-based protocols. Efficient algorithms for computing such products were proposed in [GS06,Sco11,ZL12] by sharing an amount of full extension field squarings and the costly final exponentiation step. In the case of BW13-310, the products of n-pairings can be expressed as\nn\u220f i=1 e(Pi, Qi) = (( n\u220f i=1 f\u2212z,Qi(Pi) )\u2212z+p \u00b7 ( n\u220f i=1 f\u2212z,Qi(\u03c6\u0302(Pi)) )p \u00b7 n\u220f i=1 ( yPi \u2212 y p2 Qi ))(p13\u22121)/r = (Ln,1/Ln,2)(p 13\u22121)/r.\nBy Eqs. (24) and (25), the values of Ln,1 and Ln,2 are given by\nLn,1 = ( \u220fn\ni=1N\u2212z,Qi (Pi)\u220fn i=1 D\u2212z,Qi(Pi)\u00b7 \u220fn i=1(xPi\u2212\u03c9 \u00b7x p Qi )\n)p\u2212z \u00b7 ( n\u220f\ni=1\nN\u2212z,Qi (\u03c6\u0302(Pi)) )p \u00b7 n\u220f i=1 ( yPi\u2212y p2 Qi ) ,\nLn,2 = ( n\u220f\ni=1\nD\u2212z,Qi (\u03c6\u0302(Pi)) \u00b7 n\u220f\ni=1\n(x\u0303Pi \u2212 \u03c9 \u00b7 x p Qi\n) )p ,\n(29)\nwhere x\u0303Pi represents the x-coordinate of \u03c6\u0302(Pi). Clearly, the most costly operations for computing Ln,1 and Ln,2 take place in the evaluations of \u220fn i=1N\u2212z,Qi(Pi), \u220fn i=1D\u2212z,Qi(Pi),\n\u220fn i=1N\u2212z,Qi(\u03c6\u0302(Pi)) and \u220fn i=1D\u2212z,Qi(\u03c6\u0302(Pi)). To start, we need to obtain the following four initial values: n\u220f i=1 N1,Qi(Pi) = n\u220f i=1 (xPi \u2212 xQi), n\u220f i=1 D1,Qi(Pi) = 1,\nn\u220f i=1 N1,Qi(\u03c6\u0302(Pi)) = n\u220f i=1 (x\u0303Pi \u2212 xQi), n\u220f i=1 D1,Qi(\u03c6\u0302(Pi)) = 1. (30)\nGiven an integer m, we denote Ti by [m]Qi for each point Qi. Then, the following relations are easily derived from Section 3.1:\nnSADD  n\u220f i=1 Nm+1,Qi(x, y) = n\u220f i=1 Nm,Qi(x, y) n\u220f i=1 LTi,a,1(x, y),\nn\u220f i=1 Dm+1,Qi(x, y) = n\u220f i=1 Dm,Qi(x, y) n\u220f i=1 LTi,a,2(x, y).\nnSDBL  n\u220f i=1 N2m+1,Qi(x, y) = ( n\u220f i=1 Nm,Qi(x, y) )2 n\u220f i=1 LTi,d,1(x, y),\nn\u220f i=1 D2m+1,Qi(x, y) = ( n\u220f i=1 Dm,Qi(x, y) )2 n\u220f i=1 LTi,d,2(x, y).\nnSQPL  n\u220f i=1 N4m,Qi(x, y) = ( n\u220f i=1 Nm,Qi(x, y) )4 n\u220f i=1 LTi,q,1(x, y),\nn\u220f i=1 D4m,Qi(x, y) = ( n\u220f i=1 Nm,Qi(x, y) )4( n\u220f i=1 LTi,q,2(x, y) )2 .\nBased on the analysis of Section 3.1, we can deduce that the costs of the nSADD, nSDBLADD and nSQPL steps are\n\u2022 nSADD: n(12m\u0303 + 5m\u0303u + 3s\u0303 + 39m + 3r\u0303 + 15a\u0303).\n\u2022 nSDBLADD:\nn(2m\u0303 + m\u0303u + 3s\u0303 + s\u0303u + r\u0303 + 7a\u0303)\ufe38 \ufe37\ufe37 \ufe38 point doublings +n(6m\u0303 + 2m\u0303u + 3s\u0303 + r\u0303 + 8a\u0303)\ufe38 \ufe37\ufe37 \ufe38 point additions + n(m\u0303 + 5m\u0303u + 4r\u0303 + 39m + 11a\u0303)\ufe38 \ufe37\ufe37 \ufe38 LTi,d,1 and LTi,d,2 + 4nm\u0303 + 4s\u0303\ufe38 \ufe37\ufe37 \ufe38 the final step\n= 4s\u0303 + n(13m\u0303 + 8m\u0303u + 6s\u0303 + s\u0303u + 6r\u0303 + 39m + 26a\u0303.\n\u2022 nSQPL:\nn(4m\u0303 +2m\u0303u + 6s\u0303 + 2s\u0303u+ 2r\u0303 +14a\u0303)\ufe38 \ufe37\ufe37 \ufe38 point quadruplings + n(4m\u0303 + 4m\u0303u + s\u0303 + 4r\u0303 + 26m + 13mu + 14a\u0303)\ufe38 \ufe37\ufe37 \ufe38 LTi,q,1 and LTi,q,2 + 4nm\u0303 + 8s\u0303\ufe38 \ufe37\ufe37 \ufe38 the final step\n= 8s\u0303 + n(12m\u0303 + 6m\u0303u + 7s\u0303 + 2s\u0303u + 6r\u0303 + 26m + 13mu + 28a\u0303).\nAnalogous to the single pairing computation, two full extension field squarings can be saved at the first nSQPL step, and we can obtain the terms \u220fn i=1N\u2212z,Qi(Pi), \u220fn i=1D\u2212z,Qi(Pi),\n\u220fn i=1N\u2212z,Qi(\u03c6\u0302(Pi)) and \u220fn i=1D\u2212z,Qi(\u03c6\u0302(Pi)) by executing 5 nSQPL, 2 nSADD and 1 nSDBLADD. On this basis, we continue to calculate Ln,1 and Ln,2. Since the point Pi for each i is defined over Fp, we have\nn\u220f i=1 (xPi \u2212 \u03c9 \u00b7 x p Qi ) = ( n\u220f i=1 (xPi \u2212 \u03c9 \u00b7 xQi) )p ,\nn\u220f i=1 (x\u0303Pi \u2212 \u03c9 \u00b7 x p Qi ) = ( n\u220f i=1 (x\u0303Pi \u2212 \u03c9 \u00b7 xQi))p,\nn\u220f i=1 ( yPi \u2212 y p2 Qi ) = ( n\u220f i=1 ( yPi \u2212 yQi ))p2 .\nThe above computation requires 3(n\u2212 1)m\u0303 + 13nm + 3\u0303f + 3na\u0303. By the form of Eq. (29), it is straightforward to see that the cost of computing Ln,1 and Ln,2 is\n(3(n\u2212 1)m\u0303 + 13nm + 3f\u0303 + 3na\u0303) + (e\u0303 + i\u0303 + 6m\u0303 + 2f\u0303) =e\u0303 + i\u0303 + 3(n+ 1)m\u0303 + 13nm + 5f\u0303 + 3na\u0303.\nBased on the above analysis, the cost of the Miller loop for computing n-pairings products on BW13-310 is\nnML = 2(n\u2212 1)m\u0303 + 2na\u0303\ufe38 \ufe37\ufe37 \ufe38 Eq. (30) + 6s\u0303 + n(12m\u0303 + 6m\u0303u + 7s\u0303 + 2s\u0303u + 6r\u0303 + 26m + 13mu + 28a\u0303)\ufe38 \ufe37\ufe37 \ufe38 the first nQPL +\n32s\u0303 + 4n(12m\u0303 + 6m\u0303u + 7s\u0303 + 2s\u0303u + 6r\u0303 + 26m + 13mu + 28a\u0303)\ufe38 \ufe37\ufe37 \ufe38 the last 4 nQPL + 2n(12m\u0303 + 5m\u0303u + 3s\u0303 + 39m + 3r\u0303 + 15a\u0303)\ufe38 \ufe37\ufe37 \ufe38 2 nSADD + 4s\u0303 + n(13m\u0303 + 8m\u0303u + 6s\u0303 + s\u0303u + 6r\u0303 + 39m + 26a\u0303)\ufe38 \ufe37\ufe37 \ufe38 1 nSDBLADD + e\u0303 + i\u0303 + 3(n+ 1)m\u0303 + 13nm + 5f\u0303 + 3na\u0303\ufe38 \ufe37\ufe37 \ufe38 Ln,1 and Ln,2\n=e\u0303 + i\u0303 + (102n+ 1)m\u0303 + 48nm\u0303u + (47n+ 42)s\u0303 + 11ns\u0303u + 42nr\u0303 + 260nm + 65nmu + 5f\u0303 + 201na\u0303.\n=i + (260n+ 133)m + (9965n+ 541)mu + (3828n+ 3498)su + (2483n+ 794)r + (103607n+ 27521)a.\nIn summary, the total number of operations required for computing n-pairings products on BW13-310 is\nnML+ FE =2i + (260n+ 386)m + (9965n+ 8342)mu + (3828n+ 23364)su + (2483n+ 6242)r + (103607n+ 220126)a."
        },
        {
            "heading": "5 Exponentiation in Pairing Groups",
            "text": "Exponentiation in three pairing groups G1, G2 and GT also plays a vital role in the implementation of pairing-based protocols. In this section, we discuss how to efficiently perform the operation on BW13-310. The best-known method for computing [n]P with\nP \u2208 G1 and n \u2208 Zr was introduced by Gallant, Lambert, Vanstone [GLV01], which is called the GLV method.The basic idea of this method is as follows. If the target curve has an efficiently computable endomorphism \u03c6 such that \u03c6(P ) = [\u03bb]P for some integer \u03bb, then the scalar n can be decomposed as n0, n1 such that n \u2261 n0 + n1 \u00b7 \u03bb mod r, where |n0|, |n0| \u2248 \u221a r. Thus, the computation of [n]P can be replaced by the multi-exponentiation [n0]P + [n1]\u03c6(P ). In summary, this method can halve the number of point doublings. In addition, recoding n0 and n1 with the w-width non-adjacent form (w-NAF) can reduce the number of point additions. In the RELIC cryptographic toolkit [AG], this method can be implemented automatically once the associated curve parameters are given. Therefore, we only investigate how to perform exponentiations in G2 and GT on this curve."
        },
        {
            "heading": "5.1 Exponentiation in G2",
            "text": "For exponentiation in G2 on curves admitting a twist, such as BN and BLS12 families, GLS method [GLS09] breaks a random exponent n \u2208 Zr into \u03d5(k) mini-exponents n0, n1, \u00b7 \u00b7 \u00b7 , n\u03d5(k)\u22121 such that the bit size of the maximum of |ni| is about 1\u03d5(k) log r. In general, GLS method largely reduces the number of iterations required for computing [n]Q with Q \u2208 G2.\nIt is possible to build a higher-dimensional decomposition by combining GLV and GLS methods on some certain curves. This idea was initially proposed by Longa and Sica [LS12] to obtain a four dimensional decomposition on certain curves, and subsequently applied into different scenarios [CL15,FHLS14]. On BW13-310, the orders of \u03c6 and \u03c0 are respectively 3 and k in EndF\npk (E) with gcd(3, k) = 1, where EndF pk (E) denotes the\nendomorphism ring of E over Fpk . It indicates that \u03c8 = \u03c6 \u25e6 \u03c0 satisfies \u03a62\u03d5(k)(\u03c8) = 0, so a random exponent n can be decomposed into 2\u03d5(k) mini-exponents, where the bit size of the maximum of |ni| is about 12\u03d5(k) log r. It should be noted that the 2\u03d5(k)-dimensional decomposition takes advantage of the fact that \u03c8(Q) = [\u2212z]Q. More specifically, since log r \u2248 24 log|z|, the exponent n can be written in the basis of |z| as\nn = n0 + n1 \u00b7 |z|+ \u00b7 \u00b7 \u00b7+ n23 \u00b7 |z|23,\nwhere log|ni| < log|z| \u2248 124 log r. Thus, the computation of [n]Q with Q \u2208 G2 can be accomplished as\n[n]Q = [n0]Q+ n1\u03c8(Q) + \u00b7 \u00b7 \u00b7+ [n23]\u03c823(Q).\nBy the form of the endomorphism \u03c8, we have\n\u03c8i(Q) = (\u03c9i \u00b7 xp i Q , y pi Q )\nfor i = 0, 1, \u00b7 \u00b7 \u00b7 , 23, and thus the cost of computing \u03c8i(Q) is negligible. The procedure of performing exponentiation in G2 on BW13-310 is summarized in Alg. 2. Remark 1. We conclude that if the orders of \u03c6 and \u03c0 are coprime in EndF\npk (E), then\nthere exists a 2\u03d5(k)-dimensional decomposition in G2. However, the orders of \u03c6 and \u03c0 are respectively d and k in EndF\npk (E) with d | k (d = 3 or 4) on many mainstream\npairing-friendly curves, such as BN, BLS12, KSS16 and KSS18 families. It means that \u03c8 = \u03c6 \u25e6 \u03c0 satisfies \u03a6\u03d5(k)(\u03c8) = 0. Thus, the new technique is not suitable for the above mentioned curves."
        },
        {
            "heading": "5.2 Exponentiation in GT",
            "text": "Since there is not an efficient computable endomorphism in Fpk corresponding to the GLV endomorphism in E(Fpk ), the exponentiation in GT is slightly different to that in G2. In other words, in the case of exponentiation in GT , a given exponent n can be\nAlgorithm 2 Exponentiation in G2 on BW13-310 Input: a random positive integer n \u2208 Zr, a random point Q \u2208 G2 Output: [n]Q\n1: Q0 \u2190 Q 2: for i = 1 to 23 do 3: Qi \u2190 \u03c8(Qi\u22121) 4: end for 5: Compute [j]Qi for j \u2208 {1, 3, 5, \u00b7 \u00b7 \u00b7 , 2w \u2212 1}\n6: Decompose n into (n0, n1, \u00b7 \u00b7 \u00b7 , n23) with n = 23\u2211 i=0 ni \u00b7 |z|i\n7: Recode ni = t\u22121\u2211 j=0 ni,j2j in w-NAF 8: R\u2190 O 9: for j = t\u2212 1 down to 0 do\n10: R\u2190 [2]R 11: for i = 0 to 23 do 12: if ni,j > 0 13: R\u2190 R+ [ni,j ]Qi 14: else 15: R\u2190 R\u2212 [ni,j ]Qi 16: end if 17: end for 18: end for 19: return R\nonly decomposed into \u03d5(k) multi-exponents by using the Frobenius endomorphism, rather than 2\u03d5(k). We now follow the same recipe described by Galbraith and Scott [GS08] to decompose n the as n0, n1, \u00b7 \u00b7 \u00b7 , n\u03d5(k)\u22121 such that\nn \u2261 (n0 + n1 \u00b7 p+ \u00b7 \u00b7 \u00b7+ n\u03d5(k)\u22121p\u03d5(k)\u22121) mod r\nand max{|n0|, |n1| \u00b7 \u00b7 \u00b7 , |n\u03d5(k)\u22121|} \u2248 r1/\u03d5(k). To this aim, we first define a modular lattice L as\nL = {(z0, z1, \u00b7 \u00b7 \u00b7 , z11)|z0 + z1 \u00b7 p+ \u00b7 \u00b7 \u00b7+ z11 \u00b7 p11 \u2261 0 mod r}.\nClearly, a basis B\u2217 = (b\u22170,b\u22171, \u00b7 \u00b7 \u00b7 ,b\u221711) of L is naturally selected as\nb\u22170 = (r, 0, 0, \u00b7 \u00b7 \u00b7 , 0), b\u22171 = (p,\u22121, 0 \u00b7 \u00b7 \u00b7 , 0), ... b\u221711 = (p, 0, 0 \u00b7 \u00b7 \u00b7 ,\u22121).\nInputting the basis B\u2217 into the LLL algorithm [LLL82], we obtain a LLL-reduced basis B = (b0,b1, \u00b7 \u00b7 \u00b7 ,b11) as\nb0 = (z2,\u2212z, 1, 0, 0, \u00b7 \u00b7 \u00b7 , 0), b1 = (0, z2,\u2212z, 1, 0, \u00b7 \u00b7 \u00b7 , 0), ... b9 = (0, 0, \u00b7 \u00b7 \u00b7 , 0, z2,\u2212z, 1), b10 = (1, \u00b7 \u00b7 \u00b7 , 1,\u2212z2 + 1, z + 1), b11 = (\u2212z \u2212 1,\u2212z, \u00b7 \u00b7 \u00b7 ,\u2212z,\u2212z2 + z).\nSince (r, 0, 0, \u00b7 \u00b7 \u00b7 , 0) \u2208 L, there exists a unique solution (y0, y1, \u00b7 \u00b7 \u00b7 , y11) \u2208 Z12 such that\n(r, 0, 0, \u00b7 \u00b7 \u00b7 , 0) = y0b0 + y1b1 + \u00b7 \u00b7 \u00b7+ y11b11 (31)\nMultiplying n/r on the both side of (31), it produces that\n(n, 0, 0, \u00b7 \u00b7 \u00b7 , 0) = \u03b10b0 + \u03b11b1 + \u00b7 \u00b7 \u00b7+ \u03b111b11, (32)\nwhere \u03b1i = yi \u00b7 n/r. We define\nn = (n0, n1, \u00b7 \u00b7 \u00b7 , n11) = (n, 0, 0, \u00b7 \u00b7 \u00b7 , 0)\u2212 b\u03b10eb0 \u2212 b\u03b11eb1 \u2212 \u00b7 \u00b7 \u00b7 \u2212 b\u03b111eb11. (33)\nSince b\u03b1ie \u2208 Z for each i, it is clear that n \u2208 n+ L. Moreover, combining Eqs.(32) and (33), we have\n(n0, n1, \u00b7 \u00b7 \u00b7 , n11) = (\u03b10 \u2212 b\u03b10e)b0 + (\u03b11 \u2212 b\u03b11e)b1 + \u00b7 \u00b7 \u00b7+ (\u03b111 \u2212 b\u03b111e)b11.\nSince the selected seed z is negative and |\u03b10 \u2212 b\u03b10e| \u2264 1/2, we immediately get that\n\u2016n\u2016\u221e \u2264 (z2 \u2212 2z + 2)/2 \u2248 r1/\u03d5(k). (34)\nFor the mainstream pairing-friendly curves, such as BN, BLS12, KSS16 and KSS18 families, the embedding degrees k are always even. This allows inversion in GT to be computed for almost free by using a simple conjugation over Fpk/2 . In other words, nonpositive exponent decomposition will not bring extra overhead for exponentiation in GT on these curves. However, the picture is different on BW13-310 as it has an odd prime embedding degree. It pays a penalty for expensive cost inversion in GT . In order to avoid this operation when performing exponentiation in GT , we expect multi-exponents are all-positive.\nProposition 1. Let the lattice L and the LLL-reduced basis B = (b0,b1, \u00b7 \u00b7 \u00b7 ,b11) of L be constructed as above. For any integer n \u2208 Z, there exists a vector n\u2032 = (n\u20320, n\u20321, \u00b7 \u00b7 \u00b7 , n\u203211) \u2208 n+ L such that the tuples of n\u2032 are all-positive and \u2016n\u2032\u2016\u221e \u2264 3(z2 \u2212 2z + 2)/2.\nProof. We first decompose the scalar n into the vector n as in (33). Then, we define c = b0 + b1 + \u00b7 \u00b7 \u00b7 + b9 \u2212 b10 \u2212 b11 and n\u2032 = c + n. It is obviously that n\u2032 \u2208 n + L. Moreover, by the definition of bi for each i, it is straightforward to see that\nmin{c0, c1, \u00b7 \u00b7 \u00b7 , c\u03d5(k)\u22121} \u2265 z2 \u2212 1,max{c0, c1, \u00b7 \u00b7 \u00b7 , c\u03d5(k)\u22121} \u2264 z2 \u2212 2z + 2, (35)\nwhere ci is denoted as the i-th tuple of c. Combining Eq.s (34) and (35) together, the proof is immediate.\nThe all-positive decomposition described in Proposition 1 also leads to around 1 bit increase for the bound of the size of the mini-exponents. Considering the expensive cost of inversion in GT , this trade is absolutely worthwhile. In addition, one should be noted that when performing the small exponentiations by n\u2032i for i = 0, 1, \u00b7 \u00b7 \u00b7 , 11, the NAF expression is not applicable. The procedure of exponentiation in GT on BW13-310 is presented in Alg. 3."
        },
        {
            "heading": "6 Implementation Results",
            "text": "In this section, we present our implementation results of the pairing computation and common building blocks on BW13-310 within the RELIC cryptographic toolkit. For the pairing computation and the group exponentiations in G2 and GT we use the algorithms proposed in this paper. For hashing to G1 and G2, the group membership testings and the group exponentiation in G1, we exploit state-of-the-art techniques. In detail,\nAlgorithm 3 Exponentiation in GT on BW13-310 Input: a random positive integer n \u2208 Zr, a random element f \u2208 GT Output: fn\n1: f0 \u2190 f 2: for i = 1 to 11 do 3: fi \u2190 fpi\u22121 4: end for 5: Compute f ji for j \u2208 {1, 3, 5, \u00b7 \u00b7 \u00b7 , 2w \u2212 1} 6: Decompose n into all-positive mini-exponents (n0, \u00b7 \u00b7 \u00b7 , n11) by using Proposition 1\n7: Recode ni = t\u22121\u2211 j=0 ni,j2j such that ni,j \u2208 {1, 3, 5, \u00b7 \u00b7 \u00b7 , 2w \u2212 1} 8: g \u2190 1 9: for j = t\u2212 1 down to 0 do\n10: g \u2190 g2 11: for i = 0 to 11 do 12: if ni,j > 0 13: g \u2190 g \u00b7 fni,ji 14: end if 15: end for 16: end for 17: return g\n\u2022 The function H1 : {0, 1}\u2217 \u2192 G1 is implemented by using the Shallue-van de Woestijne (SVW) map [SvdW06], followed by a cofactor multiplication. The SVW map aims to efficiently hash a binary string to a random point R1 \u2208 E(Fp) in constant time, and the cofactor multiplication forces R1 into the target group G1. RELIC provides dedicated implementation of this map in the ep_map_from_field() function in the file /src/ep/relic_ep_map.c. The procedure of clearing cofactor can be done at a cost of one multiplication by z2 \u2212 z + 1 [EHGP22].\n\u2022 The function H2 : {0, 1}\u2217 \u2192 G2 is implemented by using the method proposed in [DZZ22]. Likewise, it is split into two phases: hashing a binary string to a random point R2 \u2208 E(Fp13), followed by mapping R2 to G2. The computational cost of hashing to G2 largely comes from the second phase, which requires approximately 26 scalar multiplications by z, 13 point doublings and 41 point additions in E(Fp13).\n\u2022 The best-known algorithms for the G1, G2 and GT membership testings on BW13-310 are proposed in [DLZZ23], which require approximately 12 scalar multiplications by z in E(Fp), 1 scalar multiplications by z in E(Fp13) and 2 exponentiations by z in Fp13 , respectively.\nIn order to evaluate strengths and weaknesses of BW13-310 in real-world pairing based cryptographic protocols, we present a performance comparison between BW13-310 and other 128-bit secure pairing-friendly curves, including BN446, BLS12-446 and BLS24-315. Specially, BN446 and BLS12-446 are well known for fast pairing computations, while BLS24-315 is another interesting curve with fast exponentiation in G1. All of these curves are defined by an equation of the form y2 = x3 + b for some b \u2208 F\u2217p, and the related parameters are summarized in Table 3.\nRELIC provides high speed implementations of pairing computations and the required auxiliary building blocks on BN446, BLS12-446 and BLS24-315. We have integrated our codes in this library to allow a direct performance comparison across different curves. The source code is available at https://github.com/eccdaiy39/BW13-P310. Our benchmark results are presented in Figs. 1-4. Timings are measured on an Intel Core i9-12900K processor running at @3.2GHz with TurboBoost and hyper-threading features disabled, averaged over 104 executions. For group exponentiations G1, G2 and GT on each curve, window widths w are set as 4, 1 and 1, respectively.\n\u2022 Compared to BN446 and BLS12-446, BW13-310 is about 109.1%\u2212 227.3%, 100%\u2212 192.6%, 24.5% \u2212 108.5% and 68.2% \u2212 145.5% faster in terms of hashing to G1, exponentiations in G1 and GT , and membership testing for GT , respectively. In essence, as to operations related to G1, BW13-310 benefits from fast prime field arithmetic. As to operations related to GT , even though BW13-310 fails to provide fast cyclotomic squaring [GS10,Kar12] and decode exponents in the NAF form, it is much more favoured for a small size of full extension field and a large value of \u03d5(k), which result in fast full extension field multiplication and high dimensional GLS decomposition.\n\u2022 More surprisingly, the gap in the performance of single pairing computation between BW13-310 and BN446 (resp. BLS12-446) is only up to 4.9% (resp. 26%). In particular, the computation of the Miller loop on BW13-310 is even up to 48.2% faster than that on BN446. In fact, our results reveal that a few percent efficiency disadvantage of pairing computation on BW13-310 mainly arises from the final exponentiation part. For the computation of the n-pairings products, BW13-310 outperforms BN446, while still slower than BLS12-446. For example, for the 8- pairings products, BW13-310 is about 14.2% faster than that on BN446, while 25.5% slower than that on BLS12-446.\n\u2022 However, BW13-310 also introduces a significant penalty for hashing to G2 and exponentiation in G2. Indeed, the pairing group G2 on BW13-310 is defined over the full extension field as the lack of twists, while that on BLS12-446 and BN446 lies in a subfield Fp2 .\n\u2022 For BW13-310 and BLS24-315, they provide nearly equal performance in terms of exponentiation in G1, membership testing for G1. Moreover, the former has a significant advantage in terms of hashing to G1, exponentiation in GT , membership testing for GT and pairing computation, while the latter outperforms for hashing to G2 and exponentiation in G2.\nIn summary, our implementation results show that BW13-310 is competitive in scenarios that hashing to G2 and exponentiation in G2 are not necessary, or performed by a powerful computational entity.\nFigure 3: Group membership testings BLS12-446 BN446 BW13-310 BLS24-315\nFigure 4: Single pairing computation\nBLS12-446 BN446 BW13-310 BLS24-315 0\n500\n1,000\n1,500\n2,000\n2,500\n443\n570 561\n1,210\n763\n1,056 985\n1,791\n1,077\n1,544\n1,352\n2,372\ncl oc k cy cl es (\u00d7\n10 4 )\nn = 8 n = 5 n = 2\nFigure 5: n-pairings products computation"
        },
        {
            "heading": "7 Applications",
            "text": "In this section, we estimate the performance of two pairing-based cryptosystems built on the above mentioned pairing-friendly curves, aiming to explain that BW13-310 is an interesting candidate."
        },
        {
            "heading": "7.1 Unbalanced Chen-Kudla protocol",
            "text": "In [CK03], Chen and Kudla designed a two-party identity based authenticated key agreement protocol from pairings. In this protocol, each entity is required to perform one exponentiation in G1 and one pairing computation. In real-world protocols, it is often the\ncase that one entity (Client) is equipped with a resource-constrained device, while the other (Server) is more powerful. To reduce the workload of the client, it is reasonable to shift the time-consuming pairing computation to the server. To this aim, Scott [Sco13] proposed an unbalanced Chen-Kudla protocol (UCK). In this scenario, a system wide public parameter Q \u2208 G2 is introduced. A trusted authority (TA) posseses a master secret key s \u2208 Zr. The client and server have secret keys SA and SB issued by TA as SA = [s]H1(IDA) \u2208 G1 and SB = [s]Q \u2208 G2 respectively, where IDA is the client\u2019s identity. Then the protocol runs as follows:\n1. The client chooses r1, r2 \u2190 Zr at random, calculates R1 = [r1]SA and R2 = [r2]H1(IDA) and sends the two points R1 and R2 to the server;\n2. The server chooses r3 \u2190 Zr at random, calculates R3 = [r3]R1 and g = e(R3, Q), and send the pairing value g to the client;\n3. The client obtains the session key KA by computing\nKA = ( e(SA, Q)r1\u00b7r2 \u00b7 g )1/r1 .\nThe server obtains the session key KB by computing\nKB = e(R2 + [r3]H1(IDA), SB).\n4. If the both entities follow this protocol, they would share the same session key\nK = KA = KB = e(SA, Q)(r2+r3).\nSince the client can precompute the point H1(IDA) and the pairing value e(SA, Q), the entity only costs two exponentiations in G1 and two exponentiations in GT . Meanwhile, the server costs one hashing to G1, two exponentiations in G1 and two pairing computations.\nConsidering the protocol is designed to minimize the workload of the client, we can see that BW13-310 is well-suited as it provides fast implementation for group exponentiations in both G1 and GT . Based on implementation results presented in Figs.1-4, Table 4 shows our cost estimates for each party of the UCK protocol built on different curves. One can see that the UCK protocol built on BW13-310 is about 125.6% and 40.6% faster than that on BN446 and BLS12-446 for the client, respectively."
        },
        {
            "heading": "7.2 BLS signature scheme",
            "text": "The Boneh-Lynn-Shacham (BLS) signature is a famous short signature scheme from pairings [BLS04]. In the scheme, the point g2 \u2208 G2 is a public parameter and the signer posseses a pair of key (s, pk = [s]g2), where s is private and pk is public. Then, the scheme works as follows:\n1. To sign a message msg, the signer computes M = H1(msg), sig = [s]M , and sends the pair (msg, sig) to the verifier.\n2. To verify the signed message, the verifier computes M = H1(msg) and assert that the signature is valid if and only if sig \u2208 G1 and e(sig, pk) = e(M, g2).\nIt should be noted that an attacker can use the point sig\u2032 = sig + R to forge a valid signature as e(sig\u2032, pk) = e(sig, pk), where R is an random point in the subgroup r \u00b7E(Fp). Thus, it can not be ignored for the verifier to check sig \u2208 G1. In this setting, the signer costs one hashing to G1 and one exponentiation in G1, while the verifier costs one hashing to G1, one subgroup membership testing for G1 and one product of 2-pairings. From Figs. 1-4, we estimate that the BLS signature scheme built on BW13-310 is about both 1.5\u00d7 faster than that on BN446 and BLS12-446 for the signer, respectively. Considering that the performance penalty for the verifier is not expensive, this tradoff becomes favorable in the case that the scheme is designed to reduce the workload of the signer."
        },
        {
            "heading": "8 Conclusion and Future Work",
            "text": "In this work, we presented a detailed study of a 128-bit secure pairing-friendly curve: BW13-310. We first proposed a new formula for computing the optimal pairing on this curve. Specially, we showed that it requires two evaluations at the same Miller function of bit length approximately log r/(2\u03d5(k)). On this basis, we proposed a shared Miller loop such that the two function evaluations can share intermediate values as much as possible. In addition, we also described several optimizations for group exponentiations in G2 and GT on this curve. In the case of G2, we showed that GLV and GLS method can be combined to build a 2\u03d5(k) dimensional decomposition. In the case of GT , our optimization eliminates expensive field inversion.\nFinally, we presented high speed implementations of pairing computation, hashing (to G1 and G2), group exponentiations and membership testings on a 64-bit processor over BW13-310. The technique of lazy reduction was fully utilized to minimize the number of modular reductions. Our results showed that compared to BN446 and BLS12-446, BW13-310 wins out in the performance of hashing to G1, group exponentiations in G1 and GT , and membership testing for GT . Furthermore, it was very surprising to find that the gap in the performance of single pairing computations between BW13-310 and BN446 (resp. BLS12-446) is only up to 4.9% (resp. 26%). In particular, compared to BN446, BW13-310 even has certain advantages for the computation of pairings products. Our results also reported that the target curve would pay a penalty for hashing to G2 and the group exponentiation in G2.\nVery recently, Longa [Lon23] further optimized the technique of lazy reduction such that the penalty of \u201cdouble-precision\u201d operations can be avoided. We note that the new algorithm gets a greater performance boost on prime fields with smaller sizes, potentially helping BW13-310 become more attractive. In addition, a faster SVW map (SwiftEC) was proposed in [CSRHT23](ASIACRYPT 2022). The performance comparison across different pairing-friendly curves using these optimized algorithms are left as future work."
        },
        {
            "heading": "Acknowledgment",
            "text": "We would like to thank the anonymous referees for their valuable comments and suggestion. This work is supported by Guangdong Major Project of Basic and Applied Basic Research(No. 2019B030302008) and the National Natural Science Foundation of China(No. 61972428 and 61972429)."
        }
    ],
    "title": "Don\u2019t Forget Pairing-Friendly Curves with Odd Prime Embedding Degrees",
    "year": 2023
}