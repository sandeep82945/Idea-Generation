Monitoring the presence and movements of individuals or crowds in a given area can provide valuable insight into actual behavior patterns and hidden trends. Therefore, it is crucial in areas such as public safety, transportation, urban planning, disaster and crisis management, and mass events organization, both for the adoption of appropriate policies and measures and for the development of advanced services and applications. In this paper, we propose a non-intrusive privacy-preserving detection of people’s presence and movement patterns by tracking their carried WiFi-enabled personal devices, using the network management messages transmitted by these devices for their association with the available networks. However, due to privacy regulations, various randomization schemes have been implemented in network management messages to prevent easy discrimination between devices based on their addresses, sequence numbers of messages, data fields, and the amount of data contained in the messages. To this end, we proposed a novel derandomization method that detects individual devices by grouping similar network management messages and corresponding radio channel characteristics using a novel clustering and matching procedure. The proposed method was first calibrated using a labeled publicly available dataset, which was validated by measurements in a controlled rural and a semi-controlled indoor environment, and finally tested in terms of scalability and accuracy in an uncontrolled crowded urban environment. The results show that the proposed de-randomization method is able to correctly detect more than 96% of the devices from the rural and indoor datasets when validated separately for each device. When the devices are grouped, the accuracy of the method decreases but is still above 70% for rural environments and 80% for indoor environments. The final verification of the non-intrusive, low-cost solution for analyzing the presence and movement patterns of people, which also provides information on clustered data that can be used to analyze the movements of individuals, in an urban environment confirmed the accuracy, scalability and robustness of the method. However, it also revealed some drawbacks in terms of exponential computational complexity and determination and fine-tuning of method parameters, which require further optimization and automation. 1. conclusions This paper presented an approach for monitoring the presence of individuals at specific locations based on collected PRs, taking into account the increasing adoption of MAC address randomization due to privacy concerns. The main contribution of this work
is the development of a method for MAC de-randomization based on the similarity of PRs, more specifically IE data. We described the designed system and deployment for capturing PRs sent by WiFi-enabled devices. The detection of unique WiFi interfaces is implemented in two stages. After grouping PRs based on random or global MAC addresses, clustering is performed on PRs from devices with random MAC addresses. The generated clusters are then matched with PRs of devices with global MAC addresses. The proposed approach was validated in a controlled rural, semi-controlled indoor, and uncontrolled urban environment, first with PRs from only individual WiFi-enabled devices and later with all devices and three formed groups of devices to account for three different levels of difficulty for de-randomization. Validation on individual devices showed that in some cases, the de-randomization method detected two devices instead of one. For the formed groups, the results show the disadvantage of the proposed method when multiple devices of the same manufacturer and version of OS were present. Although the performance of the proposed method decreases in this case, it is still above 70% for rural and 80% for indoor environments. Author Contributions: Conceptualization, M.M. (Mihael Mohorčič) and A.H.; methodology, M.M. (Mihael Mohorčič) and A.H.; hardware, M.M. (Miha Mohorčič); software, A.S. and M.M. (Miha Mohorčič); validation, M.M. (Miha Mohorčič), A.S. and A.H.; data analysis and curation, A.S. and M.M. (Miha Mohorčič); writing—original draft preparation, A.S., M.M. (Miha Mohorčič) and A.H.; writing— review and editing, M.M. (Mihael Mohorčič); visualization, A.S.; supervision, A.H.; funding acquisition, M.M. (Mihael Mohorčič). All authors have read and agreed to the published version of the manuscript. Funding: This research was partly funded by the Slovenian Research Agency (Grant no. P2-0016, J2-3048, and J2-2507) and the European Community under the H2020 RESILOC project (Grant no. 833671). Institutional Review Board Statement: Not applicable. Informed Consent Statement: Not applicable. Data Availability Statement: The data presented in this study are openly available in repositories Zenodo [37,38] and Mendeley Data at https://doi.org/10.17632/j64btzdsdy.1. Conflicts of Interest: The author declare no conflict of interest. The funders had no role in the design of the study; in the collection, analyses, or interpretation of data; in the writing of the manuscript, or in the decision to publish the results. Abbreviations The following abbreviations are used in this manuscript:
CID Company Identifier GDPR General Data Protection Regulation HMM Hidden Markov Models HT High Throughput IE Information Element IFAT Inter-Frame Arrival Time IoT Internet-of-Things JSI Jozef Stefan Institute JSON JavaScript Object Notation
MAC medium access control ML Machine learning NIC Network Interface Controller OPTICS Ordering Points to Identify the Clustering Structure OS Operating system OUI Organization Unique Identifier PR Probe Request REST Representational State Transfer rPi Raspberry Pi RSSI Received Signal Strength Indicator SSID Service Set Identifier ToA Time of Arrival VHT Very High Throughput WSD Wireless Sensor Device appendix a. structure of stored data from pr Data from PRs of each MAC address are stored in the following JSON format: 1 {’MAC’: MAC_address , ’SSIDs ’: [ SSID ], ’PROBE_REQs ’: [PR_data] },
where PR_data is structured as: 1 PR_data = 2 { 3 ’TIME’: [ DATA_time ], 4 ’RSSI’: [ DATA_rssi ], 5 ’DATA’: pr_IE_data 6 }
and PR_IE_data as: 1 PR_IE_data = 2 { 3 ’DATA_RTS ’: {’SUPP’: DATA_supp , ’EXT’: DATA_ext}, 4 ’HT_CAP ’: DATA_htcap , 5 ’EXT_CAP ’: {’length ’: DATA_len , ’data’: DATA_extcap}, 6 ’VHT_CAP ’: DATA_vhtcap , 7 ’INTERWORKING ’: DATA_inter , 8 ’EXT_TAG ’: {’ID_1’: DATA_1_ext , ’ID_2’: DATA_2_ext ...}, 9 ’VENDOR_SPEC ’: {VENDOR_1 :{
10 ’ID_1’: DATA_1_vendor1 , 11 ’ID_2’: DATA_2_vendor1 12 ...}, 13 VENDOR_2 :{ 14 ’ID_1’: DATA_1_vendor2 , 15 ’ID_2’: DATA_2_vendor2 16 ...} 17 ...} 18 } appendix b. algorithms Algorithm A1 Algorithm for calculating distance between two probe requests
procedure DIST_BTWN_TWO_PROBE_REQ(PR_IE_data1, SSIDs1PR_IE_data2, SSIDs2)
distance← STARTING_DISTANCE
for each IE_key PR_IE_data1 and PR_IE_data2 have in common do if IE_key equal DATA_RTS then
merge Supported Data Rates and Extended Data Rates for both PRs increase distance for each data rate of symetric difference multiplied by IE’s specific scale
Algorithm A1 Cont. if IE_key equal HT_CAP Or VHT_CAP then distance← distance + number_o f _distinguishing_bitsnumber_o f _all_bits ∗ speci f ic_IE_scale
if IE_key equal EXT_CAP Or INTERWORKING then if length(probe_req_data1[IE_key] ! = length(probe_req_data2[IE_key] then
distance← distance + speci f ic_IE_value else
distance← distance + number_o f _distinguishing_bitsnumber_o f _all_bits ∗ speci f ic_IE_scale
if IE_key equal VENDOR_SPEC then distance← distance− special_IE_koe f increase distance for vendor ID of symetric difference
multiplied by IE’s specific scale decrease distance for each intersecting vendor ID multiplied by IE’s specific scale for each intersecting vendor ID do
decrease distance for each intersecting data ID multiplied by IE’s specific scale for each intersecting data ID do distance← distance + number_o f _distinguishing_bitsnumber_o f _all_bits ∗ speci f ic_IE_scale
if IE_key equal EXT_TAG then distance← distance− special_IE_koe f increase distance for each data ID of symetric difference
multiplied by IE’s specific scale decrease distance for each intersecting data ID multiplied by IE’s specific scale for each intersecting data ID do
distance← distance + number_o f _distinguishing_bitsnumber_o f _all_bits ∗ speci f ic_IE_scale decrease distance for intersecting SSID multiplied by IE’s specific scale
increase distance by number of IEs of symetric difference relative to number of intersecting IEs multiplied by specific scale tmp_dst← In f for each RSSI1, TOA1 in probe_req_data1 do
for each RSSI2, TOA2 in probe_req_data2 do dst_RSSI ← RSSI_KOEF|RSSI2−RSSI1| − 1 dst_TOA← 0 if |TOA2 − TOA1| < TIMING_THRESHOLD then
dst_TOA← TIMING_KOEF if (dst_RSSI + dst_TOA) < tmp_dst then
tmp_dst← dst_RSSI + dst_TOA distance← distance + tmp_dst
if distance < MINIMUM_DISTANCE then distance← MINIMUM_DISTANCE
return distance
Algorithm A2 Reachability distance-based clustering
procedure CLUSTERING(reach_dists, xi_up, xi_down, epsMax) in_cluster ← False labels[:]← −1 current_label ← 0 climbing← False f alling← False for i← 1 to length(reach_distss)− 1 do
if in_cluster then if reach_dists[i + 1] > reach_dists[i] then
if not climbing then climbing← True value_start_climbing← reach_dists[i] if reach_dists[i+1]value_start_climbing > xi_up Or reach_dists[i + 1] > epsMax then in_cluster ← False current_label ← current_label + 1 climbing← False else labels[i + 1]← current_label
else climbing← False labels[i + 1]← curr_label
else if reach_dists[i + 1] < reach_dists[i] then if not f alling then
value_start_ f alling← reach_dists[i] index_start_ f alling← i f alling← True
if reach_dists[i + 1] < epsMax And reach_dists[i+1]value_start_ f alling < xi_down then labels[index_start_ f alling− 1 : i + 1]← curr_label in_cluster ← True f alling← False
else f alling← False
i← i + 1 return labels
