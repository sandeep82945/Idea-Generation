{
    "abstractText": "We present a novel definition of an algorithm and its corresponding algorithm language called CoLweb. The merit of CoLweb[1] is that it makes algorithm design so versatile. That is, it forces us to a high-level, proof-carrying, distributed-style approach to algorithm design for both non-distributed computing and distributed one. We argue that this approach simplifies algorithm design. In addition, it unifies other approaches including recursive logical/functional algorithms, imperative algorithms, object-oriented imperative algorithms, neural-nets, interaction nets, proof-carrying code, etc. As an application, we refine Horn clause definitions into two kinds: blinduniverally-quantified (BUQ) ones and parallel-universally-quantified (PUQ) ones. BUQ definitions corresponds to the traditional ones such as those in Prolog where knowledgebase is not expanding and its proof procedure is based on the backward chaining. On the other hand, in PUQ definitions, knowledgebase is expanding and its proof procedure leads to forward chaining and automatic memoization.",
    "authors": [
        {
            "affiliations": [],
            "name": "Keehang Kwon"
        }
    ],
    "id": "SP:cc638dc04b0349c42fa0bb8a89cb288a87ab218a",
    "references": [
        {
            "authors": [
                "G. Japaridze"
            ],
            "title": "Introduction to computability logic",
            "venue": "Annals of Pure and Applied Logic, vol.123,",
            "year": 2003
        },
        {
            "authors": [
                "G. Japaridze"
            ],
            "title": "Sequential operators in computability logic",
            "venue": "Information and Computation,",
            "year": 2008
        },
        {
            "authors": [
                "D. Miller"
            ],
            "title": "A logical analysis of modules in logic programming",
            "venue": "Journal of Logic Programming, vol.6,",
            "year": 1989
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n30 4.\n01 53\n9v 1\n[ cs\n.A I]\n4 A\npr 2\n02 3\nImplementing Dynamic Programming in Computability Logic Web\nKeehang Kwon Dept. of Computer Engineering, DongA University\nkhkwon@dau.ac.kr\nWe present a novel definition of an algorithm and its corresponding algorithm language called CoLweb. The merit of CoLweb[1] is that it makes algorithm design so versatile. That is, it forces us to a high-level, proof-carrying, distributed-style approach to algorithm design for both non-distributed computing and distributed one. We argue that this approach simplifies algorithm design. In addition, it unifies other approaches including recursive logical/functional algorithms, imperative algorithms, object-oriented imperative algorithms, neural-nets, interaction nets, proof-carrying code, etc.\nAs an application, we refine Horn clause definitions into two kinds: blinduniverally-quantified (BUQ) ones and parallel-universally-quantified (PUQ) ones. BUQ definitions corresponds to the traditional ones such as those in Prolog where knowledgebase is not expanding and its proof procedure is based on the backward chaining. On the other hand, in PUQ definitions, knowledgebase is expanding and its proof procedure leads to forward chaining and automatic memoization."
        },
        {
            "heading": "1 CoLweb as a unifying framework",
            "text": "Computer science lacks a unifying computing model. It consists of diverse models such as pseudocode, petri-net, interaction net, web languages, etc. Computability-logic web (CoLweb) is a recent attempt to provide a unifying computing model for distributed computing with the following principle:\ncomputation as game playing\nIn particular, it integrates all the concepts widely used in AI as well as in everyday life \u2013 strategies, tactics, proofs, interactions, etc.\nIn this paper, we slightly extends CoLweb with class agents. A class agent is a cluster of agents in a compressed form. It is useful for applications such as dynamic programming.\nWe show that CoLweb, if scaled down, is also a candidate unifying model for a single, non-distributed computing. That is, it is an appealing alternative to pseudocode. This is not so surprising, because a block of memory\ncell within a single machine can be seen as an (local) agent. From this view, a machine with local memories can be seen as a multi-agent system where each agent shares a CPU."
        },
        {
            "heading": "2 Implementing Dynamic Programming",
            "text": "In the traditional logic programming approaches such as Prolog, their knowledgebase is not expanding and their underlying proof procedure is based on the backward chaining such as uniform proof. For example, a fib function is specified as:\nfib(0) = 1 fib(1) = 1 \u2200x, y, z[(fib(x, y) \u2227 fib(x+1, z)) \u2192 fib(x+2, y + z)].\nNote that the third definition \u2013 called blind-universally-quantified definition in [1] \u2013 is true independent of x. For example, to compute \u2294xfib(3, x), the machine simply returns 3 without expanding the BUQ-definiiton.\nHowever, this procedure discards lemmas which are generated as new instances of the existing knowledgebase. Often these lemmas are useful and discarding them often leads to clumsy code when it deals with dynamic programming.\nThere have been different approaches to this topic such as tabled logic programming. These approaches, however, lead to slow performance. In this paper, we introduce a novel approach which is based on PUQs. As we shall see from the semantics of \u2227, its proof mechanism is required to add lemmas to the program, rather than discards them. These lemmas play a role similar to automatic memoization.\nFor example, a fib relation is specified as:\nfib(0, 1) fib(1, 1) \u2227x, y, z [(fib(x, y) \u2227 fib(x+1, z) \u2192 fib(x+2, y + z)]\nNote that the third definition \u2013 which we call PUQ definition \u2013 is compressed and needs to be expanded during execution. For example, to compute fib(3, 3), our proof procedure adds the following:\nfib(0, 1) \u2227 fib(1, 1) \u2192 fib(2, 2)\nfib(1, 1) \u2227 fib(2, 2) \u2192 fib(3, 3).\nOne consequence of our approach is that it supports dynamic programming in a clean code."
        },
        {
            "heading": "3 CoLweb Algorithms",
            "text": "Although algorithm is one of the central subjects, there have been little common understandings of what an algorithm is. We believe the following definition is a simple yet quite compelling definition:\nAn algorithm for an agent d who can perform a task T , written as d = T , is defined recursively as follows:\nAlgorithm alg(d = T )\nStep 1: Identify a set of agents c1 = T1, . . . , cn = Tn such that they can collectively perform T .\nStep 2. Call recursively each of the following: alg(c1 = T1), . . . , alg(cn = Tn).\nNote that Step 2 is missing from the traditional definition of algorithms, i.e., algorithm as a sequence of instructions to perform a task. We view instructions something that are not fixed and Step 2 is added for manipulating the instructions. It turns out that Step 2 is the key idea which makes algorithm design so interesting, compared to the traditional definition. In other words, our approach corresponds to n-level-deep algorithms, while the traditional one to 1-level-deep.\nIn the above, c = T represents an agent c who can do task T . In the traditional developments of declarative algorithms, T is limited to simple tasks such as recursive functions or Horn clauses. Most complex tasks such as interactive ones are not permitted. In our algorithm design, however, interactive tasks are allowed.\nTo define the class of computable tasks, we need a specification language. An ideal language would support an optimal translation of the tasks. Computability logic(CoL)[1] is exactly what we need here."
        },
        {
            "heading": "4 Preliminaries",
            "text": "In this section a brief overview of CoL is given. There are two players: the machine \u22a4 and the environment \u22a5. There are two sorts of atoms: elementary atoms p, q, . . . to represent elementary games, and general atoms P , Q, . . . to represent any, notnecessarily-elementary, games.\nConstant elementary games \u22a4 is always a true proposition, and \u22a5 is always a false proposition.\nNegation \u00ac is a role-switch operation: For example, \u00ac(0 = 1) is true, while (0 = 1) is false.\nChoice operations The choice group of operations: \u2293, \u2294, \u2200 and \u2203 are defined below.\n\u2293xA(x) is the game where, in the initial position, only \u22a5 has a legal move which consists in choosing a value for x. After \u22a5 makes a move c \u2208 {0, 1, . . .}, the game continues as A(c). \u2200xA(x) is similar, only here the value of x is invisible. \u2294 and \u2203 are symmetric to \u2293 and \u2200, with the difference that now it is \u22a4 who makes an initial move.\nParallel operations Playing A1 \u2227 . . . \u2227 An means playing the n games concurrently. In order to win, \u22a4 needs to win in each of n games. Playing A1 \u2228 . . . \u2228 An also means playing the n games concurrently. In order to win, \u22a4 needs to win one of the games. To indicate that a given move is made in the ith component, the player should prefix it with the string \u201ci.\u201d. The operations \u2227|A means an infinite parallel game A \u2227 . . . \u2227A \u2227 . . .. To indicate that a given move is made in the i(i > 1)th component, we assume the player should first replicate A and then prefix it with the string \u201ci.\u201d.\nIn addition, we use the following notation:\n\u2227xnmA =def A(m/x) \u2227 . . . \u2227A(n/x).\nReduction A \u2192 B is defined by \u00acA\u2228B. Intuitively, A \u2192 B is the problem of reducing B (consequent) to A (antecedent)."
        },
        {
            "heading": "5 CoLweb",
            "text": "CoLweb is a multi-agent version of computability logic. It consists of a set of agent declarations. An example looks like the following form:\n\u03b11 = F1\n\u03b12 = F2\n\u03b13 = F \u03b11 3 \u2227 F \u03b11,\u03b12 4\n\u03b14 = \u03b1 \u03b11 2\n\u2227x \u03b1(x) = F (x)\nHere \u03b11 is an agent name and F1 is called the knowledge of \u03b11. Similarly for F2 is the knowledge of \u03b12.\nThe agent \u03b13 has F3 and F4 as its knowledge, provided that F3 is a logical consequence of \u03b11 and F4 a logical consequence of \u03b11, \u03b12 combined. If F3 is not logical consequence of \u03b11, the above will be converted to:\n\u03b13 = \u22a4 \u2227 F \u03b11,\u03b12 4 .\nIn \u03b14, \u03b12 is a macro call, meaning that\n\u03b14 = F \u03b11 2 .\nThe agent \u2227x\u03b1(x) = F (x) is a class agent which means the following:\n(\u03b1(1) = F (1)) \u2227 (\u03b1(2) = F (2)) \u2227 . . . \u2227 . . .\nAs an example, consider the following CoLweb:\n/m(0) = q\n\u2227x /m(x\u2032) = p \u2227 /m(x)\nGiven this definition, p\u2227 (p\u2227 (p\u2227 q))) can be represented simply as /m(0\u2032\u2032\u2032). We assume in the above that \u2032 is the number-successor function."
        },
        {
            "heading": "6 Example",
            "text": "Recursive algorithms focuses on designing algorithms with only one agent. On the contrary, in the multi-agent (or object-oriented) approach, there is no limit regarding the number of agents involved in developing an algorithm. Therefore, the main virtue of the multi-agent approach is that much more diverse algorithms are possible.\nTo support multi-agent programming, computability logic allows the introduction of a location/agent/object for knowledgebases. We called this computability logic web (CoLweb) in our previous works. For example, assume that fib(X,Y ) is stored at a location /a[X] and the rule\n\u2200y\u2200z(fib(X, y) \u2227 fib(X+1, z)) \u2192 fib(X+2, y+z)\nis stored at /b[X + 2]. Then fib can be rewritten as:\n\u2227x\u221e0 /b[x+2] = \u2200y\u2200z[(fib(x, y) \u2227 fib(x+1, z)) \u2192 fib(x+2, y+z)]\n/a[1] = fib(1, 1)\n/a[2] = fib(2, 1)\n\u2227x\u221e0 /a[x+2] = (\u2294yfib(x+ 2, y))/a[x],/a[x+1],b[x+2]\n/fib = \u2293n(\u2294yfib(n, y)/a[n])\n/query = \u2294yfib(4, y)/fib\nNow consider an expression /query. This expression tries to solve\u2294yfib(4, y) relative to /fib. It then executes fib by trying to solve \u2294yfib(4, y) relative to /a[4]. It eventually creates the following which is a form of memoization:\n/a[3] = fib(3, 2) /a[4] = fib(4, 3) \u2227x\u221e3 /a[x+2] = (\u2294yfib(x+ 2, y))/a[x],/a[x+1],b[x+2]\nSimilarly for the class agent /b. Note also that the above code is nothing but an object-oriented programming in a distilled form. That is, in objectoriented terms, /a[1], /a[2] are regular objects and /a[x+2], /b[x+2] are class objects."
        },
        {
            "heading": "7 Some Variation",
            "text": "The Fibonacci implementation in the previous section is quite complex and is hard to prove its correctness. We will present a simpler version.\n/b = \u2200x\u2200y\u2200z(fib(x, y) \u2227 fib(x+1, z)) \u2192 fib(x+2, y+z))\n/a[1] = fib(1, 1)\n/a[2] = fib(2, 1) \u2227x\u221e0 /a[x+2] = (\u2294y(fib(x+ 2, y))/a[x],/a[x+1],/b\n/fib = \u2293n((\u2294yfib(n, y))/a[n]) /query = (\u2294yfib(4, y))/fib\nThe above is somewhat different from the old version in that the agent b is not a class agent anymore. The agent eliminates \u2227 in favor of \u2200-quantifier. One consequence is that b is not expanding anymore. Now consider an expression /query. This expression tries to solve\u2294yfib(4, y) relative to /fib. It then executes fib by trying to solve \u2294yfib(4, y) relative to /a[4]. It eventually creates the following which is a form of memoization:\n/a[3] = fib(3, 2) /a[4] = fib(4, 3) \u2227x\u221e3 /a[x+2] = (\u2294y(fib(x+2, y))/a[x],/a[x+1],/b"
        },
        {
            "heading": "8 Algorithm Design via CoLweb",
            "text": "There are traditional approaches to algorithm design (for small-size problems) and software design (for big- size ones):\nalgorithm design = pseudocode, etc\nsoftware design = UML\nWe propose an alternative approach:\nalgorithm design = CoLweb\nsoftware design = CoLweb\nWe compare some approaches.\n1. CoLweb algorithms\n2. imperative algorithms\n3. object-oriented imperative algorithms\n4. logical/recursive algorithms\n(1) is a high-level, lemma-based approach to algorithm design and has the following features: (a) consists of a sequence of big steps (b) execution from bottom-up, (c) support parallelism, and (d) support proof-carrying codes. We consider this approach the best, leading to clean, versatile yet efficient codes.\nBoth (2),(3) are inferior versions of (1) and can be seen as a sequence of small steps, execution from top-down, support no correct and support no parallel codes. These leads to non-parallel, efficient yet messy and incorrect code.\n(4) is simply a high-level approach without any use of lemmas and can be seen as an empty sequence. We consider this the worst, leading to clean yet inefficient code."
        },
        {
            "heading": "9 Conclusion",
            "text": "Note that we introduce an interesting kind of agents called class agents. A class agent is a collection of agents in a compressed form.\nOur ultimate goal is to implement the computability logic web[1, 2] which is a promising approach to reaching general AI. New ideas in this paper will be useful for organizing agents and their knowledgebases in CoLweb.\nWe now discuss how the machine executes CoLweb. An important point is that it must first check the validity of CoLweb given by the programmer. This is not an easy task which may require new, sophisticated inductions. In this sense, it is a proof -carrying code."
        }
    ],
    "title": "Implementing Dynamic Programming in Computability Logic Web",
    "year": 2023
}