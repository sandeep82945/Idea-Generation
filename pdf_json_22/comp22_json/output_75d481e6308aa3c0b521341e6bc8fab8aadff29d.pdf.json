{
    "abstractText": "families of weighted tree languages In the 60\u2019s and 70\u2019s of the previous century, Ginsburg, Greibach, and Hopcroft proposed a unifying concept for the study of closure properties of sets of formal languages [GG67, GG69, GGH69, Gin75]. This is the concept of abstract family of languages (AFL). Roughly speaking, an AFL is a set of formal languages which is closed under intersection with regular languages, inverse homomorphisms, \u03b5-free homomorphisms, union, concatenation, and Kleene star. An AFL is full if it is closed under arbitrary homomorphisms. Of particular interest are principal AFL; an AFL is principal if it is generated from one formal language by using the mentioned closure properties. For instance, the sets of regular languages, context-free languages, stack languages, nested-stack languages, and recursively enumerable languages are full principal AFL [GG70, Sec. 2]. The importance of principal AFL shows up in one of the main theorems of AFL-theory [Gin75, Thm. 5.2.1]: a set L is a full principal AFL if and only if there exists a finitely encoded abstract family of acceptors (AFA) D such that L is set of all formal languages accepted by D. Roughly speaking, an acceptor D is a one-way nondeterministic finite-state automaton which uses an additional storage (indicated by the type D) such as, e.g. counter, pushdown, stack, or nested-stack. Thus, in other words, \u201ceach family of languages defined by a set of \u2019well-behaving\u2019 one-way nondeterministic acceptors of a same \u2019type\u2019 is a full principal AFL\u201d (cited from [ESvL80, p. 109]. In this chapter we define the concept of abstract family of weighted tree languages. It is inspired by the definitions of abstract family of languages [GG67, GG69, GG70, GGH69, Gin75], abstract family of formal power series [KS86], abstract family of fuzzy languages [Asv03] (also cf. [Wec78, Ch. 3]), abstract family of tree series [Kui99a, Thm. 3.5] and [\u00c9K03, Sect. 7], and sheaf of forests [BR94]. In the rest of this chapter, B denotes an arbitrary commutative and \u03c3-complete semiring. Thus, by Theorem 9.2.9, we have that Rec(\u03a3,B) = Reg(\u03a3,B), and, in particular, the closure results developed in Chapter 10 for Rec(\u03a3,B) also hold for Reg(\u03a3,B). In this chapter we follow the notions and definitions in [FV22b]. The main theorem is the following (cf. Theorem 15.4.5): for each n \u2208 N, the set Reg(n,B) of all (n,B)-weighted tree languages is the smallest principal abstract family of (n,B)-weighted tree languages. 15.1 The basic definitions For each n \u2208 N, an (n,B)-weighted tree language is a (\u03a3,B)-weighted tree language for some ranked alphabet \u03a3 with maxrk(\u03a3) \u2264 n.",
    "authors": [
        {
            "affiliations": [],
            "name": "Zolt\u00e1n F\u00fcl\u00f6p"
        },
        {
            "affiliations": [],
            "name": "Heiko Vogler"
        }
    ],
    "id": "SP:ba2c7e58bde15a06d0c2826813c9dd34c690262f",
    "references": [
        {
            "authors": [
                "A. Alexandrakis",
                "S. Bozapalidis"
            ],
            "title": "Weighted grammars and Kleene\u2019s theorem",
            "venue": "Inform. Process. Lett.,",
            "year": 1987
        },
        {
            "authors": [
                "A. Arnold",
                "M. Dauchet"
            ],
            "title": "Bi-transductions de for\u00eats",
            "venue": "3rd Int. Coll. Automata, Languages and Programming (ICALP",
            "year": 1976
        },
        {
            "authors": [
                "A. Arnold",
                "M. Dauchet"
            ],
            "title": "Morphismes et bimorphismes d\u2019arbres",
            "venue": "Theoret. Comput. Sci.,",
            "year": 1982
        },
        {
            "authors": [
                "C. Aiswarya",
                "P. Gastin"
            ],
            "title": "Weighted tiling systems for graphs: Evaluation complexity",
            "venue": "40th IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS 2020),",
            "year": 2020
        },
        {
            "authors": [
                "P.R.J. Asveld"
            ],
            "title": "A bibliography on fuzzy automata, grammars and languages",
            "venue": "Bulletin of the European Association for Theoretical Computer Science,",
            "year": 1996
        },
        {
            "authors": [
                "P.R.J. Asveld"
            ],
            "title": "Algebraic aspects of families of fuzzy languages",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2003
        },
        {
            "authors": [
                "S. Bozapalidis",
                "A. Alexandrakis"
            ],
            "title": "Repr\u00e9sentation matricielles de s\u00e9ries d\u2019arbre reconnaissables",
            "venue": "Informatique the\u0301orique et applications,",
            "year": 1989
        },
        {
            "authors": [
                "B.S. Baker"
            ],
            "title": "Composition of top-down and bottom-up tree transductions",
            "venue": "Inf. Control,",
            "year": 1979
        },
        {
            "authors": [
                "M. Bauderon",
                "B. Courcelle"
            ],
            "title": "Graph expressions and graph rewritings",
            "venue": "Math. Syst. Theory,",
            "year": 1987
        },
        {
            "authors": [
                "J. Bj\u00f6rklund",
                "F. Drewes",
                "N. Zechner"
            ],
            "title": "An efficient best-trees algorithm for weighted tree automata over the tropical semiring",
            "venue": "9th Int. Conf. on Language and Automata Theory and Applications (LATA 2015),",
            "year": 2015
        },
        {
            "authors": [
                "R. B\u011blohl\u00e1vek"
            ],
            "title": "Determinism and fuzzy automata",
            "venue": "Information Sciences,",
            "year": 2002
        },
        {
            "authors": [
                "J. Berstel"
            ],
            "title": "Transductions and Context-Free Languages",
            "venue": "Teubner Stuttgart,",
            "year": 1979
        },
        {
            "authors": [
                "M. B\u00fcchse",
                "A. Fischer"
            ],
            "title": "Deciding the twins property for weighted tree automata over extremal semifields",
            "venue": "In Workshop on Applications of Tree Automata Techniques in Natural Language Processing (ATANLP",
            "year": 2012
        },
        {
            "authors": [
                "B. Borchardt",
                "Z. F\u00fcl\u00f6p",
                "Z. Gazdag",
                "A. Maletti"
            ],
            "title": "Bounds for tree automata with polynomial costs",
            "venue": "J. Autom. Lang. Comb.,",
            "year": 2005
        },
        {
            "authors": [
                "S. Bozapalidis",
                "A. Grammatikopoulou"
            ],
            "title": "Recognizable picture series",
            "venue": "J. Autom. Lang. Comb.,",
            "year": 2005
        },
        {
            "authors": [
                "B. Bollig",
                "P. Gastin",
                "B. Monmege",
                "M. Zeitoun"
            ],
            "title": "Pebble weighted automata and transitive closure logics",
            "venue": "37th Int. Colloquium on Automata, Languages and Programming (ICALP 2010) \u2013 Part II,",
            "year": 2010
        },
        {
            "authors": [
                "B. Bollig",
                "P. Gastin",
                "B. Monmege",
                "M. Zeitoun"
            ],
            "title": "Pebble weighted automata and weighted logics",
            "venue": "ACM Transactions on Computational Logic,",
            "year": 2014
        },
        {
            "authors": [
                "G. Birkhoff"
            ],
            "title": "Lattice Theory, volume 25 of Colloquium Publications",
            "venue": "American Mathematical Society,",
            "year": 1967
        },
        {
            "authors": [
                "G. Birkhoff"
            ],
            "title": "Lattice Theory, volume 25 of Colloquium Publications",
            "venue": "American Mathematical Society,",
            "year": 1993
        },
        {
            "authors": [
                "S. Bozapalidis",
                "O. Louscou-Bozapalidou"
            ],
            "title": "The rank of a formal tree power series",
            "venue": "Theoret. Comput. Sci.,",
            "year": 1983
        },
        {
            "authors": [
                "S. Bozapalidis",
                "O. Louscou-Bozapalidou"
            ],
            "title": "Fuzzy tree language recognizability",
            "venue": "Fuzzy Sets and Systems,",
            "year": 2010
        },
        {
            "authors": [
                "A.J. Blikle"
            ],
            "title": "\u00da.T. M\u00e9dv\u00e9d\u00e9v. O klass\u00e9 sobytij, dopuska\u00fa\u0161ih pr\u00e9dstavl\u00e9ni\u00e9 v kon\u00e9\u010dnom avtomat\u00e9 (On a class of events representable in a finite automaton). Avtomaty, Izdat\u00e9l\u2019stvo Inostrannoj Lit\u00e9ratury",
            "venue": "Moscow",
            "year": 1956
        },
        {
            "authors": [
                "B. Balle",
                "M. Mohri"
            ],
            "title": "Learning weighted automata",
            "venue": "In A. Maletti, editor, 6th Int. Conf. on Algebraic Informatics (CAI 2015),",
            "year": 2015
        },
        {
            "authors": [
                "B. Borchardt",
                "A. Maletti",
                "B. \u0160e\u0161elja",
                "A. Tepav\u010devic",
                "H. Vogler"
            ],
            "title": "Cut sets as recognizable tree languages",
            "venue": "Fuzzy Sets and Systems,",
            "year": 2006
        },
        {
            "authors": [
                "F. Baader",
                "T. Nipkow"
            ],
            "title": "Term Rewriting and All That",
            "year": 1998
        },
        {
            "authors": [
                "B. Borchardt"
            ],
            "title": "A pumping lemma and decidability problems for recognizable tree series",
            "venue": "Acta Cybern.,",
            "year": 2004
        },
        {
            "authors": [
                "B. Borchardt"
            ],
            "title": "The Theory of Recognizable Tree Series",
            "venue": "Verlag fu\u0308r Wissenschaft und Forschung,",
            "year": 2005
        },
        {
            "authors": [
                "S. Bozapalidis"
            ],
            "title": "Effective construction of the syntactic algebra of a recognizable series on trees",
            "venue": "Acta Inform.,",
            "year": 1991
        },
        {
            "authors": [
                "S. Bozapalidis"
            ],
            "title": "Representable tree series",
            "venue": "Fundamenta Informaticae,",
            "year": 1994
        },
        {
            "authors": [
                "S. Bozapalidis"
            ],
            "title": "Equational elements in additive algebras",
            "venue": "Theory Comput. Syst.,",
            "year": 1999
        },
        {
            "authors": [
                "S. Borgwardt",
                "R. Pe\u00f1aloza"
            ],
            "title": "The Inclusion Problem for Weighted Automata on Infinite Trees",
            "venue": "13th Int. Conf. on Automata and Formal Languages (AFL",
            "year": 2011
        },
        {
            "authors": [
                "Y. Bar\u2013Hillel",
                "M. Perles",
                "E. Shamir"
            ],
            "title": "On Formal Properties of Simple Phrase Structure Grammars",
            "venue": "Z. Phonetik. Sprach. Komm.,",
            "year": 1961
        },
        {
            "authors": [
                "J. Berstel",
                "C. Reutenauer"
            ],
            "title": "Recognizable formal power series on",
            "venue": "trees. Theoret. Comput. Sci.,",
            "year": 1982
        },
        {
            "authors": [
                "J. Berstel",
                "Ch. Reutenauer"
            ],
            "title": "Rational Series and Their Languages, volume 12 of EATCS",
            "venue": "Monographs on Theoretical Computer Science. Springer-Verlag,",
            "year": 1988
        },
        {
            "authors": [
                "S. Bozapalidis",
                "G. Rahonis"
            ],
            "title": "On two families of forests",
            "venue": "Acta Inform.,",
            "year": 1994
        },
        {
            "authors": [
                "B. Balle",
                "G. Rabusseau"
            ],
            "title": "Approximation minimization of weighted tree automata",
            "venue": "Inf. Comput.,",
            "year": 2020
        },
        {
            "authors": [
                "W.S. Brainerd"
            ],
            "title": "Tree generating regular systems",
            "venue": "Inf. Control,",
            "year": 1969
        },
        {
            "authors": [
                "S. Burris",
                "H.P. Sankappanavar"
            ],
            "title": "A Course in Universal Algebra, volume 78 of Graduate Texts in Mathematics",
            "year": 1981
        },
        {
            "authors": [
                "J.R. B\u00fcchi"
            ],
            "title": "Weak second-order arithmetic and finite automata",
            "venue": "Zeitschr. f. math. Logik und Grundlagen der Math.,",
            "year": 1960
        },
        {
            "authors": [
                "M. B\u00fcchse"
            ],
            "title": "Algebraic decoder specification: coupling formal-language theory and statistical machine translation",
            "venue": "PhD thesis, Technische Universita\u0308t Dresden, Germany,",
            "year": 2014
        },
        {
            "authors": [
                "J.M. Buys"
            ],
            "title": "Probabilistic tree transducers for grammatical error correction",
            "venue": "Master thesis,",
            "year": 2013
        },
        {
            "authors": [
                "B. Borchardt",
                "H. Vogler"
            ],
            "title": "Determinization of finite state weighted tree automata",
            "venue": "J. Autom. Lang. Comb.,",
            "year": 2003
        },
        {
            "authors": [
                "M. B\u00fcchse",
                "H. Vogler",
                "J. May"
            ],
            "title": "Determinization of weighted tree automata using factorizations",
            "venue": "J. Autom. Lang. Comb.,",
            "year": 2010
        },
        {
            "authors": [
                "M. B\u00fcchse",
                "H. Vogler",
                "M. Nederhof"
            ],
            "title": "Tree parsing for tree-adjoining machine translation",
            "venue": "J. Logic and Comput.,",
            "year": 2014
        },
        {
            "authors": [
                "B.A. Carr\u00e9"
            ],
            "title": "An algebra for network routing problems",
            "venue": "IMA J. Applied Math.,",
            "year": 1971
        },
        {
            "authors": [
                "M. \u0106iri\u0107",
                "M. Droste",
                "J. Ignjatovi\u0107",
                "H. Vogler"
            ],
            "title": "Determinization of weighted finite automata over strong bimonoids",
            "venue": "Inform. Sci.,",
            "year": 2010
        },
        {
            "authors": [
                "B. Courcelle",
                "J. Engelfriet"
            ],
            "title": "Graph Structure and Monadic Second-Order Logic: A Language-Theoretic Approach, volume 138 of Encyclopedia of Mathematics and its Applications",
            "year": 2012
        },
        {
            "authors": [
                "T.H. Cormen",
                "C.E. Leiserson",
                "R.L. Rivest"
            ],
            "title": "Introduction to Algorithms",
            "year": 1990
        },
        {
            "authors": [
                "A. Chattopadhyay",
                "F. Mazowiecki",
                "A. Muscholl",
                "C. Riveros"
            ],
            "title": "Pumping lemmas for weighted automata, 2021",
            "year": 2001
        },
        {
            "authors": [
                "N. Chomsky",
                "M.P. Sch\u00fctzenberger"
            ],
            "title": "The algebraic theory of context-free languages",
            "venue": "Computer Programming and Formal Systems,",
            "year": 1963
        },
        {
            "authors": [
                "W. Damm"
            ],
            "title": "The IO- and OI-hierarchies",
            "venue": "Theoret. Comput. Sci.,",
            "year": 1982
        },
        {
            "authors": [
                "R. Dedekind"
            ],
            "title": "Was sind und was sollen die Zahlen? Friedr",
            "year": 1939
        },
        {
            "authors": [
                "M. Droste",
                "Z. \u00c9sik",
                "K. Larsen",
                "editors"
            ],
            "title": "Special issue on Quantitative Models and Weighted Automata. Springer, 2018",
            "venue": "Soft Computing,",
            "year": 2018
        },
        {
            "authors": [
                "T. Denkinger"
            ],
            "title": "zigzag is not bottom-up deterministically recognizable",
            "venue": "personal communications,",
            "year": 2017
        },
        {
            "authors": [
                "M. Droste",
                "Z. F\u00fcl\u00f6p",
                "D. G\u00f6tze"
            ],
            "title": "A Kleene theorem for weighted tree automata over tree valuation monoids",
            "venue": "Proceedings of Language Automata Theory and Applications (LATA 2016),",
            "year": 2016
        },
        {
            "authors": [
                "M. Droste",
                "Z. F\u00fcl\u00f6p",
                "D. K\u00f3sz\u00f3",
                "H. Vogler"
            ],
            "title": "Crisp-determinization of weighted tree automata over additively locally finite and past-finite monotonic strong bimonoids is decidable",
            "venue": "Descriptional Complexity of Formal Systems (DCFS 2020),",
            "year": 2020
        },
        {
            "authors": [
                "M. Droste",
                "Z. F\u00fcl\u00f6p",
                "D. K\u00f3sz\u00f3",
                "H. Vogler"
            ],
            "title": "Finite-image property of weighted tree automata over past-finite monotonic strong bimonoids",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2022
        },
        {
            "authors": [
                "F. D\u00f6rband",
                "Z. F\u00fcl\u00f6p",
                "H. Vogler"
            ],
            "title": "Rational weighted tree languages with storage",
            "venue": "Inf. Comput.,",
            "year": 2021
        },
        {
            "authors": [
                "W. Damm",
                "A. Goerdt"
            ],
            "title": "An automata-theoretical characterization of the OI-hierarchy",
            "venue": "Automata, Languages and Programming. ICALP 1982,",
            "year": 1982
        },
        {
            "authors": [
                "M. Droste",
                "P. Gastin"
            ],
            "title": "The Kleene-Sch\u00fctzenberger theorem for formal power series in partially commuting variables",
            "venue": "Inf. Comput.,",
            "year": 1999
        },
        {
            "authors": [
                "M. Droste",
                "P. Gastin"
            ],
            "title": "Weighted automata and weighted logics",
            "venue": "32nd Int. Colloquium Automata, Languages and Programming (ICALP 2005),",
            "year": 2005
        },
        {
            "authors": [
                "M. Droste",
                "P. Gastin"
            ],
            "title": "Weighted automata and weighted logics",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2007
        },
        {
            "authors": [
                "M. Droste",
                "P. Gastin"
            ],
            "title": "Weighted automata and weighted logics",
            "venue": "Handbook of Weighted Automata, Monographs in Theoretical Computer Science. An EATCS Series,",
            "year": 2009
        },
        {
            "authors": [
                "M. Droste",
                "D. G\u00f6tze",
                "S. M\u00e4rcker",
                "I. Meinecke"
            ],
            "title": "Weighted tree automata over valuation monoids and their characterization by weighted logics",
            "venue": "Algebraic Foundations in Computer Science,",
            "year": 2011
        },
        {
            "authors": [
                "F. Drewes",
                "K. Gebhardt",
                "H. Vogler"
            ],
            "title": "EM-training for weighted aligned hypergraph bimorphisms",
            "venue": "In Proceedings of the ACL Workshop on Statistical NLP and Weighted automata,",
            "year": 2016
        },
        {
            "authors": [
                "M. Droste",
                "D. Heusel"
            ],
            "title": "The supports of weighted unranked tree automata",
            "venue": "Fundam. Inform.,",
            "year": 2015
        },
        {
            "authors": [
                "F. Drewes",
                "J. H\u00f6gberg",
                "A. Maletti"
            ],
            "title": "MAT learners for tree series: an abstract data type and two realizations",
            "venue": "Acta Inform.,",
            "year": 2011
        },
        {
            "authors": [
                "M. Droste",
                "D. Heusel",
                "H. Vogler"
            ],
            "title": "Weighted unranked tree automata over tree valuation monoids and their characterization by weighted logics",
            "venue": "editor, 6th Int. Conf. on Algebraic Informatics (CAI 2015),",
            "year": 2015
        },
        {
            "authors": [
                "L.E. Dickson"
            ],
            "title": "Finiteness of the odd perfect and primitive abundant numbers with n distinct prime factors",
            "venue": "American Journal of Mathematics,",
            "year": 1913
        },
        {
            "authors": [
                "T. Dietze"
            ],
            "title": "A Formal View on Training of Weighted Tree Automata by Likelihood-Driven State Splitting and Merging",
            "venue": "PhD thesis,",
            "year": 2018
        },
        {
            "authors": [
                "M. Droste",
                "D. Kuske"
            ],
            "title": "Skew and infinitary formal power series",
            "venue": "In 13th Int. Colloquium on Automata, Languages and Programming (ICALP 2003),",
            "year": 2003
        },
        {
            "authors": [
                "M. Droste",
                "D. Kuske"
            ],
            "title": "Skew and infinitary formal power series",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2006
        },
        {
            "authors": [
                "M. Droste",
                "W. Kuich"
            ],
            "title": "Semirings and formal power series",
            "venue": "Handbook of Weighted Automata, Monographs in Theoretical Computer Science. An EATCS Series,",
            "year": 2009
        },
        {
            "authors": [
                "M. Droste",
                "I. Meinecke"
            ],
            "title": "Weighted automata and weighted MSO logics for average and long-time behaviors",
            "venue": "Inf. Comput.,",
            "year": 2012
        },
        {
            "authors": [
                "F. D\u00f6rband",
                "R. M\u00f6rbitz"
            ],
            "title": "Incomparability of classes for support",
            "venue": "theorems. personal communication,",
            "year": 2020
        },
        {
            "authors": [
                "J.E. Doner"
            ],
            "title": "Decidability of the weak second-order theory of two successors",
            "venue": "Notices Amer. Math. Soc.,",
            "year": 1965
        },
        {
            "authors": [
                "F. D\u00f6rband"
            ],
            "title": "A Kleene theorem for weighted forest automata",
            "year": 2019
        },
        {
            "authors": [
                "F. D\u00f6rband"
            ],
            "title": "Kleene and B\u00fcchi theorems for weighted forest languages over M-monoids",
            "venue": "Inf. Comput.,",
            "year": 2021
        },
        {
            "authors": [
                "F. D\u00f6rband"
            ],
            "title": "Characterisation Theorems for Weighted Tree Automaton Models",
            "venue": "PhD thesis, Technische Universita\u0308t Dresden,",
            "year": 2022
        },
        {
            "authors": [
                "B.A. Davey",
                "H.A. Priestley"
            ],
            "title": "Introduction to Lattices and Order",
            "year": 2012
        },
        {
            "authors": [
                "M. Droste",
                "Chr. Pech",
                "H. Vogler"
            ],
            "title": "A Kleene theorem for weighted tree automata",
            "venue": "Theory Comput. Syst.,",
            "year": 2005
        },
        {
            "authors": [
                "M. Droste",
                "G. Rahonis"
            ],
            "title": "Weighted automata and weighted logics with discounting",
            "venue": "In J. Holub and J. Z\u030cd\u030ca\u0301rek, editors, Implementation and Application of Automata (CIAA 2007),",
            "year": 2007
        },
        {
            "authors": [
                "F. Drewes"
            ],
            "title": "Grammatical Picture Generation: A Tree-Based Approach",
            "venue": "Texts in Theoretical Computer Science. An EATCS Series. Springer,",
            "year": 2006
        },
        {
            "authors": [
                "M. Droste"
            ],
            "title": "Weighted automata over monotonic strong bimonoids: Decidability and undecidability of finite image. Talk at the International Colloquium Recent Advances of Quantitative Models in Computer",
            "year": 2021
        },
        {
            "authors": [
                "F. D\u00f6rband",
                "K. Stier",
                "T. Feller"
            ],
            "title": "Sequentiality of group-weighted tree automata",
            "venue": "Int. Conf. on Language and Automata Theory and Applications (LATA 2021),",
            "year": 2021
        },
        {
            "authors": [
                "M. Droste",
                "T. St\u00fcber",
                "H. Vogler"
            ],
            "title": "Weighted finite automata over strong bimonoid",
            "venue": "Inform. Sci.,",
            "year": 2010
        },
        {
            "authors": [
                "M. Droste",
                "H. Vogler",
                "editors"
            ],
            "title": "Selected Papers of the Workshop \u201cWeighted Automata: Theory and Applications",
            "venue": "Dresden University of Technology (Germany), March 4-8,",
            "year": 2002
        },
        {
            "authors": [
                "M. Droste",
                "H. Vogler",
                "editors"
            ],
            "title": "Selected Papers of the Workshop \u201cWeighted Automata: Theory and Applications",
            "venue": "Dresden University of Technology (Germany),",
            "year": 2004
        },
        {
            "authors": [
                "M. Droste",
                "H. Vogler"
            ],
            "title": "Weighted tree automata and weighted logics",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2006
        },
        {
            "authors": [
                "F. Drewes",
                "H. Vogler"
            ],
            "title": "Learning deterministically recognizable tree series",
            "venue": "J. Autom. Lang. Comb.,",
            "year": 2007
        },
        {
            "authors": [
                "M. Droste",
                "H. Vogler",
                "editors"
            ],
            "title": "Selected Papers of the Workshop \u201cWeighted Automata: Theory and Applications",
            "venue": "University of Leipzig (Germany),",
            "year": 2006
        },
        {
            "authors": [
                "M. Droste",
                "H. Vogler",
                "editors"
            ],
            "title": "Selected Papers of the Workshop \u201cWeighted Automata: Theory and Applications",
            "venue": "Technische Universita\u0308t Dresden (Germany), May 13-16,",
            "year": 2008
        },
        {
            "authors": [
                "M. Droste",
                "H. Vogler"
            ],
            "title": "Kleene and B\u00fcchi theorems for weighted automata and multivalued logics over arbitrary bounded lattices",
            "venue": "Developments in Language Theory (DLT 2020),",
            "year": 2010
        },
        {
            "authors": [
                "M. Droste",
                "H. Vogler",
                "editors"
            ],
            "title": "Selected Papers of the Workshop \u201cWeighted Automata: Theory and Applications",
            "venue": "University of Leipzig (Germany), May 3 -",
            "year": 2010
        },
        {
            "authors": [
                "M. Droste",
                "H. Vogler"
            ],
            "title": "Weighted logics for unranked tree automata",
            "venue": "Theory of Computing Systems,",
            "year": 2011
        },
        {
            "authors": [
                "M. Droste",
                "H. Vogler"
            ],
            "title": "Weighted automata and multi-valued logics over arbitrary bounded lattices",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2012
        },
        {
            "authors": [
                "M. Droste",
                "H. Vogler"
            ],
            "title": "The Chomsky-Sch\u00fctzenberger theorem for quantitative contextfree languages",
            "venue": "Int. J. Found. Computer Science,",
            "year": 2014
        },
        {
            "authors": [
                "M. Droste",
                "H. Vogler",
                "editors"
            ],
            "title": "Selected Papers of the Workshop \u201cWeighted Automata: Theory and Applications",
            "venue": "WATA 2012, May 29 \u2013 June",
            "year": 2012
        },
        {
            "authors": [
                "J. Engelfriet",
                "Z. F\u00fcl\u00f6p",
                "H. Vogler"
            ],
            "title": "Bottom-up and top-down tree series transformations",
            "venue": "J. Autom. Lang. Comb.,",
            "year": 2002
        },
        {
            "authors": [
                "S. Eilenberg"
            ],
            "title": "Automata, Languages, and Machines \u2013 Volume A, volume 59 of Pure and Applied Mathematics",
            "year": 1974
        },
        {
            "authors": [
                "Z. \u00c9sik",
                "W. Kuich"
            ],
            "title": "Formal tree series",
            "venue": "J. Autom. Lang. Comb.,",
            "year": 2003
        },
        {
            "authors": [
                "Z. \u00c9sik",
                "G. Liu"
            ],
            "title": "Fuzzy tree automata",
            "venue": "Fuzzy Sets and Systems,",
            "year": 2007
        },
        {
            "authors": [
                "C.C. Elgot"
            ],
            "title": "Decision problems of finite automata design and related arithmetics",
            "venue": "Trans. Amer. Math. Soc.,",
            "year": 1961
        },
        {
            "authors": [
                "C.A. Ellis"
            ],
            "title": "Probabilistic tree automata",
            "venue": "Inform. and Control,",
            "year": 1971
        },
        {
            "authors": [
                "J. Engelfriet"
            ],
            "title": "Bottom-up and top-down tree transformations - a comparison",
            "venue": "Math. Systems Theory,",
            "year": 1975
        },
        {
            "authors": [
                "J. Engelfriet"
            ],
            "title": "Tree automata and tree grammars",
            "venue": "Technical Report DAIMI FN-10,",
            "year": 1975
        },
        {
            "authors": [
                "J. Engelfriet"
            ],
            "title": "Some open questions and recent results on tree transducers and tree languages",
            "venue": "In R.V. Book, editor, Formal Language Theory,",
            "year": 1980
        },
        {
            "authors": [
                "J. Engelfriet"
            ],
            "title": "Context\u2013free grammars with storage",
            "venue": "University of Leiden,",
            "year": 1986
        },
        {
            "authors": [
                "J. Engelfriet"
            ],
            "title": "Iterated stack automata and complexity classes",
            "venue": "Inform. Control,",
            "year": 1991
        },
        {
            "authors": [
                "J. Engelfriet"
            ],
            "title": "Alternative Kleene theorem for weighted automata",
            "venue": "personal communication,",
            "year": 2003
        },
        {
            "authors": [
                "J. Engelfriet",
                "E.M. Schmidt",
                "J. van Leeuwen"
            ],
            "title": "Stack machines and classes of nonnested macro languages",
            "venue": "J. Assoc. Comput. Machinery,",
            "year": 1980
        },
        {
            "authors": [
                "J. Engelfriet",
                "H. Vogler"
            ],
            "title": "Modular tree transducers",
            "venue": "Theoret. Comput. Sci.,",
            "year": 1991
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "Z. Gazdag"
            ],
            "title": "Weighted languages recognizable by weighted tree automata",
            "venue": "Acta Cybernetica,",
            "year": 2018
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "Z. Gazdag",
                "H. Vogler"
            ],
            "title": "Hierarchies of tree series transformations",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2004
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "L. Herrmann",
                "H. Vogler"
            ],
            "title": "Weighted regular tree grammars with storage",
            "venue": "Discrete Math. Theoret. Comput. Sci.,",
            "year": 2018
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "F. Herrmann",
                "S. V\u00e1gv\u00f6lgyi",
                "H. Vogler"
            ],
            "title": "Tree transducers with external functions",
            "venue": "Theoret. Comput. Sci.,",
            "year": 1993
        },
        {
            "authors": [
                "I. Fichtner"
            ],
            "title": "Weighted picture automata and weighted logics",
            "venue": "Theory Comput. Syst.,",
            "year": 2011
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "D. K\u00f3sz\u00f3",
                "H. Vogler"
            ],
            "title": "Crisp-determinization of weighted tree automata over strong bimonoids",
            "venue": "Discrete Math. Theoret. Comput. Sci.,",
            "year": 1912
        },
        {
            "authors": [
                "M. Fliess"
            ],
            "title": "Matrices de Hankel",
            "venue": "J. Math. Pures Appl.,",
            "year": 1974
        },
        {
            "authors": [
                "M. Fliess"
            ],
            "title": "S\u00e9ries rationelles positives et processus stochastiques",
            "venue": "Ann. Inst. H. Poincare\u0301 Set. B (N.S.),",
            "year": 1975
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "A. Maletti",
                "H. Vogler"
            ],
            "title": "A Kleene Theorem for Weighted Tree Automata over Distributive Multioperator Monoids",
            "venue": "Theory Comput. Syst.,",
            "year": 2009
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "A. Maletti",
                "H. Vogler"
            ],
            "title": "Preservation of recognizability for synchronous tree substitution grammars",
            "venue": "In Workshop on Applications of Tree Automata in Natural Language Processing,",
            "year": 2010
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "A. Maletti",
                "H. Vogler"
            ],
            "title": "Weighted Extended Tree Transducers",
            "venue": "Fundamenta Informaticae,",
            "year": 2011
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "M. Steinby"
            ],
            "title": "Varieties of recognizable tree series over fields",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2011
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "T. St\u00fcber",
                "H. Vogler"
            ],
            "title": "A B\u00fcchi-like theorem for weighted tree automata over multioperator monoids",
            "venue": "Theory Comput. Syst.,",
            "year": 2012
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p"
            ],
            "title": "Local weighted tree languages",
            "venue": "Acta Cybernetica,",
            "year": 2015
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "H. Vogler"
            ],
            "title": "Tree series transformations that respect copying",
            "venue": "Theory Comput. Syst.,",
            "year": 2003
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "H. Vogler"
            ],
            "title": "Weighted tree automata and tree transducers",
            "venue": "Handbook of Weighted Automata, Monographs in Theoretical Computer Science. An EATCS Series,",
            "year": 2009
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "H. Vogler"
            ],
            "title": "Characterizing weighted MSO for trees by branching transitive closure logics",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2015
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "H. Vogler"
            ],
            "title": "Characterizations of recognizable weighted tree languages by logic and bimorphisms",
            "venue": "Soft Computing,",
            "year": 2018
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "H. Vogler"
            ],
            "title": "Rational weighted tree languages with storage and the KleeneGoldstine theorem",
            "venue": "Int. Conf. on Algebraic Informatics (CAI 2019),",
            "year": 2019
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "H. Vogler"
            ],
            "title": "A comparison of sets of recognizable weighted tree languages over specific bounded lattices, 2022",
            "year": 2022
        },
        {
            "authors": [
                "Z. F\u00fcl\u00f6p",
                "H. Vogler"
            ],
            "title": "Principal abstract families of weighted tree languages",
            "venue": "Inf. Comput.,",
            "year": 2022
        },
        {
            "authors": [
                "J.H. Gallier"
            ],
            "title": "Logic for Computer Science: Foundations of Automatic Theorem Proving",
            "year": 1987
        },
        {
            "authors": [
                "J.H. Gallier"
            ],
            "title": "Logic for Computer Science: Foundations of Automatic Theorem Proving. copyright J.H",
            "year": 2003
        },
        {
            "authors": [
                "N. Galatos"
            ],
            "title": "Residuated lattices. Tutorial at \u201dSummer School on General Algebra and Ordered Sets",
            "year": 2008
        },
        {
            "authors": [
                "D. G\u00f6tze",
                "Z. F\u00fcl\u00f6p",
                "M. Droste"
            ],
            "title": "A Kleene theorem for weighted tree automata over tree valuation monoids",
            "venue": "Inf. Comput.,",
            "year": 1044
        },
        {
            "authors": [
                "S. Ginsburg",
                "S.A. Greibach"
            ],
            "title": "Abstract families of languages",
            "venue": "In 8th Annual Symposium on Switching and Automata Theory (SWAT 1967),",
            "year": 1967
        },
        {
            "authors": [
                "S. Ginsburg",
                "S.A. Greibach"
            ],
            "title": "Abstract families of languages",
            "venue": "Studies in Abstract Families of Languages,",
            "year": 1969
        },
        {
            "authors": [
                "S. Ginsburg",
                "S. Greibach",
                "J. Hopcroft"
            ],
            "title": "Studies in Abstract Families of Languages",
            "venue": "Number 87. American Mathematical Society,",
            "year": 1969
        },
        {
            "authors": [
                "M. Galley",
                "M. Hopkins",
                "K. Knight",
                "D. Marcu"
            ],
            "title": "What\u2019s in a translation rule",
            "venue": "Proc. HLT-NAACL",
            "year": 2004
        },
        {
            "authors": [
                "M. Ghorani"
            ],
            "title": "Tree automata on complete residuated lattice-valued logic: reduction algorithms and decision problems",
            "venue": "Iranian Journal of Fuzzy Systems,",
            "year": 2018
        },
        {
            "authors": [
                "M. Ghorani"
            ],
            "title": "Characterization of tree automata based on quantum logic",
            "venue": "Int. J. of Theoretical Physics,",
            "year": 2022
        },
        {
            "authors": [
                "S. Ginsburg"
            ],
            "title": "Algebraic and automata-theoretic properties of formal languages, volume 2 of Fundamental studies in computer science",
            "year": 1975
        },
        {
            "authors": [
                "J. Graehl",
                "K. Knight"
            ],
            "title": "Training tree transducers",
            "venue": "In Proc. Human Language Technologies and North American ACL,",
            "year": 2004
        },
        {
            "authors": [
                "J. Graehl",
                "K. Knight",
                "J. May"
            ],
            "title": "Training tree transducers",
            "venue": "Computational Linguistics,",
            "year": 2008
        },
        {
            "authors": [
                "P. Gastin",
                "B. Monmege"
            ],
            "title": "A unifying survey on weighted logics and weighted automata",
            "venue": "Soft Computing,",
            "year": 2018
        },
        {
            "authors": [
                "J.S. Golan"
            ],
            "title": "Semirings and their Applications",
            "venue": "Kluwer Academic Publishers, Dordrecht,",
            "year": 1999
        },
        {
            "authors": [
                "D. G\u00f6tze"
            ],
            "title": "Weighted Unranked Tree Automata over Tree Valuation Monoids",
            "venue": "PhD thesis, University of Leipzig,",
            "year": 2017
        },
        {
            "authors": [
                "S. Greibach"
            ],
            "title": "Full AFLs and nested iterated substitution",
            "venue": "Inform. Control,",
            "year": 1970
        },
        {
            "authors": [
                "J.A. Goguen",
                "J.W. Thatcher",
                "E.G. Wagner",
                "J.B. Wright"
            ],
            "title": "Initial algebra semantics and continuous algebras",
            "venue": "J. Assoc. Comput. Machinery,",
            "year": 1977
        },
        {
            "authors": [
                "M. Ghorani",
                "H. Vogler"
            ],
            "title": "A theorem on supports of weighted tree automata over strong bimonoids",
            "venue": "New Mathematics and Natural Computation,",
            "year": 2022
        },
        {
            "authors": [
                "M. Ghorani",
                "M.M. Zahedi"
            ],
            "title": "Characterizations of complete residuated lattice-valued finite tree automata",
            "venue": "Fuzzy Sets and Systems,",
            "year": 2012
        },
        {
            "authors": [
                "M. Ghorani",
                "M.M. Zahedi"
            ],
            "title": "Alternating regular tree grammars in the framework of lattice-valued logic",
            "venue": "Iranian Journal of Fuzzy Systems,",
            "year": 2016
        },
        {
            "authors": [
                "M. Ghorani",
                "M.M. Zahedi"
            ],
            "title": "Coding tree languages based on lattice-valued logic",
            "venue": "Soft Computing,",
            "year": 2017
        },
        {
            "authors": [
                "M. Ghorani",
                "M.M. Zahedi",
                "R. Ameri"
            ],
            "title": "Algebraic properties of complete residuated lattice valued tree automata",
            "venue": "Soft Computing,",
            "year": 2012
        },
        {
            "authors": [
                "M.A. Harrison"
            ],
            "title": "Introduction to Formal Language Theory",
            "venue": "Addison Wesley,",
            "year": 1978
        },
        {
            "authors": [
                "L. Herrmann"
            ],
            "title": "A Medvedev characterization of recognizable tree series",
            "venue": "In 21th Int. Conf. on Developments in Language Theory (DLT 2017),",
            "year": 2017
        },
        {
            "authors": [
                "L. Herrmann"
            ],
            "title": "Weighted Tree Automata with Storage",
            "venue": "PhD thesis, Technische Universita\u0308t Dresden,",
            "year": 2020
        },
        {
            "authors": [
                "A. Habel",
                "H.-J. Kreowski"
            ],
            "title": "Some structural aspects of hypergraph languages generated by hyperedge replacement",
            "venue": "Annual Symposium on Theoretical Aspects of Computer Science (STACS 1987),",
            "year": 1987
        },
        {
            "authors": [
                "J. H\u00f6gberg",
                "A. Maletti",
                "J. May"
            ],
            "title": "Bisimulation minimisation for weighted tree automata",
            "venue": "11th Int. Conf. Developments in Language Theory (DLT 2007),",
            "year": 2007
        },
        {
            "authors": [
                "T. Hanneforth",
                "A. Maletti",
                "D. Quernheim"
            ],
            "title": "Pushing for weighted tree automata",
            "venue": "Log. Methods Comput. Sci.,",
            "year": 2018
        },
        {
            "authors": [
                "J.E. Hopcroft",
                "R. Motawi",
                "J.D. Ullman"
            ],
            "title": "Introduction to Automata Theory, Languages, and Computation",
            "year": 2007
        },
        {
            "authors": [
                "J.E. Hopcroft",
                "R. Motwani",
                "J.D. Ullman"
            ],
            "title": "Introduction to Automata Theory, Languages, and Computation",
            "venue": "Pearson Education Limited,",
            "year": 2014
        },
        {
            "authors": [
                "J. H\u00f6gberg",
                "A. Maletti",
                "H. Vogler"
            ],
            "title": "Bisimulation minimisation of weighted automata on unranked",
            "venue": "Fundam. Inform.,",
            "year": 2009
        },
        {
            "authors": [
                "J. H\u00f6gberg"
            ],
            "title": "Contributions to the Theory and Applications of Tree Languages",
            "venue": "PhD thesis, Ume\u030aa University,",
            "year": 2007
        },
        {
            "authors": [
                "J.E. Hopcroft",
                "J.D. Ullman"
            ],
            "title": "Introduction to automata theory, languages, and computation",
            "year": 1979
        },
        {
            "authors": [
                "U. Hupbach"
            ],
            "title": "Rekursive Funktionen in mehrsortigen Peano-Algebren",
            "venue": "Elektron. Informationsverarb. Kybern.,",
            "year": 1978
        },
        {
            "authors": [
                "L. Herrmann",
                "H. Vogler"
            ],
            "title": "A Chomsky-Sch\u00fctzenberger theorem for weighted automata with storage",
            "venue": "6th Int. Conf. on Algebraic Informatics (CAI 2015),",
            "year": 2015
        },
        {
            "authors": [
                "L. Herrmann",
                "H. Vogler",
                "M. Droste"
            ],
            "title": "Weighted automata with storage",
            "venue": "Inf. Comput.,",
            "year": 1044
        },
        {
            "authors": [
                "U. Hebisch",
                "H.J. Weinert"
            ],
            "title": "Semirings - Algebraic Theory and Applications in Computer Science",
            "venue": "World Scientific,",
            "year": 1993
        },
        {
            "authors": [
                "Y. Inagaki",
                "T. Fukumura"
            ],
            "title": "On the description of fuzzy meaning of context-free languages",
            "venue": "Fuzzy Sets and Their Applications to Cognitive and Decision Processes,",
            "year": 1975
        },
        {
            "authors": [
                "T. Jech"
            ],
            "title": "Set Theory, The Third Millennium Edition, revised and expanded",
            "year": 2003
        },
        {
            "authors": [
                "A. Je\u017c",
                "A. Maletti"
            ],
            "title": "Hyper-minimization for deterministic tree automata",
            "venue": "Int. J. Found. Comput. Sci.,",
            "year": 2013
        },
        {
            "authors": [
                "A. Jonsson"
            ],
            "title": "Best Trees Extraction and Contextual Grammars for Language Processing",
            "venue": "PhD thesis, Ume\u030aa University,",
            "year": 2021
        },
        {
            "authors": [
                "K. Knight",
                "J. Graehl"
            ],
            "title": "An overview of probabilistic tree transducers for natural language processing",
            "venue": "Int. Conf. on Intelligent Text Processing and Computational Linguistics (CICLing 2005),",
            "year": 2005
        },
        {
            "authors": [
                "D. Kirsten"
            ],
            "title": "The support of a recognizable series over a zero-sum free, commutative semiring is recognizable",
            "venue": "9th Int. Conf. on Developments in Language Theory (DLT),",
            "year": 2009
        },
        {
            "authors": [
                "D. Kirsten"
            ],
            "title": "The support of a recognizable series over a zero-sum free, commutative semiring is recognizable",
            "venue": "Acta Cybern.,",
            "year": 2011
        },
        {
            "authors": [
                "D. Kirsten"
            ],
            "title": "An algebraic characterization of semirings for which the support of every recognizable series is recognizable",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2014
        },
        {
            "authors": [
                "H. Klaeren"
            ],
            "title": "A constructive method for abstract algebraic software",
            "venue": "specification. Theoret. Comput. Sci.,",
            "year": 1984
        },
        {
            "authors": [
                "S.E. Kleene"
            ],
            "title": "Representation of events in nerve nets and finite automata",
            "venue": "Automata Studies,",
            "year": 1956
        },
        {
            "authors": [
                "S.E. Kleene"
            ],
            "title": "Introduction to Meta Mathematics",
            "year": 1962
        },
        {
            "authors": [
                "I. Klimann",
                "S. Lombardy",
                "J. Mairesse",
                "C. Prieur"
            ],
            "title": "Deciding unambiguity and sequentiality from a finitely ambiguous max-plus automaton",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2004
        },
        {
            "authors": [
                "D. Kirsten",
                "I. M\u00e4urer"
            ],
            "title": "On the determinization of weighted automata",
            "venue": "J. Autom. Lang. Comb.,",
            "year": 2005
        },
        {
            "authors": [
                "K. Knight",
                "J. May"
            ],
            "title": "Applications of weighted automata in natural language processing",
            "venue": "Handbook of Weighted Automata, Monographs in Theoretical Computer Science. An EATCS Series,",
            "year": 2009
        },
        {
            "authors": [
                "D. K\u00f3sz\u00f3"
            ],
            "title": "Tree generating context-free grammars and regular tree grammars are equivalent",
            "venue": "Annales Mathematicae et Informaticae,",
            "year": 2022
        },
        {
            "authors": [
                "D. Kozen"
            ],
            "title": "On the Myhill-Nerode theorem for trees",
            "venue": "Bull. Eur. Assoc. Theoret. Comput. Sci. EATCS,",
            "year": 1992
        },
        {
            "authors": [
                "M. Kreuzer",
                "L. Robbiano"
            ],
            "title": "Computational Commutative Algebra 1",
            "year": 2008
        },
        {
            "authors": [
                "K.V. Krishna"
            ],
            "title": "Near-Semirings: Theory and Applications",
            "venue": "PhD thesis, IIT Delhi,",
            "year": 2005
        },
        {
            "authors": [
                "W. Kuich",
                "A. Salomaa"
            ],
            "title": "Semirings, Automata, Languages, volume 5 of EATCS",
            "venue": "Monographs on Theoretical Computer Science EATCS Ser. Springer-Verlag,",
            "year": 1986
        },
        {
            "authors": [
                "W. Kuich"
            ],
            "title": "Semirings and formal power series: Their relevance to formal languages and automata",
            "venue": "Handbook of Formal Languages,",
            "year": 1997
        },
        {
            "authors": [
                "W. Kuich"
            ],
            "title": "Formal Power Series over Trees",
            "venue": "3rd Int. Conf. Developments in Language Theory (DLT",
            "year": 1997
        },
        {
            "authors": [
                "W. Kuich"
            ],
            "title": "Full abstract families of tree series I",
            "venue": "Jewels are forever,",
            "year": 1999
        },
        {
            "authors": [
                "W. Kuich"
            ],
            "title": "Linear systems of equations and automata on distributive multioperator monoids",
            "venue": "Proceedings of the 58th Workshop on General Algebra \u201c58",
            "year": 1999
        },
        {
            "authors": [
                "W. Kuich"
            ],
            "title": "Tree transducers and formal tree series",
            "venue": "Acta Cybernet.,",
            "year": 1999
        },
        {
            "authors": [
                "G.J. Klir",
                "B. Yuan"
            ],
            "title": "Fuzzy Sets and Fuzzy Logic, Theory and Application",
            "year": 1995
        },
        {
            "authors": [
                "Y. Li"
            ],
            "title": "Approximation and robustness of fuzzy finite automata",
            "venue": "International Journal of Approximate Reasoning,",
            "year": 2008
        },
        {
            "authors": [
                "Y. Li"
            ],
            "title": "Fuzzy finite automata and fuzzy monadic second-order logic",
            "venue": "IEEE International Conference on Fuzzy Systems (IEEE World Congress on Computational Intelligence),",
            "year": 2008
        },
        {
            "authors": [
                "P. Linz"
            ],
            "title": "An Introduction to Formal Languages and Automata",
            "venue": "Jones & Bartlett Publishers,",
            "year": 2012
        },
        {
            "authors": [
                "J. Lassez",
                "V. Nguyen",
                "L. Sonenberg"
            ],
            "title": "Fixed point theorems and semantics: a folk tale",
            "venue": "Inf. Proc. Letters,",
            "year": 1982
        },
        {
            "authors": [
                "L.H. Loomis"
            ],
            "title": "On the representation of \u03c3-complete",
            "venue": "Boolean algebras. Bull. Amer. Math. Soc.,",
            "year": 1947
        },
        {
            "authors": [
                "Y. Li",
                "W. Pedrycz"
            ],
            "title": "Fuzzy finite automata and fuzzy regular expressions with membership values in lattice-ordered monoids",
            "venue": "Fuzzy Sets and Systems,",
            "year": 2005
        },
        {
            "authors": [
                "K. Lehmann",
                "R. Pe\u00f1aloza"
            ],
            "title": "The complexity of computing the behaviour of lattice automata on infinite trees",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2014
        },
        {
            "authors": [
                "C. L\u00f6ding",
                "W. Thomas"
            ],
            "title": "Automata on finite trees",
            "venue": "Handbook of Automata Theory,",
            "year": 2021
        },
        {
            "authors": [
                "B. Mahr"
            ],
            "title": "A birds eye view to path problems",
            "venue": "Graphtheoretic Concepts in Computer Science. WG 1980,",
            "year": 1981
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "Relating tree series transducers and weighted tree automata",
            "venue": "Int. Conf. Developments in Language Theory (DLT 2004),",
            "year": 2004
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "The power of tree series transducers of type i and ii",
            "venue": "Int. Conf. Developments in Language Theory (DLT 2005),",
            "year": 2005
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "Relating tree series transducers and weighted tree automata",
            "venue": "Internat. J. Found. Comput. Sci.,",
            "year": 2005
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "Compositions of tree series transformations",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2006
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "Hierarchies of tree series transformations revisited",
            "venue": "10th Int. Conf. Developments in Language Theory (DLT 2006),",
            "year": 2006
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "The Power of Tree Series Transducers",
            "venue": "PhD thesis, Technische Universita\u0308t Dresden,",
            "year": 2006
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "Learning deterministically recognizable tree series \u2013 revisited",
            "venue": "2nd Int. Conf. Algebraic Informatics (CAI 2007),",
            "year": 2007
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "Myhill Nerode theorem for recognizable tree series \u2014 revisited",
            "venue": "8th Int. Conf. Latin American Theoretical Informatics (LATIN 2008),",
            "year": 2008
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "Minimizing deterministic weighted tree automata",
            "venue": "Inf. Comput.,",
            "year": 2009
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "Survey: Weighted extended top-down tree transducers \u2014 part I: Basics and expressive power",
            "venue": "Acta Cybernet.,",
            "year": 2011
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "Survey: Weighted Extended Top-Down Tree Transducers \u2014 part II: Application in machine translation",
            "venue": "Fundam. Inform.,",
            "year": 2011
        },
        {
            "authors": [
                "A. Maletti",
                "editor"
            ],
            "title": "4th Int. Workshop on Trends in Tree Automata and Tree Transducers (TTATT 2016",
            "venue": "July 18,",
            "year": 2016
        },
        {
            "authors": [
                "A. Maletti"
            ],
            "title": "Survey: Finite-state technology in natural language processing",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2017
        },
        {
            "authors": [
                "A.N. Maslov"
            ],
            "title": "Multilevel stack automata",
            "venue": "Problems Inform. Transmission,",
            "year": 1976
        },
        {
            "authors": [
                "C. Mathissen"
            ],
            "title": "Weighted logics for nested words and algebraic formal power series",
            "venue": "Int. Colloquium on Automata, Languages, and Programming (ICALP 2008),",
            "year": 2008
        },
        {
            "authors": [
                "C. Mathissen"
            ],
            "title": "Weighted Automata and Weighted Logics over Tree-like Structures",
            "venue": "PhD thesis, University of Leipzig,",
            "year": 2009
        },
        {
            "authors": [
                "C. Mathissen"
            ],
            "title": "Weighted logics for nested words and algebraic formal power series",
            "venue": "Logical Methods Comput. Sci.,",
            "year": 2010
        },
        {
            "authors": [
                "I. M\u00e4urer"
            ],
            "title": "Rational and recognizable picture series",
            "venue": "In Conf. on Algebraic Informatics (CAI 2005), Thessaloniki,",
            "year": 2005
        },
        {
            "authors": [
                "I. M\u00e4urer"
            ],
            "title": "Characterizations of recognizable picture series",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2007
        },
        {
            "authors": [
                "J.D.L. May"
            ],
            "title": "Weighted tree automata and transducers for syntactic natural language processing",
            "venue": "PhD thesis, University of Southern California,",
            "year": 2010
        },
        {
            "authors": [
                "I. Meinecke"
            ],
            "title": "Weighted logics for traces",
            "venue": "1st Int. Computer Science Conf. on Theory and Applications (CSR 2006),",
            "year": 2006
        },
        {
            "authors": [
                "M. Magidor",
                "G. Moran"
            ],
            "title": "Probabilistic tree automata and context free languages",
            "venue": "Israel Journal of Mathematics,",
            "year": 1970
        },
        {
            "authors": [
                "J.N. Mordeson",
                "D.S. Malik"
            ],
            "title": "Fuzzy Automata and Languages: Theory and Applications",
            "year": 2002
        },
        {
            "authors": [
                "M. Mohri"
            ],
            "title": "Finite-state transducers in language and speech processing",
            "venue": "Computational Linguistics,",
            "year": 1997
        },
        {
            "authors": [
                "M. Mohri"
            ],
            "title": "Minimization algorithms for sequential transducers",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2000
        },
        {
            "authors": [
                "A. Maletti",
                "D. Quernheim"
            ],
            "title": "Optimal hyper-minimization",
            "venue": "Int. J. Found. Comput. Sci.,",
            "year": 2011
        },
        {
            "authors": [
                "A. Maletti",
                "D. Quernheim"
            ],
            "title": "Unweighted and weighted hyper-minimization",
            "venue": "Int. J. Found. Comput. Sci.,",
            "year": 2012
        },
        {
            "authors": [
                "A. Maletti",
                "D. Quernheim"
            ],
            "title": "Hyper-minimization for deterministic weighted tree automata",
            "venue": "14th Int. Conf. on Automata and Formal Languages, (AFL 2014),",
            "year": 2014
        },
        {
            "authors": [
                "F. Mazowiecki",
                "C. Riveros"
            ],
            "title": "Pumping lemmas for weighted automata",
            "venue": "35th Symposium on Theoretical Aspects of Computer Science (STACS 2018),",
            "year": 2018
        },
        {
            "authors": [
                "A. Maletti",
                "G. Satta"
            ],
            "title": "Parsing algorithms based on tree automata",
            "venue": "In Proceedings of the 11th Int. Conf. on Parsing Technologies (IWPT",
            "year": 2009
        },
        {
            "authors": [
                "A. Maletti",
                "G. Satta"
            ],
            "title": "Parsing and translation algorithms based on weighted extended tree transducers",
            "venue": "1st Workshop Applications of Tree Automata in Natural Language Processing (ATANLP",
            "year": 2010
        },
        {
            "authors": [
                "A. Maletti",
                "H. Vogler"
            ],
            "title": "Incomparability results for classes of polynomial tree series transformations",
            "venue": "J. Autom. Lang. Comb.,",
            "year": 2005
        },
        {
            "authors": [
                "R. M\u00f6rbitz",
                "H. Vogler"
            ],
            "title": "Weighted parsing for grammar-based language models",
            "venue": "Proc. 14th Int. Conf. on Finite-State Methods and Natural Language Processing (FSMNLP",
            "year": 2019
        },
        {
            "authors": [
                "R. M\u00f6rbitz",
                "H. Vogler"
            ],
            "title": "Weighted parsing for grammar-based language models over multioperator monoids, 2019",
            "year": 1911
        },
        {
            "authors": [
                "R. M\u00f6rbitz",
                "H. Vogler"
            ],
            "title": "Weighted parsing for grammar-based language models over multioperator monoids",
            "venue": "Inf. Comput.,",
            "year": 2021
        },
        {
            "authors": [
                "J. Mezei",
                "J.B. Wright"
            ],
            "title": "Algebraic automata and context-free sets",
            "venue": "Inf. Control,",
            "year": 1967
        },
        {
            "authors": [
                "H.G. Moore",
                "A. Yaqub"
            ],
            "title": "A first course in linear algebra with applications",
            "year": 1998
        },
        {
            "authors": [
                "S. Moghari",
                "M.M. Zahedi",
                "R. Ameri"
            ],
            "title": "New direction in fuzzy tree automata",
            "venue": "Iranian J. Fuzzy Systems,",
            "year": 2011
        },
        {
            "authors": [
                "M. Nivat"
            ],
            "title": "Transduction des langages de Chomsky",
            "venue": "Ann. de l\u2019Inst. Fourier,",
            "year": 1968
        },
        {
            "authors": [
                "E. Paul"
            ],
            "title": "Expressiveness and Decidability of Weighted Automata and Weighted Logics",
            "venue": "PhD thesis, University of Leipzig,",
            "year": 2020
        },
        {
            "authors": [
                "R. P\u00e9ter"
            ],
            "title": "Rekursive Funktionen",
            "venue": "Akade\u0301miai Kiado\u0301, Budapest,",
            "year": 1957
        },
        {
            "authors": [
                "F. Pereira",
                "M. Riley",
                "R. Sproat"
            ],
            "title": "Weighted rational transductions and their application to human language processing",
            "venue": "In Human Language Technology: Proceedings of a Workshop held at Plainsboro, New Jersey,",
            "year": 1994
        },
        {
            "authors": [
                "K. Quaas"
            ],
            "title": "Weighted timed MSO logics",
            "venue": "editors, Int. Conf. on Developments in Language Theory (DLT 2009),",
            "year": 2009
        },
        {
            "authors": [
                "D. Radovanovi\u0107"
            ],
            "title": "Weighted tree automata over strong bimonoids",
            "venue": "Novi Sad J. Math.,",
            "year": 2010
        },
        {
            "authors": [
                "G. Rahonis"
            ],
            "title": "Weighted Muller tree automata and weighted logics",
            "venue": "J. Autom. Lang. Comb.,",
            "year": 2007
        },
        {
            "authors": [
                "Ch. Reutenauer"
            ],
            "title": "An Odgen-like iteration lemma for rational power series",
            "venue": "Acta Inform.,",
            "year": 1980
        },
        {
            "authors": [
                "H.L. Rolf"
            ],
            "title": "The free lattice generated by a set of chains",
            "venue": "Pacific J. Math.,",
            "year": 1958
        },
        {
            "authors": [
                "G. Rote"
            ],
            "title": "Path problems in graphs",
            "venue": "Computational Graph Theory. Computing Supplementum,",
            "year": 1990
        },
        {
            "authors": [
                "G. Rahonis",
                "F. Torpari"
            ],
            "title": "Weighted context-free grammars over bimonoids",
            "venue": "Scientific Annals of Computer Science,",
            "year": 2019
        },
        {
            "authors": [
                "I. Rival",
                "R. Wille"
            ],
            "title": "Lattices freely generated by partially ordered sets: which can be \u201ddrawn",
            "venue": "Journal fu\u0308r die reine und angewandte Mathematik,",
            "year": 2009
        },
        {
            "authors": [
                "J. Sakarovitch"
            ],
            "title": "Elements of Automata Theory",
            "year": 2009
        },
        {
            "authors": [
                "M.P. Sch\u00fctzenberger"
            ],
            "title": "On the definition of a family of automata",
            "venue": "Inf. Control,",
            "year": 1961
        },
        {
            "authors": [
                "U. Sch\u00f6ning"
            ],
            "title": "Logic for Computer Scientists",
            "venue": "Birkha\u0308user,",
            "year": 1989
        },
        {
            "authors": [
                "H. Seidl"
            ],
            "title": "On the finite degree of ambiguity of finite tree automata",
            "venue": "Acta Informatica,",
            "year": 1989
        },
        {
            "authors": [
                "H. Seidl"
            ],
            "title": "Deciding equivalence of finite tree automata",
            "venue": "SIAM J. Comput.,",
            "year": 1990
        },
        {
            "authors": [
                "H. Seidl"
            ],
            "title": "Finite tree automata with cost functions",
            "venue": "Theoret. Comput. Sci.,",
            "year": 1994
        },
        {
            "authors": [
                "E. Shamir"
            ],
            "title": "A representation theorem for algebraic and context-free power series in noncommuting variables",
            "venue": "Information and Control,",
            "year": 1967
        },
        {
            "authors": [
                "H. Seidl",
                "S. Maneth",
                "G. Kemper"
            ],
            "title": "Equivalence of deterministic top-down tree-to-string transducers is decidable",
            "venue": "J. Assoc. Comput. Machinery,",
            "year": 2018
        },
        {
            "authors": [
                "A. Salomaa",
                "M. Soittola"
            ],
            "title": "Automata-Theoretic Aspects of Formal Power Series",
            "venue": "Texts and Monographs in Computer Science, Springer-Verlag,",
            "year": 1978
        },
        {
            "authors": [
                "Howard Straubing"
            ],
            "title": "Finite Automata, Formal Logic, and Circuit",
            "venue": "Complexity. Birkha\u0308user,",
            "year": 1994
        },
        {
            "authors": [
                "L. Strassburger"
            ],
            "title": "A Kleene theorem for forest languages",
            "venue": "3rd Int. Conf. on Language and Automata Theory and Applications (LATA 2009),",
            "year": 2009
        },
        {
            "authors": [
                "B. Seselja",
                "A. Tepav\u010devic",
                "H. Vogler"
            ],
            "title": "A note on cut-worthyness of recognizable tree series",
            "venue": "Fuzzy Sets and Systems,",
            "year": 2008
        },
        {
            "authors": [
                "T. St\u00fcber",
                "H. Vogler",
                "Z. F\u00fcl\u00f6p"
            ],
            "title": "Decomposition of weighted multioperator tree automata",
            "venue": "Int. J. Foundations of Computer Sci.,",
            "year": 2009
        },
        {
            "authors": [
                "A. Tarski"
            ],
            "title": "A lattice-theoretical fixpoint theorem and its applications",
            "venue": "Pacific J. Math.,",
            "year": 1955
        },
        {
            "authors": [
                "M. Teichmann"
            ],
            "title": "Expressing Context-Free Tree Languages by Regular Tree Grammars",
            "venue": "PhD thesis, Technische Universia\u0308t Dresden,",
            "year": 2016
        },
        {
            "authors": [
                "J.W. Thatcher"
            ],
            "title": "Characterizing derivation trees of context-free grammars through a generalization of finite automata theory",
            "venue": "J. Comput. Syst. Sci.,",
            "year": 1967
        },
        {
            "authors": [
                "M. Teichmann",
                "J. Osterholzer"
            ],
            "title": "A link between multioperator and tree valuation automata and logics",
            "venue": "Theoret. Comput. Sci.,",
            "year": 2015
        },
        {
            "authors": [
                "B.A. Trakhtenbrot"
            ],
            "title": "Finite automata and logic of monadic predicates",
            "venue": "Doklady Akademii Nauk SSSR,",
            "year": 1961
        },
        {
            "authors": [
                "J.W. Thatcher",
                "J.B. Wright"
            ],
            "title": "Generalized finite automata theory with an application to a decision problem of second-order logic",
            "venue": "Math. Syst. Theory,",
            "year": 1968
        },
        {
            "authors": [
                "H. Vogler",
                "M. Droste",
                "L. Herrmann"
            ],
            "title": "A weighted MSO logic with storage behaviour and its B\u00fcchi-Elgot-Trakhtenbrot theorem",
            "venue": "Language and Automata Theory and Applications (LATA",
            "year": 2016
        },
        {
            "authors": [
                "F.W. von Henke",
                "K. Indermark",
                "G. Rose",
                "K. Weihrauch"
            ],
            "title": "On primitive recursive wordfunctions",
            "venue": "Computing, 15:217\u2013234,",
            "year": 1975
        },
        {
            "authors": [
                "W.G. van Hoorn",
                "B. van Rootselaar"
            ],
            "title": "Fundamental notions in the theory of seminearrings",
            "venue": "Compositio Math.,",
            "year": 1967
        },
        {
            "authors": [
                "M. Wand"
            ],
            "title": "An algebraic formulation of the chomsky-hierarchy",
            "venue": "In Proc. First International Symp. on Category Theory, pages 209\u2013213. Mathematics Department and the Department of Computer and Information Science,",
            "year": 1974
        },
        {
            "authors": [
                "H. Wang"
            ],
            "title": "On characters of semirings",
            "venue": "Houston Journal of Mathematics,",
            "year": 1997
        },
        {
            "authors": [
                "H. Wang"
            ],
            "title": "On rational series and rational languages",
            "venue": "Theoret. Comput. Sci.,",
            "year": 1998
        },
        {
            "authors": [
                "S. Warshall"
            ],
            "title": "A theorem on Boolean matrices",
            "venue": "J. Assoc. Comput. Machinery,",
            "year": 1962
        },
        {
            "authors": [
                "W. Wechler"
            ],
            "title": "The Concept of Fuzziness in Automata and Language Theory. Studien zur Algebra und ihre Anwendungen",
            "venue": "Akademie-Verlag Berlin,",
            "year": 1978
        },
        {
            "authors": [
                "W. Wechler"
            ],
            "title": "Universal Algebra for Computer Scientists, volume 25 of EATCS",
            "venue": "Monographs on Theoretical Computer Science. Springer-Verlag, Heidelberg/Berlin, first edition,",
            "year": 1992
        },
        {
            "authors": [
                "T. Weidner"
            ],
            "title": "Probabilistic regular expressions and MSO logic on finite trees",
            "venue": "IARCS Annual Conf. on Foundations of Software Technology and Theoretical Computer Science (FSTTCS 2015),",
            "year": 2015
        },
        {
            "authors": [
                "G. Winskel"
            ],
            "title": "The Formal Semantics of Programming Languages. Foundations of Computing Series",
            "year": 1993
        },
        {
            "authors": [
                "K. Yamada",
                "K. Knight"
            ],
            "title": "A decoder for syntax-based statistical MT",
            "venue": "In Proceedings of the 40th Annual Meeting on Association for Computational Linguistics,",
            "year": 2002
        },
        {
            "authors": [
                "U. Zimmermann"
            ],
            "title": "Linear and Combinatorial Optimization in Ordered Algebraic Structures, volume 10 of Annals of Discrete Mathematics",
            "year": 1981
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n21 2.\n05 52\n9v 1\n[ cs\n.F L\n] 1\n1 D\nec 2\n02 2\nWeighted Tree Automata\nMay it be a little more?\nZolta\u0301n Fu\u0308lo\u0308p University of Szeged\nHungary\nHeiko Vogler Technische Universita\u0308t Dresden\nGermany\nDecember 13, 2022\nA:\n\u03b1 p \u03c3\n\u03c3\u03c3\np\u2032\n1 0 1\n0.5\n1.5\ndet(f,g)(A):\n\u03b1 ( 0 \u221e ) \u03c3\n\u03c3\n\u03c3\n( 0.5 0 ) \u03c3\n1 0 0.5\n1\n1\n0.5 1.5\n(push\u03bb(det(f,g)(A)))/R:\n\u03b1 { ( 0 \u221e ) , ( 0.5 0 ) } \u03c3\n1\n0\n1\npush\u03bb(det(f,g)(A)):\n\u03b1 ( 0 \u221e ) \u03c3\n\u03c3\n\u03c3\n( 0.5 0 ) \u03c3\n1 0 1\n1\n1\n0 1\ndet(f,g)\npush\u03bb\n(.)/R\nDedicated to the memory of Magnus Steinby (1941-2021)\nPreface\nWeighted automata form a quantitative extension of the traditional automaton model which is fundamental for Computer Science. They can be viewed as classical nondeterministic finite automata in which the transitions are equipped with weights. These weights could model, for instance, the cost, reward or probability of executing the transition. Already in 1961, Marcel Schu\u0308tzenberger investigated weighted automata and described their behaviors on finite words as rational formal power series. This extended Kleene\u2019s fundamental theorem on the coincidence of the classes of regular and rational formal languages into a quantitative setting. Subsequently, several decidability problems concerning context-free languages could be solved using weighted automata techniques, and up to now no other proof methods are known for this. This developed into a flourishing field, as described in books by Samuel Eilenberg (1974), Arto Salomaa and Matti Soittola (1978), Wolfgang Wechler (1978), Werner Kuich and Arto Salomaa (1986), Jean Berstel and Christophe Reutenauer (1988), Jacques Sakarovitch (2009) and the \u201cHandbook of Weighted Automata\u201d (2009).\nOften, the weights employed for weighted automata are taken from a field like the rational numbers, the real numbers or the complex numbers, respectively, with their usual operations. However, we might also consider just the natural numbers which, with their usual operations of addition and multiplication, form the classical example of a semiring. Moreover, in many important applications calculations of the weights combine the operations maximum and addition, or minimum and addition, where the distributivity of the second operation over the first again yields a semiring as weight structure. The weights of the transitions can very conveniently be described as a single matrix (for each letter); the weight at entry (i, j) is the weight of the transition from state i to j. Since in semirings multiplication is distributive over addition, matrix multiplication is associative. This enables us to use techniques from algebra to express and analyse the behavior of weighted automata over semirings, and this was one of the reasons for the success of the weighted automaton model. All classical automata can be recast as weighted automata by taking the Boolean semiring {0, 1} as weight structure.\nWith the turn of the century, further quantitative models began to be investigated as weight structure. For instance, we might be interested in average weights, or in discounting of weights. In semiring-weighted automata, the weight of runs is computed by employing the second operation of the semiring, whereas the weights of the (in case of non-deterministic automata, often several) runs are combined into a single weight by using the semiring\u2019s first operation. The required distributivity of the second operation over the first is quite a strong mathematical assumption. What happens without this assumption? Such \u2019semirings without requiring distributivity\u2019 were called strong bimonoids. For instance, in lattices, which arise in multi-valued logic, both operations supremum and infimum are associative but in general not distributive over each other, and large parts of lattice theory in Mathematics concern non-distributive lattices. There are many further possibilities how strong bimonoids may arise. Since for strong bimonoids matrix multiplication is in general not associative, it follows that for weighted automata, techniques from linear algebra can no longer be used. However, fortunately, direct automata constructions can very often still be used to obtain results which previously were derived only for semirings.\nIn Computer Science, a most important data structure arising, e.g., in programming analysis and from pushdown automata and context-free languages, is given by trees. Therefore, a large part of automata theory concerns automata over trees. Already early on, much research concerned extensions of results\n5\nfrom weighted automata over words to weighted tree automata, which becomes often more intricate. Moreover, weighted tree automata have found very interesting recent applications in natural language processing. In view of the above, much research has recently been devoted to weighted tree automata with strong bimonoids as weight structure.\nThe present book, written by two leading researchers of this area, is the first book on weighted tree automata. It presents large parts of the theory of weighted tree automata over strong bimonoids and semirings in a systematic way. As indicated above, for weighted automata over strong bimonoids two kinds of defining the behavior arise:\n\u2022 an automata-theoretic oriented approach using runs of the automaton and calculating their weights, and \u2022 a universal algebra oriented method similar to the algebraic method mentioned above for words, but adjusted to trees.\nIn contrast to words, trees with tree concatenation do not form a monoid; this is the reason why the algebraic method mentioned above for weighted automata on words now for weighted tree automata has been replaced by a universal algebra approach. Over semirings, the two semantics for weighted tree automata can be shown to coincide, but over strong bimonoids in general they differ. Consequently, general structure results for the possible behaviors of weighted tree automata may have two versions, using the run semantics respectively the initial algebra semantics.\nThe authors show a number of these structure results. These include, among others, descriptions of the behaviors of weighted tree automata by rational expressions, by weighted context-free or regular grammars, by weighted versions of monadic second order logic, by closure results under various operations, and as abstract families of weighted tree languages, as well as weighted versions of classical pumping lemmas and of determinization results. This shows that many structure results for weighted tree automata can also be derived in the case of strong bimonoids. The authors give full mathematical proofs, which are needed as weighted tree automata often have combinatorial intricacies which are easy to overlook. The reader will appreciate that the authors include numerous examples explaining the various aspects of definitions and differences in the results, often illustrating them with pictures.\nThe field of weighted automata over strong bimonoids is still developing. This systematic presentation of large parts of recent research is therefore very valuable and right in time. I am sure that this book will stimulate much further research in this exciting area.\nLeipzig, December 2022 Manfred Droste\nContents"
        },
        {
            "heading": "1 Introduction 1",
            "text": ""
        },
        {
            "heading": "2 Preliminaries 11",
            "text": "2.1 Numbers and sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2.2 Strings and languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2.3 Binary relations and mappings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n2.4 Hasse diagram, Venn diagram, and Euler diagram . . . . . . . . . . . . . . . . . . . . . . 13\n2.5 Well-founded induction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n2.6 Algebraic structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n2.7 Matrices and vectors over a strong bimonoid . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.8 Semimodules and vector spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n2.9 Trees and tree languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n2.10 Weighted tree languages and transformations . . . . . . . . . . . . . . . . . . . . . . . . . 49\n2.11 Finite-state string automata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\n2.12 Context-free grammars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\n2.13 Finite-state tree automata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\n2.14 Recognizable step mappings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57\n2.15 Fta-hypergraphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58"
        },
        {
            "heading": "3 The model of weighted tree automata 61",
            "text": "3.1 Basic definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.3 Weighted string automata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\n3.4 Weighted tree automata over the Boolean semiring . . . . . . . . . . . . . . . . . . . . . . 93\n3.5 Weighted tree automata over the semiring of natural numbers . . . . . . . . . . . . . . . . 95\n3.6 Weighted tree automata over commutative semirings . . . . . . . . . . . . . . . . . . . . . 97\n3.7 Extension of the weight algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102"
        },
        {
            "heading": "4 Basic properties of wta 103",
            "text": "4.1 Properties of arbitrary wta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.2 Properties of bu deterministic wta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104\n4.3 Properties of crisp deterministic wta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106\n7"
        },
        {
            "heading": "5 Comparison of the two semantics 111",
            "text": "5.1 Complexity of calculating the semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111\n5.2 Negative results for equality of the two semantics . . . . . . . . . . . . . . . . . . . . . . . 113\n5.3 Positive results for equality of the two semantics . . . . . . . . . . . . . . . . . . . . . . . 117"
        },
        {
            "heading": "6 Pumping lemmas 123",
            "text": "6.1 Pumping lemma for runs and wta over strong bimonoids . . . . . . . . . . . . . . . . . . . 124\n6.2 Pumping lemma for wta over fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129"
        },
        {
            "heading": "7 Normal forms of wta 139",
            "text": "7.1 Trimming a wta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\n7.2 Transforming wta into total wta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145\n7.3 Normalizing root weights of wta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146\n7.4 Normalizing transition weights of wta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150"
        },
        {
            "heading": "8 Weighted context-free grammars 153",
            "text": "8.1 The grammar model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153\n8.2 Normal forms of wcfg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156\n8.3 Yields of recognizable weighted tree languages . . . . . . . . . . . . . . . . . . . . . . . . . 168"
        },
        {
            "heading": "9 Weighted regular tree grammars 173",
            "text": "9.1 The grammar model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\n9.2 Normal forms of wrtg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176"
        },
        {
            "heading": "10 Closure properties 181",
            "text": "10.1 Closure under sum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181\n10.2 Closure under scalar multiplications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183\n10.3 Characterization of recognizable step mappings . . . . . . . . . . . . . . . . . . . . . . . . 187\n10.4 Closure under Hadamard product . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189\n10.5 Closure under top-concatenations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n10.6 Closure under tree concatenations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197\n10.7 Closure under Kleene-stars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201\n10.8 Closure under yield-intersection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207\n10.9 Closure under strong bimonoid homomorphisms . . . . . . . . . . . . . . . . . . . . . . . . 213\n10.10 Closure under tree relabelings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215\n10.11 Closure under linear and nondeleting tree homomorphisms . . . . . . . . . . . . . . . . . 217\n10.12 Closure under inverse of linear tree homomorphisms . . . . . . . . . . . . . . . . . . . . . 219\n10.13 Closure under weighted projective bimorphisms . . . . . . . . . . . . . . . . . . . . . . . 223\n10.14 Summary of some of the closure properties . . . . . . . . . . . . . . . . . . . . . . . . . . 240"
        },
        {
            "heading": "11 Characterizations by weighted local systems 243",
            "text": "11.1 Local tree languages and weighted local systems . . . . . . . . . . . . . . . . . . . . . . . 243\n11.2 Characterization by weighted local systems . . . . . . . . . . . . . . . . . . . . . . . . . . 246\n11.3 Characterization by local systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249"
        },
        {
            "heading": "12 Rational operations and Kleene\u2019s theorem 253",
            "text": "12.1 Rational weighted tree languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253\n12.2 From recognizable to rational . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255\n12.3 From rational to recognizable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261\n12.4 Alternative definition of rational weighted tree languages . . . . . . . . . . . . . . . . . . . 261"
        },
        {
            "heading": "13 Elementary operations and Me\u0301dve\u0301dje\u0301v\u2019s theorem 267",
            "text": "13.1 Representable weighted tree languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n13.2 From recognizable to restricted representable . . . . . . . . . . . . . . . . . . . . . . . . . 272\n13.3 From restricted representable to recognizable . . . . . . . . . . . . . . . . . . . . . . . . . 273"
        },
        {
            "heading": "14 Weighted MSO-logic and B-E-T\u2019s theorem 277",
            "text": "14.1 Monadic second-order logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279\n14.2 Adding weights . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286\n14.3 The main result . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293\n14.4 Adding weighted conjunction and universal quantification . . . . . . . . . . . . . . . . . . 299\n14.5 Relationship between decompositions and B-E-T\u2019s theorem . . . . . . . . . . . . . . . . . 316"
        },
        {
            "heading": "15 Abstract families of weighted tree languages 321",
            "text": "15.1 The basic definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n15.2 Characterization of tree cones . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322\n15.3 Reg(n,B) is an AFwtL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325\n15.4 The AFwtL Reg(n,B) is principal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325"
        },
        {
            "heading": "16 Crisp determinization 327",
            "text": "16.1 Initial algebra crisp determinization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n16.2 Run crisp determinization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330"
        },
        {
            "heading": "17 Determinization of wta over semirings 343",
            "text": "17.1 Applying the subset method to wta over arbitrary semirings . . . . . . . . . . . . . . . . . 344\n17.2 Negative results for determinization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345\n17.3 Positive result for determinization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347"
        },
        {
            "heading": "18 Support of recognizable weighted tree languages 367",
            "text": "18.1 Negative result for support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n18.2 Positive results for support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367"
        },
        {
            "heading": "19 Corollaries and theorems for wta over bounded lattices 381",
            "text": "19.1 Definition of wta over bounded lattices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381\n19.2 Crisp determinization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 382\n19.3 Relationship between several sets of recognizable wtl . . . . . . . . . . . . . . . . . . . . . 384\n19.4 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 386\n19.5 Closure results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 386\n19.6 Characterization by rational operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 387\n19.7 Characterization by elementary operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 387\n19.8 Characterization by weighted MSO-logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . 388\n19.9 Abstract families of weighted tree languages . . . . . . . . . . . . . . . . . . . . . . . . . . 391\nBibliography 393\nIndex 411\nChapter 1\nIntroduction\nThe purpose of this book is to present the basic definitions and some of the important results for weighted tree automata in a mathematically rigorous and coherent form with full proofs. The concept of weighted tree automata is part of Automata Theory and it touches the area of Universal Algebra. It originated from two sources: weighted string automata and finite-state tree automata.\nHistorical perspective. Weighted string automata were introduced in [Sch61]; here we recall briefly [Sch61, Def. 1\u2019]. Roughly speaking, a weighted string automaton A is a finite-state automaton in which each transition has a weight, which is an element of the set Z of integers. Together with summation and multiplication, Z forms the weight algebra of A. For each input symbol a, the weights of the transitions are represented as a Q\u00d7Q-matrix over Z where Q is the finite set of states of A. Due to distributivity of multiplication over summation, the set of Q\u00d7Q-matrices over Z together with matrix multiplication and the unit matrix forms a monoid. Thus, the representation can be extended to a monoid homomorphism from the free monoid over the set of input symbols to the monoid of Q\u00d7Q-matrices over Z. Finally, for a given input string w, its matrix representation is multiplied from the left by an initial weight vector and from the right by a final weight vector; the result is the weight of w computed by A. In this way, A assigns to each input string a weight in Z; this assignment is called the formal power series recognized by A or weighted language recognized by A.1. We might say that this weighted language is the monoid semantics of A. Although in [Sch61] mostly the semiring of natural numbers, the ring of integers, or commutative rings were considered, the idea of [Sch61] was general enough to deal with weighted string automata over arbitrary semirings (cf. [Wec78, p. 58]).\nSince 1961, weighted string automata and the set of recognizable weighted languages were studied intensively. Different kinds of semantics were investigated (run semantics, free monoid semantics, initial algebra semantics) and various classes of weight algebras were used (e.g., bounded lattices, fields, semirings, pairs of t-conorm and t-norm, valuation monoids, strong bimonoids). We note that, neither in bounded lattices nor in valuation monoids or strong bimonoids or pairs of t-conorm and t-norm, the multiplication has to be distributive over the summation.\nThe development of weighted string automata is witnessed by the following list of books and survey papers: [Eil74, SS78, Wec78, KS86, BR88, Kui97, MM02, Sak09, DKV09, DK21]. The state-of-the-art of this area was also cultivated and extended by the biennial workshops \u201cWeighted Automata: Theory and Applications\u201d (WATA) since 2002 (cf. [DV03, DV05, DV07b, DV09, DV11a, DV14b, DE\u0301L18, DMV22]).\nFinite-state tree automata were invented independently by [Don65, Don70] and [TW68]. A finite-state tree automaton processes a given input tree over some ranked alphabet \u03a3 also by means of transitions. Now a transition on a k-ary input symbol \u03c3 has not only one but k starting states (one for the root of each of the k subtrees below \u03c3), and it has one ending state (at the node which is labeled by \u03c3). Viewed as a\n1Since we will not deal with convergence questions, we prefer the latter notion.\n1"
        },
        {
            "heading": "2 CHAPTER 1. INTRODUCTION",
            "text": "bottom-up device2, a finite-state tree automaton A over an input ranked alphabet \u03a3 can be considered as a finite \u03a3-algebra, as it is known from Universal Algebra. Additionally, A identifies the set of final states as a subset of the carrier set of that \u03a3-algebra. Then A recognizes the set of all \u03a3-trees which are interpreted in the corresponding \u03a3-algebra as some final state. We might say that this tree language is the initial algebra semantics of A.\nAlso the concept of finite-state tree automata and the set of recognizable tree languages were investigated intensively. Here is a list of books, lecture notes, and survey papers on finite-state tree automata: [Eng75b, Eng80, GS84, GS97, CDG+07, LT21]. Some more developments on tree automata and tree transducers were published in the series \u201cInternational Workshop on Trends in Tree Automata and Tree Transducers\u201d [Man13, Fil15, Mal16].\nIt is natural to combine the concepts of weighted string automata and finite-state tree automata, resulting in the concept of weighted tree automata (wta). In [IF75] wta were introduced with the weight algebra being the real number interval [0, 1] in which summation is max and multiplication is min; such wta were called fuzzy tree automata. In [BR82], a wta is a finite-dimensional vector space V over some field B equipped with a \u03a3-algebra. Roughly speaking, each dimension corresponds to a state and each k-ary input symbol is interpreted in the \u03a3-algebra as a k-ary multilinear operation over V. In the following years, wta over different weight algebras were introduced: wta over semirings [AB87], wta over distributive multioperator monoids [Kui98], wta over multioperator monoids [FMV09, SVF09], wta over pairs of t-conorm and t-norm on the unit interval [0, 1] [BLB10], wta over strong bimonoids [Rad10], and wta over tree valuation monoids [DGMM11].\nHere we list some of the seminal papers and survey papers on wta: [IF75, BR82, AB87, Kui98, Kui99b, Boz99, E\u0301K03, E\u0301L07, FV09, DGMM11]. We also mention some recent PhD theses: [Bor05, Ho\u0308g07, Mat09, May10, Tei16, Go\u0308t17, Her20b, Pau20, Jon21, Do\u0308r22].\nWeighted tree automata over strong bimonoids. In this book we will investigate wta over strong bimonoids. In this paragraph we provide an overview on this automaton model. A strong bimonoid is an algebra B = (B,\u2295,\u2297, 0, 1) such that\n\u2022 (B,\u2295, 0) is a commutative monoid (and \u2295 is called the summation), \u2022 (B,\u2297, 1) is a monoid (and \u2297 is called the multiplication), and \u2022 0 is annihilating with respect to \u2297, i.e., b\u2297 0 = 0\u2297 b = 0 for each b \u2208 B.\nFor instance, each semiring (and thus each ring, semifield, and field) is a strong bimonoid; also each bounded lattice (and thus each complete lattice and residuated lattice) is a strong bimonoid; we note that a large part of the field of lattice theory confers to non-distributive lattices [Bir93, Gra\u030803]. The algebra (N\u221e,+,min, 0,\u221e) is a strong bimonoid, but it is not a semiring, because, e.g., min(a, a+ a) 6= min(a, a) + min(a, a) for each a \u2208 N \\ {0}, and hence the multiplication (here: min) does not distribute over the summation (here: +). Further examples of non-distributive strong bimonoids are the finite lattices N5 and M3 (cf. Figure 2.3) and the infinite bounded lattice FL(2 + 2) (cf. Figure 2.4).\nA wta over \u03a3 and B, for short: (\u03a3,B)-wta, is a tuple A = (Q, \u03b4, F ) which is almost like a finite-state tree automaton, i.e., Q is a finite set of states, \u03b4 = (\u03b4k | k \u2208 N) is a family of transition mappings, and F : Q \u2192 B is the root weight mapping. However, now each transition and each final state carries a weight, which is taken from B. More precisely, for each k \u2208 N, the mapping \u03b4k has the type\n\u03b4k : Q k \u00d7 \u03a3(k) \u00d7Q\u2192 B\nand it maps each transition (q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) with starting states q1, . . . , qk, a k-ary input symbol \u03c3, and ending state q to a weight, i.e., an element of B. Since \u03a3 is finite, only finitely many \u03b4k are different from the empty mapping. Finally, the mapping F : Q \u2192 B maps each state to an element of B; this is used as root weight (or final weight).\n2We draw a tree with its root up and the leaves down, hence bottom-up means: from the leaves towards the root.\n3 We can define two semantics of A: the run semantics [[A]]run and the initial algebra semantics [[A]]init\nwhere each of them is a weighted tree language; more precisely,\n[[A]]run : T\u03a3 \u2192 B and [[A]] init : T\u03a3 \u2192 B\nwhere T\u03a3 is the set of all \u03a3-trees.\nThe run semantics is based on the idea of a run of A on a given input tree \u03be. This is a mapping \u03c1 which maps each position of \u03be to a state of Q. Thus \u03c1 determines, for each position w of \u03be, a transition (q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) where qi (for i \u2208 {1, . . . , k}) and q are the states assigned by \u03c1 to the i-th successor of w and to w itself, respectively, and \u03c3 is the label of \u03be at position w. By applying \u03b4k to (q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q), we obtain the weight of this transition. Then the weight of \u03c1, denoted by wt(\u03be, \u03c1), is the \u2297-product of the weights of the transitions for each position of \u03be (where the factors are ordered according to the depth-first post-order of the corresponding positions). Finally, we let\n[[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwt(\u03be, \u03c1)\u2297 F (\u03c1(\u03b5))\nwhere RA(\u03be) is the set of all runs of A on \u03be, and \u03c1(\u03b5) is the state assigned by \u03c1 to the root of \u03be. A weighted tree language r : T\u03a3 \u2192 B is run recognizable if there exists a (\u03a3,B)-wta A such that r = [[A]]run. We denote by Recrun(\u03a3,B) the set of weighted tree languages which are run recognizable by some (\u03a3,B)-wta.\nThe initial algebra semantics of A is based on the concept of vector algebra of A, which is the \u03a3-algebra (BQ, \u03b4A) where \u03b4A associates with each k-ary input symbol \u03c3 \u2208 \u03a3 a k-ary operation \u03b4A(\u03c3) : B\nQ \u00d7 \u00b7 \u00b7 \u00b7 \u00d7BQ \u2192 BQ. For each q \u2208 Q, the q-component of a vector v \u2208 BQ is denoted by vq. The operation \u03b4A(\u03c3) is defined, for every v1, . . . , vk \u2208 B Q and q \u2208 Q, by\n\u03b4A(\u03c3)(v1, . . . , vk)q = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\n(vi)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) .\nThen, for every \u03be \u2208 T\u03a3, we let\n[[A]]init(\u03be) = \u2295\nq\u2208Q\nhA(\u03be)q \u2297 F (q)\nwhere hA denotes the unique \u03a3-algebra homomorphism from the \u03a3-term algebra to the \u03a3-algebra (BQ, \u03b4A). A weighted tree language r : T\u03a3 \u2192 B is initial algebra recognizable if there exists a (\u03a3,B)-wta A such that r = [[A]]init. We denote by Recinit(\u03a3,B) the set of weighted tree languages which are initial algebra recognizable by some (\u03a3,B)-wta.\nIf B is a semiring, i.e., \u2297 distributes over \u2295, then [[A]]run = [[A]]init (as in the case of weighted string automata over semirings, similar to [Eil74, Cor. 6.2]). For arbitrary strong bimonoids this equality in general does not hold (cf. [DSV10, Ex. 25] and [CDIV10, Ex. 3.1]). However, the equality does hold for arbitrary strong bimonoids if A is bottom-up deterministic.\nSince the set of trees does not have a monoid structure (in contrast to the set of strings), there does not exists a semantics of wta which corresponds directly to Schu\u0308tzenberger\u2019s semantics of wsa described above. However, for the case that B is a field, the concept of B-\u03a3-representation [BA89] can be viewed as kind of monoid-semantics of wta. In that concept it is exploited that the set of contexts over \u03a3 (i.e., trees with a variable at exactly one leaf) is a freely generated monoid; moreover, while switching from contexts to trees, a certain consistency condition has to be satisfied.\nTopics of the book. In this book we present a part of the theory of wta over strong bimonoids. Most of the theorems which we present have previously been published in research articles; others are generalizations of the corresponding published theorems. However, some results are published for the first time in this book as, e.g., Observation 2.6.16; Theorem 5.1.1; Theorem 10.3.3; results of Subsections 10.13.6, 10.13.7, and 10.13.8; results of Section 12.4; results of Subsections 14.4.2 and 14.4.3 , in particular"
        },
        {
            "heading": "4 CHAPTER 1. INTRODUCTION",
            "text": "Theorem 14.4.11; results of Section 14.5; results of Section 18.2.5, in particular Theorems 18.2.14 and 18.2.15; Theorems 19.7.1 and 19.8.4.\nIn Chapter 2 we collect all the technical ingredients for our development such that the book is selfcontained and hence also accessible for, e.g., master students of Mathematics or Computer Science. So this chapter is quite long, and of course, it may be consulted on demand.\nIn Chapter 3 we define the concept of wta over some ranked alphabet \u03a3 and some strong bimonoid B, and with each such (\u03a3,B)-wta A, we associate the run semantics [[A]]run and the initial algebra semantics [[A]]init. We define the restricted versions bottom-up deterministic wta and crisp deterministic wta. We give several examples of a wta and both kinds of semantics. In order to connect the concept of wta with its historical predecessors, we discuss particular cases of wta:\n\u2022 wta over string ranked alphabets (which are equivalent to weighted string automata), \u2022 wta over the Boolean semiring (which are equivalent to finite-state tree automata), \u2022 wta over the semiring of natural numbers (which reflect multiplicities in finite-state tree automata), \u2022 wta over commutative semirings (which are equivalent to multilinear representations).\nIn Chapter 4 we prove basic properties of wta and of their bottom-up and crisp deterministic subconcepts. Roughly speaking, these properties are consequences of the annihilation property of 0 for the multiplication \u2297.\nIn Chapter 5 we provide two algorithms (cf. Section 5.1) which compute in a natural way the values [[A]]run(\u03be) and [[A]]init(\u03be) for any given wta A and input tree \u03be. We analyse the complexity of these algorithms and, as is to be expected, the second algorithm is more efficient than the first one. Moreover, we compare the run semantics and the initial algebra semantics of wta and show some examples of wta for which these semantics are different. We prove that there exist a strong bimonoid B and a (\u03a3,B)-wta A such that [[A]]init 6\u2208 Recrun(\u03a3,B) (cf. Theorem 5.2.5). We show conditions under which, for each wta, the two semantics are equal (cf. Theorems and 5.3.1 and 5.3.2).\nIn Chapter 6 we prove three pumping lemmas: one for runs of wta over strong bimonoids (cf. Theorem 6.1.4), another one for supports of weighted tree languages recognizable by wta over positive strong bimonoids (cf. Corollary 6.1.6), and a third one for supports of weighted tree languages recognizable by wta over fields (cf. Theorem 6.2.9). We use these lemmas to show that certain weighted tree languages are not recognizable.\nIn Chapter 7 we prove under which conditions a wta can be transformed into an equivalent one which is trim, i.e., each state is \u201cuseful\u201d (cf. Theorems 7.1.3 and 7.1.4). Moreover, we show how to normalize the root weight mapping F such that there exists a unique state q with F (q) = 1 and F (p) = 0 for each state p different from q (cf. Theorem 7.3.1). Finally, we prove that each wta can be transformed into a run equivalent wta with identity transition weights if the multiplication is locally finite 7.4.2.\nIn Chapter 8 we recall the concept of weighted context-free grammar from [CS63] and prove several normal form lemmas (cf. Section 8.2). We prove the fundamental connection between weighted tree languages that are run recognizable by wta and weighted context-free languages (cf. Theorem 8.3.1). This generalizes the well-known theorem [Bra69, Don70] saying that the yield of a recognizable tree language is a context-free language, and vice versa, each context-free language can be obtained in this way.\nIn Chapter 9 we introduce weighted regular tree grammars as particular weighted context-free grammars. We show that, under certain conditions, weighted regular tree grammars and the run semantics of wta are equally expressive (cf. Theorem 9.2.9).\nIn Chapter 10 we prove a number of closure properties of the set of recognizable weighted tree languages, viz., closure under sum, scalar multiplication, Hadamard product, top-concatenations, tree concatenations, Kleene-stars, yield-intersection with weighted regular string languages, strong bimonoid homomorphisms, tree relabelings, linear and nondeleting tree homomorphisms, inverse of linear tree homomorphisms, and weighted projective bimorphisms. A brief summary of these closure results is presented in Table 10.18.\n5 In Chapter 11 we introduce two different kinds of weighted local systems and generalize another fundamental result from the theory of recognizable tree languages: each recognizable tree language is the image of a local tree language under a tree relabeling (cf. Theorem 11.2.6). Moreover, we prove a decomposition of the run semantics of a wta into the inverse of a deterministic tree relabeling, intersection with a local tree language, and a homomorphism into an evaluation algebra (cf. Theorems 11.3.1).\nIn Chapters 12, 13, and 14 we prove characterizations of the set of recognizable weighted tree languages in terms of rational weighted tree languages (cf. Theorem 12.1.2), in terms of representable weighted tree languages (cf. Theorem 13.1.4), and in terms of MSO-definable weighted tree languages (cf. Theorem 14.3.1). This generalizes corresponding well-known results of Kleene, Me\u0301dve\u0301dje\u0301v, and Bu\u0308chi-Elgot-Trakhtenbrot, respectively, from the unweighted string case to the weighted tree case.\nIn Chapter 15 we prove that, for commutative and \u03c3-complete semirings, the set of recognizable weighted tree languages is the smallest principal abstract family of weighted tree languages (cf. Theorem 15.4.5). This generalizes the well-known situation for the set of recognizable string languages [Gin75].\nIn Chapters 16 and 17 we deal with the questions under which conditions it is possible to construct, for a given wta, an equivalent crisp deterministic wta and a bottom-up deterministic wta, respectively. In general, the usual subset construction for unweighted automata leads to an infinite state set and thus cannot be employed.\nIn Chapter 18 we deal with the question whether the support of a recognizable weighted tree language is a recognizable tree language. We show that in general the answer is no and we give sufficient conditions under which the answer is yes.\nFinally, in Chapter 19 we collect some of the results of the previous chapters for the special case of wta over bounded lattices. In particular, we prove the inclusion relationship between several sets of recognizable weighted tree languages (cf. Theorem 19.3.5) and the characterizations of Recrun(\u03a3, L) in terms of unrestricted representations (cf. Theorem 19.7.1) and in terms of unrestricted weighted MSO formulas (cf. Theorem 19.8.4).\nIn Figure 1.1 (at the end of this introduction) we show an overview of the models of automata and models of grammars which occur in this book, and we indicate their relationship.\nTopics not included in this book. We have covered some of the important theorems for wta over strong bimonoids. However, this book is not meant to present the whole theory of wta over strong bimonoids, not even that of wta over semirings. The choice of the presented material is biased by our personal research in this area. In particular, we did not address the topics of the following list. For each topic, we have indicated some of the publications where the reader can start investigating the topic.\n\u2022 wta on infinite trees [Rah07, BP11, LP14] \u2022 wta on unranked trees [HMV09, DV11b, DH15, DHV15, Go\u0308t17] \u2022 (weighted) forest automata [Str09, Do\u0308r19, Do\u0308r21, Do\u0308r22] \u2022 wta over M-monoids [Kui98, Kui99b, Mal04, Mal05b, FMV09, SVF09, FSV12, TO15, FV18] \u2022 wta over tree valuation monoids [DGMM11, DM12, TO15, DFG16, Go\u0308t17, GFD19] \u2022 B-\u03a3-representation of dimension n [BA89, Boz94] \u2022 probabilistic tree automata [MM70, Ell71, Wei15] \u2022 minimization of wta [BLB83, HMM07, Mal08, Mal09, HMV09, MQ12, MQ11, JM13, MQ14, BR20] \u2022 decidability and undecidability [Sei89, Sei90, Boz91, Sei94, Bor04, Mal04, Mal05b, SMK18, FKV21, Pau20,\nDFKV20, DFKV22] (but also cf. Lemma 9.1.2 and Theorem 16.2.14) \u2022 varieties of weighted tree languages [FS11, SJC15] \u2022 cut sets of recognizable weighted tree languages over some ordered structure [BMS\u030c+06, STV08] \u2022 learning of wta [Mal07, DV07a, DHM11, BM15] \u2022 weighted tree transducers [Kui99c, EFV02, FV03, FGV04, Mal04, Mal05b, Mal05a, MV05, Mal06b, Mal06a,\nMal06c, FV09, FMV11] \u2022 wta with storage [HV15, VDH16, FHV18, FV19, HVD19, FV22b, Her20b, DFV21] \u2022 applications of wta (and weighted tree transducers) in syntactic processing of natural languages [PRS94,\nYK02, GHKM04, GK04, KG05, GKM08, KM09, MS09, FMV10, MS10, May10, Mal11a, Mal11b, Buy13,"
        },
        {
            "heading": "6 CHAPTER 1. INTRODUCTION",
            "text": "BVN14, Bu\u0308c14, BDZ15, DGV16, Mal17, Die18, MV19b, MV19a, MV21]; also cf. the workshops [DK10, DK12].\nNotes to the reader.\n... about prerequisites: The reader is assumed to be familiar with the fundamental concepts, results, and constructions in the theory of tree automata [Eng75b, GS84, GS97, CDG+07] and context-free languages [Har78, HU79, HMU07].\n... about the notion \u201cconstruction\u201d: In general, a construction is an algorithm which takes some objects as input and produces some objects as output in an effective manner. For instance, [GS84, Thm. 2.4.2] states that, for two finite-state tree automata A1 and A2, a finite-state tree automaton A can be constructed which recognizes the intersection L(A1) \u2229 L(A2) of the tree languages which are recognized by A1 and A2; then the proof of [GS84, Thm. 2.4.2] (essentially) shows an algorithm which, on input A1 and A2, builds up effectively A such that L(A) = L(A1) \u2229 L(A2).\nAlso in the present book we show a number of constructions. However, here the situation is more complicated for those constructions which involve some strong bimonoid B. If the algorithm involves calculations in B, it may happen that the calculations in B are not effective. This can arise, e.g., because the arguments of the calculation cannot be given effectively or because the operations \u2295 and \u2297 are not given algorithmically. In this unpleasant situation, we understand by \u201cconstruction\u201d just the definition of the output objects, and not an algorithm for their effective building up process. So, in our understanding a construction\n\u2022 takes some objects as input, \u2022 if the input objects are given effectively and the operations of the strong bimonoid are effective, then the construction gives the output objects effectively, \u2022 otherwise the construction merely defines the output objects (in a mathematical sense).\nLet us illustrate this understanding by considering the \u201cweighted version\u201d of [GS84, Thm. 2.4.2]. In Theorem 10.4.1(1) we claim: \u201cLet \u03a3 be a ranked alphabet, B be a strong bimonoid, and A1 and A2 be two (\u03a3,B)-wta. If B is a commutative semiring, then we can construct a (\u03a3,B)-wta A such that [[A]] = [[A1]] \u2297 [[A2]].\u201d If B is, e.g., the Boolean semiring or the semiring of natural numbers, then our proof shows an algorithm which builds up A effectively. However, if B is, e.g., the field of real numbers and some of the coefficients of A1 or A2 cannot be given effectively, then our proof just shows the definition of A.\n... about general conventions: In order to avoid many repetitions of the statements \u201cfor each ranked alphabet \u03a3\u201d and \u201cfor each strong bimonoid B\u201d, we will use the general conventions that \u03a3 always stands for an arbitrary, i.e., universally quantified ranked alphabet (cf. page 40) and that B denotes an arbitrary strong bimonoid (cf. page 35). Such a convention is placed inside \\begin{quote}-\\end{quote} in emphasized letter style. In some chapters or sections, we develop results for a particular subset of strong bimonoids, e.g., the set of commutative semirings. Again, in order to avoid repetitions of universal quantifications over this particular subset, we will place a corresponding convention local to these chapters and sections; the scope of each local convention is explicitly indicated. Then, for each result (e.g. observation, lemma, theorem, corollary) within this scope, the general and local conventions and restrictions hold. We hope that this extraction of universal quantifications helps to focus on important argumentation.\n... about theorems, lemmas, and corollaries which are in a box: If a reader just wants to look up some result, then checking for local and global conventions and collecting them is a burden and it is better to see *all* the restrictions, requirements, and universal quantifications inside the corresponding latex-environment. To solve the contradicting wishes: avoiding repetitions of universal quantifications versus fully quantified statements, for some of the main results (lemmas, theorems, and corollaries) we show all the necessary restrictions and requirements inside the latex-environment. In\n7 order to ease the search for such main results, we put them into a box.\n... about possible mistakes: We would like to ask (or: encourage) the readers to share with us their remarks and observations concerning the contents of the book. In particular, the indication of mistakes or of missing references to published results are very welcome. Please, write an email to fulop@inf.u-szeged.hu and heiko.vogler@tu-dresden.de.\n... about an electronic version: This book can be found on arXiv by searching for the authors or the title.\nAcknowledgements. In 2017 we started to work on this book. But the seed for this work was laid much earlier. In our academic youth, we both had excellent teachers of the theory of tree automata (Ferenc Ge\u0301cseg and Joost Engelfriet, respectively). After this academic qualification, we met for the first time in the year 1987, when the second author (Heiko) visited the first author (Zolta\u0301n) and his colleague Sa\u0301ndor Va\u0301gvo\u0308lgyi in Szeged. And the result of this start was the publication [FHVV93]. Since then we (the authors) jointly investigated the theory of tree automata and tree transducers. In the beginning, we communicated by hand-written letters as it was usual at that time, or we paid regular visits to each other. When in 1999 Werner Kuich visited Ferenc Ge\u0301cseg, the second author happened to be also in Szeged. Then Werner showed him his fresh paper \u201cTree transducers and tree series\u201d [Kui99c] and explained its ideas. From that point on, we (Zoltan and Heiko) worked on the theory of weighted tree automata and weighted tree transducers (starting with [EFV02]). During the development of that theory, we benefitted much from the cooperation with Symeon Bozapalidis, Frank Drewes, Manfred Droste, Joost Engelfriet, Andreas Maletti, Mark-Jan Nederhof, George Rahonis, and Magnus Steinby. In the years 2002-2021, the series of workshops \u201cWeighted Automata: Theory and Applications\u201d (WATA), co-organized by Manfred Droste, gave an excellent infrastructure for presenting our results. This book contains many ideas which were produced by these cooperations during the last 20 years; we are very grateful for this.\nWe would like to thank our colleagues for checking some parts of the book and contributing valuable suggestions: Johanna Bjo\u0308rklund, Frank Drewes, Manfred Droste, Zsolt Gazdag, Luisa Herrmann, Eija Jurvanen, Andreas Maletti, George Rahonis, and Sa\u0301ndor Va\u0301gvo\u0308lgyi. In particular, we wish to thank Manfred Droste for several fruitful discussions and suggestions, which had a very positive impact on the book. Of course, each remaining mistake is due to the authors. We are grateful to Felicita Purnama Dewi Gernhardt, Luisa Herrmann, Da\u0301vid Ko\u0301szo\u0301, and, in particular, Celina Pohl for preparing the figures. In a number of situations, Celina Pohl and Richard Mo\u0308rbitz helped us to find the appropriate latex-commands and settings.\n\u201c... who prologue-like your humble patience pray, gently to hear, kindly to judge, our play.\u201d W. Shakespeare, Henry V.\nZolta\u0301n Fu\u0308lo\u0308p and Heiko Vogler December 13, 2022 Szeged, Hungary and Dresden, Germany"
        },
        {
            "heading": "8 CHAPTER 1. INTRODUCTION",
            "text": "models of automata models of grammars\nwta: weighted tree automaton wcfg: weighted context-free grammar wsa: weighted string automaton wrtg: weighted regular tree grammar fta: finite-state tree automaton cfg: context-free grammar fsa: finite-state string automaton wpb: weighted projective bimorphism\n\u03a3, \u03a8: ranked alphabets \u0393: alphabet B: strong bimonoid rhs: right-hand side\n9 List of all general and local conventions made in this book\n\u2022 on page 12: In the rest of this book, \u0393 will denote an arbitrary alphabet, if not specified otherwise.\n\u2022 on page 35: In the rest of this book, B will denote an arbitrary strong bimonoid (B,\u2295,\u2297, 0, 1) if not specified otherwise.\n\u2022 on page 40: In the rest of this book, we assume that each ranked alphabet has at least one symbol with rank 0. Moreover, \u03a3 and \u2206 will denote arbitrary such ranked alphabets, if not specified otherwise.\n\u2022 on page 41: If not specified otherwise, then we denote the unique \u03a3-algebra homomorphism from the \u03a3-term algebra T\u03a3 = (T\u03a3, \u03b8\u03a3) to some \u03a3-algebra A = (A, \u03b8) by hA.\n\u2022 on page 48: In the rest of the book, Z and X will denote sets of variables if not specified otherwise. Moreover, we let Zn = {z1, . . . , zn} and Xn = {x1, . . . , xn} for every n \u2208 N.\n\u2022 on page 97: In the rest of this section, we let B denote an arbitrary commutative semiring.\n\u2022 on page 117: Due to Theorem 5.3.1, if A is bu deterministic, then we write [[A]] instead of [[A]]run and [[A]]init. Moreover, for a weighted tree language r, we say that r is bu deterministically recognizable (instead of bu deterministically i-recognizable and bu deterministically r-recognizable). Also, we write bud-Rec(\u03a3,B) for bud-Recrun(\u03a3,B) (and hence, for bud-Recinit(\u03a3,B)). Similarly, we say that r is crisp deterministically recognizable (instead of crisp deterministically i-recognizable and crisp deterministically r-recognizable). Also, we write cd-Rec(\u03a3,B) for cd-Recrun(\u03a3,B) and cd-Recinit(\u03a3,B)).\n\u2022 on page 121: Due to Corollary 5.3.3, if B is a semiring and A is a (\u03a3,B)-wta, then we write [[A]] instead of [[A]]run\nand [[A]]init. Moreover, for an i-recognizable or r-recognizable weighted tree language r, we say that r is recognizable. Also, we denote the set Recrun(\u03a3,B) (and hence, Recinit(\u03a3,B)) by Rec(\u03a3,B).\n\u2022 on page 122: Due to Corollary 5.3.4, if B is a semiring and A is a (\u0393,B)-wsa, then we write [[A]] instead of [[A]]run and [[A]]init.\n\u2022 on page 124: In this section, we let A = (Q, \u03b4, F ) be an arbitrary (\u03a3,B)-wta.\n\u2022 on page 130: In the rest of this section, we let B be a field and (V, \u00b5, \u03b3) be a (\u03a3,B)-multilinear representation where V is a \u03ba-dimensional B-vector space for some \u03ba \u2208 N+, unless specified otherwise.\n\u2022 on page 174: In the rest of this book, for each wrtg G, we will abbreviate [[G]]t by [[G]].\n\u2022 on page 253: In the rest of this chapter, B denotes an arbitrary commutative semiring.\n\u2022 on page 287: In the sequel we will abbreviate hM(\u03a3,\u03ba) by h\u03ba."
        },
        {
            "heading": "10 CHAPTER 1. INTRODUCTION",
            "text": "\u2022 on page 299: In this section, we assume that B is commutative.\n\u2022 on page 321: In the rest of this chapter, B denotes an arbitrary commutative and \u03c3-complete semiring.\n\u2022 on page 344: In this chapter B is a semiring and A = (Q, \u03b4, F ) denotes an arbitrary (\u03a3,B)-wta unless specified otherwise.\n\u2022 on page 347: We recall that V(A) = (BQ, \u03b4A) is the vector algebra of A, and that 0Q \u2208 BQ is the Q-vector over B which contains 0 in each component (cf. Section 3.1). We assume that there exists \u03b1 \u2208 \u03a3(0) such that \u03b4A(\u03b1)() 6= 0Q.\n\u2022 on page 370: In this subsection we assume that B is commutative.\n\u2022 on page 381: In this chapter, L = (L,\u2228,\u2227, 0, 1) denotes a bounded lattice.\nChapter 2\nPreliminaries"
        },
        {
            "heading": "2.1 Numbers and sets",
            "text": "We denote the set {0, 1, 2, . . .} of natural numbers by N and the set N \\ {0} by N+. Let n, k \u2208 N. Then we denote the set {i \u2208 N | n \u2264 i \u2264 k} by [n, k]. We abbreviate [1, k] by [k]. Thus [0] = \u2205. We denote the sets of integers, rational numbers, and real numbers by Z, Q, and R, respectively.\nFor each a, b \u2208 R, we denote by max(a, b) and min(a, b) the maximum and the minimum of a and b with respect to \u2264, respectively. We extend max and min to each nonempty, finite subset of R in a natural way. Later, when max (or min) is an operation of a monoid, we will define max \u2205 (and min \u2205, respectively) to be the unit element of that monoid (cf. (2.10)).\nSometimes we use the set N\u222a{\u221e}. We abbreviate it by N\u221e and extend the operations + and min to N\u221e in the obvious way: a+\u221e = \u221e and min(a,\u221e) = a for each a \u2208 N\u221e. In a similar way we proceed with an extension by \u2212\u221e and the operation max (and also with other sets like Z and R).\nFor the set R of real numbers, we denote its subset {r \u2208 R | r \u2265 0} by R\u22650. For the corresponding subsets of integers and rational numbers we use Z\u22650 and Q\u22650, respectively. We denote the set Q\u22650\u222a{\u221e} by Q\u22650,\u221e.\nLet A be a set. We call A countable if its cardinality coincides with that of a subset of the natural numbers. If A is finite and it has n elements a1, . . . , an, then we denote this fact by A = {a1, . . . , an}. If n = 1, then sometimes we identify A with a1 and simply write a1 for {a1}. Moreover, |A| denotes the cardinality of A. The power-set of A, denoted by P(A), is the set of all subsets of A. We denote by Pfin(A) the set of all finite subsets of A.\nLet n \u2208 N, and A1, . . . , An be sets. The Cartesian product of A1, . . . , An is the set {(a1, . . . , an) | ai \u2208 Ai for each i \u2208 [n]} and it is denoted by A1 \u00d7 . . . \u00d7 An. The n-fold Cartesian product of a set A is the set A\u00d7 . . .\u00d7A, where A appears n times. We abbreviate A\u00d7 . . .\u00d7A by An. In particular, A0 = {()}.\nLet A and B be sets. If each element of A is also an element of B, then A is a subset of B, denoted by A \u2286 B. If A \u2286 B and A 6= B, then A is a strict subset of B, denoted by A \u2282 B."
        },
        {
            "heading": "2.2 Strings and languages",
            "text": "We recall some notions and notations of strings and (formal) languages from [Har78, HU79, HMU14, Lin12].\nLet A be a set. A string (or: word) over A is a finite sequence a1 \u00b7 \u00b7 \u00b7 an with n \u2208 N and ai \u2208 A for each i \u2208 [n]. In particular, we denote the sequence a1 \u00b7 \u00b7 \u00b7 an with n = 0 by \u03b5 and call it the empty string. We say that a1 \u00b7 \u00b7 \u00b7 an has length n. For each n \u2208 N, we denote the set of strings over A of length n by\n11"
        },
        {
            "heading": "12 CHAPTER 2. PRELIMINARIES",
            "text": "An; thus A0 = {\u03b5}. Moreover, we denote by A\u2217 the set of all strings over A, i.e., A\u2217 = \u22c3 n\u2208NA\nn and we let A+ = A\u2217 \\ {\u03b5}. For each w \u2208 A\u2217, we denote by |w| the length of w.\nWe note that the notation An is overloaded in the sense that it denotes two sets: (a) the n-fold Cartesian product of A and (b) the set of strings over A of length n. Of course, formally these sets are different. But since there exists a bijection between them, we find it acceptable to use the same notation.\nThe concatenation of the strings a1 \u00b7 \u00b7 \u00b7 an and b1 \u00b7 \u00b7 \u00b7 bm is the string a1 \u00b7 \u00b7 \u00b7anb1 \u00b7 \u00b7 \u00b7 bm. For every v, w \u2208 A\u2217, we denote the concatenation of v and w by v \u00b7 w or simply by vw.\nLet w \u2208 A\u2217. For each n \u2208 N, we define wn such that w0 = \u03b5 and wn = wwn\u22121 for n \u2208 N+. Moreover, we denote by postfix(w) the set {v \u2208 A\u2217 | (\u2203u \u2208 A\u2217) : w = uv} of postfixes of w, and by prefix(w) the set {u \u2208 A\u2217 | (\u2203v \u2208 A\u2217) : w = uv} of prefixes of w. Note that {\u03b5, w} \u2286 postfix(w) \u2229 prefix(w).\nAn alphabet is a finite and nonempty set. Let \u0393 be an alphabet. Then each subset L \u2286 \u0393\u2217 is called a language (or: formal language) over \u0393. Let L1, L2 \u2286 \u0393\u2217 be two languages. The concatenation of L1 and L2, denoted by L1 \u00b7 L2 or just L1L2, is the language L1L2 = {w1w2 | w1 \u2208 L1, w2 \u2208 L2}.\nIn the rest of this book, \u0393 will denote an arbitrary alphabet, if not specified otherwise."
        },
        {
            "heading": "2.3 Binary relations and mappings",
            "text": "Binary relations. LetA and B be sets. A binary relation (on A and B) is a subsetR \u2286 A\u00d7B. As usual, we frequently write aRb for (a, b) \u2208 R. For each A\u2032 \u2286 A, we define R(A\u2032) = {b \u2208 B | (\u2203a \u2208 A\u2032) : aRb}. If A = B, then we call R a binary relation on A (or: over A). We denote by R\u22121 the binary relation {(b, a) | aRb}, and we call it the inverse of R.\nLet additionally C be a set and R1 \u2286 A\u00d7B and R2 \u2286 B\u00d7C be binary relations. The composition of R1 and R2, denoted by R1;R2, is the binary relation on A and C defined by R1;R2 = {(a, c) \u2208 A\u00d7 C | (\u2203b \u2208 B) : (a, b) \u2208 R1 and (b, c) \u2208 R2}.\nLet R be a binary relation on A. The relation R is\n\u2022 reflexive if aRa for every a \u2208 A, \u2022 symmetric if aRb implies that bRa for every a, b \u2208 A, \u2022 antisymmetric if aRb and bRa imply that a = b for every a, b \u2208 A, and \u2022 transitive if aRb and bRc imply that aRc for every a, b, c \u2208 A.\nThe reflexive, transitive closure of R, denoted by R\u2217, is the binary relation R\u2217 = \u22c3 n\u2208NR\nn where R0 = {(a, a) | a \u2208 A} and Rn+1 = Rn;R for each n \u2208 N. The transitive closure of R, denoted by R+, is the binary relation R+ =\n\u22c3 n\u2208N+ Rn. Then R\u2217 is reflexive and transitive, and R+ is transitive.\nIf R is reflexive, symmetric, and transitive, then we call it an equivalence relation (on A). Then, for every a \u2208 A, the equivalence class with representative a, denoted by [a]R, is the set {b \u2208 A | aRb}. The factor set of A modulo R, denoted by A/R, is the set {[a]R | a \u2208 A}. The index of R is the cardinality of A/R.\nLet \u2264 be a binary relation on A. If \u2264 is reflexive, antisymmetric, and transitive, then we call it a partial order (on A), and we call the pair (A,\u2264) a partially ordered set. A partial order \u2264 on A is a linear order (on A) if for every a, b \u2208 A we have a \u2264 b or b \u2264 a. For a, b \u2208 A, we write a < b to denote that a \u2264 b and a 6= b.\nLet (A,\u2264) be a partially ordered set and let B \u2286 A. An element a \u2208 A is an upper bound of B if, for each b \u2208 B, we have b \u2264 a. Moreover, if a is an upper bound and, for each upper bound a\u2032 of B, we have a \u2264 a\u2032, then a is the least upper bound of B. If the least upper bound of B exists, then we call it the supremum of B and denote it by sup\u2264B (or: supB). Similarly, we can define lower bound and the greatest lower bound, i.e., the infimum of B. We denote the latter by inf\u2264B (or: inf B)."
        },
        {
            "heading": "2.4. HASSE DIAGRAM, VENN DIAGRAM, AND EULER DIAGRAM 13",
            "text": "Mappings. Let f \u2286 A \u00d7 B be a binary relation. We say that f is a mapping from A to B, denoted by f : A \u2192 B, if for each a \u2208 A there exists a unique b \u2208 B such that (a, b) \u2208 f . In this case we write f(a) = b as usual. The set of all mappings from A to B is denoted by BA. We call A and B the domain and codomain of f , respectively. The image of f is the set im(f) = {f(a) | a \u2208 A}. A mapping f : A\u2192 B is injective if for every a1, a2 \u2208 A with a1 6= a2 we have that f(a1) 6= f(a2). It is surjective if for each b \u2208 B there exists an a \u2208 A such that f(a) = b.\nIn particular, each binary relation R \u2286 A\u00d7B can be considered as a mapping R : A\u2192 P(B), where R(a) = {b \u2208 B | aRb} for each a \u2208 A.\nLet f : A\u2192 B be a mapping and A\u2032 and B\u2032 be sets such that A\u2032 \u2286 A and B\u2032 \u2287 B. Then f is also a mapping from A to B\u2032, i.e., f : A \u2192 B\u2032. The restriction of f to A\u2032 is the mapping f |A\u2032 : A\u2032 \u2192 B and defined by f |A\u2032(a) = f(a) for each a \u2208 A \u2032.\nLet A, B, and C be sets such that A and B are disjoint. Moreover, let f : A \u2192 C and g : B \u2192 C. We define the union of f and g as the mapping (f \u222a g) : A \u222aB \u2192 C such that, for each x \u2208 (A \u222aB) we let (f \u222a g)(x) = f(x) if x \u2208 A, and (f \u222a g)(x) = g(x) otherwise. Clearly, (f \u222a g)|A = f and (f \u222a g)|B = g.\nLet C be a further set. For two mappings f : A \u2192 B and g : B \u2192 C, the composition of f and g is the mapping (g \u25e6 f) : A \u2192 C, where (g \u25e6 f)(a) = g(f(a)) for every a \u2208 A. If we view f and g as binary relations, then g \u25e6 f = f ; g.\nIn the usual way we extend a mapping f : A \u2192 B to the mapping f \u2032 : P(A) \u2192 P(B) by defining f \u2032(A\u2032) = {b \u2208 B | (\u2203a \u2208 A\u2032) : f(a) = b} for each A\u2032 \u2286 A. We denote f \u2032 also by f .\nIf we want to emphasize the listing of the values of a mapping, then we use the concept of family defined as follows. Let I be a countable set and B be a set. An I-indexed family over B is a mapping f : I \u2192 B. Such a family is also denoted by (bi | i \u2208 I) where bi = f(i) for each i \u2208 I. An I-indexed family over B is finite (nonempty) if I is finite (nonempty, respectively). We call I the index set of that family.\nLet f = (Bi | i \u2208 I) be an I-indexed family over P(B). We call f a partitioning of B (with respect to I) if \u22c3 i\u2208I Bi = B, and Bi \u2229Bj = \u2205 for every i, j \u2208 I with i 6= j.\nFor each k \u2208 N, a mapping f : Ak \u2192 A is called k-ary operation on A or simply operation on A. As usual, we identify a nullary operation f on A with the element f() \u2208 A. We denote the set of all k-ary operations on A by Opsk(A), and the set of all operations on A by Ops(A).\nWe define the identity mapping on A as the mapping idA : A \u2192 A such that idA(a) = a for each a \u2208 A."
        },
        {
            "heading": "2.4 Hasse diagram, Venn diagram, and Euler diagram",
            "text": "Let (A \u2264) be a partially ordered set. There are several ways to represent (A,\u2264) by means of a diagram in the plane.\nHasse diagram. Each element a \u2208 A is represented in the diagram by a node which is labeled by a. This node is called a-node. The nodes are placed into the diagram in such a way that whenever a < b holds for a, b \u2208 A, the b-node is drawn above the a-node. Moreover, for every a, b \u2208 A, the a-node and the b-node are connected by an edge if a < b and, for every c \u2208 A, the condition a \u2264 c \u2264 b implies that a = c or b = c. From this diagram we can reconstruct \u2264 by noting that a \u2264 b holds if and only if a = b or the b-node can be reached from the a-node via a sequence of ascending edges.\nFigure 2.1 shows an example of a Hasse diagram for A = (N\u00d7N) and the partial order \u2264 defined by (n1, n2) \u2264 (k1, k2) if n1 \u2264 k1 and n2 \u2264 k2. Of course, since A is an infinite set, we can only show a finite part of the Hasse diagram.\nVenn diagram and Euler diagram. These diagrams can be drawn if there exists a finite set U such that A is a finite collection of subsets of U , i.e., A = {B1, . . . , Bn} for some n \u2208 N+ and some subsets B1, . . . , Bn of U ; moreover, the partial order \u2264 is the subset relation \u2286. Then each element a \u2208 U is represented by an individual point in the diagram; this point is labeled by a. Each subset Bi is represented in the diagram by an area which is delimited by an oval or some polygon; this area contains exactly the elements of Bi. We call this area the Bi-area.\nIn the Venn diagram, the Bi-areas are placed into the diagram in an overlapping manner such that exactly 2n \u2212 1 overlap areas are created. It is possible that an overlap area does not contain an element of U .\nIn the Euler diagram, the Bi-areas are placed into the diagram also in an overlapping manner, but now in such a way that each overlap area contains at least one element of U .\nFigure 2.2 shows an example of a Venn diagram and an Euler diagram for U = {a, b, c} and A = {{a}, {a, b}, {b, c}}."
        },
        {
            "heading": "2.5 Well-founded induction",
            "text": "We recall the principle of proof by well-founded induction from [Win93, Jec03] (cf. also [BN98, Gal03]).\nLet C be a set and \u227a\u2286 C\u00d7C a binary relation on C. We say that \u227a is well-founded if there does not exists a family (ci | i \u2208 N) of elements of C such that \u00b7 \u00b7 \u00b7 \u227a c1 \u227a c0. (In [BN98] such a relation is called"
        },
        {
            "heading": "2.5. WELL-FOUNDED INDUCTION 15",
            "text": "terminating.) It is easy to see that a reflexive relation cannot be well-founded, and that the transitive closure \u227a+ of a well-founded relation \u227a on C is also well-founded. For instance, the relation\n\u227aN= {(n, n+ 1) | n \u2208 N}\nis a well-founded relation on N. Since <= (\u227aN)+ (where < is the usual \u201cless than\u201d relation on N), the relation < is also well-founded.\nLet C be a set and \u227a be a well-founded relation on C. We call the pair (C,\u227a) a well-founded set. Moreover, let P \u2286 C be a subset, called property. We will abbreviate the fact that c \u2208 P by P (c) and say that c has the property P . Then the following holds:\n( (\u2200c \u2208 C) : [(\u2200c\u2032 \u2208 C) : (c\u2032 \u227a c)\u2192 P (c\u2032)]\u2192 P (c) ) \u2192 ( (\u2200c \u2208 C) : P (c) ) . (2.1)\nThe formula (2.1) is called the principle of proof by well-founded induction on (C,\u227a) (for short: proof by induction on (C,\u227a)). We can use this principle to prove the claim that each c \u2208 C has property P .\nOften, the proof of the premise of (2.1), i.e., the formula\n( (\u2200c \u2208 C) : [(\u2200c\u2032 \u2208 C) : (c\u2032 \u227a c)\u2192 P (c\u2032)]\u2192 P (c) ) ,\nis split into two parts. To show them, we define the concept of minimal element. For each c \u2208 C, we say that c is minimal (with respect to \u227a) if there does not exist c\u2032 \u2208 C such that c\u2032 \u227a c. We denote by min\u227a(C) the set of all minimal elements of C. Then the first part is the proof of the induction base (for short: I.B.)\n(\u2200c \u2208 min\u227a(C)) : P (c) (2.2)\nand the second part is the proof of the induction step (for short: I.S.)\n( (\u2200c \u2208 C \\min\u227a(C)) : [(\u2200c \u2032 \u2208 C) : (c\u2032 \u227a c)\u2192 P (c\u2032)]\u2192 P (c) ) . (2.3)\nFor each c \u2208 C, the subformula [(\u2200c\u2032 \u2208 C) : (c\u2032 \u227a c)\u2192 P (c\u2032)]\nis called induction hypothesis (for short: I.H.).\nThere are several instances of well-founded sets and well-founded induction which are relevant for us. Two instances are based on the set N of natural numbers and we present these instances here (later we will present two more instances which are based on the set of trees):\n\u2022 proof by induction on (N,\u227aN) (for short: proof by induction on N): Then min\u227aN(N) = {0}, and the induction base (2.2) and the induction step (2.3) read\nP (0) and ( (\u2200n \u2208 N+) : P (n\u2212 1)\u2192 P (n) ) , respectively,\n\u2022 proof by induction on (N, <): Then min<(N) = {0}, and the induction base (2.2) and the induction step (2.3) read\nP (0) and ( (\u2200n \u2208 N+) : [ (\u2200k \u2208 [0, n\u2212 1]) : P (k) ] \u2192 P (n) ) , respectively.\nWe also use the principle of definition of a mapping by well-founded induction, which is based on the next theorem. Its historical predecessor is [Ded39, 126. Satz der Definition durch Induktion] for mappings of type f : N \u2192 A for some set A. We follow the proof of that theorem given in [Ind76] and generalize it to mappings of type f : C \u2192 A for any set C and well-founded relation \u227a on C. For each c \u2208 C, we define pred\u227a(c) = {c \u2032 \u2208 C | c\u2032 \u227a c}. (We also refer to [Kla84, Thm. 1.17] and [Win93, Thm. 10.19].)"
        },
        {
            "heading": "16 CHAPTER 2. PRELIMINARIES",
            "text": "Theorem 2.5.1. (cf. [Ded39, 126. Satz]) Let A and C be two sets, \u227a a well-founded relation on C, and G : {(c, g) | c \u2208 C, g : pred\u227a(c)\u2192 A} \u2192 A a mapping. Then there exists exactly one mapping f : C \u2192 A such that, for each c \u2208 C, we have\nf(c) = G(c, f |pred\u227a(c)) . (2.4)\nProof. We define the set\nS = { T \u2286 C \u00d7A | (\u2200c \u2208 C)(\u2200g : pred\u227a(c)\u2192 A) : (g \u2286 T )\u2192 ((c,G(c, g)) \u2208 T ) } . (2.5)\nWe note that S 6= \u2205 because (C \u00d7A) \u2208 S. Moreover, we define\n\u03c1 = \u22c2 (T | T \u2208 S) .\nNext we show the following three statements.\n(1) \u03c1 is a mapping of type \u03c1 : C \u2192 A, (2) for each c \u2208 C, we have \u03c1(c) = G(c, \u03c1|pred\u227a(c)), and (3) for each mapping h : C \u2192 A for which h(c) = G(c, h|pred\u227a(c)) for each c \u2208 C, we have h = \u03c1.\nFrom (1)-(3) it follows that \u03c1 is the desired mapping f , and hence we have proved the theorem.\nProof of (1): We define\nM = {c \u2208 C | there exists exactly one a \u2208 A such that (c, a) \u2208 \u03c1} .\nBy induction on (C,\u227a), we show that C \u2286M . For this, let c \u2208 C.\nI.B.: Let c \u2208 min\u227a(C). Since pred\u227a(c) = \u2205, we have (c,G(c, \u2205)) \u2208 T for each T \u2208 S. Hence (c,G(c, \u2205)) \u2208 \u03c1. We show that c \u2208M by contradiction.\nWe assume that there exists an a \u2208 A such that a 6= G(c, \u2205) and (c, a) \u2208 \u03c1. Let \u03c1\u2032 = \u03c1 \\ {(c, a)}; hence \u03c1\u2032 \u2282 \u03c1. We show that \u03c1\u2032 \u2208 S. For this, let c\u2032 \u2208 C and let g : pred\u227a(c\n\u2032) \u2192 A be such that g \u2286 \u03c1\u2032. Then for this c\u2032 and g we also have g \u2286 \u03c1. Then by the definition of \u03c1 we have (c\u2032, G(c\u2032, g)) \u2208 \u03c1. Now if c\u2032 = c, then (c\u2032, G(c\u2032, g)) = (c,G(c, \u2205)) 6= (c, a), Otherwise, again (c\u2032, G(c\u2032, g)) 6= (c, a). Hence in both cases (c\u2032, G(c\u2032, g)) \u2208 \u03c1\u2032. Then \u03c1\u2032 \u2208 S and thus \u03c1 \u2286 \u03c1\u2032, which contradicts \u03c1\u2032 \u2282 \u03c1.\nI.S.: Let c \u2208 C \\min\u227a(C). By I.H., for each c\u2032 \u2208 pred\u227a(c), we have c \u2208M . Let g = {(c \u2032, a) \u2208 \u03c1 | c\u2032 \u2208 pred\u227a(c)}. Then, by the definition of \u03c1, for each T \u2208 S, we have g \u2286 T and hence for each T \u2208 S, we also have (c,G(c, g)) \u2208 T . Consequently, (c,G(c, g)) \u2208 \u03c1. We show that c \u2208M by contradiction.\nWe assume that there is an a \u2208 A such that a 6= G(c, g) and (c, a) \u2208 \u03c1. Let \u03c1\u2032 = \u03c1 \\ {(c, a)}; hence \u03c1\u2032 \u2282 \u03c1. We show that \u03c1\u2032 \u2208 S. For this, let c \u2208 C and let g : pred\u227a(c) \u2192 A be such that g \u2286 \u03c1\n\u2032. Then for this c and g we also have g \u2286 \u03c1. Then by the definition of \u03c1 we have (c,G(c, g)) \u2208 \u03c1. If c = c, then (c,G(c, g)) = (c,G(c, g)) 6= (c, a), Otherwise, again (c,G(c, g)) 6= (c, a). Hence in both cases (c,G(c, g)) \u2208 \u03c1\u2032. Then \u03c1\u2032 \u2208 S and thus \u03c1 \u2286 \u03c1\u2032, which contradicts \u03c1\u2032 \u2282 \u03c1.\nProof of (2): It is obvious that, for each c \u2208 C, we have \u03c1|pred\u227a(c) \u2286 \u03c1. Hence, by the definition of \u03c1, for each c \u2208 C, we have \u03c1(c) = G(c, \u03c1|pred\u227a(c)).\nProof of (3): Let h : C \u2192 A be a mapping for which h(c) = G(c, h|pred\u227a(c)) for each c \u2208 C. By induction on (C,\u227a) we show that, for each c \u2208 C, we have h(c) = \u03c1(c). Let c \u2208 C. By I.H. for each c\u2032 \u2208 pred\u227a(c), we have h(c\n\u2032) = \u03c1(c\u2032). Hence, h|pred\u227a(c) = \u03c1|pred\u227a(c) and thus h(c) = G(c, h|pred\u227a(c)) = G(c, \u03c1|pred\u227a(c)) = \u03c1(c).\nWe say that the mapping f of Theorem 2.5.1 is defined by well-founded induction on (C,\u227a) (for short: defined by induction on (C,\u227a)).\nThe mapping G : {(c, g) | c \u2208 C, g : pred\u227a(c) \u2192 A} \u2192 A which determines by Theorem 2.5.1 a unique mapping f : C \u2192 A, might be called a schema of primitive recursion. Such schemata have been investigated, e.g., for C = N in [Pe\u0301t57], for C = \u0393\u2217 in [vHIRW75], for C being the set of trees over \u03a3 in [Hup78, EV91, FHVV93], and for C being a decomposition algebra in [Kla84]."
        },
        {
            "heading": "2.6. ALGEBRAIC STRUCTURES 17",
            "text": "In many applications of this principle, we will not show the mapping G explicitly, but only implicitly in the definition of f . Moreover, we will split (2.4) into an induction base and an induction step as follows:\nI.B.: Let c \u2208 min\u227a(C). Hence pred\u227a(c) = \u2205 and thus f |\u2205 : \u2205 \u2192 A. Then we define f(c) = G(c, f |\u2205). That means that f(c) does not depend on elements of im(f). I.S.: Let c \u2208 C \\min\u227a(C) and we assume that f(c\u2032) is defined for each c\u2032 \u2208 pred\u227a(c). Then we define f(c) = G(c, f |pred\u227a(c)). That means that f(c) may depend on elements of {f(c \u2032) | c\u2032 \u2208 pred\u227a(c)}.\nNext we demonstrate the principle of definition by well-founded induction. More precisely, given a mapping h : D \u2192 D for some set D, we define the family of iterated applications (hn | n \u2208 N) of h using this principle.\nFor this we instantiate the objects C, \u227a, A, and G which occur in the principle as follows: we let C = N, \u227a=\u227aN, and A = DD. Then G has the type\nG : {(n, g) | n \u2208 N, g : pred\u227aN(n)\u2192 D D} \u2192 DD .\nWe note that pred\u227aN(0) = \u2205 and, for each n \u2208 N+, the set pred\u227aN(n) = {n\u2212 1}. Now, for every n \u2208 N and g : pred\u227aN(n)\u2192 D D, we define\nG(n, g) =\n{ idD if n = 0\nh \u25e6 g(n\u2212 1) if n \u2208 N+ .\nBy Theorem 2.5.1, there exists a unique mapping f : N\u2192 DD such that f(n) = G(n, f |pred\u227aN (n) ). Finally, we define the family of iterated applications of a mapping h : D \u2192 D, denoted by (hn | n \u2208 N), by letting hn = f(n).\nThus, for n = 0, we have h0 = f(0) = G(0, f |pred\u227aN (0) ) = idD. Moreover, for each n \u2208 N+, we have\nhn = f(n) = G(n, f |pred\u227aN (n) ) = G(n, f |{n\u22121}) = h \u25e6 f |{n\u22121}(n\u2212 1) = h \u25e6 f(n\u2212 1) = h \u25e6 h n\u22121 .\nHence, the family of iterated applications of a mapping h : D \u2192 D satisfies the well known equations:\nh0 = idD and h n = h \u25e6 hn\u22121 for each n \u2208 N+. In particular, h 1 = h."
        },
        {
            "heading": "2.6 Algebraic structures",
            "text": ""
        },
        {
            "heading": "2.6.1 Ranked alphabets",
            "text": "A ranked alphabet is a pair (\u03a3, rk), where\n\u2022 \u03a3 is an alphabet and \u2022 rk : \u03a3\u2192 N is a mapping called rank mapping.\nFor each k \u2208 N, we denote the set rk\u22121(k) by \u03a3(k). Sometimes we write \u03c3(k) to indicate that \u03c3 \u2208 \u03a3(k). We denote max(k \u2208 N | \u03a3(k) 6= \u2205) by maxrk(\u03a3). Whenever the rank mapping is clear from the context or it is irrelevant, then we abbreviate the ranked alphabet (\u03a3, rk) by \u03a3. If \u03a3 = \u03a3(0), then we call \u03a3 trivial, and if \u03a3 = \u03a3(1) \u222a \u03a3(0), then we call \u03a3 monadic. A monadic ranked alphabet with |\u03a3(1)| \u2265 1 and |\u03a3(0)| = 1 is called a string ranked alphabet."
        },
        {
            "heading": "2.6.2 \u03a3-algebras, subalgebras, congruences, and homomorphisms",
            "text": "We recall some notions from universal algebra [Gra\u030868, GTWW77, BS81, Wec92].\nLet \u03a3 be a ranked alphabet. A \u03a3-algebra is a pair A = (A, \u03b8) which consists of a nonempty set A and a \u03a3-indexed family \u03b8 over Ops(A) such that \u03b8(\u03c3) : Ak \u2192 A for every k \u2208 N and \u03c3 \u2208 \u03a3(k). We call A"
        },
        {
            "heading": "18 CHAPTER 2. PRELIMINARIES",
            "text": "and \u03b8 the carrier set and the \u03a3-interpretation (or: interpretation of \u03a3), respectively, of A. We denote the set {\u03b8(\u03c3) | \u03c3 \u2208 \u03a3} of operations by \u03b8(\u03a3).\nIn the following, let A = (A, \u03b8) be a \u03a3-algebra. Moreover, let A\u2032 \u2286 A and O \u2286 \u03b8(\u03a3). We say that A\u2032 is closed under the operations in O, if, for every k \u2208 N, k-ary operation \u03b8(\u03c3) \u2208 O, and a1, . . . , ak \u2208 A\u2032, we have that \u03b8(\u03c3)(a1, . . . , ak) \u2208 A\u2032. We denote by \u3008A\u2032\u3009O the smallest subset of A which contains A\u2032 and is closed under the operations in O.\nA subalgebra of A is a \u03a3-algebra (A\u2032, \u03b8\u2032) such that A\u2032 \u2286 A and A\u2032 is closed under the operations in \u03b8(\u03a3) and for every k \u2208 N and \u03c3 \u2208 \u03a3(k), we have \u03b8\u2032(\u03c3) = \u03b8(\u03c3)|(A\u2032)k . For the sake of convenience, we will drop the prime from \u03b8\u2032 in the sequel. For each H \u2286 A, the subalgebra of A generated by H is the subalgebra (\u3008H\u3009\u03b8(\u03a3), \u03b8) of A. The smallest subalgebra of A is the subalgebra of A generated by \u2205.\nLet A = (A, \u03b8) be a \u03a3-algebra. We say that A is\n\u2022 finite if A is finite, \u2022 locally finite if, for each finite subset H \u2286 A, the set \u3008H\u3009\u03b8(\u03a3) is finite, and \u2022 finitely generated if there exists a finite subset H \u2286 A such that \u3008H\u3009\u03b8(\u03a3) = A.\nLemma 2.6.1. Let A = (A, \u03b8) be a \u03a3-algebra and H \u2286 A. Let f : P(A) \u2192 P(A) be defined for each U \u2208 P(A) by\nf(U) = U \u222a {\u03b8(\u03c3)(u1, . . . , uk) | k \u2208 N, \u03c3 \u2208 \u03a3 (k), u1, . . . , uk \u2208 U} .\nThen \u3008H\u3009\u03b8(\u03a3) = \u22c3 (fn(H) | n \u2208 N). Moreover, if \u3008H\u3009\u03b8(\u03a3) is finite, then we can construct it.\nProof. Obviously, for every U,U \u2032 \u2208 P(A),\nfor each n \u2208 N, we have fn(U) \u2286 fn+1(U), and (2.6) if U \u2286 U \u2032 then f(U) \u2286 f(U \u2032) . (2.7)\nLet us abbreviate \u22c3 (fn(H) | n \u2208 N) by V and show that V = \u3008H\u3009\u03b8(\u03a3).\nFirst we show that f(V ) \u2286 V as follows:\nf(V ) =f (\u22c3 (fn(H) | n \u2208 N) )\n= \u22c3 (fn(H) | n \u2208 N) \u222a { \u03b8(\u03c3)(u1, . . . , uk) | k \u2208 N, \u03c3 \u2208 \u03a3 (k), (\u2200i \u2208 [k]) : ui \u2208 \u22c3 (fn(H) | n \u2208 N) } = \u22c3 (fn(H) | n \u2208 N) \u222a {\u03b8(\u03c3)(u1, . . . , uk) | k \u2208 N, \u03c3 \u2208 \u03a3 (k), (\u2200i \u2208 [k])(\u2203ni \u2208 N) : ui \u2208 f ni(H)} = \u22c3 (fn(H) | n \u2208 N) \u222a {\u03b8(\u03c3)(u1, . . . , uk) | k \u2208 N, \u03c3 \u2208 \u03a3 (k), (\u2203n \u2208 N)(\u2200i \u2208 [k]) : ui \u2208 f n(H)}\n(by (2.6))\n= \u22c3( fn(H) \u222a {\u03b8(\u03c3)(u1, . . . , uk) | k \u2208 N, \u03c3 \u2208 \u03a3 (k), (\u2200i \u2208 [k]) : ui \u2208 f n(H)} | n \u2208 N )) = \u22c3( f(fn(H)) | n \u2208 N ) = \u22c3( fn(H) | n \u2208 N+ ) \u2286 V .\nHence V is closed under the operations of \u03b8(\u03a3) and thus (V, \u03b8) is a subalgebra of A such that H \u2286 V . Since (\u3008H\u3009\u03b8(\u03a3), \u03b8) is the smallest subalgebra of A with this property, we have \u3008H\u3009\u03b8(\u03a3) \u2286 V .\nNext we prove the inclusion from right to left. By induction on N, we show that fn(H) \u2286 \u3008H\u3009\u03b8(\u03a3) for each n \u2208 N. The statement is obvious for n = 0. Then for each n \u2208 N, we have\nfn+1(H) = f(fn(H)) \u2286 f(\u3008H\u3009\u03b8(\u03a3)) \u2286 \u3008H\u3009\u03b8(\u03a3) ,\nwhere the first inclusion follows from the I.H. and (2.7), and the second inclusion follows from the fact that \u3008H\u3009\u03b8(\u03a3), being a subalgebra, is closed under the operations of \u03b8(\u03a3). Hence, we obtain V \u2286 \u3008H\u3009\u03b8(\u03a3).\nFor each n \u2208 N, if fn(H) = fn+1(H), then fn+1(H) = fn+2(H) obviously. Now assume that \u3008H\u3009\u03b8(\u03a3) is finite. Then we can find N \u2208 N such that fN (H) = fN+1(H) and therefore \u3008H\u3009\u03b8(\u03a3) = \u22c3 (fn(H) | n \u2208 [0, N ]). Hence we can construct the set \u3008H\u3009\u03b8(\u03a3)."
        },
        {
            "heading": "2.6. ALGEBRAIC STRUCTURES 19",
            "text": "Let A = (A, \u03b8) be a \u03a3-algebra and \u223c\u2286 A\u00d7A be an equivalence relation on A. We call \u223c a congruence relation on A if, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), a1, b1, . . . , ak, bk \u2208 A, we have that a1 \u223c b1, . . . , ak \u223c bk implies \u03b8(\u03c3)(a1, . . . , ak) \u223c \u03b8(\u03c3)(b1, . . . , bk).\nLet A = (A, \u03b8) be a \u03a3-algebra and \u223c a congruence relation on A. The quotient algebra of A modulo \u223c is the \u03a3-algebra A/\u223c= (A/\u223c, \u03b8/\u223c), where A/\u223c is the factor set of A modulo \u223c and, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and a1, . . . , ak \u2208 A we have\n(\u03b8/\u223c)(\u03c3)([a1]\u223c, . . . , [ak]\u223c) = [\u03b8(\u03c3)(a1, . . . , ak)]\u223c .\nClearly, this operation is well defined, cf. [Gra\u030868, p.36].\nLet A1 = (A1, \u03b81) and A2 = (A2, \u03b82) be two \u03a3-algebras. Moreover, let h : A1 \u2192 A2 be a mapping. Then h is a \u03a3-algebra homomorphism (from A1 to A2) if, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and for every v1, . . . , vk \u2208 A1, we have\nh(\u03b81(\u03c3)(v1, . . . , vk)) = \u03b82(\u03c3)(h(v1), . . . , h(vk)) . (2.8)\nIf h is bijective, then h is a \u03a3-algebra isomorphism. If there exists such an isomorphism, then we say that A1 and A2 are isomorphic and we denote this fact by A1 \u223c= A2.\nLemma 2.6.2. [Gra\u030868, \u00a77, Lm. 3] Let (A1, \u03b81) and (A2, \u03b82) be two \u03a3-algebras, and let h : A1 \u2192 A2 be a \u03a3-algebra homomorphism. Then im(h) is closed under the operations in \u03b82(\u03a3). Hence (im(h), \u03b82) is a subalgebra of (A2, \u03b82).\nTheorem 2.6.3. [Gra\u030868, \u00a77, Lm. 5] Let (A1, \u03b81), (A2, \u03b82), and (A3, \u03b83) be three \u03a3-algebras. Moreover, let h : A1 \u2192 A2 and g : A2 \u2192 A3 be two \u03a3-algebra homomorphisms. Then g \u25e6 h is a \u03a3-algebra homomorphism.\nLet h be a \u03a3-algebra homomorphism from (A1, \u03b81) to (A2, \u03b82). The kernel of h, denoted by ker(h), is the equivalence relation on A1 defined by ker(h) = {(a1, a2) \u2208 A1 \u00d7A1 | h(a1) = h(a2)}.\nTheorem 2.6.4. [Gra\u030868, \u00a77, Lm. 6], [Gra\u030868, \u00a711, Thm. 1] Let h be a \u03a3-algebra homomorphism from A1 = (A1, \u03b81) to A2 = (A2, \u03b82). Then ker(h) is a congruence relation on A1. Moreover, if h is surjective, then A1/ ker(h) \u223c= A2.\nLet K be a set of \u03a3-algebras, A = (A, \u03b8) be a \u03a3-algebra, and H \u2286 A. The algebra A is called freely generated by H over K if the following conditions hold:\n(a) A \u2208 K, (b) A = \u3008H\u3009\u03b8(\u03a3), and (c) for every \u03a3-algebra A\u2032 = (A\u2032, \u03b8\u2032) \u2208 K and mapping f : H \u2192 A\u2032, there exists a unique extension of\nf to a \u03a3-algebra homomorphism h : A\u2192 A\u2032 from A to A\u2032.\nThe set H is called generator set. If H = \u2205, then A is called initial in K. In this case, for each A\u2032 = (A\u2032, \u03b8\u2032) \u2208 K there exists exactly one \u03a3-algebra homomorphism h : A\u2192 A\u2032 from A to A\u2032.\nTheorem 2.6.5. [Gra\u030868, \u00a724, Thm. 1] Let K be a set of \u03a3-algebras. Any two algebras freely generated by the same generator set over K are isomorphic.\nIn each of the Subsections 2.6.4 \u2013 2.6.6 we will consider particular ranked alphabets \u03a3 and consider the set of all \u03a3-algebras or the set of those \u03a3-algebras which satisfy certain algebraic laws (cf. Subsection 2.6.3). Then \u03a3 is clear from the context and can be neglected in both the name and the notation. In this case, we call a \u03a3-algebra A = (A, \u03b8) an algebra and specify it by its carrier set A and by listing all its operations, i.e., we write A = (A, \u03b8(\u03c31), . . . , \u03b8(\u03c3n)), where \u03a3 = {\u03c31, . . . , \u03c3n}."
        },
        {
            "heading": "2.6.3 Properties of binary operations",
            "text": "Let B be a nonempty set. Let \u2299 be a binary operation on B. The operation \u2299 is"
        },
        {
            "heading": "20 CHAPTER 2. PRELIMINARIES",
            "text": "\u2022 associative if (a\u2299 b)\u2299 c = a\u2299 (b \u2299 c) for every a, b, c \u2208 B, \u2022 commutative if a\u2299 b = b\u2299 a for every a, b \u2208 B, \u2022 idempotent if a\u2299 a = a for each a \u2208 B, \u2022 extremal if a\u2299 b \u2208 {a, b} for every a, b \u2208 B.\nObviously, extremal implies idempotent. The other direction does not hold, e.g., the set union \u222a is idempotent but in general not extremal.\nAn element e \u2208 B is an identity element (of \u2299) if e\u2299 a = a\u2299 e = a for every a \u2208 B. There is at most one identity element. Let e \u2208 B be an identity element and a \u2208 B. An element a \u2208 B is an inverse of a (with respect to \u2299) if a\u2299 a = a\u2299 a = e. If an inverse of a exists, then we also say that a has an inverse. If \u2299 is associative, then each element has at most one inverse.\nLet \u2295 and \u2297 be two binary operations on B. The operation \u2297 is\n\u2022 right-distributive (with respect to \u2295), if (a\u2295 b)\u2297 c = (a\u2297 c)\u2295 (b\u2297 c) for every a, b, c \u2208 B, \u2022 left-distributive (with respect to \u2295), if a\u2297 (b\u2295 c) = (a\u2297 b)\u2295 (a\u2297 c) for every a, b, c \u2208 B, \u2022 distributive (with respect to \u2295) if it is both right-distributive and left-distributive (with respect to \u2295).\nClearly, if \u2297 is commutative, then right-distributivity implies left-distributivity and vice versa. Moreover, \u2295 and \u2297 satisfy the absorption axiom if\n\u2022 a\u2297 (a\u2295 b) = a and a\u2295 (a\u2297 b) = a for every a, b \u2208 B."
        },
        {
            "heading": "2.6.4 Semigroups, monoids, and groups",
            "text": "In this subsection we recall the definitions of semigroups, monoids, and groups in the form described in the last paragraph of Subsection 2.6.2. Moreover, we define extensions of the underlying binary operations to finitely many and countably many arguments.\n\u2022 A semigroup is an algebra (B,\u2299) where \u2299 is an associative binary operation on B. \u2022 A monoid is an algebra (B,\u2299, e) where (B,\u2299) is a semigroup and e is an element of B which is an identity element of \u2299. We note that the identity element e can be considered as a nullary operation on B. \u2022 A group is a monoid (B,\u2299, e) such that each a \u2208 B has an inverse. We note that the inverses of the elements can be defined in terms of a unary operation on B.\nThe semigroup (B,\u2299) is commutative if \u2299 is commutative. Similarly, we define commutative monoids and commutative groups.\nObservation 2.6.6. Let (B,\u2299) be a semigroup such that \u2299 is commutative and idempotent. Then (B,\u2299) is locally finite.\nProof. Let H be a finite subset of B. We note that \u3008H\u3009{\u2299} = {b1 \u2299 . . . \u2299 bn | n \u2208 N+, b1, . . . , bn \u2208 H}. Let us abbreviate this set by \u3008H\u3009.\nBy induction on (N+,\u227aN+), where \u227aN+= {(n, n+ 1) | n \u2208 N+}, we prove the following statement.\nFor each n \u2208 N+ and every b1, . . . , bn \u2208 H , there exist m \u2208 N+ (2.9)\nand pairwise different c1, . . . , cm \u2208 H such that b1 \u2299 . . .\u2299 bn = c1 \u2299 . . .\u2299 cm.\nI.B.: For n = 1 the statement is trivially true.\nI.S.: Let b = b1 \u2299 \u00b7 \u00b7 \u00b7 \u2299 bn+1 with n \u2208 N+. By I.H. there exist m \u2208 N+ and pairwise different c1, . . . , cm \u2208 H such that b1 \u2299 . . .\u2299 bn = c1 \u2299 . . .\u2299 cm.\nIf bn+1 6\u2208 {c1, . . . , cm}, then (2.9) holds with m+ 1 by letting cm+1 = bn+1. Otherwise bn+1 = ci for some i \u2208 [m]. Then, by commutativity and idempotency, we have\nb1 \u2299 \u00b7 \u00b7 \u00b7 \u2299 bn+1 = c1 \u2299 . . .\u2299 cm \u2299 bn+1 = c1 \u2299 . . .\u2299 ci \u2299 bn+1 \u2299 . . .\u2299 cm = c1 \u2299 . . .\u2299 cm ."
        },
        {
            "heading": "2.6. ALGEBRAIC STRUCTURES 21",
            "text": "Thus (2.9) holds with m. This proves (2.9). Since H is finite, by (2.9) also \u3008H\u3009 is finite.\nNext we consider a monoid (B,\u2299, e) and formalize two ways of extending \u2299 to finitely many arguments. Let I be a finite set with I = {i1, . . . , ik} for some k \u2208 N. If (a) I \u2286 N and i1 < . . . < ik, where < is the usual total order \u201cless than\u201d on natural numbers or (b) \u2299 is commutative, then we define the operation\u2299\nI : B I \u2192 B such that, for each I-indexed family (bi | i \u2208 I) of elements in B, we have\n\u2299 I (bi | i \u2208 I) = { bi1 \u2299 . . .\u2299 bik if I 6= \u2205 e otherwise .\n(2.10)\nWe abbreviate \u2299 I(bi | i \u2208 I) by \u2299 (bi | i \u2208 I) or \u2299 i\u2208I bi. Thus, in particular, \u2299\ni\u2208[k] bi = b1 \u2299 . . .\u2299 bk for each k \u2208 N+, and \u2299 i\u2208\u2205 bi = e.\nObservation 2.6.7. Let I be a finite and nonempty index set such that I \u2286 N or \u2299 is commutative. If \u2299 is extremal, then for each I-indexed family (bi | i \u2208 I) over B there exists a j \u2208 I such that bj = \u2299 i\u2208I bi.\nNext let (B,\u2299, e) be commutative. We introduce a notation for the case that the index set is the Cartesian product of two sets as follows. Let I and J be finite sets and (b(i,j) | (i, j) \u2208 I \u00d7 J) be an (I \u00d7 J)-indexed family over B. Then it follows from commutativity and associativity that\n\u2299\n(i,j)\u2208I\u00d7J\nb(i,j) = \u2299\ni\u2208I\n\u2299\nj\u2208J\nb(i,j) .\nOften we will abbreviate the expression \u2299\ni\u2208I \u2299 j\u2208J b(i,j) by \u2299 i\u2208I,j\u2208J b(i,j). We will use this kind of\nabbreviation also in the case where the index set is the Cartesian product of finitely many sets.\nFinally, we consider a commutative monoid (B,\u2299, e) and identify algebraic laws such that \u2299 can be extended to countably many arguments. We call (B,\u2299, e) \u03c3-complete if, for each countable index set I, there exists a mapping \u2211\u2299\nI\n: BI \u2192 B such that for each I-indexed family (bi | i \u2208 I) over B the\nequalities (2.11) and (2.12) below are satisfied (cf. [Eil74, p. 124]) using \u2211\u2299\ni\u2208I\nbi as abbreviation for\n\u2211\u2299\nI\n(bi | i \u2208 I):\nIf I = {j}, then \u2211\u2299\ni\u2208I\nbi = bj, and if I = {j, j \u2032}, then\n\u2211\u2299\ni\u2208I\nbi = bj \u2299 bj\u2032 (2.11)\n\u2211\u2299\ni\u2208I\nbi = \u2211\u2299\nj\u2208J\n( \u2211\u2299\ni\u2208Ij\nbi) for every countable set J and partitioning (Ij | j \u2208 J) of I. (2.12)\nObservation 2.6.8. Let (B,\u2299, e) be a \u03c3-complete monoid. The following statements hold.\n(1) For each \u2205-indexed family (bi | i \u2208 \u2205) over B, we have \u2211\u2299\nj\u2208\u2205\nbj = e.\n(2) For each finite I-indexed family (bi | i \u2208 I) of elements of B, we have \u2211\u2299\ni\u2208I\nbi = \u2299 i\u2208I bi .\n(3) For each countable index set I, we have \u2211\u2299\nj\u2208I\ne = e.\nProof. Proof of (1): Let I = {1}. We consider the I-indexed family (bi | i \u2208 I) over B where b1 is an arbitrary element of B (recall that B 6= \u2205). Moreover, let J = {1, 2}, I1 = \u2205, and I2 = I. Then we have\nb1 = \u2211\u2299\ni\u2208I\nbi (by (2.11))\n22 CHAPTER 2. PRELIMINARIES\n= \u2211\u2299\nj\u2208J\n(\u2211\u2299\ni\u2208Ij\nbi ) = (\u2211\u2299\ni\u2208I1\nbi ) \u2299 (\u2211\u2299\ni\u2208I2\nbi )\n(by (2.12))\n= (\u2211\u2299\ni\u2208\u2205\nbi ) \u2299 b1 . (by (2.11))\nSince \u2299 is commutative, also b1 \u2299 (\u2211\u2299\ni\u2208\u2205\nbi ) = b1. Hence \u2211\u2299\ni\u2208\u2205\nbi is an identity element, and hence\n\u2211\u2299\ni\u2208\u2205\nbi = e.\nProof of (2): Let (bi | i \u2208 I) be a finite I-indexed family of elements of B. If I = \u2205, then the statement follows from Statement (1) and (2.10). If I 6= \u2205, then we can prove by induction on N the following statement:\nFor every n \u2208 N and index set I with |I| = n+ 1, we have \u2211\u2299\ni\u2208I\nbi = \u2299\ni\u2208I\nbi (2.13)\nI.B.: For n = 0, this follows from (2.11) and (2.10).\nI.S.: Now let n \u2208 N+ and |I| = n+1. Moreover, let (bi | i \u2208 I) be a finite I-indexed family of elements of B. Let i\u2032 \u2208 I be an arbitrary index. Using J = {1, 2} and I1 = {i\u2032} and I2 = I \\ {i\u2032}, we have:\n\u2211\u2299\ni\u2208I\nbi = \u2211\u2299\nj\u2208J\n( \u2211\u2299\ni\u2208Ij\nbi) = ( \u2211\u2299\ni\u2208{i\u2032}\nbi)\u2299 ( \u2211\u2299\ni\u2208I\\{i\u2032}\nbi) (by (2.12))\n= bi\u2032 \u2299 \u2299\ni\u2208I\\{i\u2032}\nbi (by (2.11) and I.H.)\n= \u2299\ni\u2208I\nbi .\nThen Statement (2) follows from (2.13).\nProof of (3): Let Ij = \u2205 for every j \u2208 I. Then (Ij | j \u2208 I) is a partitioning of \u2205. Hence we have\n\u2211\u2299\nj\u2208I\ne = \u2211\u2299\nj\u2208I\n( \u2299\ni\u2208Ij\ne) (by (2.10))\n= \u2211\u2299\nj\u2208I\n( \u2211\u2299\ni\u2208Ij\ne) (by Statement (2))\n= \u2211\u2299\nj\u2208\u2205\ne (because \u22c3 j\u2208I Ij = \u2205 and by (2.12))\n= e (by Statement (1))\nLet (bi | i \u2208 I) be an I-indexed family over B. Moreover, let P \u2286 B be a property. Then we denote by (bi | i \u2208 I, bi \u2208 P ) the I \u2032-indexed family (bi | i \u2208 I \u2032) over B where I \u2032 = {i \u2208 I | bi \u2208 P}. Also, we abbreviate \u2299 (bi | i \u2208 I, bi \u2208 P ) by \u2299\ni\u2208I: bi\u2208P\nbi and \u2211\u2299 I (bi | i \u2208 I, bi \u2208 P ) by \u2211\u2299\ni\u2208I: bi\u2208P\nbi."
        },
        {
            "heading": "2.6.5 Strong bimonoids, semirings, rings, and fields",
            "text": "A strong bimonoid [DSV10, Rad10, CDIV10, DV10, DV12] is an algebra B = (B,\u2295,\u2297, 0, 1) where (B,\u2295, 0) is a commutative monoid, (B,\u2297, 1) is a monoid, 0 6= 1, and 0 is an annihilator for \u2297, i.e.,"
        },
        {
            "heading": "2.6. ALGEBRAIC STRUCTURES 23",
            "text": "b\u22970 = 0\u2297b = 0 holds for every b \u2208 B. The operations \u2295 and \u2297 are called summation and multiplication, respectively.\nLet B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid. It is\n\u2022 commutative, if \u2297 is commutative, \u2022 left-distributive, if \u2297 is left-distributive (with respect to \u2295), \u2022 right-distributive, if \u2297 is right-distributive (with respect to \u2295), \u2022 distributive, if \u2297 is left-distributive and right-distributive (with respect to \u2295), \u2022 \u03c3-complete if (B,\u2295, 0) is \u03c3-complete, and , \u2022 bi-locally finite if (B,\u2295, 0) and (B,\u2297, 1) are locally finite.\nWe declare that the precedence order of the two operations in expressions is as follows: first \u2297, second \u2295. Using this convention, we can save some parentheses in expressions over B which use both operations. For instance\n\u2295\ni\u2208I\n(bi \u2297 b) can be written as \u2295\ni\u2208I\nbi \u2297 b\nfor each finite index set I, I-indexed family (bi | i \u2208 I), and b \u2208 B. Similarly, if B is \u03c3-complete, then \u2211\u2295\ni\u2208I\n(bi \u2297 b) can be written as \u2211\u2295\ni\u2208I\nbi \u2297 b\nfor each countable index set I, I-indexed family (bi | i \u2208 I), and b \u2208 B.\nA semiring [HW93, Gol99] is a strong bimonoid B = (B,\u2295,\u2297, 0, 1) which is distributive. Clearly, if B is a semiring, then for every finite and nonempty family (bi | i \u2208 I) and b \u2208 B the following equalities hold: \u2295 i\u2208I b\u2297 bi = b\u2297 ( \u2295 i\u2208I bi) and \u2295 i\u2208I bi \u2297 b = ( \u2295 i\u2208I bi)\u2297 b.\nA semiring (B,\u2295,\u2297, 0, 1) is \u03c3-complete if (B,\u2295, 0) is \u03c3-complete and the following equalities hold for every countable index set I, I-indexed family (bi | i \u2208 I), and b \u2208 B:\n\u2211\u2295\ni\u2208I\nb \u2297 bi = b\u2297 ( \u2211\u2295\ni\u2208I\nbi) and \u2211\u2295\ni\u2208I\nbi \u2297 b = ( \u2211\u2295\ni\u2208I\nbi)\u2297 b . (2.14)\nWe note that for semirings \u03c3-completeness is slightly more general than completeness (cf. e.g. [Eil74, p. 125] and [E\u0301K03]) because completeness requires the extension of \u2295 not only for countable but arbitrary index sets I.\nLet (B,\u2295,\u2297, 0, 1) be a semiring. It is a\n\u2022 ring if (B,\u2295, 0) is a commutative group (where we usually denote the inverse of a \u2208 B with respect to \u2295 by \u2212a), \u2022 semifield (or: division semiring) if (B \\ {0},\u2297, 1) is a group (where we usually denote the inverse of a \u2208 B with respect to \u2297 by a\u22121), and \u2022 field if it is a ring and a commutative semifield.\nNext we give a number of examples. We start with examples of semirings because they are more familiar than strong bimonoids.\nExample 2.6.9. Here we show examples of semirings, rings, semifields, and fields. If an example shows a \u03c3-complete semiring, i.e., there exists a mapping \u2211\u2295 which satisfies equalities (2.11), (2.12), and (2.14),\nthen we give such a mapping.\n1. The Boolean semiring Boole = (B,\u2228,\u2227, 0, 1), where B = {0, 1} (the truth values) and \u2228 and \u2227 denote disjunction and conjunction, respectively. The Boolean semiring Boole is \u03c3-complete with the mapping\n\u2211\u2228\nI\n: BI \u2192 B with (bi | i \u2208 I) 7\u2192\n{ 1 if there exists i \u2208 I such that bi = 1\n0 otherwise ."
        },
        {
            "heading": "24 CHAPTER 2. PRELIMINARIES",
            "text": "We note that Boole is a semifield.\n2. The semiring Nat = (N,+, \u00b7, 0, 1) of natural numbers, where + and \u00b7 are the usual addition and multiplication.\n3. The semiring Nat\u221e = (N\u221e,+, \u00b7, 0, 1) of natural numbers, where + and \u00b7 are extended to N\u221e in the natural way. The semiring Nat\u221e is \u03c3-complete with the mapping\n\u2211+\nI\n: (N\u221e) I \u2192 N\u221e with (ni | i \u2208 I) 7\u2192    +i\u2208J nj if {ni | i \u2208 I} \u2286 N and J = {i \u2208 I | ni 6= 0} is finite\n\u221e otherwise .\n(We recall that + denotes the extension of + to finite sums in the monoid (N,+, 0).)\n4. The ring Int = (Z,+, \u00b7, 0, 1) of integers.\n5. The ring Intmod4 = ({0, 1, 2, 3},+4, \u00b74, 0, 1) where +4 and \u00b74 are the usual addition modulo 4 and the usual multiplication modulo 4, respectively.\n6. The field Rat = (Q,+, \u00b7, 0, 1) of rational numbers and the field Real = (R,+, \u00b7, 0, 1) of real numbers.\n7. There exist only two semirings ({0, 1},\u2295,\u2297, 0, 1) with exactly two elements because, for every a, b \u2208 {0, 1} and \u2299 \u2208 {\u2295,\u2297}, the value of a \u2299 b is determined by the strong bimonoid axioms, except the value of 1\u2295 1.\n(a) If we define 1 \u2295 1 = 0, then ({0, 1},\u2295,\u2297, 0, 1) is a field, denoted by F2; we have \u22120 = 0 and \u22121 = 1\u22121 = 1. (b) If we define 1\u2295 1 = 1, then ({0, 1},\u2295,\u2297, 0, 1) is the Boolean semiring Boole.\n8. The arctic semiring Natmax,+ = (N\u2212\u221e,max,+,\u2212\u221e, 0). The arctic semiring is often called max-plus semiring.\n9. The semiring Natmax,+,n = ([0, n]\u2212\u221e,max, +\u0302n,\u2212\u221e, 0) where n \u2208 N+, [0, n]\u2212\u221e = [0, n] \u222a {\u2212\u221e}, and b1+\u0302nb2 = min(b1 + b2, n) for every b1, b2 \u2208 [0, n]\u2212\u221e [Gol99, Ex. 1.8]. The semiring Natmax,+,n is \u03c3-complete with the mapping\n\u2211max\nI\n: ([0, n]\u2212\u221e) I \u2192 [0, n]\u2212\u221e with (ni | i \u2208 I) 7\u2192 sup(ni | i \u2208 I) .\n10. The tropical semiring Natmin,+ = (N\u221e,min,+,\u221e, 0) over N. The tropical semiring Natmin,+ is \u03c3-complete with the mapping\n\u2211min\nI\n: (N\u221e) I \u2192 N\u221e with (ni | i \u2208 I) 7\u2192 inf(ni | i \u2208 I) .\nThe tropical semiring is often called the min-plus semiring.\n11. The semiring Natmax,min = (N\u221e,max,min, 0,\u221e). It is \u03c3-complete with the mapping\n\u2211max\nI\n: (N\u221e) I \u2192 N\u221e with (ni | i \u2208 I) 7\u2192    sup(ni | i \u2208 I) if {ni | i \u2208 I} \u2286 N and it is finite\n\u221e otherwise .\n12. The semiring of formal languages Lang\u0393 = (P(\u0393 \u2217),\u222a, \u00b7, \u2205, {\u03b5}) where \u00b7 denotes the concatenation\nof languages. The semiring Lang\u0393 is \u03c3-complete with the mapping\n\u2211\u222a\nI\n: P(\u0393\u2217)I \u2192 P(\u0393\u2217) with (Li | i \u2208 I) 7\u2192 \u22c3\ni\u2208I\nLi ."
        },
        {
            "heading": "2.6. ALGEBRAIC STRUCTURES 25",
            "text": "13. The Viterbi semiring Viterbi = ([0, 1],max, \u00b7, 0, 1) where [0, 1] denotes the set {r \u2208 R | 0 \u2264 r \u2264 1} of real numbers1. The Viterbi semiring is \u03c3-complete with the mapping\n\u2211max\nI\n: [0, 1]I \u2192 [0, 1] with (ri | i \u2208 I) 7\u2192 sup(ri | i \u2208 I) .\nThe Viterbi semiring can be used for calculations with probabilities, and it is isomorphic to (R\u22650,\u221e,min,+,\u221e, 0) where R\u22650,\u221e denotes the set {r \u2208 R | r \u2265 0} \u222a {\u221e}. The isomorphism from [0, 1] to [0,\u221e] is x 7\u2192 \u2212 ln(x).\n14. The tropical semifield Intmin,+ = (Z\u221e,min,+,\u221e, 0) over Z, and correspondingly the tropical semifield Ratmin,+ = (Q\u221e,min,+,\u221e, 0) over Q.\n15. The semifields Rat\u22650 = (Q\u22650,+, \u00b7, 0, 1) and Real\u22650 = (R\u22650,+, \u00b7, 0, 1).\n16. The log semifield (R\u2212\u221e,\u2295,+,\u2212\u221e, 0) with x\u2295 y = ln(e x + ey).\n17. Let B = (B,\u2297, 1) be a monoid. In the canonical way, we extend the operation \u2297 to finite sets of elements of B, i.e., for every A1, A2 \u2208 Pfin(B) we let A1 \u2297A2 = {a\u2297 b | a \u2208 A1, b \u2208 A2}. Then the algebraic structure (Pfin(B),\u222a,\u2297, \u2205, {1}) is a semiring. We denote it by Sem(B).\n18. Let A be a set. Then PSA = (P(A),\u222a,\u2229, \u2205, A) is a semiring. It is \u03c3-complete with the mapping\n\u2211\u222a\nI\n: P(A)I \u2192 P(A) with (Ai | i \u2208 I) 7\u2192 \u22c3\ni\u2208I\nAi .\nMoreover, the monoid (P(A),\u2229, A) is \u03c3-complete with the mapping\n\u2211\u2229\nI\n: P(A)I \u2192 P(A) with (Ai | i \u2208 I) 7\u2192 \u22c2\ni\u2208I\nAi .\nIn the literature (e.g., [Gra\u030868, p. 4]), often the expressions \u2211\u222a I (Ai | i \u2208 I) and\n\u2211\u222a\ni\u2208I\nAi are written\nas \u22c3 (Ai | i \u2208 I). Similarly, \u2211\u2229 I (Ai | i \u2208 I) and\n\u2211\u2229\ni\u2208I\nAi are written as \u22c2 (Ai | i \u2208 I). In this book,\nwe will also use these notations from the literature.\n19. Let (B,\u2295,\u2297, 0, 1) be a semiring. Then (B[x],+, \u00b7, p0, p1) is a semiring called polynomial semiring, where B[x] is the set of all N-indexed families (ai | i \u2208 N) over B such that the set {i \u2208 N | ai 6= 0} is finite. Moreover, for every p = (ai | i \u2208 N) and q = (bi | i \u2208 N) in B[x] we define p+ q = (ci | i \u2208 N) by letting ci = ai\u2295bi for each i \u2208 N, and we define p\u00b7q = (di | i \u2208 N) by letting di = \u2295 j\u2208[0,i] aj\u2297bi\u2212j .\nFinally, the polynomials p0 and p1 are defined by p0 = (ai | i \u2208 N) with ai = 0 for each i \u2208 N and p1 = (ai | i \u2208 N) with a0 = 1 and ai = 0 for each i \u2265 1. If B is commutative, then also B[x] is commutative, and if B is a ring, then also B[x] is a ring.\nExample 2.6.10. In [DSV10, Ex. 1],[CDIV10, Ex. 2.2], [DV12, Ex. 2.1], and [DFKV22, Ex. 2.2, 2.3] a number of examples of strong bimonoids are give, and in [DV12, Ex. 2.1.4] a general construction principle for strong bimonoids is given, which we recall here. The first two examples are \u03c3-complete strong bimonoids, and we show the mappings \u2211\u2295\nI\nwhich satisfy equalities (2.11) and (2.12).\n1not to be confused with the set [0, 1] = {0, 1} of natural numbers."
        },
        {
            "heading": "26 CHAPTER 2. PRELIMINARIES",
            "text": "1. The algebra TropBM = (N\u221e,+,min, 0,\u221e) is a commutative strong bimonoid, called the tropical bimonoid. However, it is not bi-locally finite. Moreover, it is not a semiring, because there exist a, b, c \u2208 N\u221e with min(a, b + c) 6= min(a, b) + min(a, c) (e.g., take a = b = c 6= 0). The strong bimonoid TropBM is \u03c3-complete with the mapping\n\u2211+\nI\n: (N\u221e) I \u2192 N\u221e with (ni | i \u2208 I) 7\u2192    +i\u2208J nj if {ni | i \u2208 I} \u2286 N and J = {i \u2208 I | ni 6= 0} is finite\n\u221e otherwise .\n2. For each \u03bb \u2208 R with 0 < \u03bb < 12 , let Trunc\u03bb = (B,\u2295,\u2299, 0, 1) be the algebra, where\n\u2022 B = {0} \u222a {b \u2208 R | \u03bb \u2264 b \u2264 1}, \u2022 a\u2295 b = min(a+ b, 1), and \u2022 a\u2299 b = a \u00b7 b if a \u00b7 b \u2265 \u03bb, and 0 otherwise,\nand where + and \u00b7 are the usual addition and multiplication of real numbers, respectively. Then Trunc\u03bb is a bi-locally finite and commutative strong bimonoid. It is \u03c3-complete with the mapping:\n\u2211\u2295\nI\n: BI \u2192 B with (ni | i \u2208 I) 7\u2192\n{ min (\u2295 i\u2208J nj , 1 ) if J = {i \u2208 I | ni 6= 0} is finite\n1 otherwise .\nWe note that Trunc\u03bb is not a semiring because \u2299 is not right-distributive. For instance, for a = b = 0.9, and c = \u03bb, we have (a\u2295 b)\u2299 c = \u03bb, while (a\u2299 c)\u2295 (b\u2299 c) = 0 because a\u2299 c = b\u2299 c = 0.\nIf \u03bb = 14 , then Trunc\u03bb is not locally finite, because the set H = \u3008{ 1 2}\u3009{\u2295,\u2299} is infinite. We can show this as follows [Dro19]. Let (bi | i \u2208 N) such that\nbi =   \n1 2 if i = 0 1 2 \u00b7 bi\u22121 if i is odd 1 2 + bi\u22121 if i is even and i 6= 0\nThen, e.g., b0 = 1/2, b1 = 1/4, b2 = 1/2 + 1/4 = 3/4, b3 = 3/8, b4 = 1/2 + 3/8 = 7/8, b5 = 7/16, b6 = 1/2 + 7/16 = 15/16, b7 = 15/32, b8 = 1/2 + 15/32 = 31/32, b9 = 31/64, b10 = 1/2 + 31/64 = 63/64, etc. (In fact, the subsequences (bi | i \u2208 N, i is even) and (bi | i \u2208 N, i is odd) converge to 1 and 12 , respectively.) It is easy to see that bi \u2208 \u3008{ 1 2}\u3009{\u2295,\u2299} for each i \u2208 N, and that bi 6= bj for every i, j \u2208 N with i 6= j. Hence (bi | i \u2208 N) is an infinite family of elements in \u3008{ 1 2}\u3009{\u2295,\u2299}, and thus Trunc\u03bb is not locally finite.\n3. The algebra ([0, 1],\u2295, \u00b7, 0, 1) with interval [0, 1] = {r \u2208 R | 0 \u2264 r \u2264 1} of real numbers and the usual multiplication \u00b7 of real numbers is a strong bimonoid for each of the following two definitions of \u2295 for every a, b \u2208 [0, 1]:\n\u2022 a\u2295 b = a+ b\u2212 a \u00b7 b (called algebraic sum in [KY95]) and \u2022 a\u2295 b = min(a+ b, 1) (called bounded sum in [KY95]).\nIf \u2295 is the algebraic sum, then we denote the algebra by UnitIntalg; if \u2295 is the bounded sum, then we denote the algebra by UnitIntbs. Neither UnitIntalg nor UnitIntbs is a semiring.\n4. Let [0, 1] = {r \u2208 R | 0 \u2264 r \u2264 1} and let i be a binary operation on [0, 1]. We say that i is a t-norm (or: fuzzy intersection, cf. [KY95, p. 62]) if i satisfies the following conditions:\n(a) i is commutative and associative, (b) i(a, 1) = a for each a \u2208 [0, 1] (boundary condition), and (c) a \u2264 b implies i(c, a) \u2264 i(c, b) for every a, b, c \u2208 [0, 1] (monotonicity condition).\nMoreover, let u be a binary operation on [0, 1]. We say that u is a t-conorm (or: fuzzy union, cf. [KY95, p. 77]) if u satisfies the the following conditions:"
        },
        {
            "heading": "2.6. ALGEBRAIC STRUCTURES 27",
            "text": "(a) u is commutative and associative, (b) u(a, 0) = a for each a \u2208 [0, 1] (boundary condition), and (c) a \u2264 b implies u(c, a) \u2264 u(c, b) for every a, b, c \u2208 [0, 1] (monotonicity condition).\nDue to the boundary conditions, ([0, 1], u, 0) and ([0, 1], i, 1) are commutative monoids. Since i(a, 0) = i(0, a) \u2264 i(0, 1) = 0 for each a \u2208 [0, 1] (cf. [KY95, Thm. 3.10]), we have that\nUnitIntu,i = ([0, 1], u, i, 0, 1)\nis a commutative strong bimonoid for each t-conorm u and each t-norm i.\nThere are combinations of t-conorm u and t-norm i such that the strong bimonoid UnitIntu,i is not distributive. This is the case, e.g., for the t-conorm bounded sum (cf. Example 2.6.10(3)) and the t-norm bounded difference i(a, b) = max(0, a+ b \u2212 1). We also refer to [KY95, Thm. 3.24] for sufficient conditions under which UnitIntu,i is not distributive.\n5. Let (C,+, 0) be a commutative monoid. We consider the set B of all mappings f : C \u2192 C such that f(0) = 0. Moreover, we extend + to B by a pointwise addition on elements of B, i.e., for every f, g \u2208 B and c \u2208 C, we define (f + g)(c) = f(c) + g(c). Also, we define the operation \u22c4 on B such that, for every f, g \u2208 B and c \u2208 C, we have (f \u22c4 g)(c) = g(f(c)). Finally, we denote by 0\u0303 the mapping 0\u0303 : C \u2192 C such that 0\u0303(c) = 0 for each c \u2208 C. Then\nNearSemC = (B,+, \u22c4, 0\u0303, idC)\nis a strong bimonoid. Such an algebra is called a near semiring (over C) [vHvR67, Kri05]. We note that the condition f(0) = 0 is needed to guarantee that 0\u0303 \u22c4 f = 0\u0303. Except for trivial cases, the operation \u22c4 is left-distributive over +, but not right-distributive.\nAs example we consider the commutative monoid (P(Q),\u222a, \u2205) for some set Q. Then we consider the near semiring (B,\u222a, \u22c4, 0\u0303, idP(Q)) as described above, i.e.,\n\u2022 B = {f | f : P(Q)\u2192 P(Q), f(\u2205) = \u2205}, \u2022 (f \u222a g)(U) = f(U) \u222a g(U) and (f \u22c4 g)(U) = g(f(U)) for every f, g \u2208 B and U \u2208 P(Q), and \u2022 0\u0303(U) = \u2205 and idP(Q)(U) = U for each U \u2208 P(Q).\nIt is easy to see that the operation \u22c4 is left-distributive over \u222a. However, it is not right-distributive over \u222a if |Q| \u2265 2. To show this, let p, q \u2208 Q with p 6= q and let f, g, h \u2208 B such that for every U \u2208 P(Q):\nf(U) =\n{ {p} if U = {p}\n\u2205 otherwise , g(U) =\n{ {q} if U = {p}\n\u2205 otherwise , and h(U) =\n{ \u2205 if |U | = 2\nU otherwise.\nThen ((f \u222a g) \u22c4 h)({p}) = h({p, q}) = \u2205 and ((f \u22c4 h) \u222a (g \u22c4 h))({p}) = h({p}) \u222a h({q}) = {p, q}.\n6. We consider the strong bimonoid (\u0393\u2217 \u222a {\u221e},\u2227, \u00b7,\u221e, \u03b5) where\n\u2022 \u2227 is the longest common prefix operation, \u2022 \u00b7 is the usual concatenation of strings, and \u2022 \u221e is a new element such that s\u2227\u221e =\u221e\u2227 s = s and s \u00b7\u221e =\u221e\u00b7 s =\u221e for each s \u2208 \u0393\u2217\u222a{\u221e}.\nThis bimonoid occurs in investigations for natural language processing, see [Moh00]. It is clear that (\u0393\u2217 \u222a {\u221e},\u2227, \u00b7,\u221e, \u03b5) is left-distributive but not right-distributive (consider, e.g., if \u0393 = {a, b, c}, then abc = (a \u2227 ab) \u00b7 bc 6= (a \u00b7 bc) \u2227 (ab \u00b7 bc) = ab).\n7. There exist only two strong bimonoids ({0, 1},\u2295,\u2297, 0, 1) with exactly two elements: the Boolean semiring Boole and the field F2; in particular, both are semirings (cf. Example 2.6.9(7)). However, there exist strong bimonoids with three elements which are not semirings, take, e.g., Three = ({0, 1, 2},max, \u00b7\u0302, 0, 1) where a \u00b7\u0302 b = (a \u00b7 b) mod 3 for every a, b \u2208 {0, 1, 2}; there max(2 \u00b7\u0302 2, 2 \u00b7\u03021) 6= 2 \u00b7\u0302 max(1, 2)."
        },
        {
            "heading": "28 CHAPTER 2. PRELIMINARIES",
            "text": "8. We consider the algebra (N0,\u2295,+, 0, 0), where N0 = N \u222a {0} for some new element 0 6\u2208 N. The binary operation \u2295, if restricted to N, and the binary operation +, if restricted to N, are the usual addition on natural numbers (e.g. 3 + 2 = 5). Moreover, 0\u2295 x = x\u2295 0 = x and 0+ x = x+ 0 = 0 for each x \u2208 N0. Thus, (N0,\u2295,+, 0, 0) is a strong bimonoid. However, it is not a semiring (e.g., 2+ (3\u2295 4) 6= (2+ 3)\u2295 (2+ 4)). We might call this algebra the plus-plus strong bimonoid of natural numbers and denote it by PPN.\n9. We recall the strong bimonoid Stb = (N,\u2295,\u2299, 0, 1) from [DSV10, Ex. 25]2. Intuitively, both operations are commutative and consider their maximal argument, say, b. Then, depending on the characteristic of b being even or odd, \u2295 delivers b or b+1, respectively, and dually, \u2299 delivers b+1 or b, respectively.\nFormally, the two commutative operations \u2295 and \u2299 on N are defined as follows. First, let 0\u2295a = a, 0 \u2299 a = 0, and 1 \u2299 a = a for every a \u2208 N. If a, b \u2208 N \\ {0} with a \u2264 b, we put (with + being the usual addition on N)\na\u2295 b =\n{ b if b is even\nb+ 1 if b is odd.\nIf a, b \u2208 N \\ {0, 1} with a \u2264 b, let\na\u2299 b =\n{ b+ 1 if b is even\nb if b is odd.\nThen Stb = (N,\u2295,\u2299, 0, 1) is a strong bimonoid. Clearly, it is not a semiring because, e.g., 2\u2299 (2\u2295 3) = 2 \u2299 4 = 5 and (2 \u2299 2) \u2295 (2 \u2299 3) = 3 \u2295 3 = 4. It is easy to see that Stb is bi-locally finite. However, if we apply \u2295 and \u2299 alternatingly, then the result increases arbitrarily. For instance, let (bi | n \u2208 N) be the family defined by b0 = 2 and, for each n \u2208 N, by\nbn+1 =\n{ bn \u2295 2 if n is odd\nbn \u2299 2 otherwise .\nThen, e.g., b0 = 2, b1 = 3, b2 = 4, b3 = 5, .... In general we have \u3008{2}\u3009{\u2295,\u2299,0,1} = N, and hence Stb is not locally finite.\n10. Let (B,+) be a commutative semigroup and (B, \u00b7) be a semigroup. Combining these two semigroups, we obtain a strong bimonoid structure on B by adding constants 0 and 1. Formally, let 0, 1 6\u2208 B and put B\u2032 = B \u222a {0, 1}. Then we define binary operations \u2295 and \u2299 on B\u2032 by letting\n\u2022 \u2295 |B\u00d7B= + and 0\u2295 b = b\u2295 0 = b and 1\u2295 b = b\u2295 1 = b if b 6= 0, and \u2022 \u2299 |B\u00d7B= \u00b7 and 0\u2299 b = b\u2299 0 = 0, and 1\u2299 b = b\u2299 1 = b for each b \u2208 B \u2032.\nThen (B\u2032,\u2295,\u2299, 0, 1) is a strong bimonoid.\nAfter having shown a number of examples of strong bimonoids, we define some more restrictions and prove useful relationships.\nLet B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid. It is\n\u2022 additively idempotent if \u2295 is idempotent, \u2022 multiplicatively idempotent if \u2297 is idempotent, \u2022 zero-sum free if a\u2295 b = 0 implies a = b = 0 for every a, b \u2208 B, \u2022 zero-divisor free if a\u2297 b = 0 implies a = 0 or b = 0 for every a, b \u2208 B, \u2022 positive if it is zero-sum free and zero-divisor free, \u2022 zero-cancellation free if a\u2297 b\u2297 c 6= 0 implies a\u2297 c 6= 0 for every a, b, c \u2208 B,\n2Stb refers to one of the authors"
        },
        {
            "heading": "2.6. ALGEBRAIC STRUCTURES 29",
            "text": "\u2022 extremal if \u2295 is extremal, \u2022 weakly locally finite if, for every finite subset A \u2286 B, the set Cl(A) is finite, where Cl(A) is the smallest subset C \u2286 B such that A \u2286 C, and b\u2295 b\u2032 \u2208 C and b\u2297a \u2208 C for every a \u2208 A and b, b\u2032 \u2208 C,\nWe refer the reader to the proofs of Theorems 18.2.14 and 18.2.15 for further examples of strong bimonoids.\nLet n \u2208 N and b \u2208 B. We define the elements nb \u2208 B and bn \u2208 B by induction on N as follows:\n0n = 0, (n+ 1)b = b\u2295 nb and b0 = 1, bn+1 = b\u2297 bn . (2.15)\nObservation 2.6.11. Let B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid. Then the following statements hold.\n(1) If B is commutative, then it is zero-cancellation free. Moreover, there exists a zero-cancellation free semiring which is not commutative. (2) If B is zero-divisor free, then it is zero-cancellation free. Moreover, there exists a zero-cancellation free semiring which is not zero-divisor free. (3) If B is extremal, then it is additively idempotent. (4) If B is additively idempotent, then it is zero-sum free. Moreover, there exists a zero-sum free\nsemiring which is not additively idempotent. (5) If B is locally finite, then it is bi-locally finite. (6) If B is a bi-locally finite semiring, then it is locally finite. (7) If B is \u03c3-complete, then it is zero-sum free [Gol99, Prop. 22.28]. (8) If B is \u03c3-complete, then, for every countable index set I and family (bi | i \u2208 B) of elements of B,\nwe have \u2211\u2295\ni\u2208I\nbi 6= 0 \u21d0\u21d2 (\u2203i \u2208 I) : bi 6= 0 .\n(9) If B is zero-sum free, then for every finite index set I and family (bi | i \u2208 B) of elements of B we have \u2295\ni\u2208I\nbi 6= 0 \u21d0\u21d2 (\u2203i \u2208 I) : bi 6= 0 .\n(10) If B is an additively idempotent semiring, then it is zero-sum free.\nProof. Proof of (1): For the proof of the first statement, assume that B is commutative and not zerocancellation free. By the second condition, there are a, b, c \u2208 B such that a \u2297 b \u2297 c 6= 0 and a \u2297 c = 0. Using the latter and commutativity, we obtain a\u2297 b\u2297 c = a\u2297 c\u2297 b = 0 which is a contradiction. For the second, we can consider the semiring Lang\u0393 = (P(\u0393\n\u2217),\u222a, \u00b7, \u2205, {\u03b5}) of formal languages (cf. Example 2.6.9 (12)), which is zero-cancellation free and not commutative.\nProof of (2): Let us assume that B is zero-divisor free and not zero-cancellation free. The latter means that there exist a, b, c \u2208 B such that a \u2297 b \u2297 c 6= 0 and a \u2297 c = 0. Since B is zero-divisor free, we have a = 0 or c = 0. Thus a\u2297 b\u2297 c = 0, which contradicts our assumption.\nTo prove the second statement, we consider the ring Intmod4 = ({0, 1, 2, 3},+4, \u00b74, 0, 1) as defined in Example 2.6.9(5). It is easy to see that Intmod4 is zero-cancellation free and not zero-divisor free.\nProof of (3): It is obvious.\nProof of (4): Let us assume that B is additively idempotent. Let a \u2295 b = 0. Then a = a \u2295 0 = a\u2295 (a\u2295 b) = (a\u2295 a)\u2295 b = a\u2295 b = 0. Hence B is zero-sum free. The semiring Nat of natural numbers is zero-sum free and not additively idempotent.\nProof of (5): This is obvious because for each finite subset F \u2286 B we have \u3008F \u3009{0,\u2295} \u222a \u3008F \u3009{1,\u2297} \u2286 \u3008F \u3009{0,1,\u2295,\u2297}.\nProof of (6): Let F \u2286 B be a finite subset of B. We show that set \u3008F \u3009{0,1,\u2295,\u2297} is finite. Let us abbreviate this set by \u3008F \u3009.\nSince B is bi-locally finite it is sufficient to show that \u3008F \u3009 = \u3008\u3008F \u3009{1,\u2297}\u3009{0,\u2295}. The inclusion \u3008\u3008F \u3009{1,\u2297}\u3009{0,\u2295} \u2286 \u3008F \u3009 holds obviously."
        },
        {
            "heading": "30 CHAPTER 2. PRELIMINARIES",
            "text": "We show the other inclusion. Since F \u2286 \u3008\u3008F \u3009{1,\u2297}\u3009{0,\u2295}, it is sufficient to show that \u3008\u3008F \u3009{1,\u2297}\u3009{0,\u2295} is closed under the operations \u2295, \u2297, 0, and 1. The closure under \u2295, 0, and 1 is obvious. To show the closure under \u2297, let c, d \u2208 \u3008\u3008F \u3009{1,\u2297}\u3009{0,\u2295}. Then there exist n1, n2 \u2208 N, c1, . . . , cn1 , d1, . . . , dn2 \u2208 \u3008F \u3009{1,\u2297} such that c =\n\u2295 i\u2208[n1] ci and d = \u2295 j\u2208[n2] dj . By using distributivity, we obtain\nc\u2297 d = ( \u2295\ni\u2208[n1]\nci ) \u2297 ( \u2295\nj\u2208[n2]\ndj ) = \u2295\ni\u2208[n1]\n\u2295\nj\u2208[n2]\nci \u2297 dj .\nSince ci \u2297 dj \u2208 \u3008F \u3009{1,\u2297} for every i \u2208 [n1] and j \u2208 [n2], we obtain that c\u2297 d \u2208 \u3008\u3008F \u3009{1,\u2297}\u3009{0,\u2295}.\nProof of (7): Let a, b \u2208 B such that a\u2295 b = 0 and let c = \u2211\u2295\ni\u2208N\n(a\u2295 b). Then by Observation 2.6.8 we\nhave c = 0. Moreover, let d = \u2211\u2295\ni\u2208N\na and e = \u2211\u2295\ni\u2208N\nb. By renaming indices and using axioms (2.11) and\n(2.12), it is easy to see that \u2211\u2295\ni\u2208N\n(a\u2295 b) = \u2211\u2295\ni\u2208N\na\u2295 \u2211\u2295\ni\u2208N\nb ,\nhence we have c = d\u2295 e. Similarly, it is easy to see that\n\u2211\u2295\ni\u2208N\na = a\u2295 \u2211\u2295\ni\u2208N\na,\nhence d = a\u2295 d. Then we obtain 0 = c = d\u2295 e = a\u2295 d\u2295 e = a and 0 = a\u2295 b = b.\nProof of (8): Let B be \u03c3-complete. First we prove the implication \u21d2 in the equivalence. For this we\nassume that \u2211\u2295\ni\u2208I\nbi 6= 0 and (\u2200i \u2208 I) : bi = 0. By Observation 2.6.8, the second condition implies that\n\u2211\u2295\ni\u2208I\nbi = 0, which contradicts the first one.\nLastly we prove the implication \u21d0. Let j \u2208 I be such that bj 6= 0. Then\n\u2211\u2295\ni\u2208I\nbi = \u2211\u2295\ni\u2208I\\{j}\nbi \u2295 bj 6= 0,\nwhere at the first equality we applied the laws (2.11) and (2.12), and the second equality follows from the fact that B is zero-sum free.\nProof of (9): The proof is very similar to the proof of (7). However, instead of Observation 2.6.8, we use the fact that, for every finite index set I, we have \u2295 i\u2208I 0 = 0.\nProof of (10): Let a, b \u2208 B such that a\u2295 b = 0. Then a = 0 because\n0 = a\u2295 b = a\u2297 1\u2295 b = a\u2297 (1\u2295 1)\u2295 b = a\u2295 a\u2295 b = a .\nSimilarly, we can show that b = 0."
        },
        {
            "heading": "2.6.6 Lattices and their comparison with strong bimonoids",
            "text": "We recall notions from lattice theory [Bir93, Gra\u030803] and [BS81, Ch. 1]. A lattice is an algebra (B,\u2228,\u2227) in which \u2228 (the join) and \u2227 (the meet) are binary operations, (B,\u2228) and (B,\u2227) are commutative semigroups, the operations \u2227 and \u2228 are idempotent and satisfy the absorption axioms a\u2228(a\u2227b) = a and a\u2227(a\u2228b) = a. The lattice (B,\u2228,\u2227) is bounded if there exist elements 0, 1 \u2208 B such that 0 \u2228 a = a and 1 \u2227 a = a for every a \u2208 B. We denote a bounded lattice also by (B,\u2228,\u2227, 0, 1).\nThere is an alternative order-theoretic definition of lattice. A partially ordered set (B,\u2264) is a lattice if for each a, b \u2208 B the elements sup\u2264{a, b} and inf\u2264{a, b} exist. The lattice (B,\u2264) is bounded if there"
        },
        {
            "heading": "2.6. ALGEBRAIC STRUCTURES 31",
            "text": "exist elements 0, 1 \u2208 B such that inf\u2264(0, a) = 0 and sup\u2264(1, a) = 1 for every a \u2208 B; in other words, 0 and 1 are the smallest element and greatest element, respectively, with respect to \u2264. We denote a bounded lattice also by (B,\u2264, 0, 1).\nWe recall the well known correspondence between these two definitions.\nTheorem 2.6.12. (cf. [BS81, Sect. I.1], [Bir67, Ch. I., Thm 8], [Gra\u030878, Sect. 1.1, Thm 8], [Gra\u030803, p.6]) Let B be a set. The following two statements hold.\n(1) Let the algebra (B,\u2228,\u2227) be a lattice. We define the partial order \u2264 on B such that\na \u2264 b if a \u2227 b = a for every a, b \u2208 B .\nThen the partially ordered set (B,\u2264) is a lattice with sup\u2264{a, b} = a\u2228 b and inf\u2264{a, b} = a \u2227 b for every a, b \u2208 B. (2) Let the partially ordered set (B,\u2264) be a lattice. We define the binary operations \u2228 and \u2227 on B such that\na \u2228 b = sup\u2264{a, b} and a \u2227 b = inf\u2264{a, b} for every a, b \u2208 B .\nThen the algebra (B,\u2228,\u2227) is a lattice.\nClearly, if we apply the transformation in Theorem 2.6.12(1) to the lattice (B,\u2228,\u2227) and then apply to the resulting lattice (B,\u2264) the transformation in Theorem 2.6.12(2), then we reobtain the lattice (B,\u2228,\u2227). A similar invariant occurs if we apply the transformation of (2) followed by the transformation of (1) to a lattice (B,\u2264).\nAnother consequence of Theorem 2.6.12 is the following. Let (B,\u2228,\u2227) and (B,\u2264) be bounded lattices such that the transformations of Theorem 2.6.12 transform the one into the other. Moreover, let 0 and 1 be two elements of B. Then the following equivalence holds: (B,\u2228,\u2227, 0, 1) is a bounded lattice iff (B,\u2264, 0, 1) is a bounded lattice.\nThe lattice (B,\u2228,\u2227) is distributive if \u2227 is distributive over \u2228 and \u2228 is distributive over \u2227. If fact, the first of the previous two conditions holds if and only if the second one holds [DP12, Lm. 4.3]. Hence it suffices to require one of them.\nObservation 2.6.13. (1) For each lattice (B,\u2228,\u2227), the semigroups (B,\u2228) and (B,\u2227) are locally finite. (2) Each bounded lattice (B,\u2228,\u2227, 0, 1) is a bi-locally finite and commutative strong bimonoid. (3) Each distributive bounded lattice (B,\u2228,\u2227, 0, 1) is a locally finite and commutative semiring.\nProof. Proof of (1): Let (B,\u2228,\u2227) be a lattice. The statement follows from Observation 2.6.6 because both \u2228 and \u2227 are commutative and idempotent.\nProof of (2): Let B = (B,\u2228,\u2227, 0, 1) be a bounded lattice. Since we have 0 \u2227 a = 0 \u2227 (0 \u2228 a) = 0 for every a \u2208 B (by absorption law), the algebra B is a strong bimonoid. Obviously, it is commutative. Moreover, it follows from Statement (1) that both (B,\u2228, 0) and (B,\u2227, 1) are locally finite.\nProof of (3): This follows from (2) and Observation 2.6.11(6).\nObservation 2.6.14. Let B = (B,\u2295,\u2297, 0, 1) be an algebra. Then the following two statements hold.\n(1) B is a bounded lattice if and only if (B,\u2295,\u2297) is a lattice and B is a strong bimonoid. (2) B is a distributive bounded lattice if and only if (B,\u2295,\u2297) is a lattice and B is a semiring.\nWe recall that a bounded lattice (B,\u2228,\u2227, 0, 1) (which is a particular commutative strong bimonoid) is \u03c3-complete if the monoid (B,\u2228, 0) is \u03c3-complete (cf. Section 2.6.5). We note that, for bounded lattices, our concept is more general than \u03c3-lattice in [Bir67, Ch. 9] because in a \u03c3-lattice both the join and the meet exist for arbitrary countable index sets. Moreover, \u03c3-lattice is more general than complete lattice [Bir67, Bir93, Gra\u030878, Gra\u030803] because in a complete lattice the join and the meet exist for arbitrary index sets. Lastly, we note that if meet exists for arbitrary index sets, then also join exists for arbitrary index sets and vice versa [Bir67, Ch. V, Thm. 3] [Gra\u030878, Sect. 1.3, Lm. 14].\nExample 2.6.15.\n1. Let A be a set. The \u03c3-complete semiring PSA = (P(A),\u222a,\u2229, \u2205, A) is a \u03c3-complete distributive lattice.\n2. The \u03c3-complete semiring Natmax,min = (N\u221e,max,min, 0,\u221e) is a \u03c3-complete distributive lattice.\n3. [Gra\u030803, Fig. 2, p.14], [BS81, Fig. 5] Let N5 = {o, a, b, c, i} be a set with five elements. We consider two binary operations \u2228 and \u2227 such that the following requirements hold:\na \u2227 b = b, b \u2228 c = i, and a \u2227 c = o.\nThe definition of the values of \u2228 and \u2227 for other combinations of arguments is given by the unique extension of the above requirements such that N5 = (N5,\u2228,\u2227, o, i) is a bounded lattice (cf. Figure 2.3). This lattice is not distributive.\n4. [Gra\u030803, Fig. 2, p.14], [BS81, Fig. 5] Let M3 = {o, a, b, c, i} be a set with five elements. We consider two binary operations \u2228 and \u2227 such that the following requirements hold:\na \u2227 b = a \u2227 c = b \u2227 c = o and a \u2228 b = a \u2228 c = b \u2228 c = i.\nSimilarly, the definition of the values of \u2228 and \u2227 for other combinations of arguments is given by the unique extension of the above requirements such that M3 = (M3,\u2228,\u2227, o, i) is a bounded lattice (cf. Figure 2.3). This lattice is not distributive.\nIt is well known that there exist large sets of lattices that are not distributive [Gra\u030803], e.g., orthomodular lattices. In fact, a lattice is non-distributive if and only if it contains at least one of the two lattices N5 and M3 as a sublattice [Gra\u030803, Thm. 1 on p. 80].\n5. We consider the algebra (R,max,min) with maximum and minimum based on the usual \u2264 ordering on the set of real numbers. The algebra (R,max,min) is a lattice. It is not bounded (and hence not \u03c3-complete). Moreover, both max and min are extremal.\n6. A residuated lattice is an algebra B = (B,\u2228,\u2227,\u2297,\u2192, 0, 1) such that\n(L1) (B,\u2228,\u2227, 0, 1) is a bounded lattice, (L2) (B,\u2297, 1) is a commutative monoid with the unit 1, and (L3) \u2192 is a binary operation, and \u2297 and \u2192 form an adjoint pair, i.e., they satisfy the adjunction\nproperty: for all a, b, c \u2208 B, a\u2297 b \u2264 c if and only if a \u2264 (b\u2192 c). (Here \u2264 is the partial order on B defined, as for lattices, by a \u2264 b iff a = a \u2227 b for every a, b \u2208 B.)\nIf, additionally, B is a \u03c3-complete lattice, then B is called a \u03c3-complete residuated lattice.\nThe operations \u2297 and \u2192 are called multiplication and residuum, respectively. The algebra (B,\u2228,\u2297, 0, 1) is a semiring (cf., e.g., [Gal08, Slide 11]), it is called the semiring reduct of B. Thus, in particular, the semiring reduct of each residuated lattice is a strong bimonoid.\n2.6. ALGEBRAIC STRUCTURES 33\n7. The \u03c3-complete Boolean algebras of [Loo47] are \u03c3-complete lattices.\n8. A finite chain is a finite bounded lattice (L,\u2264, 0, 1) where \u2264 is a linear order. Trivially, each finite chain is distributive.\n9. The bounded lattice FL(2+2) = (FL(2+2),\u2228,\u2227, 0, 1) (cf. [Rol58], [Gra\u030803, p. 361], [RW09, Fig. 3a]) is the lattice freely generated by the two finite chains a < b and c < d (cf. Figure 2.4). The upper bound is 1 = b \u2228 d and the lower bound is 0 = a \u2227 c. This lattice is infinite [Rol58, Thm. 2], hence it is not locally finite. Thus, by Observation 2.6.11(6), it is not distributive; this also follows from the fact that FL(2 + 2) contains N5 as sublattice.\nWe note that semiring-reducts of semi-lattice ordered monoids and of \u03c3-complete residuated lattices, and Brouwerian lattices are commutative semirings.\nIn Figure 2.5, we have placed five sets of algebras into a diagram. The sets are:\n\u2022 the set C1 of all lattices, \u2022 the set C2 of all strong bimonoids, \u2022 the set C3 of all semirings, \u2022 the set C4 of all bi-locally finite strong bimonoids, and \u2022 the set C5 of all locally finite strong bimonoids.\nObservation 2.6.16. Figure 2.5 shows the Euler diagram of the sets C1, C2, C3, C4, and C5."
        },
        {
            "heading": "34 CHAPTER 2. PRELIMINARIES",
            "text": "Proof. By Observation 2.6.11(6), we have C3 \u2229C4 = C3 \u2229C5. Moreover, the following subset relationships hold:\n\u2022 C3 \u2286 C2, \u2022 C5 \u2286 C4, \u2022 C4 \u2286 C2, \u2022 C1 \u2229 C3 \u2286 C5, and \u2022 C1 \u2229 C2 \u2286 C4.\nNext, for each nonempty area of the diagram, we show a witness (i.e., an element of that area).\nC1 \\ C2 6= \u2205: Let B1 be the lattice (R,max,min). Since B1 is not bounded, it is not a strong bimonoid.\n(C1 \u2229 C4) \\ C5 6= \u2205 [Cze\u030119]: We let B2 be the bounded lattice FL(2 + 2) in Example 2.6.15(9) (cf. Figure 2.4). This lattice is infinite and it is freely generated by the two finite chains a < b and c < d. Hence it is not locally finite.\n(C1 \u2229 C5) \\ C3 6= \u2205: We let B3 = N5 and B4 = M3. These are finite bounded lattices; hence, they are locally finite and commutative strong bimonoids. But neither of them is distributive.\nC1\u2229C3 6= \u2205: We let B5 be the semiring PSA = (P(A),\u222a,\u2229, \u2205, A) for some set A 6= \u2205. This is a bounded lattice (cf. Example 2.6.15(1)).\n(C3\u2229C4)\\C1 6= \u2205: We let B6 be the ring Intmod4 = ({0, 1, 2, 3},+4, \u00b74, 0, 1) defined in Example 2.6.9(5). This is a finite (hence also locally finite) semiring but not a lattice, because e.g. +4 is not idempotent.\nC5 \\(C1\u222aC3) 6= \u2205: We let B7 be the strong bimonoid ({0, 1, 2, 3,\u221e},+4,min, 0,\u221e) where +4 is defined as for B6 (extended in the usual way to\u221e). Since B7 is finite, it is also locally finite. B7 is neither a lattice (because +4 is not idempotent) nor a semiring (because, e.g., min(1, 1 +4 1) 6= min(1, 1) +4 min(1, 1)).\nC4 \\ (C1 \u222a C3 \u222a C5) 6= \u2205 [Dro19]: Let B8 be the strong bimonoid Trunc\u03bb = (B,\u2295,\u2299, 0, 1) of Example 2.6.10(2) (also cf. [DV12, Ex. 2.1(2)]). Then B8 is a bi-locally finite and commutative strong bimonoid, but not a locally finite strong bimonoid. Moreover, B8 is neither a semiring nor a lattice.\nC2 \\ (C1 \u222a C3 \u222a C4) 6= \u2205: We let B9 be the tropical bimonoid TropBM. This is neither a lattice (because + is not idempotent) nor a bi-locally finite strong bimonoid nor a semiring (because, e.g., min(1, 1 + 1) 6= min(1, 1) + min(1, 1)).\nC3 \\ (C1 \u222a C4): We let B10 be the semiring Nat = (N,+, \u00b7, 0, 1) of natural numbers. This is neither bi-locally finite nor it is a lattice.\nWe finish this subsection with a characterization theorem. It concerns the smallest set which is closed under certain operations. Such a set can be characterized by using a combination of the fixpoint theorem of Tarski [Tar55, Thm. 1] and the first fixpoint theorem of Kleene [Kle62, p. 348] (cf. [LNS82]). We start with some preparations.\nFirst, we recall some notions and observations from [DP12]. Let A be a set. The pair (P(A),\u2286) is a \u03c3-complete lattice in the order-theoretical sense; the corresponding algebraic version is the \u03c3-complete semiring PSA = (P(A),\u222a,\u2229, \u2205, A) where U \u222a U \u2032 and U \u2229 U \u2032 are the supremum of U and infimum of U \u2032, respectively, with respect to \u2286.\nLet D \u2286 P(A) such that D 6= \u2205. We call D directed if, for each U,U \u2032 \u2208 D, there exists V \u2208 D such that U \u2286 V and U \u2032 \u2286 V .\nLet f : P(A)\u2192 P(A) be a mapping. We say that\n\u2022 f is order-preserving if, for every U,U \u2032 \u2208 P(A), the inclusion U \u2286 U \u2032 implies f(U) \u2286 f(U \u2032), \u2022 f is continuous if, for each directed set D \u2286 P(A) we have that f(D) is a directed set and f( \u22c3 (U | U \u2208 D)) = \u22c3 (f(U) | U \u2208 D), \u2022 U \u2208 P(A) is a fixpoint of f if f(U) = U , and \u2022 U is the least fixpoint of f if it is a fixpoint and, for each fixpoint U \u2032, the inclusion U \u2286 U \u2032 holds.\nWe note that each continuous mapping f : P(A)\u2192 P(A) is order-preserving [DP12, Lm. 8.7(ii)]."
        },
        {
            "heading": "2.7. MATRICES AND VECTORS OVER A STRONG BIMONOID 35",
            "text": "Theorem 2.6.17. (cf. least fixpoint theorems [DP12, Thm. 2.35] and [DP12, Thm. 8.15]) Let A be a set and f : P(A)\u2192 P(A) be a continuous mapping. Then:\n\u22c2 (U \u2208 P(A) | f(U) \u2286 U) = \u22c3 (fn(\u2205) | n \u2208 N)\nand \u22c3 (fn(\u2205) | n \u2208 N) is the least fixpoint of f . (2.16)\nIntuitively, the left-hand side of (2.16) reflects the definition of a set as the smallest set which satisfies a closure property (formalized by f), and the right-hand side offers a kind of slicing (or stratification) of this set; that slicing can be used in a proof by induction on N.\nIn the rest of this book, B will denote an arbitrary strong bimonoid (B,\u2295,\u2297, 0, 1) if not specified otherwise."
        },
        {
            "heading": "2.7 Matrices and vectors over a strong bimonoid",
            "text": "In this section Q denotes a finite set."
        },
        {
            "heading": "36 CHAPTER 2. PRELIMINARIES",
            "text": "Matrices. A Q-square matrix over B is a mapping M : Q \u00d7 Q \u2192 B and an entry M(p, q) \u2208 B is denoted by Mp,q. We recall that the set of all Q-square matrices over B is denoted by B\nQ\u00d7Q. In case that Q = [\u03ba] for some \u03ba \u2208 N, we write B\u03ba\u00d7\u03ba instead of B[\u03ba]\u00d7[\u03ba].\nAs usual, we define the addition of Q-square matrices over B. More precisely, we define the binary operation + : BQ\u00d7Q \u00d7BQ\u00d7Q \u2192 BQ\u00d7Q by letting\n(M1 +M2)p,q = (M1)p,q \u2295 (M2)p,q\nfor every M1,M2 \u2208 BQ\u00d7Q and p, q \u2208 Q. It is clear that + is associative and commutative. Moreover, the matrix M0 \u2208 BQ\u00d7Q with all entries being 0, is the identity element for +, hence (BQ\u00d7Q,+,M0) is a commutative monoid. Also we define the multiplication of Q-square matrices over B in the usual way. We define the binary operation \u00b7 : BQ\u00d7Q \u00d7 BQ\u00d7Q \u2192 BQ\u00d7Q by letting for every M1,M2 \u2208 BQ\u00d7Q and p, q \u2208 Q:\n(M1 \u00b7M2)p,q = \u2295\nk\u2208Q\n(M1)p,k \u2297 (M2)k,q .\nIn general, \u00b7 is not associative, because B may lack distributivity. The matrix M1 \u2208 B Q\u00d7Q with\n(M1)p,q =\n{ 1 if p = q\n0 otherwise\nfor every p, q \u2208 Q, is the identity element for \u00b7. Moreover, M0 \u00b7M =M \u00b7M0 = M0 for each M \u2208 BQ\u00d7Q.\nLet B = (B,\u2295,\u2297, 0, 1) be a semiring. Since the operation \u2297 of B is distributive over \u2295, the operation \u00b7 on BQ\u00d7Q is associative. Thus, (BQ\u00d7Q, \u00b7,M1) is a monoid. Also \u00b7 is distributive with respect to +. Hence BQ\u00d7Q = (BQ\u00d7Q,+, \u00b7,M0,M1) is a semiring, called the semiring of Q-square matrices over B. If B is \u03c3-complete, then so is BQ\u00d7Q (cf. [DK09, Sec. 4]).\nWe mention that the semiring of {1, 2}-square matrices over the semiring Boole (cf. Section 2.7) is not zero-cancellation free, because\n( 1 0 0 0 ) \u00b7 ( 1 1 1 1 ) \u00b7 ( 0 0 0 1 ) = ( 0 1 0 0 ) and ( 1 0 0 0 ) \u00b7 ( 0 0 0 1 ) = ( 0 0 0 0 )\nVectors. A Q-vector v over B is a mapping v : Q\u2192 B, and an element v(q) \u2208 B of v is denoted by vq. We recall that the set of all Q-vectors over B is denoted by BQ. In case that Q = [\u03ba] for some \u03ba \u2208 N, we write B\u03ba instead of B[\u03ba].\nWe define the operation sum + : BQ \u00d7 BQ \u2192 BQ and scalar multiplication \u00b7 : B \u00d7 BQ \u2192 BQ . For this, let u, v \u2208 BQ and b \u2208 B. Then, for every q \u2208 Q, we define\n(u+ v)q = uq \u2295 vq, and (b \u00b7 u)q = b\u2297 uq .\nWe denote by 0Q the Q-vector over B which contains 0 in each component. Moreover, for each q \u2208 Q, we denote by 1q the q-unit vector in B\nQ, i.e., the vector in BQ defined by (1q)p = 1 if p = q and (1q)p = 0 otherwise. We note that the algebra (BQ,+, 0Q) is a commutative monoid. Moreover, for each v \u2208 BQ, we have v =+q\u2208Q vq \u00b7 1q.\nThe scalar product of Q-vectors is defined for every v1, v2 \u2208 BQ by:\nv1 \u00b7 v2 = \u2295\nq\u2208Q\n(v1)q \u2297 (v2)q ."
        },
        {
            "heading": "2.8. SEMIMODULES AND VECTOR SPACES 37",
            "text": "Products. Let b \u2208 B, v1, v2 \u2208 BQ, and M \u2208 BQ\u00d7Q be a matrix. We define the matrix b \u00b7M by\n(b \u00b7M)p,q = b\u2297Mp,q\nfor every p, q \u2208 Q. Moreover, we define the vector-matrix product v1 \u00b7M \u2208 BQ and the matrix-vector product M \u00b7 v2 \u2208 B Q such that for every p \u2208 Q:\n(v1 \u00b7M)p = \u2295\nq\u2208Q\n(v1)q \u2297Mq,p (M \u00b7 v2)p = \u2295\nq\u2208Q\nMp,q \u2297 (v2)q .\nIt is easy to calculate that, if B is left-distributive, then for every M1,M2 \u2208 BQ\u00d7Q and v \u2208 BQ, we have\n(M1 \u00b7M2) \u00b7 v =M1 \u00b7 (M2 \u00b7 v) . (2.17)\nCharacteristic polynomials. Let (B,\u2295,\u2297, 0, 1) be a field. Moreover, let \u03ba \u2208 N+ and M \u2208 B\u03ba\u00d7\u03ba. The characteristic polynomial of M , denoted by charM , is defined by\ncharM (x) = det(M \u2212 xM1)\nwhere M1 \u2208 B\u03ba\u00d7\u03ba is the identity for the matrix multiplication and det(M \u2032) is the determinant of the matrix M \u2032 (cf. [MY98]). Clearly, the degree of charM is \u03ba, and the coefficient of x\n\u03ba is (\u22121)\u03ba. The following shows an example of M \u2208 R3\u00d73 and charM (x):\nM =\n \n0 0 1 1 3 2 2 0 2\n  , det(M \u2212 xM1) =   \u2212x 0 1 1 3\u2212 x 2 2 0 2\u2212 x   , charM (x) = \u2212x3 + 5x2 \u2212 4x\u2212 6 .\nThe following theorem is due to Cayley and Hamilton. We recall that charM (M) is the evaluation of charM (x) in (B \u03ba\u00d7\u03ba,+, \u00b7,M0,M1) at x =M , and that M0 \u2208 B\u03ba\u00d7\u03ba is the identity element of +.\nTheorem 2.7.1. [Lan93, Ch. XIV,Thm. 3.1] Let \u03ba \u2208 N+ and M \u2208 B\u03ba\u00d7\u03ba. Then charM (M) = M0."
        },
        {
            "heading": "2.8 Semimodules and vector spaces",
            "text": "In this section let B = (B,\u2295,\u2297, 0, 1) be a semiring.\nSemimodules and multilinear operations. Let V = (V,+, 0) be a commutative monoid3. Moreover, let \u00b7 : B \u00d7 V \u2192 V be a mapping. Then V is a (left-)B-semimodule (via \u00b7) if the following laws hold:\n(b\u2297 b\u2032) \u00b7 v = b \u00b7 (b\u2032 \u00b7 v) (2.18)\nb \u00b7 (v + v\u2032) = (b \u00b7 v) + (b \u00b7 v\u2032) (2.19) (b \u2295 b\u2032) \u00b7 v = (b \u00b7 v) + (b\u2032 \u00b7 v) (2.20)\n1 \u00b7 v = v (2.21)\nb \u00b7 0 = 0 \u00b7 v = 0 (2.22)\nfor every b, b\u2032 \u2208 B and v, v\u2032 \u2208 V (cf. p.149 of [Gol99]). We note that, in Equation (2.22), the element 0 \u2208 V occurs twice and the element 0 \u2208 B occurs once. In particular, (B,\u2295, 0) is a B-semimodule via \u2297. Furthermore, we drop \u00b7 and write, e.g., bv instead of b \u00b7 v.\nLet B be commutative and V = (V,+, 0) be a B-semimodule. A linear form (over V) is a mapping \u03b3 : V \u2192 B such that for every b, b\u2032 \u2208 B and v, v\u2032 \u2208 V , we have \u03b3(bv + b\u2032v\u2032) = b\u2297 \u03b3(v)\u2295 b\u2032 \u2297 \u03b3(v\u2032).\n3We note that the 0 of the semiring B can be different from the 0 of the monoid V ."
        },
        {
            "heading": "38 CHAPTER 2. PRELIMINARIES",
            "text": "An m-ary operation \u03c9 : V m \u2192 V is called multilinear (over V) if\n\u03c9(v1, . . . , vi\u22121, bv + b \u2032v\u2032 , vi+1, . . . , vm) = b\u03c9(v1, . . . , vi\u22121, v, vi+1, . . . , vm) + b \u2032\u03c9(v1, . . . , vi\u22121, v \u2032, vi+1, . . . , vm) (2.23)\nholds for every i \u2208 [m], b, b\u2032 \u2208 B, and v, v\u2032, v1, . . . , vm \u2208 V . We denote by L(Vm,V) the set of all m-ary multilinear operations over V.\nWe explain why commutativity of B is assumed in the above. For this we consider the expression \u03c9(b1v1, b2v2) and observe that we can evaluate it in two different ways:\n\u03c9(b1v1, b2v2) \u03c9(b1v1, b2v2) = b1\u03c9(v1, b2v2) (by (2.23)(i = 1)) = b2\u03c9(b1v1, v2) (by (2.23)(i = 2)) = b1(b2\u03c9(v1, v2)) (by (2.23)(i = 2)) = b2(b1\u03c9(v1, v2)) (by (2.23)(i = 1)) = (b1 \u2297 b2)\u03c9(v1, v2) (by (2.18)) = (b2 \u2297 b1)\u03c9(v1, v2) (by (2.18))\nThen commutativity of B guarantees the well-definedness of multilinearity.\nVector spaces and linear mappings. Let B = (B,\u2295,\u2297, 0, 1) be a field. A B-vector space is a Bsemimodule (V,+, 0) where (V,+, 0) is a commutative group. In particular, (B,\u2295, 0) is a B-vector space via \u2297.\nLet V = (V,+, 0) be a B-vector space. Moreover, let U \u2286 V be a nonempty subset such that for every u, v \u2208 U and b \u2208 B, we have u+ v \u2208 U and bu \u2208 U . Then (U,+\u2032, 0) is a subspace of V where +\u2032 = +|U\u00d7U . Often we will drop the prime from +\u2032. It is easy to see that any subspace U of V is a B-vector space. Two subspaces (U1,+, 0) and (U2,+, 0) of V are supplementary if U1\u2229U2 = {0} and U1+U2 = V , where in the latter we denote also by + the natural extension of the binary operation + on V to subsets of V .\nThe elements of V are called vectors. The vectors v1, . . . , vm \u2208 V are linearly independent if, for every b1, . . . , bm \u2208 B, the equality b1v1 + . . .+ bmvm = 0 implies that b1 = . . . = bm = 0. Let Q \u2286 V . We say that\n\u2022 Q is linearly independent if, for every m \u2208 N and pairwise different v1, . . . , vm \u2208 Q, the vectors v1, . . . , vm are linearly independent. \u2022 Q generates V if, for every v \u2208 V , there exists m \u2208 N+ and for every i \u2208 [m] there exist bi \u2208 B and vi \u2208 Q such that v = b1v1 + . . .+ bmvm. \u2022 Q is a basis of V if Q is linearly independent and Q generates V .\nA vector space V that has a finite basis is called finite-dimensional. In a finite-dimensional vector space each basis has the same number of elements [MY98, p. 341]. V is \u03ba-dimensional, where \u03ba \u2208 N+, if it has a basis consisting of \u03ba elements.\nLet V = (V,+, 0) and V\u2032 = (V \u2032,+\u2032, 0\u2032) be B-vector spaces via \u00b7 and \u00b7\u2032, respectively. A mapping f : V \u2192 V \u2032 is linear (from V to V\u2032) if, for every b1, b2 \u2208 B and u, v \u2208 V , the equation\nf(b1 \u00b7 u+ b2 \u00b7 v) = b1 \u00b7 \u2032 f(u) +\u2032 b2 \u00b7 \u2032 f(v)\nholds. The vector spaces V and V\u2032 are isomorphic if there exists a bijective linear mapping from V to V\u2032.\nLet f : V \u2192 V \u2032 be a linear mapping from V to V\u2032. If Q = {v1, . . . , vm} is a basis of V, then f is determined by the vectors f(v1), . . . , f(vm), because for each v \u2208 V there exist b1, . . . , bm \u2208 B such that v = b1 \u00b7 v1 + . . .+ bm \u00b7 vm and then\nf(v) = f(b1 \u00b7 v1 + . . .+ bm \u00b7 vm) = b1 \u00b7 \u2032 f(v1) + \u2032 . . .+\u2032 bm \u00b7 \u2032 f(vm) .\nThe kernel of f , denoted by ker(f), is the set {v \u2208 V | f(v) = 0\u2032}. It is easy to see that (ker(f),+, 0) and (im(f),+\u2032, 0\u2032) are subspaces of V and V\u2032, respectively.\nWe note that each linear mapping from V to V is a unary multilinear operation over V. Thus, L(V,V) is the set of all linear mappings from V to V. Each element of L(V,V) is an endomorphism."
        },
        {
            "heading": "2.8. SEMIMODULES AND VECTOR SPACES 39",
            "text": "Since endomorphisms are closed under composition, (L(V,V), \u25e6, idV ) is a monoid (cf. [MY98, p. 384]). An endomorphism f \u2208 L(V,V) is pseudo-regular if (ker(f),+, 0) and (im(f),+, 0) are supplementary subspaces of V.\nRepresenting vector spaces and endomorphisms. Let B = (B,\u2295,\u2297, 0, 1) be a field and V = (V,+\u2032, 0) be a B-vector space via \u00b7\u2032 with the finite basis Q = {q1, . . . , q\u03ba}. Let q1, . . . , q\u03ba be an arbitrary, but fixed order of the basis vectors. As usual, each vector of V can be represented by a [\u03ba]-vector over B, and vice versa (cf. [MY98, Ch. 3]). The key for this representation is the fact that, for each vector v \u2208 V , there exist unique b1, . . . , b\u03ba \u2208 B such that v = b1 \u00b7\u2032 q1 +\u2032 . . .+\u2032 b\u03ba \u00b7\u2032 q\u03ba. Then, intuitively, we will represent v by (b1, . . . , b\u03ba). Let us formalize this.\nObviously, (B\u03ba,+, 0\u03ba) is a commutative group, where + is the sum of vectors and 0\u03ba is the [\u03ba]-vector which maps each i \u2208 [\u03ba] to 0. Moreover, it is easy to check that (B\u03ba,+, 0\u03ba) is a \u03ba-dimensional B-vector space via the scalar multiplication \u00b7. The basis of this vector space is {11, . . . , 1\u03ba} where 1i denotes the i-unit vector in B\u03ba, i.e., the element in B\u03ba of which the i-th component is 1 and the other components are 0.\nThen the B-vector space (V,+\u2032, 0) via \u00b7\u2032 and the B-vector space (B\u03ba,+, 0\u03ba) via \u00b7 are isomorphic via the bijective linear mapping \u03c8 : V \u2192 B\u03ba defined by\n\u03c8(qi) = 1i for each i \u2208 [\u03ba].\nHence, we identify (V,+\u2032, 0) and (B\u03ba,+, 0\u03ba).\nAlso as usual, we can represent each endomorphism f \u2208 L(V,V) by a \u03ba-square matrix over B. For this, we define the mapping \u03c8\u2032 : L(V,V)\u2192 B\u03ba\u00d7\u03ba for each f : V \u2192 V and i, j \u2208 [\u03ba] by:\n\u03c8\u2032(f)i,j = \u03c8(f(qj))i ,\nor, in other words, the jth column of \u03c8\u2032(f) is the \u03c8-image of the basis vector qj . It is easy to see that \u03c8 \u2032 is bijective.\nMoreover, \u03c8\u2032 is a monoid homomorphism from the monoid (L(V,V), \u25e6, idV ) to the monoid (B\u03ba\u00d7\u03ba, \u00b7,M1), which can be seen as follows. Clearly, \u03c8\u2032(idV ) = M1. Let f1, f2 \u2208 L(V,V). Then, for every i, j \u2208 [\u03ba], we have\n\u03c8\u2032(f1 \u25e6 f2)i,j = \u03c8((f1 \u25e6 f2)(qj))i\n= \u03c8(f1(f2(qj)))i = \u03c8(f1(b1 \u00b7 \u2032 q1 + \u2032 . . .+\u2032 b\u03ba \u00b7 \u2032 q\u03ba))i\n(where b1, . . . , b\u03ba \u2208 B are such that f2(qj) = b1 \u00b7\u2032 q1 +\u2032 . . .+\u2032 b\u03ba \u00b7\u2032 q\u03ba)\n= \u03c8(b1 \u00b7 \u2032 f1(q1) + \u2032 . . .+\u2032 b\u03ba \u00b7 \u2032 f1(q\u03ba)))i (since f1 is a linear mapping)\n= (b1 \u00b7 \u03c8(f1(q1)) + . . .+ b\u03ba \u00b7 \u03c8(f1(q\u03ba)))i (since \u03c8 is a linear mapping)\n= b1 \u2297 \u03c8(f1(q1))i \u2295 . . .\u2295 b\u03ba \u2297 \u03c8(f1(q\u03ba))i (by definition of scalar multiplication and vector summation)\n= \u03c8(f2(qj))1 \u2297 \u03c8(f1(q1))i \u2295 . . .\u2295 \u03c8(f2(qj))\u03ba \u2297 \u03c8(f1(q\u03ba))i (because bk = \u03c8(f2(qj))k) = \u2295\nk\u2208[\u03ba]\n\u03c8(f2(qj))k \u2297 \u03c8(f1(qk))i\n= \u2295\nk\u2208[\u03ba]\n\u03c8\u2032(f2)k,j \u2297 \u03c8 \u2032(f1)i,k\n= \u2295\nk\u2208[\u03ba]\n\u03c8\u2032(f1)i,k \u2297 \u03c8 \u2032(f2)k,j (by commutativity)\n= (\u03c8\u2032(f1) \u00b7 \u03c8 \u2032(f2))i,j ."
        },
        {
            "heading": "40 CHAPTER 2. PRELIMINARIES",
            "text": "Hence, the two monoids (L(V,V), \u25e6, idV ) and (B\u03ba\u00d7\u03ba, \u00b7,M1) are isomorphic.\nA matrix M \u2208 B\u03ba\u00d7\u03ba is pseudo-regular if the endomorphism (\u03c8\u2032)\u22121(M) is pseudo-regular. Equivalent definitions of pseudo-regularity can be found in [Reu80, Prop. 1]."
        },
        {
            "heading": "2.9 Trees and tree languages",
            "text": "We recall some notions from (formal) tree languages [Eng75b, GS84, GS97, CDG+07].\nIn the rest of this book, we assume that each ranked alphabet has at least one symbol with rank 0. Moreover, \u03a3 and \u2206 will denote arbitrary such ranked alphabets, if not specified otherwise.\nTrees. Let H be a set and let \u039e denote the set containing the opening and closing parentheses \u201c(\u201d and \u201c)\u201d, respectively, and the comma \u201c,\u201d. We assume that \u03a3, H , and \u039e are pairwise disjoint. Now we define the \u03a3-algebra ((\u03a3\u222aH \u222a\u039e)\u2217, \u03b8\u03a3) where, for every k \u2208 N, \u03c3 \u2208 \u03a3 (k), and w1, . . . , wk \u2208 (\u03a3\u222aH \u222a\u039e) \u2217, we let\n\u03b8\u03a3(\u03c3)(w1, . . . , wk) = \u03c3(w1, . . . , wk) .\nThen the set of \u03a3-terms over H , denoted by T\u03a3(H), is the set \u3008H\u3009\u03b8\u03a3(\u03a3), i.e., the smallest subset of (\u03a3 \u222a H \u222a \u039e)\u2217 which contains H and is closed under \u03b8\u03a3(\u03a3). We denote T\u03a3(\u2205) by T\u03a3 and call it the set of \u03a3-terms. If H is finite, then we can view T\u03a3(H) as T\u2206, where the ranked alphabet \u2206 is defined as follows: \u2206(0) = \u03a3(0) \u222aH and \u2206(k) = \u03a3(k) for every k \u2208 N+.\nSince terms can be depicted in a very illustrative way as trees, i.e., particular graphs, it has become a custom to call \u03a3-terms also \u03a3-trees (or just: trees). In this book we follow this custom. Each subset L \u2286 T\u03a3 is called a \u03a3-tree language (or just: tree language).\nObviously, for each \u03be \u2208 T\u03a3 there exist unique k \u2208 N, \u03c3 \u2208 \u03a3(k), and \u03be1, . . . , \u03bek \u2208 T\u03a3 such that \u03be = \u03c3(\u03be1, . . . , \u03bek). (In case k = 0 we identify \u03c3() and \u03c3.) In order to avoid the repetition of all these quantifications, we henceforth only write that we consider a \u201c\u03be \u2208 T\u03a3 of the form \u03be = \u03c3(\u03be1, . . . , \u03bek)\u201d or \u201cfor every \u03be = \u03c3(\u03be1, . . . , \u03bek)\u201d.\nAs an application of Lemma 2.6.1, we obtain the following characterization of the set T\u03a3.\nObservation 2.9.1. Let fT\u03a3 : P((\u03a3 \u222a \u039e) \u2217) \u2192 P((\u03a3 \u222a \u039e)\u2217) be the mapping defined, for each U \u2208 P((\u03a3 \u222a \u039e)\u2217), by fT\u03a3(U) = U \u222a {\u03c3(\u03be1, . . . , \u03bek) | k \u2208 N, \u03c3 \u2208 \u03a3 (k), \u03be1, . . . , \u03bek \u2208 U}. Then, by Lemma 2.6.1,\nwe have T\u03a3 = \u22c3 ((fT\u03a3) n(\u2205) | n \u2208 N).\nThe \u03a3-term algebra. Let H be a set disjoint with \u03a3. The \u03a3-term algebra over H , denoted by T\u03a3(H), is the subalgebra of the \u03a3-algebra ((\u03a3 \u222a H \u222a \u039e)\u2217, \u03b8\u03a3) which is generated by H . Thus, since \u3008H\u3009\u03b8\u03a3(\u03a3) = T\u03a3(H), the \u03a3-term algebra over H is the \u03a3-algebra\nT\u03a3(H) = (T\u03a3(H), \u03b8\u03a3) .\nThe \u03a3-term algebra, denoted by T\u03a3, is the \u03a3-term algebra over \u2205, i.e., T\u03a3 = T\u03a3(\u2205).\nNext we prove that T\u03a3(H) is freely generated by H over the set of all \u03a3-algebras by using Theorem 2.5.1. For this, we use the following auxiliary definitions. We define the binary relation \u227a on T\u03a3(H) by\n\u227a= {(\u03bei, \u03c3(\u03be1, . . . , \u03bek)) | k \u2208 N+, \u03c3 \u2208 \u03a3 (k), \u03be1, . . . , \u03bek \u2208 T\u03a3(H), i \u2208 [k]} .\nObviously \u227a is well-founded and min\u227a(T\u03a3(H)) = \u03a3 (0)\u222aH . Let A = (A, \u03b8) be a \u03a3-algebra and f : H \u2192 A. Then we define the mapping\nG\u03b8,f : {(\u03be, g) | \u03be \u2208 T\u03a3(H), g : pred\u227a(\u03be)\u2192 A} \u2192 A"
        },
        {
            "heading": "2.9. TREES AND TREE LANGUAGES 41",
            "text": "for every \u03be \u2208 T\u03a3(H) and g : pred\u227a(\u03be)\u2192 A as follows:\nG\u03b8,f(\u03be, g) =\n{ \u03b8(\u03c3)(g(\u03be1), . . . , g(\u03bek)) if (\u2203k \u2208 N, \u03c3 \u2208 \u03a3(k), \u03be1, . . . , \u03bek \u2208 T\u03a3(H)) : \u03be = \u03c3(\u03be1, . . . , \u03bek)\nf(\u03be) otherwise (i.e., \u03be \u2208 H) .\nNow we prove that the unique mapping defined by G\u03b8,f is the unique \u03a3-algebra homomorphism from T\u03a3(H) to A which extends f .\nLemma 2.9.2. Let A = (A, \u03b8) be a \u03a3-algebra and f : H \u2192 A. Moreover, let \u03c6 : T\u03a3(H) \u2192 A be a mapping. Then the following two statements are equivalent.\n(A) For each \u03be \u2208 T\u03a3(H), the mapping \u03c6 satisfies \u03c6(\u03be) = G\u03b8,f (\u03be, \u03c6|pred\u227a(\u03be)). (B) \u03c6 is a \u03a3-algebra homomorphism from T\u03a3(H) to A, and \u03c6 extends f .\nProof. Proof of (A)\u21d2(B): Let \u03be = \u03c3(\u03be1, . . . , \u03bek). Then we can compute as follows:\n\u03c6(\u03c3(\u03be1, . . . , \u03bek)) = G\u03b8,f (\u03be, \u03c6|pred\u227a(\u03be)) (by (A))\n= \u03b8(\u03c3)(\u03c6|pred\u227a(\u03be)(\u03be1), . . . , \u03c6|pred\u227a(\u03be)(\u03bek)) (by definition of G\u03b8,f)\n= \u03b8(\u03c3)(\u03c6(\u03be1), . . . , \u03c6(\u03bek)) .\nHence \u03c6 is a \u03a3-algebra homomorphism from T\u03a3(H) to A. By definition of G\u03b8,f , the homomorphism \u03c6 extends f .\nProof of (B)\u21d2(A): We prove by case analysis. Let \u03be \u2208 H . Then \u03c6(\u03be) = f(\u03be) = G\u03b8,f(\u03be, \u03c6|pred\u227a(\u03be)). Let \u03be = \u03c3(\u03be1, . . . , \u03bek). Then we can compute as follows:\nG\u03b8,f(\u03be, \u03c6|pred\u227a(\u03be)) = \u03b8(\u03c3)(\u03c6|pred\u227a(\u03be)(\u03be1), . . . , \u03c6|pred\u227a(\u03be)(\u03bek)) (by definition of G\u03b8,f)\n= \u03b8(\u03c3)(\u03c6(\u03be1), . . . , \u03c6(\u03bek))\n= \u03c6(\u03be) . (by (B))\nTheorem 2.9.3. [GTWW77, Prop. 2.3] and [GS84, Thm. 1.3.11] The \u03a3-term algebra T\u03a3(H) over H is freely generated by H over the set of all \u03a3-algebras. Moreover, the \u03a3-term algebra T\u03a3 is initial in the set of all \u03a3-algebras.\nProof. For the proof of the first statement of the lemma, we proceed along the items (a), (b), and (c) of the definition of freely generated algebra.\n(a) As we saw, the \u03a3-term algebra T\u03a3(H) over H is a \u03a3-algebra.\n(b) By definition, we have T\u03a3(H) = \u3008H\u3009\u03b8\u03a3(\u03a3).\n(c) Let A = (A, \u03b8) be a \u03a3-algebra and f : H \u2192 A a mapping. By Theorem 2.5.1, there exists a unique mapping h : T\u03a3(H)\u2192 A such that, for each \u03be \u2208 T\u03a3(H), we have h(\u03be) = G\u03b8,f (\u03be, h|pred\u227a(\u03be)). Thus, due to Lemma 2.9.2, we obtain that h is the unique \u03a3-algebra homomorphism from T\u03a3(H) to A which extends f .\nThis proves the first statement of the lemma. The second statement follows from the first one with H = \u2205.\nIf not specified otherwise, then we denote the unique \u03a3-algebra homomorphism from the \u03a3term algebra T\u03a3 = (T\u03a3, \u03b8\u03a3) to some \u03a3-algebra A by hA.\nObservation 2.9.4. Let A = (A, \u03b8) be a \u03a3-algebra and (A\u2032, \u03b8) be the smallest subalgebra of A. Then A\u2032 = im(hA).\nProof. By Lemma 2.6.2, (im(hA), \u03b8) is a subalgebra of A. Moreover, we can show by induction on T\u03a3 that, for each \u03be \u2208 T\u03a3, we have hA(\u03be) \u2208 A\u2032. Hence im(hA) \u2286 A\u2032, and since (A\u2032, \u03b8) is the smallest subalgebra of A, we have im(hA) = A \u2032."
        },
        {
            "heading": "42 CHAPTER 2. PRELIMINARIES",
            "text": "String-like terms. We can view strings over an alphabet \u0393 as trees. For this, we first define an appropriate ranked alphabet.\nLet e 6\u2208 \u0393 be a symbol. Then \u0393 and e determine the string ranked alphabet \u0393e = {a (1) | a \u2208 \u0393}\u222a{e(0)}.\nVice versa, each string ranked alphabet \u03a3 can be written in the form \u0393e, where \u0393 = \u03a3 (1) and e is the only element of \u03a3(0). In the following, sometimes we denote a string ranked alphabet by \u0393e without mentioning what \u0393 and e mean.\nNow we define the \u0393e-algebra 4 (\u0393\u2217, \u0393\u0302e) where \u0393\u0302e = (\u0302b | b \u2208 \u0393e) is the \u0393e-indexed family over Ops(\u0393\u2217)\nsuch that e\u0302 = \u03b5 and a\u0302(w) = wa for every w \u2208 \u0393\u2217 and a \u2208 \u0393 .\nThen we consider the \u0393e-term algebra (T\u0393e , \u03b8\u0393e) and show that\n(\u0393\u2217, \u0393\u0302e) \u223c= (T\u0393e , \u03b8\u0393e) , (2.24)\ni.e., the two \u0393e-algebras (\u0393 \u2217, \u0393\u0302e) and (T\u0393e , \u03b8\u0393e) are isomorphic. For this, we define the mapping\ntreee : \u0393 \u2217 \u2192 T\u0393e\nas follows. We consider the well-founded set (\u0393\u2217,\u227a) where \u227a\u2286 \u0393\u2217 \u00d7 \u0393\u2217 is defined by \u227a= {(w,wa) | w \u2208 \u0393\u2217, a \u2208 \u0393}. Clearly, \u227a is well-founded and min\u227a(\u0393\u2217) = {\u03b5}. Then we define treee by induction on (\u0393\u2217,\u227a) by\nI.B.: treee(\u03b5) = e and I.S.: treee(wa) = a(treee(w)) for every w \u2208 \u0393\u2217 and a \u2208 \u0393.\nIt is obvious that treee is a bijection. Lastly, we show that treee is a \u0393e-algebra homomorphism from (\u0393\u2217, \u0393\u0302e) to (T\u0393e , \u03b8\u0393e):\n(i) treee(e\u0302) = treee(\u03b5) = e = \u03b8\u0393e(e)(), and (ii) for every w \u2208 \u0393\u2217 and a \u2208 \u0393, we have treee(a\u0302(w)) = treee(wa) = a(treee(w)) = \u03b8\u0393e(a)(treee(w)).\nHence (2.24) holds.\nProof by induction on T\u03a3(H) and proof by induction on T\u03a3. Let H be a set disjoint with \u03a3. Many times we will use the following two instances of well-founded induction to prove that each element of T\u03a3(H) has a property:\n\u2022 proof by induction on (T\u03a3(H),\u227a\u03a3,H) (for short: proof by induction on T\u03a3(H)): we define the binary relation5 \u227a\u03a3,H on T\u03a3(H) by\n\u227a\u03a3,H= {(\u03bei, \u03c3(\u03be1, . . . , \u03bek)) | k \u2208 N+, \u03c3 \u2208 \u03a3 (k), \u03be1, . . . , \u03bek \u2208 T\u03a3(H), i \u2208 [k]} .\nObviously, \u227a\u03a3,H is well-founded and min\u227a\u03a3,H (T\u03a3(H)) = \u03a3 (0) \u222aH . In this case, the induction base (2.2) and induction step (2.3) read\nI.B.: (\u2200\u03b1 \u2208 \u03a3(0) \u222aH) : P (\u03b1) I.S.: (( \u2200k \u2208 N+, \u03c3 \u2208 \u03a3 (k), \u03be1, . . . , \u03bek \u2208 T\u03a3(H) ) : [ P (\u03be1) \u2227 . . . \u2227 P (\u03bek) ] \u2192 P (\u03c3(\u03be1, . . . , \u03bek)) ) .\n\u2022 proof by induction on (T\u03a3(H),\u227a + \u03a3,H), where \u227a + \u03a3,H= (\u227a\u03a3,H) +, i.e., \u227a+\u03a3,H is the transitive closure\nof \u227a\u03a3,H . Again we have min\u227a+\u03a3,H (T\u03a3(H)) = \u03a3\n(0) \u222a H . In this case, the induction base (2.2) and\nthe induction step (2.3) read\nI.B.: (\u2200\u03b1 \u2208 \u03a3(0) \u222aH) : P (\u03b1) I.S.: (( \u2200\u03be \u2208 T\u03a3(H) \\ (\u03a3 (0) \u222aH) ) : [( \u2200\u03be\u2032 \u2208 T\u03a3(H) with \u03be \u2032 \u227a+\u03a3,H \u03be ) : P (\u03be\u2032) ] \u2192 P (\u03be) ) .\n4(\u0393\u2217, \u0393\u0302e) should not be confused with the free monoid (\u0393\u2217, \u00b7, \u03b5). 5This is exactly the binary relation which we have used to prove that the \u03a3-term algebra over H is freely generated by\nH over the set of all \u03a3-algebras; since we will use it often, we give it a specific denotation."
        },
        {
            "heading": "2.9. TREES AND TREE LANGUAGES 43",
            "text": "Often we will use induction on T\u03a3(H) for the case that H = \u2205. We will abbreviate \u227a\u03a3,\u2205 and \u227a + \u03a3,\u2205 by\n\u227a\u03a3 and \u227a + \u03a3 , respectively; then min\u227a\u03a3(T\u03a3) = min\u227a+\u03a3 (T\u03a3) = \u03a3 (0). We will call a proof by induction on T\u03a3(\u2205) (i.e., on (T\u03a3,\u227a\u03a3)) a proof by induction on T\u03a3. As in the general case, we will use the idioms \u201cwe prove P by induction on T\u03a3(H)\u201d and \u201cwe prove P by induction on T\u03a3\u201d with their natural meanings.\nIn some proofs by induction on T\u03a3, we combine the induction base (2.2) and induction step (2.3) by proving\n(\u2200k \u2208 N, \u03c3 \u2208 \u03a3(k), \u03be1, . . . , \u03bek \u2208 T\u03a3) : [P (\u03be1) \u2227 . . . \u2227 P (\u03bek)]\u2192 P (\u03c3(\u03be1, . . . , \u03bek)) .\nWe will define several mappings on T\u03a3(H) by induction on (T\u03a3(H),\u227a\u03a3,H) (cf. (2.4)). Then we will use the idiom \u201cwe define a mapping by induction on T\u03a3(H)\u201d or, if H = \u2205, \u201cwe define a mapping by induction on T\u03a3\u201d.\nMappings on trees. Let H be a set disjoint with \u03a3. First, we define the three mappings\nheight : T\u03a3(H)\u2192 N, size : T\u03a3(H)\u2192 N, and pos : T\u03a3(H)\u2192 P(N+ \u2217)\nwhich, intuitively, for each tree \u03be \u2208 T\u03a3(H) (viewed as graph), deliver the maximal number of edges from the root of \u03be to some leaf, the number of nodes of \u03be, and the set of Gorn-addresses of \u03be, respectively. For instance, let \u03a3 = {\u03c3(2), \u03b3(1), \u03b1(0), \u03b2(0)}, H = {a}, and \u03be = \u03c3(\u03b3(\u03b1), \u03c3(\u03b3(a), \u03b2)); then\nheight(\u03be) = 3 , size(\u03be) = 7 , pos(\u03be) = {\u03b5, 1, 11, 2, 21, 211, 22} .\nFormally, we use Theorem 2.9.3 for the definition of height, size, and pos as follows.\n1. Let (N, \u03b81) be the \u03a3-algebra where \u03b81 is defined as follows:\n\u2022 for each \u03b1 \u2208 \u03a3(0), we let \u03b81(\u03b1)() = 0, and \u2022 for each k \u2208 N+, \u03c3 \u2208 \u03a3 (k), and n1, . . . , nk \u2208 N, we let \u03b81(\u03c3)(n1, . . . , nk) = 1+max(n1, . . . , nk).\nMoreover, let f : H \u2192 N be defined such that, for each a \u2208 H , we let f(a) = 0. Then\nheight : T\u03a3(H)\u2192 N\nis the unique extension of f to a \u03a3-algebra homomorphism from the \u03a3-term algebra T\u03a3(H) over H to the \u03a3-algebra (N, \u03b81).\n2. Let (N, \u03b82) be the \u03a3-algebra where \u03b82 is defined as follows: for each k \u2208 N, \u03c3 \u2208 \u03a3(k), and n1, . . . , nk \u2208 N, we let \u03b82(\u03c3)(n1, . . . , nk) = 1++i\u2208[k] ni. Moreover, let f : H \u2192 N be defined such that, for each a \u2208 H , we let f(a) = 1. Then\nsize : T\u03a3(H)\u2192 N\nis the unique extension of f to a \u03a3-algebra homomorphism from the \u03a3-term algebra T\u03a3(H) over H to the \u03a3-algebra (N, \u03b82).\n3. Let (P(N+ \u2217), \u03b83) be the \u03a3-algebra where \u03b83 is defined as follows: for each k \u2208 N, \u03c3 \u2208 \u03a3(k), and\nU1, . . . , Uk \u2208 P(N+ \u2217), we let \u03b83(\u03c3)(U1, . . . , Uk) = {\u03b5} \u222a {iv | i \u2208 [k], v \u2208 Ui}. Moreover, let f : H \u2192 P(N+ \u2217) be defined such that, for each a \u2208 H , we let f(a) = {\u03b5}. Then\npos : T\u03a3(H)\u2192 P(N+ \u2217)\nis the unique extension of f to a \u03a3-algebra homomorphism from the \u03a3-term algebra T\u03a3(H) over H to the \u03a3-algebra (P(N+ \u2217), \u03b83).\nIt is easy to verify that the following equalities hold.\n(i) For each \u03b1 \u2208 \u03a3(0) \u222aH , we have height(\u03b1) = 0, size(\u03b1) = 1, and pos(\u03b1) = {\u03b5}. (ii) For each \u03be = \u03c3(\u03be1, . . . , \u03bek) with k \u2208 N+, we have:\n\u2013 height(\u03be) = 1 +max(height(\u03bei) | i \u2208 [k]), \u2013 size(\u03be) = 1 ++i\u2208[k] size(\u03bei), and \u2013 pos(\u03be) = {\u03b5} \u222a {iv | i \u2208 [k], v \u2208 pos(\u03bei)}.\nObservation 2.9.5. For the mapping fT\u03a3 : P((\u03a3 \u222a \u039e) \u2217) \u2192 P((\u03a3 \u222a \u039e)\u2217) defined in Observation 2.9.1, there is a connection between the set fn+1T\u03a3 (\u2205) and the set of \u03a3-trees of height at most n. Indeed, we can prove by induction on N that, for each n \u2208 N, we have fn+1T\u03a3 (\u2205) = {\u03be \u2208 T\u03a3 | height(\u03be) \u2264 n}.\nNext we define three mappings f , g, and h which show the label at a position of a tree, the subtree at a position of a tree, and the replacement of the subtree at a position of a tree, respectively (cf. Figure 2.6). We define these mappings by well-founded induction. For this, we define the set TP = {(\u03be, w) | \u03be \u2208 T\u03a3(H), w \u2208 pos(\u03be)} and the binary relation \u227a on TP by\n\u227a= { ( (\u03bei, v), (\u03c3(\u03be1, . . . , \u03bek), iv) ) | k \u2208 N+, \u03c3 \u2208 \u03a3 (k), \u03be1, . . . , \u03bek \u2208 T\u03a3(H), i \u2208 [k], v \u2208 pos(\u03bei)} .\nObviously, \u227a is well-founded and min\u227a(TP) = {(\u03be, \u03b5) | \u03be \u2208 T\u03a3(H)}. We define the mappings\nf : TP\u2192 \u03a3, g : TP\u2192 T\u03a3(H), and h : TP\u2192 T\u03a3(H) T\u03a3(H)\nby induction on (TP,\u227a) as follows:\nI.B.: Let \u03be \u2208 T\u03a3(H). Moreover, let \u03b6 \u2208 T\u03a3(H). Then we define f(\u03be, \u03b5), g(\u03be, \u03b5), and h(\u03be, \u03b5)(\u03b6) as follows. \u2022 If \u03be \u2208 H , then we define f(\u03be, \u03b5) = \u03be. If there exist k \u2208 N, \u03c3 \u2208 \u03a3(k), and \u03be1, . . . , \u03bek \u2208 T\u03a3(H) such that \u03be = \u03c3(\u03be1, . . . , \u03bek), then we define f(\u03be, \u03b5) = \u03c3,\n\u2022 g(\u03be, \u03b5) = \u03be, and \u2022 h(\u03be, \u03b5)(\u03b6) = \u03b6.\nI.S.: Let \u03be \u2208 T\u03a3(H) and iv \u2208 pos(\u03be) with i \u2208 N and v \u2208 N\u2217. Thus, there exists k \u2208 N+ with k \u2265 i and there exist \u03c3 \u2208 \u03a3(k) and \u03be1, . . . , \u03bek \u2208 T\u03a3(H) such that \u03be = \u03c3(\u03be1, . . . , \u03bek). Moreover, let \u03b6 \u2208 T\u03a3(H). Then we define f(\u03be, iv), g(\u03be, iv), and h(\u03be, iv)(\u03b6) as follows.\n\u2022 f(\u03be, iv) = f(\u03bei, v), \u2022 g(\u03be, iv) = g(\u03bei, v), and \u2022 h(\u03be, iv)(\u03b6) = \u03c3(\u03be1, . . . , \u03bei\u22121, h(\u03bei, v)(\u03b6), \u03bei+1, . . . , \u03bek).\nFor every \u03be, \u03b6 \u2208 T\u03a3(H) and w \u2208 pos(\u03be) we call\n\u2022 f(\u03be, w) the label of \u03be at w, and we denote it by \u03be(w), \u2022 g(\u03be, w) the subtree of \u03be at w, and we denote it by \u03be|w, and \u2022 h(\u03be, w)(\u03b6) the replacement of the subtree of \u03be at w by \u03b6, and we denote it by \u03be[\u03b6]w . For each subset Q \u2286 \u03a3 \u222aH , we define posQ : T\u03a3(H)\u2192 P(N+ \u2217) by\nposQ(\u03be) = {w \u2208 pos(\u03be) | \u03be(w) \u2208 Q}"
        },
        {
            "heading": "2.9. TREES AND TREE LANGUAGES 45",
            "text": "and, for each \u03be \u2208 T\u03a3(H), we define the set of subtrees of \u03be, denoted by sub(\u03be), as the set\nsub(\u03be) = {\u03be|w | w \u2208 pos(\u03be)} .\nIn fact, sub(\u03be) = {\u03be} \u222a {\u03be\u2032 \u2208 T\u03a3(H) | \u03be\u2032 \u227a + \u03a3,H \u03be}.\nLet \u0393 \u2286 \u03a3(0). We define the mapping yield\u0393 : T\u03a3 \u2192 \u0393 \u2217 by induction on T\u03a3 as follows.\nI.B.: Let \u03be \u2208 \u03a3(0). If \u03be \u2208 \u0393, then let yield\u0393(\u03be) = \u03be, otherwise let yield\u0393(\u03be) = \u03b5. I.S.: Let \u03be = \u03c3(\u03be1, . . . , \u03bek) with k \u2208 N+. Then we define yield\u0393(\u03be) = yield\u0393(\u03be1) \u00b7 \u00b7 \u00b7 yield\u0393(\u03bek). We abbreviate yield\u03a3(0) by yield.\nComparison. Now we wish to compare two methods for defining mappings h : T\u03a3(H)\u2192 A, where H and A are two sets.\n(1) We define the mapping h by induction on T\u03a3(H), i.e., by using the well-founded relation \u227a\u03a3,H and Theorem 2.5.1. (2) As additional information, we know that A has a \u03a3-algebra structure (A, \u03b8). Then we define h to be the unique extension of some mapping f : H \u2192 A to a \u03a3-algebra homomorphism, i.e., by using algebraic methods and, in particular, Theorem 2.9.3; this theorem guarantees that h is a \u03a3-algebra homomorphism form T\u03a3(H) to (A, \u03b8).\nObviously, Method (1) is more general than Method (2) because the first can be used to define not only \u03a3-algebra homomorphisms. For instance, let \u03a3 = {\u03c3(2), \u03b1(0), \u03b2(0)}, H = \u2205, and A = T\u03a3. Moreover, we define the mapping G : {(\u03be, g) | \u03be \u2208 T\u03a3, g : pred\u227a\u03a3(\u03be)\u2192 T\u03a3} \u2192 T\u03a3 such that for each (\u03be, g) we let\nG(\u03be, g) =\n{ \u03c3(\u03b1, g(\u03be\u2032)) if there exists \u03be\u2032 \u2208 T\u03a3 such that \u03be = \u03c3(\u03b1, \u03be\u2032)\n\u03b1 otherwise .\nAccording to Theorem 2.5.1, there exists a unique mapping h : T\u03a3 \u2192 T\u03a3 such that h(\u03be) = G(\u03be, h|pred\u227a\u03a3 (\u03be) ) for each \u03be \u2208 T\u03a3.\nWe show that h is not a \u03a3-algebra homomorphism from the \u03a3-term algebra T\u03a3 = (T\u03a3, \u03b8\u03a3) to itself. (We note that G 6= G\u03b8\u03a3,\u2205.) We prove this claim by contradiction. For this, we assume that h is a \u03a3-algebra homomorphism from T\u03a3 to itself. Then we can calculate as follows:\n\u03b1 = G(\u03c3(\u03b2, \u03b1), h|{\u03b1,\u03b2}) (by definition of G)\n= h(\u03c3(\u03b2, \u03b1)) (by definition of h)\n= \u03b8\u03a3(\u03c3)(h(\u03b2), h(\u03b1)) (because h is a \u03a3-algebra homomorphism from T\u03a3 to T\u03a3)\n= \u03c3(h(\u03b2), h(\u03b1)) (by definition of \u03b8\u03a3(\u03c3)\n= \u03c3(\u03b1, \u03b1) . (by definition of h and by definition of G)\nThis is a contradiction. Hence h is not a \u03a3-algebra homomorphism from T\u03a3 to T\u03a3.\nNevertheless, given that A = (A, \u03b8) is some \u03a3-algebra, Method (1) can also be used to define a \u03a3algebra homomorphism from T\u03a3(H) to A. However, in this case we have to prove explicitly that h is a homomorphism. By means of an example, we compare the two methods in the case that h is a \u03a3-algebra homomorphism.\nBy using Method (1): We define the mapping size1 by well-founded induction on (T\u03a3(H),\u227a\u03a3,H) with the following induction base and induction step:\nI.B.: For each a \u2208 \u03a3(0) \u222aH , we define size1(a) = 1. I.S.: For every k \u2208 N+, \u03c3 \u2208 \u03a3(k), and \u03be1, . . . , \u03bek \u2208 T\u03a3(H), we define size1(\u03c3(\u03be1, . . . , \u03bek)) = 1 + +i\u2208[k] size1(\u03bei). By Theorem 2.5.1, there exists exactly one mapping which satisfies these conditions."
        },
        {
            "heading": "46 CHAPTER 2. PRELIMINARIES",
            "text": "Now we consider the \u03a3-algebra (N, \u03b8) with \u03b8(\u03c3)(n1, . . . , nk) = 1+ \u2211 i\u2208[k] ni for every k \u2208 N, \u03c3 \u2208 \u03a3 (k), and n1, . . . , nk \u2208 N. Then we prove that size1 is a \u03a3-algebra homomorphism from T\u03a3(H) to (N, \u03b8). For every k \u2208 N, \u03c3 \u2208 \u03a3(k), and \u03be1, . . . , \u03bek \u2208 T\u03a3(H), we have\nsize1(\u03b8\u03a3(\u03c3)(\u03be1, . . . , \u03bek)) = size1(\u03c3(\u03be1, . . . , \u03bek)) = 1 ++ i\u2208[k] size1(\u03bei) = \u03b8(\u03c3)(size1(\u03be1), . . . , size1(\u03bek)) .\nHence size1 is a \u03a3-algebra homomorphism,\nBy using Method (2): We consider the \u03a3-algebra (N, \u03b8) as above and define the mapping f : H \u2192 N by f(a) = 1 for each a \u2208 H . Then Theorem 2.9.3 guarantees that there exists a unique extension of f , say, size2, into a \u03a3-algebra homomorphism from T\u03a3(H) to (N, \u03b8).\nSince size1 is a \u03a3-algebra homomorphism and size1(a) = size2(a) for each a \u2208 H , we know that size1 = size2, due to the uniqueness property.\nIn comparison, for \u03a3-algebra homomorphisms, Method (1) seems to be slightly less efficient than Method (2), because in the first we have to prove explicitly that the mapping h is a \u03a3-algebra homomorphism; while in Method (2) this is guaranteed by Theorem 2.9.3.\nRepresenting trees by tree domains. At the beginning of this section, we have defined the set T\u03a3 of \u03a3-trees as the smallest set of strings which contains the nullary symbols of \u03a3 and which is closed under top-concatenations. Here we recall an alternative way, which is equivalent.\nA tree domain is a finite and nonempty set W \u2208 (N+)\u2217 such that\n\u2022 W is prefix-closed, i.e., prefix(W ) \u2286W , and \u2022 W is left-closed, i.e., for every u \u2208 (N+) \u2217 and i \u2208 N+, if ui \u2208 W and i \u2265 2, then u(i\u2212 1) \u2208W .\nThus \u03b5 is an element of each tree domain. Obviously, for each \u03be \u2208 T\u03a3, the set pos(\u03be) is a tree domain.\nA \u03a3-tree mapping is a mapping t :W \u2192 \u03a3 such that\n\u2022 W is a tree domain and \u2022 t is rank preserving, i.e., for each w \u2208W , we have |{j \u2208 N+ | wj \u2208 W}| = rk\u03a3(t(w)).\nLet us denote the set of \u03a3-tree mappings by TF\u03a3.\nWe define the mapping \u03d5 : T\u03a3 \u2192 TF\u03a3 for each \u03be \u2208 T\u03a3 by \u03d5(\u03be) = t such that t : pos(\u03be) \u2192 \u03a3 and for each w \u2208 pos(\u03be) we let t(w) = \u03be(w). For instance, let \u03be be the tree in Figure 2.6. Then \u03d5(\u03be) = t where t : W \u2192 \u03a3 with tree domain W = {\u03b5, 1, 11, 2, 21, 211, 22} and t(\u03b5) = t(2) = \u03c3, t(1) = t(21) = \u03b3, t(11) = \u03b1, and t(211) = t(22) = \u03b2.\nWe show that \u03d5 is bijective. To show that \u03d5 is injective, let \u03be1, \u03be2 \u2208 T\u03a3 be such that \u03be1 6= \u03be2 and let \u03d5(\u03bei) = ti for i \u2208 {1, 2}. Then there exists w \u2208 pos(\u03be1) \u2229 pos(\u03be2) such that \u03be1(w) 6= \u03be2(w). By definition of \u03d5, we have t1(w) 6= t2(w), i.e. t1 6= t2. Hence \u03d5 is injective.\nFor the proof of surjectivity of \u03d5, we define the well-founded set (TD,\u227a) where TD is the set of all tree domains and W \u2032 \u227a W if there exists i \u2208 N+ such that W \u2032 = {w \u2208 (N+) \u2217 | iw \u2208 W}. Then min\u227a(TD) = {{\u03b5}}. By induction on (TD,\u227a), we prove that the following statement holds:\nFor every W \u2208 TD and \u03a3-tree mapping t :W \u2192 \u03a3,\nthere exists a \u03be \u2208 T\u03a3 such that W = pos(\u03be) and \u03d5(\u03be) = t. (2.25)\nFor the proof, let W \u2208 TD and t :W \u2192 \u03a3 be a \u03a3-tree mapping. Then there exist k \u2208 N and \u03c3 \u2208 \u03a3 such that t(\u03b5) = \u03c3. Moreover, for each i \u2208 [k], we define Wi = {w \u2208 (N+)\u2217 | iw \u2208 W} and the \u03a3-tree mapping ti :Wi \u2192 \u03a3 by ti(w) = t(iw) for each w \u2208 Wi. Then W = {\u03b5} \u222a {iw | i \u2208 [k], w \u2208Wi}.\nSince {W \u2032 \u2208 TD | W \u2032 \u227a W} = {W1, . . . ,Wk}, the I.H. implies that, for each i \u2208 [k], there exists \u03bei \u2208 T\u03a3 such that Wi = pos(\u03bei) and \u03d5(\u03bei) = ti.\nThen let \u03be = \u03c3(\u03be1, . . . , \u03bek). We claim that \u03d5(\u03be) = t. First, by definition we have that \u03d5(\u03be) : pos(\u03be)\u2192 \u03a3. Moreover,\npos(\u03be) = {\u03b5} \u222a {iw | i \u2208 [k], w \u2208 pos(\u03bei)} = {\u03b5} \u222a {iw | i \u2208 [k], w \u2208Wi} =W ,"
        },
        {
            "heading": "2.9. TREES AND TREE LANGUAGES 47",
            "text": "where the second equality follows from I.H. Second, for the proof of \u03d5(\u03be) = t we let w \u2208 W . If w = \u03b5, then \u03be(w) = \u03c3 = t(w). If w = iw\u2032 for some i \u2208 N+ and w\u2032 \u2208 Wi, then\n\u03be(iw\u2032) = \u03bei(w \u2032) = ti(w \u2032) = t(iw\u2032) ,\nwhere the second equality follows from I.H. Hence \u03d5(\u03be) = t. This proves (2.25), and hence \u03d5 is surjective.\nSince \u03d5 is bijective we can specify a tree \u03be \u2208 T\u03a3 also by means of a \u03a3-tree mapping (cf., e.g., the proofs of Lemma 8.3.3, of Theorem 10.6.1, and of Theorem 11.3.1).\nOrders on positions of trees. The prefix order on pos(\u03be), denoted by \u2264pref , is the partial order defined for every w, v \u2208 pos(\u03be) by\nw \u2264pref v iff w \u2208 prefix(v) .\nWe let w <pref v if (w \u2264pref v) \u2227 (w 6= v).\nThe lexicographic order on pos(\u03be), denoted by \u2264lex, is the linear order defined for every w, v \u2208 pos(\u03be) by\nw \u2264lex v iff (w \u2208 prefix(v)) \u2228 (\u2203u \u2208 prefix(w) \u2229 prefix(v))(\u2203i, j \u2208 N+) :\n(ui \u2208 prefix(w)) \u2227 (uj \u2208 prefix(v)) \u2227 (i < j) .\nThe lexicographic order is also called depth-first pre-order. We let w <lex v if (w \u2264lex v) \u2227 (w 6= v).\nThe depth-first post-order on pos(\u03be), denoted by \u2264dp, is the linear order defined for every w, v \u2208 pos(\u03be) by\nw \u2264dp v iff (v \u2208 prefix(w)) \u2228 (\u2203u \u2208 prefix(w) \u2229 prefix(v))(\u2203i, j \u2208 N+) :\n(ui \u2208 prefix(w)) \u2227 (uj \u2208 prefix(v)) \u2227 (i < j) .\nWe let w <dp v if (w \u2264dp v) \u2227 (w 6= v).\nTree relabelings. A (\u03a3,\u2206)-tree relabeling (or simply: tree relabeling) [Eng75b, Def. 3.1] is an Nindexed family \u03c4 = (\u03c4k | k \u2208 N) of mappings \u03c4k : \u03a3(k) \u2192 P(\u2206(k)). We call a tree relabeling \u03c4\n\u2022 non-overlapping if \u03c4k(\u03c3) \u2229 \u03c4k(\u03c3\u2032) = \u2205 for every k \u2208 N and \u03c3, \u03c3\u2032 \u2208 \u03a3(k) with \u03c3 6= \u03c3\u2032. \u2022 deterministic if for every k \u2208 N and \u03c3 \u2208 \u03a3(k), the set \u03c4k(\u03c3) contains exactly one element. Then we specify the tree relabeling as an N-indexed family of mappings \u03c4k : \u03a3 (k) \u2192 \u2206(k).\nNow let \u03c4 = (\u03c4k | k \u2208 N) be a (\u03a3,\u2206)-tree relabeling. We extend \u03c4 to the mapping\n\u03c4 \u2032 : T\u03a3 \u2192 Pfin(T\u2206)\nby using Theorem 2.9.3 as follows. We define the \u03a3-algebra (Pfin(T\u2206), \u03b8\u03c4 ) such that, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and U1, . . . , Uk \u2208 Pfin(T\u2206), we let\n\u03b8\u03c4 (\u03c3)(U1, . . . , Uk) = {\u03b3(\u03b61, . . . , \u03b6k) | \u03b3 \u2208 \u03c4k(\u03c3), \u03b61 \u2208 U1, . . . , \u03b6k \u2208 Uk} .\nThen \u03c4 \u2032 : T\u03a3 \u2192 Pfin(T\u2206) is the unique \u03a3-homomorphism h from the \u03a3-term algebra T\u03a3 to the \u03a3-algebra (Pfin(T\u2206), \u03b8\u03c4 ) (cf. Theorem 2.9.3). We also call the mapping \u03c4\n\u2032 : T\u03a3 \u2192 Pfin(T\u2206) a (\u03a3,\u2206)-tree relabeling (or simply: tree relabeling) and we abbreviate \u03c4 \u2032 by \u03c4 . The mapping \u03c4 can also be considered as a binary relation \u03c4 \u2286 T\u03a3 \u00d7 T\u2206, and thus, in particular, \u03c4\u22121 is defined.\nWe note that pos(\u03b6) = pos(\u03be) for each \u03b6 \u2208 \u03c4(\u03be). Thus, for every \u03b6 \u2208 T\u2206, the set \u03c4\u22121(\u03b6) is finite and, if \u03c4 is non-overlapping, then |\u03c4\u22121(\u03b6)| \u2264 1. If \u03c4 is deterministic, then for every \u03be \u2208 T\u03a3 we have |\u03c4(\u03be)| = 1.\nLet \u2126 be a ranked alphabet, \u03c9 = (\u03c9k | k \u2208 N) be a (\u03a3,\u2126)-tree relabeling, and \u03c4 = (\u03c4k | k \u2208 N) be a (\u2126,\u2206)-tree relabeling. The syntactic composition of \u03c9 and \u03c4 , denoted by \u03c4 \u25e6\u0302\u03c9, is the (\u03a3,\u2206)-tree relabeling ((\u03c4 \u25e6\u0302\u03c9)k | k \u2208 N) such that (\u03c4 \u25e6\u0302\u03c9)k = \u03c4k \u25e6 \u03c9k, i.e., (\u03c4 \u25e6\u0302\u03c9)k(\u03c3) = \u22c3 \u03b4\u2208\u03c9k(\u03c3) \u03c4k(\u03b4) for every k \u2208 N and \u03c3 \u2208 \u03a3(k). It follows that if \u03c9 and \u03c4 are deterministic, then \u03c4 \u25e6\u0302\u03c9 is also deterministic."
        },
        {
            "heading": "48 CHAPTER 2. PRELIMINARIES",
            "text": "Theorem 2.9.6. (cf. [Eng75a, Lm. 3.4]) Let \u2126 be a ranked alphabet, \u03c9 be a (\u03a3,\u2126)-tree relabeling, and \u03c4 be a (\u2126,\u2206)-tree relabeling. Then \u03c4 \u25e6\u0302\u03c9 = \u03c4 \u25e6 \u03c9, i.e., the syntactic composition of \u03c9 and \u03c4 determines the mapping \u03c4 \u25e6 \u03c9.\nContexts and substitution. Next we define contexts. Let Z = {z1, z2, . . .} be a set of variables, disjoint with \u03a3, and let Zn = {z1, . . . , zn} for every n \u2208 N. Sometimes we write z for z1. Moreover, let \u03be \u2208 T\u03a3(Z) and V \u2286 Z. We say that \u03be is linear in V (\u03be is nondeleting in V ) if for each z \u2208 V we have |posz(\u03be)| \u2264 1 (and |posz(\u03be)| \u2265 1, respectively). We denote by C\u03a3(Zn) the set of all trees \u03be \u2208 T\u03a3(Zn) which are both linear and nondeleting in Zn. Since Z0 = \u2205, we have C\u03a3(Z0) = T\u03a3. We call the elements of C\u03a3(Zn) contexts over \u03a3 and Zn (or: n-contexts if \u03a3 is clear). We abbreviate C\u03a3({z}) by C\u03a3 and call its elements contexts.\nNow we define tree substitution (cf. derived operator in [GTWW77, p. 73]). Let H be a set disjoint with \u03a3; moreover, let n \u2208 N, \u03be \u2208 T\u03a3(Zn), and \u03be1, . . . , \u03ben \u2208 T\u03a3(H). Intuitively, we want to define the tree in T\u03a3(H) which is obtained from \u03be by replacing, for each zi \u2208 Zn, each occurrence of zi by \u03bei. Formally, let v : Zn \u2192 T\u03a3(H) be the mapping defined by v(zi) = \u03bei for each i \u2208 [n]. Then we denote by v the unique extension of v to a \u03a3-algebra homomorphism from the \u03a3-term algebra (T\u03a3(Zn), \u03b8\u03a3) over Zn to the \u03a3-term algebra (T\u03a3(H), \u03b8\u03a3) over H . It is easy to see that v(\u03be) is the desired tree from our informal discussion. In the sequel, we abbreviate v(\u03be) by \u03be[\u03be1, . . . , \u03ben]. For n = 1 and H = {z}, we also denote \u03be[\u03be1] by \u03be \u25e6z \u03be1. Hence, \u25e6z can be thought of as a binary operation on T\u03a3({z}).\nIn the rest of the book, Z and X will denote sets of variables if not specified otherwise. Moreover, we let Zn = {z1, . . . , zn} and Xn = {x1, . . . , xn} for every n \u2208 N.\nTree homomorphisms. A (\u03a3,\u2206)-tree homomorphism (or just tree homomorphism) [Eng75b, Def. 3.62] is a family h = (hk | k \u2208 N) of mappings hk : \u03a3(k) \u2192 T\u2206(Zk). We call a tree homomorphism h\n\u2022 linear if, for every k \u2208 N and \u03c3 \u2208 \u03a3(k), the tree hk(\u03c3) is linear in Zk; \u2022 nondeleting if, for every k \u2208 N and \u03c3 \u2208 \u03a3(k), the tree hk(\u03c3) is nondeleting in Zk; \u2022 alphabetic if, for every k \u2208 N and \u03c3 \u2208 \u03a3(k), we have |pos\u2206(hk(\u03c3))| \u2264 1; \u2022 productive if, for every k \u2208 N and \u03c3 \u2208 \u03a3(k), we have hk(\u03c3) 6\u2208 Zk (this notion is borrowed from [FMV10] where it was called output-productive); \u2022 ordered if h is linear and nondeleting and, for every k \u2208 N and \u03c3 \u2208 \u03a3(k), the sequence of variables occurring in hk(\u03c3) is ordered by increasing indices from left to right, i.e., it is z1, . . . , zk; \u2022 simple if h is alphabetic and ordered (and hence also linear and nondeleting).\nNow let H be a set disjoint with \u03a3 and \u2206. Moreover, let h = (hk | k \u2208 N) be a (\u03a3,\u2206)-tree homomorphism. We extend h to the mapping\nh : T\u03a3(H)\u2192 T\u2206(H)\nby using Theorem 2.9.3 as follows. We define the \u03a3-algebra (T\u2206(H), \u03b8h) such that, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and \u03be1, . . . , \u03bek \u2208 T\u2206(H), we let\n\u03b8h(\u03c3)(\u03be1, . . . , \u03bek) = hk(\u03c3)[\u03be1, . . . , \u03bek] .\nThen h : T\u03a3(H)\u2192 T\u2206(H) is the unique extension of idH to a \u03a3-algebra homomorphism from the \u03a3-term algebra (T\u03a3(H), \u03b8\u03a3) over H to the \u03a3-algebra (T\u2206(H), \u03b8h) (cf. Theorem 2.9.3).\nWe also call the mapping h : T\u03a3(H) \u2192 T\u2206(H) a (\u03a3,\u2206)-tree homomorphism (or simply: tree homomorphism).\nWe note that each deterministic tree relabeling can be thought of as a particular tree homomorphism. Indeed, let (\u03c4k | k \u2208 N) be a deterministic (\u03a3,\u2206)-tree relabeling. Then \u03c4 determines the (\u03a3,\u2206)-tree"
        },
        {
            "heading": "2.10. WEIGHTED TREE LANGUAGES AND TRANSFORMATIONS 49",
            "text": "homomorphism (\u03c4 \u2032k | k \u2208 N) where, for every k \u2208 N and \u03c3 \u2208 \u03a3 (k), we have \u03c4 \u2032k(\u03c3) = \u03c4k(\u03c3)(z1, . . . , zk). It is obvious that \u03c4 = \u03c4 \u2032.\nLet \u2126 be a ranked alphabet, g = (gk | k \u2208 N) be a (\u03a3,\u2126)-tree homomorphism, and h = (hk | k \u2208 N) be an (\u2126,\u2206)-tree homomorphism. The syntactic composition of g and h, denoted by h\u25e6\u0302g, is the (\u03a3,\u2206)-tree homomorphism ((h\u25e6\u0302g)k | k \u2208 N) such that (h\u25e6\u0302g)k(\u03c3) = h(gk(\u03c3)) for every k \u2208 N and \u03c3 \u2208 \u03a3(k).\nTheorem 2.9.7. (cf. [Eng75a, Lm. 3.4], [GS84, Thm. 4.3.7]) Let \u2126 be a ranked alphabet, g be a (\u03a3,\u2126)-tree homomorphism, and h be an (\u2126,\u2206)-tree homomorphism. Then h\u25e6\u0302g = h \u25e6 g, i.e., the syntactic composition of g and h determines the mapping h \u25e6 g."
        },
        {
            "heading": "2.10 Weighted tree languages and transformations",
            "text": ""
        },
        {
            "heading": "2.10.1 Weighted sets and weighted languages",
            "text": "Let B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid, A be a set, and f : A \u2192 B be a mapping. We will define several notions for and characteristics of f . We call f a B-weighted set. We note that if B1 and B2 are different strong bimonoids with the same carrier set B, then a mapping f : A\u2192 B is both a B1-weighted set and a B2-weighted set.\nLet f : A\u2192 B be a B-weighted set. The support of f , denoted by suppB(f), is defined by suppB(f) = {a \u2208 A | f(a) 6= 0}. If B is clear from the context, then we abbreviate suppB(f) by supp(f).\nWe call f\n\u2022 polynomial if supp(f) is finite. \u2022 monomial if supp(f) \u2286 {a} for some a \u2208 A; then we denote f also by f(a).a .\n\u2022 constant if there exists a b \u2208 B such that for every a \u2208 A, we have f(a) = b; then we denote f by b\u0303.\nWe note that 0\u0303 is a monomial and 0\u0303 = 0.a for each a \u2208 A.\nLet L \u2286 A. The characteristic mapping of L with respect to B, denoted by \u03c7B(L), is the B-weighted set \u03c7B(L) : A \u2192 B defined, for each a \u2208 A, by \u03c7B(L)(a) = 1 if a \u2208 L, and \u03c7B(L)(a) = 0 otherwise. In particular, \u03c7B(\u2205) = 0\u0303 and \u03c7B({a}) = 1.a. Certainly, suppB(\u03c7B(L)) = L and, if |B| > 2, then there exists a B-weighted set f : A \u2192 B such that \u03c7B(suppB(f)) 6= f . However, for each Boole-weighted set f : A\u2192 B, we have \u03c7Boole(suppBoole(f)) = f . If B is clear from the context, then we abbreviate \u03c7B by \u03c7.\nA weighted language over \u0393 and B (for short: (\u0393,B)-weighted language) is a B-weighted set r : \u0393\u2217 \u2192 B."
        },
        {
            "heading": "2.10.2 Weighted tree languages and operations",
            "text": "LetH be a set with \u03a3\u2229H = \u2205. A weighted tree language over \u03a3, H, and B is a weighted set r : T\u03a3(H)\u2192 B. If H = \u2205, then we just say weighted tree language over \u03a3 and B or (\u03a3,B)-weighted tree language. A Bweighted tree language is a (\u03a3,B)-weighted tree language for some ranked alphabet \u03a3. A weighted \u03a3-tree language is a (\u03a3,B)-weighted tree language for some strong bimonoid B. Finally, a weighted tree language is a (\u03a3,B)-weighted tree language for some ranked alphabet \u03a3 and some strong bimonoid B.\nA (\u03a3,B)-weighted tree language r has the preimage property if, for each b \u2208 B, the \u03a3-tree language r\u22121(b) is recognizable (in the sense of Section 2.13).\nWe denote the set of polynomial (\u03a3,B)-weighted tree languages by Pol(\u03a3,B). We call each element of Pol(\u03a3,B) a (\u03a3,B)-polynomial.\nWe extend the concept of support to sets of weighted tree languages in the natural way: for each set C of weighted tree languages, we define supp(C) = {supp(r) | r \u2208 C}.\nLet r : T\u03a3 \u2192 B and b \u2208 B. The scalar multiplication of r with b from the left (with respect to B), denoted by b \u2297 r, is the weighted tree language (b \u2297 r) : T\u03a3 \u2192 B defined for each \u03be \u2208 T\u03a3 by (b\u2297 r)(\u03be) = b\u2297 r(\u03be). In a similar way, we define the scalar multiplication of r with b from the right (with"
        },
        {
            "heading": "50 CHAPTER 2. PRELIMINARIES",
            "text": "respect to B) and denote it by r \u2297 b.\nLet r1 : T\u03a3 \u2192 B and r2 : T\u03a3 \u2192 B. The sum of r1 and r2 (with respect to B), denoted by (r1 \u2295 r2), is the weighted tree language (r1\u2295r2) : T\u03a3 \u2192 B defined for each \u03be \u2208 T\u03a3 by (r1\u2295r2)(\u03be) = r1(\u03be)\u2295r2(\u03be). The algebra (BT\u03a3 ,\u2295, 0\u0303) is a commutative monoid. If B is \u03c3-complete, then also this monoid is \u03c3-complete.\nMoreover, the Hadamard product of r1 and r2 (with respect to B), denoted by (r1\u2297r2), is the weighted tree language (r1 \u2297 r2) : T\u03a3 \u2192 B defined for each \u03be \u2208 T\u03a3 by (r1 \u2297 r2)(\u03be) = r1(\u03be)\u2297 r2(\u03be). In general, the Hadamard product is not commutative. However, for each L \u2286 T\u03a3, the equality r1 \u2297 \u03c7(L) = \u03c7(L)\u2297 r1 holds.\nThe algebra (BT\u03a3 ,\u2297, 1\u0303) is a monoid. Since 0\u0303 \u2297 r = r \u2297 0\u0303 = 0\u0303 for each r \u2208 BT\u03a3 , the algebra (BT\u03a3 ,\u2295,\u2297, 0\u0303, 1\u0303) is a strong bimonoid. If B is a semiring, then so is (BT\u03a3 ,\u2295,\u2297, 0\u0303, 1\u0303). In particular, the semiring (BT\u03a3 ,\u2295,\u2297, 0\u0303, 1\u0303) is isomorphic to the semiring (P(T\u03a3),\u222a,\u2229, \u2205,T\u03a3).\nLet r : T\u03a3 \u2192 B and L \u2286 T\u03a3 be finite. Then we define r(L) \u2208 B by r(L) = \u2295 \u03be\u2208L r(\u03be).\nEvaluation algebras. We define particular (\u03a3,B)-weighted tree languages; they are the unique \u03a3algebra homomorphisms from T\u03a3 to \u03a3-algebras which are based on the evaluation of \u03a3-symbols in B.\nFormally, let \u03ba = (\u03bak | k \u2208 N) be an N-indexed family of mappings \u03bak : \u03a3(k) \u2192 B. The (\u03a3, \u03ba)evaluation algebra, denoted by M(\u03a3, \u03ba), is the \u03a3-algebra (B, \u03ba), where\n\u03ba(\u03c3)(b1, . . . , bk) = b1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 bk \u2297 \u03bak(\u03c3)\nfor every k \u2208 N, \u03c3 \u2208 \u03a3(k), and b1, . . . , bk \u2208 B. We recall that hM(\u03a3,\u03ba) denotes the unique \u03a3-algebra homomorphism from T\u03a3 to M(\u03a3, \u03ba). Then, for each \u03be = \u03c3(\u03be, . . . , \u03bek) in T\u03a3, we have\nhM(\u03a3,\u03ba)(\u03be) = \u03ba(\u03c3)(hM(\u03a3,\u03ba)(\u03be1), . . . , hM(\u03a3,\u03ba)(\u03bek)) = (\u2297\ni\u2208[k]\nhM(\u03a3,\u03ba)(\u03bei) ) \u2297 \u03bak(\u03c3) . (2.26)\nObviously, we have\nhM(\u03a3,\u03ba)(\u03be) = \u2297\nw\u2208pos(\u03be) in \u2264dp order\n\u03bark(\u03be(w))(\u03be(w)) . (2.27)\nIn particular, hM(\u03a3,\u03ba) : T\u03a3 \u2192 B is a (\u03a3,B)-weighted tree language."
        },
        {
            "heading": "2.10.3 Weighted tree transformations",
            "text": "Let A be a set and \u03c4 : T\u03a3 \u00d7A\u2192 B a B-weighted set. We say that\n\u2022 \u03c4 is supp-i-finite if, for every a \u2208 A, the set {\u03be \u2208 T\u03a3 | \u03c4(\u03be, a) 6= 0} is finite; \u2022 \u03c4 is supp-o-finite if, for every \u03be \u2208 T\u03a3, the set {a \u2208 A | \u03c4(\u03be, a) 6= 0} is finite.\nHere supp-i-finite and supp-o-finite abbreviate \u201csupport input finite\u201d and \u201csupport output finite\u201d, respectively. If A = T\u2206, then we call \u03c4 a (\u03a3,\u2206,B)-weighted tree transformation or simply weighted tree transformation.\nLet r : T\u03a3 \u2192 B be a weighted tree language and \u03c4 : T\u03a3 \u00d7A \u2192 B be a B-weighted set. We say that r is \u03c4-summable if \u03c4 is supp-i-finite or r has finite support. If r is \u03c4 -summable or B is \u03c3-complete, then the application of \u03c4 to r, denoted by \u03c4(r), is the B-weighted set \u03c4(r) : A\u2192 B defined, for each a \u2208 A, by\n\u03c4(r)(a) = \u2211\u2295\n\u03be\u2208T\u03a3\nr(\u03be) \u2297 \u03c4(\u03be, a) . (2.28)\nObviously, if r is \u03c4 -summable, then \u2211\u2295\n\u03be\u2208T\u03a3\nr(\u03be) \u2297 \u03c4(\u03be, a) = \u2295\n\u03be\u2208T\u03a3\nr(\u03be)\u2297 \u03c4(\u03be, a) . (2.29)\nWe will use this application in three different scenarios."
        },
        {
            "heading": "2.10. WEIGHTED TREE LANGUAGES AND TRANSFORMATIONS 51",
            "text": "Scenario 1. In this scenario, \u03c4 is the characteristic mapping of a binary relation. Formally, let r : T\u03a3 \u2192 B and g \u2286 T\u03a3 \u00d7A. If r is \u03c7(g)-summable or B is \u03c3-complete, then for each a \u2208 A we have\n\u03c7(g)(r)(a) = \u2211\u2295\n\u03be\u2208T\u03a3\nr(\u03be) \u2297 \u03c7(g)(\u03be, a) = \u2211\u2295\n\u03be\u2208g\u22121(a)\nr(\u03be) . (2.30)\nWe will use the following five cases of this scenario. In Case (a) we have A = \u0393\u2217, and in Cases (b)-(e) we have A = T\u2206. Moreover, \u03c4 is the characteristic mapping of\n(a) a yield mapping g : T\u03a3 \u2192 \u0393 \u2217, where \u0393 \u2286 \u03a3(0) is an alphabet (Section 8.3), (b) a tree relabeling g \u2286 T\u03a3 \u00d7 T\u2206 (Section 10.10), (c) a tree homomorphism g : T\u03a3 \u2192 T\u2206 (Section 10.11), (d) the inverse of a tree homomorphism g \u2286 T\u2206 \u00d7 T\u03a3 (Section 10.12), and (e) a tree relabeling g \u2286 T\u03a3 \u00d7 T\u2206 (Subsection 14.5.1).\nAs a consequence of (2.30), we obtain the following inclusion and equality:\nsupp(\u03c7(g)(r)) \u2286 g(supp(r)) and,\nif B is zero-sum free, then supp(\u03c7(g)(r)) = g(supp(r)) . (2.31)\nFirst we prove the inclusion. For this, let a \u2208 A. Then we have\na \u2208 supp(\u03c7(g)(r)) \u21d0\u21d2 ( \u2211\u2295\n\u03be\u2208g\u22121(a)\nr(\u03be) ) 6= 0 (by (2.30))\n=\u21d2 (\u2203\u03be \u2208 g\u22121(a)) : r(\u03be) 6= 0 (by Observation 2.6.8)\n\u21d0\u21d2 a \u2208 g(supp(r)) .\nIf B is zero-sum free, then the above implication can be turned into an equivalence by Observation 2.6.11(8) or (9), respectively.\nThe next observation will be useful later.\nObservation 2.10.1. Let g \u2286 T\u03a3 \u00d7 T\u2206 be a (\u03a3,\u2206)-tree relabeling, r : T\u03a3 \u2192 B, L \u2286 T\u03a3, and \u03be \u2208 T\u2206. Then \u03c7(g) ( \u03c7(L)\u2297 r ) (\u03be) = r(g\u22121(\u03be) \u2229 L).\nProof.\nr(g\u22121(\u03be) \u2229 L) = \u2295\n\u03b6\u2208g\u22121(\u03be)\u2229L\nr(\u03b6) (we note that g\u22121(\u03be) \u2229 L is finite)\n= \u2295\n\u03b6\u2208g\u22121(\u03be)\n\u03c7(L)(\u03b6) \u2297 r(\u03b6) = \u2295\n\u03b6\u2208g\u22121(\u03be)\n( \u03c7(L)\u2297 r ) (\u03b6)\n= \u03c7(g) ( \u03c7(L)\u2297 r ) (\u03be) . (by (2.30))\nScenario 2. In this scenario, A = T\u03a3 and \u03c4 is the diagonalization of a (\u03a3,B)-tree language r \u2032 : T\u03a3 \u2192 B. We define the diagonalization of r\u2032 [FMV11, Sect. 2.6] to be the (\u03a3,\u03a3,B)-weighted tree transformation r\u2032 : T\u03a3 \u00d7 T\u03a3 \u2192 B such that, for every \u03be, \u03b6 \u2208 T\u03a3, we let\nr\u2032(\u03be, \u03b6) =\n{ r\u2032(\u03be) if \u03be = \u03b6\n0 otherwise . (2.32)"
        },
        {
            "heading": "52 CHAPTER 2. PRELIMINARIES",
            "text": "Obviously, r\u2032 is supp-i-finite and hence, for each r : T\u03a3 \u2192 B, the application r\u2032(r) is defined. Then the application of the diagonalization of r\u2032 to r is the Hadamard product of r and r\u2032, i.e., r\u2032(r) = r \u2297 r\u2032, because for each \u03b6 \u2208 T\u03a3 we have\n(r\u2032(r))(\u03b6) = \u2211\u2295\n\u03be\u2208T\u03a3\nr(\u03be) \u2297 r\u2032(\u03be, \u03b6) = r(\u03b6) \u2297 r\u2032(\u03b6) = (r \u2297 r\u2032)(\u03b6) . (2.33)\nIn the sequel we will sometimes drop the bar from r\u2032. Then it will be clear from the context whether r\u2032 denotes a (\u03a3,B)-weighted tree language or its diagonalization. We will use this type of application, e.g., in the alternative proof of closure of the set of recognizable weighted tree languages under Hadamard product (cf. Subsection 10.13.6).\nScenario 3. Finally, in this scenario, we have A = T\u2206, i.e., \u03c4 is a (\u03a3,\u2206,B)-weighted tree transformation. Let r : T\u03a3 \u2192 B and \u03c4 : T\u03a3 \u00d7 T\u2206 \u2192 B. If r is \u03c4 -summable or B is \u03c3-complete, then for each \u03b6 \u2208 T\u2206 we have\n\u03c4(r)(\u03b6) = \u2211\u2295\n\u03be\u2208T\u03a3\nr(\u03be) \u2297 \u03c4(\u03be, \u03b6) . (2.34)\nWe will use this type of application, e.g., in Section 10.13 and in Chapter 15.\nNext we define the composition of weighted tree transformations. Let \u2126 be a ranked alphabet and \u03c4 : T\u03a3 \u00d7 T\u2206 \u2192 B and \u03c4 \u2032 : T\u2206 \u00d7 T\u2126 \u2192 B be weighted tree transformations. If \u03c4 is supp-o-finite, \u03c4 \u2032 is supp-i-finite, or B is \u03c3-complete, then we define the composition of \u03c4 and \u03c4 \u2032 to be the weighted tree transformation (\u03c4 ; \u03c4 \u2032) : T\u03a3 \u00d7 T\u2126 \u2192 B defined by\n(\u03c4 ; \u03c4 \u2032)(\u03be, \u03b6) = \u2211\u2295\n\u03b7\u2208T\u2206\n\u03c4(\u03be, \u03b7) \u2297 \u03c4 \u2032(\u03b7, \u03b6) (2.35)\nfor every \u03be \u2208 T\u03a3 and \u03b6 \u2208 T\u2126. Clearly, if \u03c4 is supp-o-finite or \u03c4 \u2032 is supp-i-finite, then\n\u2211\u2295\n\u03b7\u2208T\u2206\n\u03c4(\u03be, \u03b7) \u2297 \u03c4 \u2032(\u03b7, \u03b6) = \u2295\n\u03b7\u2208T\u2206\n\u03c4(\u03be, \u03b7) \u2297 \u03c4 \u2032(\u03b7, \u03b6) .\nWe show that, roughly speaking, if B is a semiring, then the composition of weighted tree transformations is associative. Intuitively, the conditions P1 and P2 of the next observation guarantee that the expressions (\u03c41; \u03c42); \u03c43 and \u03c41; (\u03c42; \u03c43), respectively, are well defined.\nObservation 2.10.2. Let B be a semiring. Moreover, let \u2126 and \u03a8 be ranked alphabets and \u03c41 : T\u03a3 \u00d7 T\u2206 \u2192 B, \u03c42 : T\u2206 \u00d7 T\u2126 \u2192 B, and \u03c43 : T\u2126 \u00d7 T\u03a8 \u2192 B be weighted tree transformations such that the condition P1 \u2227 P2 holds or B is \u03c3-complete, where\n\u2022 P1: [\u03c41 is supp-o-finite or \u03c42 is supp-i-finite] and [\u03c41; \u03c42 is supp-o-finite or \u03c43 is supp-i-finite] and \u2022 P2: [\u03c42 is supp-o-finite or \u03c43 is supp-i-finite] and [\u03c41 is supp-o-finite or \u03c42; \u03c43 is supp-i-finite].\nThen (\u03c41; \u03c42); \u03c43 = \u03c41; (\u03c42; \u03c43).\nProof. Due to the first conjunct (and the second conjunct) of P1 the compositions \u03c41; \u03c42 (and (\u03c41; \u03c42); \u03c43, respectively) are defined. Moreover, due to the first conjunct (and the second conjunct) of P2 the compositions \u03c42; \u03c43 (and \u03c41; (\u03c42; \u03c43), respectively) are defined.\nLet \u03be \u2208 T\u03a3 and \u03b6 \u2208 T\u03a8. Then\n( (\u03c41; \u03c42); \u03c43 ) (\u03be, \u03b6) = \u2211\u2295\n\u03b7\u2208T\u2126\n(\u03c41; \u03c42)(\u03be, \u03b7)\u2297 \u03c43(\u03b7, \u03b6) = \u2211\u2295\n\u03b7\u2208T\u2126\n(\u2211\u2295\n\u03b8\u2208T\u2206\n\u03c41(\u03be, \u03b8)\u2297 \u03c42(\u03b8, \u03b7) ) \u2297 \u03c43(\u03b7, \u03b6)\n2.11. FINITE-STATE STRING AUTOMATA 53\n= \u2211\u2295\n\u03b7\u2208T\u2126\n(\u2211\u2295\n\u03b8\u2208T\u2206\n\u03c41(\u03be, \u03b8)\u2297 \u03c42(\u03b8, \u03b7)\u2297 \u03c43(\u03b7, \u03b6) )\n(by right-distributivity)\n= \u2211\u2295\n\u03b8\u2208T\u2206\n\u03c41(\u03be, \u03b8)\u2297 (\u2211\u2295\n\u03b7\u2208T\u2126\n\u03c42(\u03b8, \u03b7)\u2297 \u03c43(\u03b7, \u03b6) )\n(by left-distributivity)\n= \u2211\u2295\n\u03b8\u2208T\u2206\n\u03c41(\u03be, \u03b8)\u2297 (\u03c42; \u03c43)(\u03b8, \u03b6) = ( \u03c41; (\u03c42; \u03c43) ) (\u03be, \u03b6).\nNext we show that, roughly speaking, if B is a semiring, then the application of the composition of weighted tree transformations \u03c41 and \u03c42 to a weighted tree language r can be expressed as the consecutive applications of \u03c41 and \u03c42 to r. Intuitively, the conditions P1 and P2 of the next observation guarantee that the expressions (\u03c4 ; \u03c4 \u2032)(r) and \u03c4 \u2032(\u03c4(r)), respectively, are well defined.\nObservation 2.10.3. Let B be a semiring. Moreover, let \u2126 be a ranked alphabet, \u03c4 : T\u03a3\u00d7T\u2206 \u2192 B and \u03c4 \u2032 : T\u2206 \u00d7 T\u2126 \u2192 B be weighted tree transformations, and let r : T\u03a3 \u2192 B be a weighted tree language such that the condition P1 \u2227 P2 holds or B is \u03c3-complete, where\n\u2022 P1: [\u03c4 is supp-o-finite or \u03c4 \u2032 is supp-i-finite] and [\u03c4 ; \u03c4 \u2032 is supp-i-finite or r has finite support] and \u2022 P2: [\u03c4 is supp-i-finite or r has finite support] and [\u03c4 \u2032 is supp-i-finite or \u03c4(r) has finite support].\nThen we have (\u03c4 ; \u03c4 \u2032)(r) = \u03c4 \u2032(\u03c4(r)).\nProof. Due to the first conjunct (and the second conjunct) of P1 the composition \u03c4 ; \u03c4 \u2032 (and the application (\u03c4 ; \u03c4 \u2032)(r), respectively) are defined. Moreover, due to the first conjunct (and the second conjunct) of P2 the applications \u03c4(r) (and \u03c4 \u2032(\u03c4(r)), respectively) are defined.\nLet \u03b8 \u2208 T\u2126. Then\n(\u03c4 ; \u03c4 \u2032)(r)(\u03b8) = \u2211\u2295\n\u03be\u2208T\u03a3\nr(\u03be) \u2297 (\u03c4 ; \u03c4 \u2032)(\u03be, \u03b8) = \u2211\u2295\n\u03be\u2208T\u03a3\nr(\u03be) \u2297 \u2211\u2295\n\u03b6\u2208T\u2206\n\u03c4(\u03be, \u03b6) \u2297 \u03c4 \u2032(\u03b6, \u03b8)\n= \u2211\u2295\n\u03be\u2208T\u03a3\n\u2211\u2295\n\u03b6\u2208T\u2206\nr(\u03be) \u2297 \u03c4(\u03be, \u03b6) \u2297 \u03c4 \u2032(\u03b6, \u03b8) (by left-distributivity)\n= \u2211\u2295\n\u03b6\u2208T\u2206\n\u2211\u2295\n\u03be\u2208T\u03a3\nr(\u03be) \u2297 \u03c4(\u03be, \u03b6) \u2297 \u03c4 \u2032(\u03b6, \u03b8)\n= \u2211\u2295\n\u03b6\u2208T\u2206\n(\u2211\u2295\n\u03be\u2208T\u03a3\nr(\u03be) \u2297 \u03c4(\u03be, \u03b6) ) \u2297 \u03c4 \u2032(\u03b6, \u03b8) (by right-distributivity)\n= \u2211\u2295\n\u03b6\u2208T\u2206\n\u03c4(r)(\u03b6) \u2297 \u03c4 \u2032(\u03b6, \u03b8) = \u03c4 \u2032(\u03c4(r))(\u03b8) ."
        },
        {
            "heading": "2.11 Finite-state string automata",
            "text": "We recall the definition of \u0393-automaton from [Eil74, p. 12]. A finite-state string automaton over \u0393 (for short: \u0393-fsa) is a quadruple A = (Q, I, \u03b4, F ) where Q is a finite nonempty set of states such that Q\u2229\u0393 = \u2205, I \u2286 Q (initial states), \u03b4 \u2286 Q\u00d7 \u0393\u00d7Q (transitions), and F \u2286 Q (final states).\nLet w = a1 \u00b7 \u00b7 \u00b7 an be a string in \u0393\u2217 with n \u2208 N and a1, . . . , an \u2208 \u0393. A run of A on w is a string \u03c1 = q0 \u00b7 \u00b7 \u00b7 qn in Q\nn+1 such that, for each i \u2208 [0, n\u2212 1] we have (qi, ai+1, qi+1) \u2208 \u03b4. We denote q0 and qn by first(\u03c1) and last(\u03c1), respectively. The language recognized by A, denoted by L(A), is the set\nL(A) = {w \u2208 \u0393\u2217 | there exists a run \u03c1 of A on w such that first(\u03c1) \u2208 I and last(\u03c1) \u2208 F} .\nLet L \u2286 \u0393\u2217. We call L recognizable if there exists an fsa A such that L(A) = L."
        },
        {
            "heading": "54 CHAPTER 2. PRELIMINARIES",
            "text": ""
        },
        {
            "heading": "2.12 Context-free grammars",
            "text": "The theory of context-free grammars is well established; for more details, we refer the reader to, e.g., [Har78, HU79, HMU07]. Here we only recall the most basic definitions.\nA context-free grammar over \u0393 (for short: \u0393-cfg) is a triple G = (N,S,R) where N is a finite set (nonterminals) with N \u2229 \u0393 = \u2205, S \u2286 N with S 6= \u2205 (initial nonterminals), and R is a finite set (rules); each rule has the form A\u2192 \u03b1 where A \u2208 N and \u03b1 \u2208 (N \u222a \u0393)\u2217.\nLet r = (A \u2192 \u03b1) be a rule. We call r a chain rule (an \u03b5-rule, a terminal rule) if \u03b1 \u2208 N (and if \u03b1 = \u03b5, and if \u03b1 \u2208 \u0393\u2217, respectively). The left-hand side of r is the nonterminal A, denoted by lhs(r). Moreover, the i-th occurrence of a nonterminal in \u03b1 (counted from left to right) is denoted by rhsN,i(r). We sometimes want to show the occurrences of elements of N in the right-hand side of rule r more explicitly. Then we will also write r in the form\nA\u2192 u0A1u1 \u00b7 \u00b7 \u00b7Akuk ,\nwhere k \u2208 N, u0, u1, . . . , uk \u2208 \u0393 \u2217, and A1, . . . , Ak \u2208 N . If S contains only one element, say S0, then we denote G by (N,S0, R).\nThe derivation relation (of G) is the binary relation \u21d2G on (N \u222a \u0393)\u2217 defined as follows. For every \u03b3, \u03b4 \u2208 (N \u222a \u0393)\u2217 and rule A \u2192 \u03b1 in R, we have \u03b3A\u03b4 \u21d2G \u03b3\u03b1\u03b4. If G is clear from the context, then we denote \u21d2G by \u21d2. We recall that the reflexive and transitive closure of \u21d2 is denoted by \u21d2\u2217.\nA derivation (of G) is a sequence d = (\u03b31, . . . , \u03b3n) with n \u2208 N+, \u03b3i \u2208 (N \u222a \u0393)\u2217, and \u03b3i \u21d2 \u03b3i+1 for each i \u2208 [n\u2212 1]. We denote d also by \u03b31 \u21d2\u2217G \u03b3n. Let L1, L2 \u2286 (N \u222a \u0393)\n\u2217. We denote by DG(L1, L2) the set of all derivations \u03b31 \u21d2\u2217G \u03b3n such that \u03b31 \u2208 L1 and \u03b3n \u2208 L2.\nThe language generated by G is the set L(G) = {w \u2208 \u0393\u2217 | S0 \u2208 S, S0 \u21d2\u2217G w} or, equivalently, L(G) = {w \u2208 \u0393\u2217 | DG(S,w) 6= \u2205}. Let L \u2286 \u0393\u2217. We call L a context-free language if there exists a \u0393-cfg G such that L(G) = L.\nThe leftmost derivation relation \u21d2G,l is defined such that, for every u \u2208 \u0393\u2217, \u03b3 \u2208 (N \u222a \u0393)\u2217, and rule A \u2192 \u03b1 in R, we have uA\u03b3 \u21d2G,l u\u03b1\u03b3. If G is clear from the context, then we denote \u21d2G,l by \u21d2l. The concept of leftmost derivation is defined analogously to the concept of derivation. For every L1, L2 \u2286 (N \u222a \u0393)\u2217, we denote by DG,l(L1, L2) the set of all leftmost derivations \u03b31 \u21d2\u2217G,l \u03b3n such that \u03b31 \u2208 L1 and \u03b3n \u2208 L2. It is well known that L(G) = {w \u2208 \u0393 \u2217 | S0 \u2208 S, S0 \u21d2 \u2217 G,l w}.\nLet G = (N,S,R) be a context-free grammar over \u0393 and A \u2208 N be a nonterminal. We say that\n\u2022 A is generating if there exists w \u2208 \u0393\u2217 such that A\u21d2\u2217 w, \u2022 A is reachable if there exist S0 \u2208 S and \u03b3, \u03b4 \u2208 (N \u222a \u0393)\u2217 such that S0 \u21d2\u2217 \u03b3A\u03b4, and \u2022 A is useful if it is generating and reachable.\nWe say that G is reduced if R = \u2205 or each nonterminal A \u2208 N is useful.\nTheorem 2.12.1. [Har78, Thm. 3.2.3] For each \u0393-cfg G with a single initial nonterminal S0, we can construct a \u0393-cfg G\u2032 such that G\u2032 has the single initial nonterminal S0, L(G \u2032) = L(G), and G\u2032 is reduced.\nFinally, we give a characterization of the languages generated by context-free grammars which have a terminal rule. The characterization uses the concept of rule trees (cf. [Eng75b, Def. 3.54] and [GS84, Def. 3.2.8]). Intuitively, each leftmost derivation corresponds to exactly one rule tree, and vice versa. Because of our general assumption made at the beginning of Section 2.9, that each ranked alphabet contains a symbol of rank zero, such a characterization is only possible for cfg which have a terminal rule. Clearly, we can transform each cfg into an equivalent one which has a terminal rule.\nFormally, let G = (N,S,R) be a \u0393-cfg which has a terminal rule. We consider R as ranked alphabet by defining the rank of each rule r to be the number of nonterminals in the right-hand side of r. Hence, each terminal rule has rank 0 and, due to our assumption, R(0) 6= \u2205.\nWe define the projection of G, denoted by \u03c0G, to be the mapping\n\u03c0G : TR \u2192 \u0393 \u2217"
        },
        {
            "heading": "2.13. FINITE-STATE TREE AUTOMATA 55",
            "text": "defined by induction on TR as follows. For every k \u2208 N, r \u2208 R(k) of the form r = (A\u2192 u0A1u1 \u00b7 \u00b7 \u00b7Akuk), and d1, . . . , dk \u2208 TR, we define\n\u03c0G(r(d1, . . . , dk)) = u0\u03c0G(d1)u1 . . . \u03c0G(dk)uk .\nIf there is no confusion, then we drop the index G from \u03c0G and just write \u03c0.\nNow let d \u2208 TR. We say that d is a rule tree of G if, for every w \u2208 posR(d) and i \u2208 [rkR(d(w))], we have rhsN,i(d(w)) = lhs(d(wi)). Let A \u2208 N , u \u2208 \u0393\u2217, and d \u2208 TR be a rule tree of G. We say that d is\n\u2022 an A-rule tree of G if lhs(d(\u03b5)) = A. \u2022 a rule tree of G for u if \u03c0G(d) = u.\nWe denote the set of all A-rule trees of G for u by RTG(A, u). For every N \u2032 \u2286 N and L \u2286 \u0393\u2217, we define RTG(N \u2032, L) = \u22c3 A\u2208N \u2032,u\u2208L RTG(A, u), and we abbreviate RTG(S,L) by RTG(L). Obviously, for each u \u2208 \u0393\u2217, we have \u03c0\u22121G (u) \u2229 RTG(\u0393 \u2217) = RTG(u). Finally, we abbreviate RTG(\u0393\n\u2217) by RTG. Then the following is easy to see.\nObservation 2.12.2. For each \u0393-cfg G which has a terminal rule we have that L(G) = \u03c0G(RTG).\nWe note that L(G) = \u2205 for each \u0393-cfg G which does not have a terminal rule. Therefore such grammars are not relevant. On the other hand, L(G) = \u2205 does not imply that G does not have a terminal rule.\nExample 2.12.3. We consider the alphabet \u0393 = {a, b, c} and the \u0393-cfgG = (N,S,R) withN = {S,A,B} and the rules\nS \u2192 aAB, A\u2192 AaBA, A\u2192 B, B \u2192 bc, A\u2192 \u03b5 .\nFigure 2.7 shows the A-rule tree d \u2208 RTG(A, abcbc) of G for abcbc."
        },
        {
            "heading": "2.13 Finite-state tree automata",
            "text": "We recall the notions of finite-state tree automaton and recognizable tree language from [GS84, Eng75b, GS97, CDG+07].\nA finite-state tree automaton over \u03a3 (for short: \u03a3-fta, or just fta) is a triple A = (Q, \u03b4, F ) where\n\u2022 Q is a finite nonempty set (states) such that Q \u2229\u03a3 = \u2205, \u2022 \u03b4 = (\u03b4k | k \u2208 N) is a family of relations \u03b4k \u2286 Qk\u00d7\u03a3(k)\u00d7Q6 (transition relations) where we consider Qk as a set of strings over Q of length k, and \u2022 F \u2286 Q (set of root states).\n6For each k \u2208 N with k > maxrk(\u03a3) we have \u03b4k = \u2205, because \u03a3 (k) = \u2205."
        },
        {
            "heading": "56 CHAPTER 2. PRELIMINARIES",
            "text": "We say that A is bottom-up deterministic (for short: bu deterministic) if for every k \u2208 N, w \u2208 Qk, and \u03c3 \u2208 \u03a3(k), there exists at most one q \u2208 Q such that (w, \u03c3, q) \u2208 \u03b4k. And we say that A is total if for every k \u2208 N, w \u2208 Qk, and \u03c3 \u2208 \u03a3(k), there exists at least one q \u2208 Q such that (w, \u03c3, q) \u2208 \u03b4k.\nWe can associate two semantics with A: the initial algebra semantics and the run semantics. Both lead to the same tree language. Since each of the semantics has its benefits we present them both.\nInitial algebra semantics. We define the \u03a3-algebra associated with A to be the \u03a3-algebra (P(Q), \u03b4A) where, for every k \u2208 N and \u03c3 \u2208 \u03a3(k), the mapping \u03b4A(\u03c3) : P(Q)k \u2192 P(Q) is defined by\n\u03b4A(\u03c3)(P1, . . . , Pk) = {q \u2208 Q | (\u2203q1 \u2208 P1) . . . (\u2203qk \u2208 Pk) : (q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) \u2208 \u03b4k}\nfor every P1, . . . , Pk \u2208 P(Q). We denote the unique \u03a3-algebra homomorphism from the term algebra T\u03a3 to (P(Q), \u03b4A) by hA. The tree language i-recognized by A, denoted by Li(A), is defined by\nLi(A) = {\u03be \u2208 T\u03a3 | hA(\u03be) \u2229 F 6= \u2205} .\nRun semantics. Let \u03be \u2208 T\u03a3. A run of A on \u03be is a mapping \u03c1 : pos(\u03be) \u2192 Q. Let q \u2208 Q. Then \u03c1 is called\n\u2022 q-run if \u03c1(\u03b5) = q, \u2022 valid if for every w \u2208 pos(\u03be) it holds that ( \u03c1(w1) \u00b7 \u00b7 \u00b7 \u03c1(wk), \u03be(w), \u03c1(w) ) \u2208 \u03b4k where \u03be(w) \u2208 \u03a3(k), and \u2022 accepting if \u03c1 is valid and \u03c1(\u03b5) \u2208 F .\nThe set of all q-runs (all valid q-runs, all accepting q-runs) ofA on \u03be is denoted by RA(q, \u03be) (respectively, RvA(q, \u03be) and R a A(q, \u03be)). We let\nRA(\u03be) = \u22c3\nq\u2208Q\nRA(q, \u03be) and R v A(\u03be) =\n\u22c3\nq\u2208Q\nRvA(q, \u03be) and R a A(\u03be) =\n\u22c3\nq\u2208F\nRaA(q, \u03be) .\nThe tree language r-recognized by A, denoted by Lr(A), is defined by\nLr(A) = {\u03be \u2208 T\u03a3 | R a A(\u03be) 6= \u2205} .\nLemma 2.13.1. Let A = (Q, \u03b4, F ) be a \u03a3-fta. Then Li(A) = Lr(A).\nProof. Let \u03be \u2208 T\u03a3. We have\n\u03be \u2208 Li(A) iff hA(\u03be) \u2229 F 6= \u2205 iff (\u2203q \u2208 F ) : q \u2208 hA(\u03be) iff (\u2217) (\u2203q \u2208 F ) : RvA(q, \u03be) 6= \u2205 iff \u03be \u2208 Lr(A).\nIt remains to prove (*). By induction on T\u03a3, we prove that the following more general statement holds:\nFor every \u03be \u2208 T\u03a3 and q \u2208 Q, we have: q \u2208 hA(\u03be) iff ( (\u2203\u03c1 \u2208 RA(q, \u03be)) : \u03c1 is valid ) . (2.36)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). Then\nq \u2208 hA(\u03c3(\u03be1, . . . , \u03bek))\niff (\u2203q1 \u00b7 \u00b7 \u00b7 qk \u2208 Q k) : (q1 \u2208 hA(\u03be1)) \u2227 . . . \u2227 (qk \u2208 hA(\u03bek)) \u2227 ((q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) \u2208 \u03b4k)\niff (\u2203q1 \u00b7 \u00b7 \u00b7 qk \u2208 Q k) :\n( (\u2203\u03c11 \u2208 RA(q1, \u03be)) : \u03c11 is valid ) \u2227 . . . \u2227 ( (\u2203\u03c1k \u2208 RA(qk, \u03be)) : \u03c1k is valid ) \u2227 ((q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) \u2208 \u03b4k)\n(I.H.)\niff (\u2203q1 \u00b7 \u00b7 \u00b7 qk \u2208 Q k)(\u2203\u03c11 \u2208 RA(q1, \u03be)) . . . (\u2203\u03c1k \u2208 RA(qk, \u03be)) :\n(\u03c11 is valid) \u2227 . . . \u2227 (\u03c1k is valid) \u2227 ((q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) \u2208 \u03b4k) (by distributivity of \u2227 over \u2203)\niff (\u2203\u03c1 \u2208 RA(q, \u03be)) : \u03c1 is valid ."
        },
        {
            "heading": "2.14. RECOGNIZABLE STEP MAPPINGS 57",
            "text": "Since Li(A) = Lr(A) for each \u03a3-fta A, we will sometimes drop the indices i and r from Li(A) and Lr(A), respectively, and we call the language L(A) the tree language recognized by A. Two \u03a3-fta A and A\u2032 are equivalent if L(A) = L(A\u2032). A tree language L \u2286 T\u03a3 is recognizable if there exists a \u03a3-fta A such that L(A) = L. The set of all recognizable \u03a3-tree languages is denoted by Rec(\u03a3).\nTheorem 2.13.2. (cf. [GS84, Thm. 2.2.6]7 and [Eng75b, Thm. 3.8]8) For each \u03a3-fta A we can construct a total and bu deterministic \u03a3-fta B such that L(A) = L(B).\nTheorem 2.13.3. (cf. [Eng75b, Thm. 3.25 and 3.32] and [GS84, Thm. 2.4.2] Let A1, A2 be two \u03a3-fta.\n(1) We can construct a \u03a3-fta A such that L(A) = L(A1) \u222a L(A2). (2) We can construct a \u03a3-fta A such that L(A) = L(A1) \u2229 L(A2). (3) We can construct a \u03a3-fta A such that L(A) = L(A1) \\ L(A2).\nThus, the set Rec(\u03a3) is closed under union, intersection, set subtraction, and complement.\nFor the theory of recognizable tree languages we refer to [Eng75b], [GS84, GS97],[CDG+07]."
        },
        {
            "heading": "2.14 Recognizable step mappings",
            "text": "We recall the concept of recognizable step mapping from [DV06] (also cf. [DG05, DG07, DG09]). Roughly speaking, these are (\u03a3,B)-weighted tree languages which can be obtained from characteristic mappings of finitely many recognizable \u03a3-tree languages by multiplying with elements of B and summing up.\nFormally, a weighted tree language r : T\u03a3 \u2192 B is a (\u03a3,B)-recognizable step mapping (or just: recognizable step mapping) if there exist n \u2208 N+, b1, . . . , bn \u2208 B, and recognizable \u03a3-tree languages L1, . . . , Ln such that we have\nr = \u2295\ni\u2208[n]\nbi \u2297 \u03c7(Li) , (2.37)\n(where we have extended the sum of two weighted tree languages to the sum of finitely many weighted tree languages, cf. page 21). In other words, for each \u03be \u2208 T\u03a3, we have\nr(\u03be) = \u2295\ni\u2208[n]: \u03be\u2208Li\nbi .\nIn particular, if \u03be 6\u2208 L1 \u222a . . . \u222a Ln, then r(\u03be) = 0. Moreover, if n = 1 and L1 = \u2205, then r = 0\u0303. Also, each polynomial (\u03a3,B)-weighted tree language is a recognizable step mapping, because singleton \u03a3-tree languages are recognizable. The tree languages Li are called step languages. If n = 1, then r is called (\u03a3,B)-recognizable one-step mapping. We denote by RecStep(\u03a3,B) the set of (\u03a3,B)-recognizable step mappings.\nIn general, the step languages of a recognizable step mapping need not be disjoint. However, for each recognizable step mapping we can find a characterization in terms of pairwise disjoint step languages.\nObservation 2.14.1. [DV06, Lm. 3.1] Let r : T\u03a3 \u2192 B be a recognizable step mapping. There exist a finite set F and for each f \u2208 F , there exist a recognizable \u03a3-tree language Uf and an element af \u2208 B such that (Uf | f \u2208 F ) is a partitioning of T\u03a3 and r = \u2295 f\u2208F af \u2297 \u03c7(Uf ).\nProof. Let n \u2208 N+, b1, . . . , bn \u2208 B, and recognizable \u03a3-tree languages L1, . . . , Ln be such that, for each \u03be \u2208 T\u03a3, Equation (2.37) holds.\nLet F be the set of all mappings of type {1, . . . , n} \u2192 {1, c} (where 1 and c are just viewed as two\ndistinct symbols). For each mapping f \u2208 F , we define the \u03a3-tree language Uf = \u22c2n i=1 L f(i) i where L 1 i = Li\n7When citing results of [GS84] we use the numbers in the arXiv-version of that book. 8When citing results of [Eng75b] we use the numbers in the arXiv-version of those lecture notes."
        },
        {
            "heading": "58 CHAPTER 2. PRELIMINARIES",
            "text": "and Lci = T\u03a3 \\Li. We note that the family (Uf | f \u2208 F ) forms a partitioning of T\u03a3. Moreover, since the set of recognizable \u03a3-tree languages is closed under intersection and complementation [GS84], we have that Uf is a recognizable \u03a3-tree language.\nFor each f \u2208 F , we define the element af = \u2295 i\u2208f\u22121(1) bi in B. Then clearly, for each \u03be \u2208 T\u03a3 we have r(\u03be) = af if \u03be \u2208 Uf , where the f is uniquely determined because (Uf | f \u2208 F ) forms a partitioning of T\u03a3. Thus r = \u2295 f\u2208F af \u2297 \u03c7(Uf ).\nWe mention that recognizable step mappings play an important role in the characterization of recognizable weighted languages by weighted MSO-logic (cf. [DG05, DG07, DG09] for strings, and [DV06, DV11b, FSV12, DHV15] for trees; also cf. Section 14.4). In fact, the semantics of the weighted MSO-formula \u2200x.\u03d5 is a recognizable weighted language if the semantics of \u03d5 is a recognizable step mapping ([DG05, Lm. 4.2] and [DG09, Lm. 5.4], also cf. [DV06, Lm. 5.5] and Lemma 14.4.16 for the tree case); moreover, there exists a weighted MSO-formula \u03d5 of which the semantics is a recognizable weighted language and the semantics \u2200x.\u03d5 is not recognizable [DG09, Ex. 3.6].\nWe note that in [GZ12, Def. 3.4], a (\u03a3, L)-recognizable step mapping for some \u03c3-complete residuated lattice L is called an L-valued regular tree language."
        },
        {
            "heading": "2.15 Fta-hypergraphs",
            "text": "The concept of hypergraph [BC87, HK87, CE12] generalizes that of graphs. In this book we consider particular hypergraphs which we call fta-hypergraphs. Let Q be a finite set. A (Q,\u03a3)-hypergraph is a pair g = (Q,E), where E \u2286 \u22c3 k\u2208NQ\nk \u00d7 \u03a3(k) \u00d7Q (set of hyperedges); the elements of Q are called nodes. An fta-hypergraph is a (Q,\u03a3)-hypergraph for some finite set Q and some ranked alphabet \u03a3.\nWe can represent a (Q,\u03a3)-hypergraph as a picture as follows. Each node q \u2208 Q is represented as a circle with q in its center. Each hyperedge (q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) is represented as a box with \u03c3 in its center and with incoming and outgoing arrows. More specifically, this box has exactly one outgoing arrow, which leads to the representation of the node q. Moreover, it has k incoming arrows, which come from the representations of the nodes q1. . . . , qk, respectively. The order among q1, . . . , qk which is determined by the string q1 \u00b7 \u00b7 \u00b7 qk, is represented in the picture as follows: starting from the unique outgoing arrow and moving counter-clockwise around the box, the i-th incoming arrow comes from the representation of the i-th component of the string q1 \u00b7 \u00b7 \u00b7 qk.\nFigure 2.8 illustrates the (Q,\u03a3)-hypergraph (Q,E) with Q = {h, 0}, \u03a3 = {\u03c3(2), \u03b1(0)}, and\nE = {(\u03b5, \u03b1, h), (h0, \u03c3, h), (0h, \u03c3, h), (\u03b5, \u03b1, 0), (00, \u03c3, 0)} .\nFor instance, the hyperedge (0h, \u03c3, h) is represented by the left-lower box. In the sequel, we will not distinguish between an fta-hypergraph and its representation as picture.\n2.15. FTA-HYPERGRAPHS 59\n60 CHAPTER 2. PRELIMINARIES\nChapter 3\nThe model of weighted tree automata\nIn this chapter we present the basic model of weighted tree automata. Intuitively, it results from the concept of fta by applying two steps.\nIn the first step, for a given \u03a3-fta A = (Q, \u03b4, F ), we replace each transition relation\n\u03b4k \u2286 Q k \u00d7 \u03a3(k) \u00d7Q by its characteristic mapping \u03c7Boole(\u03b4k) : Q k \u00d7 \u03a3(k) \u00d7Q\u2192 B\nwith respect to the Boolean semiring Boole = (B,\u2228,\u2227, 0, 1) (where B = {0, 1}), and similarly, we replace\nF \u2286 Q by its characteristic mapping \u03c7Boole(F ) : Q\u2192 B .\nFor the sake of simplicity, we denote \u03c7Boole(\u03b4k) and \u03c7Boole(F ) also by \u03b4k and F , respectively.\nSince there is a bijection between the set of subsets of Qk \u00d7 \u03a3(k) \u00d7 Q and set of mappings of type Qk \u00d7 \u03a3(k) \u00d7Q \u2192 B (and the same holds for subsets of Q and mappings of type Q \u2192 B), this step does not change the concept of an fta; it is simply another way to specify an fta.\nIn the second step, we replace the Boolean semiring Boole by an arbitrary strong bimonoid B, i.e., we let\n\u03b4k : Q k \u00d7 \u03a3(k) \u00d7Q\u2192 B and F : Q\u2192 B .\nIn contrast to the first step, the second one generalizes the concept of fta considerably, because\n(a) a strong bimonoid B need not be finite and (b) a number of algebraic laws which hold for the summation \u2228 and multiplication \u2227 of Boole need not\nhold anymore in B, e.g., idempotency, commutativity of \u2227, zero-sum freeness, zero-divisor freeness, absorption axiom, and distributivity.\nHence, in the proofs of lemmas and theorems on weighted tree automata over some arbitrary strong bimonoid B we have to be careful not to use the latter properties out of habit.\nIn Section 3.1 we recall the concept of weighted tree automata and define the run semantics, the initial algebra semantics, and the corresponding notions of recognizable weighted tree language. In Section 3.2 we illustrate these definitions by a number of examples. In Sections 3.3-3.6 we connect the concept of weighted tree automata with its historical predecessors in a formal way: weighted string automata, finite-state tree automata, finite-state tree automata with multiplicities, and multilinear representations, respectively. Finally, in Section 3.7 we briefly mention a consequence of extending the weight algebra and we define the concept of Fatou extension.\n61"
        },
        {
            "heading": "62 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA",
            "text": ""
        },
        {
            "heading": "3.1 Basic definitions",
            "text": "A weighted tree automaton over \u03a3 and B (for short: (\u03a3,B)-wta, or: wta) is a tuple A = (Q, \u03b4, F ) where\n\u2022 Q is a finite nonempty set (states) such that Q \u2229\u03a3 = \u2205, \u2022 \u03b4 = (\u03b4k | k \u2208 N) is a family of mappings \u03b4k : Q\nk \u00d7 \u03a3(k) \u00d7Q\u2192 B (transition mappings)1 where we consider Qk as set of strings over Q of length k, and\n\u2022 F : Q\u2192 B is a mapping (root weight vector).\nFor each k \u2208 N, we call each element in Qk \u00d7 \u03a3(k) \u00d7Q a transition. For each transition (w, \u03c3, q), the element \u03b4k(w, \u03c3, q) of B is its weight, and for each q \u2208 Q, the element Fq is its root weight. (We recall that Fq denotes F (q).) We denote the set of all transition weights and root weights occurring in A by wts(A), i.e.,\nwts(A) = im(\u03b4) \u222a im(F ) where im(\u03b4) = \u22c3\nk\u2208N\nim(\u03b4k) .\nLet A = (Q, \u03b4, F ) be a (\u03a3,B)-wta.\n\u2022 A is bottom-up deterministic (for short: bu deterministic) if for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and w \u2208 Qk\nthere exists at most one q \u2208 Q such that \u03b4k(w, \u03c3, q) 6= 0. \u2022 A is total if for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and w \u2208 Qk there exists at least one state q such that \u03b4k(w, \u03c3, q) 6= 0. \u2022 A has identity transition weights if im(\u03b4) \u2286 {0, 1}. \u2022 A is crisp deterministic if A is bu deterministic, total, and A has identity transition weights (cf. [CDIV10, Sec. 5]). \u2022 A has identity root weights if im(F ) \u2286 {0, 1}. \u2022 A is root weight normalized if there exists a state q \u2208 Q such that supp(F ) = {q} and Fq = 1.\nWe note that, for each (\u03a3,B)-wta A = (Q, \u03b4, F ), we consider the strong bimonoid B as integral part of the specification of A. Thus, if B\u2032 is another strong bimonoid which has the same carrier set as B (but different operations and/or unit elements), then we consider A to be different from the (\u03a3,B\u2032)-wta A\u2032 = (Q, \u03b4, F ). In other words, instead of saying that A = (Q, \u03b4, F ) is a (\u03a3,B)-wta, we could equivalently say that A = (Q,\u03a3,B, \u03b4, F ) is a wta. And clearly, (Q,\u03a3,B, \u03b4, F ) 6= (Q,\u03a3,B\u2032, \u03b4, F ).\nRepresentation of wta by fta-hypergraphs. We can represent each (\u03a3,B)-wta A = (Q, \u03b4, F ) as an fta-hypergraph with extra annotations. For this we first consider the (Q,\u03a3)-hypergraph\ngA = (Q, \u22c3\nk\u2208N\nsupp(\u03b4k)) .\nThen we add to gA the weights of transitions and the root weights of A as follows. For each q \u2208 Q such that Fq 6= 0, we add Fq to the node which represents q. If Fq = 0, then we do not illustrate Fq in the picture. Moreover, for each transition of A with non-0-weight, i.e., element in \u22c3 k\u2208N supp(\u03b4k), we add its weight to its representing hyperedge.\nFor instance, let us consider the (\u03a3,Natmax,+)-wta A = (Q, \u03b4, F ), where \u2022 \u03a3 = {\u03c3(2), \u03b1(0)}, \u2022 Natmax,+ = (N\u2212\u221e,max,+,\u2212\u221e, 0), the arctic semiring, \u2022 Q = {h, 0}, \u2022 \u03b40(\u03b5, \u03b1, h) = \u03b40(\u03b5, \u03b1, 0) = 0 and for every q1, q2, q \u2208 Q,\n\u03b42(q1q2, \u03c3, q) =    1 if q1q2q \u2208 {h0h, 0hh} , 0 if q1q2q = 000 ,\n\u2212\u221e otherwise ,\n1For each k \u2208 N with k > maxrk(\u03a3) we have \u03b4k : \u2205 \u2192 B, because \u03a3 (k) = \u2205.\n3.1. BASIC DEFINITIONS 63\n\u2022 Fh = 0 and F0 = \u2212\u221e.\nIn Figure 3.1 we show how A is represented as fta-hypergraph with extra annotations. We note that, e.g., the transition (hh, \u03c3, 0) is not represented in the fta-hypergraph, because \u03b42(hh, \u03c3, 0) = \u2212\u221e and \u2212\u221e is the identity for the summation of the arctic semiring Natmax,+. Also, the value F0 is not represented because F0 = \u2212\u221e.\nRun semantics. The run semantics of a (\u03a3,B)-wta can be viewed as a generalization of the algebraic path problem (cf. [Car71], [Zim81, Ch. 8], [Mah81], [Rot90], [CLR90, Sec. 26.4], and [HW93, Ch. IV.6]). Roughly speaking, given a finite, directed graph such that each edge is labeled by an element of some \u03c3-complete strong bimonoid B, the algebraic path problem asks the following: for each pair q, q\u2032 of nodes, how can the value\nlq,q\u2032 = \u2211\u2295\n\u03c1 path from q to q\u2032\n\u03bb(\u03c1)\nin B be computed where, for each path \u03c1 = (q0, q1)(q1, q2) \u00b7 \u00b7 \u00b7 (qn\u22121, qn) from q0 to qn, we let\n\u03bb(\u03c1) = \u2297\ni\u2208[n]\nw(qi\u22121, qi)\nand w(qi\u22121, qi) \u2208 B is the label of the edge (qi\u22121, qi). For instance, if B is the formal language semiring Lang\u0393 = (P(\u0393\n\u2217),\u222a, \u00b7, \u2205, {\u03b5}) and, for every two vertices q, q\u2032, we have w((q, q\u2032)) \u2286 \u0393, then the graph can be considered as a \u0393-fsa A. Then lq,q\u2032 \u2208 P(\u0393\u2217) is the formal language recognized by A starting from q and ending in q\u2032. Another example is that B is the tropical semiring Natmin,+ = (N\u221e,min,+,\u221e, 0) and, for every two vertices q, q\u2032, the value w((q, q\u2032)) is the distance between q and q\u2032 (which may be \u221e). Then the value lq,q\u2032 \u2208 N\u221e is the length of a shortest path from q to q\u2032.\nSince a wta A corresponds to an fta-hypergraph, the algebraic path problem can be generalized to an \u201calgebraic fta-hyperpath problem\u201d in order to capture the recursive structure of A (cf. [Knu77] where the fta-hypergraph is called superior context-free grammar, and each hyperedge is labeled by a superior function). Given an fta-hypergraph A and a node q, a q-hyperpath is an unfolding of the fta-hypergraph, starting in node q and moving in the direction opposite to the direction of the hyperedges; this unfolding results in a \u03a3-tree \u03be (constituted by protocoling the labels of the visited hyperedges) together with a decoration of each position of \u03be by some node of the fta-hypergraph A; we call this decoration a \u201cq-run of A on \u03be\u201d. We note that the first node of a path in a graph (see above) disappears when generalizing to hyperpaths and fta-hypergraphs, because at each leaf of an fta-hyperpath a transition in \u03b40 of A is applied, which does not have source states.\nFormally, let \u03be \u2208 T\u03a3. A run of A on \u03be is a mapping \u03c1 : pos(\u03be)\u2192 Q. If \u03c1(\u03b5) = q for some q \u2208 Q, then \u03c1 is also called a q-run. The set of all runs of A on \u03be and the set of all q-runs of A on \u03be are denoted\n64 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA\nby RA(\u03be) and RA(q, \u03be), respectively. Each run \u03c1 \u2208 RA(\u03be) determines, for each w \u2208 pos(\u03be), a unique transition, viz., if k = rk(\u03be(w)) and \u03c3 = \u03be(w), then \u03c1 determines the transition (\u03c1(w1) \u00b7 \u00b7 \u00b7 \u03c1(wk), \u03c3, \u03c1(w)). We call this the transition induced by \u03c1 on \u03be at w. For every \u03c1 \u2208 RA(\u03be) and w \u2208 pos(\u03be), the run induced by \u03c1 at position w, denoted by \u03c1|w, is the run in RA(\u03be|w) defined for every w\u2032 \u2208 pos(\u03be|w) by \u03c1|w(w \u2032) = \u03c1(ww\u2032).\nNext we define the weight of a run \u03c1 \u2208 RA(\u03be). For this, we will define a mapping wtA : C \u2192 B by well-founded induction on (C,\u227a) (using Theorem 2.5.1 and (2.4)). One might be tempted to choose C = RA(\u03be). However, this leads to an underspecification, because one can easily imagine a ranked alphabet \u03a3 and two trees \u03be1, \u03be2 \u2208 T\u03a3 such that \u03be1 6= \u03be2 and pos(\u03be1) = pos(\u03be2); then RA(\u03be1) = RA(\u03be2) and the mapping wtA is not able to \u201csee\u201d the \u03a3-labels at the positions; but, of course, the weight of a run depends on these labels.2 Thus, we let C be the set of pairs where each pair consists of a tree \u03be \u2208 T\u03a3 and a run \u03c1 \u2208 RA(\u03be); due to this origin, we denote C by TR (tree-run); and we define an appropriate well-founded relation on this set of pairs.\nFormally, we let TR = {(\u03be, \u03c1) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be)} and we define the binary relation \u227a on TR by\n\u227a= { ( (\u03be|i, \u03c1|i), (\u03be, \u03c1) ) | (\u03be, \u03c1) \u2208 TR, i \u2208 [rk(\u03be(\u03b5))]} .\nObviously, \u227a is well-founded and min\u227a(TR) = {(\u03b1, \u03c1) | \u03b1 \u2208 \u03a3(0), \u03c1 : {\u03b5} \u2192 Q}. The well-founded relation \u227a is illustrated in Figure 3.2.\nWe define the mapping wtA : TR\u2192 B\nby induction on (TR,\u227a) for every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be) by\nwtA(\u03be, \u03c1) = (\u2297\ni\u2208[k]\nwtA(\u03be|i, \u03c1|i) ) \u2297 \u03b4k ( \u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5) ) , (3.1)\nwhere k and \u03c3 abbreviate rk(\u03be(\u03b5)) and \u03be(\u03b5), respectively. We call wtA(\u03be, \u03c1) the weight of \u03c1 by A on \u03be. If \u03be is uniquely determined by the context, then the phrase weight of \u03c1 by A means the value wtA(\u03be, \u03c1). If the wta A is clear from the context, then we drop \u201cby A\u201d and the index A from the phrase \u201cweight of \u03c1 by A on \u03be\u201d and from the denotation wtA(\u03be, \u03c1), respectively.\nIntuitively, the run semantics of A on a tree \u03be \u2208 T\u03a3 is the finite summation of the weights of each run \u03c1 on \u03be, which is additionally multiplied by the root weight F\u03c1(\u03b5). Here we use the fact that the binary summation \u2295 of B is extended in a unique way to the summation over the finite RA(\u03be)-family (wt(\u03be, \u03c1)\u2297F\u03c1(\u03b5) | \u03c1 \u2208 RA(\u03be)) over B (cf. page 21). Formally, the run semantics of A, denoted by [[A]]\nrun, is the weighted tree language [[A]]run : T\u03a3 \u2192 B such that, for each \u03be \u2208 T\u03a3, we let\n[[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwt(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) .\n2For instance, Equations 11.4 and 11.5 show that the run alone does not determine the value of wt."
        },
        {
            "heading": "3.1. BASIC DEFINITIONS 65",
            "text": "Obviously, we have\n[[A]]run(\u03be) = \u2295\nq\u2208Q\n\u2295\n\u03c1\u2208RA(q,\u03be)\nwt(\u03be, \u03c1)\u2297 Fq ,\nbecause the Q-indexed family (RA(q, \u03be) | q \u2208 Q) is a partitioning of RA(\u03be).\nNext we prove that the weight wtA(\u03be, \u03c1) of a run \u03c1 is the product of the weights of the transitions induced by \u03c1 on \u03be.\nObservation 3.1.1. For every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be), we have\nwtA(\u03be, \u03c1) = \u2297\nu\u2208pos(\u03be) in \u2264dp order\n\u03b4rk(\u03be(u))(\u03c1(u1) \u00b7 \u00b7 \u00b7 \u03c1(u rk(\u03be(u))), \u03be(u), \u03c1(u)) .\nProof. We prove the statement by induction on T\u03a3. Let \u03be = \u03c3(\u03be1, . . . , \u03bek) and \u03c1 \u2208 RA(\u03be). Then we can calculate as follows:\nwtA(\u03be, \u03c1) = (\u2297\ni\u2208[k]\nwtA(\u03bei, \u03c1|i) ) \u2297 \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)) (by (3.1))\n= \u2297\nu\u2208pos(\u03be1) in \u2264dp order\n\u03b4rk(\u03be1(u))(\u03c1|1(u1) \u00b7 \u00b7 \u00b7 \u03c1|1(u rk(\u03be1(u))), \u03be1(u), \u03c1|1(u))\n\u2297 . . .\u2297 \u2297\nu\u2208pos(\u03bek) in \u2264dp order\n\u03b4rk(\u03bek(u))(\u03c1|k(u1) \u00b7 \u00b7 \u00b7 \u03c1|k(u rk(\u03bek(u))), \u03bek(u), \u03c1|k(u))\n\u2297 \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)) (by I.H.)\n= \u2297\nu\u2208pos(\u03be) in \u2264dp order\n\u03b4rk(\u03be(u))(\u03c1(u1) \u00b7 \u00b7 \u00b7 \u03c1(u rk(\u03be(u))), \u03be(u), \u03c1(u))\n(by associativity of \u2297 and definition of \u2264dp)\nA weighted tree language r : T\u03a3 \u2192 B is run recognizable over B (for short: run recognizable or r-recognizable) if there exists a (\u03a3,B)-wta A such that r = [[A]]run. The set of all (\u03a3,B)-weighted tree languages which are run recognizable over B, is denoted by Recrun(\u03a3,B). In the obvious way, we can define the notions of bu deterministically r-recognizable over B and crisp deterministically r-recognizable over B. We denote the corresponding sets of all such weighted tree languages by bud-Recrun(\u03a3,B) and cd-Recrun(\u03a3,B), respectively.\nTwo (\u03a3,B)-wta A1 and A2 are run equivalent (r-equivalent) if [[A1]]run = [[A2]]run.\nThe following result is an obvious consequence of the corresponding definitions.\nLemma 3.1.2. Let B be bi-locally finite and A be a (\u03a3,B)-wta A. Then im([[A]]run) is finite.\nProof. Let A = (Q, \u03b4, F ). For each \u03be \u2208 T\u03a3, we have wt(\u03be, \u03c1) \u2297 F\u03c1(\u03b5) \u2208 \u3008wts(A)\u3009{\u2297}. Thus [[A]] run(\u03be) =\u2295\n\u03c1\u2208RA(\u03be) wt(\u03be, \u03c1)\u2297F\u03c1(\u03b5) \u2286 \u3008\u3008wts(A)\u3009{\u2297}\u3009{\u2295}. This latter set is finite because B is bi-locally finite. Hence\nim([[A]]run) is also finite.\nIn Theorem 16.2.7 we will prove the converse result: if for each (\u03a3,B)-wta A the set im([[A]]run) is finite, then B is bi-locally finite."
        },
        {
            "heading": "66 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA",
            "text": "Initial algebra semantics. The heart of the initial algebra semantics [GTWW77] of a (\u03a3,B)-wta A is a particular \u03a3-algebra, called the vector algebra of A; it is tailormade for A. Due to the uniqueness of the \u03a3-algebra homomorphism from the \u03a3-term algebra T\u03a3 = (T\u03a3, \u03b8\u03a3) to the vector algebra of A, each \u03a3-tree \u03be can be interpreted (or: evaluated) in a unique way in the vector algebra. Eventually, the interpretation of \u03be is modified with root weights. On first glance, the definition of the vector algebra of a wta below might look a bit artificial. However, conceptually, this definition results from the straightforward application of the two steps described at the beginning of this chapter to an fta and its initial algebra semantics.\nFormally, the vector algebra of A is the \u03a3-algebra V(A) = (BQ, \u03b4A) where, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), the k-ary operation \u03b4A(\u03c3) : B Q \u00d7 \u00b7 \u00b7 \u00b7 \u00d7BQ \u2192 BQ is defined by\n\u03b4A(\u03c3)(v1, . . . , vk)q = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\n(vi)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) (3.2)\nfor every v1, . . . , vk \u2208 BQ and q \u2208 Q.\nWe abbreviate hV(A) by hA, i.e., we denote the unique \u03a3-algebra homomorphism from the \u03a3-term algebra T\u03a3 to the vector algebra V(A) by hA. Then, for every \u03be = \u03c3(\u03be1, . . . , \u03bek) in T\u03a3 and q \u2208 Q, we have\nhA(\u03c3(\u03be1, . . . , \u03bek))q = hA(\u03b8\u03a3(\u03c3)(\u03be1, . . . , \u03bek))q = \u03b4A(\u03c3)(hA(\u03be1), . . . , hA(\u03bek))q\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\nhA(\u03bei)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q),\nwhere \u03b8\u03a3(\u03c3) is the operation of the \u03a3-term algebra associated to \u03c3; the second equality holds, because hA is a \u03a3-algebra homomorphism. In the subsequent proofs, we will show only the first and the last expressions of the above calculation. For the particular case that k = 0, we obtain the following:\nhA(\u03c3)q = hA(\u03b8\u03a3(\u03c3)())q = \u03b4A(\u03c3)()q = \u2295\n\u03b5\u2208Q0\n1\u2297 \u03b40(\u03b5, \u03c3, q) = \u03b40(\u03b5, \u03c3, q),\nand thus we will write hA(\u03c3)q = \u03b40(\u03b5, \u03c3, q) directly.\nThe initial algebra semantics of A, denoted by [[A]]init, is the weighted tree language [[A]]init : T\u03a3 \u2192 B defined for every \u03be \u2208 T\u03a3 by\n[[A]]init(\u03be) = \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq .\nThe vector algebra V(A) may contain Q-vectors which are not accessible by A, i.e., in general, we have BQ \\ im(hA) 6= \u2205. Next we define a \u03a3-algebra which is a subalgebra of V(A) and has exactly im(hA) as carrier set. We define the accessible subalgebra of V(A), denoted by aV(A), to be the \u03a3-algebra\naV(A) = (im(hA), \u03b4aV(A)) ,\nwhere for each k \u2208 N and \u03c3 \u2208 \u03a3(k), the operation \u03b4aV(A)(\u03c3) is the restriction of \u03b4A(\u03c3) to im(hA) k. By Observation 2.9.4, aV(A) is the smallest subalgebra of V(A).\nWe denote the unique \u03a3-algebra homomorphism from T\u03a3 to aV(A) by haV(A). Since aV(A) is a subalgebra of V(A), the homomorphism haV(A) is a \u03a3-algebra homomorphism also from T\u03a3 to V(A), and since T\u03a3 is initial, we have\nhaV(A)(\u03be) = hA(\u03be) for every \u03be \u2208 T\u03a3 . (3.3)\nThen we can express the initial algebra semantics [[A]]init also in terms of the homomorphism haV(A) as follows:\n[[A]]init = F \u2032 \u25e6 haV(A) (3.4)"
        },
        {
            "heading": "3.1. BASIC DEFINITIONS 67",
            "text": "where F \u2032 : im(hA)\u2192 B is the mapping defined by F \u2032(u) = \u2295\nq\u2208Q uq \u2297 Fq for every u \u2208 im(hA). Indeed, for each \u03be \u2208 T\u03a3, we have\n[[A]]init(\u03be) = \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq (3.3) = \u2295\nq\u2208Q\nhaV(A)(\u03be)q \u2297 Fq = (F \u2032 \u25e6 haV(A))(\u03be) .\nBy Theorem 2.6.4, the kernel ker(hA) is a congruence relation on the \u03a3-term algebra (T\u03a3, \u03b8\u03a3). 3\nLemma 3.1.3. aV(A) \u223c= T\u03a3/ ker(hA), i.e., the accessible subalgebra of V(A) is isomorphic to the quotient algebra of the \u03a3-term algebra modulo ker(hA).\nProof. Since haV(A) is a surjective \u03a3-algebra homomorphism from the \u03a3-term algebra to aV(A), Theorem 2.6.4 implies aV(A) \u223c= T\u03a3/ ker(haV(A)). Since (3.3) implies ker(hA) = ker(haV(A)), we obtain aV(A) \u223c= T\u03a3/ ker(hA).\nA weighted tree language r : T\u03a3 \u2192 B is initial algebra recognizable over B (for short: initial algebra recognizable or i-recognizable) if there exists a (\u03a3,B)-wta A such that r = [[A]]init. The set of all weighted tree languages over \u03a3 and B which are i-recognizable, is denoted by Recinit(\u03a3,B). In an obvious way, we can define the notion of bu deterministically i-recognizable weighted tree language and crisp deterministically i-recognizable weighted tree language. We denote the corresponding sets of all such weighted tree languages by bud-Recinit(\u03a3,B) and cd-Recinit(\u03a3,B), respectively.\nLet A1 and A2 be (\u03a3,B)-wta. We say that A1 and A2 are initial algebra equivalent (i-equivalent) if [[A1]]init = [[A2]]init. Moreover, A1 and A2 are equivalent if they are both r-equivalent and i-equivalent.\nThe following result is an obvious consequence of the corresponding definitions.\nLemma 3.1.4. Let B be locally finite and A be a (\u03a3,B)-wta A. Then im([[A]]init) is finite.\nProof. Let A = (Q, \u03b4, F ). For each \u03be \u2208 T\u03a3 and q \u2208 Q, we have that [[A]]init(\u03be) \u2208 \u3008wts(A)\u3009{\u2295,\u2297}. This latter set is finite because B is locally finite. Hence im([[A]]init) is also finite.\nIn Theorem 16.1.6 we will prove the converse result: if for each (\u03a3,B)-wta A the set im([[A]]init) is finite, then B is locally finite.\nWe finish this section with an interesting property of the initial algebra semantics. This result will be applied in several proofs.\nTheorem 3.1.5. [Rad10, Lm. 6.1] Let A \u2286 B be a finite subset. If |\u03a3(0)| \u2265 |A \u222a {0, 1}| and |\u03a3(2)| \u2265 2, then we can construct a (\u03a3,B)-wta A such that im([[A]]init) = \u3008A\u3009{\u2295,\u2297,0,1}. In particular, if B is generated by A, then we obtain im([[A]]init) = B.\nProof. Let us abbreviate \u3008A\u3009{\u2295,\u2297,0,1} by \u3008A\u3009. By our assumption on \u03a3, we may also assume that A \u222a {0, 1} \u2286 \u03a3(0) and {+(2),\u00d7(2)} \u2286 \u03a3(2).\nNow we construct the (\u03a3,B)-wta A = (Q, \u03b4, F ) as follows. We let Q = {v, 1}, Fv = 1, and F1 = 0. Moreover, we define \u03b40(\u03b5, a, v) = a and \u03b40(\u03b5, a, 1) = 1 for each a \u2208 A \u222a {0, 1}, and for every p, q, r \u2208 Q we define\n\u03b42(pq,+, r) = { 1 if (pq, r) \u2208 {(11, 1), (v1, v), (1v, v)} 0 otherwise\nand\n\u03b42(pq,\u00d7, r) = { 1 if (pq, r) \u2208 {(11, 1), (vv, v)} 0 otherwise\n3For the case of wsa, in [CDIV10, Prop. 6.2] the relation ker(hA) was defined and called \u201cNerode right congruence\u201d. We refrain from also calling our relation ker(hA) \u201cNerode congruence relation\u201d, because the Nerode congruence relation from classical formal language theory means something else: it is based on a language L \u2286 \u0393\u2217 and defines two strings w1 and w2 to be equivalent if for each u \u2208 \u0393\u2217: w1u \u2208 L iff w2u \u2208 L (also cf. [Koz92] for tree languages). Our ker(hA) is of different nature."
        },
        {
            "heading": "68 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA",
            "text": "Lastly, for every k \u2208 N, \u03c3 \u2208 \u03a3(k) such that \u03c3 6\u2208 A \u222a {0, 1,+,\u00d7}, and q1, . . . , qk, q \u2208 Q, we let \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = a for an arbitrary a \u2208 A \u222a {0, 1}.\nSince wts(A) \u2286 A \u222a {0, 1}, we have im([[A]]init) \u2286 \u3008A\u3009.\nAs preparation for the proof of the other inclusion, we define the relation \u227a on \u3008A\u3009 as follows. For each a \u2208 \u3008A\u3009, let i(a) \u2208 N be the minimal number of operations in {\u2295,\u2297} which must be applied to elements of A \u222a {0, 1} in order to produce a. Then, for each a, b \u2208 \u3008A\u3009, we define a \u227a b if i(a) < i(b). It is easy to see that \u227a is a well-founded relation on \u3008A\u3009 with min\u227a(\u3008A\u3009) = A \u222a {0, 1}. By induction on (\u3008A\u3009,\u227a), we prove that the following statement holds:\nFor each a \u2208 \u3008A\u3009, there exists \u03be \u2208 T\u03a3 such that hA(\u03be)v = a and hA(\u03be)1 = 1 . (3.5)\nI.B.: Let a \u2208 A\u222a{0, 1}. Then with \u03be = a we have hA(a)v = \u03b40(\u03b5, a, v) = a and hA(\u03be)1 = \u03b40(\u03b5, a, 1) = 1.\nI.S.: Now let a = a1\u2295 a2. By the I.H., for each i \u2208 {1, 2}, there exists \u03bei \u2208 T\u03a3 such that hA(\u03bei)v = ai and hA(\u03bei)1 = 1. We let \u03be = +(\u03be1, \u03be2). Then\nhA(+(\u03be1, \u03be2))v = \u2295\np,q\u2208Q\nhA(\u03be1)p \u2297 hA(\u03be2)q \u2297 \u03b42(pq,+, v)\n= ( hA(\u03be1)v \u2297 hA(\u03be2)1 \u2297 \u03b42(v1,+, v) ) \u2295 ( hA(\u03be1)1 \u2297 hA(\u03be2)v \u2297 \u03b42(1v,+, v) ) = ( a1 \u2297 1\u2297 1 ) \u2295 ( 1\u2297 a2 \u2297 1 ) = a1 \u2295 a2 = a\nand hA(+(\u03be1, \u03be2))1 = hA(\u03be1)1 \u2297 hA(\u03be2)1 \u2297 \u03b42(11,+, 1) = 1.\nNext let a = a1 \u2297 a2. As before, for each i \u2208 {1, 2}, there exists \u03bei \u2208 T\u03a3 such that hA(\u03bei)v = ai and hA(\u03bei)1 = 1. We let \u03be = \u00d7(\u03be1, \u03be2). Then\nhA(\u00d7(\u03be1, \u03be2))v = \u2295\np,q\u2208Q\nhA(\u03be1)p \u2297 hA(\u03be2)q \u2297 \u03b42(pq,\u00d7, v)\n= hA(\u03be1)v \u2297 hA(\u03be2)v \u2297 \u03b42(vv,\u00d7, v)\n= a1 \u2297 a2 \u2297 1 = a\nand hA(\u00d7(\u03be1, \u03be2))1 = 1 as above. This proves (3.5).\nFinally, we note that, for each \u03be \u2208 T\u03a3, we have\n[[A]]init(\u03be) = ( hA(\u03be)v \u2297 Fv ) \u2295 ( hA(\u03be)1 \u2297 F1 ) = hA(\u03be)v .\nHence, by (3.5), for each a \u2208 \u3008A\u3009, there exists \u03be \u2208 T\u03a3 such that [[A]]init(\u03be) = a. This proves \u3008A\u3009 \u2286 im([[A]]init), i.e., that \u3008A\u3009 = im([[A]]init).\nA consequence of Lemma 3.1.2 and Theorem 3.1.5 is the following result.\nTheorem 3.1.6. Let B = (B,\u2295,\u2297, 0, 1) be bi-locally finite and not locally finite. Moreover, let A \u2286 B be a finite subset such that \u3008A\u3009{\u2295,\u2297,0,1} is an infinite set. If |\u03a3\n(0)| \u2265 |A \u222a {0, 1}| and |\u03a3(2)| \u2265 2, then we can construct a (\u03a3,B)-wta A such that [[A]]init 6\u2208 Recrun(\u03a3,B). Hence, for such a \u03a3, we have Recinit(\u03a3,B) \\ Recrun(\u03a3,B) 6= \u2205.\nProof. By Theorem 3.1.5 we can construct a (\u03a3,B)-wta A such that im([[A]]init) = \u3008A\u3009{\u2295,\u2299,0,1}. Thus im([[A]]init) is an infinite set. On the other hand, by Lemma 3.1.2, im(r) is finite for each r \u2208 Recrun(\u03a3,B). Hence im([[A]]init) 6\u2208 Recrun(\u03a3,B)."
        },
        {
            "heading": "3.2. EXAMPLES 69",
            "text": "We show three applications of Theorem 3.1.6. First, we consider the strong bimonoid Trunc\u03bb from Example 2.6.10(2) which is not a semiring. We recall that Trunc\u03bb = (B,\u2295,\u2299, 0, 1) where \u03bb \u2208 R and B = {0} \u222a {b \u2208 R | \u03bb \u2264 b \u2264 1}; Trunc\u03bb is bi-locally finite and not locally finite. In fact, for \u03bb = 1 4 , in Example 2.6.10(2) an infinite family (bi |\u2208 i \u2208 N) of elements of B is given which is generated by A = { 12}. Thus, for each ranked alphabet \u03a3 with |\u03a3 (0)| \u2265 3 and |\u03a3(2)| \u2265 2, Theorem 3.1.6 implies that Recinit(\u03a3,Trunc 1 4 ) \\ Recrun(\u03a3,Trunc 1 4 ) 6= \u2205.\nSecond, we consider the bounded lattice FL(2 + 2) in Example 2.6.15(9). This lattice is infinite and freely generated by the two chains a < b and c < d, i.e., by four elements (cf. Figure 2.4). By Observation 2.6.13, the bounded lattice FL(2+2) is a bi-locally finite strong bimonoid. Thus, for each ranked alphabet \u03a3 with |\u03a3(0)| \u2265 6 and |\u03a3(2)| \u2265 2, Theorem 3.1.6 implies that Recinit(\u03a3,FL(2+2))\\Recrun(\u03a3,FL(2+2)) 6= \u2205.\nThird, we consider the strong bimonoid Stb = (N,\u2295,\u2299, 0, 1) from Example 2.6.10(9). We saw that Stb is bi-locally finite and not locally finite. Moreover, \u3008{2}\u3009{\u2295,\u2299,0,1} = N. Thus, by Theorem 3.1.6, for each ranked alphabet \u03a3 with |\u03a3(0)| \u2265 3 and |\u03a3(2)| \u2265 2, we have that Recinit(\u03a3, Stb) \\Recrun(\u03a3, Stb) 6= \u2205. Later a stronger version of this statement will be shown (cf. Theorem 5.2.5 in which we make a weaker assumption on \u03a3)."
        },
        {
            "heading": "3.2 Examples",
            "text": "Here we list a number of weighted tree languages and show how they can be recognized by wta.\nExample 3.2.1. (Number of accepting runs of an fta on a tree.) Let A = (Q, \u03b4, F ) be a \u03a3-fta. We recall that RA(\u03be), R v A(\u03be), and R a A(\u03be) denote the set of runs, valid runs, and accepting runs of A on a tree \u03be, respectively. We consider the mapping\n#Ra A : T\u03a3 \u2192 N with #Ra A (\u03be) = |RaA(\u03be)| for each \u03be \u2208 T\u03a3 .\nWe call #Ra A the multiplicity mapping of A (cf. [Eil74, Sect. VI.1]).\nAs weight algebra we use the semiring Nat = (N,+, \u00b7, 0, 1) of natural numbers. We construct a (\u03a3,Nat)-wta A = (Q, \u03b4\u2032, F \u2032) which r-recognizes and also i-recognizes #Ra\nA , as follows:\n\u2022 for each k \u2208 N, we have (\u03b4\u2032)k = \u03c7(\u03b4k) and \u2022 F \u2032 = \u03c7(F ).\nObviously, A has identity transition weights and identity root weights.\nNext we show that A r-recognizes #Ra A , i.e., [[A]]run = #Ra A . We observe that, for each \u03be \u2208 T\u03a3, we have RA(\u03be) = RA(\u03be). By induction on (TR,\u227a) (defined on page 64), we prove that, for each (\u03be, \u03c1) \u2208 TR, we have\nwt(\u03be, \u03c1) =\n{ 1 if \u03c1 \u2208 RvA(\u03be)\n0 otherwise . (3.6)\nI.B.: Let \u03be = \u03b1 for some \u03b1 \u2208 \u03a3(0), and let \u03c1 : {\u03b5} \u2192 Q. Then wt(\u03be, \u03c1) = (\u03b4\u2032)0(\u03b5, \u03b1, \u03c1(\u03b5)) by definition of wt. We proceed by case analysis.\nCase (a): Let \u03c1 \u2208 RvA(\u03b1). Then (\u03b5, \u03b1, \u03c1(\u03b5)) \u2208 \u03b40 and by the definition of (\u03b4 \u2032)0 we have\n(\u03b4\u2032)0(\u03b5, \u03b1, \u03c1(\u03b5)) = 1. Thus wt(\u03be, \u03c1) = 1.\nCase (b): Let \u03c1 6\u2208 RvA(\u03b1). Then (\u03b5, \u03b1, \u03c1(\u03b5)) 6\u2208 \u03b40 and we have (\u03b4 \u2032)0(\u03b5, \u03b1, \u03c1(\u03b5)) = 0, i.e., wt(\u03be, \u03c1) = 0. I.S.: Let (\u03be, \u03c1) \u2208 TR such that \u03be = \u03c3(\u03be1, . . . , \u03bek) for some k \u2208 N+. Then\nwt(\u03be, \u03c1) = ( wt(\u03be1, \u03c1|1) \u00b7 . . . \u00b7 wt(\u03bek, \u03c1|k) ) \u00b7 (\u03b4\u2032)k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5))\nby definition of wt. Again, we proceed by case analysis."
        },
        {
            "heading": "70 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA",
            "text": "Case (a): Let \u03c1 \u2208 RvA(\u03be). Then, for each i \u2208 [k], we have \u03c1|i \u2208 R v A(\u03bei), and (\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)) \u2208 \u03b4k. Hence, by I.H., we have wt(\u03bei, \u03c1|i) = 1 for each i \u2208 [k] and, by construction, we have (\u03b4\u2032)k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)) = 1. Thus wt(\u03be, \u03c1) = 1.\nCase (b1): Let \u03c1 6\u2208 RvA(\u03be) and (\u2200i \u2208 [k]) : \u03c1|i \u2208 R v A(\u03bei). Then (\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)) 6\u2208 \u03b4k, i.e.,\n(\u03b4\u2032)k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)) = 0. Hence wt(\u03be, \u03c1) = 0.\nCase (b2): \u03c1 6\u2208 RvA(\u03be) and (\u2203i \u2208 [k]) : \u03c1|i 6\u2208 R v A(\u03bei). Then, by I.H., wt(\u03bei, \u03c1|i) = 0 and hence\nwtA(\u03be, \u03c1) = 0. This finishes the proof of (3.6).\nHence, for each \u03be \u2208 T\u03a3,\n[[A]]run(\u03be) = + \u03c1\u2208RA(\u03be) wt(\u03be, \u03c1) \u00b7 F \u2032\u03c1(\u03b5) = + \u03c1\u2208RvA(\u03be) 1 \u00b7 F \u2032\u03c1(\u03b5) = + \u03c1\u2208RaA(\u03be) 1 = |RaA(\u03be)| = #RaA(\u03be) ,\ni.e., [[A]]run(\u03be) is the number of accepting runs of A on \u03be. Hence #Ra A \u2208 Recrun(\u03a3,Nat).\nNext we show that A also i-recognizes #Ra A , i.e., [[A]]init = #Ra A . By induction on T\u03a3, we prove that\nthe following statement holds:\nFor every \u03be \u2208 T\u03a3 and q \u2208 Q we have: hA(\u03be)q = |R v A(q, \u03be)|. (3.7)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). Then we can calculate as follows.\nhA(\u03c3(\u03be1, . . . , \u03bek))q = + q1,...,qk\u2208Q hA(\u03be1)q1 \u00b7 . . . \u00b7 hA(\u03bek)qk \u00b7 (\u03b4 \u2032)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= + q1,...,qk\u2208Q |RvA(q1, \u03be1)| \u00b7 . . . \u00b7 |R v A(qk, \u03bek)| \u00b7 (\u03b4 \u2032)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) (by I.H.) = |RvA(q, \u03c3(\u03be1, . . . , \u03bek))| . (by definitions of (\u03b4 \u2032)k and of R v A(q, \u03c3(\u03be1, . . . , \u03bek)))\nThen, for each \u03be \u2208 T\u03a3, we have\n[[A]]init(\u03be) =+ q\u2208Q hA(\u03be)q \u00b7 F \u2032 q\n=+ q\u2208Q |RvA(q, \u03be)| \u00b7 F \u2032 q (by (3.7))\n=+ q\u2208Q |RaA(q, \u03be)| (by definitions of F \u2032, RvA(q, \u03be), and R a A(q, \u03be)) = | \u22c3\nq\u2208Q\nRaA(q, \u03be)| (because R a A(q1, \u03be) \u2229 R a A(q2, \u03be) = \u2205 for every q1, q2 \u2208 Q)\n= |RaA(\u03be)| (because R a A(\u03be) = \u22c3 q\u2208QR a A(q, \u03be))\n= #Ra A (\u03be) .\nHence #Ra A \u2208 Recinit(\u03a3,Nat).\nThere will be a general result which says that, if B is a semiring, then [[A]]init = [[A]]run for each (\u03a3,B)-wta A (cf. Theorem 5.3.2).\nExample 3.2.2. [Dro21] (Number of occurrences of transitions of accepting computations of an fta on a tree.) Let A = (Q, \u03b4, F ) be a \u03a3-fta. We consider the mapping\n#A : T\u03a3 \u2192 N with #A(\u03be) = |R a A(\u03be)| \u00b7 size(\u03be) for each \u03be \u2208 T\u03a3 .\nAs weight algebra we use the plus-plus strong bimonoid PPN = (N0,\u2295,+, 0, 0) (cf. Example 2.6.10(8)).\nWe construct the (\u03a3,PPN)-wta A = (Q, \u03b4\u2032, F \u2032) which r-recognizes #A, as follows. For every k \u2208 N, q1, . . . , qk, q \u2208 Q, and \u03c3 \u2208 \u03a3 (k), we let:\n\u03b4\u2032k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) =\n{ 1 if (q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) \u2208 \u03b4k\n0 otherwise and F \u2032q =\n{ 0 if q \u2208 F\n0 otherwise .\nObviously, for each \u03be \u2208 T\u03a3, we have RA(\u03be) = RA(\u03be), and for each \u03c1 \u2208 RA(\u03be), we have\nwt(\u03be, \u03c1) =\n{ size(\u03be) if \u03c1 \u2208 RvA(\u03be)\n0 otherwise . (3.8)\nHence, for each \u03be \u2208 T\u03a3,\n[[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwt(\u03be, \u03c1) + F \u2032\u03c1(\u03b5)\n= \u2295\n\u03c1\u2208Rv A (\u03be)\nsize(\u03be) + F \u2032\u03c1(\u03b5) (by (3.8))\n= \u2295\n\u03c1\u2208Ra A (\u03be)\nsize(\u03be) + 0 (because 0 is the identity element of \u2295)\n= + \u03c1\u2208Ra\nA (\u03be)\nsize(\u03be) (because size(\u03be) \u2208 N)\n= |RaA(\u03be)| \u00b7 size(\u03be) = #A(\u03be) .\nHence #A \u2208 Rec run(\u03a3,PPN).\nExample 3.2.3. (Size of trees.) Let \u03a3 = {\u03c3(2), \u03b1(0)}. We consider the mapping\nsize : T\u03a3 \u2192 N\ndefined on page 43. As weight algebra we use the tropical semiring Natmin,+ = (N\u221e,min,+,\u221e, 0). Since N \u2286 N\u221e, by our convention in Section 2.3, size is also a mapping of type size : T\u03a3 \u2192 N\u221e, i.e., a (\u03a3,Natmin,+)-weighted tree language.\nWe construct the (\u03a3,Natmin,+)-wta A = (Q, \u03b4, F ) which r-recognizes size, as follows.\n\u2022 Q = {s}, (intuitively, the state s computes the size of the tree), \u2022 \u03b40(\u03b5, \u03b1, s) = \u03b42(ss, \u03c3, s) = 1, and \u2022 Fs = 0.\nIn Figure 3.3 we represent A as an fta-hypergraph. Clearly, A is bu deterministic, total, and root weight normalized; A is not crisp deterministic, because 1 6\u2208 {\u221e, 0}.\nFor each \u03be \u2208 T\u03a3, there is exactly one run on \u03be. We denote it by \u03c1\u03be, hence \u03c1\u03be(w) = s for each w \u2208 pos(\u03be). Obviously, for each \u03be \u2208 T\u03a3:\nwt(\u03be, \u03c1\u03be) = |pos(\u03be)| .\n72 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA\nThen, for each \u03be \u2208 T\u03a3, we have\n[[A]]run(\u03be) = min(wt(\u03be, \u03c1) + F\u03c1(\u03b5) | \u03c1 \u2208 RA(\u03be)) = wt(\u03be, \u03c1 \u03be) + 0 = |pos(\u03be)| = size(\u03be) .\nHence [[A]]run = size and thus size \u2208 bud-Recrun(\u03a3,Natmin,+). The construction can easily be generalized to an arbitrary ranked alphabet \u03a3.\nExample 3.2.4. (Height of trees.) Let \u03a3 = {\u03c3(2), \u03b1(0)}. We consider the mapping\nheight : T\u03a3 \u2192 N\ndefined on page 43. As weight algebra we use the arctic semiring Natmax,+ = (N\u2212\u221e,max,+,\u2212\u221e, 0). Thus, the mapping height is a (\u03a3,Natmax,+)-weighted tree language.\nWe construct the (\u03a3,Natmax,+)-wta A = (Q, \u03b4, F ) which i-recognizes height, as follows.\n\u2022 Q = {h, 0}, (intuitively, h and 0 should calculate the height and the natural number 0, respectively) \u2022 \u03b40(\u03b5, \u03b1, h) = \u03b40(\u03b5, \u03b1, 0) = 0 and for every q1, q2, q \u2208 Q,\n\u03b42(q1q2, \u03c3, q) =    1 if q1q2q \u2208 {h0h, 0hh} , 0 if q1q2q = 000 ,\n\u2212\u221e otherwise .\n\u2022 Fh = 0 and F0 = \u2212\u221e.\nIn Figure 3.4 we represent A as an fta-hypergraph. Clearly, A is root weight normalized; A is not total, because there does not exist a state q such that \u03b42(hh, \u03c3, q) 6= \u2212\u221e; A is not bu deterministic, because \u03b40(\u03b5, \u03b1, h) = \u03b40(\u03b5, \u03b1, 0) = 0 6= \u2212\u221e.\nBy induction on T\u03a3, we prove that the following statement holds:\nFor each \u03be \u2208 T\u03a3, we have hA(\u03be)h = height(\u03be) and hA(\u03be)0 = 0 . (3.9)\nI.B.: Let \u03be = \u03b1. Then hA(\u03be)h = \u03b4(\u03b5, \u03b1, h) = 0 (and similarly for hA(\u03be)0).\nI.S.: Now let \u03be = \u03c3(\u03be1, \u03be2) for some trees \u03be1, \u03be2 \u2208 T\u03a3. Then\nhA(\u03c3(\u03be1, \u03be2))h\n= max(hA(\u03be1)q1 + hA(\u03be2)q2 + \u03b42(q1q2, \u03c3, h) | q1, q2 \u2208 Q)"
        },
        {
            "heading": "3.2. EXAMPLES 73",
            "text": "= max(hA(\u03be1)h + hA(\u03be2)0 + \u03b42(h0, \u03c3, h), hA(\u03be1)0 + hA(\u03be2)h + \u03b42(0h, \u03c3, h)) (using that \u03b42(hh, \u03c3, h) = \u03b42(00, \u03c3, h) = \u2212\u221e and \u2212\u221e is neutral for max)\n= max(height(\u03be1) + 0 + 1, 0 + height(\u03be2) + 1) (by I.H. and definition of \u03b4)\n= 1 +max(height(\u03be1), height(\u03be2)) = height(\u03be) .\nMoreover, using similar arguments, we can calculate:\nhA(\u03c3(\u03be1, \u03be2))0 = hA(\u03be1)0 + hA(\u03be2)0 + \u03b42(00, \u03c3, 0) = 0 + 0 + 0 = 0 .\nThis finishes the proof of Statement (3.9). Then, for each \u03be \u2208 T\u03a3, we have\n[[A]]init(\u03be) = max(hA(\u03be)q + Fq | q \u2208 Q) = max(hA(\u03be)h + 0, 0 + (\u2212\u221e)) = hA(\u03be)h = height(\u03be) .\nHence [[A]]init = height, and thus height \u2208 Recinit(\u03a3,Natmax,+).\nNext we show that the (\u03a3,Natmax,+)-wta A also r-recognizes the weighted tree language height. First, we observe that for each \u03be \u2208 T\u03a3,\nheight(\u03be) = max(|w| | w \u2208 pos\u03b1(\u03be)) . (3.10)\nLet \u03be \u2208 T\u03a3 be an arbitrary \u03a3-tree. We define the run \u03c10 : pos(\u03be) \u2192 Q by \u03c10(w) = 0 for each w \u2208 pos(\u03be). It is obvious that wt(\u03be, \u03c10) = 0.\nMoreover, for every w \u2208 pos\u03b1(\u03be), we define the run \u03c1w : pos(\u03be) \u2192 Q such that for each v \u2208 pos(\u03be) we let \u03c1w(v) = h if v is a prefix of w, and 0 otherwise. By induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and w \u2208 pos\u03b1(\u03be), we have wt(\u03be, \u03c1w) = |w| . (3.11)\nI.B.: Let \u03be = \u03b1. Then w = \u03b5 and wt(\u03be, \u03c1\u03b5) = \u03b40(\u03b5, \u03b1, h) = 0.\nI.S.: Now let \u03be = \u03c3(\u03be1, \u03be2) and assume that w = 1v for some v \u2208 pos(\u03be1). Then\nwt(\u03c3(\u03be1, \u03be2), \u03c1w) = wt(\u03be1, \u03c1w|1) + wt(\u03be2, \u03c1w|2) + \u03b42(\u03c1w(1)\u03c1w(2), \u03c3, \u03c1w(\u03b5))\n= wt(\u03be1, \u03c1v) + wt(\u03be2, \u03c10) + \u03b42(h0, \u03c3, h)\n= |v|+ 0 + 1 (by I.H. and definition of \u03b42)\n= |w| .\nIn a similar way we prove wt(\u03be, \u03c1w) = |w| if w = 2v for some v. This proves (3.11). Also it is obvious that\nfor every \u03c1 \u2208 RA(\u03be) and w \u2208 pos\u03b1(\u03be), if \u03c1 6\u2208 {\u03c10, \u03c1w}, then wt(\u03be, \u03c1) = \u2212\u221e . (3.12)\nThen we can compute the run semantics of A on \u03be as follows:\n[[A]]run(\u03be) = max \u03c1\u2208RA(\u03be) wt(\u03be, \u03c1) + F\u03c1(\u03b5) = max(wt(\u03be, \u03c1) + F\u03c1(\u03b5) | \u03c1 \u2208 RA(\u03be))\n= max(wt(\u03be, \u03c1) + Fh | \u03c1 \u2208 RA(h, \u03be)) (because F0 = \u2212\u221e)\n= max(wt(\u03be, \u03c1w) + 0 | w \u2208 pos\u03b1(\u03be)) (by (3.12)) = max(|w| | w \u2208 pos\u03b1(\u03be)) (by (3.11)) = height(\u03be) . (by (3.10))\nHence [[A]]run = height, and thus height \u2208 Recrun(\u03a3,Natmax,+). The construction can easily be generalized to an arbitrary ranked alphabet \u03a3.\n74 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA\nExample 3.2.5. (Set of positions.) Let \u03a3 = {\u03c3(2), \u03b3(1), \u03b1(0)}. We consider the mapping\npos : T\u03a3 \u2192 P(N \u2217 +)\ndefined on page 43.\nAs weight algebra we use the semiring Pos = (P(N+ \u2217),\u222a, \u25e6R, \u2205, {\u03b5}) where U \u25e6R V = V U for every\nU, V \u2208 P(N+ \u2217). Thus, the mapping pos is a (\u03a3,Pos)-weighted tree language.\nWe construct the (\u03a3,Pos)-wta A = (Q, \u03b4, F ) which r-recognizes pos, as follows. \u2022 Q = {e, p} (intuitively, e and p calculate \u03b5 \u2208 N+ \u2217 and a path in N+\n\u2217, respectively), \u2022 for every q1, q2, q \u2208 Q we define \u03b40(\u03b5, \u03b1, q) = {\u03b5} and\n\u03b41(q1, \u03b3, q) =    {\u03b5} if q1 = e {1} if q1 = q = p \u2205 otherwise\nand \u03b42(q1q2, \u03c3, q) =    {\u03b5} if q1q2 = ee {1} if q1q2q = pep {2} if q1q2q = epp \u2205 otherwise\n\u2022 Fe = \u2205 and Fp = {\u03b5}.\nIn Figure 3.5 we represent A as fta-hypergraph. Clearly, A is root weight normalized; A is not bu deterministic, because e.g. \u03b41(e, \u03b3, e) = \u03b41(e, \u03b3, p) = {\u03b5}, which is different from \u2205; A is not total, because there does not exist a state q such that \u03b42(pp, \u03c3, q) 6= \u2205.\nLet \u03be \u2208 T\u03a3. First we define particular runs on \u03be and show their weights. For each u \u2208 pos(\u03be), we define the run \u03c1\u03beu : pos(\u03be)\u2192 Q for each w \u2208 pos(\u03be) by\n\u03c1\u03beu(w) = { p if w is a prefix of u e otherwise.\n(We recall that \u03b5 and u are prefixes of u.) Also, we define the run \u03c1\u03bee : pos(\u03be)\u2192 Q by \u03c1 \u03be e(w) = e for each w \u2208 pos(\u03be).\nThen we claim that the following three statements hold for each \u03be \u2208 T\u03a3:\nwt(\u03be, \u03c1\u03bee) = {\u03b5} (3.13)\nfor each \u03c1 \u2208 RA(\u03be) \\ ( {\u03c1\u03beu | u \u2208 pos(\u03be)} \u222a {\u03c1 \u03be e} ) , we have wt(\u03be, \u03c1) = \u2205 (3.14)\nfor each u \u2208 pos(\u03be), we have wt(\u03be, \u03c1\u03beu) = {u} . (3.15)"
        },
        {
            "heading": "3.2. EXAMPLES 75",
            "text": "By direct inspection of the corresponding definitions we get the proofs of Statements (3.13) and (3.14).\nNext we prove Statement (3.15). For this we fix \u03be \u2208 T\u03a3 and u \u2208 pos(\u03be). We define the binary relation \u227ad (d irect postfix) on postfix(u) by letting v1 \u227ad v2 if there exists an i \u2208 N+ such that v2 = iv1. It is obvious that \u227ad is well-founded on postfix(u) and min\u227ad(postfix(u)) = {\u03b5}. By induction on (postfix(u),\u227ad), we prove that the following statement holds (where w is determined by wv = u.)\nFor each v \u2208 postfix(u), we have wt(\u03be|w, \u03c1 \u03be|w v ) = {v} . (3.16)\nI.B.: Let v = \u03b5. Then w = u and \u03c1 \u03be|u \u03b5 : pos(\u03be|u)\u2192 Q maps \u03b5 to p and each other position to e. Let\n\u03be(u) = \u03ba for some \u03ba \u2208 \u03a3(k) with k \u2208 {0, 1, 2}. Then we calculate as follows (abbreviating \u03c1 \u03be|u e by \u03bd):\nwt(\u03be|u, \u03bd) = wt(\u03be|u1, \u03bd|1) \u25e6 R . . . \u25e6R wt(\u03be|uk, \u03bd|k) \u25e6 R \u03b4k(e \u00b7 \u00b7 \u00b7 e\ufe38 \ufe37\ufe37 \ufe38 k , \u03ba, p)\n= {\u03b5} \u25e6R . . . \u25e6R {\u03b5} \u25e6R {\u03b5}\n(by the fact that \u03bd|i = (\u03c1 \u03be|u e )|i = \u03c1 \u03be|ui e for each i \u2208 [k], by (3.13), and by definition of \u03b4)\n= {\u03b5} .\nI.S.: Let v 6= \u03b5. Let \u03be(w) = \u03ba for some \u03ba \u2208 \u03a3(k) with k \u2208 {1, 2}. Then there exists a unique\nv\u2032 \u2208 postfix(u) with v\u2032 \u227ad v. Let i \u2208 [k] be such that v = iv\u2032, then wt(\u03be|wi, \u03c1 \u03be|wi v\u2032 ) = {v \u2032} by the I.H. Then we can calculate as follows (abbreviating \u03c1 \u03be|w v by \u03bd):\nwt(\u03be|w, \u03bd) = wt(\u03bew1, \u03bd|1) \u25e6 R . . . \u25e6R wt(\u03bew(i\u22121), \u03bd|i\u22121) \u25e6 R wt(\u03bewi, \u03bd|i)\n\u25e6R wt(\u03bew(i+1), \u03bd|i+1) \u25e6 R . . . \u25e6R wt(\u03bewk, \u03bd|k) \u25e6 R \u03b4k(e \u00b7 \u00b7 \u00b7 e\ufe38 \ufe37\ufe37 \ufe38 i\u22121 p e \u00b7 \u00b7 \u00b7 e\ufe38 \ufe37\ufe37 \ufe38 k\u2212i , \u03ba, p)\n= wt(\u03bewi, \u03bd|i) \u25e6 R \u03b4k(e \u00b7 \u00b7 \u00b7 e\ufe38 \ufe37\ufe37 \ufe38\ni\u22121 p e \u00b7 \u00b7 \u00b7 e\ufe38 \ufe37\ufe37 \ufe38 k\u2212i , \u03ba, p)\n(because \u03bd|j = \u03c1 \u03be|wj e for each j 6= i; thus wt(\u03bewj , \u03bd|j) = {\u03b5} by Statement (3.13))\n={v\u2032} \u25e6R \u03b4k(e \u00b7 \u00b7 \u00b7 e\ufe38 \ufe37\ufe37 \ufe38 i\u22121 p e \u00b7 \u00b7 \u00b7 e\ufe38 \ufe37\ufe37 \ufe38 k\u2212i , \u03ba, p) (because \u03bd|i = \u03c1 \u03be|wi v\u2032 ; by I.H. wt(\u03bewi, \u03bd|i) = {v \u2032})\n={v\u2032} \u25e6R {i} = {iv\u2032} = {v} . (by definition of \u03b4k(e \u00b7 \u00b7 \u00b7 e\ufe38 \ufe37\ufe37 \ufe38 i\u22121 p e \u00b7 \u00b7 \u00b7 e\ufe38 \ufe37\ufe37 \ufe38 k\u2212i , \u03ba, p))\nThis finishes the proof of Statement (3.16). Choosing v = u in this statement proves Statement (3.15).\nNow, for each \u03be \u2208 T\u03a3, we can prove that [[A]]run(\u03be) = pos(\u03be) as follows.\n[[A]]run(\u03be) = \u22c3 (wt(\u03be, \u03c1) \u25e6R F\u03c1(\u03b5) | \u03c1 \u2208 RA(\u03be))\n= \u22c3\n(wt(\u03be, \u03c1) \u25e6R F\u03c1(\u03b5) | \u03c1 \u2208 {\u03c1 \u03be u | u \u2208 pos(\u03be)} \u222a {\u03c1 \u03be e}) (by (3.14))\n= \u22c3\n(wt(\u03be, \u03c1) \u25e6R F\u03c1(\u03b5) | \u03c1 \u2208 {\u03c1 \u03be u | u \u2208 pos(\u03be)}) (because \u03c1 \u03be e(\u03b5) = e and Fe = \u2205)\n= \u22c3\n(wt(\u03be, \u03c1) | \u03c1 \u2208 {\u03c1\u03beu | u \u2208 pos(\u03be)}) (because \u03c1 \u03be u(\u03b5) = p for each u \u2208 pos(\u03be) and Fp = {\u03b5})\n= \u22c3\n(wt(\u03be, \u03c1\u03beu) | u \u2208 pos(\u03be))\n= \u22c3 ({u} | u \u2208 pos(\u03be)) (by (3.15))\n= pos(\u03be) .\nHence [[A]]run = pos and thus pos \u2208 Recrun(\u03a3,Pos).\n76 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA\nExample 3.2.6. (Yield of trees.) Let \u03a3 = {\u03c3(2), \u03b1(0), \u03b2(0)}. We consider the mapping\nyieldP : T\u03a3 \u2192 P((\u03a3 (0))\u2217)\ndefined, for each \u03be \u2208 T\u03a3, by yield P(\u03be) = {yield(\u03be)}. For the definition of yield(\u03be) we refer to Section 2.9. For instance, yieldP(\u03c3(\u03b1, \u03c3(\u03b1, \u03b2)) = {\u03b1\u03b1\u03b2}.\nAs weight algebra we use the formal language language semiring Lang\u03a3 = (P(\u03a3 \u2217),\u222a, \u00b7, \u2205, {\u03b5}). Thus,\nthe mapping yield is a (\u03a3, Lang\u03a3)-weighted tree language.\nWe define the (\u03a3, Lang\u03a3)-wta A = (Q, \u03b4, F ) which i-recognizes yield P , as follows. \u2022 Q = {y} (intuitively, y calculates the yield), \u2022 \u03b40(\u03b5, \u03b1, y) = {\u03b1}, \u03b40(\u03b5, \u03b2, y) = {\u03b2}, and \u03b42(yy, \u03c3, y) = {\u03b5}, \u2022 Fy = {\u03b5}.\nIn Figure 3.6 we represent A as fta-hypergraph. Clearly, A is bu deterministic, total, and root weight normalized; A is not crisp deterministic because, e.g., \u03b40(\u03b5, \u03b1, y) 6\u2208 {\u2205, {\u03b5}}.\nBy induction on T\u03a3, we prove that the following statement holds:\nFor each \u03be \u2208 T\u03a3, we have hA(\u03be)y = {yield(\u03be)} .\nI.B.: Let \u03be = \u03b1. Then hA(\u03be)y = \u03b40(\u03b5, \u03b1, y) = {\u03b1} = {yield(\u03b1)}. For \u03be = \u03b2 the proof is similar.\nI.S.: Now let \u03be = \u03c3(\u03be1, \u03be2) and assume that hA(\u03bei)y = {yield(\u03bei)} for each i \u2208 {1, 2}. Then\nhA(\u03be)y = hA(\u03be1)y hA(\u03be2)y \u03b42(yy, \u03c3, y) = {yield(\u03be1)}{yield(\u03be2)}{\u03b5} = {yield(\u03be)} .\nThen we have [[A]]init(\u03be) = hA(\u03be)y Fy = {yield(\u03be)} = yield P(\u03be). Thus yieldP \u2208 bud-Recinit(\u03a3, Lang\u03a3).\nExample 3.2.7. (Transformation monoid.) We recall from Section 2.11 that a \u0393-fsa is a tuple A = (Q, I, \u03b4, F ) where Q is the finite set of states, I \u2286 Q and F \u2286 Q are the sets of initial states and final states, respectively, and \u03b4 \u2286 Q \u00d7 \u0393\u00d7Q is the set of transitions. The language L(A) recognized by A is defined in terms of runs.\nAlternatively, we wish to describe L(A) by using the mapping\n\u03b4\u0304 : \u0393\u2217 \u2192 (P(Q)\u2192 P(Q)) .\nas follows. Intuitively, for every w \u2208 \u0393\u2217 and U \u2286 Q, the set \u03b4\u0304(w)(U) is the set of all states which A can enter when starting in some state of U and reading the string w. Formally, we define \u03b4\u0304 by induction on (\u0393\u2217,\u227a) where, for every w1, w2 \u2208 \u0393\u2217, we let w1 \u227a w2 if there exists an a \u2208 \u0393 such that w2 = w1a. Obviously, \u227a is well-founded and min\u227a(\u0393\u2217) = {\u03b5}. For every a \u2208 \u0393, w \u2208 \u0393\u2217, and U \u2286 Q, we define\n\u03b4\u0304(\u03b5)(U) = U and \u03b4\u0304(wa)(U) = {p \u2208 Q | (\u2203r \u2208 \u03b4\u0304(w)(U)) : (r, a, p) \u2208 \u03b4} ."
        },
        {
            "heading": "3.2. EXAMPLES 77",
            "text": "Then it easy to see that L(A) = {w \u2208 \u0393\u2217 | \u03b4\u0304(w)(I) \u2229 F 6= \u2205}.\nLet \u03a3 = {\u03c3(2), \u03b1(0), \u03b2(0)} and let A = (Q, I, \u03b4, F ) be a \u0393-fsa with \u0393 = {\u03b1, \u03b2}. We define the mapping\nBPSA : T\u03a3 \u2192 (P(Q)\u2192 P(Q)) with BPSA(\u03be) = \u03b4\u0304(yield(\u03be)) for each \u03be \u2208 T\u03a3\nwhere yield is defined in Section 2.9. Eventually, we will prove that BPSA is r-recognizable over a suitable strong bimonoid.\nThe name \u201cBPS\u201d of the mapping refers to Bar-Hillel, Perles, and Shamir [BPS61]; in that paper they have used a technique to fold the computation of a finite-state automaton onto a derivation tree of a context-free grammar. They used this technique for the proof of the fact that the set of context-free languages is closed under intersection with the set of regular languages. We note that the set of contextfree languages and the set of yields of recognizable tree languages are equal, cf. [Bra69, Thm. 3.20] and [Don70, Thm. 2.5] (also cf. Corollary 8.3.4 and [GS84, Cor. 3.2.4 and Thm. 3.2.5]). Here we illustrate the BPS-technique for the yield of the particular recognizable tree language T\u03a3 (also cf. Section 8.3).\nWe consider the near semiring NearSemP(Q) = (B,\u222a, \u22c4, \u2205\u0303, id) over the commutative semigroup (P(Q),\u222a, \u2205) as defined in Example 2.6.10(5), where id abbreviates idP(Q). We recall that B = {f | f : P(Q)\u2192 P(Q), f(\u2205) = \u2205}.\nWe note that (B, \u22c4, id) is a monoid. Moreover, it is easy to verify that \u03b4\u0304 is monoid homomorphism from (\u0393\u2217, \u00b7, \u03b5) to (B, \u22c4, id), i.e., \u03b4\u0304(\u03b5) = id and,\nfor every v, w \u2208 \u0393\u2217, we have \u03b4\u0304(wv) = \u03b4\u0304(w) \u22c4 \u03b4\u0304(v). (3.17)\nBy induction on (\u0393\u2217,\u227a), we can now easily prove (3.17).\nNow we construct the (\u03a3,NearSemP(Q))-wta A = ({\u2217}, \u03b4 \u2032, F ) which r-recognizes BPSA as follows: \u2022 (\u03b4\u2032)0(\u03b5, \u03b1, \u2217) = \u03b4\u0304(\u03b1), (\u03b4 \u2032)0(\u03b5, \u03b2, \u2217) = \u03b4\u0304(\u03b2), and (\u03b4\n\u2032)2(\u2217\u2217, \u03c3, \u2217) = id and \u2022 F\u2217 = id.\nIn fact, A is bu deterministic and root weight normalized, and in general A is not crisp deterministic.\nLet \u03be \u2208 T\u03a3 and \u03c1\u03be : pos(\u03be)\u2192 Q be the run which maps each position of \u03be to \u2217. By induction on T\u03a3, we prove that the following statement holds:\nFor each \u03be \u2208 T\u03a3, we have wtA(\u03be, \u03c1\u03be) = \u03b4\u0304(yield(\u03be)) . (3.18)\nLet \u03be = \u03b1. Then wtA(\u03be, \u03c1\u03be) = (\u03b4 \u2032)0(\u03b5, \u03b1, \u2217) = \u03b4\u0304(\u03b1) = \u03b4\u0304(yield(\u03be)). In the same way we obtain (3.18)\nfor \u03be = \u03b2. Now let \u03be = \u03c3(\u03be1, \u03be2) and assume that (3.18) holds for \u03be1 and \u03be2. Then\nwtA(\u03be, \u03c1\u03be) = wtA(\u03be1, \u03c1\u03be1) \u22c4 wtA(\u03be2, \u03c1\u03be2) \u22c4 (\u03b4 \u2032)2(\u2217\u2217, \u03c3, \u2217)\n= \u03b4\u0304(yield(\u03be1)) \u22c4 \u03b4\u0304(yield(\u03be2)) \u22c4 id (by I.H. and construction)\n= \u03b4\u0304(yield(\u03be1)) \u22c4 \u03b4\u0304(yield(\u03be2)) (because id is the identity)\n= \u03b4\u0304(yield(\u03be1) yield(\u03be2)) (because \u03b4\u0304 is a monoid homomorphism)\n= \u03b4\u0304(yield(\u03c3(\u03be1, \u03be2)) .\nFinally, for each \u03be \u2208 T\u03a3 we have\n[[A]]run(\u03be) = \u22c3\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1) = wtA(\u03be, \u03c1\u03be) = \u03b4\u0304(yield(\u03be)) = BPSA(\u03be) .\nThus BPSA \u2208 bud-Rec run(\u03a3,NearSemP(Q)).\n78 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA\nExample 3.2.8. (Exponentiation.) We consider the string ranked alphabet \u03a3 = {\u03b3(1), \u03b1(0)} and the mapping\nexp : T\u03a3 \u2192 N with exp(\u03be) = 2 n+1 if \u03be = \u03b3n(\u03b1) for some n \u2208 N .\nAs weight algebra we consider the tropical bimonoid TropBM = (N\u221e,+,min, 0,\u221e) from Example 2.6.10. Thus exp is a (\u03a3,TropBM)-weighted tree language.\nWe construct the (\u03a3,TropBM)-wta A = (Q, \u03b4, F ) which r-recognizes exp, as follows.\n\u2022 Q = {q0, q1}, \u2022 \u03b40(\u03b5, \u03b1, p) = \u03b41(p, \u03b3, q) = 1 for every p, q \u2208 Q, and \u2022 Fq0 = Fq1 = 1.\nIn Figure 3.7 we show the wta A. Obviously, A is not bu deterministic.\nNow let n \u2208 N. We compute [[A]]run(\u03b3n(\u03b1)). It is easy to see that wt(\u03b3n(\u03b1), \u03c1) = 1 for each run \u03c1 \u2208 RA(\u03b3n(\u03b1)). Then for each n \u2208 N we have\n[[A]]run(\u03b3n(\u03b1)) = + \u03c1\u2208RA(\u03b3n(\u03b1)) min(wt(\u03b3n(\u03b1), \u03c1), F\u03c1(\u03b5)) = + \u03c1\u2208RA(\u03b3n(\u03b1)) 1 = |RA(\u03b3 n(\u03b1))| = 2n+1 = exp(\u03b3n(\u03b1)) ,\nwhere the last but one equality is due to the fact that there exists a bijection between the two finite sets RA(\u03b3 n(\u03b1)) and {q0, q1} n+1. Hence [[A]]run = exp and thus exp \u2208 Recrun(\u03a3,TropBM).\nExample 3.2.9. (Exponentiation plus one.) Let \u03a3 = {\u03b3(1), \u03b1(0)} be a string ranked alphabet. We define the mapping\n(exp+1) : T\u03a3 \u2192 N with (exp+1)(\u03b3 n(\u03b1)) = 2n + 1 for each n \u2208 N .\nAs weight algebra we consider the semiring Nat = (N,+, \u00b7, 0, 1). Thus, the mapping exp is a (\u03a3,N)weighted tree language.\nWe construct the (\u03a3,Nat)-wta A = (Q, \u03b4, F ) which i-recognizes (exp+1), as follows:\n\u2022 Q = {1, e} (intuitively, 1 and e calculate 1 \u2208 N and 2n, respectively), \u2022 \u03b40(\u03b5, \u03b1, 1) = \u03b40(\u03b5, \u03b1, e) = 1 and for every q1, q \u2208 Q,\n\u03b41(q1, \u03b3, q) =    1 if q1 = q = 1 2 if q1 = q = e\n0 otherwise .\n\u2022 F1 = Fe = 1.\n3.2. EXAMPLES 79\nIn Figure 3.8 we represent A as fta-hypergraph. Clearly, A is total and has identity root weights; A is not bu deterministic and it is not root weight normalized.\nWe can prove easily that:\nhA(\u03b3 n(\u03b1))1 = 1 and hA(\u03b3 n(\u03b1))e = 2 n for each n \u2208 N.\nThen [[A]]init(\u03b3n(\u03b1)) = 2n + 1 = (exp+1)(\u03b3n(\u03b1)) for each n \u2208 N. Thus (exp+1) \u2208 Recinit(\u03a3,Nat).\nExample 3.2.10. (Number of \u03b3\u2019s modulo 2) Let \u03a3 = {\u03b3(1), \u03b1(0)} be a string ranked alphabet. We define the mapping\nodd : T\u03a3 \u2192 {0, 1} with odd(\u03b3 n(\u03b1)) =\n{ 1 if n is odd\n0 otherwise for each n \u2208 N.\nAs weight algebra we consider the field F2 = ({0, 1},\u2295,\u2297, 0, 1) (cf. Example 2.6.10(7)). Thus, the mapping odd is a (\u03a3,F2)-weighted tree language.\nWe construct the (\u03a3,F2)-wta A = (Q, \u03b4, F ) which r-recognizes odd, as follows. \u2022 Q = {q0, q1} (intuitively, on each input tree \u03b3n(\u03b1), the wta A starts at the leaf in state q0 or q1 and, at any of the occurrences of \u03b3, nondeterministically either stays in q0 or switches to q1 and remains there), \u2022 for every p1, p2 \u2208 Q we define\n\u03b40(\u03b5, \u03b1, q0) = 1 and \u03b40(\u03b5, \u03b1, q1) = 0 and \u03b41(p1, \u03b3, p2) = { 1 if p1p2 \u2208 {q0q0, q0q1, q1q1} 0 otherwise\n\u2022 Fq0 = 0 and Fq1 = 1.\nIn Figure 3.9 we show the (\u03a3,F2)-wta which r-recognizes odd. Clearly, A has identity transition weights and it is root weight normalized; A is not bu deterministic.\nLet n \u2208 N and let \u03be = \u03b3n(\u03b1). Then\n[[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwt(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = \u2295\n\u03c1\u2208RA(q1,\u03be)\nwt(\u03be, \u03c1) = \u2295\n\u03c1\u2208[n]\n1 = odd(\u03be) .\nHere we use the additive monoid ({0, 1},\u2295, 0) of F2 to count modulo 2. At the same time, for each strong bimonoid B = (B,\u2295,\u2297, 0, 1), we can easily design a crisp deterministic (\u03a3,B)-wta with two states and identity root weights such that it simulates counting modulo 2 in its state behaviour. Hence, for each strong bimonoid B, the corresponding mapping oddB : T\u03a3 \u2192 {0, 1} is r-recognizable by a crisp deterministic (\u03a3,B)-wta with identity root weights. We note that we use the state behaviour of a wta for \u201ccounting\u201d also in Example 3.2.16.\n80 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA\nExample 3.2.11. (Number of occurrences of a pattern, semiring Nat.) Let \u03a3 = {\u03c3(2), \u03b3(1), \u03b1(0)}. We define the mapping\n#\u03c3(.,\u03b1) : T\u03a3 \u2192 N with #\u03c3(.,\u03b1)(\u03be) = |U(\u03be)| for each \u03be \u2208 T\u03a3\nwhere U(\u03be) = {u \u2208 pos(\u03be) | \u03be(u) = \u03c3, \u03be(u2) = \u03b1}. Intuitively, #\u03c3(.,\u03b1)(\u03be) is the number of occurrences of\nthe pattern \u03c3(., \u03b1) in \u03be. For instance, #\u03c3(.,\u03b1) ( \u03c3(\u03b3(\u03c3(\u03b1, \u03b1)), \u03c3(\u03b1, \u03b1)) ) = 2.\nAs weight algebra we use the natural number semiring Nat = (N,+, \u00b7, 0, 1). Thus, the mapping #\u03c3(.,\u03b1) is a (\u03a3,Nat)-weighted tree language.\nWe construct the (\u03a3,Nat)-wta A = (Q, \u03b4, F ) which r-recognizes #\u03c3(.,\u03b1), as follows.\n\u2022 Q = {\u22a5, a, f} (intuitively, \u22a5 ignores occurrences of the pattern, a detects an \u03b1-labeled leaf, and f reports \u201cpattern found\u201d up to the root), \u2022 for every q1, q2, q \u2208 Q we define\n\u03b40(\u03b5, \u03b1, q) = { 1 if q \u2208 {\u22a5, a} 0 otherwise \u03b41(q1, \u03b3, q) = { 1 if q1q \u2208 {\u22a5\u22a5, ff} 0 otherwise\n\u03b42(q1q2, \u03c3, q) = { 1 if q1q2q \u2208 {\u22a5\u22a5\u22a5,\u22a5af,\u22a5ff, f\u22a5f} 0 otherwise\n\u2022 F\u22a5 = Fa = 0 and Ff = 1.\nClearly, A is root weight normalized; A is not total, because there does not exist a state q with \u03b41(a, \u03b3, q) 6= 0; A is not bu deterministic. In Figure 3.10 we represent A as an fta-hypergraph."
        },
        {
            "heading": "3.2. EXAMPLES 81",
            "text": "Let \u03be \u2208 T\u03a3. We prove that [[A]]run(\u03be) = #\u03c3(.,\u03b1)(\u03be). For this we define, for each u \u2208 U(\u03be), the special\nrun \u03c1\u03beu : pos(\u03be)\u2192 Q for each w \u2208 pos(\u03be) by\n\u03c1\u03beu(w) =    f if w is a prefix of u a if w = u2 \u22a5 otherwise\nIt is obvious that wt(\u03be, \u03c1\u03beu) = 1 and \u03c1 \u03be u(\u03b5) = f . Hence wt(\u03be, \u03c1 \u03be u)\u00b7F\u03c1\u03beu(\u03b5) = 1. Moreover, wt(\u03be, \u03c1)\u00b7F\u03c1(\u03b5) =\n0 for each \u03c1 \u2208 RA(\u03be) \\ {\u03c1 \u03be u | u \u2208 U(\u03be)}.\nThen we can calculate as follows.\n[[A]]run(\u03be) = + \u03c1\u2208RA(\u03be) wt(\u03be, \u03c1) \u00b7 F\u03c1(\u03b5) = + u\u2208U(\u03be) wt(\u03be, \u03c1\u03beu) \u00b7 F\u03c1\u03beu(\u03b5) = |U(\u03be)| = #\u03c3(.,\u03b1)(\u03be) .\nHence [[A]]run = #\u03c3(.,\u03b1) and thus #\u03c3(.,\u03b1) \u2208 Rec run(\u03a3,Nat).\nNext we show that A also i-recognizes #\u03c3(.,\u03b1). By induction on T\u03a3, we prove that the following statement holds:\nFor each \u03be \u2208 T\u03a3, we have hA(\u03be)\u22a5 = 1, hA(\u03be)a = c(\u03be), and hA(\u03be)f = #\u03c3(.,\u03b1)(\u03be), where c(\u03be) = 1 if \u03be = \u03b1, and 0 otherwise. (3.19)\nI.B.: Let \u03be = \u03b1. Then\nhA(\u03b1)\u22a5 = \u03b40(\u03b5, \u03b1,\u22a5) = 1,\nhA(\u03b1)a = \u03b40(\u03b5, \u03b1, a) = 1 = c(\u03b1), and\nhA(\u03b1)f = \u03b40(\u03b5, \u03b1, f) = 0 = #\u03c3(.,\u03b1)(\u03b1) .\nI.S.: Let \u03be = \u03b3(\u03be\u2032). Then\nhA(\u03b3(\u03be \u2032))\u22a5 = hA(\u03be \u2032)\u22a5 \u00b7 \u03b41(\u22a5, \u03b3,\u22a5) = 1, hA(\u03b3(\u03be \u2032))a = 0 = c(\u03b3(\u03be \u2032)), and hA(\u03b3(\u03be \u2032))f = hA(\u03be \u2032)f \u00b7 \u03b41(f, \u03b3, f) = #\u03c3(.,\u03b1)(\u03be \u2032) = #\u03c3(.,\u03b1)(\u03b3(\u03be \u2032)) .\nLet \u03be = \u03c3(\u03be1, \u03be2). Then\nhA(\u03c3(\u03be1, \u03be2))\u22a5 = hA(\u03be1)\u22a5 \u00b7 hA(\u03be2)\u22a5 \u00b7 \u03b42(\u22a5\u22a5, \u03c3,\u22a5) = 1,\nhA(\u03c3(\u03be1, \u03be2))a = 0 = c(\u03c3(\u03be1, \u03be2)), and\nhA(\u03c3(\u03be1, \u03be2))f = hA(\u03be1)\u22a5 \u00b7 hA(\u03be2)a \u00b7 \u03b42(\u22a5a, \u03c3, f) +\nhA(\u03be1)\u22a5 \u00b7 hA(\u03be2)f \u00b7 \u03b42(\u22a5f, \u03c3, f) +\nhA(\u03be1)f \u00b7 hA(\u03be2)\u22a5 \u00b7 \u03b42(f\u22a5, \u03c3, f)\n= c(\u03be2) + #\u03c3(.,\u03b1)(\u03be2) + #\u03c3(.,\u03b1)(\u03be1)\n= #\u03c3(.,\u03b1)(\u03c3(\u03be1, \u03be2)) .\nThis proves (3.19). Then for each \u03be \u2208 T\u03a3 we have\n[[A]]init(\u03be) =+ q\u2208Q hA(\u03be)q \u00b7 Fq = hA(\u03be)f = #\u03c3(.,\u03b1)(\u03be) .\nHence #\u03c3(.,\u03b1) \u2208 Rec init(\u03a3,Nat)."
        },
        {
            "heading": "82 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA",
            "text": "Example 3.2.12. (Number of occurrences of a pattern, semiring Natmax,+.) Again, let \u03a3 = {\u03c3(2), \u03b3(1), \u03b1(0)} and let us consider the mapping #\u03c3(.,\u03b1) : T\u03a3 \u2192 N defined in Example 3.2.11.\nWe construct an (\u03a3,Natmax,+)-wta A = (Q, \u03b4, F ) which r-recognizes #\u03c3(.,\u03b1), where Natmax,+ is the arctic semiring. For this, we let\n\u2022 Q = {\u03c3, \u03b3, \u03b1}, \u2022 for every q1, q2, q \u2208 Q we define\n\u03b40(\u03b5, \u03b1, q) = { 0 if q = \u03b1 \u2212\u221e otherwise \u03b41(q1, \u03b3, q) = { 0 if q = \u03b3 \u2212\u221e otherwise\n\u03b42(q1q2, \u03c3, q) =    1 if q2 = \u03b1 and q = \u03c3 0 if q2 6= \u03b1 and q = \u03c3 \u2212\u221e otherwise ,\n\u2022 for each q \u2208 Q we define Fq = 0.\nIt is clear that A is bu deterministic. Since \u03b42(q1\u03b1, \u03c3, \u03c3) 6\u2208 {\u2212\u221e, 0} for each q1 \u2208 Q, the wta A is not crisp deterministic.\nNow let \u03be \u2208 T\u03a3. We define the particular run \u03c1\u03be on \u03be such that \u03c1\u03be(w) = \u03be(w) for each w \u2208 pos(\u03be). Then, for each w \u2208 pos(\u03be), the weight of the transition induced by \u03c1\u03be on \u03be at w is 1 if \u03be(w) = \u03c3 and \u03be(w2) = \u03b1 (i.e., the pattern \u03c3(., \u03b1) shows up at w) and 0 otherwise. Hence wt(\u03be, \u03c1\u03be) = #\u03c3(.,\u03b1)(\u03be). Moreover, for each \u03c1 \u2208 RA(\u03be) \\ {\u03c1\u03be} we have wt(\u03be, \u03c1) = \u2212\u221e.\nThus we can calculate as follows. [[A]]run(\u03be) = max ( wt(\u03be, \u03c1) + F\u03c1(\u03b5) | \u03c1 \u2208 RA(\u03be) ) = wt(\u03be, \u03c1\u03be) + F\u03c1\u03be(\u03b5) = #\u03c3(.,\u03b1)(\u03be) + 0 = #\u03c3(.,\u03b1)(\u03be),\nhence [[A]]run(\u03be) = #\u03c3(.,\u03b1)(\u03be). Thus #\u03c3(.,\u03b1) \u2208 bud-Rec run(\u03a3,Natmax,+).\nExample 3.2.13. (Difference of numbers of occurrences of nullary symbols.) Let \u03a3 = {\u03c3(2), \u03b1(0), \u03b2(0)} be a ranked alphabet. We define the weighted tree language\ndiff : T\u03a3 \u2192 Z\u221e such that, for each \u03be \u2208 T\u03a3, we let\ndiff(\u03be) = { |pos\u03b1(\u03be1)| \u2212 |pos\u03b2(\u03be2)| if \u03be = \u03c3(\u03be1, \u03be2) for some \u03be1, \u03be2 \u2208 T\u03a3 \u221e otherwise.\nFor instance, diff(\u03c3(\u03b1, \u03c3(\u03b2, \u03b2))) = \u22121. As weight algebra we consider the tropical semiring Intmin,+ = (Z\u221e,min,+,\u221e, 0) over Z. Thus, the mapping diff is a (\u03a3, Intmin,+)-weighted tree language.\nWe construct the (\u03a3, Intmin,+)-wta A = (Q, \u03b4, F ) which i-recognizes diff, as follows:\n\u2022 Q = {#\u03b1,#\u03b2 , d} (intuitively, #\u03b1 calculates the number of occurrences of \u03b1, #\u03b2 calculates the negative of the number of occurrences of \u03b2, and d calculates the difference), \u2022 for each q \u2208 Q we define\n\u03b40(\u03b5, \u03b1, q) =    1 if q = #\u03b1 0 if q = #\u03b2 \u221e otherwise\n\u03b40(\u03b5, \u03b2, q) =    0 if q = #\u03b1 \u22121 if q = #\u03b2 \u221e otherwise\nand for each q1, q2, q \u2208 Q we define\n\u03b42(q1q2, \u03c3, q) = { 0 if q1q2q \u2208 {#\u03b1#\u03b1#\u03b1, #\u03b2#\u03b2#\u03b2 , #\u03b1#\u03b2d} \u221e otherwise\n\u2022 F#\u03b1 = F#\u03b2 =\u221e and Fd = 0.\n3.2. EXAMPLES 83\nClearly, A is root weight normalized; A is not total, because there does not exist a state q such that \u03b42(dd, \u03c3, q) 6= \u221e; A is not bu deterministic, because \u03b40(\u03b5, \u03b1,#\u03b1) 6= \u221e 6= \u03b40(\u03b5, \u03b1,#\u03b2). In Figure 3.11 we represent A as fta-hypergraph.\nFirst we observe that, for each \u03be \u2208 T\u03a3, we have\nhA(\u03be)#\u03b1 = |pos\u03b1(\u03be)| and hA(\u03be)#\u03b2 = \u2212|pos\u03b2(\u03be)| . (3.20)\nNext we prove that [[A]]init = diff. Let \u03be \u2208 T\u03a3. By definition of F , we have:\n[[A]]init(\u03be) = min(hA(\u03be)q + Fq | q \u2208 Q) = hA(\u03be)d + Fd = hA(\u03be)d .\nLet \u03be \u2208 {\u03b1, \u03b2}. Then hA(\u03be)d = \u03b40(\u03b5, \u03be, d) =\u221e. Hence [[A]]init(\u03be) =\u221e = diff(\u03be).\nNow let \u03be = \u03c3(\u03be1, \u03be2) for some \u03be1, \u03be2 \u2208 T\u03a3. Then we can calculate as follows:\nhA(\u03c3(\u03be1, \u03be2))d = min ( hA(\u03be1)q1 + hA(\u03be2)q2 + \u03b42(q1q2, \u03c3, d) | q1, q2 \u2208 Q )\n= hA(\u03be1)#\u03b1 + hA(\u03be2)#\u03b2 + \u03b42(#\u03b1#\u03b2 , \u03c3, d) = hA(\u03be1)#\u03b1 + hA(\u03be2)#\u03b2 + 0 = |pos\u03b1(\u03be1)| \u2212 |pos\u03b2(\u03be2)| (by (3.20))\n= diff(\u03c3(\u03be1, \u03be2)) .\nHence [[A]]init = diff and thus diff \u2208 Recinit(\u03a3, Intmin,+).\nExample 3.2.14. (Difference of numbers of occurrences of symbols in monadic trees.) Let \u03a3 = {\u03b3(1), \u03c3(1), \u03b1(0)} be a string ranked alphabet. We define the mapping\ndiffm : T\u03a3 \u2192 Z with diffm(\u03be) = |pos\u03b3(\u03be)| \u2212 |pos\u03c3(\u03be)| for each \u03be \u2208 T\u03a3 .\nAs weight algebra we consider the ring Int = (Z,+, \u00b7, 0, 1) of integers. Thus, the mapping diffm is a (\u03a3, Int)-weighted tree language.\nWe construct the (\u03a3, Int)-wta A = (Q, \u03b4, F ) which i-recognizes diffm, as follows.\n\u2022 Q = {1, d} (intuitively, the state 1 calculates the integer 1 and, at each non-leaf position u, the state d increases or decreases the difference by 1 depending on the symbol at u),\n84 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA\n\u2022 \u03b40(\u03b5, \u03b1, 1) = 1 and \u03b40(\u03b5, \u03b1, d) = 0, and for every q1, q2 \u2208 Q and \u03bd \u2208 {\u03b3, \u03c3} we define\n\u03b41(q1, \u03bd, q2) =    1 if q1q2 \u2208 {11, dd} 1 if q1q2 = 1d and \u03bd = \u03b3 \u22121 if q1q2 = 1d and \u03bd = \u03c3\n0 if q1q2 = d1\n\u2022 F1 = 0 and Fd = 1.\nClearly, A is root weight normalized; A is not bu deterministic, because \u03b41(1, \u03b3, 1) 6= 0 6= \u03b41(1, \u03b3, d). In Figure 3.12 we represent A as fta-hypergraph.\nFirst, by induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3, we have hA(\u03be)1 = 1 and hA(\u03be)d = |pos\u03b3(\u03be)| \u2212 |pos\u03c3(\u03be)| . (3.21)\nI.B.: Let \u03be = \u03b1. Then hA(\u03be)1 = \u03b40(\u03b5, \u03b1, 1) = 1 and hA(\u03be)d = \u03b40(\u03b5, \u03b1, d) = 0. Thus (3.21) holds. I.S.: Let \u03be = \u03b3(\u03be\u2032) for some \u03be\u2032 \u2208 T\u03a3. Then\nhA(\u03be)1 =+ q\u2208Q hA(\u03be \u2032)q \u00b7 \u03b41(q, \u03b3, 1)\n= hA(\u03be \u2032)1 \u00b7 \u03b41(1, \u03b3, 1) (by definition of \u03b41 and by I.H.)\n= 1 \u00b7 1 = 1\nand\nhA(\u03be)d =+ q\u2208Q hA(\u03be \u2032)q \u00b7 \u03b41(q, \u03b3, d) = hA(\u03be \u2032)1 \u00b7 \u03b41(1, \u03b3, d) + hA(\u03be \u2032)d \u00b7 \u03b41(d, \u03b3, d)\n= 1 \u00b7 1 + (|pos\u03b3(\u03be \u2032)| \u2212 |pos\u03c3(\u03be \u2032)|) \u00b7 1 (by definition of \u03b41 and by I.H.) = (|pos\u03b3(\u03be \u2032)|+ 1)\u2212 |pos\u03c3(\u03be \u2032)|\n= |pos\u03b3(\u03be)| \u2212 |pos\u03c3(\u03be)|.\nIn a similar way we can prove that (3.21) holds for \u03be = \u03c3(\u03be\u2032).\nUsing Statement (3.21), we obtain for each \u03be \u2208 T\u03a3:\n[[A]]init(\u03be) =+ q\u2208Q hA(\u03be)q \u00b7 Fq = hA(\u03be)d = |pos\u03b3(\u03be)| \u2212 |pos\u03c3(\u03be)| = diffm(\u03be) .\nThus diffm \u2208 Recinit(\u03a3, Int)."
        },
        {
            "heading": "3.2. EXAMPLES 85",
            "text": "Example 3.2.15. (Length of zigzag-path.) Let \u03a3 = {\u03c3(2), \u03b1(0)} be a ranked alphabet. We define the mapping zigzag : T\u03a3 \u2192 N which, intuitively, computes for each tree the length of its zigzag-path (where \u201czig\u201d means \u201cgo to the left child\u201d, and \u201czag\u201d means \u201cgo to the right child\u201d). Formally, we first define the auxiliary mappings zzl : T\u03a3 \u2192 (N+)\u2217 and zzr : T\u03a3 \u2192 (N+)\u2217 by induction on T\u03a3 as follows. We let\nzzl(\u03b1) = zzr(\u03b1) = \u03b5,\nand, for each \u03be = \u03c3(\u03be1, \u03be2), we define\nzzl(\u03c3(\u03be1, \u03be2)) = 1 zzr(\u03be1) and zzr(\u03c3(\u03be1, \u03be2)) = 2 zzl(\u03be2) .\nThen we let\nzigzag : T\u03a3 \u2192 N with zigzag(\u03be) = |zzl(\u03be)| for each \u03be \u2208 T\u03a3 .\nFor instance, for \u03be = \u03c3(\u03c3(\u03b61, \u03b1), \u03b62) and any \u03b61, \u03b62 \u2208 T\u03a3, we have zigzag(\u03be) = |zzl(\u03be)| = |12| = 2.\nAs weight algebra we use the arctic semiring Natmax,+ = (N\u2212\u221e,max,+,\u2212\u221e, 0). Thus, the mapping zigzag is a (\u03a3,Natmax,+)-weighted tree language.\nWe construct the (\u03a3,Natmax,+)-wta A = (Q, \u03b4, F ) which i-recognizes zigzag as follows.\n\u2022 Q = {l, r, 0} (intuitively, l and r stand for \u201cleft\u201d and \u201cright\u201d, respectively, and 0 calculates the 0 \u2208 N), \u2022 \u03b40(\u03b5, \u03b1, l) = \u03b40(\u03b5, \u03b1, r) = \u03b40(\u03b5, \u03b1, 0) = 0 and for every q1, q2, q \u2208 Q\n\u03b42(q1q2, \u03c3, q) =    1 if q1q2q \u2208 {r0l, 0lr} 0 if q1q2q = 000 \u2212\u221e otherwise\n\u2022 Fl = 0, Fr = F0 = \u2212\u221e.\nClearly, A is root weight normalized; A is not bu deterministic. In Figure 3.13 we represent A as an fta-hypergraph.\nBy induction on T\u03a3, we can prove that the following statement holds:\nFor each \u03be \u2208 T\u03a3, we have hA(\u03be)l = |zzl(\u03be)|, hA(\u03be)r = |zzr(\u03be)|, and hA(\u03be)0 = 0 . (3.22)\nI.B.: Let \u03be = \u03b1. Then, for each q \u2208 Q, we have hA(\u03be)q = \u03b40(\u03b5, \u03b1, q) = 0 = |zzl(\u03be)| = |zzr(\u03be)|."
        },
        {
            "heading": "86 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA",
            "text": "I.S.: Now let \u03be = \u03c3(\u03be1, \u03be2) for some \u03be1, \u03be2 \u2208 T\u03a3. Then\nhA(\u03c3(\u03be1, \u03be2))l =max(hA(\u03be1)q1 + hA(\u03be)q2 + \u03b42(q1q2, \u03c3, l) | q1, q2 \u2208 Q)\n= hA(\u03be1)r + hA(\u03be2)0 + \u03b42(r0, \u03c3, l)\n= |zzr(\u03be1)|+ 0 + 1 (by I.H.)\n= |zzl(\u03c3(\u03be1, \u03be2))| .\nIn a similar way we can prove that hA(\u03c3(\u03be1, \u03be2))r = |zzr(\u03c3(\u03be1, \u03be2))|, and hA(\u03c3(\u03be1, \u03be2))0 = 0. This finishes the proof of Statement (3.22).\nNow let \u03be \u2208 T\u03a3. Then, using (3.22) at the fourth equality below, we obtain\n[[A]]init(\u03be) = max(hA(\u03be)q + Fq | q \u2208 Q) = hA(\u03be)l + Fl = hA(\u03be)l = |zzl(\u03be)| = zigzag(\u03be) .\nThus [[A]]init = zigzag and hence zigzag \u2208 Recinit(\u03a3,Natmax,+). In [DV06, Ex. 3.2] and [HMM07, Ex. 2], a (\u03a3,Nat)-wta N (over the semiring of natural numbers) is shown for which [[N ]]init = zigzag.\nExample 3.2.16. (Recognizable step mapping twothree.) Let \u03a3 = {\u03c3(2), \u03b3(1), \u03b1(0)} be a ranked alphabet. We define the mapping twothree : T\u03a3 \u2192 N for each \u03be \u2208 T\u03a3 by\ntwothree : T\u03a3 \u2192 N with twothree(\u03be) =\n{ 2 if |pos(\u03be)| is even\n3 otherwise for each \u03be \u2208 T\u03a3 .\nAs weight algebra we use the natural number semiring Nat = (N,+, \u00b7, 0, 1). Thus, the mapping twothree is a (\u03a3,Nat)-weighted tree language. Since the two \u03a3-tree languages\nLe = {\u03be \u2208 T\u03a3 | |pos(\u03be)| is even } and Lo = T\u03a3 \\ Le\nare recognizable, twothree is even a recognizable step mapping, because\ntwothree = (2 \u00b7 \u03c7Nat(Le) + 3 \u00b7 \u03c7Nat(Lo)) .\nWe construct the (\u03a3,Nat)-wta A = (Q, \u03b4, F ) which i-recognizes twothree as follows\n\u2022 Q = {e, o} where e and o stand for \u201ceven\u201d and \u201codd\u201d, respectively, \u2022 \u03b40(\u03b5, \u03b1, e) = 0 and \u03b40(\u03b5, \u03b1, o) = 1 and for every q1, q2, q \u2208 Q we let\n\u03b41(q1, \u03b3, q) =\n{ 1 if (q1 = e and q = o) or (q1 = o and q = e)\n0 otherwise,\n\u03b42(q1q2, \u03c3, q) =\n{ 1 if (q1 = q2 and q = o) or (q1 6= q2 and q = e)\n0 otherwise,\nand \u2022 Fe = 2 and Fo = 3.\nWe note that A is crisp deterministic and consequently also bu deterministic. Figure 3.14 shows the (\u03a3,Nat)-wta A.\nLet \u03be \u2208 T\u03a3 and q \u2208 Q. It is clear that\nhA(\u03be)q =\n{ 1 if ( (q = e and |pos(\u03be)| is even) or (q = o and |pos(\u03be)| is odd) )\n0 otherwise\n3.2. EXAMPLES 87\nThus\n[[A]]init(\u03be) =+ q\u2208Q (hA(\u03be)q \u00b7 Fq)\n= (hA(\u03be)e \u00b7 Fe) + (hA(\u03be)o \u00b7 Fo) = (hA(\u03be)e \u00b7 2) + (hA(\u03be)o \u00b7 3)\n= twothree(\u03be) .\nHence twothree \u2208 bud-Recinit(\u03a3,Nat).\nExample 3.2.17. (Evaluation algebras.) [FSV12, Lm. 4.3] Let (\u03bak | k \u2208 N) be an N-indexed family of mappings \u03bak : \u03a3\n(k) \u2192 B. We recall that B = (B,\u2295,\u2297, 0, 1) is a strong bimonoid, M(\u03a3, \u03ba) is the (\u03a3, \u03ba)-evaluation algebra and hM(\u03a3,\u03ba) : T\u03a3 \u2192 B is the unique \u03a3-algebra homomorphism, as defined in Subsection 2.10.2.\nWe construct the (\u03a3,B)-wta A = (Q, \u03b4, F ) which i-recognizes hM(\u03a3,\u03ba) as follows.\n\u2022 Q = {q} and Fq = 1 and \u2022 for every k \u2208 N, \u03c3 \u2208 \u03a3(k), we let \u03b4k(q \u00b7 \u00b7 \u00b7 q, \u03c3, q) = \u03bak(\u03c3).\nObviously, A is bu deterministic and root weight normalized. Moreover, if there exists a \u03c3 such that \u03bak(\u03c3) 6\u2208 {0, 1}, then A does not have identity transition weights and A is not crisp deterministic.\nIt is easy to see that the vector algebra V(A) = (BQ, \u03b4A) of A and the (\u03a3, \u03ba)-evaluation algebra M(\u03a3, \u03ba) = (B, \u03ba) are isomorphic \u03a3-algebras, by identifying each Q-vector over B with its one and only component in B, and by verifying that, for every b1, . . . , bk \u2208 B, we have\n\u03b4A(\u03c3)((b1), . . . , (bk))q = (\u2297\ni\u2208[k]\nbi ) \u2297 \u03b4k(q \u00b7 \u00b7 \u00b7 q, \u03c3, q) = (\u2297\ni\u2208[k]\nbi ) \u2297 \u03bak(\u03c3) = \u03ba(\u03c3)(b1, . . . , bk) .\nHence, for each \u03be \u2208 T\u03a3, we have hA(\u03be)q = hM(\u03a3,\u03ba)(\u03be). Then, for each \u03be \u2208 T\u03a3, we have\n[[A]]init(\u03be) = \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq = hA(\u03be)q = hM(\u03a3,\u03ba)(\u03be) ."
        },
        {
            "heading": "88 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA",
            "text": "Thus, in particular, hM(\u03a3,\u03ba) \u2208 bud-Rec init(\u03a3,B).\nAbove we have proved that, for each N-indexed family \u03ba = (\u03bak | k \u2208 N) of mappings \u03bak : \u03a3(k) \u2192 B, the \u03a3-algebra homomorphism hM(\u03a3,\u03ba) is i-recognizable by a bu deterministic (\u03a3,B)-wta. This can be used to show i-recognizability of the mappings size (cf. Example 3.2.3), yieldP (cf. Example 3.2.6), and BPSA (cf. Example 3.2.7) by instantiating B and providing N-indexed families of mappings appropriately.\n\u2022 We consider the tropical semiring Natmin,+ = (N\u221e,min,+,\u221e, 0) and the (\u03a3,Natmin,+)-weighted tree language\nsize : T\u03a3 \u2192 N\nof Example 3.2.3 with \u03a3 = {\u03c3(2), \u03b1(0)}. We define the N-indexed family \u03basize = (\u03basizek | k \u2208 N) of mappings by \u03basize0 (\u03b1) = \u03ba size 2 (\u03c3) = 1. Then size = hM(\u03a3,\u03basize).\n\u2022 We consider the ranked alphabet \u03a3 = {\u03c3(2), \u03b1(0), \u03b2(0)} and the formal language semiring Lang\u03a3 = (P(\u03a3\u2217),\u222a, \u00b7, \u2205, {\u03b5}) (where we forget about the rank of symbols). Moreover, we consider the (\u03a3, Lang\u03a3)-weighted tree language\nyieldP : T\u03a3 \u2192 P((\u03a3 (0))\u2217)\nof Example 3.2.6. We define the N-indexed family \u03bayield = (\u03bayieldk | k \u2208 N) of mappings by \u03bayield0 (\u03b1) = {\u03b1}, \u03ba yield 0 (\u03b2) = {\u03b2}, and \u03ba yield 2 (\u03c3) = {\u03b5}. Then yield P = hM(\u03a3,\u03bayield).\n\u2022 Let A = (Q, I, \u03b4, F ) be an {\u03b1, \u03b2}-fsa. We consider the near semiring NearSemP(Q) = (B,\u222a, \u22c4, \u2205, idP(Q)) with B = {f | f : P(Q) \u2192 P(Q), f(\u2205) = \u2205} and the (\u03a3,NearSemP(Q))-weighted tree language\nBPSA : T\u03a3 \u2192 P(Q) P(Q)\nof Example 3.2.7 with \u03a3 = {\u03c3(2), \u03b1(0), \u03b2(0)}. We define the N-indexed family \u03baBPS = (\u03baBPSk | k \u2208 N) of mappings such that, for each U \u2208 P(Q), we let\n\u2013 \u03baBPS0 (\u03b1)(U) = {p \u2208 Q | (\u2203r \u2208 U) : (r, \u03b1, p) \u2208 \u03b4}, \u2013 \u03baBPS0 (\u03b2)(U) = {p \u2208 Q | (\u2203r \u2208 U) : (r, \u03b2, p) \u2208 \u03b4}, and \u2013 \u03baBPS2 (\u03c3)(U) = U (i.e., \u03ba BPS 2 (\u03c3) = idP(Q)).\nThen BPSA = hM(\u03a3,\u03baBPS).\nExample 3.2.18. (\u03a3-algebra homomorphism.) Let \u03a3 be a ranked alphabet and B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid. Moreover, let B = (B, \u03b8) be a \u03a3-algebra such that there exists a family (b\u03c3,w | k \u2208 N, \u03c3 \u2208 \u03a3(k), w \u2208 {0, 1}k) over B and, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and b1, . . . , bk \u2208 B, the following holds:\n\u03b8(\u03c3)(b1, . . . , bk) = \u2295\nw\u2208{0,1}k\nbw11 \u2297 \u00b7 \u00b7 \u00b7 \u2297 b wk k \u2297 b\u03c3,w (3.23)\nwhere wi denotes the i-th symbol of w and b 0 i = 1 and b 1 i = bi. Thus \u03b8(\u03c3) is a polynomial over k noncommuting variables with degree at most 1. Let us denote by hB the unique \u03a3-algebra homomorphism from T\u03a3 to B.\nWe construct the (\u03a3,B)-wta A = (Q, \u03b4, F ) such that [[A]]init = hB, as follows. We let Q = {0, 1}, F0 = 0, and F1 = 1. Moreover, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and q1, . . . , qk, q \u2208 Q, we let\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) =    b\u03c3,q1\u00b7\u00b7\u00b7qk if q = 1 1 if q1 \u00b7 \u00b7 \u00b7 qkq = 0k+1\n0 otherwise\nBy induction on T\u03a3 we prove the following statement:\nFor each \u03be \u2208 T\u03a3, we have: hA(\u03be)1 = hB(\u03be) and hA(\u03be)0 = 1. (3.24)"
        },
        {
            "heading": "3.2. EXAMPLES 89",
            "text": "Let \u03be = \u03c3(\u03be1, . . . , \u03bek). Then we can calculate as follows:\nhA(\u03c3(\u03be1, . . . , \u03bek))1 = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nhA(\u03be1)q1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 hA(\u03bek)qk \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, 1)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nhA(\u03be1)q1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 hA(\u03bek)qk \u2297 b\u03c3,q1\u00b7\u00b7\u00b7qk (by construction)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nhB(\u03be1) q1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 hB(\u03bek) qk \u2297 b\u03c3,q1\u00b7\u00b7\u00b7qk (by I.H.)\n= \u03b8(\u03c3)(hB(\u03be1), . . . , hB(\u03bek)) (by definition of \u03b8)\n= hB(\u03c3(\u03be1, . . . , \u03bek)) . (because hB is a \u03a3-algebra homomorphism)\nMoreover we can calculate:\nhA(\u03c3(\u03be1, . . . , \u03bek))0 = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nhA(\u03be1)q1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 hA(\u03bek)qk \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, 0)\n= hA(\u03be1)0 \u2297 \u00b7 \u00b7 \u00b7 \u2297 hA(\u03bek)0 \u2297 1 (by construction)\n= 1\u2297 \u00b7 \u00b7 \u00b7 \u2297 1\u2297 1 = 1 . (by I.H.)\nThen, for each \u03be \u2208 T\u03a3, we have [[A]] init(\u03be) = \u2295 q\u2208Q hA(\u03be)q \u2297 Fq = hA(\u03be)1 = hB(\u03be).\nWe finish this example with three instances of this general scenario. Each instance results in a wta which we have already constructed in an ad hoc manner, viz., in Example 3.2.17 (evaluation algebras), in Example 3.2.4 (the mapping height : T\u03a3 \u2192 N), and in the proof of Lemma 3.1.5 (the computation of \u3008A\u3009{\u2295,\u2297,0,1}).\n1. Let (\u03bak | k \u2208 N) be an N-indexed family of mappings \u03bak : \u03a3(k) \u2192 B. We consider the (\u03a3, \u03ba)evaluation algebra M(\u03a3, \u03ba) = (B, \u03ba) and the unique \u03a3-algebra homomorphism hM(\u03a3,\u03ba) : T\u03a3 \u2192 B (cf. Subsection 2.10.2). We note that M(\u03a3, \u03ba) is a particular \u03a3-algebra.\nNow we define the family (b\u03c3,w | k \u2208 N, \u03c3 \u2208 \u03a3(k), w \u2208 {0, 1}k) over B such that b\u03c3,w = \u03bak(\u03c3) if w = 1k, and 0 otherwise, and we define the \u03a3-algebra B = (B, \u03b8) as in (3.23). Then, for every b1, . . . , bk \u2208 B, we have\n\u03ba(\u03c3)(b1, . . . , bk) = b1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 bk \u2297 \u03bak(\u03c3) = \u2295\nw\u2208{0,1}k\nbw11 \u2297 \u00b7 \u00b7 \u00b7 \u2297 b wk k \u2297 b\u03c3,w = \u03b8(\u03c3)(b1, . . . , bk) .\nHence \u03ba = \u03b8 and thus hM(\u03a3,\u03ba) = hB. Then, using the general scenario, we can construct a (\u03a3,B)-wta A such that [[A]]init = hM(\u03a3,\u03ba). In this sense, the construction of the current example subsumes the one given in Example 3.2.17 (where the state 1 corresponds to state q, and state 0 is superfluous).\n2. As strong bimonoid B we consider the semiring Natmax,+ = (N\u2212\u221e,max,+,\u2212\u221e, 0). Moreover, we extend the \u03a3-algebra (N, \u03b81) defined on page 43 to the \u03a3-algebra (N\u2212\u221e, \u03b8 \u2032 1) canonically as follows:\n\u2022 for each \u03b1 \u2208 \u03a3(0), we let \u03b8\u20321(\u03b1)() = 0, and \u2022 for every k \u2208 N+, \u03c3 \u2208 \u03a3(k), and n1, . . . , nk \u2208 N\u2212\u221e, we let \u03b8\u20321(\u03c3)(n1, . . . , nk) = 1 + max(n1, . . . , nk). Then the unique \u03a3-algebra homomorphism from T\u03a3 to (N\u2212\u221e, \u03b8 \u2032 1) is the mapping height : T\u03a3 \u2192 N. Now we define the family (b\u03c3,w | k \u2208 N, \u03c3 \u2208 \u03a3(k), w \u2208 {0, 1}k) over N\u2212\u221e such that b\u03c3,w = 1 if w contains exactly one occurrence of 1, and \u2212\u221e otherwise. Moreover, we define the \u03a3-algebra B = (N\u2212\u221e, \u03b8) as in (3.23). Then we have\n\u03b8\u20321(\u03c3)(n1, . . . , nk) = 1 +max(n1, . . . , nk) = max(n1 + 1, . . . , nk + 1)\n= max w\u2208{0,1}k\n(nw11 + \u00b7 \u00b7 \u00b7+ n wk k + b\u03c3,w) = \u03b8(\u03c3)(n1, . . . , nk) ."
        },
        {
            "heading": "90 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA",
            "text": "Hence \u03b8\u20321 = \u03b8 and thus height = hB. Then, using the general scenario, we can construct a (\u03a3,Natmax,+)-wta A such that [[A]]init = height. In fact, for \u03a3 = {\u03c3(2), \u03b1(0)}, this (\u03a3,Natmax,+)-wta A is the same as the one that we have constructed in Example 3.2.4.\n3. Here we wish to show that also the (\u03a3,B)-wta A constructed in the proof of Lemma 3.1.5 can be obtained as an application of our general scenario. For this, let A \u2286 B be a finite subset and \u03a3 a ranked alphabet such that |\u03a3(0)| \u2265 |A \u222a {0, 1}| and |\u03a3(2)| \u2265 2. Without loss of generality we can assume that {a(0) | a \u2208 A \u222a {0, 1}} \u2286 \u03a3(0) and {+(2),\u00d7(2)} \u2286 \u03a3(2). We let \u2206 be the ranked alphabet {a(0) | a \u2208 A \u222a {0, 1}} \u222a {+(2),\u00d7(2)}.\nMoreover, we define the family (b\u03c3,w | k \u2208 N, \u03c3 \u2208 \u03a3(k), w \u2208 {0, 1}k) over B such that\n\u2022 ba,\u03b5 = a for every a \u2208 A \u222a {0, 1}, \u2022 b+,01 = b+,10 = 1 and b+,00 = b+,11 = 0, \u2022 b\u00d7,11 = 1 and b\u00d7,00 = b\u00d7,10 = b\u00d7,01 = 0, and \u2022 for every k \u2208 N, \u03c3 \u2208 \u03a3(k) \\\u2206, and w \u2208 {0, 1}k, we define b\u03c3,w to be an arbitrary element of A \u222a {0, 1}.\nUsing this family, we define the \u03a3-algebra B = (B, \u03b8) as in (3.23). Then, in particular, the following properties hold:\n(P1) \u03b8(a)() = a for each a \u2208 A \u222a {0, 1}, (P2) \u03b8(+)(b1, b2) = b1 \u2295 b2 and \u03b8(\u00d7)(b1, b2) = b1 \u2297 b2 for every b1, b2 \u2208 B, and (P3) for every k \u2208 N, \u03c3 \u2208 \u03a3(k) \\\u2206, the set \u3008A\u3009{\u2295,\u2297,0,1} is closed under the operation \u03b8(\u03c3).\nLet us abbreviate \u3008A\u3009{\u2295,\u2297,0,1} by \u3008A\u3009. Next we show that im(hB) = \u3008A\u3009.\nThe inclusion im(hB) \u2286 \u3008A\u3009 follows from the definition of \u03a3-algebra homomorphism and properties (P1), (P2), and (P3) of the operations of B.\nAs preparation for the proof of the other inclusion, we consider the well-founded relation \u227a on \u3008A\u3009 which we defined in the proof of Lemma 3.1.5. By induction on (\u3008A\u3009,\u227a), we prove that the following statement holds:\nFor each a \u2208 \u3008A\u3009, there exists \u03be \u2208 T\u03a3 such that hB(\u03be) = a . (3.25)\nI.B.: Let a \u2208 A \u222a {0, 1}. Then with \u03be = a we have hB(\u03be) = \u03b8(a)( ) = a.\nI.S.: Now let a = a1 \u2295 a2. By the I.H., for each i \u2208 {1, 2}, there exists a \u03bei \u2208 T\u03a3 such that hB(\u03bei) = ai. We let \u03be = +(\u03be1, \u03be2). Then\nhB(\u03be) = hB(+(\u03be1, \u03be2)) = \u03b8(+)(hB(\u03be1), hB(\u03be2)) = \u03b8(+)(a1, a2)\n= a1 \u2295 a2 . (by property (P1))\nNext let a = a1 \u2297 a2. As before, for each i \u2208 {1, 2}, there exists a \u03bei \u2208 T\u03a3 such that hB(\u03bei) = ai. We can show that hB(\u03be) = a1 \u2297 a2 in a similar way as above. This proves (3.25).\nHence \u3008A\u3009 \u2286 im(hB) and thus \u3008A\u3009 = im(hB). By using our general scenario, we can construct a (\u03a3,B)-wta A such that [[A]]init = hB. Thus, in particular, im([[A]]init) = \u3008A\u3009. In fact, this (\u03a3,B)-wta A is the same as the one which we have constructed in the proof of Lemma 3.1.5."
        },
        {
            "heading": "3.3 Weighted string automata",
            "text": "In this section we recall the concept of weighted string automata [Sch61, Eil74] and show that, essentially, they are equivalent to wta over string ranked alphabets (cf. [FV09, p. 324]). Moreover, we show that they generalize fsa."
        },
        {
            "heading": "3.3. WEIGHTED STRING AUTOMATA 91",
            "text": "A weighted string automaton (over \u0393 and B) (for short: (\u0393,B)-wsa or wsa) is a tuple A = (Q, \u03bb, \u00b5, \u03b3), where Q is a finite nonempty set of states such that Q\u2229 \u0393 = \u2205, \u00b5 : \u0393\u2192 BQ\u00d7Q is the transition mapping, and \u03bb, \u03b3 \u2208 BQ are the initial weight mapping and the final weight mapping, respectively. We define the run semantics and the initial algebra semantics for A as follows.\nRun semantics. Let w = a1 \u00b7 \u00b7 \u00b7 an be a string in \u0393\u2217 with n \u2208 N. A run of A on w is a string \u03c1 \u2208 Qn+1. Let \u03c1 = q0 \u00b7 \u00b7 \u00b7 qn with qi \u2208 Q for each i \u2208 [0, n]. The weight of \u03c1 for w, denoted by wtA(w, \u03c1), is the element of B defined by\nwtA(w, \u03c1) = \u03bbq0 \u2297 wt \u2212 A(w, \u03c1) \u2297 \u03b3qn\nwhere wt\u2212A(w, \u03c1) = \u00b5(a1)q0,q1 \u2297 . . .\u2297 \u00b5(an)qn\u22121,qn . Thus, in particular, we have that wt\u2212A(\u03b5, \u03c1) = 1 and wtA(\u03b5, \u03c1) = \u03bbq0 \u2297 \u03b3q0 .\nThe run semantics of A is the weighted language [[A]]run : \u0393\u2217 \u2192 B defined by\n[[A]]run(w) = \u2295\n\u03c1\u2208Q|w|+1\nwtA(w, \u03c1)\nfor every w \u2208 \u0393\u2217. In particular, [[A]]run(\u03b5) = \u2295\nq\u2208Q \u03bbq \u2297 \u03b3q.\nA weighted language r : \u0393\u2217 \u2192 B is run recognizable (over B) (for short: r-recognizable) if there exists a (\u0393,B)-wsa A such that r = [[A]]run.\nInitial algebra semantics. Let e 6\u2208 \u0393. For the definition of the initial algebra semantics, we use the string ranked alphabet \u0393e and the \u0393e-algebra (\u0393\n\u2217, \u0393\u0302e) defined in Paragraph \u201cString-like terms\u201d of Section 2.9.\nAlso, we define the \u0393e-algebra (B Q, \u03b8) with\n\u03b8(e)() = \u03bb and \u03b8(a)(v) = v \u00b7 \u00b5(a) (vector-matrix product, see Section 2.7)\nfor every v \u2208 BQ and a \u2208 \u0393. By (2.24), (\u0393\u2217, \u0393\u0302e) is initial, hence there exists a unique \u0393e-algebra homomorphism from (\u0393\u2217, \u0393\u0302e) to (B Q, \u03b8). Let us denote this by hA. Then the initial algebra semantics of A is the weighted language [[A]]init : \u0393\u2217 \u2192 B defined by\n[[A]]init(w) = \u2295\nq\u2208Q\nhA(w)q \u2297 \u03b3q\nfor every w \u2208 \u0393\u2217. We note that, using another nullary symbol e\u2032 instead of e, leads to the same weighted language [[A]]init.\nA weighted language r : \u0393\u2217 \u2192 B is initial algebra recognizable (over B) (for short: i-recognizable) if there exists a (\u0393,B)-wsa A such that r = [[A]]init.\nThe next lemma shows the connection of the initial algebra semantics of A to its behaviour semantics as defined in [Eil74, VI.6], if B is a semiring (also cf. [Sch61, Def. 1\u2019]). We recall that, under this assumption, the matrix multiplication is associative, and hence (BQ\u00d7Q, \u00b7,M1) is a monoid (cf. Section 2.7). Then \u00b5 : \u0393\u2217 \u2192 BQ\u00d7Q is a monoid homomorphism from (\u0393\u2217, \u00b7, \u03b5) to (BQ\u00d7Q, \u00b7,M1).\nLemma 3.3.1. Let B be a semiring and w \u2208 \u0393\u2217. Then hA(w) = \u03bb \u00b7\u00b5(w). Hence [[A]]init(w) = \u03bb \u00b7\u00b5(w) \u00b7 \u03b3.\nProof. Let w \u2208 \u0393\u2217. We consider the well-founded set (prefix(w),\u227a) where, for every w1, w2 \u2208 prefix(w), we let w1 \u227a w2 if w1a = w2 for some a \u2208 \u0393. Obviously, \u227a is well-founded and min\u227a(prefix(w)) = {\u03b5}.\nBy induction on (prefix(w),\u227a), we prove that the following statement holds:\nFor every v \u2208 prefix(w), we have hA(v) = \u03bb \u00b7 \u00b5(v) . (3.26)"
        },
        {
            "heading": "92 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA",
            "text": "Let v \u2208 prefix(w).\nI.B.: Let v = \u03b5. Then we can calculate as follows.\nhA(\u03b5) = hA(e\u0302()) (interpretation of e in the \u0393e-algebra (\u0393 \u2217, \u0393\u0302e))\n= \u03b8(e)() (hA is a \u0393e-algebra homomorphism)\n= \u03bb . (interpretation of e in the \u0393e-algebra (B Q, \u03b8))\nI.S.: Let v = v\u2032a for some a \u2208 \u0393. Then we can calculate as follows.\nhA(v \u2032a) = hA(a\u0302(v \u2032)) (interpretation of a in the \u0393e-algebra (\u0393 \u2217, \u0393\u0302e))\n= \u03b8(a)(hA(v \u2032)) (hA is a \u0393e-algebra homomorphism) = \u03b8(a)(\u03bb \u00b7 \u00b5(v\u2032)) (by I.H.)\n= \u03bb \u00b7 \u00b5(v\u2032) \u00b7 \u00b5(a) (interpretation of a in the \u0393e-algebra (BQ, \u03b8)) = \u03bb \u00b7 \u00b5(v\u2032a) . (because \u00b5 is a monoid homomorphism)\nThis proves (3.26). Since w \u2208 prefix(w), Equation (3.26) implies the first statement of the lemma. Finally\n[[A]]init(w) = \u2295\nq\u2208Q\nhA(w)q \u2297 \u03b3q = \u2295\nq\u2208Q\n(\u03bb \u00b7 \u00b5(w))q \u2297 \u03b3q = \u03bb \u00b7 \u00b5(w) \u00b7 \u03b3 .\nEmbedding of wsa into wta. Now let A = (Q, \u03bb, \u00b5, \u03b3) be a (\u0393,B)-wsa, \u03a3 a string ranked alphabet, and B = (Q\u2032, \u03b4, F ) a (\u03a3,B)-wta. We say that A and B are related if\n\u2022 \u03a3 = \u0393e for some e 6\u2208 \u0393, \u2022 Q = Q\u2032, \u2022 for every a \u2208 \u03a3(1) and p, q \u2208 Q, we have \u03b40(\u03b5, e, q) = \u03bbq, and \u03b41(p, a, q) = \u00b5(a)p,q, and \u2022 F = \u03b3.\nFor the proof of the next lemma, we recall that treee is an isomorphism from the \u0393e-algebra (\u0393 \u2217, \u0393\u0302e)\nto the \u0393e-term algebra (T\u0393e , \u03b8\u0393e), cf. Paragraph \u201cString-like terms\u201d in Section 2.9.\nLemma 3.3.2. Let \u03a3 be a string ranked alphabet, A = (Q, \u03bb, \u00b5, \u03b3) a (\u0393,B)-wsa, and B = (Q\u2032, \u03b4, F ) a (\u03a3,B)-wta. If A and B are related, then [[A]]run = [[B]]run \u25e6 treee and [[A]]init = [[B]]init \u25e6 treee, where e denotes the unique nullary element of \u03a3.\nProof. To show that [[A]]run = [[B]]run \u25e6 treee, let w \u2208 \u0393\u2217 with w = a1 \u00b7 \u00b7 \u00b7 an for some n \u2208 N. It is obvious that there exists a bijection 7\u2192 between Q|w|+1 and RB(treee(w)) such that, for \u03c1 = q0 \u00b7 \u00b7 \u00b7 qn, we have \u03c1 7\u2192 \u03c1\u2032, where \u03c1\u2032(1i) = qn\u2212i for every i \u2208 [0, n] (note that pos(treee(w)) = {1i | i \u2208 [0, n]}). Moreover, if \u03c1 7\u2192 \u03c1\u2032, then due to Observation 3.1.1 we also have\nwtA(w, \u03c1) = wtB(treee(w), \u03c1 \u2032)\u2297 Fqn ,\nwhere wtB(treee(w), \u03c1 \u2032) denotes the weight of \u03c1\u2032 on treee(w) for B. Then\n[[A]]run(w) = \u2295\n\u03c1\u2208Q|w|+1\nwtA(w, \u03c1) = \u2295\n\u03c1\u2032\u2208RB(treee(w))\nwtB(treee(w), \u03c1 \u2032)\u2297 F\u03c1\u2032(\u03b5) = [[B]] run(treee(w)),\nwhere the second equality follows from the bijection 7\u2192 described above and the fact that \u03c1\u2032(\u03b5) = qn.\nNow we show that [[A]]init = [[B]]init \u25e6 treee. Since treee : \u0393\u2217 \u2192 T\u0393e and hB : T\u0393e \u2192 B Q are \u0393ealgebra homomorphisms, it follows from Theorem 2.6.3 that (hB \u25e6 treee) : \u0393\u2217 \u2192 BQ is a \u0393e-algebra homomorphism. Since hA is the unique \u0393e-algebra homomorphism from (\u0393 \u2217, \u0393\u0302e) to (B\nQ, \u03b8), we have hA = hB \u25e6 treee."
        },
        {
            "heading": "3.4. WEIGHTED TREE AUTOMATA OVER THE BOOLEAN SEMIRING 93",
            "text": "Then we obtain\n[[A]]init(w) = \u2295\nq\u2208Q\nhA(w)q \u2297 \u03b3q = \u2295\nq\u2208Q\u2032\nhB(treee(w))q \u2297 Fq = [[B]] init(treee(w)) .\nLemma 3.3.3. Let \u0393 be an alphabet and B be a strong bimonoid. Then the following two statements hold. (1) For every (\u0393,B)-wsa A and e 6\u2208 \u0393, we can construct a (\u0393e,B)-wta B such that [[A]]\nrun = [[B]]run\u25e6treee and [[A]]init = [[B]]init \u25e6 treee. (2) For every string ranked alphabet \u0393e and (\u0393e,B)-wta B, we can construct a (\u0393,B)-wsa A such that [[A]]run = [[B]]run \u25e6 treee and [[A]] init = [[B]]init \u25e6 treee.\nProof. First we prove Statement (1). For a given (\u0393,B)-wsa A, it is easy to construct a (\u0393e,B)-wta B such that A and B are related. Then the statement follows from Lemma 3.3.2. Statement (2) follows analogously.\nWeighted string automata over the Boolean semiring. Let A = (Q, \u03bb, \u00b5, \u03b3) be a (\u0393,Boole)-wsa and A = (Q, I, \u03b4, F ) be a \u0393-fsa. We say that A and A are related if I = supp(\u03bb), F = supp(\u03b3), and for every a \u2208 \u0393 and q, q\u2032 \u2208 Q we have: \u00b5(a)q,q\u2032 = 1 iff (q, a, q\u2032) \u2208 \u03b4.\nIt is easy to see that, if A and A are related, then supp([[A]]run) = L(A). Moreover, for each (\u0393,Boole)wsa, we can construct a \u0393-fsa A such that A and A are related; and vice versa, for each \u0393-fsa A, we can construct a (\u0393,Boole)-wsa A such that A and A are related. Thus we obtain the following equivalence between \u0393-fsa and (\u0393,Boole)-wsa.\nObservation 3.3.4. Let L \u2286 \u0393\u2217. Then the following two statements are equivalent.\n(A) We can construct a \u0393-fsa A such that L = L(A). (B) We can construct a (\u0393,Boole)-wsa A such that L = supp([[A]]run)."
        },
        {
            "heading": "3.4 Weighted tree automata over the Boolean semiring",
            "text": "Here we prove that every wta over the Boolean semiring Boole = (B,\u2228,\u2227, 0, 1) is essentially an fta, and vice versa.\nLet A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. The support fta of A, denoted by suppB(A), is the \u03a3-fta (Q, \u03b4 \u2032, F \u2032) where for every k \u2208 N we have \u03b4\u2032k = suppB(\u03b4k) and F \u2032 = suppB(F ). If B is clear from the context, then we drop B from suppB.\nTheorem 3.4.1. Let A be (\u03a3,Boole)-wta. Then supp([[A]]init) = supp([[A]]run) = L(supp(A)). Thus [[A]]init = [[A]]run.\nProof. Let A = (Q, \u03b4, F ) and supp(A) = (Q, \u03b4\u2032, F \u2032). We recall that L(supp(A)) = Li(supp(A)) = Lr(supp(A)), cf. Lemma 2.13.1.\nFirst we prove supp([[A]]init) = Li(supp(A)). By induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and q \u2208 Q: hA(\u03be)q 6= 0 iff q \u2208 hsupp(A)(\u03be) . (3.27)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek).\nhA(\u03be)q 6= 0\niff ( \u2228\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nhA(\u03be1)q1 \u2227 . . . \u2227 hA(\u03bek)qk \u2227 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) ) 6= 0"
        },
        {
            "heading": "94 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA",
            "text": "iff (\u2217)(\u2203q1 \u00b7 \u00b7 \u00b7 qk \u2208 Q k) : (hA(\u03be1)q1 6= 0) \u2227 . . . \u2227 (hA(\u03bek)qk 6= 0) \u2227 (\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) 6= 0)\niff (\u2203q1 \u00b7 \u00b7 \u00b7 qk \u2208 Q k) : (q1 \u2208 hsupp(A)(\u03be1)) \u2227 . . . \u2227 (qk \u2208 hsupp(A)(\u03bek)) \u2227 ((q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) \u2208 \u03b4 \u2032 k)) (by I.H.)\niff q \u2208 hsupp(A)(\u03be) .\nAt the implication from right to left of equivalence (\u2217), we have used the fact that the Boolean semiring is positive, i.e., zero-divisor free and zero-sum free. This proves (3.27).\nThen, for each \u03be \u2208 T\u03a3, we can argue as follows:\n\u03be \u2208 supp([[A]]init) iff ( \u2228\nq\u2208Q\nhA(\u03be)q \u2227 Fq ) 6= 0 iff ( \u2228\nq\u2208F \u2032\nhA(\u03be)q\n) 6= 0\niff (\u2217\u2217)(\u2203q \u2208 F \u2032) : hA(\u03be)q 6= 0 iff (\u2203q \u2208 F \u2032) : q \u2208 hsupp(A)(\u03be) iff \u03be \u2208 Li(supp(A))\nwhere the implication from right to left at equivalence (\u2217\u2217) uses the fact that Boole is zero-sum free; the last but one equivalence is due to (3.27). This proves supp([[A]]init) = Li(supp(A)).\nNext we prove that supp([[A]]run) = Lr(supp(A)). We note that RA(\u03be) = Rsupp(A)(\u03be) for every \u03be \u2208 T\u03a3. First, by induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be): wtA(\u03be, \u03c1) 6= 0 iff \u03c1 \u2208 R v supp(A)(\u03be) . (3.28)\nWe let \u03be = \u03c3(\u03be1, . . . , \u03bek). Then\nwtA(\u03be, \u03c1) 6= 0 iff (wtA(\u03be1, \u03c1|1) \u2227 . . . \u2227 wtA(\u03bek, \u03c1|k) \u2227 \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5))) 6= 0\niff (\u2217\u2217\u2217) (wtA(\u03be1, \u03c1|1) 6= 0) \u2227 . . . \u2227 (wtA(\u03bek, \u03c1|k) 6= 0) \u2227 (\u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)) 6= 0)\niff (\u03c1|1 \u2208 R v supp(A)(\u03be1)) \u2227 . . . \u2227 (\u03c1|k \u2208 R v supp(A)(\u03bek)) \u2227 ((\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)) \u2208 \u03b4 \u2032 k) (by I.H.) iff \u03c1 \u2208 Rvsupp(A)(\u03be)\nwhere at (\u2217 \u2217 \u2217) from right to left we have used the fact that Boole is zero-divisor free. This proves (3.28).\nNow let \u03be \u2208 T\u03a3. Then\n\u03be \u2208 supp([[A]]run) iff ( \u2228\nq\u2208Q\n\u2228\n\u03c1\u2208RA(q,\u03be)\nwtA(\u03be, \u03c1) \u2227 Fq ) 6= 0\niff ( \u2228\nq\u2208F \u2032\n\u2228\n\u03c1\u2208RA(q,\u03be)\nwtA(\u03be, \u03c1) ) 6= 0\niff (v\u2217)(\u2203q \u2208 F \u2032)(\u2203\u03c1 \u2208 RA(q, \u03be)) : wtA(\u03be, \u03c1) 6= 0\niff (\u2203q \u2208 F \u2032)(\u2203\u03c1 \u2208 Rsupp(A)(q, \u03be)) : \u03c1 \u2208 R v supp(A)(\u03be) iff \u03be \u2208 Lr(supp(A))\nwhere at (v\u2217) from right to left we have used the fact that Boole is zero-sum free; the last but one equivalence is due to (3.28). This proves supp([[A]]run) = Lr(supp(A)).\nFinally we have [[A]]init = \u03c7(supp([[A]]init)) = \u03c7(supp([[A]]run)) = [[A]]run.\nIn Lemma 18.2.3(1) we will generalize the first statement of Theorem 3.4.1 from the Boolean semiring Boole to arbitrary positive strong bimonoids. In Theorem 5.3.2 we will generalize the second statement of Theorem 3.4.1 from Boole to arbitrary semirings.\nCorollary 3.4.2. Let \u03a3 be a ranked alphabet and L \u2286 T\u03a3. Then the following three statements are equivalent. (A) We can construct a \u03a3-fta A such L = L(A). (B) We can construct a (\u03a3,Boole)-wta A such that L = supp([[A]]run) = supp([[A]]init). (C) We can construct a (\u03a3,Boole)-wta A such that \u03c7(L) = [[A]]run = [[A]]init. Moreover, we have supp(Recinit(\u03a3,Boole)) = supp(Recrun(\u03a3,Boole)) = Rec(\u03a3)."
        },
        {
            "heading": "3.5. WEIGHTED TREE AUTOMATA OVER THE SEMIRING OF NATURAL NUMBERS 95",
            "text": "Proof. Proof of (A)\u21d2(B): Let A = (Q, \u03b4, F ) be a \u03a3-fta such that L = L(A). We construct the (\u03a3,Boole)wta A = (Q, \u03b4\u2032, F \u2032) such that supp(\u03b4\u2032k) = \u03b4k for each k \u2208 N, and supp(F\n\u2032) = F (note that this determines \u03b4\u2032 and F \u2032 because B = {0, 1}). Then A = supp(A) and by Theorem 3.4.1 we obtain L(A) = L(supp(A)) = supp([[A]]run) = supp([[A]]init).\nProof of (B)\u21d2(A): Let (\u03a3,Boole)-wta A such that L = supp([[A]]run) = supp([[A]]init). Then, we construct the \u03a3-fta supp(A), and by Theorem 3.4.1, we have that L(supp(A)) = supp([[A]]run) = supp([[A]]init).\nProof of (B)\u21d4(C): This follows from the equivalence that for every r : T\u03a3 \u2192 B and L \u2286 T\u03a3: r = \u03c7(L) iff L = supp(r).\nFinally, the equality supp(Recinit(\u03a3,Boole)) = supp(Recrun(\u03a3,Boole)) follows from Theorem 3.4.1; and the equality Rec(\u03a3) = supp(Recrun(\u03a3,Boole)) follows from (A)\u21d4(B)."
        },
        {
            "heading": "3.5 Weighted tree automata over the semiring of natural num-",
            "text": "bers\nIn this section we will consider the semiring Nat = (N,+, \u00b7, 0, 1) of natural numbers as weight algebra. In [Eil74, Thm. 9.1] it was proved that, for every alphabet \u0393 and (\u0393,Nat)-wsaA, there exists an unambiguous (\u0393,Nat)-wsa B such that [[A]]run = [[B]]run. There, unambiguous means that each transition weight and each initial and final weight are elements of {0, 1}. For wta, we call the corresponding property \u201cB has identity transition weights and identity root weights\u201d. Here we generalize Eilenberg\u2019s result to wta. However, since we will discuss normal forms of wta only later, we have to start with a (\u03a3,Nat)-wta A which has identity root weights.\nLemma 3.5.1. (cf. [Eil74, Thm. 9.1]) For each (\u03a3,Nat)-wta A which has identity root weights, we can construct a (\u03a3,Nat)-wta B such that B has identity transition weights and identity root weights and [[A]]init = [[B]]init.\nProof. Let A = (Q, \u03b4, F ). Let m = max(wts(A)). If m = 0, then let B = A. Otherwise, we construct B = (Q\u2032, \u03b4\u2032, F \u2032) according to the following idea. We supply B with m copies of each state of A; a copy is a pair (q, \u2113) with q \u2208 Q and \u2113 \u2208 [m]. If \u03c4 = (q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) is a transition of A and (q1, \u21131), . . . , (qk, \u2113k) are copies of q1, . . . , qk, then B simulates the weight \u03b4k(\u03c4) by nondeterministically branching from (q1, \u21131), . . . , (qk, \u2113k) while reading \u03c3 into (q, 1), . . . , (q, \u03b4k(\u03c4)), and each of these transitions has weight 1. Formally, we let:\n\u2022 Q\u2032 = Q\u00d7 [m], \u2022 for each (q, \u2113) \u2208 Q\u2032, we define F \u2032(q,\u2113) = Fq, \u2022 for every k \u2208 N, \u03c3 \u2208 \u03a3(k), (q1, \u21131), . . . , (qk, \u2113k), (q, \u2113) \u2208 Q\u2032, we define\n(\u03b4\u2032)k((q1, \u21131) \u00b7 \u00b7 \u00b7 (qk, \u2113k), \u03c3, (q, \u2113)) =\n{ 1 if \u2113 \u2208 [\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)]\n0 otherwise .\nBy induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and q \u2208 Q, we have: hA(\u03be)q =+ \u2113\u2208[m] hB(\u03be)(q,\u2113) . (3.29)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). Then we can calculate as follows.\nhA(\u03c3(\u03be1, . . . , \u03bek))q\n= + q1,...,qk\u2208Q hA(\u03be1)q1 \u00b7 . . . \u00b7 hA(\u03bek)qk \u00b7 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n96 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA\n= + q1,...,qk\u2208Q ( + \u21131\u2208[m] hB(\u03be1)(q1,\u21131) ) \u00b7 . . . \u00b7 ( + \u2113k\u2208[m] hB(\u03bek)(qk,\u2113k) ) \u00b7 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) (by I.H.)\n= + (q1,\u21131),...,(qk,\u2113k)\u2208Q\u2032 hB(\u03be1)(q1,\u21131) \u00b7 . . . \u00b7 hB(\u03bek)(qk,\u2113k) \u00b7 ( + \u2113\u2208[m] (\u03b4\u2032)k((q1, \u21131) \u00b7 \u00b7 \u00b7 (qk, \u2113k), \u03c3, (q, \u2113)) )\n(by right-distributivity and construction)\n=+ \u2113\u2208[m] + (q1,\u21131),...,(qk,\u2113k)\u2208Q\u2032 hB(\u03be1)(q1,\u21131) \u00b7 . . . \u00b7 hB(\u03bek)(qk,\u2113k) \u00b7 (\u03b4 \u2032)k((q1, \u21131) \u00b7 \u00b7 \u00b7 (qk, \u2113k), \u03c3, (q, \u2113))\n(by left-distributivity)\n=+ \u2113\u2208[m] hB(\u03c3(\u03be1, . . . , \u03bek))(q,\u2113)\nNow let \u03be \u2208 T\u03a3. Then we can calculate as follows.\n[[A]]init(\u03be) =+ q\u2208Q hA(\u03be)q \u00b7 Fq\n=+ q\u2208Q ( + \u2113\u2208[m] hB(\u03be)(q,\u2113) ) \u00b7 Fq (by (3.29))\n=+ q\u2208Q + \u2113\u2208[m] hB(\u03be)(q,\u2113) \u00b7 Fq (because Fq \u2208 {0, 1})\n= + (q,\u2113)\u2208Q\u2032 hB(\u03be)(q,\u2113) \u00b7 (F \u2032)(q,\u2113) (by construction)\n= [[B]]init(\u03be) .\nAssuming that Theorem 5.3.2 and the normal form theorem Theorem 7.3.1 are already available, Lemma 3.5.1 implies the following corollary. We note that the proofs of the Theorems 5.3.2 and 7.3.1 do not depend on Corollary 3.5.2.\nCorollary 3.5.2. For each (\u03a3,Nat)-wta A, we can construct a (\u03a3,Nat)-wta B such that B has identity transition weights and identity root weights and [[A]]init = [[B]]init.\nProof. Let A be a (\u03a3,Nat)-wta. By Theorem 5.3.2 we have [[A]]init = [[A]]run. By Theorem 7.3.1 we can construct a root weight normalized (\u03a3,Nat)-wta C such that [[A]]run = [[C]]run. By Theorem 5.3.2 we have [[C]]run = [[C]]init. Then, by Lemma 3.5.1 we can construct a (\u03a3,Nat)-wta B such that B has identity transition weights and identity root weights and [[C]]init = [[B]]init.\nNext we define the characteristic wta of a \u03a3-fta A. For this, let A = (Q, \u03b4, F ) be a \u03a3-fta. The characteristic wta of A, denoted by \u03c7Nat(A), is the (\u03a3,Nat)-wta (Q, \u03b4\n\u2032, F \u2032) where for every k \u2208 Nat we have \u03b4\u2032k = \u03c7Nat(\u03b4k) and F\n\u2032 = \u03c7Nat(F ). Note that \u03c7Nat(A) has identity transition weights and identity root weights.\nThe characteristic wta is the \u201cinverse\u201d of the support fta in the following sense. For each (\u03a3,Nat)-wta A with identity transition weights and identity root weights, we have \u03c7Nat(supp(A)) = A. Moreover, for each \u03a3-fta A, we have supp(\u03c7Nat(A)) = A.\nWe recall that, for a \u03a3-fta A, we denote by RaA(\u03be) the set of accepting runs of A on a tree \u03be. Moreover, we recall that the multiplicity mapping of A is defined as the weighted tree language #Ra\nA : T\u03a3 \u2192 N such\nthat, for each \u03be \u2208 T\u03a3, we have #Ra A (\u03be) = |RaA(\u03be)| (cf Example 3.2.1).\nIn Example 3.2.1 we have proved the following result.\nLemma 3.5.3. For each \u03a3-fta A, we have [[\u03c7Nat(A)]] init = #Ra\nA ."
        },
        {
            "heading": "3.6. WEIGHTED TREE AUTOMATA OVER COMMUTATIVE SEMIRINGS 97",
            "text": "We also have the following kind of inverse result.\nLemma 3.5.4. Let A be a (\u03a3,Nat)-wta which has identity transition weights and identity root weights. Then [[A]]init = #Ra\nsupp(A) .\nProof. This follows from the fact that A = \u03c7Nat(supp(A)) and from Lemma 3.5.3.\nFor example, the (\u03a3,Nat)-wta A in Example 3.2.11 has identity transition weights and identity root weights. Since [[A]]init = #\u03c3(.,\u03b1), it follows from Lemma 3.5.4 that #\u03c3(.,\u03b1) = #Rasupp(A) .\nWe can conclude the following characterization of Recinit(\u03a3,Nat), which says that the i-recognizable (\u03a3,Nat)-weighted tree languages are exactly the multiplicity mappings of \u03a3-fta.\nTheorem 3.5.5. Let \u03a3 be a ranked alphabet and r : T\u03a3 \u2192 N. Then the following three statements are equivalent. (A) We can construct a (\u03a3,Nat)-wta A such that r = [[A]]init. (B) We can construct a (\u03a3,Nat)-wta A which has identity transition weights and identity root weights\nsuch that r = [[A]]init. (C) We can construct a \u03a3-fta A such that r = #Ra\nA .\nProof. (A)\u21d2(B) follows from Corollary 3.5.2 and (B)\u21d2(A) is obvious. (B)\u21d2(C) follows from Lemma 3.5.4 and (C)\u21d2(B) follows from Lemma 3.5.3.\nIt will turn out later (cf. Theorem 5.3.2) that [[A]]init = [[A]]run for each (\u03a3,Nat)-wta. Hence, Theorem 3.5.5 also shows a characterization of Recrun(\u03a3,Nat).\nFinally, we show that, for each (\u03a3,Nat)-wta A and \u03be \u2208 T\u03a3, the value [[A]]run(\u03be) is bounded exponentially by size(\u03be).\nLemma 3.5.6. Let A = (Q, \u03b4, F ) be a (\u03a3,Nat)-wta. There exists K \u2208 N such that, for each \u03be \u2208 T\u03a3, we have [[A]]run(\u03be) \u2264 Ksize(\u03be).\nProof. Let m = max(wts(A)) and K = |Q| \u00b7m2. Obviously, for each \u03be \u2208 T\u03a3, the number of runs on \u03be is |Q|size(\u03be). Moreover, for each \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be), we have wt(\u03be, \u03c1) \u2264 msize(\u03be). Then\n[[A]]run(\u03be) = + \u03c1\u2208RA(\u03be) wt(\u03be, \u03c1) \u00b7 F\u03c1(\u03b5) \u2264 + \u03c1\u2208RA(\u03be) msize(\u03be)+1 = |Q|size(\u03be) \u00b7msize(\u03be)+1 \u2264 Ksize(\u03be) ."
        },
        {
            "heading": "3.6 Weighted tree automata over commutative semirings",
            "text": "In the particular case that B is a commutative semiring, we can view each (\u03a3,B)-wta as a B-semimodule with multilinear operations and a linear form. The latter combination will be called multilinear representation (cf. [BR82, BA89, Boz91, FS11]). Also, vice versa, each multilinear representation can be viewed as a wta. In the next subsections we will formalize these informal statements. We will use notions from Sections 2.7 and 2.8.\nIn the rest of this section, we let B denote an arbitrary commutative semiring."
        },
        {
            "heading": "98 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA",
            "text": ""
        },
        {
            "heading": "3.6.1 Multilinear representations",
            "text": "Let Q be a finite set. We recall that 0Q is the Q-vector in B Q which contains 0 in each component, and that 1q is the q-unit vector in B Q for each q \u2208 Q (cf. Section 2.7). We start this subsection with an important observation.\nObservation 3.6.1. For each finite set Q, the triple (BQ,+, 0Q) is a B-semimodule via scalar multiplication.\nProof. Obviously, (BQ,+, 0Q) is a commutative monoid. Also the properties (2.18)-(2.22) are satisfied, where (2.19) and (2.20) require that B is distributive. Hence (BQ,+, 0Q) is a B-semimodule.\nA (\u03a3,B)-multilinear representation4 is a tuple (V, \u00b5, \u03b3) where\n\u2022 V = (BQ,+, 0Q) for some finite set Q, \u2022 (BQ, \u00b5) is a \u03a3-algebra such that \u00b5(\u03c3) \u2208 L(Vk,V) for each k-ary \u03c3, i.e., \u00b5(\u03c3) is a k-ary multilinear operation over V, and \u2022 \u03b3 : BQ \u2192 B is a linear form over V (cf. Section 2.8).\nWe call (BQ, \u00b5) the \u03a3-algebra associated with (V, \u00b5, \u03b3), and denote the unique \u03a3-algebra homomorphism from T\u03a3 to (B\nQ, \u00b5) by hV. The weighted tree language recognized by (V, \u00b5, \u03b3) is the weighted tree language r : T\u03a3 \u2192 B where r(\u03be) = \u03b3(hV(\u03be)) for every \u03be \u2208 T\u03a3.\nBefore showing an example of a multilinear representation, we prove a useful lemma. For this, we note that the algebra (BT\u03a3 ,\u2295, 0\u0303) is a B-semimodule via \u2297, i.e., scalar multiplication from left.\nLemma 3.6.2. (cf. [BR82, Prop. 3.1]) The set of weighted tree languages which are recognizable by (\u03a3,B)-multilinear representations is a sub-semimodule of the B-semimodule (BT\u03a3 ,\u2295, 0\u0303).\nProof. We show that the subset of BT\u03a3 which consists of all weighted tree languages which are recognizable by (\u03a3,B)-multilinear representations is closed under (a) scalar multiplication from left and (b) under sum.\n(a) Let r \u2208 BT\u03a3 and b \u2208 B and assume that r is recognized by the (\u03a3,B)-multilinear representation (V, \u00b5, \u03b3) with V = (BQ,+, 0Q). Then the (\u03a3,B)-weighted tree language b \u2297 r is recognizable by the (\u03a3,B)-multilinear representation (V, \u00b5, \u03b3\u2032), where \u03b3\u2032(v) = b\u2297 \u03b3(v) for each v \u2208 V .\n(b) Let r1, r2 \u2208 B T\u03a3 and assume that, for each i \u2208 {1, 2}, the (\u03a3,B)-multilinear representation (Vi, \u00b5i, \u03b3i) with Vi = (B Qi ,+, 0Qi) recognizes ri. We assume that Q1 \u2229 Q2 = \u2205. We define a (\u03a3,B)multilinear representation (V, \u00b5, \u03b3) which recognizes r1 \u2295 r2 as follows. Let\n\u2022 V = (BQ1\u222aQ2 ,+, 0Q1\u222aQ2) where + is the usual sum of (Q1 \u222aQ2)-vectors over B,\n\u2022 let \u00b5 be the \u03a3-indexed family over the set of all operations over B such that, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and v1, . . . , vk \u2208 BQ1\u222aQ2 and q \u2208 Q1 \u222aQ2, we have (recalling that vectors are mappings)\n\u00b5(\u03c3) ( v1, . . . , vk ) q =\n{ \u00b51(\u03c3)(v1|Q1 , . . . , vk|Q1)q if q \u2208 Q1\n\u00b52(\u03c3)(v1|Q2 , . . . , vk|Q2)q otherwise ,\n\u2022 and let \u03b3 : BQ1\u222aQ2 \u2192 B be a mapping such that, for each u \u2208 BQ1\u222aQ2 , we have \u03b3(u) = \u03b31(u|Q1)\u2295 \u03b32(u|Q2).\nIt is easy to see that \u00b5(\u03c3) \u2208 L(Vk,V) for every k \u2208 N and \u03c3 \u2208 \u03a3(k), and that \u03b3 is a linear form. Hence (V, \u00b5, \u03b3) is a (\u03a3,B)-multilinear representation.\n4called \u2018multilinear representation of T\u03a3\u2019 in [BR82]"
        },
        {
            "heading": "3.6. WEIGHTED TREE AUTOMATA OVER COMMUTATIVE SEMIRINGS 99",
            "text": "It is also easy to show by induction on T\u03a3 that hV(\u03be) = hV1(\u03be) \u222a hV2(\u03be) for each \u03be \u2208 T\u03a3. Then, for each \u03be \u2208 T\u03a3, we have\n\u03b3(hV(\u03be)) = \u03b3(hV1(\u03be) \u222a hV2(\u03be)) = \u03b31(hV1(\u03be)) \u2295 \u03b32(hV2(\u03be)) = r1(\u03be) \u2295 r2(\u03be) ,\ni.e., (V, \u00b5, \u03b3) recognizes r1 \u2295 r2.\nExample 3.6.3. [BR82, Ex. 4.1] Here we show an example of a multilinear representation for the field Rat of rational numbers. For this, we consider the weighted tree language size : T\u03a3 \u2192 Q (cf. Example 3.2.3) over the Rat and we show that size is recognizable by a (\u03a3,Rat)-multilinear representation.\nFor each \u03b4 \u2208 \u03a3, we define the mapping size\u03b4 : T\u03a3 \u2192 Q by size\u03b4(\u03be) = |pos\u03b4(\u03be)|. Then we have size = +\u03b4\u2208\u03a3 size\u03b4. By Lemma 3.6.2, a finite sum of weighted tree languages which are recognizable by (\u03a3,Rat)-multilinear representation is also recognizable by a (\u03a3,Rat)-multilinear representation. Hence, it suffices to prove, for an arbitrary but fixed \u03b4 that size\u03b4 is recognizable by some (\u03a3,Q)-multilinear representation. From now on let \u03b4 \u2208 \u03a3 be arbitrary, but fixed. We assume that \u03b4 has rank \u2113 for some \u2113 \u2208 N.\nWe define the (\u03a3,Rat)-multilinear representation (Rat2, \u00b5, \u03b3) with the Rat-vector space Rat2 = (Q2,+, (0, 0)) in the following way. Certainly, it is sufficient to define each multilinear operation \u00b5k(\u03c3) (for k \u2208 N and \u03c3 \u2208 \u03a3(k)) and \u03b3 on the basis vectors e1 = (1, 0) and e2 = (0, 1). For every ei1 , . . . , ei\u2113 \u2208 {e1, e2}, we define\n\u00b5(\u03b4)(ei1 , . . . , ei\u2113) =    e1 + e2 if i1 = . . . = i\u2113 = 1 e2 if there exists exactly one j \u2208 [\u2113] with ij = 2\n(0, 0) otherwise,\nand, for every \u03c3 \u2208 \u03a3(k) with k \u2208 N and \u03c3 6= \u03b4 and ei1 , . . . , eik \u2208 {e1, e2}, we define\n\u00b5(\u03c3)(ei1 , . . . , eik) =    e1 if i1 = . . . = ik = 1 e2 if there exists exactly one j \u2208 [k] with ij = 2\n(0, 0) otherwise.\nThus, in particular, for \u03b1 \u2208 \u03a3(0), this gives\n\u00b5(\u03b1)() =\n{ e1 + e2 if \u03b1 = \u03b4\ne1 otherwise. (3.30)\nFinally, we define \u03b3(e1) = 0 and \u03b3(e2) = 1.\nNext, by induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3: hRat2(\u03be) = e1 + size\u03b4(\u03be)e2 . (3.31)\nI.B.: Let \u03be \u2208 \u03a3(0). Then (3.31) follows from (3.30).\nI.S.: Now let \u03be = \u03c3(\u03be1, . . . , \u03bek). Then, using the multilinearity at equations marked by \u2217, we can calculate as follows:\nhRat2(\u03be) = \u00b5(\u03c3)(hRat2(\u03be1), . . . , hRat2(\u03bek))\n= \u00b5(\u03c3)(e1 + size\u03b4(\u03be1)e2, . . . , e1 + size\u03b4(\u03bek)e2) (by I.H.)\n=\u2217 \u00b5(\u03c3)(e1, . . . , e1) ++ i\u2208[k] \u00b5(\u03c3)(e1, . . . , e1, size\u03b4(\u03bei)e2, e1, . . . , e1)\n+ + 1\u2264i<j\u2264m \u00b5(\u03c3)(. . . , size\u03b4(\u03bei)e2, . . . , size\u03b4(\u03bej)e2, . . .)\n100 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA\n=\u2217 \u00b5(\u03c3)(e1, . . . , e1) ++ i\u2208[k] size\u03b4(\u03bei)\u00b5(\u03c3)(e1, . . . , e1, e2, e1, . . . , e1)\n++ . . . size\u03b4(\u03bei) . . . size\u03b4(\u03bej) . . . \u00b5(\u03c3)(. . . , e2, . . . , e2, . . .) = \u00b5(\u03c3)(e1, . . . , e1) ++\ni\u2208[k]\nsize\u03b4(\u03bei)e2 + (0, 0)\n= { e1 + e2 ++i\u2208[k] size\u03b4(\u03bei)e2 if \u03c3 = \u03b4 e1 ++i\u2208[k] size\u03b4(\u03bei)e2 otherwise.\nThis proves (3.31). Finally, it is easy to see that \u03b3(hRat2(\u03be)) = size\u03b4(\u03be) for each \u03be \u2208 T\u03a3. This means that size\u03b4 is recognizable by the (\u03a3,Rat)-multilinear representation (Rat\n2, \u00b5, \u03b3). Thus size is recognizable by some (\u03a3,Rat)-multilinear representation."
        },
        {
            "heading": "3.6.2 Relationship between wta and multilinear representations",
            "text": "Let (V, \u00b5, \u03b3) be a (\u03a3,B)-multilinear representation with V = (BQ,+, 0Q). Moreover, let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. We recall that V(A) = (BQ, \u03b4A) is the vector algebra of A.\nWe say that (V, \u00b5, \u03b3) and A are related if\n\u2022 for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and q, q1, . . . , qk \u2208 Q, the equation\n\u00b5(\u03c3)(1q1 , . . . , 1qk)q = \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\nholds, and \u2022 for every q \u2208 Q, the equation \u03b3(1q) = Fq holds.\nThe intention of the first condition in the definition of relatedness is that \u00b5 and \u03b4A should play the same role. In order to formalize this, we first prove that each \u03b4A(\u03c3) is a multilinear mapping.\nLemma 3.6.4. (cf. [Boz99]) Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. For every k \u2208 N and \u03c3 \u2208 \u03a3(k), the operation \u03b4A(\u03c3) is multilinear.\nProof. Let k \u2208 N, \u03c3 \u2208 \u03a3(k), i \u2208 [k], b, b\u2032 \u2208 B, v1, . . . , vk, v, v\u2032 \u2208 BQ, and q \u2208 Q. Then we can calculate as follows.\n\u03b4A(\u03c3)(v1, . . . , vi\u22121, bv + b \u2032v\u2032, vi+1, . . . , vk)q\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n( \u2297\nj\u2208[1,i\u22121]\n(vj)qj ) \u2297 (bv + b\u2032v\u2032)qi \u2297 ( \u2297\nj\u2208[i+1,k]\n(vj)qj ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n( \u2297\nj\u2208[1,i\u22121]\n(vj)qj ) \u2297 (b\u2297 vqi \u2295 b \u2032 \u2297 (v\u2032)qi)\u2297 ( \u2297\nj\u2208[i+1,k]\n(vj)qj ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n[( \u2297\nj\u2208[1,i\u22121]\n(vj)qj ) \u2297 b\u2297 vqi \u2297 ( \u2297\nj\u2208[i+1,k]\n(vj)qj ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n\u2295 ( \u2297\nj\u2208[1,i\u22121]\n(vj)qj ) \u2297 b\u2032 \u2297 (v\u2032)qi \u2297 ( \u2297\nj\u2208[i+1,k]\n(vj)qj ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) ]\n(by distributivity of B)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n[( \u2297\nj\u2208[1,i\u22121]\n(vj)qj ) \u2297 b\u2297 vqi \u2297 ( \u2297\nj\u2208[i+1,k]\n(vj)qj ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) ]\n\u2295 \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n[( \u2297\nj\u2208[1,i\u22121]\n(vj)qj ) \u2297 b\u2032 \u2297 (v\u2032)qi \u2297 ( \u2297\nj\u2208[i+1,k]\n(vj)qj ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) ]\n3.6. WEIGHTED TREE AUTOMATA OVER COMMUTATIVE SEMIRINGS 101\n= b\u2297 [ \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n( \u2297\nj\u2208[1,i\u22121]\n(vj)qj ) \u2297 vqi \u2297 ( \u2297\nj\u2208[i+1,k]\n(vj)qj ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) ]\n\u2295 b\u2032 \u2297 [ \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n( \u2297\nj\u2208[1,i\u22121]\n(vj)qj ) \u2297 (v\u2032)qi \u2297 ( \u2297\nj\u2208[i+1,k]\n(vj)qj ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) ]\n(by commutativity and distributivity)\n= b\u03b4A(\u03c3)(v1, . . . , vi\u22121, v, vi+1, . . . , vk)q + b \u2032\u03b4A(\u03c3)(v1, . . . , vi\u22121, v \u2032, vi+1, . . . , vk)q .\nHence \u03b4A(\u03c3) is multilinear.\nNow we can show the semantic implications of the relatedness between a multilinear representation and a wta.\nLemma 3.6.5. Let (V, \u00b5, \u03b3) with V = (BQ,+, 0Q) and A = (Q, \u03b4, F ) be related. Then\n\u2022 \u00b5(\u03c3) = \u03b4A(\u03c3) for each \u03c3 \u2208 \u03a3, \u2022 for every \u03be \u2208 T\u03a3 and q \u2208 Q we have that hV(\u03be)q = hA(\u03be)q , and \u2022 for every \u03be \u2208 T\u03a3 we obtain: \u03b3(hV(\u03be)) = [[A]] init(\u03be).\nProof. Let k \u2208 N, \u03c3 \u2208 \u03a3(k), and q, q1, . . . , qk \u2208 Q. Then we have\n\u00b5(\u03c3)(1q1 , . . . , 1qk)q = \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = \u03b4A(\u03c3)(1q1 , . . . , 1qk)q ,\nwhere the first equality holds by relatedness and the second one holds by the definition of \u03b4A(\u03c3). Since \u00b5(\u03c3) is multilinear (by definition) and \u03b4A(\u03c3) is multilinear (due to Lemma 3.6.4) and they coincide on unit vectors, we obtain that \u00b5(\u03c3) = \u03b4A(\u03c3). This proves the first statement.\nThe second statement follows from the fact that the two \u03a3-algebras (BQ, \u00b5) and (BQ, \u03b4A) and hence also the two \u03a3-algebra homomorphisms hV and hA are equal. Now let \u03be \u2208 T\u03a3. Then\n[[A]]init(\u03be) = \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq = \u2295\nj\u2208[\u03ba]\nhA(\u03be)qj \u2297 Fqj = \u2295\nj\u2208[\u03ba]\nhV(\u03be)qj \u2297 \u03b3(1qj ) = \u03b3(hV(\u03be)).\nThe next theorem contains a characterization of recognizability in terms of multilinear representations. For the case that the weight algebra B is a field, the proof was sketched in [FV09, Thm. 3.52]. Already in [Bor04, p. 518], direct constructions have been indicated. There, the author deals with the concepts of B-vector space and basis, and thereby gives the impression that B is a field. On the background of this understanding, it is a bit puzzling that the author mentions twice the condition that \u201cthe underlying semiring is commutative\u201d, as if the indicated constructions would also hold for commutative semirings. Anyway, the characterization for the case that B is a commutative semiring has been (re)discovered in [Dro22].\nTheorem 3.6.6. [Dro22] Let \u03a3 be a ranked alphabet, B be a commutative semiring, and r : T\u03a3 \u2192 B. Then the following two statements are equivalent. (A) We can construct a (\u03a3,B)-multilinear representation which recognizes r. (B) We can construct a (\u03a3,B)-wta which i-recognizes r.\nProof. Proof of (A)\u21d2(B): Let r : T\u03a3 \u2192 B be recognizable by the (\u03a3,B)-multilinear representation (V, \u00b5, \u03b3) with V = (BQ,+, 0Q) for some finite set Q. Hence r(\u03be) = \u03b3(hV(\u03be)) for every \u03be \u2208 T\u03a3.\nIt is easy to construct a (\u03a3,B)-wta A = (Q, \u03b4, F ) such that (V, \u00b5, \u03b3) and A are related. Hence, by Lemma 3.6.5, for every \u03be \u2208 T\u03a3 we obtain: \u03b3(hV(\u03be)) = [[A]]init(\u03be).\nProof of (B)\u21d2(A): Let r : T\u03a3 \u2192 B be i-recognizable by some (\u03a3,B)-wta A = (Q, \u03b4, F ) with Q = {q1, . . . , q\u03ba}. By Observation 3.6.1, (BQ,+, 0Q) is a B-semimodule and for every k \u2208 N and \u03c3 \u2208 \u03a3(k),\n102 CHAPTER 3. THE MODEL OF WEIGHTED TREE AUTOMATA\nthe operation \u03b4A(\u03c3) is multilinear. We define the linear form \u03b3 : B Q \u2192 B such that, for each v = b11q1 + . . . + b\u03ba1q\u03ba in B Q, we let \u03b3(v) = \u2295 j\u2208[\u03ba] bj \u2297 Fqj . In particular, \u03b3(1qj ) = Fqj for each j \u2208 [\u03ba]. Then (BQ, \u03b4A, \u03b3) is a (\u03a3,B)-multilinear representation and, moreover, (B Q, \u03b4A, \u03b3) and A are related. Thus it follows from Lemma 3.6.5 that \u03b3(hV(\u03be)) = [[A]]init(\u03be) for every \u03be \u2208 T\u03a3.\nFinally, we note that Theorem 3.6.6 might be understood as the tree version of the well-known result for wsa that a weighted string language is run-recognizable iff it has a linear representation (\u03bb, \u00b5, \u03b3) (cf. [Eil74, Cor. 6.2], [BR88, Ch. I, Sect. 5], and [DK21, Thm. 3.2])."
        },
        {
            "heading": "3.7 Extension of the weight algebra",
            "text": "We finish this chapter with an easy observation on the extension of the weight algebra of a (\u03a3,B)-wta A. If C is a strong bimonoid such that B is a subalgebra of C, then we say that C is an extension of B. If this is the case, then we can view each (\u03a3,B)-wta A as a (\u03a3,C)-wta. Moreover, the run semantics and the initial algebra semantics of the (\u03a3,C)-wta A are the same as the corresponding semantics of the (\u03a3,B)-wta A. Thus we obtain the following observation.\nObservation 3.7.1. Let the strong bimonoid C be an extension of B. Then Recrun(\u03a3,B) \u2286 Recrun(\u03a3,C) and Recinit(\u03a3,B) \u2286 Recinit(\u03a3,C).\nOne might also think of the following inverse problem. Is it true that, for each extension C of B, the inclusions\nRecrun(\u03a3,C) \u2229BT\u03a3 \u2286 Recrun(\u03a3,B) and Recinit(\u03a3,C) \u2229BT\u03a3 \u2286 Recinit(\u03a3,B) (3.32)\nhold?\nAn extension C of B for which (3.32) holds, is called Fatou extension of B (cf. [BR88, Ch. V]). For instance, for string ranked alphabets, the ring of integers is not a Fatou extension of the semiring of natural numbers [KS86, Ex. 8.1] (also cf. Lemma 18.2.5). In contrast, for the case that \u03a3 is a string ranked alphabet, the semiring Rat\u22650 is a Fatou extension of the semiring Nat of natural numbers [Fli75] (also cf. [BR88, Thm. 3.3]); moreover, for every two fields B and C, if C is an extension of B, then C is a Fatou extension of B [Fli74] (also cf. [BR88, Thm. 3.1]). Recently, the latter result has been extended to wta in [Dro22].\nChapter 4\nBasic properties of wta\nIn this chapter we analyse basic properties of an arbitrary (\u03a3,B)-wta A. In particular, we show that the annihilation property (i.e., 0\u2297 b = b\u2297 0 = 0) propagates over runs of A on an input tree \u03be \u2208 \u03a3 and over Q-vectors hA(\u03be) (where Q is the set of states of A; cf. Lemma 4.1.1). If A is bu deterministic, then for each input tree \u03be \u2208 T\u03a3, there exists at most one run \u03c1 \u2208 RA(\u03be) with weight different from 0, and at most one component q of hA(\u03be) is different from 0; moreover, such a \u03c1 exists if and only if such a component q exists, and if they exist, then wtA(\u03be, \u03c1) = hA(\u03be)q (cf. Lemma 4.2.1). If A is crisp deterministic, then we can replace in the previous sentence \u201cat most one\u201d by \u201cexactly once\u201d and wtA(\u03be, \u03c1) = hA(\u03be)q = 1 (cf. Lemma 4.3.1). Moreover, we prove a characterization result which involves the congruence ker(hA) (cf. Theorem 4.3.5)."
        },
        {
            "heading": "4.1 Properties of arbitrary wta",
            "text": "Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. For each \u03be \u2208 T\u03a3 we define the sets\nQhA6=0(\u03be) = {q \u2208 Q | hA(\u03be)q 6= 0}, and QRA6=0 (\u03be) = {q \u2208 Q | \u2203(\u03c1 \u2208 RA(q, \u03be)) such that wt(\u03be, \u03c1) 6= 0} .\nSince 0 is annihilating with respect to the multiplication of B, we obtain the following zero-propagation statements (where the second statement can be compared to [Bor04, Cor. 3.6]).\nLemma 4.1.1. Let \u03be \u2208 T\u03a3 and w \u2208 pos(\u03be). Then the following two statements hold.\n(1) If QhA6=0(\u03be|w) = \u2205, then Q hA 6=0(\u03be) = \u2205. (2) If QRA6=0 (\u03be|w) = \u2205, then Q RA 6=0 (\u03be) = \u2205.\nProof. Let \u03be \u2208 T\u03a3 and w \u2208 pos(\u03be). We define the well-founded set (prefix(w),\u227a) where, for every w1, w2 \u2208 prefix(w), we let w1 \u227a w2 if there exists a j \u2208 N such that w1 = w2j. Obviously, \u227a is well-founded and min\u227a(prefix(w)) = {w}.\nProof of (1): We assume that QhA6=0(\u03be|w) = \u2205. By induction on (prefix(w),\u227a), we prove that the following statement holds:\nFor each w\u2032 \u2208 prefix(w), we have QhA6=0(\u03be|w\u2032) = \u2205 . (4.1)\nI.B.: Let w\u2032 = w. Then the statement holds by assumption.\n103\n104 CHAPTER 4. BASIC PROPERTIES OF WTA\nI.S.: Now let w\u2032 \u2208 prefix(w) \\ {w} and \u03be(w\u2032) = \u03c3 for some \u03c3 \u2208 \u03a3(k) and k \u2208 N. Since w\u2032 \u2208 prefix(w) \\ {w}, we have that k \u2265 1 and there exists a j \u2208 [k] such that w\u2032j \u2208 prefix(w). Moreover, for each q \u2208 Q, we have\nhA(\u03be|w\u2032)q = hA(\u03c3(\u03be|w\u20321, . . . , \u03be|w\u2032k))q = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\nhA(\u03be|w\u2032i)qi ) \u2297 \u03b4(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) .\nThen, by the I.H., QhA6=0(\u03be|w\u2032j) = \u2205 and thus for each qj \u2208 Q we have hA(\u03be|w\u2032j)qj = 0. Hence each of the summands is a product in which the j-th factor is 0. Consequently, each summand is 0 and thus hA(\u03be|w\u2032)q = 0. This proves (4.1).\nFinally, QhA6=0(\u03be) = \u2205 follows from (4.1) with w \u2032 = \u03b5. Thus Statement (1) holds.\nProof of (2): We assume that QRA6=0 (\u03be|w) = \u2205. Then, by induction on (prefix(w),\u227a), we prove that the following statement holds:\nFor each w\u2032 \u2208 prefix(w), we have QRA6=0 (\u03be|w\u2032) = \u2205 . (4.2)\nI.B.: Let w\u2032 = w. Then the statement holds by assumption.\nI.S.: Now let w\u2032 \u2208 prefix(w) \\ {w}. Let \u03be(w\u2032) = \u03c3 for some \u03c3 \u2208 \u03a3(k) and k \u2208 N. Since w\u2032 \u2208 prefix(w) \\ {w}, we have that k \u2265 1 and there exists a j \u2208 [k] such that w\u2032j \u2208 prefix(w).\nLet q \u2208 Q and \u03c1 be an arbitrary run in RA(q, \u03be|w\u2032). The weight of \u03c1, by definition, is\nwt(\u03be|w\u2032 , \u03c1) = (\u2297\ni\u2208[k]\nwt(\u03be|w\u2032i, \u03c1|i) ) \u2297 \u03b4(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, q) .\nBy the I.H. QRA6=0 (\u03be|w\u2032j) = \u2205, hence wt(\u03be|w\u2032j , \u03c1|w\u2032j) = 0. This implies wt(\u03be|w\u2032 , \u03c1) = 0 and thus (4.2) holds.\nThen QRA6=0 (\u03be) = \u2205 follows from (4.2) for w \u2032 = \u03b5. Thus Statement (2) holds."
        },
        {
            "heading": "4.2 Properties of bu deterministic wta",
            "text": "Next we consider an arbitrary bu deterministic (\u03a3,B)-wta A = (Q, \u03b4, F ). Thus, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and w \u2208 Qk there exists at most one q \u2208 Q such that \u03b4k(w, \u03c3, q) 6= 0. This fact has the following consequences.\nLemma 4.2.1. [FKV21, Lm. 3.5] Let \u03a3 be a ranked alphabet, B = (B,\u2295,\u2297, 0, 1) a strong bimonoid, A = (Q, \u03b4, F ) a bu deterministic (\u03a3,B)-wta, and \u03be \u2208 T\u03a3. Then the following three statements hold. (1) |QhA6=0(\u03be)| \u2264 1 (cf. [BV03, Thm. 3.6]).\n(2) |QRA6=0 (\u03be)| \u2264 1. (3) Either (a) QhA6=0(\u03be) = \u2205 = Q RA 6=0 (\u03be) or (b) there exists a q \u2208 Q such that Q hA 6=0(\u03be) = {q} = Q RA 6=0 (\u03be),\nthere exists a \u03c1 \u2208 RA(q, \u03be) with wt(\u03be, \u03c1) 6= 0 and hA(\u03be)q = wt(\u03be, \u03c1), and for each \u03c1 \u2032 \u2208 RA(q, \u03be)\\ {\u03c1} we have wt(\u03be, \u03c1\u2032) = 0.\nProof. Proof of (1): We prove the statement by induction on T\u03a3. Let \u03be = \u03c3(\u03be1, . . . , \u03bek). We assume that |QhA6=0(\u03bei)| \u2264 1 for each i \u2208 [k] (I.H.), and we continue by case analysis.\nCase (1a): There exists an i \u2208 [k] such that |QhA6=0(\u03bei)| = 0. Then by Lemma 4.1.1(1) also |Q hA 6=0(\u03be)| = 0.\n4.2. PROPERTIES OF BU DETERMINISTIC WTA 105\nCase (1b): For each i \u2208 [k], we have |QhA6=0(\u03bei)| = 1. Let Q hA 6=0(\u03bei) = {q\u03bei}. Then for each q \u2208 Q:\nhA(\u03c3(\u03be1, . . . , \u03bek))q = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\nhA(\u03bei)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= (\u2297\ni\u2208[k]\nhA(\u03bei)q\u03bei ) \u2297 \u03b4k(q\u03be1 \u00b7 \u00b7 \u00b7 q\u03bek , \u03c3, q) .\nSince A is bu deterministic, there exists at most one q \u2208 Q such that \u03b4k(q\u03be1 \u00b7 \u00b7 \u00b7 q\u03bek , \u03c3, q) 6= 0. Thus |QhA6=0(\u03c3(\u03be1, . . . , \u03bek))| \u2264 1. (We note that, since B may contain zero-divisors, the cardinality of this set can be 0.)\nProof of (2): Its proof is very similar to that of Statement (1). Proof of (3): We prove the statement by induction on T\u03a3. Let \u03be = \u03c3(\u03be1, . . . , \u03bek). If Q hA 6=0(\u03be) = \u2205 = QRA6=0 (\u03be), then we are done. Otherwise, first assume that Q hA 6=0(\u03be) 6= \u2205. Then, by Statement (1), QhA6=0(\u03be) = {q} for some q \u2208 Q and, by Lemma 4.1.1(1), Q hA 6=0(\u03bei) 6= \u2205 for every i \u2208 [k]. By the I.H, for every i \u2208 [k] there exists a qi \u2208 Q such that Q hA 6=0(\u03bei) = {qi} = Q RA 6=0 (\u03bei) and there exists exactly one \u03c1i \u2208 RA(qi, \u03bei) with wt(\u03bei, \u03c1i) 6= 0 and hA(\u03bei)qi = wt(\u03bei, \u03c1i). Now we define the run \u03c1 \u2208 RA(q, \u03be) by \u03c1(\u03b5) = q, and \u03c1(iw) = \u03c1i(w) for every i \u2208 [k] and w \u2208 pos(\u03bei). Then we have\nwt(\u03be, \u03c1) = (\u2297\ni\u2208[k]\nwt(\u03bei, \u03c1|i) ) \u2297 \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5))\n= (\u2297\ni\u2208[k]\nwt(\u03bei, \u03c1i) ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= (\u2297\ni\u2208[k]\nhA(\u03bei)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = hA(\u03be)q.\nSince hA(\u03be)q 6= 0, we have wt(\u03be, \u03c1) 6= 0, i.e., q \u2208 Q RA 6=0 (\u03be), and thus, by Statement (2), Q RA 6=0 (\u03be) = {q}. Lastly, let \u03c1\u2032 \u2208 RA(q, \u03be) with \u03c1\u2032 6= \u03c1. Using the definition of \u03c1, the assumption that \u03c1i is the only run in RA(qi, \u03bei) with wt(\u03bei, \u03c1i) 6= 0 for each i \u2208 [k], and the fact that A is bu deterministic, it follows easily that wt(\u03be, \u03c1\u2032) = 0.\nThe case QRA6=0 (\u03be) 6= \u2205 can be proved similarly.\nA consequence of Lemma 4.2.1(3) is that both, the run semantics and the initial algebra semantics of a bu deterministic (\u03a3,B)-wta A are determined by the multiplicative monoid of B; the additive part does not play any role (apart from its unit element). Hence, if we replace the addition by another operation such that the algebra is still a strong bimonoid, then both the run semantics and the initial algebra semantics of A remain the same mapping. Below, we prove this statement and show some pairs of strong bimonoids which differ only in the definition of the addition.\nCorollary 4.2.2. Let B1 = (B,\u2295,\u2297, 0, 1) and B2 = (B,+,\u2297, 0, 1) be strong bimonoids and A = (Q, \u03b4, F ) be a bu deterministic (\u03a3,B1)-wta. Then, for the bu deterministic (\u03a3,B2)-wta B = (Q, \u03b4, F ), we have (1) [[B]]run = [[A]]run and (2) [[B]]init = [[A]]init.\nProof. It is obvious that, for every \u03be \u2208 T\u03a3 and q \u2208 Q, we have RA(q, \u03be) = RB(q, \u03be). Moreover, for each \u03c1 \u2208 RA(q, \u03be), we have\nwtA(\u03be, \u03c1) = wtB(\u03be, \u03c1) . (4.3)\nHence it follows that QRA6=0 (\u03be) = Q RB 6=0(\u03be) . (4.4)\nNow let \u03be \u2208 T\u03a3. By Lemma 4.2.1(3), we distinguish two cases.\n106 CHAPTER 4. BASIC PROPERTIES OF WTA\nCase (a): QhA6=0(\u03be) = \u2205 = Q RA 6=0 (\u03be). Then, by (4.4) and Lemma 4.2.1(3) (applied to B), we have\nQhB6=0(\u03be) = \u2205 = Q RB 6=0(\u03be). Hence, for each \u03c1 \u2208 RA(\u03be), we have wtA(\u03be, \u03c1) = 0 = wtB(\u03be, \u03c1). Then\n[[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = \u2295\n\u03c1\u2208RA(\u03be) 0 = 0 = + \u03c1\u2208RB(\u03be) 0 = + \u03c1\u2208RB(\u03be) wtB(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = [[B]] run(\u03be) .\nAlso, for each q \u2208 Q, we have hA(\u03be)q = 0 = hB(\u03be)q . Then, obviously, [[A]]init(\u03be) = 0 = [[B]]init(\u03be).\nCase (b): There exists a q \u2208 Q such that QhA6=0(\u03be) = {q} = Q RA 6=0 (\u03be), and there exists a \u03c1 \u2208 RA(q, \u03be)\nwith wtA(\u03be, \u03c1) 6= 0 and hA(\u03be)q = wtA(\u03be, \u03c1), and for each \u03c1\u2032 \u2208 RA(q, \u03be) \\ {\u03c1} we have wtA(\u03be, \u03c1\u2032) = 0.\nAgain, by (4.4) and Lemma 4.2.1(3) (applied to B), as well as (4.3), we obtain QhB6=0(\u03be) = {q} = Q RB 6=0(\u03be),\nwtB(\u03be, \u03c1) = wtA(\u03be, \u03c1) 6= 0 and hB(\u03be)q = wtB(\u03be, \u03c1), and for each \u03c1 \u2032 \u2208 RB(q, \u03be)\\{\u03c1} we have wtB(\u03be, \u03c1 \u2032) = 0. Then we have\n[[A]]run(\u03be) = \u2295\n\u03c1\u2032\u2208RA(\u03be)\nwtA(\u03be, \u03c1 \u2032)\u2297 F\u03c1\u2032(\u03b5) = wtA(\u03be, \u03c1)\u2297 Fq = wtB(\u03be, \u03c1)\u2297 Fq\n= + \u03c1\u2032\u2208RB(\u03be) wtB(\u03be, \u03c1 \u2032)\u2297 F\u03c1\u2032(\u03b5) = [[B]] run(\u03be) .\nSince wtA(\u03be, \u03c1) = wtB(\u03be, \u03c1), we also have hA(\u03be)q = hB(\u03be)q. Moreover, for each p \u2208 Q \\ {q}, we have hA(\u03be)p = 0 = hB(\u03be)p. Hence, we obtain\n[[A]]init(\u03be) = \u2295\np\u2208Q hA(\u03be)p \u2297 Fp = hA(\u03be)q \u2297 Fq = hB(\u03be)q \u2297 Fq =+ p\u2208Q hB(\u03be)p \u2297 Fp = [[B]] init(\u03be) .\nNext we show three examples of pairs of strong bimonoids B1 = (B,\u2295,\u2297, 0, 1) and B2 = (B,+,\u2297, 0, 1):\n\u2022 the strong bimonoids ([0, 1],\u2295, \u00b7, 0, 1) and ([0, 1],+, \u00b7, 0, 1) where \u2295 and + are t-conorms (cf. Example 2.6.10 (3)) and \u00b7 is the usual multiplication; examples of a t-conorm u : [0, 1] \u00d7 [0, 1] \u2192 [0, 1] are\n\u2013 the standard union u(a, b) = max(a, b), \u2013 the algebraic sum u(a, b) = a+ b\u2212 a \u00b7 b, or \u2013 the bounded sum u(a, b) = min(a+ b, 1),\n\u2022 the Boolean semiring Boole and the field F2 with two elements (cf. Example 2.6.10 (7)), and \u2022 the plus-plus strong bimonoid of natural numbers PPN = (N0,\u2295,+, 0, 0) (cf. Example 2.6.10 8) and the semiring (N0,max\n\u2032,+, 0, 0) where the binary operation max\u2032, if restricted to N, is the usual operation max on natural numbers (e.g. max(3, 2) = 3). Moreover, max\u2032(0, x) = max\u2032(x, 0) = x for each x \u2208 N0.\nAnother consequence of Lemma 4.2.1 is that, for each bu deterministic wta, its run semantics coincides with its initial algebra semantics. We will deal with this topic in Section 5.3."
        },
        {
            "heading": "4.3 Properties of crisp deterministic wta",
            "text": "Here we consider an arbitrary crisp deterministic (\u03a3,B)-wta A = (Q, \u03b4, F ). Thus, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and w \u2208 Qk there exists a q \u2208 Q such that \u03b4k(w, \u03c3, q) = 1 and for every q\u2032 \u2208 Q with q\u2032 6= q we have \u03b4k(w, \u03c3, q \u2032) = 0.\n4.3. PROPERTIES OF CRISP DETERMINISTIC WTA 107\nLemma 4.3.1. Let \u03a3 be a ranked alphabet, B = (B,\u2295,\u2297, 0, 1) a strong bimonoid, and A = (Q, \u03b4, F ) a crisp deterministic (\u03a3,B)-wta. For each \u03be \u2208 T\u03a3 there exists a q \u2208 Q such that (1) QhA6=0(\u03be) = {q} = Q RA 6=0 (\u03be) and there exists \u03c1 \u2208 RA(q, \u03be) with hA(\u03be)q = wt(\u03be, \u03c1) = 1 and for each\n\u03c1\u2032 \u2208 RA(q, \u03be) \\ {\u03c1} we have wt(\u03be, \u03c1\u2032) = 0, and (2) [[A]]init(\u03be) = Fq.\nThus, in particular, im([[A]]init) \u2286 im(F ).\nProof. Proof of (1): First, by induction on T\u03a3, we prove that the following statement holds:\nFor each \u03be \u2208 T\u03a3 there exists a q \u2208 Q such that Q hA 6=0(\u03be) = {q} and hA(\u03be)q = 1 . (4.5)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). We assume that Q hA 6=0(\u03bei) = {q\u03bei} and hA(\u03bei)q\u03bei = 1 for each i \u2208 [k] (I.H.). Then for every p \u2208 Q:\nhA(\u03c3(\u03be1, . . . , \u03bek))p = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\nhA(\u03bei)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, p) = \u03b4k(q\u03be1 \u00b7 \u00b7 \u00b7 q\u03bek , \u03c3, p)\nwhere the last equality holds by I.H. Since A is bu deterministic and total, there exists a q \u2208 Q such that \u03b4k(q\u03be1 \u00b7 \u00b7 \u00b7 q\u03bek , \u03c3, q) 6= 0 and for each q \u2032 \u2208 Q with q 6= q\u2032 we have \u03b4k(q\u03be1 \u00b7 \u00b7 \u00b7 q\u03bek , \u03c3, q \u2032) = 0. Thus QhA6=0(\u03be) = {q}. Since A has identity transition weights, we have that \u03b4k(q\u03be1 \u00b7 \u00b7 \u00b7 q\u03bek , \u03c3, q) = 1, and hence hA(\u03be)q = 1. This proves (4.5).\nNow let \u03be \u2208 T\u03a3. Then Statement (1) follows from Lemma 4.2.1(3).\nProof of (2): Let \u03be \u2208 T\u03a3. Then there exists q \u2208 Q such that Statement (1) holds. Thus we have [[A]]init(\u03be) = hA(\u03be)q \u2297 Fq = Fq.\nFinally, it follows from Statements (2) that im([[A]]init) \u2286 im(F ).\nEssentially, each crisp deterministic wta A is a finite \u03a3-algebra combined with a mapping which reflects the root weights. For the formalization of this statement, let us consider the crisp deterministic (\u03a3,B)-wta A = (Q, \u03b4, F ). The state algebra of A is the \u03a3-algebra S(A) = (Q, \u03b8A) such that, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), q \u2208 Q, and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Qk, we define\n\u03b8A(\u03c3)(q1, . . . , qk) = q, where q is the unique state for which \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = 1 .\nWe recall that the unique \u03a3-algebra homomorphism from the \u03a3-term algebra to S(A) is denoted by hS(A). Obviously, S(A) is isomorphic to the subalgebra (1Q, \u03bdA) of the vector algebra V(A), where\n\u2022 1Q = {1q | q \u2208 Q} is the set of q-unit vectors over Q (cf. Section 2.8), and \u2022 \u03bdA(\u03c3)(1q1 , . . . , 1qk)q = \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) for every k \u2208 N, \u03c3 \u2208 \u03a3 (k), q \u2208 Q, and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Qk.\nLemma 4.3.2. Let A = (Q, \u03b4, F ) be a crisp deterministic (\u03a3,B)-wta and S(A) = (Q, \u03b8A) the state algebra of A. The following two statements hold.\n(1) For each \u03be \u2208 T\u03a3 and each q \u2208 Q, we have\nhA(\u03be)q = { 1 if q = hS(A)(\u03be) 0 otherwise.\n(2) [[A]]init = F \u25e6 hS(A).\nProof. Proof of (1): We prove the statement by induction on T\u03a3. Let \u03be = \u03c3(\u03be1, . . . , \u03bek). Then by I.H. and the definition of state algebra we obtain hA(\u03c3(\u03be1, . . . , \u03bek))q = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\nhA(\u03bei)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = (\u2297\ni\u2208[k]\nhA(\u03bei)q\u03bei ) \u2297 \u03b4k(q\u03be1 \u00b7 \u00b7 \u00b7 q\u03bek , \u03c3, q)\n(where q\u03bei is the unique element of Q hA 6=0(\u03bei) with hA(\u03bei)q\u03bei = 1 for each i \u2208 [k], cf. Lemma 4.3.1(1))\n108 CHAPTER 4. BASIC PROPERTIES OF WTA\n= \u03b4k(hS(A)(\u03be1) \u00b7 \u00b7 \u00b7 hS(A)(\u03bek), \u03c3, q) ( by I.H.)\n=\n{ 1 if \u03b8A(\u03c3)(hS(A)(\u03be1), . . . , hS(A)(\u03bek)) = q\n0 otherwise . (by the definition of (Q, \u03b8A))\nSince \u03b8A(\u03c3)(hS(A)(\u03be1), . . . , hS(A)(\u03bek)) = hS(A)(\u03c3(\u03be1, . . . , \u03bek)), we have proved Statement (1).\nProof of (2): For each \u03be \u2208 T\u03a3, we have\n[[A]]init(\u03be) = \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq = FhS(A)(\u03be) = (F \u25e6 hS(A))(\u03be) ,\nwhere the second equality follows from Statement (1).\nNow we consider two strong bimonoids B1 and B2 which have the same carrier set; note that the unit elements of B1 and B2 may not be the same (examples are given below). Moreover, we let A be a crisp deterministic (\u03a3,B1)-wta. According to the note on page 62, A is different from the crisp deterministic (\u03a3,B2)-wta B which we obtain from A by replacing the unit elements of B1 in the transitions of A by the corresponding unit elements of B2. However, due to Lemma 4.3.2(2), the initial algebra semantics of A and B viewed as mappings coincide.1 In [FV22a] the next corollary was proved for the special case that B1 and B2 are bounded lattices.\nCorollary 4.3.3. [FV22a] Let B1 and B2 be strong bimonoids with the same carrier set. For each crisp deterministic (\u03a3,B1)-wta A, we can construct a crisp deterministic (\u03a3,B2)-wta B such that [[B]]init = [[A]]init. In particular, cd-Recinit(\u03a3,B1) = cd-Rec init(\u03a3,B2).\nProof. Let B1 = (B,\u2295,\u2297, 0, 1) and B2 = (B,+,\u00d7, 0, 1) be strong bimonoids. Let A = (Q, \u03b4, F ) be a crisp deterministic (\u03a3,B1)-wta. We construct the crisp deterministic (\u03a3,B2)-wta B = (Q, \u03b4\n\u2032, F ) where for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and q1, . . . , qk, q \u2208 Q we let\n(\u03b4\u2032)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) =\n{ 1 if \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = 1\n0 otherwise.\nClearly, B is crisp deterministic. It is obvious that the state algebra S(A) is equal to the state algebra S(B). As a consequence, the \u03a3-algebra homomorphism from T\u03a3 to S(A), denoted by hS(A), is the same as the \u03a3-algebra homomorphism from T\u03a3 to S(B), denoted by hS(B). Then, by applying Lemma 4.3.2(2) twice, we have [[A]]init = F \u25e6 hS(A) = F \u25e6 hS(B) = [[B]] init.\nExamples for pairs (B1,B2) of different strong bimonoids which have the same carrier set (\u2013 and the last three also have the same unit elements \u2013) are\n\u2022 the semiring (N\u221e,+, \u00b7, 0, 1) and the distributive bounded lattice (N\u221e,max,min, 0,\u221e), \u2022 the bounded lattices N5 and M3 from Examples 2.6.15(3) and 2.6.15(4), respectively, \u2022 the tropical semiring (N\u221e,min,+,\u221e, 0) and the tropical bimonoid (N\u221e,+,min, 0,\u221e), \u2022 the semiring of formal languages (P(\u0393\u2217),\u222a, \u00b7, \u2205, {\u03b5}) and the semiring (P(\u0393\u2217),\u222a,\u2229, \u2205,\u0393\u2217), \u2022 the two different strong bimonoids with the carrier set [0, 1] in Example 2.6.10(3) using algebraic sum and bounded sum, respectively, \u2022 the strong bimonoid ([0, 1],\u2295, \u00b7, 0, 1) with bounded sum \u2295 (cf. Example 2.6.10(3)) and the strong bimonoid ([0, 1], u, i, 0, 1) with t-conorm u and t-norm i (cf. Example 2.6.10(4)), and \u2022 the Boolean semiring Boole and the field F2 with two elements (cf. Example 2.6.10(7).\nIn the next theorem we characterize the set of weighted tree languages which are i-recognizable by crisp deterministic wta. As preparation we prove the following lemma which is a kind of inverse of Lemma 4.3.2(2).\n1This does not mean that A and B are i-equivalent because the latter concept is defined for wta over the same strong bimonoid.\n4.3. PROPERTIES OF CRISP DETERMINISTIC WTA 109\nLemma 4.3.4. For every finite \u03a3-algebra A = (Q, \u03b8) and mapping F : Q \u2192 B, we can construct a crisp deterministic (\u03a3,B)-wta A such that A is the state algebra of A (as defined on page 107) and F \u25e6 hA = [[A]]init.\nProof. We construct the crisp deterministic (\u03a3,B)-wta A = (Q, \u03b4, F ) where for every k \u2208 N, \u03c3 \u2208 \u03a3(k), q \u2208 Q, and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Qk we define\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = { 1 if \u03b8(\u03c3)(q1, . . . , , qk) = q 0 otherwise .\nClearly, A is the state algebra of A. Then hA = hS(A) and thus, by Lemma 4.3.2(2), we obtain F \u25e6 hA = [[A]]init.\nIn the next theorem we characterize the weighted tree languages which are recognized by crisp deterministic wta. Roughly speaking, it shows that each crisp deterministic (\u03a3,B)-wta consists of a finite \u03a3-algebra with carrier set Q and a mapping F : Q \u2192 B. In [BLB10, Thm. 2], the combination of (a) a finite \u03a3-algebra with carrier set Q and (b) a mapping F : Q\u2192 B was called \u201cfinite representation\u201d.\nTheorem 4.3.5. Let \u03a3 be a ranked alphabet, B be a strong bimonoid, and r : T\u03a3 \u2192 B. Then the following three statements are equivalent. (A) We can construct a finite \u03a3-algebra A = (Q, \u03b8) and a mapping F : Q\u2192 B such that r = F \u25e6 hA. (B) We can construct a crisp deterministic (\u03a3,B)-wta A such that r = [[A]]init. (C) We can construct a (\u03a3,B)-wta A such that the congruence ker(hA) has finite index and r = [[A]]init.\nProof. Proof of (A)\u21d2(B): This follows directly from Lemma 4.3.4.\nProof of (B)\u21d2(C): Let A = (Q, \u03b4, F ) be a crisp deterministic (\u03a3,B)-wta with r = [[A]]init. The image of hA is a finite set because, by Lemma 4.3.1, im(hA) \u2286 {0, 1}Q. Thus ker(hA) has finite index.\nProof of (C)\u21d2(A): Let A = (Q, \u03b4, FA) be a (\u03a3,B)-wta such that ker(hA) has finite index and r = [[A]]init. We consider the accessible subalgebra aV(A) = (im(hA), \u03b4aV(A)) of V(A) (cf. Section 3.1). Since ker(hA) has finite index, im(hA) is finite and hence aV(A) is a finite \u03a3-algebra. By Observation 2.9.4, we have im(hA) = \u3008\u2205\u3009\u03b4A(\u03a3), and by Lemma 2.6.1, we have that \u3008\u2205\u3009\u03b4A(\u03a3) can be constructed. Thus im(hA) can be constructed. Finally we define the mapping F : im(hA) \u2192 B for every v \u2208 im(hA) by F (v) = \u2295 q\u2208Q vq \u2297 (FA)q. Then by (3.4), we have [[A]] init = F \u25e6 haV(A).\nFinally, we prove that the set of weighted tree languages which are recognized by crisp deterministic (\u03a3,B)-wta with identity root weights, is exactly the set of characteristic mappings of recognizable \u03a3-tree languages. We note that in the following theorem (B)\u21d2(A) is in fact Theorem 2.13.2.\nTheorem 4.3.6. Let L \u2286 T\u03a3. Then the following three statements are equivalent.\n(A) We can construct a total and bu deterministic \u03a3-fta A such that L(A) = L. (B) We can construct a \u03a3-fta A such that L(A) = L. (C) We can construct a crisp deterministic (\u03a3,B)-wta A with identity root weights such that\n[[A]]init = \u03c7(L).\nProof. Proof of (A)\u21d2(B): This is by definition.\nProof of (B)\u21d2(C): Let A = (Q, \u03b4, F ) be a \u03a3-fta such that L = L(A). We consider the finite \u03a3-algebra (P(Q), \u03b4A) associated with A (for the definition of this algebra see page 56; we recall that the unique \u03a3-homomorphism from T\u03a3 to (P(Q), \u03b4A) is denoted by hA) and the mapping F \u2032 : P(Q)\u2192 B defined for each P \u2208 P(Q) by\nF \u2032(P ) = { 1 if P \u2229 F 6= \u2205 0 otherwise .\n110 CHAPTER 4. BASIC PROPERTIES OF WTA\nObviously, \u03c7(L) = F \u2032 \u25e6 hA. Then, by Lemma 4.3.4 we can construct a crisp deterministic (\u03a3,B)-wta A\u2032 = (P(Q), \u03b4\u2032, F \u2032) such that [[A\u2032]]init = F \u2032 \u25e6 hA. Hence [[A\u2032]]init = \u03c7(L). Moreover, A\u2032 has identity root weights and thus (C) holds.\nProof of (C)\u21d2(A): Let A = (Q, \u03b4, F ) be a crisp deterministic (\u03a3,B)-wta with identity root weights and [[A]]init = \u03c7(L). Let S(A) = (Q, \u03b8A) be the state algebra of A. By Lemma 4.3.2(2), we have [[A]]init = F \u25e6 hS(A), and by Lemma 4.3.2(1), we have for each \u03be \u2208 T\u03a3\nhA(\u03be)q = { 1 if q = hS(A)(\u03be) 0 otherwise.\nWe construct the total and bu deterministic \u03a3-fta A = (Q, \u03b4\u2032, F \u2032) such that for every k \u2208 N, \u03c3 \u2208 \u03a3(k), q \u2208 Q, and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Qk we have (\u03b4\u2032)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3) = q iff \u03b8A(\u03c3)(q1, . . . , qk) = q, and that F \u2032 = supp(F ). Since (\u03b4\u2032)A = \u03b8A, we have hA = hS(A). Then, for each \u03be \u2208 T\u03a3, we have:\n\u03be \u2208 L(A) iff hA(\u03be) \u2208 F \u2032 iff FhA(\u03be) = 1 iff FhS(A)(\u03be) = 1\niff \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq = 1 iff [[A]] init(\u03be) = 1 iff \u03be \u2208 supp([[A]]init)\nThus (A) holds.\nChapter 5\nComparison of initial algebra semantics and run semantics\nIn Section 3.2 we gave a number of examples of a (\u03a3,B)-wta A and we computed its run semantics or initial algebra semantics.\nIn Section 5.1, we start with an analysis of the complexity of two algorithms; the one calculates [[A]]init(\u03be) on input A and \u03be, and the other calculates [[A]]run(\u03be) on input A and \u03be (cf. Theorem 5.1.1); both algorithms follow the definition of the respective semantics in a natural way. We refer the reader to [AG20] for investigations on the complexity of the evaluation problem in the general framework of weighted tiling systems.\nSecond, in Section 5.2, we compare the run semantics and initial algebra semantics of some arbitrary, but fixed wta. In some situations, the semantics are equal. For instance, for the mapping height, in Example 3.2.4 we constructed a (\u03a3,Natmax,+)-wta A and proved that [[A]]init = [[A]]run = height. The question arises whether [[A]]init = [[A]]run for each (\u03a3,B)-wtaA. In Section 5.2 we will show that the answer is negative, i.e., we show a (\u03a3,B)-wta A such that [[A]]init 6= [[A]]run; in fact, we show four such examples. This stimulates the next question: is it possible to construct, for each (\u03a3,B)-wta A, a (\u03a3,B)-wta B such that [[A]]init = [[B]]run (and similarly with run semantics and initial algebra semantics exchanged)? In general, the answer to this question is also negative, i.e., we prove that there exist a strong bimonoid B and a (\u03a3,B)-wta A such that [[A]]init 6\u2208 Recrun(\u03a3,B) (cf. Theorem 5.2.5).\nOn the positive side, in Section 5.3, we will prove that, under certain conditions (on the wta or the strong bimonoid), the two semantics are equal."
        },
        {
            "heading": "5.1 Complexity of calculating run semantics and initial algebra",
            "text": "semantics\nIn this section we analyse the complexity of two natural algorithms: one calculates [[A]]run(\u03be) on input A and \u03be (cf. Algorithm 1) and the other calculates [[A]]init(\u03be) of input A and \u03be (cf. Algorithm 2). It is obvious that these algorithms are correct.\nMore specifically, we are interested in the number #run(A, \u03be) of occurrences of the strong bimonoid operations \u2295 and \u2297 that occur in the execution of Algorithm 1 if the inputs are A and \u03be. Similarly, we are interested in the number #init(A, \u03be) of occurrences of the strong bimonoid operations \u2295 and \u2297 that occur in the execution of Algorithm 2 if the inputs are A and \u03be.\n111\n112 CHAPTER 5. COMPARISON OF THE TWO SEMANTICS\nAlgorithm 1 Computation of the run semantics\nInput: (\u03a3,B)-wta A = (Q, \u03b4, F ) and \u03be \u2208 T\u03a3 Variables: b, r : B; w : pos(\u03be) Output: [[A]]run(\u03be) 1: b\u2190 0 2: for each \u03c1 : pos(\u03be)\u2192 Q do 3: r \u2190 1 4: for each w \u2208 pos(\u03be) in depth-first post-order do 5: let k = rk(\u03be(w)) 6: r \u2190 r \u2297 \u03b4k(\u03c1(w1) \u00b7 \u00b7 \u00b7 \u03c1(wk), \u03be(w), \u03c1(w)) 7: end for 8: b\u2190 b\u2295 (r \u2297 F\u03c1(\u03b5)) 9: end for 10: return b\nAlgorithm 2 Computation of the initial algebra semantics\nInput: (\u03a3,B)-wta A = (Q, \u03b4, F ) and \u03be \u2208 T\u03a3 Variables: v : pos(\u03be)\u2192 BQ; w : pos(\u03be); b : B Output: [[A]]init(\u03be) 1: for each w \u2208 pos(\u03be) in depth-first post-order do 2: let k = rk(\u03be(w)) 3: for each q \u2208 Q do 4: v(w)q \u2190 0 5: for each q1 \u00b7 \u00b7 \u00b7 qk \u2208 Q\nk do 6: v(w)q \u2190 v(w)q \u2295 v(w1)q1 \u2297 . . .\u2297 v(wk)qk \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03be(w), q) 7: end for 8: end for 9: end for\n10: b\u2190 0 11: for each q \u2208 Q do 12: b\u2190 b\u2295 (v(\u03b5)q \u2297 Fq) 13: end for 14: return b\nTheorem 5.1.1. Let \u03a3 be a ranked alphabet, B be a strong bimonoid, and A be a (\u03a3,B)-wta. For every \u03be \u2208 T\u03a3, we have (1) #run(A, \u03be) = (size(\u03be) + 2) \u00b7 |Q|\nsize(\u03be), and (2) #init(A, \u03be) \u2264 size(\u03be) \u00b7max(m+ 1, 2) \u00b7 (|Q|m+1 + |Q|) where m = maxrk(\u03a3).\nProof. Proof of (1): The loop in line 2 of Algorithm 1 is executed |Q|size(\u03be) many times. In each execution of the body of this loop, size(\u03be) + 1 times \u2297 is executed and 1 times \u2295 is executed.\nProof of (2): We abbreviate maxrk(\u03a3) by m. By assuming that each position of w of \u03be has m children (apart from the leaves of \u03be) we can approximate #init(A, \u03be) as follows. The loops in lines 1, 3, and 5 are executed size(\u03be) many times, |Q| many times, and maximally |Q|m many times, respectively. In line 6 there are maximally m+ 1 occurrences of \u2295 and \u2297. Hence, during execution of the loop in line 1, there are maximally size(\u03be) \u00b7 |Q|m+1 \u00b7 (m + 1) many occurrences of \u2295 and \u2297. During execution of the loop in line 11 there are 2 \u00b7 |Q| many occurrences of \u2295 and \u2297. Thus in total we obtain\n#init(A, \u03be) \u2264 size(\u03be) \u00b7 |Q| m+1 \u00b7 (m+ 1) + 2 \u00b7 |Q|\n5.2. NEGATIVE RESULTS FOR EQUALITY OF THE TWO SEMANTICS 113\n\u2264 size(\u03be) \u00b7 |Q|m+1 \u00b7max(m+ 1, 2) + max(m+ 1, 2) \u00b7 |Q| \u00b7 size(\u03be)\n\u2264 size(\u03be) \u00b7max(m+ 1, 2) \u00b7 (|Q|m+1 + |Q|) .\nAs we can see from Theorem 5.1.1, the effort of calculating [[A]]run(\u03be) by Algorithm 1 is exponential in the size of \u03be, and the effort of calculating [[A]]init(\u03be) by Algorithm 2 is at most linear in the size of \u03be.\nWith respect to the discussion on page 63, both algorithms compute the values of the algebraic ftahyperpath problem of an fta-hypergraph where the weights come from a strong bimonoid. We note that the value computation algorithm in [MV21, Alg. 6.1] (also cf. [MV19a, Alg. 1]) computes the values of the fta-algebraic hyperpath problem where the weights are calculated in a multioperator monoid."
        },
        {
            "heading": "5.2 Negative results for equality of the two semantics",
            "text": "In general, the run semantics and the initial algebra semantics of a wta over B are different, which is witnessed by the following four examples for string ranked alphabets.\nExample 5.2.1. We consider the string ranked alphabet \u03a3 = {\u03b3(1), \u03b1(0)} and the tropical bimonoid TropBM = (N\u221e,+,min, 0,\u221e) from Example 2.6.10(1). Moreover, let A = (Q, \u03b4, F ) be the (\u03a3,TropBM)wta from Example 3.2.8, i.e.,\n\u2022 Q = {q0, q1}, \u2022 \u03b40(\u03b5, \u03b1, p) = \u03b41(p, \u03b3, q) = 1 for every p, q \u2208 Q, and \u2022 Fq0 = Fq1 = 1.\nFrom Example 3.2.8 we know that [[A]]run(\u03b3n(\u03b1)) = 2n+1 for every n \u2208 N. Next we compute [[A]]init(\u03b3n(\u03b1)).\n[[A]]init(\u03b3n(\u03b1)) =+ q\u2208Q min(hA(\u03b3 n(\u03b1))q , Fq) =+ q\u2208Q min(hA(\u03b3 n(\u03b1))q , 1) = (\u2217)+ q\u2208Q 1 = 2 ,\nwhere we have to verify (\u2217). For this, by induction on N, we prove that the following statement holds:\nFor every n \u2208 N and q \u2208 Q we have: hA(\u03b3 n(\u03b1))q = { 1 if n = 0 2 otherwise .\nI.B.: Let n = 0. Then hA(\u03b3 n(\u03b1))q = hA(\u03b1)q = \u03b40(\u03b5, \u03b1, q) = 1 for each q \u2208 Q.\nI.S.: Let n \u2265 1. Then for each q \u2208 Q:\nhA(\u03b3 n(\u03b1))q =+\np\u2208Q\nmin(hA(\u03b3 n\u22121(\u03b1))p, \u03b41(p, \u03b3, q)) =+\np\u2208Q\n1 = 2 ,\nwhere the second equality follows from (a) the I.H. saying that 1 \u2264 hA(\u03b3n\u22121(\u03b1))p \u2264 2 and (b) the fact that \u03b41(p, \u03b3, q) = 1. Hence [[A]]run 6= [[A]]init.\nExample 5.2.2. (adapted from [CDIV10, Ex. 3.1]) Let UnitIntbs = ([0, 1],\u2295, \u00b7 , 0, 1) be the strong bimonoid given in Example 2.6.10(3), where \u2295 is the bounded sum, and let \u03a3 = {\u03b3(1), \u03bd(1), \u03b1(0)}. We consider the (\u03a3,UnitIntbs)-wta A = (Q, \u03b4, F ), where\n\u2022 Q = {p, q}, \u2022 the transition mappings are given as follows: \u03b40(\u03b5, \u03b1, p) = 0.6, \u03b40(\u03b5, \u03b1, q) = 0, \u03b41(p, \u03b3, p) = 1, \u03b41(p, \u03b3, q) = 1, \u03b41(q, \u03b3, p) = 0, \u03b41(q, \u03b3, q) = 0, \u03b41(p, \u03bd, p) = 1, \u03b41(p, \u03bd, q) = 0, \u03b41(q, \u03bd, p) = 1, \u03b41(q, \u03bd, q) = 0,\n114 CHAPTER 5. COMPARISON OF THE TWO SEMANTICS\n\u2022 Fp = 0.6 and Fq = 0.\nFigure 5.1 shows the fta-hypergraph of A.\nWe consider the tree \u03be = \u03bd(\u03b3(\u03b1)) and the runs \u03c11 and \u03c12 of A on \u03be with \u03c11(\u03b5) = \u03c11(1) = \u03c11(11) = p and \u03c12(\u03b5) = p, \u03c11(1) = q, and \u03c12(11) = p. Then wt(\u03be, \u03c11) = wt(\u03be, \u03c12) = 0.6. Then we can calculate as follows:\n[[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwt(\u03be, \u03c1) \u00b7 F\u03c1(\u03b5) = \u2295\n\u03c1\u2208RA(p,\u03be)\nwt(\u03be, \u03c1) \u00b7 0.6\n= wt(\u03be, \u03c11) \u00b7 0.6\u2295 wt(\u03be, \u03c12) \u00b7 0.6 = 0.36\u2295 0.36 = 0.72 .\nFor the calculation of [[A]]init(\u03be) we calculate the following Q-vectors where the upper component corresponds to the state p:\nhA(\u03b1) = ( 0.6 0 ) hA(\u03b3(\u03b1)) = ( hA(\u03b1)p \u00b7 1 hA(\u03b1)p \u00b7 1 ) = ( 0.6 0.6 )\nhA(\u03bd(\u03b3(\u03b1))) = ( hA(\u03b3(\u03b1))p \u00b7 1\u2295 hA(\u03b3(\u03b1))q \u00b7 1 hA(\u03b3(\u03b1))p \u00b7 0\u2295 hA(\u03b3(\u03b1))q \u00b7 0 ) = ( 0.6\u2295 0.6 0 ) = ( 1 0 ) .\nThen [[A]]init(\u03be) = \u2295\nq\u2032\u2208Q hA(\u03be)q\u2032 \u00b7 Fq\u2032 = hA(\u03be)p \u00b7 0.6 = 0.6. Hence [[A]] run 6= [[A]]init. This inequality is\ndue to the lack of right-distributivity in UnitIntbs:\n0.72 = 0.36\u2295 0.36 = (0.6 \u00b7 0.6)\u2295 (0.6 \u00b7 0.6) 6= (0.6\u2295 0.6) \u00b7 0.6 = 1 \u00b7 0.6 = 0.6 .\nAs the next two examples show, the run semantics and the initial algebra semantics can be different even when the strong bimonoid is finite.\nExample 5.2.3. We consider the finite strong bimonoid Three = ({0, 1, 2},max, \u00b7\u0302 , 0, 1) with\na \u00b7\u0302 b = (a \u00b7 b) mod 3\nfor every a, b \u2208 {0, 1, 2} (cf. Example 2.6.10(7)), and the string ranked alphabet \u03a3 = {\u03b3(1), \u03b1(0)}. Now we let A = (Q, \u03b4, F ) be the (\u03a3,Three)-wta such that Q = {1, 2, q}, F1 = F2 = 0 and Fq = 2, and\n\u03b40(\u03b5, \u03b1, 1) = 1, \u03b40(\u03b5, \u03b1, 2) = 2, \u03b40(\u03b5, \u03b1, q) = 0, \u03b41(1, \u03b3, q) = \u03b41(2, \u03b3, q) = 1\nand for every other combination p1, p2 \u2208 Q we let \u03b41(p1, \u03b3, p2) = 0. Figure 5.2 shows the fta-hypergraph of A.\n5.2. NEGATIVE RESULTS FOR EQUALITY OF THE TWO SEMANTICS 115\nNow let \u03be = \u03b3(\u03b1). Clearly {\u03c1 \u2208 RA(q, \u03be) | wt(\u03be, \u03c1) 6= 0} = {\u03c11, \u03c12} with\n\u03c11(\u03b5) = \u03c12(\u03b5) = q, \u03c11(1) = 1, \u03c12(1) = 2, and wt(\u03be, \u03c11) = 1, wt(\u03be, \u03c12) = 2 .\nHence [[A]]run(\u03be) = max(wt(\u03be, \u03c11) \u00b7\u0302 2,wt(\u03be, \u03c12) \u00b7\u0302 2) = max(1 \u00b7\u0302 2, 2 \u00b7\u0302 2) = max(2, 1) = 2 .\nFor the initial algebra semantics, we have\nhA(\u03b1)1 = 1, hA(\u03b1)2 = 2, hA(\u03b1)q = 0\nand hA(\u03be)q = max(hA(\u03b1)1 \u00b7\u0302 1, hA(\u03b1)2 \u00b7\u0302 1) = max(1, 2) = 2 . Hence [[A]]init(\u03be) = hA(\u03be)q \u00b7\u0302 2 = 2 \u00b7\u0302 2 = 1 .\nWe obtain [[A]]run(\u03be) = 2 6= 1 = [[A]]init(\u03be). This inequality is due to the lack of right-distributivity in Three: max(1 \u00b7\u0302 2, 2 \u00b7\u0302 2) = max(2, 1) = 2 6= 1 = 2 \u00b7\u0302 2 = max(1, 2) \u00b7\u0302 2.\nExample 5.2.4. [FV22a] We consider the bounded lattice N5 = (N5,\u2228,\u2227, o, i) shown in Figure 2.3. Moreover, we consider the string ranked alphabet \u03a3 = {\u03b3(1), \u03b1(0)}. Now we let A = (Q, \u03b4, F ) be the (\u03a3,N5)-wta with Q = {q1, q2, q}, Fq1 = Fq2 = o and Fq = a. Moreover, let\n\u2022 \u03b40(\u03b5, \u03b1, q1) = b, \u03b40(\u03b5, \u03b1, q2) = c, \u03b41(q1, \u03b3, q) = \u03b41(q2, \u03b3, q) = i, \u2022 \u03b40(\u03b5, \u03b1, q) = o and, for each p1p2 \u2208 (Q\u00d7Q) \\ {q1q, q2q}, we let \u03b41(p1, \u03b3, p2) = o.\nThe fta-hypergraph of A is obtained from the one in Figure 5.2 by replacing the states 1 and 2 by q1 and q2, respectively, and by adapting the weights appropriately.\nThen\n[[A]]init(\u03b3(\u03b1)) = \u2228\np\u2208Q\nhA(\u03b3(\u03b1))p \u2227 Fp = hA(\u03b3(\u03b1))q \u2227 a = ( \u2228\np\u2208Q\nhA(\u03b1)p \u2227 \u03b41(p, \u03b3, q) ) \u2227 a\n= ( (hA(\u03b1)q1 \u2227 \u03b41(q1, \u03b3, q)) \u2228 (hA(\u03b1)q2 \u2227 \u03b41(q2, \u03b3, q)) ) \u2227 a = ( (\u03b40(\u03b5, \u03b1, q1) \u2227 i) \u2228 (\u03b40(\u03b5, \u03b1, q2) \u2227 i) ) \u2227 a\n= (b \u2228 c) \u2227 a = a .\nAlso we have\n[[A]]run(\u03b3(\u03b1)) = \u2228\np\u2208Q\n\u2228\n\u03c1\u2208RA(p,\u03be)\nwt(\u03b3(\u03b1), \u03c1) \u2227 Fp = \u2228\n\u03c1\u2208RA(q,\u03be)\n(wt(\u03b3(\u03b1), \u03c1) \u2227 a)\n= ( \u03b40(\u03b5, \u03b1, q1) \u2227 \u03b41(q1, \u03b3, q) \u2227 a ) \u2228 ( \u03b40(\u03b5, \u03b1, q2) \u2227 \u03b41(q2, \u03b3, q) \u2227 a )\n= (b \u2227 i \u2227 a) \u2228 (c \u2227 i \u2227 a)\n= (b \u2227 a) \u2228 (c \u2227 a) = b .\n116 CHAPTER 5. COMPARISON OF THE TWO SEMANTICS\nHence [[A]]init 6= [[A]]run.\nFor the particular string ranked alphabet \u03a3 and the (\u03a3,TropBM)-wta A of Example 5.2.1, it is easy to construct a (\u03a3,TropBM)-wta B such that [[A]]init = [[B]]run (just let B have one state q, the weight of each transition is 2, and the root weight of q is also 2). The next theorem shows that, in general, this is not possible. Its proof is a slight adaptation of the proof of [DSV10, Ex. 25].\nTheorem 5.2.5. [DSV10, Ex. 25] The following two statements hold. (1) For each (\u03a3, Stb)-wta A, the set im([[A]]run) is finite. (2) If \u03a3 is nontrivial, then Recinit(\u03a3, Stb) \\Recrun(\u03a3, Stb) 6= \u2205.\nProof. Before proving Statements (1) and (2), we recall the strong bimonoid Stb = (N,\u2295,\u2299, 0, 1) from [DSV10, Ex. 25] (also cf. Example 2.6.10(9)). The two commutative operations \u2295 and \u2299 on N are defined as follows. First, let 0\u2295 a = a, 0\u2299 a = 0, and 1\u2299 a = a for every a \u2208 N. If a, b \u2208 N \\ {0} with a \u2264 b, we put (with + being the usual addition on N)\na\u2295 b =\n{ b if b is even\nb+ 1 if b is odd.\nIf a, b \u2208 N \\ {0, 1} with a \u2264 b, let\na\u2299 b =\n{ b+ 1 if b is even\nb if b is odd.\nProof of (1): Let A = (Q, \u03b4, F ) be an arbitrary (\u03a3, Stb)-wta. Let m = max(wts(A)) be the maximum of all weights which occur in A. Then, by the definition of [[A]]run, we have for each \u03be \u2208 T\u03a3 that\n[[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwt(\u03be, \u03c1)\u2299 F\u03c1(\u03b5) \u2264 \u2295\n\u03c1\u2208RA(\u03be)\n( \u2299\nw\u2208pos(\u03be)\nm ) \u2299m ,\nwhere the inequality holds because \u2299 is monotonic in each argument.\nNow let \u03be = \u03b1 for some \u03b1 \u2208 \u03a3(0). Then we can calculate as follows.\n[[A]]run(\u03be) \u2264 \u2295\n\u03c1\u2208RA(\u03b1)\n( \u2299\nw\u2208{\u03b5}\nm ) \u2299m = \u2295\n\u03c1\u2208RA(\u03b1)\nm\u2299m \u2264 \u2295\n\u03c1\u2208RA(\u03b1)\n(m+ 1) = \u2295\nq\u2208Q\n(m+ 1) \u2264 m+ 2 .\nNow let \u03be \u2208 T\u03a3 \\ \u03a3(0). Then by definition of \u2299:\n\u2299\nw\u2208pos(\u03be)\nm =\n{ m+ 1 if m is even\nm otherwise and\n( \u2299\nw\u2208pos(\u03be)\nm ) \u2299m =\n{ m+ 1 if m is even\nm otherwise.\nWe note that in these calculations we have used the fact that |pos(\u03be)| \u2265 2.\nBy definition of \u2295 we finally have:\n\u2295\n\u03c1\u2208RA(\u03be)\n( \u2299\nw\u2208pos(\u03be)\nm ) \u2299m =\n{ m+ 2 if m is even\nm+ 1 otherwise.\nHence im([[A]]run) is finite.\n5.3. POSITIVE RESULTS FOR EQUALITY OF THE TWO SEMANTICS 117\nProof of (2): Let \u03a3 be nontrivial. Now we consider the particular (\u03a3, Stb)-wta A = (Q, \u03b4, F ) with Q = {q1, q2} and \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, \u03c3, p) = Fp = 2 for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and p, p1, . . . , pk \u2208 Q. By induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and p \u2208 Q, we have : hA(\u03be)p = 2 \u00b7 height(\u03be) + 2 . (5.1)\nI.B.: Let \u03be = \u03b1 be in \u03a3(0). Then hA(\u03be)p = \u03b40(\u03b5, \u03b1, p) = 2 = 2 \u00b7 height(\u03be) + 2.\nI.S.: Let \u03be = \u03c3(\u03be1, . . . , \u03bek) with k \u2265 1 and p \u2208 Q. Moreover, let j \u2208 [k] be such that height(\u03bej) = max(height(\u03bei) | i \u2208 [k]). Then,\nhA(\u03c3(\u03be1, . . . , \u03bek))p = \u2295\np1\u00b7\u00b7\u00b7pk\u2208Q\nhA(\u03be1)p1 \u2299 . . .\u2299 hA(\u03bek)pk \u2299 \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, \u03c3, p)\n= \u2295\np1\u00b7\u00b7\u00b7pk\u2208Q\n(2 \u00b7 height(\u03be1) + 2)\u2299 . . .\u2299 (2 \u00b7 height(\u03bek) + 2)\u2299 2\n(by I.H. and definition of \u03b4k)\n= \u2295\np1\u00b7\u00b7\u00b7pk\u2208Q\n(2 \u00b7 height(\u03bej) + 3)\n(by definition of \u2299 and our choice of j; note that 2 \u00b7 height(\u03bej) + 2 is even)\n= 2 \u00b7 height(\u03bej) + 4 (by definition of \u2295 and the fact that there are at least two summands due to k \u2265 1 and |Q| = 2)\n= 2 \u00b7 height(\u03c3(\u03be1, . . . , \u03bek)) + 2 .\nThis finished the proof of (5.1).\nHence, for each \u03be \u2208 T\u03a3, we have\n[[A]]init(\u03be) = \u2295\np\u2208Q\nhA(\u03be)q \u2299 Fp = \u2295\np\u2208Q\n(2 \u00b7 height(\u03be) + 2)\u2299 2 = \u2295\np\u2208Q\n(2 \u00b7 height(\u03be) + 3) = 2 \u00b7 height(\u03be) + 4 .\nSince \u03a3 is not trivial, this implies that the set im([[A]]init) is infinite.\nBy using Statement (1), we obtain that\n[[A]]init \u2208 Recinit(\u03a3, Stb) \\ Recrun(\u03a3, Stb) .\nThe result which is dual to Theorem 5.2.5 would be that there exists a ranked alphabet \u03a3 and a strong bimonoid B such that Recrun(\u03a3,B) \\ Recinit(\u03a3,B) 6= \u2205. The corresponding statement for wsa was shown in [DSV10, Ex. 26]. However, we were not able to reproduce that proof, and thus, we cannot include its version for wta into the book."
        },
        {
            "heading": "5.3 Positive results for equality of the two semantics",
            "text": "In this section we show that the run semantics and the initial algebra semantics of a (\u03a3,B)-wta A are equal if A is bu deterministic or B is distributive.\nTheorem 5.3.1. (cf. [FKV21, Thm. 3.6]) Let \u03a3 be a ranked alphabet and B be a strong bimonoid. For each bu deterministic (\u03a3,B)-wta A we have [[A]]run = [[A]]init. Thus, in particular, bud-Recrun(\u03a3,B) = bud-Recinit(\u03a3,B) and cd-Recrun(\u03a3,B) = cd-Recinit(\u03a3,B).\nProof. Let A = (Q, \u03b4, F ) and \u03be \u2208 T\u03a3. Using Q RA 6=0 (\u03be) and Q hA 6=0(\u03be) (cf. Section 4.1), we have\n[[A]]run(\u03be) = \u2295\nq\u2208Q RA 6=0 (\u03be)\n\u2295\n\u03c1\u2208RA(q,\u03be)\nwt(\u03be, \u03c1)\u2297 Fq and [[A]] init(\u03be) =\n\u2295\nq\u2208Q hA 6=0 (\u03be)\nhA(\u03be)q \u2297 Fq .\n118 CHAPTER 5. COMPARISON OF THE TWO SEMANTICS\nThen we proceed by case analysis. Using Lemma 4.2.1(3) we distinguish the following two cases. Case (a): Let QRA6=0 (\u03be) = \u2205 = Q hA 6=0(\u03be). Then\n[[A]]run(\u03be) = \u2295\nq\u2208\u2205\n\u2295\n\u03c1\u2208RA(q,\u03be)\nwt(\u03be, \u03c1)\u2297 Fq = 0 = \u2295\nq\u2208\u2205\nhA(\u03be)q \u2297 Fq = [[A]] init(\u03be)\nCase (b): Let QRA6=0 (\u03be) = {q} = Q hA 6=0(\u03be) for some q \u2208 Q and there exists exactly one \u03c1 \u2208 RA(q, \u03be) with\nhA(\u03be)q = wt(\u03be, \u03c1). Then\n[[A]]run(\u03be) = wt(\u03be, \u03c1)\u2297 Fq = hA(\u03be)q \u2297 Fq = [[A]] init(\u03be) .\nDue to Theorem 5.3.1, if A is bu deterministic, then we write [[A]] instead of [[A]]run and [[A]]init. Moreover, for a weighted tree language r, we say that r is bu deterministically recognizable (instead of bu deterministically i-recognizable and bu deterministically r-recognizable). Also, we write bud-Rec(\u03a3,B) for bud-Recrun(\u03a3,B) (and hence, for bud-Recinit(\u03a3,B)). Similarly, we say that r is crisp deterministically recognizable (instead of crisp deterministically i-recognizable and crisp deterministically r-recognizable). Also, we write cd-Rec(\u03a3,B) for cd-Recrun(\u03a3,B) and cd-Recinit(\u03a3,B)).\nAlso the two semantics are equal for each (\u03a3,B)-wta if B is a semiring (as, e.g., for the Boolean semiring, cf. Lemma 2.13.1). In the next theorem we will prove that even the \u201cconverse\u201d result holds. The theorem was proved in [DSV10, Lm. 4] for the particular case that \u03a3 is a string ranked alphabet; there only right-distributivity is needed. It turns out that in the tree case also left-distributivity is needed if \u03a3 is not monadic. Moreover, in [LP05, Thm. 3.1(i),(iii)], the implication (A)\u21d2(B) of the theorem was proved for string ranked alphabets and lattice-ordered monoids in which the unit element of the monoid equals the upper bound of the lattice.\nTheorem 5.3.2. (cf. [Rad10, Thm. 4.1] and [Bor05, Lm. 4.1.13]) Let \u03a3 be a ranked alphabet and B be a strong bimonoid. The following two statements are equivalent: (A) If \u03a3 is not trivial, then B is right-distributive, and if \u03a3 is not monadic, then B is left-distributive. (B) For each (\u03a3,B)-wta A we have [[A]]run = [[A]]init.\nProof. Proof of (A)\u21d2(B): Let \u03be \u2208 T\u03a3. Since\n[[A]]run(\u03be) = \u2295\nq\u2208Q\n\u2295\n\u03c1\u2208RA(q,\u03be)\nwt(\u03be, \u03c1)\u2297 Fq and [[A]] init(\u03be) =\n\u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq ,\nit suffices to show that\nfor each q \u2208 Q, we have hA(\u03be)q \u2297 Fq = \u2295\n\u03c1\u2208RA(q,\u03be)\nwt(\u03be, \u03c1)\u2297 Fq .\nIf \u03a3 is trivial, then |RA(q, \u03be)| = 1. Otherwise B is right-distributive. Thus in both cases we have\n\u2295\n\u03c1\u2208RA(q,\u03be)\nwt(\u03be, \u03c1)\u2297 Fq = ( \u2295\n\u03c1\u2208RA(q,\u03be)\nwt(\u03be, \u03c1) ) \u2297 Fq.\nHence, by induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and q \u2208 Q, we have hA(\u03be)q = \u2295\n\u03c1\u2208RA(q,\u03be)\nwt(\u03be, \u03c1) . (5.2)\n5.3. POSITIVE RESULTS FOR EQUALITY OF THE TWO SEMANTICS 119\nFor this, let \u03be = \u03c3(\u03be1, . . . , \u03bek) and q \u2208 Q. Then\nhA(\u03be)q\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\nhA(\u03bei)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n( \u2295\n\u03c11\u2208RA(q1,\u03be1)\nwt(\u03be1, \u03c11) ) \u2297 . . .\u2297 ( \u2295\n\u03c1k\u2208RA(qk,\u03bek)\nwt(\u03bek, \u03c1k) ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) (by I.H.)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n( \u2295\n\u03c11\u2208RA(q1,\u03be1)\nwt(\u03be1, \u03c11)\u2297 ( . . .\u2297 ( \u2295\n\u03c1k\u2208RA(qk,\u03bek)\nwt(\u03bek, \u03c1k)\u2297 \u03b4k(\u03c11(\u03b5) \u00b7 \u00b7 \u00b7 \u03c1k(\u03b5), \u03c3, q) ) . . . ))\n(by right-distributivity, in case k \u2265 1)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n( \u2295\n\u03c11\u2208RA(q1,\u03be1)\n\u00b7 \u00b7 \u00b7 \u2295\n\u03c1k\u2208RA(qk,\u03bek)\n(\u2297\ni\u2208[k]\nwt(\u03bei, \u03c1i) ) \u2297 \u03b4k(\u03c11(\u03b5) \u00b7 \u00b7 \u00b7 \u03c1k(\u03b5), \u03c3, q) )\n(by left-distributivity, in case k \u2265 2)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n( \u2295\n\u03c1\u2208RA(q,\u03be), \u03c1(1)=q1,...,\u03c1(k)=qk\n(\u2297\ni\u2208[k]\nwt(\u03bei, \u03c1|i) ) \u2297 \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)) )\n= \u2295\n\u03c1\u2208RA(q,\u03be)\n(\u2297\ni\u2208[k]\nwt(\u03bei, \u03c1|i) ) \u2297 \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)) = \u2295\n\u03c1\u2208RA(q,\u03be)\nwt(\u03be, \u03c1) .\nProof of (B)\u21d2(A): We have to show:\n(i) If \u03a3 is not trivial, then (a\u2295 b)\u2297 c = a\u2297 c\u2295 b\u2297 c for every a, b, c \u2208 B, and (ii) if \u03a3 is not monadic, then a\u2297 (b\u2295 c) = a\u2297 b\u2295 a\u2297 c for every a, b, c \u2208 B.\nTo prove (i), we assume that \u03a3 is not trivial. Hence, \u03a3 6= \u03a3(0) and, by our convention on page 40, we also have \u03a3(0) 6= \u2205. Thus there exist \u03b1 \u2208 \u03a3(0) and \u03b3 \u2208 \u03a3(n) for some n \u2208 N+. Let a, b, c \u2208 B. We construct the (\u03a3,B)-wta A = (Q, \u03b4, F ) as follows: Q = {(a, 1), (b, 2), c, 1}, F(a,1) = F(b,2) = F1 = 0, and Fc = c. (We use (a, 1) and (b, 2) in order to keep the states separate even if a = b.) Moreover, we define the transition mappings as follows:\n\u2022 \u03b40(\u03b5, \u03b1, (a, 1)) = a, \u03b40(\u03b5, \u03b1, (b, 2)) = b, and \u03b40(\u03b5, \u03b1, 1) = 1 \u2022 \u03b40(\u03b5, \u03b1, c) = 0, \u2022 \u03b4n((a, 1)1 \u00b7 \u00b7 \u00b71\ufe38 \ufe37\ufe37 \ufe38\nn\u22121 , \u03b3, c) = \u03b4n((b, 2)1 \u00b7 \u00b7 \u00b71\ufe38 \ufe37\ufe37 \ufe38 n\u22121 , \u03b3, c) = 1,\n\u2022 \u03b4n(w, \u03b3, q) = 0 for each (w, q) \u2208 (Qn \u00d7Q) \\ {((a, 1)1 \u00b7 \u00b7 \u00b71, c), ((b, 2)1 \u00b7 \u00b7 \u00b7 1, c)}, and \u2022 for every other input symbol \u03c3 \u2208 \u03a3(k) with k \u2208 N and (w, r) \u2208 Qk \u00d7 Q we can define \u03b4k(w, \u03c3, r) arbitrarily.\nWe consider the particular input tree \u03be = \u03b3(\u03b1, . . . , \u03b1) in T\u03a3 and calculate its initial algebra semantics.\n[[A]]init(\u03be) = \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq = hA(\u03be)c \u2297 Fc = ( \u2295\nq1\u00b7\u00b7\u00b7qn\u2208Qn\n(\u2297\ni\u2208[n]\nhA(\u03b1)qi ) \u2297 \u03b4n(q1 \u00b7 \u00b7 \u00b7 qn, \u03b3, c) ) \u2297 c\n= ( hA(\u03b1)(a,1) \u2297 hA(\u03b1)1 \u2297 . . .\u2297 hA(\u03b1)1\ufe38 \ufe37\ufe37 \ufe38\nn\u22121\n\u2297 \u03b4n((a, 1)1 \u00b7 \u00b7 \u00b7 1, \u03b3, c)\n\u2295 hA(\u03b1)(b,2) \u2297 hA(\u03b1)1 \u2297 . . .\u2297 hA(\u03b1)1\ufe38 \ufe37\ufe37 \ufe38 n\u22121\n\u2297 \u03b4n((b, 2)1 \u00b7 \u00b7 \u00b71, \u03b3, c) ) \u2297 c\n= (a\u2297 1\u2297 . . .\u2297 1\u2297 1\u2295 b\u2297 1\u2297 . . .\u2297 1\u2297 1)\u2297 c = (a\u2295 b)\u2297 c .\nFor the calculation of the run semantics of \u03be we consider the particular runs \u03c1(a,1) and \u03c1(b,2) of A on\n\u03be (cf. Figure 5.3(a)) defined by\n\u2022 \u03c1(a,1)(\u03b5) = c, \u03c1(a,1)(1) = (a, 1), and \u03c1(a,1)(i) = 1 for every i \u2208 [2, n] and \u2022 \u03c1(b,2)(\u03b5) = c, \u03c1(b,2)(1) = (b, 2), and \u03c1(b,2)(i) = 1 for every i \u2208 [2, n].\nWe note that, for every \u03c1 \u2208 RA(\u03be) \\ {\u03c1(a,1), \u03c1(b,2)}, we have wt(\u03be, \u03c1) = 0. Then\n[[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwt(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = \u2295\n\u03c1\u2208RA(c,\u03be)\nwt(\u03be, \u03c1)\u2297 c = wt(\u03be, \u03c1(a,1))\u2297 c\u2295 wt(\u03be, \u03c1(b,2))\u2297 c\n= wt(\u03b1, \u03c1(a,1)|1)\u2297 wt(\u03b1, \u03c1(a,1)|2)\u2297 . . .\u2297 wt(\u03b1, \u03c1(a,1)|n)\u2297 \u03b4n((a, 1)1 \u00b7 \u00b7 \u00b71, \u03b3, c)\u2297 c\n\u2295 wt(\u03b1, \u03c1(b,2)|1)\u2297 wt(\u03b1, \u03c1(b,2)|2)\u2297 . . .\u2297 wt(\u03b1, \u03c1(b,2)|n)\u2297 \u03b4n((b, 2)1 \u00b7 \u00b7 \u00b7 1, \u03b3, c)\u2297 c\n= a\u2297 1\u2297 . . .\u2297 1\u2297 1\u2297 c\u2295 b\u2297 1\u2297 . . .\u2297 1\u2297 1\u2297 c = a\u2297 c\u2295 b\u2297 c.\nSince [[A]]init = [[A]]run, we obtain that Statement (i) holds.\nFor the proof of (ii), we assume \u03a3 is not monadic. Hence, \u03a3 6= \u03a3(0) \u222a\u03a3(1) and, by our convention on page 40, we also have \u03a3(0) 6= \u2205. Thus there exist \u03b1 \u2208 \u03a3(0) and \u03c3 \u2208 \u03a3(m) for some m \u2265 2. Let a, b, c \u2208 B. We construct the (\u03a3,B)-wta A = (Q, \u03b4, F ) with Q = {a, (b, 1), (c, 2), p, q, 1}, Fq = 1, Fu = 0 for every u \u2208 Q \\ {q}, and \u03b4 is defined by:\n\u2022 \u03b40(\u03b5, \u03b1, x) = x for every x \u2208 {a, 1}, \u03b40(\u03b5, \u03b1, (b, 1)) = b, \u03b40(\u03b5, \u03b1, (c, 2)) = c, and \u03b40(\u03b5, \u03b1, p) = \u03b40(\u03b5, \u03b1, q) = 0, \u2022 \u03b4m((b, 1)1 \u00b7 \u00b7 \u00b7 1\ufe38 \ufe37\ufe37 \ufe38 m\u22121 , \u03c3, p) = \u03b4m((c, 2)1 \u00b7 \u00b7 \u00b7 1\ufe38 \ufe37\ufe37 \ufe38 m\u22121 , \u03c3, p) = \u03b4m(a 1 \u00b7 \u00b7 \u00b7 1\ufe38 \ufe37\ufe37 \ufe38 m\u22122 p, \u03c3, q) = 1, \u2022 for every other (w, r) \u2208 Qm \u00d7Q, we let \u03b4m(w, \u03c3, r) = 0, and \u2022 for every input symbol \u03c4 \u2208 \u03a3 \\ {\u03b1, \u03c3} (with some rank k \u2265 0) and every (w, r) \u2208 Qk \u00d7 Q we can define \u03b4k(w, \u03c4, r) arbitrarily.\nNow we consider the particular input tree \u03be = \u03c3(\u03b1, . . . , \u03b1\ufe38 \ufe37\ufe37 \ufe38 m\u22121 , \u03c3(\u03b1, . . . , \u03b1\ufe38 \ufe37\ufe37 \ufe38 m )) \u2208 T\u03a3.\nhA(\u03c3(\u03b1, . . . , \u03b1\ufe38 \ufe37\ufe37 \ufe38 m\n))p = \u2295\nq1\u00b7\u00b7\u00b7qm\u2208Qm\nhA(\u03b1)q1 \u2297 hA(\u03b1)q2 \u2297 . . .\u2297 hA(\u03b1)qm \u2297 \u03b4m(q1q2 \u00b7 \u00b7 \u00b7 qm, \u03c3, p)\n= hA(\u03b1)(b,1) \u2297 hA(\u03b1)1 \u2297 . . .\u2297 hA(\u03b1)1 \u2297 \u03b4m((b, 1)1 \u00b7 \u00b7 \u00b71, \u03c3, p)\n\u2295 hA(\u03b1)(c,2) \u2297 hA(\u03b1)1 \u2297 . . .\u2297 hA(\u03b1)1 \u2297 \u03b4m((c, 2)1 \u00b7 \u00b7 \u00b7 1, \u03c3, p) = b\u2295 c .\n5.3. POSITIVE RESULTS FOR EQUALITY OF THE TWO SEMANTICS 121\nThen\n[[A]]init(\u03be) = hA(\u03be)q\n= hA(\u03b1)a \u2297 hA(\u03b1)1 \u2297 . . .\u2297 hA(\u03b1)1 \u2297 hA(\u03c3(\u03b1, . . . , \u03b1))p \u2297 \u03b4m(a1 \u00b7 \u00b7 \u00b7 1p, \u03c3, q) = a\u2297 (b\u2295 c) .\nNow we consider the particular runs \u03c1a\u2297(b,1), \u03c1a\u2297(c,2) \u2208 RA(q, \u03be) (cf. Figure 5.3(b)) such that\n\u2022 \u03c1a\u2297(b,1)(\u03b5) = q, \u03c1a\u2297(b,1)(1) = a, \u03c1a\u2297(b,1)(i) = 1 for every i \u2208 [2,m \u2212 1], \u03c1a\u2297(b,1)(m) = p, \u03c1a\u2297(b,1)(m1) = (b, 1), and \u03c1a\u2297(b,1)(mj) = 1 for every j \u2208 [2,m], and\n\u2022 \u03c1a\u2297(c,1) is the same as \u03c1a\u2297(b,1) except that \u03c1a\u2297(c,2)(m1) = (c, 2).\nIt is clear that wt(\u03be, \u03c1a\u2297(b,1)) = a\u2297 b and wt(\u03be, \u03c1a\u2297(c,2)) = a\u2297 c. Then [[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwt(\u03be, \u03c1)\u2297F\u03c1(\u03b5) = \u2295\n\u03c1\u2208RA(q,\u03be)\nwt(\u03be, \u03c1) = wt(\u03be, \u03c1a\u2297(b,1))\u2295wt(\u03be, \u03c1a\u2297(c,2)) = a\u2297 b\u2295 a\u2297 c.\nSince [[A]]run = [[A]]init, we obtain a\u2297 (b \u2295 c) = a\u2297 b\u2295 a\u2297 c. This proves Statement (ii).\nIn Examples 3.2.4 and 3.2.11 we gave a wta over the semiring Natmax,+ and a wta over the semiring Nat, respectively, and we have proved that for both wta the run semantics coincides with the initial algebra semantics. The following corollary shows that this coincidence is valid for each wta over an arbitrary semiring.\nCorollary 5.3.3. Let \u03a3 be a ranked alphabet and B = (B,\u2295,\u2297, 0, 1) be a semiring. For each (\u03a3,B)-wta A, we have (1) hA(\u03be)q = \u2295 \u03c1\u2208RA(q,\u03be) wt(\u03be, \u03c1) for every \u03be \u2208 T\u03a3 and state q of A and\n(2) [[A]]run = [[A]]init. Thus, in particular, Recrun(\u03a3,B) = Recinit(\u03a3,B).\nProof. Since B is a semiring, Equation (5.2) holds, and hence Statement (1) holds. Moreover, Theorem 5.3.2((A)\u21d2(B)) implies that [[A]]run = [[A]]init and Recrun(\u03a3,B) = Recinit(\u03a3,B).\nDue to Corollary 5.3.3, if B is a semiring and A is a (\u03a3,B)-wta, then we write [[A]] instead of [[A]]run and [[A]]init. Moreover, for an i-recognizable or r-recognizable weighted tree language r, we say that r is recognizable. Also, we denote the set Recrun(\u03a3,B) (and hence, Recinit(\u03a3,B)) by Rec(\u03a3,B).\nWith respect to the complexity of calculating the semantics [[A]] of some (\u03a3,B)-wta A where B is a semiring, Theorem 5.1.1 implies the following: in general, it is more efficient to calculate [[A]] according to Algorithm 2 (initial algebra semantics) than to calculate it according to Algorithm 1 (run semantics).\nIn Section 3.3 we have recalled the definition of wsa and the definitions of their run semantics and initial algebra semantics. Moreover, we have shown that wsa can be considered as particular wta (cf. Lemma 3.3.2). As an easy consequence of previous results we obtain that the two semantics of wsa over semirings are equal.\nCorollary 5.3.4. (cf. [DSV10, Lm. 4]) Let \u0393 be an alphabet and B be a right-distributive strong bimonoid. For each (\u0393,B)-wsa A we have [[A]]run = [[A]]init.\n122 CHAPTER 5. COMPARISON OF THE TWO SEMANTICS\nProof. Let A be a (\u0393,B)-wsa. Moreover, let e 6\u2208 \u0393. By Lemma 3.3.2, we can construct a (\u0393e,B)-wta B such that [[A]]run = [[B]]run \u25e6 treee and [[A]]init = [[B]]init \u25e6 treee. We note that \u0393 6= \u2205 and hence \u0393e is not trivial. Then, by Theorem 5.3.2 and again by Lemma 3.3.2, we obtain that [[A]]run = [[A]]init.\nDue to Corollary 5.3.4, if B is a semiring and A is a (\u0393,B)-wsa, then we write [[A]] instead of [[A]]run and [[A]]init.\nChapter 6\nPumping lemmas\nIn this chapter we show three pumping lemmas, which have different flavors: the pumping lemma for runs [Bor04, Sec. 5] (cf. Theorem 6.1.4) and, as a corollary, a pumping lemma for wta over positive strong bimonoids (cf. Corollary 6.1.6), and the pumping lemma for wta over fields [BR82] (cf. Theorem 6.2.9).\nThe pumping lemma in Theorem 6.1.4 concerns runs of weighted tree automata over B. It says that, given a big tree and a run on that tree, both the tree and the run can be decomposed such that both, the tree and the run can be pumped up along its components, and the weight of a pumped run on the corresponding pumped tree can be constructed as the product of the weights of the components of the run. As a corollary of Theorem 6.1.4, we prove a pumping lemma for the support of weighted tree languages recognizable by wta over a positive strong bimonoid B (cf. Corollary 6.1.6). Essentially this is the classical pumping lemma for recognizable \u03a3-tree languages [GS84, Lm. 2.10.1].\nThe pumping lemma in Theorem 6.2.9 concerns the support of weighted tree languages recognizable by wta over a field B. It says that, given a recognizable weighted tree language r and a big tree in the support of r, the tree can be decomposed such that it can be pumped up along its components and infinitely many of the pumped trees belong to the support of r.\nWe mention that in [MR18, CMMR21] five pumping lemmas for wsa over particular important semirings are shown. They concern weighted languages (a) which are recognizable by wsa over Nat\u221e, (b) which have the form min(r1, . . . , rm), where r1, . . . , rm are recognizable by wsa over Nat\u221e, (c) which are recognizable by polynomially-ambiguous wsa over Natmin,+, (d) which are recognizable by finitely-ambiguous wsa over Natmax,+, and (e) which are recognizable by polynomially-ambiguous wsa over Natmax,+, respectively. Each of these pumping lemmas is used to show that certain weighted languages do not belong to the corresponding set of recognizable weighted languages.\nWe recall that C\u03a3 \u2286 T\u03a3({z}) denotes the set of all \u03a3-contexts (cf. page 48). For each c \u2208 C\u03a3, we denote by depth(c) the length of the unique z-labeled position of c, i.e. depth(c) = |posz(c)|. We say that c is elementary if depth(c) = 1, i.e., there exist k \u2208 N+, \u03c3 \u2208 \u03a3(k), i \u2208 [k], and \u03be1, . . . , \u03bei\u22121, \u03bei+1, . . . , \u03bek \u2208 T\u03a3 such that\nc = \u03c3(\u03be1, . . . , \u03bei\u22121, z, \u03bei+1, . . . , \u03bek) .\nWe denote the set of all elementary \u03a3-contexts by eC\u03a3. Lastly we define the binary relation \u227aC\u03a3 on C\u03a3 such that, for every c1, c2 \u2208 C\u03a3, we have c1 \u227aC\u03a3 c2 if there exists an elementary context c \u2208 eC\u03a3 such that c2 = c[c1]. Obviously, \u227aC\u03a3 is well-founded and min\u227aC\u03a3 (C\u03a3) = {z}.\n123\n124 CHAPTER 6. PUMPING LEMMAS"
        },
        {
            "heading": "6.1 Pumping lemma for runs and wta over strong bimonoids",
            "text": "The pumping lemma of this section is based on the idea in [Bor04, Sec. 5]. The form in which we present it is adapted from [DFKV20, DFKV22].\nIn this section, we let A = (Q, \u03b4, F ) be an arbitrary (\u03a3,B)-wta.\nWe extend the concept of run (cf. Section 2.9) to runs on trees in T\u03a3({z}), where z is a variable. For this, let \u03be \u2208 T\u03a3({z}) and q \u2208 Q. A run (of A) on \u03be is a mapping \u03c1 : pos(\u03be) \u2192 Q, and it is a q-run if \u03c1(\u03b5) = q. Also, we denote the set of all runs on \u03be by RA(\u03be) and the set of all q-runs on \u03be by RA(q, \u03be). For every \u03be \u2208 T\u03a3({z}), \u03c1 \u2208 RA(\u03be), and w \u2208 pos(\u03be), the run induced by \u03c1 at position w, denoted by \u03c1|w, is defined in a similar way as shown on page 64.\nNext we define the weight of a run on trees in T\u03a3({z}) in a similar way as shown on page 64. We consider the well-founded set (TRz,\u227a) where TRz = {(\u03be, \u03c1) | \u03be \u2208 T\u03a3({z}), \u03c1 \u2208 RA(\u03be)} and \u227a is the binary relation on TRz defined by\n\u227a= { ( (\u03be|i, \u03c1|i), (\u03be, \u03c1) ) | (\u03be, \u03c1) \u2208 TRz , i \u2208 [rk(\u03be(\u03b5))]} .\nObviously, \u227a is well-founded and min\u227a(TRz) = {(\u03b1, \u03c1) | \u03b1 \u2208 \u03a3(0) \u222a {z}, \u03c1 : {\u03b5} \u2192 Q}. We define the mapping\nwtA : TRz \u2192 B\nby induction on (TRz,\u227a) for every \u03be \u2208 T\u03a3({z}) and \u03c1 \u2208 RA(\u03be) as follows:\nI.B.: If \u03be = z, then wtA(\u03be, \u03c1) = 1. If \u03be = \u03b1 is in \u03a3 (0), then wtA(\u03be, \u03c1) = \u03b40(\u03b5, \u03b1, \u03c1(\u03b5)).\nI.S.: Let \u03be = \u03c3(\u03be1, . . . , \u03bek) with k \u2265 1. Then we define\nwtA(\u03be, \u03c1) = (\u2297\ni\u2208[k]\nwtA(\u03be|i, \u03c1|i) ) \u2297 \u03b4k ( \u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5) ) . (6.1)\nWe call wtA(\u03be, \u03c1) the weight of \u03c1 (by A on \u03be).\nNow let c \u2208 C\u03a3 be a context with posz(c) = v and let \u03c1 \u2208 RA(q, c) for some q \u2208 Q. If \u03c1(v) = p, then we call \u03c1 a (q, p)-run on c and we denote the set of all such (q, p)-runs by RA(q, c, p). A (q, q)-run is called a loop. If \u03c1 \u2208 RA(z) with \u03c1(\u03b5) = q for some q \u2208 Q, then sometimes we write q\u0303 for \u03c1.\nLet c \u2208 C\u03a3, \u03b6 \u2208 T\u03a3, v = posz(c), q \u2032, q \u2208 Q, \u03c1 \u2208 RA(q\u2032, c, q), and \u03b8 \u2208 RA(q, \u03b6). The combination of \u03c1 and \u03b8, denoted by \u03c1[\u03b8], is the mapping \u03c1[\u03b8] : pos(c[\u03b6]) \u2192 Q defined for every u \u2208 pos(c[\u03b6]) as follows: if u = vw for some w, then we define \u03c1[\u03b8](u) = \u03b8(w), otherwise we define \u03c1[\u03b8](u) = \u03c1(u). Clearly, \u03c1[\u03b8] \u2208 RA(q\u2032, c[\u03b6]).\nLet \u03be \u2208 T\u03a3 and v \u2208 pos(\u03be). We denote by \u03be|v the context \u03be[z]v obtained by replacing the subtree of \u03be at v by z (cf. page 44). Moreover, for each \u03c1 \u2208 RA(\u03be), we define the run \u03c1|v on the context \u03be|v such that for every w \u2208 pos(\u03be|v) we set \u03c1|v(w) = \u03c1(w).\nLet c \u2208 C\u03a3, v = posz(c), and \u03c1 \u2208 RA(c). We define two mappings\nlc,\u03c1 : prefix(v)\u2192 B and rc,\u03c1 : prefix(v)\u2192 B\n(cf. [Bor04, p. 526] for deterministic wta). Intuitively, the product (6.1) which yields the element wt(c, \u03c1) \u2208 B, can be split into a left subproduct lc,\u03c1(\u03b5) and a right subproduct rc,\u03c1(\u03b5), where the border is given by the factor 1 coming from the weight of z. Figure 6.1 illustrates the mappings lc,\u03c1 and rc,\u03c1.\nFormally, we define the well-founded set (prefix(v),\u227a) where, for every w1, w2 \u2208 prefix(v), we let w1 \u227a w2 if there exists an i \u2208 N such that w1 = w2i. Obviously, \u227a is well-founded and min\u227a(prefix(v)) = {v} (cf. the proof of Lemma 4.1.1). Then we define lc,\u03c1 and rc,\u03c1 by induction on (prefix(v),\u227a) as follows. Let w \u2208 prefix(v) and assume that c(w) = \u03c3 and rk\u03a3(\u03c3) = k. Then we define\n6.1. PUMPING LEMMA FOR RUNS AND WTA OVER STRONG BIMONOIDS 125\nlc,\u03c1(w) =   \n1 if w = v\u2297 j\u2208[1,i\u22121] wt(c|wj , \u03c1|wj)\u2297 lc,\u03c1(wi) if wi \u2208 prefix(v) for some i \u2208 N+\nrc,\u03c1(w) =    1 if w = v rc,\u03c1(wi)\u2297 \u2297 j\u2208[i+1,k] wt(c|wj , \u03c1|wj)\u2297 \u03b4k(\u03c1(w1) \u00b7 \u00b7 \u00b7 \u03c1(wk), \u03c3, \u03c1(w))\nif wi \u2208 prefix(v) for some i \u2208 N+ .\nIn the sequel, we abbreviate lc,\u03c1(\u03b5) and rc,\u03c1(\u03b5) by lc,\u03c1 and rc,\u03c1, respectively.\nObservation 6.1.1. Let c \u2208 C\u03a3 and \u03c1 \u2208 RA(c). Then wt(c, \u03c1) = lc,\u03c1 \u2297 rc,\u03c1.\nLemma 6.1.2. (cf. [Bor04, Lm. 5.1]) Let c \u2208 C\u03a3, \u03b6 \u2208 T\u03a3, q\u2032, q \u2208 Q, \u03c1 \u2208 RA(q\u2032, c, q), and \u03b8 \u2208 RA(q, \u03b6). Then wt(c[\u03b6], \u03c1[\u03b8]) = lc,\u03c1 \u2297 wt(\u03b6, \u03b8) \u2297 rc,\u03c1.\nProof. We prove the statement by induction on (C\u03a3,\u227aC\u03a3).\nI.B.: Let c = z. Then\nwt(c[\u03b6], \u03c1[\u03b8]) = wt(\u03b6, \u03b8) (since c[\u03b6] = \u03b6 and \u03c1[\u03b8] = \u03b8)\n= 1\u2297 wt(\u03b6, \u03b8) \u2297 1\n= lz,\u03c1 \u2297 wt(\u03b6, \u03b8)\u2297 rz,\u03c1 (since lz,\u03c1 = 1 and rz,\u03c1 = 1)\nI.S.: Let c = \u03c3(\u03be1, . . . , \u03bei\u22121, c \u2032, \u03bei+1, . . . , \u03bek) with k \u2208 N+, i \u2208 [k], \u03be1, . . . , \u03bek \u2208 T\u03a3, and c\u2032 \u2208 C\u03a3. Then\nwe have\nwt(c[\u03b6], \u03c1[\u03b8]) = ( \u2297\nj\u2208[1,i\u22121]\nwt(\u03bej , \u03c1|j) ) \u2297 wt ( c\u2032[\u03b6], (\u03c1|i)[\u03b8] )\n\u2297 ( \u2297\nj\u2208[i+1,k]\nwt(\u03bej , \u03c1|j) ) \u2297 \u03b4k ( \u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, q\u2032 ) (by the definition of c[\u03b6] and \u03c1[\u03b8])\n= ( \u2297\nj\u2208[1,i\u22121]\nwt(\u03bej , \u03c1|j) ) \u2297 lc\u2032,\u03c1|i \u2297 wt(\u03b6, \u03b8)\u2297 rc\u2032,\u03c1|i\n\u2297 ( \u2297\nj\u2208[i+1,k]\nwt(\u03bej , \u03c1|j) ) \u2297 \u03b4k ( \u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, q\u2032 ) (by I.H.)\n= lc,\u03c1 \u2297 wt(\u03b6, \u03b8)\u2297 rc,\u03c1 (by the definition of lc,\u03c1 and rc,\u03c1)\n(note that lc|i,\u03c1|i = lc\u2032,\u03c1|i and rc|i,\u03c1|i = rc\u2032,\u03c1|i)\nLet c \u2208 C\u03a3. For each n \u2208 N, we define the n-th power of c, denoted by cn, by induction on N as follows: c0 = z and cn+1 = c[cn]. Moreover, let q \u2208 Q and \u03c1 \u2208 RA(q, c, q) be a loop. For each n \u2208 N, the n-th power of \u03c1, denoted by \u03c1n, is the run on cn defined by induction on N as follows: \u03c10 = q\u0303 (note that c0 = z) and \u03c1n+1 = \u03c1[\u03c1n]. Next we apply the previous results to the weights of powers of loops.\nTheorem 6.1.3. (cf. [Bor04, Lm. 5.3]) Let c\u2032, c \u2208 C\u03a3 and \u03b6 \u2208 T\u03a3, q\u2032, q \u2208 Q, \u03c1\u2032 \u2208 RA(q\u2032, c\u2032, q), \u03c1 \u2208 RA(q, c, q), and \u03b8 \u2208 RA(q, \u03b6). Then, for each n \u2208 N,\nwt(c\u2032 [ cn[\u03b6] ] , \u03c1\u2032 [ \u03c1n[\u03b8] ] ) = lc\u2032,\u03c1\u2032 \u2297 (lc,\u03c1) n \u2297 wt(\u03b6, \u03b8) \u2297 (rc,\u03c1) n \u2297 rc\u2032,\u03c1\u2032 . (6.2)\n1 2 6\nC H A P T E R\n6 .\nP U M P IN\nG L E M M A S\nw c \u2208 C\u03a3 \u03c1 \u2208 RA(c)\n6.1. PUMPING LEMMA FOR RUNS AND WTA OVER STRONG BIMONOIDS 127\nProof. First, by induction on N, we prove that the following statement holds:\nFor each n \u2208 N we have wt(cn[\u03b6], \u03c1n[\u03b8]) = (lc,\u03c1) n \u2297 wt(\u03b6, \u03b8)\u2297 (rc,\u03c1) n . (6.3)\nI.B.: Let n = 0. Then c0 = z and we have\nwt(c0[\u03b6], \u03c10[\u03b8]) = wt(\u03b6, \u03b8) (since c0[\u03b6] = \u03b6 and \u03c10[\u03b8] = \u03b8)\n= 1\u2297 wt(\u03b6, \u03b8) \u2297 1\n= (lc,\u03c1) 0 \u2297 wt(\u03b6, \u03b8) \u2297 (rc,\u03c1) 0 (since (lc,\u03c1) 0 = 1 and (rc,\u03c1) 0 = 1.)\nI.S.: We assume that the equality holds for n. Since cn+1 = c[cn] and \u03c1n+1 = \u03c1[\u03c1n], we have\nwt(cn+1[\u03b6], \u03c1n+1[\u03b8]) = lc,\u03c1 \u2297 wt(c n[\u03b6], \u03c1n[\u03b8]) \u2297 rc,\u03c1 (by Lemma 6.1.2)\n= lc,\u03c1 \u2297 (lc,\u03c1) n \u2297 wt(\u03b6, \u03b8) \u2297 (rc,\u03c1) n \u2297 rc,\u03c1 (by I.H.) = (lc,\u03c1) n+1 \u2297 wt(\u03b6, \u03b8) \u2297 (rc,\u03c1) n+1.\nThis proves (6.3). Now let n \u2208 N. Then we have\nwt(c\u2032 [ cn[\u03b6] ] , \u03c1\u2032 [ \u03c1n[\u03b8] ] ) = lc\u2032,\u03c1\u2032 \u2297 wt(c n[\u03b6], \u03c1n[\u03b8])\u2297 rc\u2032,\u03c1\u2032 (by Lemma 6.1.2)\n= lc\u2032,\u03c1\u2032 \u2297 (lc,\u03c1) n \u2297 wt(\u03b6, \u03b8) \u2297 (rc,\u03c1) n \u2297 rc\u2032,\u03c1\u2032 (by (6.3))\nNext, we prove our pumping lemma for runs of A on trees in T\u03a3 which are large enough. We note that B need not be commutative.\nTheorem 6.1.4. (cf. [Bor04, Lm. 5.5]) Let \u03a3 be a ranked alphabet, B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid, and A be a (\u03a3,B)-wta. Let \u03be \u2208 T\u03a3, q\u2032 \u2208 Q, and \u03ba \u2208 RA(q\u2032, \u03be). If height(\u03be) \u2265 |Q|, then there exist c\u2032, c \u2208 C\u03a3, \u03b6 \u2208 T\u03a3, q \u2208 Q, \u03c1\u2032 \u2208 RA(q\u2032, c\u2032, q), \u03c1 \u2208 RA(q, c, q), and \u03b8 \u2208 RA(q, \u03b6) such that \u03be = c\u2032 [ c[\u03b6] ] ,\n\u03ba = \u03c1\u2032 [ \u03c1[\u03b8] ] , height(c) > 0, height ( c[\u03b6] ) < |Q|, and, for each n \u2208 N,\nwt(c\u2032 [ cn[\u03b6] ] , \u03c1\u2032 [ \u03c1n[\u03b8] ] ) = lc\u2032,\u03c1\u2032 \u2297 (lc,\u03c1) n \u2297 wt(\u03b6, \u03b8) \u2297 (rc,\u03c1) n \u2297 rc\u2032,\u03c1\u2032 .\nProof. Since height(\u03be) \u2265 |Q| there exist u,w \u2208 N\u2217+ such that uw \u2208 pos(\u03be), |w| > 0, height(\u03be|u) < |Q|, and \u03ba(u) = \u03ba(uw). Then we let c\u2032 = \u03be|u, c = (\u03be|u)|w, \u03b6 = \u03be|uw. Clearly, \u03be = c\u2032 [ c[\u03b6] ] , height(c) > 0\nbecause |w| > 0, and height ( c[\u03b6] ) < |Q| because height(\u03be|u) < |Q|. Moreover, we set q = \u03ba(u), \u03c1\u2032 = \u03ba|u, \u03c1 = (\u03ba|u)| w and \u03b8 = \u03ba|uw. Then the statement follows from Theorem 6.1.3.\nBy Example 3.2.4, for \u03a3 = {\u03c3(2), \u03b1(0)}, the weighted tree language height : T\u03a3 \u2192 N is initial algebra recognizable by a (\u03a3,Natmax,+)-wta. As an application of Theorem 6.1.3, we show that height cannot be recognized by a bu deterministic (\u03a3,Natmax,+)-wta. In contrast, if we consider an arbitrary string ranked alphabet \u03a3, then height : T\u03a3 \u2192 N is in bud-Rec(\u03a3,Natmax,+).\nCorollary 6.1.5. [Bor04, Ex. 5.9] For the ranked alphabet \u03a3 = {\u03c3(2), \u03b1(0)}, we have that height 6\u2208 bud-Rec(\u03a3,Natmax,+).\nProof. We prove by contradiction. For this, let us assume that there exists a bu deterministic (\u03a3,Natmax,+)-wta A = (Q, \u03b4, F ) such that [[A]] = height.\nLet \u03be = \u03c3(\u03b61, \u03b62) be a tree such that height(\u03b61) = |Q| and height(\u03b62) = 2|Q|. By Lemma 4.2.1(3)(b), there exist a q \u2208 Q and a run \u03ba \u2208 RA(q, \u03be) such that\n[[A]](\u03be) = wt(\u03be, \u03ba) + Fq .\nMoreover, there exist u \u2208 (N+)+ and v \u2208 (N+)+ such that uv \u2208 pos(\u03be) and u = 1u\u2032 for some u\u2032 \u2208 pos(\u03b61) (i.e., u is located in \u03b61), and \u03ba(u) = \u03ba(uv). Let us introduce\n128 CHAPTER 6. PUMPING LEMMAS\n- the contexts c\u2032 = \u03be|u, c = (\u03be|u)|v, the tree \u03b6 = \u03be|uv, as well as, - the runs \u03c1\u2032 = \u03ba|u, \u03c1 = (\u03ba|u)|v, and \u03b8 = \u03ba|uv, see Figure 6.2 and - let \u03ben = c \u2032[cn[\u03b6]] and \u03ban = \u03c1 \u2032[\u03c1n[\u03b8]] for each n \u2208 N.\nNote that \u03be1 = \u03be and \u03ba1 = \u03ba. By Theorem 6.1.3, we have\nwt(\u03ben, \u03ban) = lc\u2032,\u03c1\u2032 + n \u00b7 lc,\u03c1 +wt(\u03b6, \u03b8) + n \u00b7 rc,\u03c1 + rc\u2032,\u03c1\u2032\nfor each n \u2208 N. Since height(\u03be) = 2|Q|+ 1, we have\n[[A]](\u03be) = lc\u2032,\u03c1\u2032 + lc,\u03c1 +wt(\u03b6, \u03b8) + rc,\u03c1 + rc\u2032,\u03c1\u2032 + Fq = 2|Q|+ 1.\nThus, each of lc\u2032,\u03c1\u2032 , lc,\u03c1, wt(\u03b6, \u03b8), rc,\u03c1, rc\u2032,\u03c1\u2032 , and Fq is in N. Therefore wt(\u03ben, \u03ban) 6= \u2212\u221e for each n \u2208 N and thus, by Lemma 4.2.1(3)(b), we have\n[[A]](\u03ben) = lc\u2032,\u03c1\u2032 + n \u00b7 lc,\u03c1 +wt(\u03b6, \u03b8) + n \u00b7 rc,\u03c1 + rc\u2032,\u03c1\u2032 + Fq\nfor each n \u2208 N. It follows that lc,\u03c1 6= 0 or rc,\u03c1 6= 0 because otherwise height(\u03ben) would be the same number for each n \u2208 N. But then [[A]](\u03be0) < [[A]](\u03be1), which is a contradiction because height(\u03be0) = height(\u03be1).\nContrary to Corollary 6.1.5, for each string ranked alphabet \u03a3, the weighted tree language height : T\u03a3 \u2192 N is in bud-Rec(\u03a3,Natmax,+). To see this, let \u03a3 be a string ranked alphabet and assume that \u03a3(0) = {\u03b1}. Then we consider the bu deterministic (\u03a3,Natmax,+)-wta A = ({q}, \u03b4, F ) with \u03b40(\u03b5, \u03b1, q) = 0, and \u03b41(q, \u03b3, q) = 1 for each \u03b3 \u2208 \u03a3(1); moreover, we let Fq = 0. It is easy to see that [[A]]run = height.\nAs a corollary of Theorem 6.1.4, we prove a pumping lemma for the supports of weighted tree languages recognizable by wta over positive strong bimonoids.\nCorollary 6.1.6. Let \u03a3 be a ranked alphabet, B be a positive strong bimonoid, and L \u2286 T\u03a3. If L \u2208 supp(Recrun(\u03a3,B)), then there exists a p \u2208 N+ such that for each \u03be \u2208 L with height(\u03be) \u2265 p, there exist c\u2032, c \u2208 C\u03a3, \u03b6 \u2208 T\u03a3 such that\n\u2022 \u03be = c\u2032 [ c[\u03b6] ] , \u2022 height(c) > 0 and height ( c[\u03b6] ) < p, and \u2022 for each n \u2208 N, we have c\u2032 [ cn[\u03b6] ] \u2208 L.\nProof. Since L \u2208 supp(Recrun(\u03a3,B)), there exists a (\u03a3,B)-wta A = (Q, \u03b4, F ) such that L = supp([[A]]run). Let p = |Q|.\nLet \u03be \u2208 L with height(\u03be) \u2265 p. There there exist q\u2032 \u2208 Q and \u03ba \u2208 RA(q\u2032, \u03be) such that wtA(\u03be, \u03ba)\u2297Fq\u2032 6= 0. Thus wtA(\u03be, \u03ba) 6= 0 and Fq\u2032 6= 0.\nBy Theorem 6.1.4, there exist c\u2032, c \u2208 C\u03a3, \u03b6 \u2208 T\u03a3, q \u2208 Q, \u03c1\u2032 \u2208 RA(q\u2032, c\u2032, q), \u03c1 \u2208 RA(q, c, q), and \u03b8 \u2208 RA(q, \u03b6) such that \u03be = c\u2032 [ c[\u03b6] ] , \u03ba = \u03c1\u2032 [ \u03c1[\u03b8] ] , height(c) > 0, height ( c[\u03b6] ) < p, and, for each n \u2208 N,\n6.2. PUMPING LEMMA FOR WTA OVER FIELDS 129\nwt(c\u2032 [ cn[\u03b6] ] , \u03c1\u2032 [ \u03c1n[\u03b8] ] ) = lc\u2032,\u03c1\u2032 \u2297 (lc,\u03c1)n \u2297 wt(\u03b6, \u03b8) \u2297 (rc,\u03c1)n \u2297 rc\u2032,\u03c1\u2032 . Together with wtA(\u03be, \u03ba) 6= 0, this implies (for n = 1) that each of the three values lc\u2032,\u03c1\u2032 , wt(\u03b6, \u03b8), and rc,\u03c1 is different from 0. Since B is zero-divisor free, we obtain that\nlc\u2032,\u03c1\u2032 \u2297 (lc,\u03c1) n \u2297 wt(\u03b6, \u03b8) \u2297 (rc,\u03c1) n \u2297 rc\u2032,\u03c1\u2032 6= 0\nfor each n \u2208 N, and hence wt(c\u2032 [ cn[\u03b6] ] , \u03c1\u2032 [ \u03c1n[\u03b8] ] ) 6= 0 (using Theorem 6.1.4 again). Since Fq\u2032 6= 0 and B is zero-divisor free, we obtain that\nwt(c\u2032 [ cn[\u03b6] ] , \u03c1\u2032 [ \u03c1n[\u03b8] ] )\u2297 Fq\u2032 6= 0 .\nSince B is zero-sum free, we obtain:\n[[A]]run(c\u2032[cn[\u03b6]] ] ) = \u2295\n\u03bd\u2208RA(\u03be)\nwt(c\u2032 [ cn[\u03b6] ] , \u03bd)\u2297 F\u03bd(\u03b5) 6= 0 .\nThus, for each n \u2208 N, we have that c\u2032[cn[\u03b6]] \u2208 L.\nBy Corollary 3.4.2, supp(Recrun(\u03a3,Boole)) = Rec(\u03a3). Thus, for the case that B is the Boolean semiring, Corollary 6.1.6 shows a slight improvement of the pumping lemma for recognizable tree languages [GS84, Lm. 2.10.1] (because [GS84, Lm. 2.10.1] does not show the condition height ( c[\u03b6] ) < p). Hence in case B = Boole, by using the contraposition of Corollary 6.1.6, we can give a shorter proof of that a certain tree language is not recognizable, than by using [GS84, Lm. 2.10.1]. The contraposition is the following statement:\nLet L \u2286 T\u03a3. If for each p \u2208 N+, there exists \u03be \u2208 L with height(\u03be) \u2265 p such that for every c\u2032, c \u2208 C\u03a3, \u03b6 \u2208 T\u03a3 with \u03be = c\u2032[c[\u03b6]], height(c) > 0, and height ( c[\u03b6] ) < p, there exists an n \u2208 N\nsuch that c\u2032 [ cn[\u03b6] ] 6\u2208 L, then L is not recognizable.\nLet us give an example of this application (cf. [HMU14, Ex. 4.2]).\nExample 6.1.7. We consider the string ranked alphabet \u03a3 = {\u03c3(1), \u03b3(1), \u03b1(0)} and the \u03a3-tree language\nL = {\u03be \u2208 T\u03a3 | |pos\u03b3(\u03be)| = |pos\u03c3(\u03be)|} .\nNow we apply the contraposition of Corollary 6.1.6 (for B = Boole). For this let p \u2208 N+. We consider the tree \u03be = \u03c3p+1\u03b3p+1\u03b1. Clearly, \u03be \u2208 L and height(\u03be) \u2265 p.\nNow we consider an arbitrary decomposition of \u03be of the form \u03be = c\u2032 [ c[\u03b6] ] for some c\u2032, c \u2208 C\u03a3, \u03b6 \u2208 T\u03a3\nsuch that height(c) > 0 and height ( c[\u03b6] ) < p. By our choice of \u03be, we have that c = \u03b3k(z1) for some k \u2265 1 (we recall that height(z1) = 0).\nNow we choose n = 2. Obviously, c\u2032[c2[\u03b6]] contains more \u03b3s than \u03c3s, hence c\u2032[c2[\u03b6]] 6\u2208 L. Hence, by the contraposition of Corollary 6.1.6 (for B = Boole), the tree language L is not recognizable.\nIt will turn out later (when Theorem 18.2.4 is available), that supp(Recrun(\u03a3,B)) = Rec(\u03a3) for each positive semiring B, hence Corollary 6.1.6 is the same slight improvement of the classical pumping lemma for recognizable \u03a3-tree languages [GS84, Lm. 2.10.1] which we described for the case B = Boole."
        },
        {
            "heading": "6.2 Pumping lemma for wta over fields",
            "text": "Here we deal with weighted tree automata over fields and a pumping lemma which guarantees the existence of infinitely many trees in the support of the semantics of such wta. The pumping lemma is based on [Reu80, BR82].\n130 CHAPTER 6. PUMPING LEMMAS\nLet B be a field and (V, \u00b5, \u03b3) be a (\u03a3,B)-multilinear representation with V = (BQ,+, 0\u0303). Then V is a |Q|-dimensional B-vector space. Vice versa, let V be a \u03ba-dimensional B-vector space with \u03ba \u2208 N. According to our convention on representing vector spaces (cf. page 39), we have V = (B\u03ba,+, 0\u03ba). This justifies to use, as first component of a (\u03a3,B)-multilinear representation, also an arbitrary finite dimensional B-vector space V. We will use this point of view in this section.\nIn the rest of this section, we let B be a field and (V, \u00b5, \u03b3) be a (\u03a3,B)-multilinear representation where V = (V,+, 0) is a \u03ba-dimensional B-vector space for some \u03ba \u2208 N+, unless specified otherwise.\nWe recall from Section 3.6.1 that (V, \u00b5) is a \u03a3-algebra and that hV is the unique \u03a3-algebra homomorphism from T\u03a3 to (V, \u00b5). Moreover, (V, \u00b5, \u03b3) recognizes the weighted tree language r : T\u03a3 \u2192 B where r(\u03be) = \u03b3(hV(\u03be)) for every \u03be \u2208 T\u03a3. We also recall that L(V,V) is the set of all linear mappings f : V \u2192 V from V to V."
        },
        {
            "heading": "6.2.1 The set of contexts viewed as monoid",
            "text": "Each tree \u03be can be considered as a sequence c of contexts which are substituted consecutively into each other, and a nullary symbol \u03b1 for turning the resulting context into \u03be. The monoid (C\u03a3, \u25e6z, z) formalizes the substitution of contexts, where we also denote by \u25e6z the restriction of the binary operation \u25e6z on T\u03a3({z}) (cf. page 48) to C\u03a3. In the next lemma we prove that (C\u03a3, \u25e6z, z) is freely generated by comparing it with the monoid ((eC\u03a3) \u2217, \u00b7, \u03b5). In the sequel we abbreviate (eC\u03a3)\u2217 by eC\u2217\u03a3.\nLemma 6.2.1. [BR82, Prop. 9.1] The monoid (C\u03a3, \u25e6z, z) is freely generated by eC\u03a3 over the set of all monoids.\nProof. We prove that the monoid (C\u03a3, \u25e6z, z) is isomorphic to the monoid (eC\u2217\u03a3, \u00b7, \u03b5). Since (eC \u2217 \u03a3, \u00b7, \u03b5) is freely generated by eC\u03a3 over the set of all monoids, this implies the statement of the lemma.\nWe define the mapping \u03c8 : eC\u03a3 \u2192 C\u03a3 with \u03c8(e) = e for each e \u2208 eC\u03a3. Since (eC\u2217\u03a3, \u00b7, \u03b5) is freely generated by eC\u03a3 over the set of all monoids, there exists a unique monoid homomorphism [[.]] : eC \u2217 \u03a3 \u2192 C\u03a3 which extends \u03c8. For each c \u2208 eC\u2217\u03a3, we write [[c]] instead of [[.]](c). Then, for every n \u2208 N+ and e1, . . . , en \u2208 eC\u03a3 we have\n[[e1 \u00b7 \u00b7 \u00b7 en]] = e1 \u25e6z \u00b7 \u00b7 \u00b7 \u25e6z en and [[\u03b5]] = z .\nWe prove that the mapping [[.]] is surjective. For this, by induction on (C\u03a3,\u227aC\u03a3) (cf. page 123), we prove that the following statement holds:\nFor each c \u2208 C\u03a3, we have c \u2208 im([[.]]) . (6.4)\nI.B.: Let c = z. Then the statement holds because [[\u03b5]] = z.\nI.S.: Let c = e[c\u2032] for some e \u2208 eC\u03a3 and c \u2032 \u2208 C\u03a3. By the I.H. we have c \u2032 \u2208 im([[.]]) and thus there exists a d \u2208 eC\u2217\u03a3 such that [[d]] = c \u2032. Since [[ed]] = [[e]] \u25e6z [[d]] = e \u25e6z c\u2032 = c, we have that c \u2208 im([[.]]).\nHence (6.4) holds and [[.]] is surjective.\nFinally, we prove that [[.]] is injective. Let e1, . . . , en \u2208 eC\u03a3 and e\u20321, . . . , e \u2032 m \u2208 eC\u03a3 such that [[e1 \u00b7 \u00b7 \u00b7 en]] =\n[[e\u20321 \u00b7 \u00b7 \u00b7 e \u2032 m]]. Since depth([[e1 \u00b7 \u00b7 \u00b7 en]]) = n and depth([[e \u2032 1 \u00b7 \u00b7 \u00b7 e \u2032 m]]) = m, it follows that n = m. Now assume that there exists i \u2208 [n] such that ei 6= e\u2032i. Then there exists a w \u2208 pos(ei)\u2229pos(e \u2032 i) such that ei(w) 6= e \u2032 i(w). Using this fact, it is easy to see that [[e1 \u00b7 \u00b7 \u00b7 en]] 6= [[e\u20321 \u00b7 \u00b7 \u00b7 e \u2032 m]]. Thus ei = e \u2032 i for each i \u2208 [n]. Hence, [[.]] is injective.\nSo we have proved that [[.]] is an isomorphism from (eC\u2217\u03a3, \u00b7, \u03b5) to (C\u03a3, \u25e6z, z).\n6.2. PUMPING LEMMA FOR WTA OVER FIELDS 131\nEach context c \u2208 C\u03a3 determines a linear mapping in the following way. We define the mapping \u03b8 : eC\u03a3 \u2192 L(V,V) for every e \u2208 eC\u03a3 and v \u2208 V by\n(\u03b8(e))(v) = \u00b5(\u03c3)(hV(\u03be1), . . . , hV(\u03bei\u22121), v, hV(\u03bei+1), . . . , hV(\u03bek)) ,\nif e has the form \u03c3(\u03be1, . . . , \u03bei\u22121, z, \u03bei+1, . . . , \u03bek). Then \u03b8(e) is an endomorphism on V because \u00b5(\u03c3) is multilinear.\nBy Lemma 6.2.1, the monoid (C\u03a3, \u25e6z, z) is freely generated by eC\u03a3. Thus there exists a unique monoid homomorphism L.M from the monoid (C\u03a3, \u25e6z, z) to the monoid (L(V,V), \u25e6, idV )) which extends \u03b8. Instead of L.M(c) we write LcM for each c \u2208 C\u03a3.\nIn the next example we illustrate the evaluation of LcM(v) for a multilinear representation which is related to a particular (\u03a3,Rat)-wta. Before that, we would like to discuss a phenomenon: the reversing of the roles of rows and columns when starting from weighted string automata and moving towards multilinear representations.\nLet A = (Q, \u03bb, \u00b5, \u03c4) be a (\u0393,B)-wsa (where we have used untypically \u03c4 as final weight mapping because we use \u03b3 as part of the multilinear representation). Then by Lemma 3.3.1 we have hA(w) = \u03bb \u00b7 \u00b5(w) for each w \u2208 \u0393\u2217. For instance, let \u0393 = {a, b}. Since \u00b5 is a monoid homomorphism, we have\n\u03bb \u00b7 \u00b5(abb) = \u03bb \u00b7 \u00b5(a) \u00b7 \u00b5(b) \u00b7 \u00b5(b) .\nThe intuition behind the matrix, say, \u00b5(a), is that, for each row q \u2208 Q and each column p \u2208 Q, the value \u00b5(a)q,p is the weight of the transition from state q to state p when reading a.\nNow we might turn A into the related (\u0393e,B)-wta B (using treee and Lemma 3.3.3) and then we can look at the (\u0393e,B)-multilinear representation which is related to B (cf. Figure 6.3). When turning A into B, the string abb is turned into the tree b(b(a(e))). Obviously, when reading the string b(b(a(e))) from left to right, the order of a and the b\u2019s is reversed with respect to the order of these symbols in the string abb. Hence, the order of the matrices \u00b5(a) and \u00b5(b) is also reversed. In order to keep the correct value, the matrices \u00b5(a) and \u00b5(b) have to be transposed. (Since we do not distinguish between row- and column-vectors, we do not have to transpose \u03bb.) Thus,\n\u03bb \u00b7 \u00b5(a) \u00b7 \u00b5(b) \u00b7 \u00b5(b) = \u00b5(b)T \u00b7 \u00b5(b)T \u00b7 \u00b5(a)T \u00b7 \u03bb = Lb(z)M(Lb(z)M(La(z)M(\u03bb))) ,\nwhere the linear mappings La(z)M and Lb(z)M are represented by the matrices \u00b5(a)T and \u00b5(b)T, respectively. In particular, an entry (\u00b5(b)T)q,p shows the transition weight on the elementary context b(z) when starting at the z-labeled leaf in the q-column of \u00b5(b) and ending at the b-labeled root in the p-row of \u00b5(b). In this sense the order of rows and columns is reversed.\nExample 6.2.2. Here we consider the mapping #\u03c3(.,\u03b1) : T\u03a3 \u2192 N and the (\u03a3,Nat)-wta A as defined in Example 3.2.11 with two slight modifications. One modification is that we replace in \u03a3 the unary symbol \u03b3 \u2208 \u03a3(1) by the unary symbol \u03c9 because we use \u03b3 as part of the multilinear representation. The other modification is that we view A as a (\u03a3,Rat)-wta, which is possible because Rat is an extension of Nat (cf. Section 3.7). Thus, \u03a3 = {\u03c3(2), \u03c9(1), \u03b1(0)} and\n#\u03c3(.,\u03b1) : T\u03a3 \u2192 Q\n\u03be 7\u2192 |U(\u03be)| for every \u03be \u2208 T\u03a3\nwhere U(\u03be) = {u \u2208 pos(\u03be) | \u03be(u) = \u03c3, \u03be(u2) = \u03b1}. We recall that A = (Q, \u03b4, F ), where\n\u2022 Q = {\u22a5, a, f} (intuitively, \u22a5 ignores occurrences of the pattern, a detects an \u03b1-labeled leaf, and f reports \u201cpattern found\u201d up to the root), \u2022 for every q1, q2, q \u2208 Q we define\n\u03b40(\u03b5, \u03b1, q) = { 1 if q \u2208 {\u22a5, a} 0 otherwise \u03b41(q1, \u03c9, q) = { 1 if q1q \u2208 {\u22a5\u22a5, ff} 0 otherwise\n\u03b42(q1q2, \u03c3, q) = { 1 if q1q2q \u2208 {\u22a5\u22a5\u22a5,\u22a5af,\u22a5ff, f\u22a5f} 0 otherwise\n\u2022 F\u22a5 = Fa = 0 and Ff = 1.\nNow we define the (\u03a3,Rat)-multilinear representation (V, \u03b4A, \u03b3) where \u2022 V = (QQ,+, 03) is a Rat-vector space, where the components of each v \u2208 QQ are ordered according to the sequence (\u22a5, a, f), and 03 = (0, 0, 0) and \u2022 \u03b3(v) = vf .\nThen (V, \u03b4A, \u03b3) and A are related. Hence, by Lemma 3.6.5, for each \u03be \u2208 T\u03a3, we have hA(\u03be) = hV(\u03be) and [[A]]init(\u03be) = \u03b3(hA(\u03be)) = #\u03c3(.,\u03b1)(\u03be).\nFor each \u03b6 \u2208 C\u03a3, we define the (Q \u00d7Q)-matrix :\nM\u03b6 =\n \n1 0 0 0 a(\u03b6) 0 #\u03c3(.,\u03b1)(\u03b6) b(\u03b6) 1\n \nwhere\n(a) the rows and columns are ordered according to the sequence (\u22a5, a, f), (b) we have extended #\u03c3(.,\u03b1) in the obvious way such that it is also applicable to contexts, and (c) a(\u03b6) = 1 if \u03b6 = z, and 0 otherwise; and b(\u03b6) = 1 if there exists a position w \u2208 pos(\u03b6) such that\nz = \u03b6(w2), and 0 otherwise.\nIntuitively, for each q, p \u2208 Q, the entry (M\u03b6)q,p is the sum of the weights of all (q, p)-runs of A on \u03b6. In particular, Mz = M1.\nIn Figure 6.4 we illustrate the evaluation of L\u03b6M(v) for \u03b6 = \u03c3(\u03c3(\u03c3(\u03b1, z), \u03b1), \u03b1) and v = (1, 0, 2) (where, e.g., (1, 0, 2) = hA(\u03be) with \u03be = \u03c3(\u03c3(\u03b1, \u03b1), \u03b1)).\nBy induction on (C\u03a3,\u227aC\u03a3), we prove that the following statement holds:\nFor each \u03b6 \u2208 C\u03a3 and v \u2208 Q Q, we have L\u03b6M(v) =M\u03b6 \u00b7 v . (6.5)\nI.B.: Let \u03b6 = z and v \u2208 QQ. Then L\u03b6M(v) = LzM(v) = idQQ(v) = v =M\u03b6 \u00b7 v.\nI.S.: Let \u03b6 = e[\u03b6\u2032] for some e \u2208 eC\u03a3 and \u03b6\u2032 \u2208 C\u03a3. Let e = \u03c3(z, \u03be) for some \u03be \u2208 T\u03a3. Using the I.H., we obtain:\nL\u03b6M(v) = Le[\u03b6\u2032]M(v) = LeM(L\u03b6\u2032M(v)) = LeM(M\u03b6\u2032 \u00b7 v) = \u03b4A(\u03c3)(M\u03b6\u2032 \u00b7 v, hA(\u03be)) .\n6.2. PUMPING LEMMA FOR WTA OVER FIELDS 133\nWe recall that, by (3.19), for each \u03be \u2208 T\u03a3, we have hA(\u03be)\u22a5 = 1, hA(\u03be)a = c(\u03be) and hA(\u03be)f = #\u03c3(.,\u03b1)(\u03be), where c(\u03be) = 1 if \u03be = \u03b1 and c(\u03be) = 0 otherwise. Then we obtain:\nL\u03b6M(v)\u22a5 = \u03b4A(\u03c3)(M\u03b6\u2032 \u00b7 v, hA(\u03be))\u22a5 = (M\u03b6\u2032 \u00b7 v)\u22a5 \u00b7 hA(\u03be)\u22a5 \u00b7 1 = v\u22a5 = (M\u03b6 \u00b7 v)\u22a5\nL\u03b6M(v)a = \u03b4A(\u03c3)(M\u03b6\u2032 \u00b7 v, hA(\u03be))a = 0 = (M\u03b6 \u00b7 v)a (the last equality holds because a(\u03b6) = 0)\nL\u03b6M(v)f = \u03b4A(\u03c3)(M\u03b6\u2032 \u00b7 v, hA(\u03be))f\n= (M\u03b6\u2032 \u00b7 v)\u22a5 \u00b7 hA(\u03be)a + (M\u03b6\u2032 \u00b7 v)\u22a5 \u00b7 hA(\u03be)f + (M\u03b6\u2032 \u00b7 v)f \u00b7 hA(\u03be)\u22a5\n= (M\u03b6\u2032 \u00b7 v)\u22a5 \u00b7 (c(\u03be) + #\u03c3(.,\u03b1)(\u03be)) + (M\u03b6\u2032 \u00b7 v)f\n=\n   \n1 0 0 0 0 0\nc(\u03be) + #\u03c3(.,\u03b1)(\u03be) 0 1\n  \u00b7 (M\u03b6\u2032 \u00b7 v)   f\n= (Me \u00b7 (M\u03b6\u2032 \u00b7 v))f = (\u2217) ((Me \u00b7M\u03b6\u2032) \u00b7 v)f = (Me[\u03b6\u2032] \u00b7 v)f = (M\u03b6 \u00b7 v)f ,\nwhere we have used (2.17) at the equality marked by (\u2217) (note that Q is distributive).\nNow let e = \u03c3(\u03be, z) for some \u03be \u2208 T\u03a3. Using the I.H., we obtain:\nL\u03b6M(v) = Le[\u03b6\u2032]M(v) = LeM(L\u03b6\u2032M(v)) = LeM(M\u03b6\u2032 \u00b7 v) = \u03b4A(\u03c3)(hA(\u03be),M\u03b6\u2032 \u00b7 v) .\nThen, using (3.19), we obtain:\nL\u03b6M(v)\u22a5 = \u03b4A(\u03c3)(hA(\u03be),M\u03b6\u2032 \u00b7 v)\u22a5 = hA(\u03be)\u22a5 \u00b7 (M\u03b6\u2032 \u00b7 v)\u22a5 \u00b7 1 = v\u22a5 = (M\u03b6 \u00b7 v)\u22a5\nL\u03b6M(v)a = \u03b4A(\u03c3)(hA(\u03be),M\u03b6\u2032 \u00b7 v)a = 0 = (M\u03b6 \u00b7 v)a (because a(\u03b6) = 0)\nL\u03b6M(v)f = \u03b4A(\u03c3)(hA(\u03be),M\u03b6\u2032 \u00b7 v)f\n= hA(\u03be)\u22a5 \u00b7 (M\u03b6\u2032 \u00b7 v)a + hA(\u03be)\u22a5 \u00b7 (M\u03b6\u2032 \u00b7 v)f + hA(\u03be)f \u00b7 (M\u03b6\u2032 \u00b7 v)\u22a5\n134 CHAPTER 6. PUMPING LEMMAS\n=\n   \n1 0 0 0 0 0 #\u03c3(.,\u03b1)(\u03be) 1 1\n  \u00b7 (M\u03b6\u2032 \u00b7 v)   f\n= (Me \u00b7 (M\u03b6\u2032 \u00b7 v))f = (\u2217) ((Me \u00b7M\u03b6\u2032) \u00b7 v)f = (Me[\u03b6\u2032] \u00b7 v)f = (M\u03b6 \u00b7 v)f ,\nwhere, again, we have used (2.17) at the equality marked by (\u2217).\nNow let e = \u03c9(z). Using the I.H., we obtain:\nL\u03b6M(v) = Le[\u03b6\u2032]M(v) = LeM(L\u03b6\u2032M(v)) = LeM(M\u03b6\u2032 \u00b7 v) = \u03b4A(\u03c9)(M\u03b6\u2032 \u00b7 v) .\nThen we obtain:\nL\u03b6M(v)\u22a5 = \u03b4A(\u03c9)(M\u03b6\u2032 \u00b7 v)\u22a5 = (M\u03b6\u2032 \u00b7 v)\u22a5 \u00b7 1 = (M\u03b6\u2032 \u00b7 v)\u22a5\n=     1 0 0 0 0 0 0 0 1   \u00b7 (M\u03b6\u2032 \u00b7 v)  \n\u22a5\n= (Me \u00b7 (M\u03b6\u2032 \u00b7 v))\u22a5 = (\u2217) ((Me \u00b7M\u03b6\u2032) \u00b7 v)\u22a5 = (Me[\u03b6\u2032] \u00b7 v)\u22a5 = (M\u03b6 \u00b7 v)\u22a5 ,\nL\u03b6M(v)a = \u03b4A(\u03c9)(M\u03b6\u2032 \u00b7 v)a = 0 = (M\u03b6 \u00b7 v)a (because a(\u03b6) = 0)\nL\u03b6M(v)f = \u03b4A(\u03c9)(M\u03b6\u2032 \u00b7 v)f = (M\u03b6\u2032 \u00b7 v)f = (Me \u00b7 (M\u03b6\u2032 \u00b7 v))f = (M\u03b6 \u00b7 v)f ,\nwhere, again, we have used (2.17) at the equality marked by (\u2217).\nThis proves (6.5).\nLemma 6.2.3. For every c \u2208 C\u03a3 and \u03be \u2208 T\u03a3, we have LcM(hV(\u03be)) = hV(c[\u03be]).\nProof. We prove this statement by induction on (C\u03a3,\u227aC\u03a3).\nI.B.: Let c = z. Then the statement is obvious because LzM is the identity mapping on v.\nI.S.: Now let c = e[c\u2032], where e = \u03c3(\u03be1, . . . , \u03bei\u22121, z, \u03bei+1, . . . , \u03bek) is an elementary \u03a3-context and c\u2032 \u2208 C\u03a3. Then, for each \u03be \u2208 T\u03a3, we have\nLcM(hV(\u03be)) = LeM(Lc \u2032M(hV(\u03be))) (because L.M is a monoid homomorphism)\n= \u03b8(e)(Lc\u2032M(hV(\u03be))) (because L.M extends \u03b8) = \u00b5(\u03c3)(hV(\u03be1), . . . , hV(\u03bei\u22121), Lc \u2032M(hV(\u03be)), hV(\u03bei+1), . . . , hV(\u03bek)) = \u00b5(\u03c3)(hV(\u03be1), . . . , hV(\u03bei\u22121), hV(c \u2032[\u03be]), hV(\u03bei+1), . . . , hV(\u03bek)) (by I.H) = hV(\u03c3(\u03be1, . . . , \u03bei\u22121, c \u2032[\u03be], \u03bei+1, . . . , \u03bek))\n= hV(c[\u03be]) ."
        },
        {
            "heading": "6.2.2 Linear recurrence equation",
            "text": "Weighted tree languages that are recognizable over multilinear operations by a vector space satisfy a particular linear recurrence equation. In the following lemma, for a context \u03b6 \u2208 C\u03a3, we view L\u03b6M \u2208 L(V,V) as an element of B\u03ba\u00d7\u03ba, i.e., as a [\u03ba]-square matrix over B (cf. page 39). We recall that the characteristic polynomial of such a L\u03b6M is charL\u03b6M(x) = det(L\u03b6M\u2212 xM1) (cf. page 37).\nLemma 6.2.4. Let \u03a3 be a ranked alphabet, B = (B,\u2295,\u2297, 0, 1) be a field, V be a \u03ba-dimensional B-vector space, and r : T\u03a3 \u2192 B. Let (V, \u00b5, \u03b3) be a (\u03a3,B)-multilinear representation which recognizes r. Moreover, let \u03b6 \u2208 C\u03a3 and let charL\u03b6M(x) = (\u22121)\n\u03ba\u2297 x\u03ba \u2295 b1\u2297 x\u03ba\u22121 \u2295 \u00b7 \u00b7 \u00b7 \u2295 b\u03ba. Then, for every \u03b8 \u2208 C\u03a3, \u03b1 \u2208 \u03a3(0), and n \u2208 N, we have\n(\u22121)\u03ba \u2297 r(\u03b8[\u03b6n+\u03ba[\u03b1]])\u2295 b1 \u2297 r(\u03b8[\u03b6 n+\u03ba\u22121[\u03b1]])\u2295 \u00b7 \u00b7 \u00b7 \u2295 b\u03ba \u2297 r(\u03b8[\u03b6 n[\u03b1]]) = 0 .\n6.2. PUMPING LEMMA FOR WTA OVER FIELDS 135\nProof. For the sake of brevity we write charL\u03b6M(x) = \u2295 i\u2208[0,\u03ba] b\u03ba\u2212i \u2297 x i where we let b0 = (\u22121)\u03ba.\nBy Theorem 2.7.1 (i.e., the theorem of Cayley and Hamilton), we have charL\u03b6M(L\u03b6M) = M0. Now let \u03b8 \u2208 C\u03a3, \u03b1 \u2208 \u03a3(0), and n \u2208 N. Then we can calculate as follows (where we abbreviate by v0 the [\u03ba]-vector in B\u03ba with 0 in each of its entries):\ncharL\u03b6M(L\u03b6M) = M0\n\u21d2 + i\u2208[0,\u03ba] b\u03ba\u2212i \u00b7 L\u03b6M i = M0 (we use + because b\u03ba\u2212i \u00b7 L\u03b6M i is a matrix) \u21d2 (+ i\u2208[0,\u03ba] b\u03ba\u2212i \u00b7 L\u03b6M i ) \u00b7 hV(\u03b1) = v0 (matrix-vector multiplication with hV(\u03b1)) \u21d2 L\u03b8[\u03b6n]M \u00b7 (+ i\u2208[0,\u03ba] b\u03ba\u2212i \u00b7 L\u03b6M i ) \u00b7 hV(\u03b1) = v0 (matrix-vector multiplication with L\u03b8[\u03b6n]M) \u21d2 (+ i\u2208[0,\u03ba] b\u03ba\u2212i \u00b7 L\u03b8[\u03b6 n]M \u00b7 L\u03b6Mi \u00b7 hV(\u03b1) ) = v0 (because L\u03b8[\u03b6 n]M is a linear mapping) \u21d2 (+ i\u2208[0,\u03ba] b\u03ba\u2212i \u00b7 L\u03b8[\u03b6 n+i]M \u00b7 hV(\u03b1) ) = v0 (because L.M is a monoid homomorphism) \u21d2 (+ i\u2208[0,\u03ba] b\u03ba\u2212i \u00b7 hV(\u03b8[\u03b6 n+i[\u03b1]]) ) = v0 (by Lemma 6.2.3) \u21d2 \u03b3 (+ i\u2208[0,\u03ba] b\u03ba\u2212i \u00b7 hV(\u03b8[\u03b6 n+i[\u03b1]]) ) = 0 (by applying the linear form \u03b3 to both sides) \u21d2 \u2295\ni\u2208[0,\u03ba]\nb\u03ba\u2212i \u2297 \u03b3(hV(\u03b8[\u03b6 n+i[\u03b1]])) = 0 (because \u03b3 is a linear form)\n\u21d2 \u2295\ni\u2208[0,\u03ba]\nb\u03ba\u2212i \u2297 r(\u03b8[\u03b6 n+i[\u03b1]]) = 0 (because (V, \u00b5, \u03b3) recognizes r)\nExample 6.2.5. We continue with Example 6.2.2 and compute the characteristic polynomial of L\u03b6M for each context \u03b6. This characteristic polynomial has the following form:\n\u2022 if \u03b6 6= z, then a(\u03b6) = 0 and charL\u03b6M(x) = \u2212x 3 + 2x2 \u2212 x and \u2022 if \u03b6 = z, then a(\u03b6) = 1 and charL\u03b6M(x) = \u2212x 3 + 3x2 \u2212 3x+ 1.\nThen, due to Lemma 6.2.4, we obtain the following linear recurrence equation for #\u03c3(.,\u03b1). For every \u03b8, \u03b6 \u2208 C\u03a3 with \u03b6 6= z and every n \u2208 N we have\n#\u03c3(.,\u03b1)(\u03b8[\u03b6 n+3[\u03b1]]) = 2 \u00b7#\u03c3(.,\u03b1)(\u03b8[\u03b6 n+2[\u03b1]]) \u2212#\u03c3(.,\u03b1)(\u03b8[\u03b6 n+1[\u03b1]]) .\nIn the following corollary, height : T\u03a3 \u2192 N is the weighted tree language defined in Example 3.2.4.\nCorollary 6.2.6. [BR82, Ex. 9.2] For the ranked alphabet \u03a3 = {\u03c3(2), \u03b1(0)}, we have that height 6\u2208 Rec(\u03a3,Real).\nProof. We prove by contradiction. For this we assume that there exists a (\u03a3,Real)-multilinear representation (V, \u00b5, \u03b3) such that height(\u03be) = \u03b3(hV(\u03be)) for each \u03be \u2208 T\u03a3. Let V be \u03ba-dimensional for some \u03ba \u2208 N.\nLet \u03be \u2208 T\u03a3 be a tree with height(\u03be) = \u03ba. Due to the definition of \u03a3 such a \u03be exists. We consider the two elementary \u03a3-contexts \u03b8 = \u03c3(z, \u03be) and \u03b6 = \u03c3(z, \u03b1). For each n \u2208 N we define the tree \u03ben = \u03b8[\u03b6n[\u03b1]] in T\u03a3. Then\nheight(\u03ben) = 1 +max(n, \u03ba) for every n \u2208 N .\n136 CHAPTER 6. PUMPING LEMMAS\nBy Lemma 6.2.4, there exist b1, . . . , b\u03ba \u2208 R such that\n(\u22121)\u03ba \u00b7 height(\u03ben+\u03ba) + b1 \u00b7 height(\u03ben+\u03ba\u22121) + \u00b7 \u00b7 \u00b7+ b\u03ba \u00b7 height(\u03ben) = 0 for every n \u2208 N. (6.6)\nBy using (6.6) for n = 0 and n = 1, we obtain\n(\u22121)\u03ba \u00b7 (1 + \u03ba) + b1 \u00b7 (1 + \u03ba) + \u00b7 \u00b7 \u00b7+ b\u03ba \u00b7 (1 + \u03ba) = 0 , and (6.7)\n(\u22121)\u03ba \u00b7 (1 + (\u03ba+ 1)) + b1 \u00b7 (1 + \u03ba) + \u00b7 \u00b7 \u00b7+ b\u03ba \u00b7 (1 + \u03ba) = 0 , (6.8)\nrespectively. Then Equations (6.7) and (6.8) imply that \u03ba = \u03ba+ 1 which is a contradiction.\nIt follows that, for \u03a3 = {\u03c3(2), \u03b1(0)} and any strong bimonoid B such that Real is an extension of B, the weighted tree language height is not recognizable by any (\u03a3,B)-wta (cf. Observation 3.7.1). In particular, height is not recognizable by any (\u03a3,Rat)-wta and (\u03a3,Nat)-wta. Recall that, at the same time, there is a (\u03a3,Natmax,+)-wta which recognizes height (cf. Example 3.2.4)."
        },
        {
            "heading": "6.2.3 The pumping lemma",
            "text": "Lemma 6.2.1 justifies to use the following theorem and lemma from [Reu80] (using A = eC\u03a3). We will use the fact that a matrix M \u2208 B\u03ba\u00d7\u03ba is pseudo-regular if and only if x2 does not divide its characteristic polynomial charM (cf. [Reu80, Prop. 1]). We do not show the proof of this statement.\nTheorem 6.2.7. [Reu80, Thm. 3] Let \u03ba \u2208 N+. There exists N \u2208 N such that for every set A, monoid homomorphism \u00b5 : A\u2217 \u2192 B\u03ba\u00d7\u03ba, string w \u2208 A\u2217 of length at least N , the string w has a factor v 6= \u03b5 such that \u00b5(v) is a pseudo-regular matrix.\nLemma 6.2.8. [Reu80, Lm. 1] Let \u03ba \u2208 N+, M \u2208 B\u03ba\u00d7\u03ba, and \u03bb, \u03b3 \u2208 B\u03ba. If M is pseudo-regular and \u03bb \u00b7M \u00b7 \u03b3 6= 0, then there exist infinitely many n \u2208 N such that \u03bb \u00b7Mn \u00b7 \u03b3 6= 0.\nProof. Let charM (x) = (\u22121) \u03ba \u2297 x\u03ba \u2295 b1 \u2297 x \u03ba\u22121 \u2295 \u00b7 \u00b7 \u00b7 \u2295 b\u03ba\u22121 \u2297 x\u2295 b\u03ba .\nBy our assumption b\u03ba\u22121 6= 0 or b\u03ba 6= 0. Let us abbreviate \u03bb \u00b7Mn \u00b7 \u03b3 by an for each n \u2208 N. We show that, for each n \u2208 N, if an 6= 0, then there exists m > n such that am 6= 0. Since a1 6= 0, this proves the lemma.\nLet n \u2208 N and assume that an 6= 0. In addition, assume that b\u03ba 6= 0. By Theorem 2.7.1, we have\n(\u22121)\u03ba \u2297 an+\u03ba \u2295 b1 \u2297 an+\u03ba\u22121 \u2295 \u00b7 \u00b7 \u00b7 \u2295 b\u03ba\u22121 \u2297 an+1 \u2295 b\u03ba \u2297 an = 0 .\nThen am 6= 0 for some m \u2208 [n + 1, n+ \u03ba]. Now assume that b\u03ba = 0 and b\u03ba\u22121 6= 0. By our assumption \u03ba > 1 and by Theorem 2.7.1, we have\n(\u22121)\u03ba \u2297 an+\u03ba\u22121 \u2295 b1 \u2297 an+\u03ba\u22122 \u2295 \u00b7 \u00b7 \u00b7 \u2295 b\u03ba\u22121 \u2297 an = 0 .\nThen am 6= 0 for some m \u2208 [n+ 1, n+ \u03ba\u2212 1].\nLet \u03be \u2208 T\u03a3, c \u2208 C\u03a3, and \u03b1 \u2208 \u03a3(0). The pair (c, \u03b1) is a walk in \u03be if \u03be = c[\u03b1]. The depth of (c, \u03b1) is depth(c). Let c \u2208 C\u03a3. We recall that c0 = z, and for every n \u2208 N, we have cn+1 = c[cn].\nTheorem 6.2.9. [BR82, Thm. 9.2] Let \u03a3 be a ranked alphabet, B be a field, and r \u2208 Rec(\u03a3,B). There exists a constant N \u2208 N such that for every \u03be \u2208 supp(r) and every walk (c, \u03b1) in \u03be of depth at least N , there exist c1, c2, c3 \u2208 C\u03a3 such that c2 6= z, c = c1\u25e6zc2\u25e6zc3, and the set {(c1\u25e6zcn2 \u25e6zc3)[\u03b1] | n \u2208 N}\u2229supp(r) is infinite.\n6.2. PUMPING LEMMA FOR WTA OVER FIELDS 137\nProof. By Theorem 3.6.6 there exists a (\u03a3,B)-multilinear representation (V, \u00b5, \u03b3) where V = (V,+, 0) is a \u03ba-dimensional B-vector space for some \u03ba \u2208 N and\nr(\u03be) = \u03b3(hV(\u03be)) for each \u03be \u2208 T\u03a3 . (6.9)\nSince the two monoids (B\u03ba\u00d7\u03ba, \u00b7,M1) and (L(V,V), \u25e6, id) are isomorphic (cf Section 2.8), we identify them.\nThen we can apply Theorem 6.2.7. Let N \u2208 N be the integer from that theorem. Moreover, let \u03be \u2208 supp(r) and (c, \u03b1) be a walk of \u03be of depth at least N . By Theorem 6.2.7, there exists c1, c2, c3 \u2208 C\u03a3 such that c = c1 \u25e6z c2 \u25e6z c3 with c2 6= z and Lc2M is a pseudo-regular endomorphism. In particular, we have \u03be = c1[c2[c3[\u03b1]]].\nFor each n \u2208 N we define the element un \u2208 B by\nun = \u03b3(Lc1M(Lc2M n(Lc3M(hV(\u03b1)))) .\nIn particular,\nu1 = \u03b3(Lc1M(Lc2M(Lc3M(hV(\u03b1)))) = \u03b3(hV(c1[c2[c3[(\u03b1)]]]))) = r(c1[c2[c3[(\u03b1)]]]) = r(\u03be) 6= 0\nwhere the second and third equality are due to Lemma 6.2.3 and (6.9), respectively.\nThus, we can apply Lemma 6.2.8 (usingM = Lc2M and \u03bb = Lc3M\u00b7hV(\u03b1)) and hence, there exist infinitely many n such that un 6= 0.\nSince un = r(c1[c n 2 [c3[(\u03b1)]]]) (by a similar calculation as for u1), we obtain the statement of the\ntheorem.\nTheorem 6.2.9 can be used to show that certain tree languages cannot be the support of recognizable B-weighted tree languages.\nCorollary 6.2.10. Let \u03a3 = {\u03b3(1), \u03c3(1), \u03b1(0)}. For each field B, the tree language L = {\u03c3n\u03b3n(\u03b1) | n \u2265 0} is not in supp(Rec(\u03a3,B)).\nProof. Let B be a field. We continue to prove by contradiction. For this, we assume that there exists an r \u2208 Rec(\u03a3,B) such that L = supp(r). Let N be the number for r appearing in Theorem 6.2.9 and consider the tree \u03be = \u03c3N\u03b3N(\u03b1) and the walk (c, \u03b1) in \u03be, where c = \u03c3N\u03b3N (z). By Theorem 6.2.9, there exist c1, c2, c3 \u2208 C\u03a3 such that c2 6= z, c = c1 \u25e6z c2 \u25e6z c3 and the set {(c1 \u25e6z cn2 \u25e6z c3)[\u03b1] | n \u2208 N} \u2229 L is infinite. On the other hand, for any decomposition c = c1 \u25e6z c2 \u25e6z c3 of c with c2 6= z we have {(c1\u25e6z cn2 \u25e6z c3)[\u03b1] | n \u2208 N}\u2229L \u2286 {(c1\u25e6z c3)[\u03b1], \u03be}. This is a contradiction, hence L 6\u2208 supp(Rec(\u03a3,B)).\nBy similar arguments as in Corollary 6.2.10, we can show that the tree language FB is not in supp(Rec(\u03a3,B)). The tree language FB of fully balanced trees over {\u03c3(2), \u03b1(0)} is the smallest \u03a3-tree language L satisfying (i) \u03b1 \u2208 L, and (ii) \u03c3(\u03be, \u03be) \u2208 L for each \u03be \u2208 L.\n138 CHAPTER 6. PUMPING LEMMAS\nChapter 7\nNormal forms of wta\nIn this chapter we prove some useful normal forms of wta. More precisely, we define several useful properties which a given wta either has or does not have. Then, for each of these properties, we show that, under some conditions on the weight algebra, any given wta can be transformed into an equivalent wta which has this property. In this sense, the given wta is turned into a normal form. Sometimes normal forms of wta are useful for reducing the complexity of proofs which start from a given wta.\nWe deal with the following properties: trim, total, root weight normalized, and identity transition weights."
        },
        {
            "heading": "7.1 Trimming a wta",
            "text": "In this section we elaborate two trimming methods for wta. Intuitively, a trimming method takes a wta as input and constructs a run equivalent trim wta as output. A wta is trim if it contains only useful states, i.e., states which occur in a successful run on some input tree.\nIn the literature trimming methods are known for finite-state automata [Sak09, Prop. 1.9], context-free grammars [Har78, Thm. 3.2.3], regular tree grammars [CDG+07, Prop. 2.1.3] and [Dre06, Lm. A.2.6], fta [Sei89, Prop. 1.1], weighted string automata over semirings [Sak09, p. 408], and wta over strong bimonoids [DFKV22, Thm. 4.2]. Except for the last two shown references, each of them deals with the unweighted case.\nOur first trimming method is applicable to wta over zero-cancellation free strong bimonoids and it leads to a \u201cstrong form\u201d of trim wta. Our second method is applicable to wta over arbitrary strong bimonoids and it leads to a \u201cweak form\u201d of trim wta. We start by defining some useful concepts."
        },
        {
            "heading": "7.1.1 Basic definitions",
            "text": "Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. Let q \u2208 Q, \u03be \u2208 T\u03a3, and \u03c1 \u2208 RA(q, \u03be). We say that\n\u2022 \u03c1 is successful if wt(\u03be, \u03c1)\u2297 Fq 6= 0, \u2022 \u03c1 is local-successful if (a) for each v \u2208 pos(\u03be) we have \u03b4k(\u03c1(v1) \u00b7 \u00b7 \u00b7 \u03c1(vk), \u03be(v), \u03c1(v)) 6= 0 where k = rk\u03a3(\u03be(v)) and (b) Fq 6= 0.\nLet p \u2208 Q. We say that\n\u2022 p is useful if there exist q \u2208 Q, \u03be \u2208 T\u03a3, and a successful run \u03c1 \u2208 RA(q, \u03be) such that p \u2208 im(\u03c1). \u2022 p is local-useful if there exist q \u2208 Q, \u03be \u2208 T\u03a3, and a local-successful run \u03c1 \u2208 RA(q, \u03be) such that p \u2208 im(\u03c1). \u2022 p is accessible if there exist \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(p, \u03be) such that wt(\u03be, \u03c1) 6= 0.\n139\n\u2022 p is local-accessible if there exist \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(p, \u03be) such that, for each v \u2208 pos(\u03be), we have \u03b4k(\u03c1(v1) \u00b7 \u00b7 \u00b7 \u03c1(vk), \u03be(v), \u03c1(v)) 6= 0 where k = rk\u03a3(\u03be(v)). \u2022 p is co-accessible if there exist q \u2208 Q, a context c \u2208 C\u03a3, and a run \u03c1 \u2208 RA(q, c, p) such that wt(c, \u03c1)\u2297 Fq 6= 0. \u2022 p is weakly useful if it is accessible and co-accessible.\nClearly, useful implies weakly useful, and weakly useful implies local-useful. Moreover, if B is zerodivisor free, then the three notions are equivalent; thus, in particular, this holds if B is the Boolean semiring Boole.\nA (\u03a3,B)-wta A is called trim if each of its states is useful; in a similar way, we define weak-trim and local-trim by employing weakly useful and local-useful, respectively. We note that the notions of trim in [Sak09] and in [DFKV22] correspond to the notions weak-trim and local-trim, respectively. In the next observation we formally compare the different trim properties (cf. Figure 7.1).\nObservation 7.1.1. The following five statements hold.\n(1) Each trim (\u03a3,B)-wta is weak-trim, and each weak-trim (\u03a3,B)-wta is local-trim. (2) There exist a trivial ranked alphabet \u03a3 and a (\u03a3,B)-wta A such that [[A]]run 6= 0\u0303 and A is not\nlocal-trim. (3) There exist a string ranked alphabet \u03a3, a strong bimonoid B, and a local-trim (\u03a3,B)-wta which is\nnot weak-trim. (4) There exist a string ranked alphabet \u03a3, a strong bimonoid B, and a weak-trim (\u03a3,B)-wta which is\nnot trim. (5) If B is zero-divisor free, then for each (\u03a3,B)-wta A we have: A is trim iff A is weak-trim iff A is\nlocal-trim.\nProof. Statements (1) and (5) are obvious.\nProof of Statement (2): We consider the ranked alphabet \u03a3 = {\u03b1(0)} and the (\u03a3,B)-wta A = (Q, \u03b4, F ), where Q = {q, p}, \u03b4(\u03b5, \u03b1, q) = 1, \u03b4(\u03b5, \u03b1, p) = 0, and Fq = 1 and Fp = 0. Then [[A]]run(\u03b1) = 1, i.e., [[A]]run 6= 0\u0303. We note that p is not local-useful and hence A is not local-trim.\nProof of Statement (3): We consider the string ranked alphabet \u03a3 = {\u03b3(1), \u03b1(0)} and the ring Intmod4 = ({0, 1, 2, 3},+4, \u00b74, 0, 1) defined in Example 2.6.9(5). This Intmod4 is not zero-divisor free because 2 \u00b74 2 = 0.\nThen we let A = (Q, \u03b4, F ) be the (\u03a3, Intmod4)-wta with Q = {q, q1, p, q2} and for each f, g \u2208 Q we define\n\u03b40(\u03b5, \u03b1, f) =\n{ 1 if f = q\n0 otherwise and \u03b41(f, \u03b3, g) =\n{ 2 if fg \u2208 {qq1, q1p, pq2, q2q}\n0 otherwise\nand Fq = 1 and Fq1 = Fp = Fq2 = 0. Then each f \u2208 Q is local-useful and hence A is local-trim. The state q is weakly useful. The state q1 is accessible; p and q2 are not accessible; q2 is co-accessible; p and q1 are not co-accessible. Hence A is not weak-trim.\nProof of Statement (4): We consider the ranked alphabet \u03a3 and the semiring Intmod4 as in the proof of Statement (3).\n7.1. TRIMMING A WTA 141\nThen we let A = (Q, \u03b4, F ) be the (\u03a3, Intmod4)-wta with Q = {q, p} and for each f, g \u2208 Q we define\n\u03b40(\u03b5, \u03b1, f) =\n{ 1 if f = q\n0 otherwise and \u03b41(f, \u03b3, g) =\n{ 2 if fg \u2208 {qp, pq}\n0 otherwise\nand Fq = 1 and Fp = 0. Then p and q are accessible and co-accessible, and hence, weakly useful. Thus A is weak-trim. The state p is not useful and hence A is not trim."
        },
        {
            "heading": "7.1.2 Trimming for zero-cancellation free strong bimonoids",
            "text": "Here we show our first trimming method. It takes a (\u03a3,B)-wta over some zero-cancellation free strong bimonoid B, and constructs a run equivalent trim (\u03a3,B)-wta. The method employs the pumping lemma to cut out in a careful way contexts from successful runs; due to zero-cancellation freeness of B, this results in smaller successful runs. As preparation we characterize useful states.\nLemma 7.1.2. Let B be zero-cancellation free, A = (Q, \u03b4, F ) be a (\u03a3,B)-wta, and p \u2208 Q. Then p is useful if and only if there exist q \u2208 Q, \u03be \u2208 T\u03a3, and a successful run \u03c1 \u2208 RA(q, \u03be) such that p \u2208 im(\u03c1) and height(\u03be) < 2|Q|.\nProof. The \u201cif\u201d-direction holds trivially. For the \u201conly-if\u201d-direction we prove the following.\nFor every q \u2208 Q, \u03be \u2208 T\u03a3, v \u2208 pos(\u03be), and successful run \u03ba \u2208 RA(q, \u03be),\nthere exist \u03be\u0302 \u2208 T\u03a3, v\u0302 \u2208 pos(\u03be\u0302), and successful run \u03ba\u0302 \u2208 RA(q, \u03be\u0302)\nsuch that height(\u03be\u0302) < 2|Q|, and \u03ba\u0302(v\u0302) = \u03ba(v).\n(7.1)\nLet q \u2208 Q, \u03be \u2208 T\u03a3, v \u2208 pos(\u03be), and \u03ba \u2208 RA(q, \u03be) be a successful run. We prove (7.1) in three steps. Intuitively, in Step 1 we cut out repeatedly contexts above v such that eventually the state \u03ba(v) occurs at v\u0302 and |v\u0302| < |Q|. In Step 2 we cut out repeatedly contexts below v\u0302 such that eventually the subtree below v\u0302 has height smaller than |Q|. In Step 3 we cut out repeatedly contexts aside of v\u0302 such that eventually we obtain the desired result. Since B is zero-cancellation free, cutting out a context transforms a successful run into a successful run. We illustrate the three steps in Figures 7.2, 7.3, and 7.4, respectively.\n142 CHAPTER 7. NORMAL FORMS OF WTA\nStep 1: We construct a \u03be\u2032 \u2208 T\u03a3, a v\u0302 \u2208 pos(\u03be\u2032), and a successful run \u03ba\u2032 \u2208 RA(q, \u03be\u2032) such that |v\u0302| < |Q| and \u03ba\u2032(v\u0302) = \u03ba(v) as follows.\nIf |v| < |Q|, then we let \u03be\u2032 = \u03be, v\u0302 = v, and \u03ba\u2032 = \u03ba and we are ready. Otherwise, there exist u, x \u2208 N\u2217+ and w \u2208 N + + such that v = uwx and \u03ba(u) = \u03ba(uw). Let c\n\u2032 = \u03be|u, c = (\u03be|u)|w, and \u03b6 = \u03be|uw, and let \u03c1\u2032 = \u03ba|u, \u03c1 = (\u03ba|u)|w, and \u03b8 = \u03ba|uw. Then \u03be = c\u2032[c[\u03b6]] and \u03ba = \u03c1\u2032[\u03c1[\u03b8]], where \u03c1 is a loop due to the condition \u03c1(u) = \u03c1(uw). Thus, by Theorem 6.1.3 (equality (6.2) for n = 1), we have\nwt(\u03be, \u03ba)\u2297 Fq = lc\u2032,\u03c1\u2032 \u2297 lc,\u03c1 \u2297 wt(\u03b6, \u03b8) \u2297 rc,\u03c1 \u2297 rc\u2032,\u03c1\u2032 \u2297 Fq.\nNow we cut out the context c and the corresponding loop \u03c1. Formally, let \u03be\u2032 = c\u2032[\u03b6] and \u03ba\u2032 = \u03c1\u2032[\u03b8]. By equality (6.2) for n = 0, we obtain\nwt(\u03be\u2032, \u03ba\u2032)\u2297 Fq = lc\u2032,\u03c1\u2032 \u2297 wt(\u03b6, \u03b8)\u2297 rc\u2032,\u03c1\u2032 \u2297 Fq.\nSince \u03ba is a successful run, i.e., wt(\u03be, \u03ba) \u2297 Fq 6= 0, and B is zero-cancellation free, we obtain that \u03ba\u2032 is also successful. Moreover, for v\u0302 = ux, we have \u03ba\u2032(v\u0302) = \u03ba(v) by the definition of \u03ba\u2032. If |v\u0302| \u2265 |Q|, then we repeat the above procedure with \u03be\u2032, v\u0302, and \u03ba\u2032. After finitely many steps, we obtain \u03be\u2032, v\u0302, and \u03ba\u2032 such that |v\u0302| < |Q|.\nStep 2: Given \u03be\u2032 \u2208 T\u03a3, v\u0302 \u2208 pos(\u03be \u2032), and the successful run \u03ba\u2032 \u2208 RA(q, \u03be \u2032) constructed in Step 1, we construct \u03be\u2032\u2032 \u2208 T\u03a3 and successful run \u03ba\u2032\u2032 \u2208 RA(q, \u03be\u2032\u2032) such that v\u0302 \u2208 pos(\u03be\u2032\u2032), \u03ba\u2032\u2032(v\u0302) = \u03ba\u2032(v\u0302), and height(\u03be\u2032\u2032|v\u0302) < |Q| as follows.\nIf height(\u03be\u2032|v\u0302) < |Q|, then we let \u03be \u2032\u2032 = \u03be\u2032 and \u03ba\u2032\u2032 = \u03ba\u2032 and we are ready. Otherwise, there exist u \u2208 N\u2217+ and w \u2208 N + + such that v\u0302uw \u2208 pos(\u03be\n\u2032) and \u03ba\u2032(v\u0302u) = \u03ba\u2032(v\u0302uw). Similarly to the construction in Step 1, by cutting out the context (\u03be\u2032|v\u0302u)| w and the loop (\u03ba\u2032|v\u0302u)| w from \u03be\u2032 and \u03ba\u2032, respectively, we obtain \u03be\u2032\u2032 \u2208 T\u03a3 and successful run \u03ba\u2032\u2032 \u2208 RA(q, \u03be\u2032\u2032) such that v\u0302 \u2208 pos(\u03be\u2032\u2032), \u03ba\u2032\u2032(v\u0302) = \u03ba\u2032(v\u0302) and size(\u03be\u2032\u2032|v\u0302) < size(\u03be \u2032|v\u0302). If height(\u03be \u2032\u2032|v\u0302) \u2265 |Q|, then we repeat the above procedure with \u03be\n\u2032\u2032 and \u03ba\u2032\u2032. After finitely many steps, we obtain \u03be\u2032\u2032 and \u03ba\u2032\u2032 such that height(\u03be\u2032\u2032|v\u0302) < |Q|.\nStep 3: Given \u03be\u2032\u2032 \u2208 T\u03a3, v\u0302 \u2208 pos(\u03be\u2032\u2032), and the successful run \u03ba\u2032\u2032 \u2208 RA(q, \u03be\u2032\u2032) constructed in Step 2, we construct \u03be\u0302 \u2208 T\u03a3 and the successful run \u03ba\u0302 \u2208 RA(q, \u03be\u0302) such that v\u0302 \u2208 pos(\u03be\u0302), \u03ba\u0302(v\u0302) = \u03ba\u2032\u2032(v\u0302), and height(\u03be\u0302) < 2|Q|.\nLet x \u2208 pos(\u03be\u2032\u2032) be such that x 6\u2208 prefix(v\u0302). Let us denote by lcp(v\u0302, x) the longest common prefix of v\u0302 and x. Moreover, let rest(v\u0302, x) be the unique string in N++ such that x = lcp(v\u0302, x)rest(v\u0302, x). We note that if v\u0302 \u2208 prefix(x), i.e., lcp(v\u0302, x) = v\u0302, then |rest(v\u0302, x)| < |Q| due to the condition height(\u03be\u2032\u2032|v\u0302) < |Q|.\nIf, for each x \u2208 pos(\u03be\u2032\u2032) with x 6\u2208 prefix(v\u0302) and v\u0302 6\u2208 prefix(x), we also have |rest(v\u0302, x)| < |Q|+ 1, then we are ready because |v\u0302| < |Q|.\nOtherwise, there exist u \u2208 N++ and w \u2208 N + + such that lcp(v\u0302, x)uw \u2208 prefix(x) and \u03ba \u2032\u2032(lcp(v\u0302, x)u) = \u03ba\u2032\u2032(lcp(v\u0302, x)uw). Similarly to the construction in Step 1, by cutting out the context (\u03be\u2032\u2032|lcp(v\u0302,x)u)| w and the loop (\u03ba\u2032\u2032|lcp(v\u0302,x)u)| w from \u03be\u2032\u2032 and \u03ba\u2032\u2032, respectively, we obtain \u03be\u0302 \u2208 T\u03a3 and successful run \u03ba\u0302 \u2208 RA(q, \u03be\u0302) such that v\u0302 \u2208 pos(\u03be\u0302), \u03ba\u0302(v\u0302) = \u03ba\u2032\u2032(v\u0302) and size(\u03be\u0302) < size(\u03be\u2032\u2032). The condition v\u0302 \u2208 pos(\u03be\u0302) is ensured by u \u2208 N++.\n7.1. TRIMMING A WTA 143\nIf there still exists an x \u2208 pos(\u03be\u0302) such that x 6\u2208 prefix(v\u0302), v\u0302 6\u2208 prefix(x), and |rest(v\u0302, x)| \u2265 |Q| + 1, then\nwe repeat the above procedure with \u03be\u0302 and \u03ba\u0302. After finitely many steps, we obtain \u03be\u0302 and \u03ba\u0302 as desired.\nNow we can prove the trimming result for zero-cancellation free strong bimonoids. By Observation 2.6.11(1) this also covers commutative strong bimonoids.\nTheorem 7.1.3. Let \u03a3 be a ranked alphabet, B be a zero-cancellation free strong bimonoid, and A be a (\u03a3,B)-wta. If A contains a useful state, then we can construct a (\u03a3,B)-wta A\u2032 such that A\u2032 is trim and [[A\u2032]]run = [[A]]run.\nProof. Let A = (Q, \u03b4, F ). We construct the set\nQ\u2032 = \u22c3( im(\u03c1) | \u03be \u2208 T\u03a3, height(\u03be) < 2|Q|, \u03c1 \u2208 RA(q, \u03be),wt(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) 6= 0 ) .\nBy Lemma 7.1.2, Q\u2032 is the set of all useful states of A. Due to our assumption on A, we have Q\u2032 6= \u2205. Then we construct the (\u03a3,B)-wta A\u2032 = (Q\u2032, \u03b4\u2032, F \u2032) such that\n\u2022 \u03b4\u2032k = \u03b4k restricted to (Q \u2032)k \u00d7 \u03a3(k) \u00d7Q\u2032 for each k \u2208 N, and \u2022 F \u2032 = F |Q\u2032 .\nClearly, A\u2032 is trim. Let \u03be \u2208 T\u03a3. Then\n[[A]]run(\u03be) = \u2295\nq\u2208Q\n\u2295\n\u03c1\u2208RA(q,\u03be)\nwtA(\u03be, \u03c1)\u2297 Fq = \u2295\nq\u2208Q\n\u2295\n\u03c1\u2208RA(q,\u03be): \u03c1 is successful\nwtA(\u03be, \u03c1)\u2297 Fq\n= \u2295\nq\u2208Q\u2032\n\u2295\n\u03c1\u2208RA\u2032 (q,\u03be)\nwtA\u2032(\u03be, \u03c1)\u2297 F \u2032 q = [[A \u2032]]run(\u03be),\nwhere the third equality follows from the fact that, if \u03c1 is successful, then all states in im(\u03c1) are useful and that for every q \u2208 Q\u2032 and \u03c1 \u2208 RA\u2032(q, \u03be) we have wtA\u2032(\u03be, \u03c1) = wtA(\u03be, \u03c1)."
        },
        {
            "heading": "7.1.3 Local-trimming for arbitrary strong bimonoids",
            "text": "Here we show our second trimming method. It takes a (\u03a3,B)-wta over an arbitrary strong bimonoid B as input and constructs a run equivalent local-trim (\u03a3,B)-wta. This trimming method is adapted from [Har78, Thm. 3.2.3] where it is shown how to construct an equivalent reduced context-free grammar from a given context-free grammar.\nTheorem 7.1.4. Let A be a (\u03a3,B)-wta. If A contains a local-useful state, then we can construct a (\u03a3,B)-wta A\u2032 such that A\u2032 is local-trim and [[A\u2032]]run = [[A]]run.\nProof. The following proof is based on [Dro22]. Let A = (Q, \u03b4, F ). First, in a bottom-up process, we construct the set Q1 of all local-accessible states of A (by using a mapping f). Second, in a top-down process, we construct the set of all local-useful states (by using a mapping g).\nWe define the mapping f : P(Q)\u2192 P(Q) for each U \u2208 P(Q) by\nf(U) = U \u222a {q \u2208 Q| there exist k \u2208 N, q1, ..., qk \u2208 U, and \u03c3 \u2208 \u03a3 (k) such that \u03b4k(q1...qk, \u03c3, q) 6= 0} .\nTrivially, f is order-preserving and hence continuous, as Q is finite.\nLet Q1 be the smallest subset of Q which is closed under f . Thus, by Theorem 2.6.17, we have that Q1 = \u22c3 (fn(\u2205) | n \u2208 N). Since \u22c3 (fn(\u2205) | n \u2208 N) = \u22c3 (fn(\u2205) | 0 \u2264 n \u2264 |Q|), we can construct Q1. Moreover, each state in Q1 is local-accessible in A. Conversely, working up a run, it follows that each local-accessible state of A belongs to Q1. Hence Q1 is the set of all local-accessible states of A.\n144 CHAPTER 7. NORMAL FORMS OF WTA\nNext we define g : P(Q1)\u2192 P(Q1) for each U \u2208 P(Q1) by\ng(U) =    {q \u2208 Q1 | Fq 6= 0} if U = \u2205 U \u222a {qi \u2208 Q1 | there exist k \u2208 N+, q \u2208 U, q1, . . . , qk \u2208 Q1, i \u2208 [k] and\n\u03c3 \u2208 \u03a3(k) such that \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) 6= 0} otherwise .\nThe mapping g is order-preserving and hence continuous, as Q1 is finite. Let Q \u2032 be the smallest subset of Q1 which is closed under g. Thus, by Theorem 2.6.17, we have that Q \u2032 = \u22c3 (gn(\u2205) | n \u2208 N). Since\u22c3\n(gn(\u2205) | n \u2208 N) = \u22c3 (gn(\u2205) | 0 \u2264 n \u2264 |Q1|), we can construct Q \u2032.\nWe claim that Q\u2032 is the set of all local-useful states of A. (7.2)\n(a) First we show that each q \u2208 Q\u2032 is local-useful. For this, by induction on N, we prove the following statement.\nFor each n \u2208 N+, we have that each state in g n(\u2205) is local-useful. (7.3)\nI.B.: Clearly, each state in g(\u2205) = {q \u2208 Q1 | Fq 6= 0} is local-useful.\nI.S.: Let n \u2265 1 and p \u2208 gn+1(\u2205). We may assume that p \u2208 gn+1(\u2205) \\ gn(\u2205) because otherwise the statement follows by the I.H. immediately. Then there exist k \u2208 N+, j \u2208 [k], q \u2208 gn(\u2205), q1, . . . , qk \u2208 Q1, and \u03c3 \u2208 \u03a3(k) such that \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) 6= 0 and p = qj .\nSince q1, . . . , qk are in Q1, i.e., local-accessible, for each i \u2208 [k] there is a tree \u03bei \u2208 T\u03a3 and run \u03c1i \u2208 RA(qi, \u03bei) such that for every v \u2208 pos(\u03bei), the weight \u03b4\u2113(\u03c1i(v1) \u00b7 \u00b7 \u00b7 \u03c1i(v\u2113), \u03bei(v), \u03c1i(v)) 6= 0, where \u2113 = rk(\u03be(v)).\nBy the I.H. q is local-useful, hence there is a \u03be \u2208 T\u03a3, and a local-successful run \u03c1 \u2208 RA(\u03be) such that q \u2208 im(\u03c1). Let w \u2208 pos(\u03be) with \u03c1(w) = q.\nNow consider the tree \u03b6 = \u03c3(\u03be1, . . . , \u03bek) and define the run \u03ba \u2208 RA(\u03b6) such that \u03ba(\u03b5) = q and for each i \u2208 [k] and v \u2208 pos(\u03bei) we have \u03ba(iv) = \u03c1i(v).\nNote that \u03ba(j) = p and\nfor every v \u2208 pos(\u03b6), the weight \u03b4\u2113(\u03ba(v1) \u00b7 \u00b7 \u00b7\u03ba(v\u2113), \u03b6(v), \u03ba(v)) 6= 0, where \u2113 = rk(\u03be \u2032(v)). (7.4)\nLastly, we consider the tree \u03be\u2032 = \u03be[\u03b6]w and the run \u03c1 \u2032 \u2208 RA(\u03be\u2032) defined, for each v \u2208 pos(\u03be\u2032), by\n\u03c1\u2032(v) =\n{ \u03ba(u) if (\u2203u \u2208 N\u2217) : v = wu\n\u03c1(v) otherwise.\nSince \u03c1 is local-successful and \u03ba has property (7.4), the run \u03c1\u2032 is also local-successful. Moreover, \u03c1\u2032(wj) = \u03ba(j) = p, hence p is local-useful. This finishes the proof of (7.3).\nSince Q\u2032 = \u22c3 (gn(\u2205) | n \u2208 N), we obtain that each state of Q\u2032 is local-useful in A.\n(b) Next we show that each local-useful state of A is in Q\u2032.\nFor this, let \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be) be a local-successful run on \u03be. By induction on (pos(\u03be), <pref) we show that\nfor each w \u2208 pos(\u03be), there exists n \u2208 N such that state \u03c1(w) \u2208 gn(\u2205). (7.5)\nWe note that, since \u03c1 is local-successful, \u03c1(v) \u2208 Q1 for each v \u2208 pos(\u03be).\nI.B.: Let w = \u03b5. Again, since \u03c1 is local-successful, we have F\u03c1(\u03b5) 6= 0. Hence \u03c1(\u03b5) \u2208 g(\u2205).\nI.S.: Let w = vi for some v \u2208 pos(\u03be) and i \u2208 maxrk(\u03a3). By I.H., there exists n \u2208 N such that the state \u03c1(v) \u2208 gn(\u2205). Let \u03c3 = \u03be(v) and k = rk(\u03c3). Since \u03c1 is local-successful, we have \u03b4k(\u03c1(v1) . . . \u03c1(vk), \u03c3, \u03c1(v)) 6= 0. Then \u03c1(v1), . . . , \u03c1(vk) \u2208 gn+1(\u2205) and thus, in particular, \u03c1(w) \u2208 gn+1(\u2205).\nWith this we proved that (7.2) holds. By our assumption on A, the set Q\u2032 is not empty.\n7.2. TRANSFORMING WTA INTO TOTAL WTA 145\nNow we construct the (\u03a3,B)-wta A\u2032 = (Q\u2032, \u03b4\u2032, F \u2032) such that, for each k \u2208 N, \u03b4\u2032k = \u03b4k|(Q\u2032)k\u00d7\u03a3(k)\u00d7Q\u2032 , and F \u2032 = F |Q\u2032 . Then A\u2032 is local-trim.\nFinally, we prove that [[A]]run = [[A\u2032]]run. Let \u03be \u2208 T\u03a3. Obviously, RA\u2032(\u03be) \u2286 RA(\u03be) and for each \u03c1 \u2208 RA\u2032(\u03be) we have wtA\u2032(\u03be, \u03c1) = wtA(\u03be, \u03c1). If \u03c1 \u2208 RA(\u03be) \\ RA\u2032(\u03be), then there exists p \u2208 im(\u03c1) such that p is not local-useful. Then wtA(\u03be, \u03c1) = 0 or F\u03c1(\u03b5) = 0 and hence wtA(\u03be, \u03c1) \u2297 F\u03c1(\u03b5) = 0. Thus we can compute\n[[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = \u2295\n\u03c1\u2208RA\u2032 (\u03be)\nwtA\u2032(\u03be, \u03c1)\u2297 F \u2032 \u03c1(\u03b5) = [[A \u2032]]run(\u03be)."
        },
        {
            "heading": "7.2 Transforming wta into total wta",
            "text": "We recall that a (\u03a3,B)-wta A = (Q, \u03b4, F ) is total if for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and w \u2208 Qk there exists at least one state q such that \u03b4k(w, \u03c3, q) 6= 0.\nTheorem 7.2.1. Let A be a (\u03a3,B)-wta. We can construct a (\u03a3,B)-wta A\u2032 such that A\u2032 is total, [[A]]init = [[A\u2032]]init, and [[A]]run = [[A\u2032]]run. Moreover, if A is bu deterministic (or crisp deterministic), then so is A\u2032.\nProof. Let A = (Q, \u03b4, F ). We construct the (\u03a3,B)-wta A\u2032 = (Q\u2032, \u03b4\u2032, F \u2032) as follows.\n\u2022 Q\u2032 = Q \u222a {q\u22a5} where q\u22a5 6\u2208 Q, \u2022 \u03b4\u2032 = (\u03b4\u2032k | k \u2208 N) such that for every k \u2208 N, \u03c3 \u2208 \u03a3 (k), and q \u2208 Q\u2032, and q1 \u00b7 \u00b7 \u00b7 qk \u2208 (Q\u2032)k:\n(\u03b4\u2032)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) =    \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) if q1 \u00b7 \u00b7 \u00b7 qk \u2208 Q k, q \u2208 Q 1 if q1 \u00b7 \u00b7 \u00b7 qk \u2208 Q k, q = q\u22a5, and (\u2200q\u2032 \u2208 Q) : \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q\u2032) = 0 1 if q\u22a5 \u2208 {q1, . . . , qk} and q = q\u22a5\n0 otherwise\n\u2022 F \u2032q = Fq for each q \u2208 Q and F \u2032 q\u22a5 = 0. Obviously, if A is bu deterministic, then so is A\u2032. The construction also preserves crisp determinism.\nFirst we prove that [[A]]init = [[A\u2032]]init. By induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and q \u2208 Q: hA(\u03be)q = hA\u2032(\u03be)q . (7.6)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek) and assume that (7.6) holds for \u03be1, . . . , \u03bek. Let q \u2208 Q. Then we can calculate:\nhA\u2032(\u03c3(\u03be1, . . . , \u03bek))q = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208(Q\u222a{q\u22a5})k\n(\u2297\ni\u2208[k]\nhA\u2032(\u03bei)qi ) \u2297 \u03b4\u2032k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\nhA\u2032(\u03bei)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n(note that \u03b4\u2032k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = 0 if one of the qi is q\u22a5)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\nhA(\u03bei)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) (by I.H.)\n= hA(\u03c3(\u03be1, . . . , \u03bek))q .\nThen for each \u03be \u2208 T\u03a3.\n[[A\u2032]]init(\u03be) = \u2295\nq\u2208Q\u222a{q\u22a5}\nhA\u2032(\u03be)q \u2297 F \u2032 q =\n\u2295\nq\u2208Q\nhA\u2032(\u03be)q \u2297 Fq = \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq = [[A]] init(\u03be) ,\nwhere the second equality holds because F \u2032q\u22a5 = 0 and F \u2032|Q = F .\n146 CHAPTER 7. NORMAL FORMS OF WTA\nNext we prove that [[A]]run = [[A\u2032]]run. First, it is easy to see that\nfor every \u03be \u2208 T\u03a3 and q \u2208 Q: RA(q, \u03be) \u2286 RA\u2032(q, \u03be), and\nfor each \u03c1 \u2208 RA\u2032(q, \u03be) \\ RA(q, \u03be): wtA\u2032(\u03be, \u03c1) = 0. (7.7)\nAlso it is easy to see that\nfor each \u03be \u2208 T\u03a3, q \u2208 Q, and \u03c1 \u2208 RA(q, \u03be): wtA\u2032(\u03be, \u03c1) = wtA(\u03be, \u03c1), (7.8)\nwhere wtA\u2032 and wtA use \u03b4 \u2032 and \u03b4, respectively. Now let \u03be \u2208 T\u03a3. Then we can calculate as follows.\n[[A\u2032]]run(\u03be) = \u2295\nq\u2208Q\u2032\n\u2295\n\u03c1\u2208RA\u2032 (q,\u03be)\nwtA\u2032(\u03be, \u03c1)\u2297 F \u2032 q\n= \u2295\nq\u2208Q\n\u2295\n\u03c1\u2208RA\u2032 (q,\u03be)\nwtA\u2032(\u03be, \u03c1)\u2297 Fq (because F \u2032q\u22a5 = 0 and F \u2032|Q = F )\n= \u2295\nq\u2208Q\n\u2295\n\u03c1\u2208RA(q,\u03be)\nwtA\u2032(\u03be, \u03c1)\u2297 Fq (by (7.7))\n= \u2295\nq\u2208Q\n\u2295\n\u03c1\u2208RA(q,\u03be)\nwtA(\u03be, \u03c1)\u2297 Fq (by (7.8))\n= [[A]]run(\u03be) ."
        },
        {
            "heading": "7.3 Normalizing root weights of wta",
            "text": "Next we want to show that each wta can be transformed into a run equivalent root weight normalized wta. In [DPV05, Lm. 4.8] the same statement is proved if B is a semiring. (In fact, in the proof of [DPV05, Lm. 4.8] only right-distributivity is used.) Here we present a slightly more complicated construction which allows to prove the statement for an arbitrary strong bimonoid.\nTheorem 7.3.1. Let \u03a3 be a ranked alphabet, B be a strong bimonoid, and A be a (\u03a3,B)-wta. We can construct a (\u03a3,B)-wta A\u2032 such that A\u2032 is root weight normalized and [[A]]run = [[A\u2032]]run.\nProof. Let A = (Q, \u03b4, F ). The idea for the construction of A\u2032 is the following. The wta A\u2032 simulates A. Additionally, at each leaf of the given input tree \u03be, the wta A\u2032 guesses a state p of A and stores it in its states; at each non-nullary symbol of \u03a3, the wta A\u2032 checks whether the guesses in the subtrees are consistent and propagates the guessed state; and at the root, the wta A\u2032 multiplies the last transition weight with Fp (if p is the state guessed at each leaf) and moves to the final state qf . (We note that the idea for maintaining the guessed final states was used in [HVD19, Lm. 9] where initial- and final-state normalization was proved for weighted string automata with storage over unital valuation monoids.)\nWe construct the (\u03a3,B)-wta A\u2032 = (Q\u2032, \u03b4\u2032, F \u2032) as follows:\n\u2022 Q\u2032 = (Q \u00d7Q) \u222a {qf} where qf 6\u2208 Q; for each q\u2032 \u2208 Q \u00d7Q we let (q\u2032)i denote the i-th component of q\u2032 for i \u2208 {1, 2}; \u2022 \u03b4\u2032 = (\u03b4\u2032k | k \u2208 N) where for each k \u2208 N, \u03c3 \u2208 \u03a3 (k), q\u20320 \u2208 Q \u2032 and q\u20321 \u00b7 \u00b7 \u00b7 q \u2032 k \u2208 (Q\n\u2032)k we define \u03b4\u2032k(q \u2032 1 \u00b7 \u00b7 \u00b7 q \u2032 k, \u03c3, q \u2032 0) by case analysis as follows. Case (a): Let k = 0. Then\n\u03b4\u20320(\u03b5, \u03c3, q \u2032 0) =\n{ \u03b40(\u03b5, \u03c3, (q \u2032 0)1) if q \u2032 0 \u2208 Q\u00d7Q\u2295\np\u2208Q \u03b40(\u03b5, \u03c3, p)\u2297 Fp if q \u2032 0 = qf .\n7.3. NORMALIZING ROOT WEIGHTS OF WTA 147\nCase (b): Let k \u2265 1. Then\n\u03b4\u2032k(q \u2032 1 \u00b7 \u00b7 \u00b7 q \u2032 k, \u03c3, q \u2032 0)\n=    \u03b4k((q \u2032 1)1 \u00b7 \u00b7 \u00b7 (q \u2032 k)1, \u03c3, (q \u2032 0)1) if (\u2203p \u2208 Q) (\u2200i \u2208 [0, k]) (\u2203qi \u2208 Q) : q \u2032 i = (qi, p) \u03b4k((q \u2032 1)1 \u00b7 \u00b7 \u00b7 (q \u2032 k)1, \u03c3, (q \u2032 1)2)\u2297 F(q\u20321)2 if (\u2203p \u2208 Q) (\u2200i \u2208 [k]) (\u2203qi \u2208 Q) : q \u2032 i = (qi, p) and q \u2032 0 = qf\n0 otherwise,\nwhere in the second case we have used the assumption that k \u2265 1, \u2022 F \u2032qf = 1 and F \u2032 q\u2032 = 0 for each q \u2032 \u2208 Q\u2032 \\ {qf}.\nIt is clear that, for each position of \u03be \u2208 T\u03a3 except at its root, A\u2032 behaves exactly as A. To make this precise, for each p \u2208 Q, we define the family (\u03c8p,\u03be | \u03be \u2208 T\u03a3) of mappings\n\u03c8p,\u03be : RA(\u03be)\u2192 RA\u2032(\u03be)\nsuch that, for every \u03c1 \u2208 RA(\u03be) and w \u2208 pos(\u03be), we let \u03c8p,\u03be(\u03c1)(w) = (\u03c1(w), p). Obviously, \u03c8p,\u03be is injective. Also it is obvious that, for every \u03be = \u03c3(\u03be1, . . . , \u03bek), i \u2208 [k], and \u03c1 \u2208 RA(\u03be), the following holds:\n\u03c8p,\u03be(\u03c1)|i = \u03c8p,\u03bei(\u03c1|i) . (7.9)\nBy induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be), and p \u2208 Q, we have wtA(\u03be, \u03c1) = wtA\u2032(\u03be, \u03c8p,\u03be(\u03c1)) . (7.10)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). Then we can calculate as follows:\nwtA(\u03be, \u03c1) = (\u2297\ni\u2208[k]\nwtA(\u03bei, \u03c1|i) ) \u2297 \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5))\n= (\u2297\ni\u2208[k]\nwtA\u2032(\u03bei, \u03c8p,\u03bei(\u03c1|i)) ) \u2297 \u03b4\u2032k((\u03c1(1), p) \u00b7 \u00b7 \u00b7 (\u03c1(k), p), \u03c3, (\u03c1(\u03b5), p))\n(by I.H. and construction)\n= (\u2297\ni\u2208[k]\nwtA\u2032(\u03bei, \u03c8p,\u03be(\u03c1)|i) ) \u2297 \u03b4\u2032k((\u03c1(1), p) \u00b7 \u00b7 \u00b7 (\u03c1(k), p), \u03c3, (\u03c1(\u03b5), p)) (by (7.9))\n= wtA\u2032(\u03be, \u03c8p,\u03be(\u03c1)) .\nNext we prove that [[A]]run(\u03be) = [[A\u2032]]run(\u03be) for each \u03be \u2208 T\u03a3 by case analysis. Case (a): Let \u03be = \u03b1 for some \u03b1 \u2208 \u03a3(0). Since, for each p \u2208 Q, we have RA(p, \u03b1) = {\u03c1} with \u03c1(\u03b5) = p and wtA(\u03b1, \u03c1) = \u03b40(\u03b5, \u03b1, p), and similarly, RA\u2032(qf , \u03b1) = {\u03c1\u2032} with \u03c1\u2032(\u03b5) = qf and wtA\u2032(\u03b1, \u03c1\u2032) = \u03b4\u20320(\u03b5, \u03b1, qf ), we obtain\n[[A]]run(\u03b1) = \u2295\np\u2208Q\n\u2295\n\u03c1\u2208RA(p,\u03be)\nwtA(\u03b1, \u03c1)\u2297 Fp = \u2295\np\u2208Q\n\u03b40(\u03b5, \u03b1, p)\u2297 Fp = \u03b4 \u2032 0(\u03b5, \u03b1, qf )\n= \u03b4\u20320(\u03b5, \u03b1, qf )\u2297 F \u2032 qf\n= \u2295\nq\u2032\u2208Q\u2032\n\u2295\n\u03c1\u2032\u2208RA\u2032(q \u2032,\u03be)\nwtA\u2032(\u03b1, \u03c1 \u2032)\u2297 F \u2032q\u2032 = [[A \u2032]]run(\u03b1) .\nCase (b): Let \u03be \u2208 T\u03a3 \\\u03a3(0). Let p \u2208 Q. First we relate p-runs of A on \u03be with qf -runs of A\u2032 on \u03be which assign states of the form (q, p) to inner nodes of \u03be for some q \u2208 Q. Formally, we define the mapping\n\u03d5p : RA(p, \u03be)\u2192 R p A\u2032(qf , \u03be)\nwhere RpA\u2032(qf , \u03be) = {\u03c1 \u2032 \u2208 RA\u2032(qf , \u03be) | (\u2200w \u2208 pos(\u03be) \\ {\u03b5}) : \u03c1\u2032(w) \u2208 Q \u00d7 {p}}, and for every \u03c1 \u2208 RA(p, \u03be)\nand w \u2208 pos(\u03be) we let ( \u03d5p(\u03c1) ) (w) = qf if w = \u03b5, and (\u03c1(w), p) otherwise. It is obvious that, for every p \u2208 Q, the mapping \u03d5p is bijective (note that \u03be 6\u2208 \u03a3(0)) and\nfor every \u03c1\u2032 \u2208 RA\u2032(qf , \u03be) \\ \u22c3\np\u2208Q\nRpA\u2032(qf , \u03be) we have wtA\u2032(\u03be, \u03c1 \u2032) = 0 . (7.11)\n148 CHAPTER 7. NORMAL FORMS OF WTA\nMoreover, the family (RpA\u2032 (qf , \u03be) | p \u2208 Q) partitions \u22c3 p\u2208QR p A\u2032(qf , \u03be), i.e.,\nRpA\u2032(qf , \u03be) \u2229 R p\u2032 A\u2032(qf , \u03be) = \u2205 for every p, p \u2032 \u2208 Q with p 6= p\u2032 . (7.12)\nNext we prove a correspondence between the weights of runs of A and A\u2032 on \u03be. We claim:\nfor every p \u2208 Q, and \u03c1 \u2208 RA(p, \u03be), we have wtA(\u03be, \u03c1)\u2297 Fp = wtA\u2032(\u03be, \u03d5p(\u03c1)) . (7.13)\nFor the proof let \u03be = \u03c3(\u03be1, . . . , \u03bek) (note that k \u2265 1). Let p \u2208 Q, and \u03c1 \u2208 RA(p, \u03be) (hence \u03c1(\u03b5) = p). Then we can calculate as follows:\nwtA(\u03be, \u03c1)\u2297 Fp = ((\u2297\ni\u2208[k]\nwtA(\u03bei, \u03c1|i) ) \u2297 \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, p) ) \u2297 Fp\n= (\u2297\ni\u2208[k]\nwtA(\u03bei, \u03c1|i) ) \u2297 ( \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, p) \u2297 Fp )\n= (\u2297\ni\u2208[k]\nwtA\u2032(\u03bei, \u03c8p,\u03bei(\u03c1|i)) ) \u2297 ( \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, p)\u2297 Fp ) (by (7.10))\n= (\u2297\ni\u2208[k]\nwtA\u2032(\u03bei, \u03c8p,\u03bei(\u03c1|i)) ) \u2297 \u03b4\u2032k((\u03c1(1), p) \u00b7 \u00b7 \u00b7 (\u03c1(k), p), \u03c3, qf ) (by construction)\n= (\u2297\ni\u2208[k]\nwtA\u2032(\u03bei, \u03d5p(\u03c1)|i) ) \u2297 \u03b4\u2032k(\u03d5p(\u03c1)(1) \u00b7 \u00b7 \u00b7\u03d5p(\u03c1)(k), \u03c3, \u03d5p(\u03c1)(\u03b5))\n(because \u03c8p,\u03bei(\u03c1|i) = \u03d5p(\u03c1)|i for each i \u2208 [k] and \u03d5p(\u03c1)(\u03b5) = qf )\n= wtA\u2032(\u03be, \u03d5p(\u03c1)) .\nFinally, we can prove that [[A]]run(\u03be) = [[A\u2032]]run(\u03be).\n[[A\u2032]]run(\u03be) = \u2295\nq\u2032\u2208Q\u2032\n\u2295\n\u03c1\u2032\u2208RA\u2032(q \u2032,\u03be)\nwtA\u2032(\u03be, \u03c1 \u2032)\u2297 F \u2032q\u2032\n= \u2295\n\u03c1\u2032\u2208RA\u2032 (qf ,\u03be)\nwtA\u2032(\u03be, \u03c1 \u2032) (because F \u2032qf = 1 and F \u2032 q\u2032 = 0 for each q \u2032 \u2208 Q\u2032 \\ {qf})\n= \u2295\n\u03c1\u2032\u2208 \u22c3 p\u2208Q R p A\u2032 (qf ,\u03be)\nwtA\u2032(\u03be, \u03c1 \u2032) (by (7.11))\n= \u2295\np\u2208Q\n\u2295\n\u03c1\u2032\u2208Rp A\u2032 (qf ,\u03be)\nwtA\u2032(\u03be, \u03c1 \u2032) (by (7.12))\n= \u2295\np\u2208Q\n\u2295\n\u03c1\u2208RA(p,\u03be)\nwtA\u2032(\u03be, \u03d5p(\u03c1)) (because \u03d5p is a bijection)\n= \u2295\np\u2208Q\n\u2295\n\u03c1\u2208RA(p,\u03be)\nwtA(\u03be, \u03c1)\u2297 Fp (by (7.13))\n= [[A]]run(\u03be) .\nAn analysis of the construction in the proof of Theorem 7.3.1 shows that it does not preserve bu determinism. If we restrict the set of weight algebras to the set of commutative semifields, then we can transform each wta into an equivalent one with identity root weights and this transformation preserves bu determinism. The transformation uses the technique of weight pushing [HMQ18, Def. 4.1] (also cf. [Moh97, p. 296] for the case that B is the tropical semiring on the set of non-negative real numbers), which is of interest of its own.\n7.3. NORMALIZING ROOT WEIGHTS OF WTA 149\nFormally, let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta over some commutative semifield B. Moreover, let \u03bb : Q \u2192 B \\ {0} be a mapping such that \u03bb(q) = Fq for each q \u2208 supp(F ). We define the wta push\u03bb(A) to be the (\u03a3,B)-wta (Q, \u03b4\u2032, F \u2032) as follows. For each k \u2208 N, \u03c3 \u2208 \u03a3(k), q \u2208 Q, and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Q:\n\u03b4\u2032k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = (\u2297\ni\u2208[k]\n\u03bb(qi) \u22121 ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) \u2297 \u03bb(q)\nand for each q \u2208 Q\nF \u2032q = { 1 if q \u2208 supp(F ) 0 otherwise .\nLemma 7.3.2. (cf. [HMQ18, Prop. 4.2]) Let A and \u03bb be defined as above. Then [[A]] = [[push\u03bb(A)]].\nProof. We abbreviate push\u03bb(A) by A \u2032. By induction on T\u03a3, we prove that the following statement holds:\nFor each \u03be \u2208 T\u03a3 and q \u2208 Q, we have: hA\u2032(\u03be)q = \u03bb(q)\u2297 hA(\u03be)q . (7.14)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). Then\nhA\u2032(\u03c3(\u03be1, . . . , \u03bek))q\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\nhA\u2032(\u03bei)qi ) \u2297 \u03b4\u2032(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\n\u03bb(qi)\u2297 hA(\u03bei)qi\n) \u2297 ((\u2297\ni\u2208[k]\n\u03bb(qi) \u22121 ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) \u2297 \u03bb(q) )\n(by I.H. and construction of push\u03bb(A))\n= \u03bb(q)\u2297 \u2295\nq1...qk\u2208Qk\n(\u2297\ni\u2208[k]\nhA(\u03bei)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n(by commutativity and associativity of \u2297 and by distributivity)\n= \u03bb(q)\u2297 hA(\u03c3(\u03be1, . . . , \u03bek))q .\nThen, for each \u03be \u2208 T\u03a3, we have\n[[push\u03bb(A)]](\u03be)\n= \u2295\nq\u2208Q\nhA\u2032(\u03be)q \u2297 F \u2032 q =\n\u2295\nq\u2208Q\nhA(\u03be)q \u2297 \u03bb(q) \u2297 F \u2032 q (by (7.14) and commutativity of \u2297)\n= \u2295\nq\u2208supp(F )\nhA(\u03be)q \u2297 \u03bb(q) (by the definition of F \u2032)\n= \u2295\nq\u2208supp(F )\nhA(\u03be)q \u2297 Fq (by the definition of \u03bb)\n= [[A]](\u03be) .\nTheorem 7.3.3. Let B be a commutative semifield and A be a (\u03a3,B)-wta. We can construct a (\u03a3,B)-wta A\u2032 such that A\u2032 has identity root weights and [[A]] = [[A\u2032]]. If A is bu deterministic, then so is A\u2032.\nProof. Let A = (Q, \u03b4, F ) and let \u03bb : Q \u2192 B \\ {0} be any mapping such that \u03bb(q) = Fq for each q \u2208 supp(F ). We note that push\u03bb(A) has identity root weights. It is obvious that push\u03bb(A) is bu deterministic, if A is so. By Lemma 7.3.2 we have [[A]] = [[push\u03bb(A)]], and hence we can choose A\n\u2032 = push\u03bb(A).\n150 CHAPTER 7. NORMAL FORMS OF WTA"
        },
        {
            "heading": "7.4 Normalizing transition weights of wta",
            "text": "Finally, we want to show that each (\u03a3,B)-wta A can be transformed into a run equivalent (\u03a3,B)-wta which only has identity transition weights provided that the set\nH(A) = {wt(\u03be, \u03c1) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be)} (7.15)\nis finite. Due to this requirement on A, we can code the weights of runs into the states. First we show constructivity of H(A) if this set is finite.\nLemma 7.4.1. [DFKV22, Lm. 6.5] Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. If H(A) is finite, then we can construct the set H(A).\nProof. Let H(A) be finite. For every n \u2208 N and q \u2208 Q let\nHn,q = {wt(\u03be, \u03c1) | \u03be \u2208 T\u03a3, height(\u03be) \u2264 n, \u03c1 \u2208 RA(q, \u03be)} .\nClearly, we have H0,q \u2286 H1,q \u2286 . . . \u2286 H(A) for each q \u2208 Q. We claim that\nfor each n \u2208 N, if for each q \u2208 Q: Hn,q = Hn+1,q, then for each q \u2208 Q: Hn+1,q = Hn+2,q. (7.16)\nTo show this, let n \u2208 N, q \u2208 Q, and b \u2208 Hn+2,q. There exist \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(q, \u03be) such that height(\u03be) \u2264 n + 2 and wt(\u03be, \u03c1) = b. We may assume that height(\u03be) = n + 2. Hence \u03be = \u03c3(\u03be1, . . . , \u03bek) such that height(\u03bei) \u2264 n + 1 for each i \u2208 [k]. Clearly, for each i \u2208 [k], we have wt(\u03bei, \u03c1|i) \u2208 Hn+1,\u03c1(i),\nso by our assumption there exist \u03b6i \u2208 T\u03a3 with height(\u03b6i) \u2264 n and run \u03b8i \u2208 RA ( \u03c1(i), \u03b6i ) such that wt(\u03bei, \u03c1|i) = wt(\u03b6i, \u03b8i).\nNow let \u03b6 = \u03c3(\u03b61, . . . , \u03b6k). Obviously, height(\u03b6) \u2264 n+1. Moreover, let \u03b8 \u2208 RA(q, \u03b6) such that \u03b8|i = \u03b8i for each i \u2208 [k]. Clearly, wt(\u03b6, \u03b8) \u2208 Hn+1,q, and we calculate\nwt(\u03b6, \u03b8) = (\u2297\ni\u2208[k]\nwt(\u03b6i, \u03b8|i) ) \u2297 \u03b4k ( \u03b8(1) \u00b7 \u00b7 \u00b7 \u03b8(i), \u03c3, q )\n= (\u2297\ni\u2208[k]\nwt(\u03bei, \u03c1|i) ) \u2297 \u03b4k ( \u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(i), \u03c3, q ) = wt(\u03be, \u03c1) = b .\nThis shows that b \u2208 Hn+1,q, proving (7.16).\nWe recall that H0,q \u2286 H1,q \u2286 . . . \u2286 H(A) for each q \u2208 Q. Obviously, we can construct Hn,q for every n \u2208 N and q \u2208 Q.\nThen, since H(A) is finite, by constructing H0,q for each q \u2208 Q, H1,q for each q \u2208 Q, and so on, we can find the least number nm \u2208 N such that Hnm,q = Hnm+1,q for each q \u2208 Q and thus by (7.16) we have Hnm,q = Hj,q for every q \u2208 Q and j \u2208 N with j \u2265 nm.\nWe show that H(A) = \u22c3 q\u2208QHnm,q. For this, let b \u2208 H(A), i.e., b = wt(\u03be, \u03c1) for some \u03be \u2208 T\u03a3 with height(\u03be) = j, q \u2208 Q and \u03c1 \u2208 RA(q, \u03be). Then b \u2208 Hj,q = Hnm,q. The other inclusion is obvious. Since we can construct the set \u22c3 q\u2208QHnm,q, the set H(A) can be constructed.\nNow we can prove the following normal form theorem.\nTheorem 7.4.2. Let \u03a3 be a ranked alphabet and B be a strong bimonoid. Moreover, let A be a (\u03a3,B)-wta A such that H(A) is finite. Then we can construct a (\u03a3,B)-wta B such that [[B]]run = [[A]]run and B has identity transition weights.\nProof. Let B = (B,\u2295,\u2297, 0, 1) and A = (Q, \u03b4, F ). Since H(A) is finite, by Lemma 7.4.1, we can construct H(A).\nNow we construct the (\u03a3,B)-wta B = (Q\u2032, \u03b4\u2032, F \u2032) as follows.\n7.4. NORMALIZING TRANSITION WEIGHTS OF WTA 151\n\u2022 Q\u2032 = Q\u00d7H(A), \u2022 for each (q, b) \u2208 Q\u2032, we let (F \u2032)(q,b) = b\u2297 Fq, and \u2022 for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and (q1, b1), . . . , (qk, bk), (q, b) \u2208 Q \u2032 we define\n(\u03b4\u2032)k((q1, b1) \u00b7 \u00b7 \u00b7 (qk, bk), \u03c3, (q, b)) =\n{ 1 if b = (\u2297 i\u2208[k] bi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n0 otherwise .\nObviously, B has identity transition weights.\nAs preparation for the proof of [[A]]run = [[B]]run, we define a bijection between the set of runs of A on an input tree and the set of runs of B on that tree. Indeed, it is easy to see that for every q \u2208 Q, \u03be \u2208 T\u03a3, and b \u2208 H(A), the mapping\n\u03d5 : {\u03c1 \u2208 RA(q, \u03be) | wtA(\u03be, \u03c1) = b} \u2192 {\u03c1 \u2032 \u2208 RB((q, b), \u03be) | wtB(\u03be, \u03c1 \u2032) = 1}\ndefined, for each w \u2208 pos(\u03be), by \u03d5(\u03c1)(w) = (\u03c1(w),wtA(\u03be|w, \u03c1|w)) is a bijection.\nThen we can calculate as follows.\n[[A]]run(\u03be) = \u2295\nq\u2208Q\n\u2295\n\u03c1\u2208RA(q,\u03be)\nwtA(\u03be, \u03c1)\u2297 Fq\n= \u2295\nq\u2208Q\n\u2295\nb\u2208H(A)\n\u2295\n\u03c1\u2208RA(q,\u03be): wtA(\u03be,\u03c1)=b\nwtA(\u03be, \u03c1)\u2297 Fq\n= \u2295\n(q,b)\u2208Q\u2032\n\u2295\n\u03c1\u2208RA(q,\u03be): wtA(\u03be,\u03c1)=b\nb\u2297 Fq (by the definition of Q\u2032)\n= \u2295\n(q,b)\u2208Q\u2032\n\u2295\n\u03c1\u2032\u2208RB((q,b),\u03be): wtB(\u03be,\u03c1 \u2032)=1\nb\u2297 Fq (because \u03d5 is a bijection)\n= \u2295\n(q,b)\u2208Q\u2032\n\u2295\n\u03c1\u2032\u2208RB((q,b),\u03be): wtB(\u03be,\u03c1 \u2032)=1\nwtB(\u03be, \u03c1 \u2032)\u2297 b\u2297 Fq\n= \u2295\n(q,b)\u2208Q\u2032\n\u2295\n\u03c1\u2032\u2208RB((q,b),\u03be)\nwtB(\u03be, \u03c1 \u2032)\u2297 b\u2297 Fq (because wtB(\u03be, \u03c1\u2032) \u2208 {0, 1})\n= \u2295\n(q,b)\u2208Q\u2032\n\u2295\n\u03c1\u2032\u2208RB((q,b),\u03be)\nwtB(\u03be, \u03c1 \u2032)\u2297 (F \u2032)(q,b) (by definition of F \u2032)\n= [[B]]run(\u03be)\nIf H(A) is finite, then we can characterize the run semantics of a (\u03a3,B)-wta A in an easy way. We recall that nb denotes the n-fold summation of b \u2208 B (cf. (2.15)).\nTheorem 7.4.3. Let \u03a3 be a ranked alphabet and B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid. Moreover, let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta such that H(A) is finite. Then we can construct a \u03a3-fta D such that, for each \u03be \u2208 T\u03a3, we have [[A]]run(\u03be) = \u2295 q\u2208Q |R v D(q, \u03be)|Fq.\nProof. By Theorem 7.4.2 we can construct a (\u03a3,B)-wta B such that B has identity transition weights and [[B]]run = [[A]]run. Now we let D = suppB(B) (cf. Section 3.4 for the definition of suppB(B)).\nLet \u03be \u2208 T\u03a3. The following statements are obvious.\nFor each \u03c1 \u2208 RB(\u03be), we have wtB(\u03be, \u03c1) \u2208 {0, 1} (7.17)\n152 CHAPTER 7. NORMAL FORMS OF WTA\nFor every q \u2208 Q and \u03c1 \u2208 RB(q, \u03be), we have: wtB(\u03be, \u03c1) = 1 iff \u03c1 \u2208 R v D(q, \u03be) (7.18)\nThen we can calculate as follows:\n[[A]]run(\u03be) = [[B]]run(\u03be) = \u2295\nq\u2208Q\n\u2295\n\u03c1\u2208RB(q,\u03be)\nwtB(\u03be, \u03c1)\u2297 Fq\n= \u2295\nq\u2208Q\n\u2295\n\u03c1\u2208RvD(q,\u03be)\nFq (by (7.17) and (7.18))\n= \u2295\nq\u2208Q\n|RvD(q, \u03be)|Fq .\nWhen additionally restricting the summation to be idempotent, we obtain the following consequence.\nCorollary 7.4.4. Let B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid such that \u2295 is idempotent. Moreover, let A be a (\u03a3,B)-wta such that H(A) is finite. Then [[A]]run is a recognizable step mapping.\nProof. By Theorem 7.4.3 we can construct a \u03a3-fta D such that, for each \u03be \u2208 T\u03a3, we have [[A]]run(\u03be) =\u2295 q\u2208Q |R v D(q, \u03be)|Fq . Let D = (Q, \u03b4, F ). For each q \u2208 Q, we define the \u03a3-fta D q = (Q, \u03b4, {q}). Then\nfor each \u03be \u2208 T\u03a3, we have R v D(q, \u03be) 6= \u2205 iff \u03be \u2208 L(D q) iff \u03c7B(L(D q))(\u03be) = 1 . (7.19)\nThen, for each \u03be \u2208 T\u03a3, we can calculate as follows.\n[[A]]run(\u03be) = \u2295\nq\u2208Q\n|RvD(q, \u03be)|Fq\n= \u2295\nq\u2208Q: RvD(q,\u03be) 6=\u2205\nFq (because \u2295 is idempotent)\n= \u2295\nq\u2208Q\nFq \u2297 \u03c7B(L(D q))(\u03be) (by (7.19))\n= (\u2295\nq\u2208Q\nFq \u2297 \u03c7B(L(D q)) ) (\u03be) .\nThus [[A]]run is a recognizable step mapping.\nSince for each (\u03a3,B)-wta A where B has a locally finite multiplication, the set H(A) is finite, Corollary 7.4.4 implies the following: for each (\u03a3,B)-wta A where B has an idempotent summation and a locally finite multiplication, the run semantics [[A]]run is a recognizable step mapping. Next we show some examples of such strong bimonoids:\n\u2022 each bounded lattice. \u2022 the semiring Natmax,+,n = ([0, n]\u2212\u221e,max, +\u0302n,\u2212\u221e, 0) from Example 2.6.9(9). \u2022 the semiring Natmax,min = (N\u221e,max,min, 0,\u221e) from Example 2.6.9(11). \u2022 the strong bimonoid (B,max,\u2299, 0, 1) where\n\u2013 B = {0} \u222a {b \u2208 R | \u03bb \u2264 b \u2264 1} for some \u03bb \u2208 R with 0 < \u03bb < 12 and \u2013 a\u2299 b = a \u00b7 b if a \u00b7 b \u2265 \u03bb, and 0 otherwise,\nand \u00b7 is the usual multiplication of real numbers (thus, \u2299 is the same as the multiplication of Trunc\u03bb of Example 2.6.10(2)).\nWe note that in Theorem 16.2.6 we will strengthen Corollary 7.4.4 by relaxing the requirement that the summation of the strong bimonoid is idempotent.\nChapter 8\nWeighted context-free grammars\nIn the theory of tree languages it is a fundamental theorem that the yield of a recognizable tree language is a context-free language and, vice versa, each context-free language can be obtained in this way [Tha67] (also cf. [Eng75b, Thm. 3.28] and [GS84, Sect. 3.2]). This fundamental theorem has been generalized to the weighted setting in [E\u0301K03] for continuous and commutative semirings and in [FG18] for arbitrary semirings. Here we generalize it for arbitrary strong bimonoids.\nFirst, we recall the concept of weighted context-free grammars (cf. Section 8.1) and prove a number of normal form lemmas: nonterminal form, start-separated, local-reduced, chain-free, and \u03b5-free (cf. Section 8.2). Then we prove that a weighted language is context-free if and only if it is the yield of an r-recognizable weighted tree language (cf. Theorem 8.3.1).\nWe note that in [RT19] weighted context-free grammars over bimonoids were investigated; roughly speaking, a bimonoid is a strong bimonoid in which the addition need not be commutative and the annihilation law (b \u2297 0 = 0 \u2297 b = 0) need not hold. Moreover, we note that we will use the concept of weighted context-free grammar to define the concept of weighted regular tree grammar (cf. Chapter 9) and the concept of weighted projective bimorphism (cf. Section 10.13)."
        },
        {
            "heading": "8.1 The grammar model",
            "text": "Weighted context-free grammars were introduced in [CS63] where the weights reflected the degree of ambiguity (also cf [Sha67]). Similar to such grammars, finite systems of algebraic equations were investigated in [SS78, KS86, E\u0301K03]. We build our definitions along [DV14a].\nA weighted context-free grammar over \u0393 and B (for short: (\u0393,B)-wcfg, or: wcfg) is a tuple G = (N,S,R,wt), where\n\u2022 (N,S,R) is a \u0393-cfg which has a terminal rule1 and \u2022 wt : R\u2192 B is the weight mapping.\nThe cfg underlying G, denoted by Gu, is the \u0393-cfg (N,S,R).\nSince each (\u0393,B)-wcfg G is an extension of some \u0393-cfg (viz. by some weight mapping wt), the concepts and abbreviations which are defined for context-free grammars (cf. Section 2.12) are also available for weighted-context free grammars. This concerns, in particular,\n\u2022 the abbreviations lhs(r) and rhsN,i(r) for some rule r of G, \u2022 the explicit form A\u2192 u0A1u1 \u00b7 \u00b7 \u00b7Akuk of a rule r of G, \u2022 the mapping \u03c0Gu : TR \u2192 \u0393\n\u2217, which we will call projection of G and denote by \u03c0G , \u2022 the concept of rule tree; we will denote the sets RTGu(A, u), RTGu(N \u2032, L), RTGu(L), and RTGu by\n1We need this condition because we wish to define the semantics of a wcfg in terms of rule trees (cf. Section 2.12)\n153\n154 CHAPTER 8. WEIGHTED CONTEXT-FREE GRAMMARS\nRTG(A, u), RTG(N \u2032, L), RTG(L), and RTG , respectively.\nNext we define the weight of rule trees by using the concept of evaluation algebra (cf. Section 2.9). For this we consider the mapping wt as N-indexed family (wtk | k \u2208 N) of mappings wtk : R\n(k) \u2192 B by defining wtk = wt|R(k) . Then, for each d \u2208 TR, the weight of d is the value hM(R,wt)(d) in B, where M(R,wt) is the (R,wt)-evaluation algebra. For convenience, we will abbreviate hM(R,wt) by wtG . We note that, for each d = r(d1, . . . , dk) in TR, we have\nwtG(d) = wtG(d1)\u2297 \u00b7 \u00b7 \u00b7 \u2297 wtG(dk)\u2297 wt(r) , (8.1)\nby (2.26). If there is no confusion, then we drop the index G from wtG and just write wt(d) for the weight of d.\nWe define the weighted rule tree language of G, denoted by [[G]]wrt, as the weighted tree language [[G]]wrt : TR \u2192 B defined by the Hadamard product\n[[G]]wrt = wtG \u2297 \u03c7(RTG) .\nWe say that G is finite-derivational if the set RTG(u) is finite for every u \u2208 \u0393\u2217. We note that, if G is finite-derivational, then [[G]]wrt is \u03c7(\u03c0G)-summable (cf. Section 2.10.3) because \u03c0 \u22121 G (u) \u2229 supp([[G]]\nwrt) \u2286 RTG(u) for each u \u2208 \u0393\u2217.\nIf G is finite-derivational or B is \u03c3-complete, then the weighted language generated by G is the weighted language [[G]]s : \u0393\u2217 \u2192 B defined by\n[[G]]s = \u03c7(\u03c0G) ( [[G]]wrt ) .\nThus, for each u \u2208 \u0393\u2217, we have\n[[G]]s(u) = \u03c7(\u03c0G) ( [[G]]wrt ) (u) = \u2211\u2295\nd\u2208\u03c0\u22121G (u)\n[[G]]wrt(d)\n= \u2211\u2295\nd\u2208\u03c0\u22121G (u)\n( wtG \u2297 \u03c7(RTG) ) (d) = \u2211\u2295\nd\u2208RTG(u)\nwtG(d) , (8.2)\nwhere in the second equality we have used (2.30). In the last expression of (8.2), the sum is well defined: if B is \u03c3-complete, then the sum is defined on page 21 and, if in addition G is finite-derivational, then it is equal to\n\u2295 d\u2208RTG(u) wt(d) by (2.6.8); if B is not \u03c3-complete, then G is finite-derivational and the sum\ndenotes \u2295\nd\u2208RTG(u) wt(d) by our convention (cf. page 21). Thus, the sum is well defined for arbitrary B.\nFigure 8.1 illustrates the definition of [[G]]s(u).\nLet G1 and G2 be two (\u0393,B)-wcfg such that both G1 and G2 are finite-derivational or B is \u03c3-complete. Then G1 and G2 are equivalent if [[G1]]s = [[G2]]s.\nA weighted language s : \u0393\u2217 \u2192 B is called (\u0393,B)-weighted context-free language if there exists a (\u0393,B)-wcfg G which is finite-derivational if B is not \u03c3-complete such that s = [[G]]s.\nSince the Boolean semiring Boole = (B,\u2228,\u2227, 0, 1) is \u03c3-complete, for each (\u0393,Boole)-wcfg G, the weighted language [[G]]s : \u0393\u2217 \u2192 B is defined, and the support of [[G]]s is a context-free language. Vice versa, each context-free language over \u0393 is the support of some (\u0393,Boole)-weighted context-free language. Indeed, the concept of weighted context-free grammars generalizes the concept of context-free grammars in the following sense.\nObservation 8.1.1. Let L \u2286 \u0393\u2217. Then the following two statements are equivalent.\n(A) We can construct a \u0393-cfg G which has a terminal rule such that L(G) = L. (B) We can construct a (\u0393,Boole)-wcfg G such that supp([[G]]s) = L.\n8.1. THE GRAMMAR MODEL 155\nProof. Proof of (A)\u21d2(B): Let G = (N,S,R) be a \u0393-cfg with a terminal rule. Then we construct the (\u0393,Boole)-wcfg G = (N,S,R,wt) such that for each r \u2208 R we let wt(r) = 1. Obviously, RTG = RTG and, for each d \u2208 RTG , we have wtG(d) = 1. Then we can prove L(G) = supp([[G]]s) as follows.\nsupp([[G]]s) = supp(\u03c7(\u03c0G)(wtG \u2297 \u03c7(RTG))) = supp(\u03c7(\u03c0G)(\u03c7(RTG)))\n= \u03c0G(supp(\u03c7(RTG))) (by (2.31))\n= \u03c0G(RTG) = L(G) . (because \u03c0G = \u03c0G and RTG = RTG)\nProof of (B)\u21d2(A): Let G = (N,S,R,wt) be a (\u0393,Boole)-wcfg. We distinguish two cases.\nCase (a): For each terminal rule r \u2208 R, we have wt(r) = 0. Then supp([[G]]s) = \u2205. We construct the\n\u0393-cfg G = ({A,S0}, {S0}, R\u2032) where R\u2032 = {A\u2192 \u03b5}. Obviously, L(G) = \u2205.\nCase (b): There exists a terminal rule r \u2208 R for which wt(r) = 1. Then we construct the \u0393-cfg G = (N,S,R\u2032) where R\u2032 = supp(wt). We can view R\u2032 as a ranked alphabet. Hence RTG = RTG \u2229 TR\u2032 . We note that, for each d \u2208 RTG , we have wtG(d) = 1 if d \u2208 TR\u2032 , and wtG(d) = 0 otherwise. Then we can prove\nsupp(wtG \u2297 \u03c7(RTG)) = RTG . (8.3)\nFor this let d \u2208 TR. Then\nd \u2208 supp(wtG \u2297 \u03c7(RTG)) iff wtG(d) = 1 \u2227 d \u2208 RTG iff d \u2208 TR\u2032 \u2227 d \u2208 RTG iff d \u2208 RTG .\nThen we can prove L(G) = supp([[G]]s) as follows.\nsupp([[G]]s) = supp(\u03c7(\u03c0G)(wtG \u2297 \u03c7(RTG)))\n= \u03c0G(supp(wtG \u2297 \u03c7(RTG))) (by (2.31))\n= \u03c0G(RTG) (by (8.3))\n= \u03c0G(RTG) = L(G) . (because \u03c0G = \u03c0G)\nExample 8.1.2. Let G = (N,S,R) be an arbitrary \u0393-cfg which has a terminal rule.\n1. (cf. [CS63, Sec. 2.3]) We consider the \u03c3-complete semiring Nat\u221e = (N\u221e,+, \u00b7, 0, 1) of natural numbers and we define the (\u0393,Nat\u221e)-wcfg G = (N,S,R,wt) such that wt(r) = 1 for each r \u2208 R. Then [[G]]wrt = \u03c7(RTG), i.e., the characteristic mapping of RTG . Obviously, the sets DG,l(S, u) and\n156 CHAPTER 8. WEIGHTED CONTEXT-FREE GRAMMARS\nRTG(u) are in a one-to-one correspondence for each u \u2208 \u0393\u2217, and L(G) = \u03c0G(RTG). Moreover, for each u \u2208 \u0393\u2217, we have\n[[G]]s(u) = \u2211+\nd\u2208RTG(u)\n= |RTG(u)| = |DG,l(S, u)| ,\ni.e., [[G]]s(u) is the number of leftmost derivations of u in G.\n2. We consider the tropical semiring Natmin,+ = (N\u221e,min,+,\u221e, 0), which is \u03c3-complete. Moreover, we define the (\u0393,Natmin,+)-wcfg G = (N,S,R,wt) such that wt(r) = 1 for each r \u2208 R (as above). Then, for every u \u2208 \u0393\u2217 and d \u2208 RTG(u), we have wtG(d) = size(d) and\n[[G]]s(u) = \u2211min\nd\u2208RTG(u)\nsize(d) .\n(We recall that \u2211min is the extension of min to an arbitrary countable index set.) Thus [[G]]s(u) is\nthe minimal size of a rule tree for u. Since size(d) is equal to the length of the leftmost derivation which corresponds to d, also the number [[G]]s(u) is the minimal length of a leftmost derivation of u in G.\nExample 8.1.3. (cf. [FG18, Ex. 1]) Let \u0393 = {a, b}. It is known that the language L = {w \u2208 \u0393\u2217 | |w|a = |w|b} is context-free. It can be generated, for instance, by the \u0393-cfg G = ({S}, S, R), where R is the set of the following rules:\nr1 : S \u2192 SS, r2 : S \u2192 aSb, r3 : S \u2192 bSa, and r4 : S \u2192 \u03b5 .\nNow we consider the tropical semiring Natmin,+ and define the (\u0393,Natmin,+)-wcfg G = ({S}, S, R,wt), where wt(r1) = wt(r2) = wt(r3) = 0 and wt(r4) = 1.\nIn Figure 8.2, we show two rule trees d1 and d2 of G, for which the following hold: \u03c0G(d1) = ab, \u03c0G(d2) = abab, hence d1 \u2208 RTG(ab) and d2 \u2208 RTG(abab). Clearly, wt(d1) = wt(d2) = 2.\nNote that G is not finite-derivational. In fact, for each u \u2208 L, the set RTG(u) is not finite. However, the semiring Natmin,+ is \u03c3-complete. Moreover, due to the fact that there exists only one nonterminal, we have RTG = TR (recall that we view R as a ranked alphabet).\nIt is clear that, for each d \u2208 RTG , the weight wt(d) is the number of the occurrences of r4 (i.e., the erasing rule) in d. Let us denote this number by #ers(d). Hence, for each d \u2208 TR, we have\n[[G]]wrt(d) = #ers(d) .\nMoreover, for each u \u2208 \u0393\u2217 we have [[G]]s(u) = \u2211min\nd\u2208RTG(u)\n#ers(d)."
        },
        {
            "heading": "8.2 Normal forms of wcfg",
            "text": "Now we define wcfg which satisfy particular properties. Let G = (N,S,R,wt) be a (\u03a3,B)-wcfg. We say that G is\n\u2022 in nonterminal form if, for each rule A\u2192 \u03b1 in R, either \u03b1 \u2208 \u0393 or \u03b1 \u2208 N\u2217, \u2022 start-separated if it has exactly one initial nonterminal and this nonterminal does not occur in the right-hand side of a rule, \u2022 chain-free if G does not have chain rules, and \u2022 \u03b5-free if G does not have \u03b5-rules.\nMoreover,\n\u2022 a rule tree d \u2208 RTG is local-successful if wt(d(w)) 6= 0 for each w \u2208 pos(d), \u2022 a nonterminal A \u2208 N is local-useful if there exists a local-successful d \u2208 RTG such that A occurs in d, and \u2022 G is local-reduced if supp(wt) = R and each nonterminal in N is local-useful.\nFinally, we call a nonterminal A \u2208 N nullable if RTG(A, \u03b5) 6= \u2205.\nWe note that G has a local-useful nonterminal if and only if it has a local-successful rule tree.\nObservation 8.2.1. Let G = (N,S,R,wt) be a finite-derivational and local-reduced (\u0393,B)-wcfg. Then, for every A \u2208 N and u \u2208 \u0393\u2217, the set RTG(A, u) is finite.\nProof. We prove by contradiction. We assume that there exist A \u2208 N and u \u2208 \u0393\u2217 such that RTG(A, u) is not finite. Since G is local-reduced, there exists an x \u2208 \u0393\u2217 and a rule tree d \u2208 RTG(x) such that A occurs in d, i.e., there exists a w \u2208 pos(d) with lhs(d(w)) = A. Then there exists a y \u2208 \u0393\u2217 such that for each d\u2032 \u2208 RTG(A, u), we have d[d\u2032]w \u2208 RTG(y). Hence RTG(y) is not finite which contradicts that G is finite-derivational.\nObservation 8.2.2. If the (\u0393,B)-wcfg G is chain-free and \u03b5-free, then it is finite-derivational.\nProof. Let G = (N,S,R,wt) be chain-free and \u03b5-free. By induction on TR, we prove that the following statement holds:\nFor each d \u2208 TR, we have size(d) \u2264 2 |\u03c0G(d)|. (8.4)\nFor this, let d = r(d1, . . . , dk) be in TR with r = (A \u2192 u0A1u1 \u00b7 \u00b7 \u00b7Akuk). Since G is chain-free, in case k = 1 we have |u0u1| > 0. Moreover, since G is \u03b5-free, we have that |\u03c0G(di)| > 0 for each i \u2208 [k]. Then we can calculate as follows:\nsize(r(d1, . . . , dk)) = 1 ++ i\u2208[k] size(di)\n\u2264 1 ++ i\u2208[k] 2|\u03c0G(di)| (by I.H.)\n\u2264 2|u0u1\u00b7\u00b7\u00b7uk| \u00b7 2|\u03c0G(d1)| \u00b7 . . . \u00b7 2|\u03c0G(dk)| (since G is chain-free and \u03b5-free)\n= 2|u0u1\u00b7\u00b7\u00b7uk|++i\u2208[k]|\u03c0G(di)| = 2|\u03c0G(r(d1,...,dk))| .\nBy (8.4), for every u \u2208 \u0393\u2217 and d \u2208 RTG(u), we have that size(d) \u2264 2|u|, and hence G is finite-derivational.\n158 CHAPTER 8. WEIGHTED CONTEXT-FREE GRAMMARS\nNext we show the following normal form constructions for wcfg:\n\u2022 nonterminal form, \u2022 start-separated, \u2022 local-reduced, \u2022 chain-free, and \u2022 \u03b5-free.\nLemma 8.2.3. Let G be a (\u0393,B)-wcfg such that G is finite-derivational or B is \u03c3-complete. We can construct a (\u0393,B)-wcfg G\u2032 such that G\u2032 is in nonterminal form and [[G\u2032]]s = [[G]]s. Moreover, the construction preserves the properties finite-derivational, start-separated, chain-free, \u03b5-free, and local-reduced.\nProof. Let G = (N,S,R,wt). We construct the (\u0393,B)-wcfg G\u2032 = (N \u2032, S, R\u2032, wt\u2032) such that N \u2032 = N \u222a{Aa | a \u2208 \u0393} and, for each rule r = (A\u2192 \u03b1) in R,\n\u2022 if \u03b1 \u2208 \u0393, then r is in R\u2032; we let wt\u2032(r) = wt(r), \u2022 otherwise the rule r\u2032 = (A \u2192 \u03b1\u2032) is in R\u2032 where \u03b1\u2032 is obtained from \u03b1 by replacing each symbol a \u2208 \u0393 by Aa; we let wt\u2032(r\u2032) = wt(r).\nMoreover, for each a \u2208 \u0393, the rule Aa \u2192 a is in R \u2032 with wt\u2032(Aa \u2192 a) = 1.\nClearly, G\u2032 is in nonterminal form and the construction preserves the mentioned properties. In particular, if G is finite-derivational, then so is G\u2032. Hence [[G\u2032]]s is defined. It is clear that, for each u \u2208 \u0393\u2217, the sets RTG(u) and RTG\u2032(u) are in a one-to-one correspondence, and wtG(d) = wtG\u2032(d \u2032) if d and d\u2032 correspond to each other. Thus [[G]]s = [[G\u2032]]s.\nLemma 8.2.4. Let G be a (\u0393,B)-wcfg such that G is finite-derivational or B is \u03c3-complete. We can construct a (\u0393,B)-wcfg G\u2032 such that G\u2032 is start-separated and [[G\u2032]]s = [[G]]s. Moreover, the construction preserves the properties finite-derivational, nonterminal form, \u03b5-free, and local-reduced. The construction does not preserve the property chain-free.\nProof. Let G = (N,S,R,wt). We construct the (\u0393,B)-wcfg G\u2032 = (N \u2032, S0, R \u2032, wt\u2032) as follows. We let N \u2032 = N \u222a {S0} where S0 6\u2208 N \u222a \u0393. The set R\u2032 contains the following rules.\n\u2022 For each A \u2208 S, the rule r = (S0 \u2192 A) is in R\u2032 with wt\u2032(r) = 1. \u2022 Each rule r \u2208 R is in R\u2032 with wt\u2032(r) = wt(r).\nIt is clear that G\u2032 is start-separated and that the construction preserves the mentioned properties. In particular, if G is finite-derivational, then so is G\u2032. Hence [[G\u2032]]s is defined. Moreover, it is clear that,\nfor every A \u2208 N and u \u2208 \u0393\u2217, we have RTG(A, u) = RTG\u2032(A, u) and wtG(d) = wtG\u2032(d) for each d \u2208 RTG(A, u). (8.5)\nWe can prove that [[G]]s = [[G\u2032]]s as follows. Let u \u2208 \u0393\u2217. Then [[G]]s(u) = \u2211\u2295\nd\u2208RTG(S,u)\nwtG(d) (by (8.2))\n= \u2295\nA\u2208S\n\u2211\u2295\nd\u2208RTG(A,u)\nwtG(d) (because the family (RTG(A, u) | A \u2208 S) partitions RTG(S, u).)\n= \u2295\nA\u2208S\n\u2211\u2295\nd\u2032\u2208RTG\u2032 (A,u)\nwtG\u2032(d \u2032) (by (8.5))\n= \u2295\nA\u2208S\n\u2211\u2295\nd\u2032\u2208RTG\u2032 (A,u)\nwtG\u2032(d \u2032)\u2297 wt\u2032(S0 \u2192 A)\n= \u2211\u2295\nd\u2032\u2032\u2208RTG\u2032 (S0,u)\nwtG\u2032(d \u2032\u2032)\n(because the family ({(S0 \u2192 A)(d\u2032) | d\u2032 \u2208 RTG\u2032(A, u)} | A \u2208 S) partitions RTG\u2032(S0, u))\n8.2. NORMAL FORMS OF WCFG 159\n= [[G\u2032]]s(u).\nNext we will prove that for each wcfg we can construct an equivalent local-reduced wcfg. We follow the outline of the proof of constructing an equivalent local-trim wta from a given wta (cf. Theorem 7.1.4). As an auxiliary tool, we associate to each (\u0393,B)-wcfg G = (N,S,R,wt), the context-free grammar G(G) = (N \u222a {S0}, S0, P ) over \u0393, where S0 is a new symbol and P is the smallest set of rules such that\n\u2022 for each A \u2208 S, the rule S0 \u2192 A is in P and \u2022 supp(wt) \u2286 P .\nThen it is obvious that a nonterminal A \u2208 N is local-useful in G if and only if it is useful in G(G). This implies that G is local-reduced if and only if G(G) is reduced.\nLemma 8.2.5. Let G be a (\u0393,B)-wcfg such that G is finite-derivational or B is \u03c3-complete. If G has a local-successful rule tree, then we can construct a (\u0393,B)-wcfg G\u2032 such that G\u2032 is local-reduced and [[G\u2032]]s = [[G]]s. Moreover, the construction preserves the properties finite-derivational, nonterminal form, start-separated, chain-free, and \u03b5-free.\nProof. Let G = (N,S,R,wt). We can construct the context-free grammar G(G) = (N \u222a {S0}, S0, P ) associated to G. Due to our assumption on G we have L(G(G)) 6= \u2205. Thus, by Theorem 2.12.1, a contextfree grammar G\u2032 = (N \u2032, S0, P\n\u2032) can be constructed such that G\u2032 is reduced and L(G\u2032) = L(G(G)). By the proof of that theorem, we know that N \u2032 = Nu \u222a {S0}, where Nu is the set of all useful nonterminals in N . Moreover, Nu 6= \u2205 by our assumption on G.\nNow let G\u2032 = (Nu, S \u2229Nu, R\u2032, wt\u2032) be the (\u0393,B)-wcfg such that \u2022 R\u2032 = {(A\u2192 \u03b1) \u2208 R | A \u2208 Nu, \u03b1 \u2208 (Nu \u222a \u0393)\u2217} and \u2022 wt\u2032(r) = wt(r) for each r \u2208 R\u2032.\nWe note that, since G has a local-successful rule tree, there exists a terminal rule B \u2192 u in R and B is useful in G(G). This rule is also in R\u2032, hence R\u2032 contains a terminal rule. Moreover, it is obvious that G\u2032 is local-reduced and the mentioned properties are preserved. Thus, in particular, [[G\u2032]] is defined.\nLastly, we prove that [[G]]s = [[G\u2032]]s. Let u \u2208 \u0393\u2217. Obviously, RTG\u2032(u) \u2286 RTG(u) and for each d \u2208 RTG\u2032(u) we have wtG\u2032(d) = wtG(d). For each d \u2208 RTG(u) \\ RTG\u2032(u), there exists A \u2032 \u2208 N such that A\u2032 occurs in d and A\u2032 is not local-useful. Hence wtG(d) = 0. Thus we can compute\n[[G]]s(u) = \u2295\nd\u2208RTG(u)\nwtG(d) = \u2295\nd\u2208RTG\u2032 (u)\nwtG\u2032(d) = [[G \u2032]]s(u).\nNext we show how a wcfg can be transformed into an equivalent chain-free wcfg.\nTheorem 8.2.6. (cf. [KS86, Thm. 14.2]) Let \u0393 be an alphabet, B be a semiring, and G be a (\u0393,B)wcfg such that (a) G is finite-derivational or (b) B is \u03c3-complete. Then there exists a (\u0393,B)-wcfg G\u2032 such that G\u2032 is chain-free and [[G\u2032]]s = [[G]]s. If G has one of the following properties, then also G\u2032 has it: finite-derivational, nonterminal form, start-separated, \u03b5-free, and local-reduced. Moreover, if G is finite-derivational, then we can even construct G\u2032.\nProof. Let G = (N,S,R,wt). By standard pumping methods, we can decide whether G has a localsuccessful rule tree. If the answer is no, then [[G]]s = 0\u0303 and thus the statement of the lemma holds obviously. Otherwise, by Lemma 8.2.5 we can construct a (\u0393,B)-wcfg which is local-reduced and equivalent to G. So we may assume that G is local-reduced.\nWe will prove the theorem by case analysis according to the Cases (a) and (b). Before doing so, we make some common preparations. Since B is a semiring, we can consider the semiring (BN\u00d7N ,+, \u00b7,M0,M1) of all N -square matrices over B (where we assume an arbitrary but fixed linear\n160 CHAPTER 8. WEIGHTED CONTEXT-FREE GRAMMARS\norder on N).2 We define the N -square matrix M over B such that, for every A,A\u2032 \u2208 N :\nMA\u2032,A =\n{ wt(r) if r = (A\u2192 A\u2032) is in R\n0 otherwise.\nThen, for each n \u2208 N, we define the N -square matrix Mn over B such that M0 = M1 and Mn+1 = Mn \u00b7M . Since \u2297 is distributive with respect to \u2295, for each n \u2208 N+ and A,A \u2032 \u2208 N , we have\n(Mn)A\u2032,A = \u2295\nC1,...,Cn+1\u2208N : C1=A,Cn+1=A \u2032\n\u2297\nj\u2208[0,n\u22121]\nMCn+1\u2212j,Cn\u2212j . (8.6)\nHence, (Mn)A\u2032,A is the sum of all products\nwt(rn)\u2297 \u00b7 \u00b7 \u00b7 \u2297 wt(r1), (8.7)\nwhere, for each i \u2208 [n], ri is a chain-rule of the form Ci \u2192 Ci+1 such that C1 = A and Cn+1 = A\u2032.\nWe start the proof with Case (b), i.e., we assume that B is \u03c3-complete. Then also the semiring\n(BN\u00d7N ,+, \u00b7,M0,M1) is \u03c3-complete and hence the matrix M\u2217 is well defined where M\u2217 = \u2211+\nn\u2208N\nMn.\nHence, (M\u2217)A\u2032,A is the sum of all products (8.7) for some n \u2208 N.\nThen we eliminate the chain rules from G (cf., e.g., [E\u0301K03, Thm. 3.2], [FMV11, Lm. 3.2], and [FHV18, Thm. 6.3]). We define the (\u0393,B)-wcfg G\u2032 = (N,S,R\u2032, wt\u2032) as follows. Let\nR\u2032 = {A\u2192 \u03b1 | A \u2208 N,\u03b1 6\u2208 N, (\u2203A\u2032 \u2208 N) : A\u2032 \u2192 \u03b1 is in R}.\nMoreover, for each rule A\u2192 \u03b1 in R\u2032, we define\nwt\u2032(A\u2192 \u03b1) = \u2295\nA\u2032\u2208N : (A\u2032\u2192\u03b1)\u2208R\nwt(A\u2032 \u2192 \u03b1)\u2297 (M\u2217)A\u2032,A .\nObviously, G\u2032 is chain-free and each mentioned property is preserved. In particular, [[G\u2032]]s is defined.\nIn fact, the above definition of G\u2032 is the same as the corresponding one in the proof of [FHV18, Thm. 6.3] for the case that (i) the storage type is the trivial one and (ii) the M-monoidK is the M-monoid associated with the \u03c3-complete semiring B (for the concept of \u201cM-monoid associated with a semiring\u201d cf. [FMV09, Def. 8.5] or [FSV12, p. 261]). By instantiating the correctness proof of [FHV18, Thm. 6.3] to the case specified by (i) and (ii), we obtain a proof of [[G\u2032]]s = [[G]]s. For the sake of \u03c3-completeness, we repeat this correctness proof here.\nWe note that, in virtue of the definition of G\u2032, we cannot construct G\u2032. This is due to the fact that the definition of the weights of rules involves the matrix M\u2217, and, although M\u2217 is well defined, in general, we cannot compute it algorithmically.\nFor the inductive definition of a mapping that relates rule trees of G with rule trees of G\u2032, we employ the well-founded set (RTG(N,\u0393 \u2217),\u227a) where we let\n\u227a = \u227aR \u2229 (RTG(N,\u0393 \u2217)\u00d7 RTG(N,\u0393 \u2217))\n(for the definition of \u227aR we refer to page 43). Obviously, \u227a is well-founded and min\u227a(RTG(N,\u0393 \u2217)) is the set of terminal rules of R, which is not empty. We define the mapping eff : RTG(N,\u0393 \u2217) \u2192 RTG\u2032(N,\u0393\u2217) by induction on (RTG(N,\u0393 \u2217),\u227a) as follows. Let d \u2208 RTG(N,\u0393\u2217). Then\n\u2022 there exist n \u2208 N and rules r1 = (C1 \u2192 C2), . . . , rn = (Cn \u2192 Cn+1), and Cn+1 \u2192 \u03b1 with \u03b1 = u0A1u1 . . . Akuk in R such that \u03b1 6\u2208 N and\n2The multiplication \u00b7 of matrices is associative only if the multiplication \u2297 of B distributes over \u2295.\n8.2. NORMAL FORMS OF WCFG 161\n\u2022 for each i \u2208 [k] there exists a rule tree di \u2208 RTG(Ai,\u0393\u2217)\nsuch that d = r1 . . . rn(Cn+1 \u2192 \u03b1) ( d1, . . . , dk ) . We define\neff(d) = (C1 \u2192 \u03b1)(eff(d1), . . . , eff(dk)).\nThen lhs(eff(di)(\u03b5)) = Ai for each i \u2208 [k]. Moreover,\nfor every A \u2208 N , u \u2208 \u0393\u2217, and d \u2208 RTG(N,\u0393 \u2217) we have: d \u2208 RTG(A, u) if and only if eff(d) \u2208 RTG\u2032(A, u) . (8.8)\nNext we will prove a relationship between the weights of rule trees that are related by eff. For this we use the well-founded set (RTG\u2032(N,\u0393 \u2217),\u227a\u2032) where we let\n\u227a\u2032 = \u227aR\u2032 \u2229 (RTG\u2032(N,\u0393 \u2217)\u00d7 RTG\u2032(N,\u0393 \u2217)) .\nAgain, \u227a\u2032 is well-founded and min\u227a\u2032(RTG\u2032(N,\u0393\u2217)) is the set of terminal rules of R\u2032, which is not empty. Then, by induction on (RTG\u2032(N,\u0393 \u2217),\u227a\u2032), we prove that the following statement holds.\nFor every d\u2032 \u2208 RTG\u2032(N,\u0393 \u2217) we have\n\u2211\u2295\nd\u2208RTG(N,\u0393 \u2217):\neff(d)=d\u2032\nwt(d) = wt\u2032(d\u2032) . (8.9)\nLet d\u2032 \u2208 RTG\u2032(N,\u0393\u2217). Hence there exist A \u2208 N and u \u2208 \u0393\u2217 such that d\u2032 \u2208 RTG\u2032(A, u). Then \u2022 there exists a rule r\u2032 = (A\u2192 \u03b1) in R\u2032 with \u03b1 = u0A1u1 . . . Akuk, k \u2208 N+, and \u03b1 6\u2208 N and \u2022 for each i \u2208 [k] there exist vi \u2208 \u0393\u2217 and d\u2032i \u2208 RTG\u2032(Ai, vi)\nsuch that u = u0v1u1 \u00b7 \u00b7 \u00b7 vkuk and d\u2032 = r\u2032(d\u20321, . . . , d \u2032 k). Then we can calculate as follows:\n\u2211\u2295\nd\u2208RTG(N,\u0393 \u2217):\neff(d)=d\u2032\nwt(d) = \u2211\u2295\nd\u2208RTG(A,u): eff(d)=r\u2032(d\u20321,...,d \u2032 k)\nwt(d) (by (8.8))\n= \u2211\u2295\nn\u2208N\n\u2295\nC1,...,Cn+1\u2208N : C1=A\n\u2211\u2295\nd1\u2208RTG(A1,v1),...,dk\u2208RTG(Ak,vk): (\u2200i\u2208[k]):eff(di)=d\n\u2032 i(\u2297\ni\u2208[k]\nwt(di) ) \u2297 wt(Cn+1 \u2192 u0A1u1 . . . Akuk)\u2297 \u2297\nj\u2208[0,n\u22121]\nMCn+1\u2212j,Cn\u2212j\n= \u2211\u2295\nn\u2208N\n\u2295\nC1,...,Cn+1\u2208N : C1=A\n(\u2297\ni\u2208[k]\n\u2211\u2295\ndi\u2208RTG(Ai,vi): eff(di)=d \u2032 i\nwt(di) )\n\u2297 wt(Cn+1 \u2192 u0A1u1 . . . Akuk)\u2297 \u2297\nj\u2208[0,n\u22121]\nMCn+1\u2212j,Cn\u2212j (because B is distributive)\n= \u2211\u2295\nn\u2208N\n\u2295\nC1,...,Cn+1\u2208N : C1=A\n(\u2297\ni\u2208[k]\nwt\u2032(d\u2032i) ) \u2297 wt(Cn+1 \u2192 u0A1u1 . . . Akuk)\u2297 \u2297\nj\u2208[0,n\u22121]\nMCn+1\u2212j,Cn\u2212j (by I.H.)\n= \u2295\nA\u2032\u2208N\n\u2211\u2295\nn\u2208N\n\u2295\nC1,...,Cn+1\u2208N : C1=A,Cn+1=A \u2032\n(\u2297\ni\u2208[k]\nwt\u2032(d\u2032i) ) \u2297 wt(A\u2032 \u2192 u0A1u1 . . . Akuk)\u2297 \u2297\nj\u2208[0,n\u22121]\nMCn+1\u2212j,Cn\u2212j\n(by renaming of Cn+1 by A \u2032)\n= (\u2297\ni\u2208[k]\nwt\u2032(d\u2032i) ) \u2297 ( \u2295\nA\u2032\u2208N\nwt(A\u2032 \u2192 u0A1u1 . . . Akuk) ) \u2297 \u2211\u2295\nn\u2208N\n\u2295\nC1,...,Cn+1\u2208N : C1=A,Cn+1=A \u2032\n\u2297\nj\u2208[0,n\u22121]\nMCn+1\u2212j,Cn\u2212j\n(by distributivity)\n162 CHAPTER 8. WEIGHTED CONTEXT-FREE GRAMMARS\n= (\u2297\ni\u2208[k]\nwt\u2032(d\u2032i) ) \u2297 ( \u2295\nA\u2032\u2208N\nwt(A\u2032 \u2192 u0A1u1 . . . Akuk) ) \u2297 \u2211\u2295\nn\u2208N\n(Mn)A\u2032,A (by (8.6))\n= (\u2297\ni\u2208[k]\nwt\u2032(d\u2032i) ) \u2297 ( \u2295\nA\u2032\u2208N\nwt(A\u2032 \u2192 u0A1u1 . . . Akuk) ) \u2297 (\u2211+\nn\u2208N\n(Mn) ) A\u2032,A\n= (\u2297\ni\u2208[k]\nwt\u2032(d\u2032i) ) \u2297 ( \u2295\nA\u2032\u2208N\nwt(A\u2032 \u2192 u0A1u1 . . . Akuk) \u2297 (M \u2217)A\u2032,A\n)\n= (\u2297\ni\u2208[k]\nwt\u2032(d\u2032i) ) \u2297 wt\u2032(r\u2032) (by the definition of G\u2032)\n= wt\u2032(r\u2032(d\u20321, . . . , d \u2032 k)).\nThis proves (8.9).\nThen we can prove for each u \u2208 \u0393\u2217:\n[[G]]s(u) = \u2211\u2295\nd\u2208RTG(\u03be)\nwt(d) = \u2295\nA\u2208S\n\u2211\u2295\nd\u2208RTG(A,u)\nwt(d) = \u2295\nA\u2208S\n\u2211\u2295\nd\u2032\u2208RTG\u2032 (A,u)\n\u2211\u2295\nd\u2208RTG(A,u): eff(d)=d\u2032\nwt(d)\n= \u2295\nA\u2208S\n\u2211\u2295\nd\u2032\u2208RTG\u2032 (A,u)\nwt\u2032(d\u2032) (by (8.9))\n= \u2211\u2295\nd\u2032\u2208RTG\u2032 (u)\nwt\u2032(d\u2032) = [[G\u2032]]s(u) .\nNow we continue the proof with Case (a), i.e., we assume that G is finite-derivational. Since G is localreduced and finite-derivational, the length of sequences of chain rules in A-rule trees of G is bounded by |N | \u2212 1 for each A \u2208 N . We show this statement by contradiction. For this, let us assume that there exist a string u \u2208 \u0393\u2217 and a d \u2208 RTG(A, u) such that d contains a sequence of chain rules of length at least |N |. Then a nonterminal is repeated in that sequence and, by applying the standard pumping argument, we obtain that RTG(A, u) is not finite. However, this contradicts Observation 8.2.1.\nThis boundedness property gives us the possibility to construct G\u2032, because, in order to eliminate the chain rules from G, now we can use the matrix +\nn\u2208[0,|N |\u22121]\nMn.\nThus, we construct the (\u0393,B)-wcfg G\u2032 = (N,S,R\u2032, wt\u2032) as follows. As in Case (b), we let\nR\u2032 = {A\u2192 \u03b1 | A \u2208 N,\u03b1 6\u2208 N, (\u2203A\u2032 \u2208 N) : A\u2032 \u2192 \u03b1 is in R}.\nMoreover, for each rule A\u2192 \u03b1 in R\u2032, we define\nwt\u2032(A\u2192 \u03b1) = \u2295\nA\u2032\u2208N : (A\u2032\u2192\u03b1)\u2208R\nwt(A\u2032 \u2192 \u03b1)\u2297 ( +\nn\u2208[0,|N |\u22121]\nMn ) A\u2032,A .\nObviously, G\u2032 is chain-free and, again, all the mentioned properties are preserved. Thus, since G is finite-derivational, also G\u2032 is so, hence [[G\u2032]]s is defined. By induction on (RTG\u2032(N,\u0393\u2217),\u227a\u2032) (where \u227a\u2032 is the well-founded relation defined in the proof of Case (b) above), we prove that the following statement holds:\nFor every d\u2032 \u2208 RTG\u2032(N,\u0393 \u2217), we have\n\u2295\nd\u2208RTG(N,\u0393 \u2217):\neff(d)=d\u2032\nwt(d) = wt\u2032(d\u2032). (8.10)\n8.2. NORMAL FORMS OF WCFG 163\nThe proof of (8.10) is the same as the proof of (8.9) except that the four infinite summations\n\u2211\u2295\nd\u2208RTG(A,u): eff(d)=r\u2032(d\u20321,...,d \u2032 k)\nand \u2211\u2295\ndi\u2208RTG(Ai,vi): eff(di)=d \u2032 i\nand \u2211\u2295\nn\u2208N\nand \u2211+\nn\u2208N\nare replaced by the finite summations\n\u2295\nd\u2208RTG(A,u): eff(d)=r\u2032(d\u20321,...,d \u2032 k)\nand \u2295\ndi\u2208RTG(Ai,vi): eff(di)=d \u2032 i\nand \u2295\nn\u2208[0,|N |\u22121] and + n\u2208[0,|N |\u22121] , respectively,\nas well as,\n(M\u2217)A\u2032,A is replaced by ( +\nn\u2208[0,|N |\u22121]\nMn ) A\u2032,A .\nBy a similar modification of the final calculation of (b) we obtain the proof for [[G]]s = [[G\u2032]]s.\nIn the next theorem we deal with the transformation of a (\u0393,B)-wcfg into an \u03b5-free one. More precisely, for a given (\u0393,B)-wcfg G = (N,S,R,wt) such that (a) B is a commutative semiring and (b) G is finitederivational or B is \u03c3-complete, we define an \u03b5-free (\u0393,B)-wcfg G\u2032 such that [[G\u2032]]s = [[G]]s \u2297 \u03c7B(\u0393+). We follow the idea of [BPS61, Lm. 4.1] (also cf. [HMU07, Subsec. 7.1.3]) where context-free grammars are transformed into (almost) equivalent \u03b5-free context-free grammars. However, here we have to be careful about the weights and have to cope with two phenomena.\nWe explain the first phenomenon by means of an example. Let G contain the initial nonterminal A and the three rules\nr = (A\u2192 aCC), r\u2032 = (C \u2192 b), and r\u2032\u2032 = (C \u2192 \u03b5).\nThen RTG(A, ab) = {d1, d2} with d1 = r(r\u2032, r\u2032\u2032) and d2 = r(r\u2032\u2032, r\u2032). Hence\n[[G]]s(ab) = wtG(d1)\u2295 wtG(d2) .\nAccording to the construction of [BPS61, Lm. 4.1], the wcfg G\u2032 contains the rules r, r\u2032, and r\u0304 = (A\u2192 aC), where r\u0304 results from r by erasing either the first occurrence of C or the second one. Thus RTG\u2032(A, ab) = {r\u0304(r\u2032)} and\n[[G\u2032]]s(ab) = wtG\u2032(r\u0304(r \u2032)) .\nWe observe that this construction does not take care of the different ways in which a right-hand side (e.g. aC) results from erasing nonterminals from the right-hand side of the G-rule (e.g. aCC). In this particular example, we could define the weights of the rules of G\u2032 such that the weight balance [[G]]s(ab) = [[G\u2032]]s(ab) is satisfied. But in general, rules of G call each other recursively, and then this method of defining weights is not successful. Instead, we will code the occurrences of nonterminals which are selected for erasing into the rules of G\u2032, and thereby we keep the different ways in which a rule for G\u2032 was obtained separately.\nThe second phenomenon is the fact that the empty string \u03b5 can be derived in many different ways, and G\u2032 has to sum up the weights of all the corresponding rule trees. For instance, if there exists a rule r = (C \u2192 aAb) in R and we have detected that A is nullable, i.e., RTG(A, \u03b5) 6= \u2205, then according to the construction in [BPS61, Lm. 4.1] the rule r\u2032 = (C \u2192 ab) will be in G\u2032 and the weight of r\u2032 in G\u2032 will be wt(r) \u2297W (A), where we define\nW (A) = \u2211\u2295\nd\u2208RTG(A,\u03b5)\nwtG(d) .\nBy our assumptions on G and B, the value W (A) is well defined. We note that, if RTG(A, \u03b5) = \u2205, then W (A) = 0. If G is not finite-derivational (and hence B is \u03c3-complete), it is in general not clear how to construct W (A). However, if G is finite-derivational, then W (A) can be computed.\n164 CHAPTER 8. WEIGHTED CONTEXT-FREE GRAMMARS\nObservation 8.2.7. Let G = (N,S,R,wt) be a finite-derivational and local-reduced (\u0393,B)-wcfg. Then, for each A \u2208 N , we can compute W (A).\nProof. First we show that\nRTG(A, \u03b5) = {d \u2208 RTG(A, \u03b5) | height(d) \u2264 |N | \u2212 1} . (8.11)\nWe prove (8.11) by contradiction and assume that there exists a d \u2208 RTG(A, \u03b5) such that height(d) \u2265 |N |. Then there exist w \u2208 pos(d) and v \u2208 N+ such that lhs(d(w)) = lhs(d(wv)). Then, using c as abbreviation for the context (d|w)[z]v, we obtain that d[cn[d|wv]]w \u2208 RTG(A, \u03b5) for each n \u2208 N. Hence RTG(A, \u03b5) is not finite, which contradicts Observation 8.2.1. This proves (8.11).\nThen we have\nW (A) = \u2211\u2295\nd\u2208RTG(A,\u03b5)\nwtG(d)\n= \u2211\u2295\nd\u2208RTG(A,\u03b5): height(d)\u2264|N |\u22121\nwtG(d) (by (8.11))\n= \u2295\nd\u2208RTG(A,\u03b5): height(d)\u2264|N |\u22121\nwtG(d) (by Observation 2.6.8(2))\nObviously, \u2295\nd\u2208RTG(A,\u03b5): height(d)\u2264|N |\u22121\nwtG(d) can be computed.\nThe next theorem has been achieved in [KS86, Thm. 14.6] for wcfg over a partially ordered, continuous, and commutative semiring B. We follow the construction given in [KS86, Thm. 14.6].\nTheorem 8.2.8. (cf. [KS86, Thm. 14.6]) Let \u0393 be an alphabet, B be a commutative semiring, and G be a (\u0393,B)-wcfg such that G is finite-derivational or B is \u03c3-complete. Then there exists an \u03b5-free (\u0393,B)-wcfg G\u2032 such that [[G\u2032]]s = [[G]]s \u2297 \u03c7B(\u0393+). If G is finite-derivational, then we can construct G\u2032.\nProof. Let G = (N,S,R,wt). By standard pumping methods, we can decide whether G has a localsuccessful rule tree. If the answer is no, then [[G]]s = 0\u0303. Hence, the statement of the theorem holds obviously because we can construct an \u03b5-free (\u0393,B)-wcfg G\u2032 such that [[G\u2032]]s = 0\u0303.\nOtherwise, by Lemma 8.2.3 and Lemma 8.2.5, we can construct a (\u0393,B)-wcfg which is in nonterminal form, local-reduced, and equivalent to G. Hence we can assume that G is in nonterminal form and local-reduced. Then we distinguish two cases.\nCase (a): Each terminal rule of G is an \u03b5-rule. Then [[G]]s \u2297 \u03c7B(\u0393 +) = 0\u0303. Again, the statement of the\ntheorem holds obviously.\nCase (b): There exists a terminal rule of G, say A \u2192 u, such that u 6= \u03b5. Since G is in nonterminal form, we have u \u2208 \u0393. We will use this property when we construct G\u2032. But before this we need some preparations.\nAs in the case of context-free grammars, we construct the set of nullable nonterminal symbols (cf. [BPS61, Lm. 4.1]), i.e., the set\nE = {A \u2208 N | RTG(A, \u03b5) 6= \u2205} .\nIn order to prepare for the above mentioned first phenomenon, we introduce the concept of E-selection. Intuitively, an E-selection is a string over {0, 1} and it shows, for a given right-hand side \u03b1 \u2208 (N\u222a\u0393)\u2217 of a rule and each of its nonterminal occurrences, whether that occurrence is selected for erasing (represented by 1) or not (represented by 0). Formally, let \u03b1 = u0A1u1 . . . Akuk be in (N \u222a \u0393)\u2217. An E-selection for\n8.2. NORMAL FORMS OF WCFG 165\n\u03b1 is a string f = f1 \u00b7 \u00b7 \u00b7 fk with fi \u2208 {0, 1} such that, for every i \u2208 [k], if fi = 1, then Ai \u2208 E, i.e., only occurrences of nullable nonterminals can be selected for erasing. In particular, for each u \u2208 \u0393\u2217, the only E-selection is f = \u03b5.\nFor instance, if \u03b1 = aAbDCC, E = {C,D}, then f = 0110 is an E-selection. It indicates that the occurrence of D and the leftmost occurrence of C are selected for erasing, and the other two occurrences of nonterminals are not.\nLet \u03b1 = u0A1u1 . . . Akuk in (N \u222a \u0393)\u2217 and f be an E-selection for \u03b1. Then we define the application of f to \u03b1, denoted by f(\u03b1), to be the string u0X1u1 . . . Xkuk, where for each i \u2208 [k]:\nXi =\n{ \u03b5 if fi = 1\nAi otherwise.\nIn particular, for each u \u2208 \u0393\u2217, we have \u03b5(u) = u. For \u03b1 and f in the above example we have f(\u03b1) = aAbC.\nFor each nonterminal which is not selected by f for erasing, we will have to know its target position in f(\u03b1). Formally, let f = f1 \u00b7 \u00b7 \u00b7 fk be an E-selection for \u03b1. We let pos0(f) = {i \u2208 [k] | fi = 0}. Then we define the mapping gf : pos0(f)\u2192 [|pos0(f)|] for each i \u2208 pos0(f) by gf (i) = j if the jth occurrence of 0 in f (counted from left to right) has position i. We note that gf is bijective. For f in the above example, we have pos0(f) = {1, 4} and gf (1) = 1 and gf (4) = 2.\nNow we define the (\u0393,B)-wcfg G\u2032 = (N \u2032, S, R\u2032, wt\u2032) as follows. \u2022 N \u2032 = N \u222a {[\u03b1, f ] | ( \u2203(A\u2192 \u03b1) in R ) : f is an E-selection for \u03b1} and \u2022 R\u2032 and wt\u2032 are defined as follows. For every r = (A\u2192 \u03b1) with \u03b1 = u0A1u1 . . . Akuk in R and \u03b1 6= \u03b5, and E-selection f for \u03b1 such that f(\u03b1) 6= \u03b5,\n\u2013 the rule r\u2032 = (A\u2192 [\u03b1, f ]) is in R\u2032 with wt\u2032(r\u2032) = wt(r) and \u2013 the rule r\u2032\u2032 = ([\u03b1, f ]\u2192 f(\u03b1)) is in R\u2032 with\nwt\u2032(r\u2032\u2032) = \u2297\ni\u2208[k]: fi=1\nW (Ai) .\nIn particular, if {i \u2208 [k] | fi = 1} = \u2205, then wt\u2032(r\u2032\u2032) = 1.\nSince R contains a terminal rule A\u2192 u with u \u2208 \u0393, the set R\u2032 contains the rule [u, \u03b5]\u2192 u, and hence the \u0393-cfg (N \u2032, S, R\u2032) contains a terminal rule. Thus, G\u2032 is a (\u0393,B)-wcfg. Moreover, if G is finite-derivational, then wt\u2032(r\u2032\u2032) can be constructed by Observation 8.2.7, and hence G\u2032 can be constructed.\nWe note that the construction of G\u2032 is essentially the same as the construction of the algebraic system (yi = qi | 1 \u2264 i \u2264 n) in the proof of Theorem [KS86, Thm. 14.6]. For an explanation, we assume that N = {A1, . . . , An} and Aj \u2192 \u03b11, . . . , Aj \u2192 \u03b1\u2113 are all the rules of G with left-hand side Aj . Then the corresponding algebraic system has the set Y = N as set of variables and it contains the equation\nAj = pj where pj = \u03b11 + . . .+ \u03b1\u2113 .\nThe set of all right-hand sides f(\u03b1i) where 1 \u2264 i \u2264 \u2113 and f is an E-selection for \u03b1i, is in one-toone correspondence to the set of all monomials in the polynomial qi (in the proof of Theorem [KS86, Thm. 14.6]); the latter is obtained by substituting (\u03c3, \u03b5)\u03b5 + Y into pj . The coefficient (\u03c3, \u03b5) is the N - vector (W (A1), . . . ,W (An)), which is relevant for all those nonterminals which are selected for erasing, and the part Y reflects the case that a nonterminal is not erased.\nNext we prove [[G\u2032]]s = [[G]]s\u2297\u03c7B(\u0393+). As preparation, we define the binary relation \u227a on RTG(N,\u0393+) by\n\u227a=\u227aR \u2229RTG(N,\u0393 +)\u00d7 RTG(N,\u0393 +) .\nSince \u227aR is well-founded, also \u227a has this property. Moreover, we have min\u227a(RTG(N,\u0393+)) = {(A\u2192 u) \u2208 R | u \u2208 \u0393+}, which is not empty. We define the mapping\n\u03d5 : RTG(N,\u0393 +)\u2192 RTG\u2032(N,\u0393 +)\n166 CHAPTER 8. WEIGHTED CONTEXT-FREE GRAMMARS\nby induction on (RTG(N,\u0393 +),\u227a) as follows (cf. Figure 8.3). Let d \u2208 RTG(N,\u0393+). Then there exists a rule (A \u2192 \u03b1) in R with \u03b1 = u0A1u1 . . . Akuk, and for every i \u2208 [k] there exists di \u2208 RTG(Ai,\u0393\u2217) such that\nd = (A\u2192 \u03b1) ( d1, . . . , dk ) .\nWe can assume that \u03d5(di) is defined for each di \u2208 RTG(N,\u0393+).\nSince \u03c0G(d) 6= \u03b5, we have u0u1 \u00b7 \u00b7 \u00b7uk 6= \u03b5 or there exists i \u2208 [k] such that di \u2208 RTG(Ai,\u0393+). Let f = f1 \u00b7 \u00b7 \u00b7 fk be the E-selection for \u03b1 defined, for each i \u2208 [k], by\nfi =\n{ 1 if di \u2208 RTG(Ai, \u03b5)\n0 otherwise .\nThen the rule A\u2192 [\u03b1, f ] is in R\u2032 and we define\n\u03d5(d) = (A\u2192 [\u03b1, f ]) ( ([\u03b1, f ]\u2192 f(\u03b1))\u03b6\u0304 ) ,\nwhere the sequence \u03b6\u0304 of rule trees of G\u2032 is obtained from the sequence (d1, . . . , dk) by\n(a) dropping each rule tree di with di \u2208 RTG(Ai, \u03b5) and (b) replacing each remaining di by \u03d5(di) (which is defined because di \u2208 RTG(N,\u0393+)).\nFor instance, if r = (S \u2192 aAbCDD), d1 \u2208 RTG(A,\u0393+), d2 \u2208 RTG(C, \u03b5), d3 \u2208 RTG(D, \u03b5), and d4 \u2208 RTG(D,\u0393 +), then f = 0110 and \u03b6\u0304 = (\u03d5(d1), \u03d5(d4)), cf. Figure 8.3.\nIn the particular case that di \u2208 RTG(Ai,\u0393+) for each i \u2208 [k], we have f = 0k and\n\u03d5(d) = (A\u2192 [\u03b1, f ]) ( ([\u03b1, f ]\u2192 \u03b1)(\u03d5(d1), . . . , \u03d5(dk)) ) ,\nand in the particular case that di \u2208 RTG(Ai, \u03b5) for each i \u2208 [k], we have f = 1k and\n\u03d5(d) = (A\u2192 [\u03b1, f ]) ( [\u03b1, f ]\u2192 u0u1 . . . uk ) .\nNext we prove that \u03d5 is surjective. More precisely, by induction on (RTG\u2032(N,\u0393 +),\u227a), we prove that\nthe following statement holds:\nFor every d\u2032 \u2208 RTG\u2032(N,\u0393 +), there exists a d \u2208 RTG(A,\u0393 +) such that \u03d5(d) = d\u2032. (8.12)\nLet d\u2032 \u2208 RTG\u2032(N,\u0393+). Then d\u2032 has the form\n(A\u2192 [\u03b1, f ]) ( ([\u03b1, f ]\u2192 v0C1v1 . . . Cnvn)(d \u2032 1, . . . , d \u2032 n) )\n8.2. NORMAL FORMS OF WCFG 167\nwhere n \u2208 N, f is an E-selection for \u03b1; moreover v0C1v1 . . . Cnvn = f(\u03b1) and d\u20321 \u2208 RTG\u2032(Cj ,\u0393 +), . . . , d\u2032n \u2208 RTG\u2032(Cn,\u0393 +). Let \u03b1 = u0A1u1 . . . Akuk and f = f1 \u00b7 \u00b7 \u00b7 fk. Hence, Cj = Ag\u22121\nf (j) for each j \u2208 [n].\nBy I.H. we can assume that, for every j \u2208 [n], there exists ej \u2208 RTG(Cj ,\u0393 +) such that \u03d5(ej) = d \u2032 j . Moreover, for each i \u2208 [k] such that fi = 1, we choose an arbitrary rule tree d\u2032\u2032i from RTG(Ai, \u03b5). We note that RTG(Ai, \u03b5) 6= \u2205 because f is an E-selection for \u03b1. Then we construct the rule tree d = (A \u2192 \u03b1)(d1, . . . , dk) in RTG(A,\u0393 +) where for each i \u2208 [k] we let\ndi =\n{ d\u2032\u2032i if fi = 1\negf (i) otherwise .\nThen \u03d5(d) = d\u2032. This proves that \u03d5 is surjective. We mention that, in general, \u03d5 is not injective because there may be several rule trees for \u03b5 with the same nonterminal on the left-hand side of the rule at their root.\nFrom the construction of G\u2032, it is obvious that\nfor every A \u2208 N and d \u2208 RTG(A,\u0393 +), we have \u03c0G(d) = \u03c0G\u2032(\u03d5(d)) (8.13)\nand, by using (8.13), we have that\nfor every A \u2208 N and u \u2208 \u0393+, the sets RTG(A, u) and {(d\u2032, d) | d\u2032 \u2208 RTG\u2032(A, u), d \u2208 \u03d5 \u22121(d\u2032)} are in a one-to-one correspondence.\n(8.14)\nFinally, by induction on (RTG\u2032(N,\u0393 +),\u227a), we prove that the following statement holds:\nFor every d\u2032 \u2208 RTG\u2032(N,\u0393 +) we have wtG\u2032(d \u2032) = \u2211\u2295\nd\u2208\u03d5\u22121(d\u2032)\nwtG(d) . (8.15)\nLet d\u2032 \u2208 RTG\u2032(N,\u0393+). Then d\u2032 has the form\nd\u2032 = (A\u2192 [\u03b1, f ]) ( ([\u03b1, f ]\u2192 f(\u03b1)) ( d\u20321, . . . , d \u2032 n) )\nwith \u03b1 = u0A1u1 . . . Akuk. Hence f(\u03b1) contains n occurrences of 0. Moreover, for each j \u2208 [n], we have d\u2032j \u2208 RTG\u2032(Ag\u22121\nf (j),\u0393\n\u2217). Then we can calculate as follows.\nwtG\u2032(d \u2032)\n= ( \u2297\nj\u2208[n]\nwtG\u2032(d \u2032 j) ) \u2297 wt\u2032([\u03b1, f ]\u2192 f(\u03b1))\u2297 wt\u2032(A\u2192 [\u03b1, f ])\n= ( \u2297\ni\u2208[k]: fi=0\nwtG\u2032(d \u2032 gf (i)\n) ) \u2297 ( \u2297\ni\u2208[k]: fi=1\nW (Ai) ) \u2297 wt(A\u2192 \u03b1) (by definition of f and construction)\n= (\u2297\ni\u2208[k]\nci\n) \u2297 wt(A\u2192 \u03b1) (by commutativity)\nwhere\nci =\n{ wtG\u2032(d\n\u2032 gf (i) ) if fi = 0\nW (Ai) otherwise .\nBy I.H. and by definition of W (Ai), we have\nci =   \n\u2211\u2295\ndi\u2208\u03d5\u22121(d\u2032gf (i) )\nwtG(di) if fi = 0\n\u2211\u2295\ndi\u2208RTG(Ai,\u03b5)\nwtG(di) otherwise .\n168 CHAPTER 8. WEIGHTED CONTEXT-FREE GRAMMARS\nThen, by distributivity and by surjectivity of \u03d5 (see (8.12)), we obtain\n(\u2297\ni\u2208[k]\nci\n) \u2297 wt(A\u2192 \u03b1) = \u2211\u2295\nd\u2208\u03d5\u22121(d\u2032)\nwtG(d)\nwhich proves (8.15). Then for each u \u2208 \u0393+\n[[G\u2032]]s(u) = \u2295\nA\u2208S\n\u2211\u2295\nd\u2032\u2208RTG\u2032 (A,u)\nwtG\u2032(d \u2032)\n= \u2295\nA\u2208S\n\u2211\u2295\nd\u2032\u2208RTG\u2032 (A,u)\n\u2211\u2295\nd\u2208\u03d5\u22121(d\u2032)\nwtG(d) (by (8.15))\n= \u2295\nA\u2208S\n\u2211\u2295\nd\u2208RTG(A,u)\nwtG(d) (by (8.14))\n= [[G]]s(u) .\nSince [[G\u2032]]s(\u03b5) = 0, we obtain [[G\u2032]]s = [[G]]s \u2297 \u03c7B(\u0393+)."
        },
        {
            "heading": "8.3 Yields of recognizable weighted tree languages",
            "text": "In this section we state the main result of this chapter: the yield of an r-recognizable weighted tree language is a weighted context-free language, and vice versa, each weighted context-free language can be obtained in this way. This result generalizes [Bra69, Thm. 3.20] and [Don70, Thm. 2.5] from the unweighted case to the weighted case (also cf. [GS84, Thm. 3.2.7]), it generalizes [E\u0301K, Thm. 6.8.6] (also cf. [E\u0301K03, Thm. 8.6]) from commutative, continuous semirings to strong bimonoids, and it generalizes Theorem [FG18, Thm.1 (1) \u21d4 (5)] from semirings to strong bimonoids. (We also refer to [Boz99, Thm. 30].)\nWe recall the mapping yield\u0393 from Section 2.9. Let \u0393 \u2286 \u03a3 (0). Then the mapping yield\u0393 : T\u03a3 \u2192 \u0393 \u2217 is defined for each \u03be = \u03c3(\u03be1, . . . , \u03bek) in T\u03a3 by\nyield\u0393(\u03be) =    yield\u0393(\u03be1) \u00b7 \u00b7 \u00b7 yield\u0393(\u03bek) if k \u2265 1 \u03c3 if k = 0 and \u03c3 \u2208 \u0393\n\u03b5 otherwise .\nLet r : T\u03a3 \u2192 B be a weighted tree language. Also we recall from (2.30) that, if r is \u03c7(yield\u0393)summable or B is \u03c3-complete, then \u03c7(yield\u0393)(r) : \u0393\n\u2217 \u2192 B is a weighted language such that, for each u \u2208 \u0393\u2217, we have\n\u03c7(yield\u0393)(r)(u) = \u2211\u2295\n\u03be\u2208yield\u22121\u0393 (u)\nr(\u03be) .\nTheorem 8.3.1. [FG18, Thm. 1] Let \u0393 be an alphabet and B be a strong bimonoid. For each weighted language s : \u0393\u2217 \u2192 B the following two statements are equivalent. (A) We can construct a (\u0393,B)-wcfg G such that G is finite-derivational or B is \u03c3-complete, and s = [[G]]s. (B) We can construct a ranked alphabet \u03a3 with \u0393 \u2286 \u03a3(0) and a (\u03a3,B)-wta A such that [[A]]run is\n\u03c7(yield\u0393)-summable or B is \u03c3-complete, and s = \u03c7(yield\u0393) ( [[A]]run ) .\nProof. This follows from Lemmas 8.3.2 and 8.3.3.\n8.3. YIELDS OF RECOGNIZABLE WEIGHTED TREE LANGUAGES 169\nLemma 8.3.2. Let G be a (\u0393,B)-wcfg such that G is finite-derivational or B is \u03c3-complete. We can construct a ranked alphabet \u03a3 with \u0393 \u2286 \u03a3(0) and a root weight normalized (\u03a3,B)-wta A = (Q, \u03b4, F ) such that (a) [[A]]run is \u03c7(yield\u0393)-summable if G is finite-derivational and (b) [[G]] s = \u03c7(yield\u0393)([[A]] run).\nProof. Let G = (N,S,R,wt). By Lemmas 8.2.3 and 8.2.4, we can construct a (\u0393,B)-wcfg which is in nonterminal form, start-separated, and equivalent to G. Hence we can assume that G is in nonterminal form and start-separated.\nWe define the N-indexed family (Rk | k \u2208 N) such that\nRk = {(A\u2192 \u03b1) \u2208 R | |\u03b1| = k} .\nWe note that, if G is \u03b5-free, then (Rk | k \u2208 N) is not a ranked alphabet, because R0 = \u2205. Moreover, a terminal rule A\u2192 a with a \u2208 \u0393 is in R1 (and not in R(0) as defined in Section 8.1).\nWe construct the ranked alphabet \u03a3 by \u03a3(k) = Rk for each k \u2208 N+, and \u03a3(0) = R0 \u222a\u0393. We construct the (\u03a3,B)-wta A = (Q, \u03b4, F ) as follows.\n\u2022 Q = N \u222a \u0393 where \u0393 = {a | a \u2208 \u0393} (note that Q \u2229 \u03a3 = \u2205), \u2022 for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and q, q1, . . . , qk \u2208 Q, we let\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) =    wt(\u03c3) if q, q1, . . . , qk \u2208 N and \u03c3 = (q \u2192 q1 \u00b7 \u00b7 \u00b7 qk) is in R wt(\u03c3) if k = 1, q \u2208 N , q1 = a for some a \u2208 \u0393 such that \u03c3 = (q \u2192 a) is in R 1 if k = 0, q = \u03c3, and \u03c3 \u2208 \u0393\n0 otherwise ,\n\u2022 for each q \u2208 Q, we define Fq = 1 if q = S, and 0 otherwise.\nObviously, A is root weight normalized.\nFor the proof of (a) and (b) we need some preparations. For each \u03be \u2208 T\u03a3, we define the run \u03c1\u03be : pos(\u03be)\u2192 Q such that, for each w \u2208 pos(\u03be), we let\n\u03c1\u03be(w) =\n{ lhs(\u03be(w)) if \u03be(w) \u2208 R\n\u03be(w) otherwise .\nWe define the mapping \u03d5 : RTG \u2192 {(\u03be, \u03c1) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be)} for every d \u2208 RTG by \u03d5(d) = (\u03be, \u03c1\u03be) where \u03be is obtained from d by replacing each leaf which is labeled by a rule of the form A \u2192 a with a \u2208 \u0393 by the tree (A\u2192 a)(a) (cf. Figure 8.4). In particular, for each (\u03be, \u03c1\u03be) \u2208 im(\u03d5), we have that \u03c1\u03be \u2208 RA(S, \u03be). Obviously, \u03d5 is injective.\nNext we define \u03d5\u2032 : RTG \u2192 im(\u03d5) by \u03d5 \u2032(d) = \u03d5(d) for each d \u2208 RTG . Obviously, \u03d5 \u2032 is bijective. Moreover,\nfor each d \u2208 RTG , if \u03d5 \u2032(d) = (\u03be, \u03c1\u03be), then \u03c0(d) = yield\u0393(\u03be). (8.16)\nFor the proof of (a), assume that G is finite-derivational. Then, (8.16) and the fact that \u03d5\u2032 is bijective imply that yield\u22121\u0393 (u) \u2229 supp([[A]] run) is finite for each u \u2208 \u0393\u2217, i.e., that [[A]]run is \u03c7(yield\u0393)-summable.\nFinally, we prove (b). It is easy to see that\nfor each d \u2208 RTG , we have wtG(d) = wtA(\u03d5 \u2032(d)) . (8.17)\nMoreover, for every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(S, \u03be): if (\u03be, \u03c1) 6\u2208 im(\u03d5), then wtA(\u03be, \u03c1) = 0 . (8.18)\nThen, for each u \u2208 \u0393\u2217, we can calculate as follows.\n[[G]]s(u) = \u2211\u2295\nd\u2208RTG(u)\nwtG(d) (by (8.2))\n= \u2211\u2295\nd\u2208RTG : \u03c0(d)=u\nwtG(d)\n= \u2211\u2295\n(\u03be,\u03c1\u03be)\u2208im(\u03d5): yield\u0393(\u03be)=u\nwtG((\u03d5 \u2032)\u22121((\u03be, \u03c1\u03be))) (because \u03d5 \u2032 is bijective and by (8.16))\n= \u2211\u2295\n(\u03be,\u03c1\u03be)\u2208im(\u03d5): yield\u0393(\u03be)=u\nwtA(\u03be, \u03c1\u03be) (by (8.17) and because \u03d5((\u03d5 \u2032)\u22121((\u03be, \u03c1\u03be))) = (\u03be, \u03c1\u03be))\n= \u2211\u2295\n\u03be\u2208yield\u22121\u0393 (u)\n\u2295\n\u03c1\u2208RA(S,\u03be)\nwtA(\u03be, \u03c1) (by (8.18))\n= \u2211\u2295\n\u03be\u2208yield\u22121\u0393 (u)\n\u2295\nq\u2208Q\n\u2295\n\u03c1\u2208RA(q,\u03be)\nwtA(\u03be, \u03c1)\u2297 Fq (because FS = 1 and Fq = 0 for each q \u2208 Q \\ {S})\n= \u2211\u2295\n\u03be\u2208yield\u22121\u0393 (u)\n[[A]]run(\u03be) (by definition of [[A]]run)\n= ( \u03c7(yield\u0393)([[A]] run) ) (u) . (by (2.30))\nLemma 8.3.3. Let \u0393 \u2286 \u03a3(0). Moreover, let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta such that [[A]]run is \u03c7(yield\u0393)summable or B is \u03c3-complete. We can construct a (\u0393,B)-wcfg in nonterminal form such that (a) G is finite-derivational if [[A]]run is \u03c7(yield\u0393)-summable and (b) [[G]] s = \u03c7(yield\u0393) ( [[A]]run ) .\nProof. Let A = (Q, \u03b4, F ). By Theorem 7.3.1 we can construct a (\u03a3,B)-wta which is root weight normalized and r-equivalent toA. Hence, we can assume thatA is root weight normalized. Thus, supp(F ) = {qf} for some qf \u2208 Q and Fqf = 1.\nWe construct the (\u0393,B)-wcfg G = (N,S,R,wt) as follows.\n\u2022 N = Q\u00d7 \u03a3 where each element has the form [q, \u03c3] for some q \u2208 Q and \u03c3 \u2208 \u03a3, \u2022 S = {qf} \u00d7 \u03a3, \u2022 R is the smallest set such that the following conditions hold; simultaneously, we define wt.\n\u2013 For every k \u2208 N+, \u03c3 \u2208 \u03a3(k), q, q1, . . . , qk \u2208 Q, and \u03c31, . . . , \u03c3k \u2208 \u03a3, the rule r = ([q, \u03c3]\u2192 [q1, \u03c31] \u00b7 \u00b7 \u00b7 [qk, \u03c3k]) is in R and wt(r) = \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q).\n8.3. YIELDS OF RECOGNIZABLE WEIGHTED TREE LANGUAGES 171\n\u2013 For every \u03c3 \u2208 \u0393 and q \u2208 Q, the rule r = ([q, \u03c3]\u2192 \u03c3) is in R and wt(r) = \u03b40(\u03b5, \u03c3, q). \u2013 For every \u03c3 \u2208 \u03a3(0) \\ \u0393 and q \u2208 Q, the rule r = ([q, \u03c3]\u2192 \u03b5) is in R and wt(r) = 1.\nWe define the mapping \u03d5 : {(\u03be, \u03c1) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(qf , \u03be)} \u2192 RTG for every (\u03be, \u03c1) by \u03d5(\u03be, \u03c1) = d where d is determined by the tree domain W and the R-tree mapping d\u2032 : W \u2192 R (recall that there is a bijective representation of trees as tree domains and tree mappings, cf. Section 2.9). We define W = pos(\u03be) and for each w \u2208W (using k as abbreviation for rk\u03a3(\u03be(w))) we let\nd\u2032(w) =    [\u03c1(w), \u03be(w)] \u2192 [\u03c1(w1), \u03be(w1)] \u00b7 \u00b7 \u00b7 [\u03c1(wk), \u03be(wk)] if k \u2265 1 [\u03c1(w), \u03be(w)] \u2192 \u03be(w) if k = 0 and \u03be(w) \u2208 \u0393\n[\u03c1(w), \u03be(w)] \u2192 \u03b5 if k = 0 and \u03be(w) \u2208 \u03a3(0) \\ \u0393 .\nObviously, \u03d5 is injective and surjective, hence bijective (cf. Figure 8.5). Moreover,\nfor every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be), if \u03d5(\u03be, \u03c1) = d, then \u03c0(d) = yield\u0393(\u03be) and wtG(d) = wtA(\u03be, \u03c1). (8.19)\nThus, since \u03d5 is bijective, the assumption that [[A]]run is \u03c7(yield\u0393)-summable implies that G is finitederivational.\nThen, for each u \u2208 \u0393\u2217, we can calculate as follows.\n[[G]]s(u) = \u2211\u2295\nd\u2208RTG(u)\nwtG(d) = \u2211\u2295\nd\u2208RTG : \u03c0(d)=u\nwtG(d)\n= \u2211\u2295\n\u03be\u2208T\u03a3: yield\u0393(\u03be)=u\n\u2295\n\u03c1\u2208RA(qf ,\u03be)\nwtA(\u03be, \u03c1) (because \u03d5 is bijective and by (8.19))\n= \u2211\u2295\n\u03be\u2208yield\u22121\u0393 (u)\n\u2295\n\u03c1\u2208RA(qf ,\u03be)\nwtA(\u03be, \u03c1)\n= \u2211\u2295\n\u03be\u2208yield\u22121\u0393 (u)\n\u2295\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) (because supp(F ) = {qf} and Fqf = 1)\n= \u2211\u2295\n\u03be\u2208yield\u22121\u0393 (u)\n[[A]]run(\u03be) (by definition of [[A]]run)\n= \u03c7(yield\u0393)([[A]] run)(u) . (by (2.30))\nFinally, we verify that Theorem 8.3.1 generalizes [Bra69, Thm. 3.20] and [Don70, Thm. 2.5]. We achieve this by proving that the latter results are equivalent to Theorem 8.3.1 for the case that B is the Boolean semiring Boole.\nCorollary 8.3.4. For each language L \u2286 \u0393\u2217 the following two statements are equivalent.\n(A) We can construct a context-free grammar G such that L(G) = L. (B) We can construct a ranked alphabet \u03a3 with \u0393 \u2286 \u03a3(0) and a \u03a3-fta A such that L = yield\u0393(L(A)).\nProof. Proof of (A)\u21d2(B): Let G be a \u0393-cfg such that L = L(G). By Observation 8.1.1(A)\u21d2(B), we can construct a (\u0393,Boole)-wcfg G such that L = supp([[G]]s). Since Boole is \u03c3-complete, Theorem 8.3.1(A)\u21d2(B) implies that we can construct a ranked alphabet \u03a3 with \u0393 \u2286 \u03a3(0) and a (\u03a3,Boole)wta A such that L = supp(\u03c7(yield\u0393)([[A]])). By (2.31) (using r = [[A]] and g = yield\u0393), we obtain L = yield\u0393(supp([[A]])). By Corollary 3.4.2(B)\u21d2(A), we can construct a \u03a3-fta A such that supp([[A]]) = L(A). Thus L = yield\u0393(L(A)).\nProof of (B)\u21d2(A): Let A be a \u03a3-fta such that L = yield\u0393(L(A)). By Corollary 3.4.2(A)\u21d2(B), we can construct a (\u03a3,Boole)-wta A such that L = yield\u0393(supp([[A]])). Then we can apply (2.31) and obtain that L = supp(\u03c7(yield\u0393)([[A]])). Since Boole is \u03c3-complete, Theorem 8.3.1(B)\u21d2(A) implies that we can construct a (\u0393,Boole)-wcfg G such that L = supp([[G]]s). Finally, Observation 8.1.1(B)\u21d2(A), we can construct a \u0393-cfg G such that L = L(G).\nChapter 9\nWeighted regular tree grammars\nHere we introduce weighted regular tree grammars as particular wcfg. This possibility is based on the simple fact that each tree is a particular string. We indicate that the normal forms for wcfg are also normal forms for weighted regular tree grammars. We define two more restricted forms of weighted regular tree grammars: alphabetic and tree automata form, and prove that they are normal forms (cf. Lemmas 9.2.2 and 9.2.3, respectively). In particular, we prove that weighted regular tree grammars in tree automata form are essentially wta (cf. Theorem 9.2.9)."
        },
        {
            "heading": "9.1 The grammar model",
            "text": "By definition, each tree \u03be over \u03a3 is a particular string over the alphabet \u03a3 \u222a \u039e where \u039e contains the opening and closing parentheses and the comma. For convenience, we abbreviate \u03a3\u222a\u039e by \u03a3\u039e. Then, by definition, we have T\u03a3 \u2286 (\u03a3\u039e)\u2217. Of course, (\u03a3\u039e)\u2217 \\ T\u03a3 6= \u2205.\nThis aspect of the definition of trees (being particular strings) allows one to define particular wcfg, viz. those which generate weighted tree languages. We call them weighted regular tree grammars.\nFormally, a weighted regular tree grammar over \u03a3 and B (for short: (\u03a3,B)-wrtg, or: wrtg) is a (\u03a3\u039e,B)wcfg G = (N,S,R,wt) where each rule in R has the form A\u2192 \u03be with \u03be \u2208 T\u03a3(N). Obviously, G is \u03b5-free because \u03b5 6\u2208 T\u03a3(N). Also here we sometimes want to show the occurrences of elements of N in the right-hand side of a rule more explicitly. Then we will write a rule in the form\nA\u2192 \u03be[A1, . . . , Ak] ,\nwhere k \u2208 N, \u03be \u2208 C\u03a3(Zk), and A1, . . . , Ak \u2208 N .\nLet G = (N,S,R,wt) be a (\u03a3,B)-wrtg. We recall that we considered R as ranked alphabet (where the rank of a rule is the number of nonterminal occurrences in its right-hand side) and that the projection of G has the type \u03c0G : TR \u2192 (\u03a3\u039e)\u2217. Due to the special form of the rules, we have im(\u03c0G) \u2286 T\u03a3, and thus we can view \u03c0G as mapping of type\n\u03c0G : TR \u2192 T\u03a3 ,\nand hence RTG = RTG(T\u03a3). Moreover, it is easy to see that \u03c0G is determined by the (R,\u03a3)-tree homomorphism \u03c0G = ((\u03c0G)k | k \u2208 N) defined, for every k \u2208 N and r \u2208 R\n(k) of the form r = (A \u2192 \u03be[A1, . . . , Ak]), by (\u03c0G)k(r) = \u03be.\nBy Observation 8.2.2 and since G is \u03b5-free, if G is chain-free, then it is finite-derivational.\nIf G is finite-derivational or B is \u03c3-complete, then the weighted tree language generated by G, denoted by [[G]]t, is the mapping [[G]]t : T\u03a3 \u2192 B defined for each \u03be \u2208 T\u03a3 by\n[[G]]t(\u03be) = [[G]]s(\u03be) .\n173\n174 CHAPTER 9. WEIGHTED REGULAR TREE GRAMMARS\nHence [[G]]t = [[G]]s|T\u03a3 and for each \u03be \u2208 T\u03a3, using (8.2), we have\n[[G]]t(\u03be) = \u2211\u2295\nd\u2208RTG(\u03be)\nwtG(d) .\nLet r be a (\u03a3,B)-weighted tree language. It is called regular if there exists a (\u03a3,B)-wrtg G which is finite-derivational if B is not \u03c3-complete and for which r = [[G]]t.\nSince in this book we will use [[G]]t many times, we make the following convention.\nIn the rest of this book, for each wrtg G, we will abbreviate [[G]]t by [[G]].\nWe denote by (i) Regnc(\u03a3,B), (ii) Regfd(\u03a3,B), and (iii) Reg(\u03a3,B) the sets of (\u03a3,B)-weighted tree languages which can be generated by\n(i) chain-free (\u03a3,B)-wrtg (ii) finite-derivational (\u03a3,B)-wrtg, and (iii) (\u03a3,B)-wrtg which are finite-derivational if B is not \u03c3-complete, respectively.\nThen Regnc(\u03a3,B) \u2286 Regfd(\u03a3,B) \u2286 Reg(\u03a3,B); moreover, Regfd(\u03a3,B) = Reg(\u03a3,B) if B is not \u03c3-complete.\nExample 9.1.1. We consider the ranked alphabet \u03a3 = {\u03c3(2), \u03b3(1), \u03b1(0)} and the set of trees U \u2282 T\u03a3 such that each tree \u03be \u2208 U has an upper part, which only contains \u03c3-labeled positions, and a number of lower parts, which only contain \u03b3- and \u03b1-labeled positions. Formally,\nU = {\u03b6[\u03b61, . . . , \u03b6n] | n \u2208 N, \u03b6 \u2208 C\u03a3(Zn), pos{\u03b3,\u03b1}(\u03b6) = \u2205, and \u03b61, . . . , \u03b6n \u2208 T{\u03b3,\u03b1}} .\nLet \u03be \u2208 U . There are unique n, \u03b6, and \u03b61, . . . , \u03b6n such that \u03be = \u03b6[\u03b61, . . . , \u03b6n]. Then \u03b6 is the upper part of \u03be and \u03b61, . . . , \u03b6n are the lower parts of \u03be. We denote by bor(\u03be) the set of positions of \u03be which are at the border between the upper part and the lower parts, i.e., bor(\u03be) = posZ(\u03b6).\nNow we wish to determine, for each \u03be \u2208 U , the minimal height of a lower part of \u03be. For this we consider the tropical semiring Natmin,+ = (N\u221e,min,+,\u221e, 0) and the mapping f : T\u03a3 \u2192 N\u221e defined for each \u03be \u2208 T\u03a3 by\nf(\u03be) =\n{ min(height(\u03be|w) | w \u2208 bor(\u03be)) if \u03be \u2208 U\n\u221e otherwise .\nWe will show that f is a regular (\u03a3,Natmin,+)-weighted tree language. For this we construct the following (\u03a3,Natmin,+)-wrtg G = (N, {S}, R, wt) with N = {S,A,B,C,D} and the following rules and weights:\nS \u2192 \u03c3(A,S) : 0, S \u2192 \u03c3(S,A) : 0, S \u2192 B : 0, A\u2192 \u03c3(A,A) : 0, A\u2192 C : 0, B \u2192 \u03b3(B) : 1, B \u2192 \u03b1 : 0, C \u2192 \u03b3(C) : 0, C \u2192 \u03b1 : 0.\nWe note that G contains two chain-rules. However G is finite-derivational because of the following. For each \u03be \u2208 U , there exists a bijection between the sets RTG(\u03be) and bor(\u03be) (in particular, based on \u03a3, we can reconstruct from the set bor(\u03be) of positions the tree \u03be). Thus |RTG(\u03be)| = |bor(\u03be)| for each \u03be \u2208 U , and |RTG(\u03be)| = \u2205 for each \u03be \u2208 T\u03a3 \\ U . Hence G is finite-derivational. Moreover, it is easy to see that supp([[G]]) = U .\nNow let \u03be \u2208 U . Then, for every d \u2208 RTG(\u03be), there exists a unique position w \u2208 pos(d) such that d(w) = (S \u2192 B) and w \u2208 bor(\u03be) (i.e., \u03be|w is a lower part of \u03be); this is due to the form of the S-rules. Let us denote this unique position by wd. Vice versa, for each w \u2208 bor(\u03be), there exists a d \u2208 RTG(\u03be) such that d(w) = (S \u2192 B). Let us denote this d by dw. Clearly, wdw = w. We refer to Figure 9.1 for an illustration.\n9.1. THE GRAMMAR MODEL 175\nIt is clear that, for each d \u2208 RTG(B,T{\u03b3,\u03b1}) we have wtG(d) = height(\u03c0G(d)). Moreover, for each d \u2208 RTG(C,T{\u03b3,\u03b1}) we have wtG(d) = 0. Since each of the rules\nS \u2192 \u03c3(A,S) S \u2192 \u03c3(S,A) S \u2192 B\nA\u2192 \u03c3(A,A) A\u2192 C\nhas weight 0, we obtain the following:\nfor each d \u2208 RTG(\u03be) we have wtG(d) = height(\u03be|wd) . (9.1)\nThen we have\n[[G]](\u03be) = \u2211min\nd\u2208RTG(S,\u03be)\nwtG(d) = min(wtG(d) | d \u2208 RTG(\u03be))\n= min(wtG(dw) | w \u2208 bor(\u03be))\n= min(height(\u03be|w) | w \u2208 bor(\u03be)) (by (9.1))\n= f(\u03be) .\nLemma 9.1.2. For every (\u03a3,B)-wrtg G it is decidable whether G is finite-derivational.\nProof. Let G = (N,S,R,wt) be a (\u03a3,B)-wrtg. By standard methods, we can decide whether there exists a \u03be \u2208 T\u03a3 such that RTG(\u03be) 6= \u2205. If for every \u03be \u2208 T\u03a3 we have RTG(\u03be) = \u2205, then G is finite-derivational.\nNow let us assume that there exists a \u03be \u2208 T\u03a3 with RTG(\u03be) 6= \u2205. The idea is to transform G into a context-free grammar and to apply the construction in the proof of Theorem 2.12.1 for reducing that context-free grammar. In fact, we view each tree \u03be \u2208 T\u03a3(N) as a string over the alphabet \u03a3\n\u039e \u222a N . Formally, we construct the \u03a3\u039e-cfg G = (N \u222a {S0}, S0, P ), where S0 is a new nonterminal and P = R \u222a {S0 \u2192 A | A \u2208 S}. (We note that G is not the context-free grammar associated to G in the sense of Chapter 8.) Then L(G) \u2286 T\u03a3 and, due to our assumption on G, we have L(G) 6= \u2205.\nThen we apply the construction (cf. Theorem 2.12.1) to obtain a reduced \u03a3\u039e-cfg G\u2032 = (N \u2032, S0, P \u2032) such that G\u2032 and G are equivalent. Since G\u2032 is reduced, each nonterminal in N \u2032 occurs in some rule tree d \u2208 RTG\u2032(S0,\u2206\u2217).\n176 CHAPTER 9. WEIGHTED REGULAR TREE GRAMMARS\nDue to the construction, we have that N \u2032 \u2286 N and P \u2032 \u2286 P . Then we construct the (\u03a3,B)-wrtg G\u2032 = (N \u2032, S\u2032, R\u2032, wt\u2032), where S\u2032 = S \u2229N \u2032, R\u2032 = P \u2032 \\ {S0 \u2192 A | A \u2208 S\u2032} (hence R\u2032 \u2286 R), and wt\u2032 = wt|R\u2032 . Since G\u2032 is reduced, the following property holds for G\u2032:\nfor each A \u2208 N \u2032 there exist \u03be \u2208 T\u03a3 and d \u2208 RTG\u2032(\u03be) such that A occurs in d. (9.2)\nMoreover, RTG\u2032(\u03be) = RTG(\u03be) for each \u03be \u2208 T\u03a3. Thus G\u2032 is equivalent to G, and G\u2032 is finite-derivational iff G is finite-derivational.\nSince G\u2032 satisfies (9.2) and it is \u03b5-free, it is finite-derivational iff there do not exist n \u2208 N+ and a sequence A1 \u2192 A2, . . . , An\u22121 \u2192 An of chain rules of G\u2032 such that A1 = An. This latter property of G\u2032 is decidable by a standard algorithm on finite graphs [War62].\nFinally, we mention that in [Ko\u0301s22, Thm. V.5., V.6] the following was proved for the unweighted case: it is decidable whether the language generated by a given \u03a3\u039e-cfg is a \u03a3-tree language. Furthermore, if the answer to this question is positive, then a regular tree grammar can be constructed which generates that tree language."
        },
        {
            "heading": "9.2 Normal forms of wrtg",
            "text": "Since each (\u03a3,B)-wrtg G is a particular (\u03a3\u039e,B)-wcfg, we can apply the normal form lemmas proved in Chapter 8 also to G. Then it is a question whether the wcfg G\u2032 constructed in the proof of such a lemma is a wrtg or not. Next we tailor those lemmas for wrtg for which the answer to the question is positive.\nLemma 9.2.1. Let G be a (\u03a3,B)-wrtg such that G is finite-derivational or B is \u03c3-complete. Then the following three statements hold.\n(1) We can construct a start-separated (\u03a3,B)-wrtg G\u2032 such that [[G]] = [[G\u2032]]. The construction preserves the properties finite-derivational and local-reduced. The construction does not preserve the property chain-free. (2) We can construct a local-reduced (\u03a3,B)-wrtg G\u2032 such that [[G]] = [[G\u2032]]. The construction preserves the properties finite-derivational, start-separated, and chain-free. (3) If B is a semiring, then there exists a chain-free (\u03a3,B)-wrtg G\u2032 such that [[G]] = [[G\u2032]]. If G has one of the properties: start-separated and local-reduced, then also G\u2032 has it. Moreover, if G is finite-derivational, then we can construct G\u2032.\nProof. Statement (1) is a corollary of Lemma 8.2.4 because if G is a wrtg, then the construction in the proof of the lemma yields a wrtg G\u2032 with the properties stated in (1). Similarly, Statements (2) and (3) are corollaries of Lemma 8.2.5 and Theorem 8.2.6, respectively.\nWe continue with the definition of two more restricted forms of wrtg. Let G = (N,S,R,wt) be a (\u03a3,B)-wrtg. We say that G is\n\u2022 alphabetic if each rule contains at most one occurrence of a symbol in \u03a3. \u2022 in tree automata form if R = {A \u2192 \u03c3(A1, . . . , Ak) | k \u2208 N, \u03c3 \u2208 \u03a3\n(k), A,A1, . . . , Ak \u2208 N} . Thus, there exists a bijection from R to the set \u22c3 k\u2208NN \u00d7 \u03a3 (k) \u00d7Nk.\nObviously, if G is in tree automata form, then it is alphabetic and chain-free.\nLemma 9.2.2. (cf. [MW67, Lm. 3.1], [IF75, Thm. 1], and [AB87, Prop. 1.2]) Let G be a (\u03a3,B)-wrtg such that G is finite-derivational or B is \u03c3-complete. We can construct a (\u03a3,B)-wrtg G\u2032 such that G\u2032 is alphabetic and [[G\u2032]] = [[G]]. The construction preserves the properties finite-derivational, start-separated, chain-free, and local-reduced.\n9.2. NORMAL FORMS OF WRTG 177\nProof. Let G = (N,S,R,wt) be a (\u03a3,B)-wrtg. As a degree for \u201chow much\u201d a (\u03a3,B)-wrtg G does not match the condition of being alphabetic, we define, for each rule r = (A \u2192 \u03be), the degree of r, denoted by deg(r), by\ndeg(r) =\n{ 0 if r is a chain-rule\n|pos\u03a3(\u03be)| \u2212 1 otherwise,\nand we define deg(G) = \u2211\nr\u2208R deg(r). Then we have the following equivalence: deg(G) = 0 iff each rule of G contains at most one occurrence of a symbol in \u03a3 (i.e., G is alphabetic). Thus, we will construct a (\u03a3,B)-wrtg G\u2032 such that G\u2032 is equivalent to G and deg(G\u2032) = 0.\nFor the construction of G\u2032, we pick a rule from G with more than one occurrence of a symbol in \u03a3 and apply the usual decomposition to its right-hand side (cf. [GS84, Lm. 2.3.4] and [Eng75b, Thm. 3.22]). More precisely, if deg(G) > 0, i.e., there exists a rule\nr = (A\u2192 \u03c3(\u03be1, . . . , \u03bei\u22121, \u03bei, \u03bei+1, . . . , \u03bek))\nin R such that \u03bei 6\u2208 N for some i \u2208 [k], then we replace this rule by the rules\nr1 = (A\u2192 \u03c3(\u03be1, . . . , \u03bei\u22121, A \u2032, \u03bei+1, . . . , \u03bek)) and r2 = (A \u2032 \u2192 \u03bei),\nwhere A\u2032 is a new nonterminal. Moreover, we let wt(r1) = wt(r) and wt(r2) = 1. It is clear that this construction preserves each of the mentioned properties. Moreover, it does not change the semantics of G. Since deg(r1) + deg(r2) = deg(r) \u2212 1, the degree deg(G) has decreased by one. Now we repeat this decomposition until we reach eventually a (\u03a3,B)-wrtg with degree 0; this (\u03a3,B)-wrtg we call G\u2032.\nNext we relate wrtg with wta.\nLemma 9.2.3. Let \u03a3 be a ranked alphabet, B be a strong bimonoid, and G be a (\u03a3,B)-wrtg. If (a) G is chain-free or (b) B is a semiring and G is finite-derivational or (c) B is a \u03c3-complete semiring, then there exists a (\u03a3,B)-wrtg G\u2032 such that G\u2032 is in tree automata form and [[G\u2032]] = [[G]]. In Cases (a) and (b) we can even construct G\u2032.\nProof. Let G = (N,S,R,wt). In Case (a), by Lemma 9.2.2 we can construct an alphabetic and chain-free (\u03a3,B)-wrtg which is equivalent to G; thus we can assume that G is alphabetic and chain-free.\nIn Cases (b) and (c), by Lemma 9.2.1(3), there exists a chain-free (\u03a3,B)-wrtg which is equivalent to G. Then, by Lemma 9.2.2, there exists an alphabetic and chain-free (\u03a3,B)-wrtg which is equivalent to G. Moreover, in Case (b) we can even assume that G is alphabetic and chain-free, because then Lemma 9.2.1(3) is constructive.\nNext we complete the set R of rules by adding rules with weight 0. Formally, we construct the (\u03a3,B)-wrtg G\u2032 = (N,S,R\u2032, wt\u2032) such that R\u2032 is the set of all rules r = (A \u2192 \u03c3(A1, . . . , Ak)) with k \u2208 N, \u03c3 \u2208 \u03a3(k), and A,A1, . . . , Ak \u2208 N . Moreover, for each r \u2208 R\u2032 we let wt\u2032(r) = wt(r) if r \u2208 R, and wt\u2032(r) = 0 otherwise. Clearly, G\u2032 is in tree automata form and [[G\u2032]] = [[G]].\nLet A = (Q, \u03b4, F ) be a (\u03a3,B)-wta with identity root weights and G = (N,S,R,wt) be a (\u03a3,B)-wrtg in tree automata form. We call A and G related if Q = N , for each q \u2208 Q we have Fq = 1 if and only if q \u2208 S, and\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = wt(q \u2192 \u03c3(q1, . . . , qk))\nfor every k \u2208 N, \u03c3 \u2208 \u03a3(k), q \u2208 Q, and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Qk. We note that, if q 6\u2208 S, then Fq = 0 because A has identity root weights. Moreover, if A and G are related, then A is local-trim iff G is reduced.\nExample 9.2.4. We give an example of a wta and a wrtg which are related. As wta, we choose the root weight normalized (\u03a3,Nat)-wta A = (Q, \u03b4, F ) of Example 3.2.11, which we recall here:\n178 CHAPTER 9. WEIGHTED REGULAR TREE GRAMMARS\n\u2022 \u03a3 = {\u03c3(2), \u03b3(1), \u03b1(0)}, \u2022 Q = {\u22a5, a, f} and F\u22a5 = Fa = 0 and Ff = 1, \u2022 for every q1, q2, q \u2208 Q we define\n\u03b40(\u03b5, \u03b1, q) = { 1 if q \u2208 {\u22a5, a} 0 otherwise \u03b41(q1, \u03b3, q) = { 1 if q1q \u2208 {\u22a5\u22a5, ff} 0 otherwise\n\u03b42(q1q2, \u03c3, q) = { 1 if q1q2q \u2208 {\u22a5\u22a5\u22a5,\u22a5af,\u22a5ff, f\u22a5f} 0 otherwise .\nThe (\u03a3,Nat)-wrtg G = (Q, f,R,wt) in tree automata form which is related to A is defined by:\n\u2022 R = {q \u2192 \u03b8(q1, . . . , qk) | k \u2208 N, \u03b8 \u2208 \u03a3(k), q, q1, . . . , qk \u2208 Q} and \u2022 for every q1, q2, q \u2208 Q\nwt(q \u2192 \u03b1) = { 1 if q \u2208 {\u22a5, a} 0 otherwise wt(q \u2192 \u03b3(q1)) = { 1 if q1q \u2208 {\u22a5\u22a5, ff} 0 otherwise\nwt(q \u2192 \u03c3(q1, q2)) = { 1 if q1q2q \u2208 {\u22a5\u22a5\u22a5,\u22a5af,\u22a5ff, f\u22a5f} 0 otherwise .\nLemma 9.2.5. Let \u03a3 be a ranked alphabet and B be a strong bimonoid. Moreover, let A be a (\u03a3,B)-wta with identity root weights and G be a (\u03a3,B)-wrtg in tree automata form. If A and G are related, then [[A]]run = [[G]].\nProof. LetA = (Q, \u03b4, F ) and G = (N,S,R,wt). Since G is in tree automata form, we have pos(d) = pos(\u03be) for every \u03be \u2208 T\u03a3 and d \u2208 RTG(\u03be). Moreover, since A and G are related, there exists a one-to-one correspondence between (a) the rules tree of G and (b) pairs of \u03a3-trees and runs on them.\nFor the formalization we recall the set TR defined in Section 3.1 on p. 63. We have TR = {(\u03be, \u03c1) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be)}. Then we define the mapping \u03d5 : RTG(N,T\u03a3)\u2192 TR such that, for every A \u2208 N , \u03be \u2208 T\u03a3, and d \u2208 RTG(A, \u03be), we let\n\u03d5(d) = (\u03be, \u03c1)\nwhere, for each w \u2208 pos(\u03be), we let \u03c1(w) = lhs(d(w)) (cf. Figure 9.2). Hence, \u03c1 \u2208 RA(A, \u03be). Since A and G are related, \u03d5 is bijective.\nNext we will prove a relationship between the weights of rule trees of G and weights of runs of A that are related by \u03d5. For this we use the well-founded set (RTG(N,T\u03a3),\u227a), where we let\n\u227a = \u227aR \u2229 (RTG(N,T\u03a3)\u00d7 RTG(N,T\u03a3)) .\nObviously, \u227a is well-founded and min\u227a(RTG(N,T\u03a3)) is the set of terminal rules of R, which is not empty. Then, by induction on (RTG(N,T\u03a3),\u227a), we prove that the following statement holds:\nFor each d \u2208 RTG(N,T\u03a3), we have: wtG(d) = wtA(\u03d5(d)) . (9.3)\nLet d \u2208 RTG(N,T\u03a3), i.e., d \u2208 RTG(A, \u03be) for some A \u2208 N and \u03be = \u03c3(\u03be1, . . . , \u03bek). Since pos(\u03be) = pos(d), there exists a rule r = (A \u2192 \u03c3(B1 . . . , Bk)) in R and for each i \u2208 [k] there exists a rule tree di \u2208 RTG(Bi, \u03bei) such that d = r(d1, . . . , dk). Then\nwtG(d) = \u2297\ni\u2208[k]\nwtG(di)\u2297 wt(A\u2192 \u03c3(B1 . . . , Bk)) (by (8.1))\n= \u2297\ni\u2208[k]\nwtA(\u03d5(di))\u2297 \u03b4k(B1 \u00b7 \u00b7 \u00b7Bk, \u03c3, A) (by I.H. and definition of related)\n= wtA(\u03d5(d)) . (by definition of \u03d5 and (3.1))\nThis proves (9.3).\nLet \u03be \u2208 T\u03a3. Then\n[[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5)\n= \u2295\nA\u2208S\n\u2295\n\u03c1\u2208RA(A,\u03be)\nwtA(\u03be, \u03c1) (because A has identity root weights and FA = 1 iff A \u2208 S)\n= \u2295\nA\u2208S\n\u2295\nd\u2208RTG(A,\u03be)\nwtA(\u03be, \u03d5(d))\n(because \u03d5 is a bijection and \u03d5(RTG(A, \u03be)) = RA(A, \u03be) for each A \u2208 S)\n= \u2295\nA\u2208S\n\u2295\nd\u2208RTG(A,\u03be)\nwtG(d) (by Equation (9.3))\n=[[G]](\u03be) .\nLemma 9.2.6. For each (\u03a3,B)-wta A, we can construct a (\u03a3,B)-wrtg G such that G is in tree automata form and [[A]]run = [[G]].\nProof. By Theorem 7.3.1, we can construct a root weight normalized (\u03a3,B)-wta A\u2032 such that [[A]]run = [[A\u2032]]run. Thus, in particular, A\u2032 has identity root weights. It is obvious how to construct the (\u03a3,B)-wrtg G in tree automata form such that A\u2032 and G are related. By Lemma 9.2.5, we have [[A\u2032]]run = [[G]].\nCorollary 9.2.7. Each r-recognizable (\u03a3,B)-weighted tree language is a (\u03a3\u039e,B)-weighted context-free language.\nProof. By Lemma 9.2.6, for each (\u03a3,B)-wta A we can construct a (\u03a3,B)-wrtg G such that G is in tree automata form and [[A]]run = [[G]]. Since G is a particular (\u03a3\u039e,B)-wcfg, we obtain the result.\nLemma 9.2.8. Let G be a (\u03a3,B)-wrtg. If (a) G is chain-free or (b) B is a semiring and G is finitederivational or (c) B is a \u03c3-complete semiring, then there exists a (\u03a3,B)-wta A such that [[G]] = [[A]]run. In Cases (a) and (b) we can even construct A.\nProof. By Lemma 9.2.3, in each of the Cases (a), (b), and (c) there exists a (\u03a3,B)-wrtg G\u2032 in tree automata form such that [[G\u2032]] = [[G]]. In Cases (a) and (b) we can even construct G\u2032. Then, it is obvious\n180 CHAPTER 9. WEIGHTED REGULAR TREE GRAMMARS\nhow to construct a (\u03a3,B)-wta A with identity root weights such that A and G\u2032 are related. Finally, by Lemma 9.2.5, we have [[G\u2032]] = [[A]]run.\nNow we can prove the equivalence of (\u03a3,B)-wta and chain-free (\u03a3,B)-wrtg. For the case that B is the Boolean semiring, this is [GS84, Thm. 2.3.6] and [Eng75b, Thm. 3.25].\nTheorem 9.2.9. Let \u03a3 be a ranked alphabet and B be a strong bimonoid. Then the following two statements hold. (1) Regnc(\u03a3,B) = Rec\nrun(\u03a3,B). (2) If B is a semiring, then Reg(\u03a3,B) = Rec(\u03a3,B).\nProof. First we prove the inclusions from left to right. In Statement (1), the inclusion follows from Lemma 9.2.8(a). In Statement (2), if B is not \u03c3-complete, then Reg(\u03a3,B) = Regfd(\u03a3,B), hence the inclusion follows from Lemma 9.2.8(b). In Statement (2), if B is \u03c3-complete, then it follows from Lemma 9.2.8(c). The inclusions from right to left follow from Lemma 9.2.6 and the fact that, if a wrtg is in tree automata form, then it is both chain-free and finite-derivational.\nFinally, we mention that, for every (\u03a3,B)-wta A with identity root weights and (\u03a3,B)-wrtg G in tree automata form, if A and G are related, then the following equivalence holds:\nA is local-trim iff G is local-reduced.\nThe following result generalizes [IF75, Thm. 2] (also cf. [Eng75b, Thm. 3.57] and [GS84, Thm. 3.2.2] for the unweighted case). It says that the weighted rule tree language of each wcfg is a regular weighted tree language. In Lemma 11.2.2 we will prove that each such weighted rule tree language can be determined by some weighted local system.\nTheorem 9.2.10. Let \u0393 be an alphabet and B a strong bimonoid. Let \u0393 be an alphabet and B a strong bimonoid. For each (\u0393,B)-wcfg G with rule set R, we can construct an (R,B)-wrtg G\u2032 such that [[G\u2032]] = [[G]]wrt.\nProof. Let G = (N,S,R,wt). We consider R as ranked alphabet such that, for each r \u2208 R, the rank of r is the number of nonterminals in the right-hand side of r.\nWe construct the (R,B)-wrtg G\u2032 = (N,S,R\u2032,wt\u2032) as follows. If r = (A \u2192 u0A1u1 \u00b7 \u00b7 \u00b7Akuk) is in R, then r\u2032 = (A \u2192 r(A1, . . . , Ak)) is in R\u2032, and we let wt\n\u2032(r\u2032) = wt(r). In the usual way, we also consider R\u2032 as ranked alphabet.\nLet \u03be \u2208 RTG . We define d\u03be \u2208 RTG\u2032 such that pos(d\u03be) = pos(\u03be) and, for each w \u2208 pos(d\u03be), if \u03be(w) = r and r = (A \u2192 u0A1u1 \u00b7 \u00b7 \u00b7Akuk), then we let d\u03be(w) = (A \u2192 r(A1, . . . , Ak)). Obviously, RTG\u2032(\u03be) = {d\u03be} and wtG\u2032(d\u03be) = wtG(\u03be).\nNow let \u03be \u2208 TR. If \u03be 6\u2208 RTG , then RTG\u2032(\u03be) = \u2205 and\n[[G\u2032]](\u03be) = \u2211\u2295\nd\u2208RTG\u2032 (\u03be)\nwtG\u2032(d) = 0 = (wtG \u2297 \u03c7(RTG))(\u03be) = [[G]] wrt(\u03be) .\nIf \u03be \u2208 RTG , then\n[[G\u2032]](\u03be) = \u2211\u2295\nd\u2208RTG\u2032 (\u03be)\nwtG\u2032(d) = wtG\u2032(d\u03be) = wtG(\u03be) = (wtG \u2297 \u03c7(RTG))(\u03be) = [[G]] wrt(\u03be) .\nChapter 10\nClosure properties\nIn this chapter we prove that the set of recognizable weighted tree languages is closed under several operations. For some of the closure results it is technically easier first to prove them in the setting of wrtg and second to instantiate them to wta by using results on the connection between wrtg and wta (cf. Lemmas 9.2.6 and 9.2.8).\nSince some of the operations change the ranked alphabet or the strong bimonoid, we define corresponding sets of recognizable weighted tree languages in which these parameters are left open (using the underscore). Formally, we abbreviate by Recrun( ,B) the set of all r-recognizable (\u03a3,B)-weighted tree languages for some ranked alphabet \u03a3. Similarly we define the abbreviations Recinit( ,B) and Rec( ,B). Moreover, we abbreviate by Recrun(\u03a3, ) the set of all r-recognizable (\u03a3,B)-weighted tree language for some strong bimonoid B. Similarly we define the abbreviations Recinit(\u03a3, ) and Rec(\u03a3, )."
        },
        {
            "heading": "10.1 Closure under sum",
            "text": "In this section we will prove that the sets Recrun(\u03a3,B) and Recinit(\u03a3,B) are closed under sum. A set L of B-weighted tree languages is closed under sum if the following holds: for every (\u03a3,B)-weighted tree languages r1 and r2, if r1, r2 \u2208 L, then (r1 \u2295 r2) \u2208 L.\nTheorem 10.1.1. Let \u03a3 be a ranked alphabet, B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid, and A1 and A2 be two (\u03a3,B)-wta. Then the following two statements hold. (1) (cf. [Rad10, Lm. 5.1(1)]) We can construct a (\u03a3,B)-wta B such that [[B]]run = [[A1]]run \u2295 [[A2]]run\nand [[B]]init = [[A1]]init \u2295 [[A2]]init. (2) If A1 and A2 are crisp deterministic, then we can construct a crisp deterministic (\u03a3,B)-wta B such\nthat [[B]] = [[A1]]\u2295 [[A2]]. Thus, in particular, the sets Recrun(\u03a3,B) and Recinit(\u03a3,B) are closed under sum.\nProof. Let A1 = (Q1, \u03b41, F1) and A2 = (Q2, \u03b42, F2) such that Q1 \u2229Q2 = \u2205.\nProof of (1): We construct the (\u03a3,B)-wta B = (Q, \u03b4, F ) as follows:\n\u2022 Q = Q1 \u222aQ2, \u2022 for every k \u2208 N, \u03c3 \u2208 \u03a3(k), q \u2208 Q, and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Qk we define\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) =    (\u03b41)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) if q1, . . . , qk, q \u2208 Q1 (\u03b42)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) if q1, . . . , qk, q \u2208 Q2 0 otherwise ,\n\u2022 for each q \u2208 Q we define Fq = (F1)q if q \u2208 Q1, and Fq = (F2)q if q \u2208 Q2.\n181\n182 CHAPTER 10. CLOSURE PROPERTIES\nWe prove that [[B]]run = [[A1]]run\u2295[[A2]]run. Let \u03be \u2208 T\u03a3 and \u03c1 \u2208 RB(\u03be). Obviously, RA1(\u03be)\u2229RA2(\u03be) = \u2205 and RA1(\u03be) \u222a RA2(\u03be) \u2286 RB(\u03be). Moreover, wtB(\u03be, \u03c1) = wtAi(\u03be, \u03c1) if \u03c1 \u2208 RAi(\u03be) for each i \u2208 {1, 2}, and wtB(\u03be, \u03c1) = 0 if \u03c1 \u2208 RB(\u03be) \\ (RA1(\u03be) \u222a RA2(\u03be)). Thus\n[[B]]run(\u03be) = \u2295\n\u03c1\u2208RB(\u03be)\nwtB(\u03be, \u03c1)\u2297 F\u03c1(\u03b5)\n= \u2295\n\u03c1\u2208RA1 (\u03be)\nwtA1(\u03be, \u03c1)\u2297 (F1)\u03c1(\u03b5) \u2295 \u2295\n\u03c1\u2208RA2 (\u03be)\nwtA2(\u03be, \u03c1)\u2297 (F2)\u03c1(\u03b5)\n= [[A1]] run(\u03be) \u2295 [[A2]] run(\u03be2) .\nNext we prove [[B]]init = [[A1]]init \u2295 [[A2]]init. Let \u03be \u2208 T\u03a3. Obviously, for every q \u2208 Q,\nhB(\u03be)q =\n{ hA1(\u03be)q if q \u2208 Q1\nhA2(\u03be)q if q \u2208 Q2 .\nThus,\n[[B]]init(\u03be) = \u2295\nq\u2208Q\nhB(\u03be)q \u2297 Fq = \u2295\nq\u2208Q1\nhA1(\u03be)q \u2297 (F1)q \u2295 \u2295\nq\u2208Q2\nhA2(\u03be)q \u2297 (F2)q\n= [[A1]] init(\u03be)\u2295 [[A2]] init(\u03be) .\nProof of (2): Let A1 and A2 be crisp deterministic. We construct the (\u03a3,B) wta B = (Q, \u03b4, F ) as follows:\n\u2022 Q = Q1 \u00d7Q2; for each q \u2208 Q we denote its first and second component by q1 and q2, respectively, \u2022 for every k \u2208 N, \u03c3 \u2208 \u03a3(k), q \u2208 Q and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Qk we define\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = (\u03b41)k(q 1 1 \u00b7 \u00b7 \u00b7 q 1 k, \u03c3, q 1)\u2297 (\u03b42)k(q 2 1 \u00b7 \u00b7 \u00b7 q 2 k, \u03c3, q 2)\n\u2022 for each q \u2208 Q we define Fq = (F1)q1 \u2295 (F2)q2 .\nObviously, B is crisp deterministic.\nLet \u03be \u2208 T\u03a3 and i \u2208 {1, 2}. Since Ai is crisp deterministic, by Lemma 4.3.1 there exists a state qi\u03be such\nthat Q hAi 6=0 (\u03be) = {q i \u03be} and hAi(\u03be)qi\u03be = 1. Then, obviously, Q hB 6=0(\u03be) = {(q 1 \u03be , q 2 \u03be )} and hB(\u03be)(q1\u03be ,q2\u03be)(\u03be) = 1. Then we can calculate as follows:\n[[B]](\u03be) = hB(\u03be)(q1 \u03be ,q2 \u03be ) \u2297 F(q1 \u03be ,q2 \u03be ) = F(q1 \u03be ,q2 \u03be ) = (F1)q1 \u03be \u2295 (F2)q2 \u03be = [[A1]](\u03be)\u2295 [[A2]](\u03be) .\nWe note that, in the proof of Theorem 10.1.1(1), we cannot use the product construction of the proof of Theorem 10.1.1(2), because that would require the strong bimonoid B to be commutative. Also, vice versa, in the proof of Theorem 10.1.1(2), we cannot use the union construction of the proof of Theorem 10.1.1(1), because in general that does not preserve bu determinism: on a nullary symbol the constructed (\u03a3,B)-wta B can start with some q \u2208 Q1 or with some q\u2032 \u2208 Q2.\nFurther, we note that in [Gho22, Thm. 4.1] closure of Recinit(\u03a3,B) under sum was proved for the particular case that B is a \u03c3-complete orthomodular lattice. Since each \u03c3-complete orthomodular lattice is a particular strong bimonoid, [Gho22, Thm. 4.1] follows from Theorem 10.1.1 and from [Rad10, Lm. 5.1(1)].\nFor the case of bu deterministic wta we get the following negative result. (Hence [Rad10, Lm. 5.1(2)] is wrong, because the construction of that lemma does not preserve bu determinism.)\nTheorem 10.1.2. There exists a string ranked alphabet \u03a3 such that bud-Rec(\u03a3,Rat) is not closed under sum.\n10.2. CLOSURE UNDER SCALAR MULTIPLICATIONS 183\nProof. We let \u03a3 = {\u03b3(1), \u03b1(0)}. It is easy to define the bu deterministic (\u03a3,Rat)-wta A1 and A2 over \u03a3 and Q such that [[A1]](\u03b3n\u03b1) = 2n and [[A2]](\u03b3n\u03b1) = 1 for each n \u2208 N. Clearly, [[A1]] + [[A2]] = (exp+1) where the weighted tree language (exp+1) is defined in Example 3.2.9. However, as Theorem 17.2.2 shows, (exp+1) is not in bud-Rec(\u03a3,Rat)."
        },
        {
            "heading": "10.2 Closure under scalar multiplications",
            "text": "In this section we will prove that the sets Recinit(\u03a3,B) and Recrun(\u03a3,B) are closed under scalar multiplications from the left and from the right. A set L of B-weighted tree languages is closed under scalar multiplications from the left if for every b \u2208 B and r \u2208 L, the B-weighted tree language b \u2297 r is in L. Similarly we define the concept closed under scalar multiplications from the right. A set L is closed under scalar multiplications if it is closed under scalar multiplications from the left and closed under scalar multiplications from the right.\nTheorem 10.2.1. (cf. [Rad10, Thm. 5.4]) Let \u03a3 be a ranked alphabet, B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid, and A be a (\u03a3,B)-wta. Moreover, let b \u2208 B. Then the following four statements hold. (1) If (a) B is left-distributive or (b) A is bu deterministic, then we can construct a (\u03a3,B)-wta B such\nthat [[B]]init = b\u2297 [[A]]init and [[B]]run = b\u2297 [[A]]run. (2) If B is right-distributive, then we can construct a (\u03a3,B)-wta B such that [[B]]init = [[A]]init \u2297 b and\n[[B]]run = [[A]]run \u2297 b. (3) If A is bu deterministic, then we can construct a bu deterministic (\u03a3,B)-wta B such that [[B]] =\n[[A]]\u2297 b. Moreover, if A is crisp deterministic, then so is B. (4) If A is crisp deterministic, then we can construct a crisp deterministic (\u03a3,B)-wta B such that\n[[B]] = b\u2297 [[A]]. Thus, in particular, if B is a semiring, then the set Rec(\u03a3,B) is closed under scalar multiplications.\nProof. Proof of (1): Let A = (Q, \u03b4, F ). We construct the (\u03a3,B)-wta B = (Q\u2032, \u03b4\u2032, F \u2032) such that, if (a) or (b) holds, then [[B]]init = b \u2297 [[A]]init and [[B]]run = b \u2297 [[A]]run, using the following idea. The wta B simulates A but, at the leftmost leaf of each input tree, it multiplies the weight of the applied transition with b from the left. The information about this multiplication is propagated up by using states of the form q\u2113 for each q \u2208 Q. Formally, we let\n\u2022 Q\u2032 = Q0 \u222aQ\u2113 where Q0 = {q0 | q \u2208 Q} and Q\u2113 = {q\u2113 | q \u2208 Q}, \u2022 for every q \u2208 Q and \u03b1 \u2208 \u03a3(0), we let \u03b4\u20320(\u03b5, \u03b1, q 0) = \u03b40(\u03b5, \u03b1, q) and \u03b4 \u2032 0(\u03b5, \u03b1, q\n\u2113) = b\u2297 \u03b40(\u03b5, \u03b1, q), for every k \u2208 N+, \u03c3 \u2208 \u03a3(k), and q s1 1 , . . . , q sk k , q s \u2208 Q\u2032, we let\n\u03b4\u2032k(q s1 1 \u00b7 \u00b7 \u00b7 q sk k , \u03c3, q s) =    \u03b4k(q1 . . . qk, \u03c3, q) if ( s1 = s = \u2113 \u2227 (\u2200i \u2208 [2, k]) : si = 0 ) \u2228 ( s = 0 \u2227 (\u2200i \u2208 [k]) : si = 0 )\n0 otherwise\n\u2022 for every q \u2208 Q we let (F \u2032)q\u2113 = Fq and (F \u2032)q0 = 0.\nWe note that this construction does not preserve bu determinism.\nNow we assume that B is left-distributive or A is bu deterministic. First, we prove that [[B]]init = b\u2297 [[A]]init. For this, by induction on T\u03a3, we can prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and q \u2208 Q, we have hB(\u03be)q0 = hA(\u03be)q . (10.1)\nSince this proof is straightforward, we do not show it. Next, by induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and q \u2208 Q, we have hB(\u03be)q\u2113 = b\u2297 hA(\u03be)q . (10.2)\n184 CHAPTER 10. CLOSURE PROPERTIES\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). Then\nhB(\u03be)q\u2113 = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Q k,\ns1,...,sk\u2208{0,\u2113}\nhB(\u03be1)qs11 \u2297 . . .\u2297 hB(\u03bek)q sk k \u2297 \u03b4\u2032k(q s1 1 \u00b7 \u00b7 \u00b7 q sk k , \u03c3, q \u2113)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nhB(\u03be1)q\u21131 \u2297 hB(\u03be2)q02 \u2297 . . .\u2297 hB(\u03bek)q0k \u2297 \u03b4 \u2032 k(q \u2113 1q 0 2 \u00b7 \u00b7 \u00b7 q 0 k, \u03c3, q \u2113)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nb\u2297 hA(\u03be1)q1 \u2297 hA(\u03be2)q2 \u2297 . . .\u2297 hA(\u03bek)qk \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n(by I.H., (10.1), and construction)\nWe continue with case analysis.\nCase (a): Let B be left-distributive. Then we can continue as follows:\n\u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nb\u2297 hA(\u03be1)q1 \u2297 . . .\u2297 hA(\u03bek)qk \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= b\u2297 \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nhA(\u03be1)q1 \u2297 . . .\u2297 hA(\u03bek)qk \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= b\u2297 hA(\u03be)q .\nCase (b): Let A be bu deterministic. By Lemma 4.2.1(3), there are two subcases.\nCase (b1): There exists i \u2208 [k] such that for each q \u2208 Q we have hA(\u03bei)q = 0. Then we can continue as follows:\n\u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nb\u2297 hA(\u03be1)q1 \u2297 . . .\u2297 hA(\u03bei)qi \u2297 . . .\u2297 hA(\u03bek)qk \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nb\u2297 hA(\u03be1)q1 \u2297 . . .\u2297 0\u2297 . . .\u2297 hA(\u03bek)qk \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= 0 = b\u2297 \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nhA(\u03be1)q1 \u2297 . . .\u2297 0\u2297 . . .\u2297 hA(\u03bek)qk \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= b\u2297 hA(\u03be)q .\nCase (b2): For each i \u2208 [k] there exists exactly one q\u0304i \u2208 Q such that hA(\u03bei)q\u0304i 6= 0. Then we can continue as follows:\n\u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nb\u2297 hA(\u03be1)q1 \u2297 . . .\u2297 hA(\u03bek)qk \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= b\u2297 hA(\u03be1)q\u03041 \u2297 . . .\u2297 hA(\u03bek)q\u0304k \u2297 \u03b4k(q\u03041 \u00b7 \u00b7 \u00b7 q\u0304k, \u03c3, q)\nb\u2297 \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\nhA(\u03be1)q1 \u2297 . . .\u2297 hA(\u03bek)qk \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= b\u2297 hA(\u03be)q .\nThis finishes the proof of (10.2). Now we prove that [[B]]init = b\u2297 [[A]]init. For each \u03be \u2208 T\u03a3 we have:\n[[B]]init(\u03be) = \u2295\ns\u2208{0,\u2113} qs\u2208Q\u2032\nhB(\u03be)qs \u2297 (F \u2032)qs =\n\u2295\nq\u2113\u2208Q\u2113\nhB(\u03be)q\u2113 \u2297 Fq\u2113 = \u2295\nq\u2208Q\nb\u2297 hA(\u03be)q \u2297 Fq ,\n10.2. CLOSURE UNDER SCALAR MULTIPLICATIONS 185\nwhere the last equality follows from (10.2) and the definition of B.\nWe proceed by case analysis as above.\nCase (a): Let B be left-distributive. Then we can continue as follows:\n\u2295\nq\u2208Q\nb\u2297 hA(\u03be)q \u2297 Fq = b\u2297 \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq = b\u2297 [[A]] init(\u03be) .\nCase (b): Let A be bu deterministic. Again, by Lemma 4.2.1(3), there are two cases.\nCase (b1): For each q \u2208 Q we have hA(\u03be)q = 0. Then we can continue as follows:\n\u2295\nq\u2208Q\nb\u2297 hA(\u03be)q \u2297 Fq = 0 = b\u2297 \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq = b\u2297 [[A]] init(\u03be) .\nCase (b2): There exists exactly one q\u0304 \u2208 Q such that hA(\u03be)q\u0304 6= 0. Then we can continue as follows:\n\u2295\nq\u2208Q\nb\u2297 hA(\u03be)q \u2297 Fq = b\u2297 hA(\u03be)q\u0304 \u2297 Fq\u0304 = b\u2297 \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq = b\u2297 [[A]] init(\u03be) .\nThis finishes the proof of [[B]]init = b\u2297 [[A]]init.\nSecond, we prove that [[B]]run = b\u2297 [[A]]run. For each \u03be \u2208 T\u03a3 we define the sets\nposleft(\u03be) = {w \u2208 pos(\u03be) | w = 1 n for some n \u2208 N},\nR0B(\u03be) = {\u03c1 \u2208 RB(\u03be) | im(\u03c1) \u2286 Q 0}, and R\u2113B(\u03be) = {\u03c1 \u2208 RB(\u03be) | (\u2200w \u2208 posleft(\u03be)) : \u03c1(w) \u2208 Q \u2113 and (\u2200w \u2208 pos(\u03be) \\ posleft(\u03be)) : \u03c1(w) \u2208 Q 0} .\nMoreover, for each \u03be \u2208 T\u03a3, we define the mapping (.) : RB(\u03be) \u2192 RA(\u03be) such that, for every \u03c1 \u2208 RB(\u03be), we abbreviate (.)(\u03c1) by \u03c1 and the run \u03c1 of A is obtained from \u03c1 by dropping the upper index (in {0, \u2113}) from each state.\nBy the construction of B, the following observations are easy to see.\nFor every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RB(\u03be) \\ (R 0 B(\u03be) \u222a R \u2113 B(\u03be)) we have wtB(\u03be, \u03c1) = 0. (10.3)\nFor every \u03be \u2208 T\u03a3 and \u03c1 \u2208 R 0 B(\u03be) we have wtB(\u03be, \u03c1) = wtA(\u03be, \u03c1). (10.4)\nFor every \u03be \u2208 T\u03a3 and \u03c1 \u2208 R \u2113 B(\u03be) we have wtB(\u03be, \u03c1) = b\u2297 wtA(\u03be, \u03c1). (10.5)\nFor the proof of (10.5) we need (10.3), and (10.4). Then for each \u03be \u2208 T\u03a3 we can compute as follows.\n[[B]]run(\u03be) = \u2295\n\u03c1\u2208RB(\u03be)\nwtB(\u03be, \u03c1)\u2297 (F \u2032)\u03c1(\u03b5)\n= \u2295\n\u03c1\u2208RB(\u03be): \u03c1(\u03b5)\u2208Q\u2113\nwtB(\u03be, \u03c1)\u2297 (F \u2032)\u03c1(\u03b5) (because (F \u2032)qs = 0 for each q s \u2208 Q0)\n= \u2295\n\u03c1\u2208RB(\u03be): \u03c1(\u03b5)\u2208Q\u2113\nwtB(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) (by definition of F \u2032)\n= \u2295\n\u03c1\u2208R\u2113B(\u03be)\nwtB(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) (by (10.3))\n= \u2295\n\u03c1\u2208R\u2113B(\u03be)\nb\u2297 wtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) (by (10.5))\n186 CHAPTER 10. CLOSURE PROPERTIES\n= \u2295\n\u03c1\u2208RA(\u03be)\nb\u2297 wtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) (because the restriction of (.) to R \u2113 B(\u03be) is a bijection)\nWe proceed by case analysis.\nCase (a): Let B be left-distributive. Then we can continue as follows:\n\u2295\n\u03c1\u2208RA(\u03be)\nb\u2297 wtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = b\u2297 \u2295\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = b\u2297 [[A]] run(\u03be) ,\nwhere we use left-distributivity at the first equality.\nCase (b): Let A be bu deterministic. By Lemma 4.2.1(3), there are two cases.\nCase (b1): For each \u03c1 \u2208 RA(\u03be) we have wtA(\u03be, \u03c1) = 0. Then we can continue as follows:\n\u2295\n\u03c1\u2208RA(\u03be)\nb\u2297 wtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = \u2295\n\u03c1\u2208RA(\u03be)\nb \u2297 0\u2297 F\u03c1(\u03b5) = b\u2297 \u2295\n\u03c1\u2208RA(\u03be)\n0\u2297 F\u03c1(\u03b5)\n= b\u2297 \u2295\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = b\u2297 [[A]] run(\u03be) .\nCase (b2): There exist exactly one q \u2208 Q and one \u03c1 \u2208 RA(q, \u03be) such that wtA(\u03be, \u03c1) 6= 0; then wtA(\u03be, \u03c1) = hA(\u03be)q . (Note that \u03c1(\u03b5) = q.) Then we continue as follows:\n\u2295\n\u03c1\u2208RA(\u03be)\nb\u2297 wtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = b \u2297 wtA(\u03be, \u03c1)\u2297 Fq = b\u2297 \u2295\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = b\u2297 [[A]] run(\u03be) .\nThis finishes the proof of [[B]]run = b\u2297 [[A]]run.\nProof of (2): Let A = (Q, \u03b4, F ). We construct B = (Q, \u03b4, F \u2032) by letting (F \u2032)q = Fq \u2297 b for each q \u2208 Q. First, we prove that [[B]]init = [[A]]init \u2297 b. Obviously,\nfor each q \u2208 Q we have hB(\u03be)q = hA(\u03be)q . (10.6)\n(We note that the proof of (10.6) does not need the assumption that B is right-distributive.) Now we assume that B is right-distributive.\nThen, for each \u03be \u2208 T\u03a3, we can calculate as follows.\n[[B]]init(\u03be) = \u2295\nq\u2208Q\nhB(\u03be)q \u2297 (F \u2032)q\n= \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq \u2297 b (by (10.6) and the definition of B)\n= (\u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq ) \u2297 b (by right-distributivity)\n= [[A]]init(\u03be)\u2297 b .\nSecond, we prove that [[B]]run = [[A]]run \u2297 b. Obviously,\nfor each \u03be \u2208 T\u03a3 we have RA(\u03be) = RB(\u03be) and for each \u03c1 \u2208 RA(\u03be) we have wtA(\u03be, \u03c1) = wtB(\u03be, \u03c1) . (10.7)\nThen, for each \u03be \u2208 T\u03a3, we can calculate as follows.\n[[B]]run(\u03be) = \u2295\n\u03c1\u2208RB(\u03be)\nwtB(\u03be, \u03c1)\u2297 (F \u2032)\u03c1(\u03b5)\n10.3. CHARACTERIZATION OF RECOGNIZABLE STEP MAPPINGS 187\n= \u2295\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) \u2297 b (by (10.7))\n= ( \u2295\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) ) \u2297 b (by right-distributivity)\n= [[A]]run(\u03be)\u2297 b .\nProof of (3): Let A = (Q, \u03b4, F ) be bu deterministic. We construct B = (Q, \u03b4, F \u2032) in the same way as in the proof of Statement (2). It is obvious that this construction preserves bu determinism and crisp determinism. Let \u03be \u2208 T\u03a3. By Lemma 4.2.1, there are two cases.\nCase (a): For each q \u2208 Q we have hA(\u03be)q = 0. Then by (10.6) we obtain:\n[[B]](\u03be) = \u2295\nq\u2208Q\nhB(\u03be)q \u2297 (F \u2032)q = 0 =\n(\u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq ) \u2297 b = [[A]](\u03be) \u2297 b .\nCase (b): There exists exactly one q\u0304 \u2208 Q such that hA(\u03be)q\u0304 6= 0. Then, using (10.6) again, we can continue as follows:\n[[B]](\u03be) = \u2295\nq\u2208Q\nhB(\u03be)q \u2297 (F \u2032)q = hB(\u03be)q\u0304 \u2297 F \u2032 q\u0304 = hA(\u03be)q\u0304 \u2297 Fq\u0304 \u2297 b =\n(\u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq ) \u2297 b = [[A]](\u03be) \u2297 b .\nProof of (4). Let A = (Q, \u03b4, F ) be crisp deterministic. We construct B = (Q, \u03b4, F \u2032) where F \u2032q = b\u2297Fq for each q \u2208 Q. Obviously, B is crisp deterministic and (10.6) also holds for this B. Due to Lemma 4.3.1, there exists a state q\u03be such that Q hA 6=0(\u03be) = {q\u03be} and hA(\u03be)q\u03be = 1, and hence [[A]](\u03be) = Fq\u03be . Then:\n[[B]](\u03be) = hB(\u03be)q\u03be \u2297 (F \u2032)q\u03be = hA(\u03be)q\u03be \u2297 b\u2297 Fq\u03be = b\u2297 Fq\u03be = b\u2297 [[A]](\u03be) ."
        },
        {
            "heading": "10.3 Characterization of recognizable step mappings",
            "text": "As a kind of application of closure under sum and under scalar multiplications, we show that recognizable step mappings and crisp deterministic wta are closely related (cf. Theorem 10.3.1). Moreover, we prove a characterization of the set of all recognizable step mappings in terms of characteristic mappings of recognizable tree languages and closure under sum and scalar multiplication (cf. Theorem 10.3.3).\nWe recall that a weighted tree language r : T\u03a3 \u2192 B is a recognizable step mapping (cf. Section 2.14) if there exist n \u2208 N+, b1, . . . , bn \u2208 B, and recognizable \u03a3-tree languages L1, . . . , Ln such that\nr = \u2295\ni\u2208[n]\nbi \u2297 \u03c7(Li) .\nIn the next theorem, the equivalences (A)\u21d4(B)\u21d4(C) were proved in [DSV10, Lm. 8 and Prop. 9], respectively, for the string case. The implication (B)\u21d2(D) of Theorem 10.3.1 was proved in [DV06, Lm. 3.1] for the case that B is a semiring. A similar result was proved in [Li08a, Thm. 2.1] for wsa over a pair of t-conorm and t-norm. We recall that a weighted tree language r : T\u03a3 \u2192 B has the preimage property, if r\u22121(b) is a recognizable \u03a3-tree language for each b \u2208 B.\n188 CHAPTER 10. CLOSURE PROPERTIES\nTheorem 10.3.1. Let \u03a3 be a ranked alphabet and B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid. Let r : T\u03a3 \u2192 B. Then the following four statements are equivalent. (A) We can construct a crisp deterministic (\u03a3,B)-wta A such that r = [[A]]. (B) r is a recognizable step mapping and we can construct n \u2208 N+, b1, . . . , bn \u2208 B, and \u03a3-fta A1, . . . , An\nsuch that r = \u2295\ni\u2208[n] bi \u2297 \u03c7(L(Ai)).\n(C) im(r) is finite, r has the preimage property, and we can construct n \u2208 N+ and elements b1, . . . , bn \u2208 B such that im(r) = {b1, . . . , bn} and, moreover, for each b \u2208 B we can construct a \u03a3-fta which recognizes r\u22121(b). (D) r is a recognizable step mapping with pairwise disjoint step languages and we can construct n \u2208 N+, b1, . . . , bn \u2208 B, and \u03a3-fta A1, . . . , An such that r = \u2295 i\u2208[n] bi \u2297 \u03c7(L(Ai)).\nThus, in particular, cd-Rec(\u03a3,B) = RecStep(\u03a3,B).\nProof. Proof of (A)\u21d2(D): Let A be a crisp deterministic (\u03a3,B)-wta such that r = [[A]]. By Theorem 4.3.5, we can construct a finite \u03a3-algebra (Q, \u03b8) and a mapping F : Q\u2192 B such that [[A]] = F \u25e6 hQ.\nLet n = |Q| and let p1, . . . , pn be a list of the elements of Q. For each i \u2208 [n] we construct the bu deterministic and total \u03a3-fta Ai = (Q, \u03b4, {pi}), where for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and q \u2208 Q and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Qk, we have\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3) = q iff \u03b8(\u03c3)(q1, . . . , qk) = q .\nSince each fta Ai is bu deterministic, it is obvious that, for every i, i \u2032 \u2208 [n] with i 6= i\u2032, the sets L(Ai) and L(Ai\u2032 ) are disjoint, i.e., L(Ai) \u2229 L(Ai\u2032) = \u2205.\nLet us abbreviate Fpi by bi for every i \u2208 [n]. Next we prove that r = \u2295 i\u2208[n] bi\u2297\u03c7(L(Ai)). Obviously, for every i \u2208 [n], we have hQ = hAi , where hAi is the unique homomorphism from T\u03a3 to the \u03a3-algebra (P(Q), \u03b4Ai) defined in Section 2.13.\nNow let \u03be \u2208 T\u03a3 and let hQ(\u03be) = pj. Then, in particular, hQ = hAj . By definition of Aj it follows that \u03be \u2208 L(Aj), and thus \u03c7(L(Aj))(\u03be) = 1. Moreover, for each pi \u2208 Q with pi 6= hQ(\u03be), we have \u03be 6\u2208 L(Ai) and thus \u03c7(L(Ai))(\u03be) = 0. Thus we have\nr(\u03be) = (F \u25e6 hQ)(\u03be) = Fpj = bj \u2297 \u03c7(L(Aj))(\u03be) = \u2295\ni\u2208[n]\nbi \u2297 \u03c7(L(Ai))(\u03be) .\nHence r is a recognizable step mapping with pairwise disjoint step languages.\nProof of (D)\u21d2(C): For each i \u2208 [n], let us abbreviate L(Ai) by Li. Hence r = \u2295 i\u2208[n] bi \u2297 \u03c7(Li),\nwhere the step languages L1, . . . , Ln are pairwise disjoint. Then im(r) = {b1, . . . , bn} if T\u03a3 = \u22c3 i\u2208[n] Li\nand im(r) = {b1, . . . , bn, 0} if T\u03a3 \\ \u22c3 i\u2208[n] Li 6= \u2205; in both cases im(r) is finite.\nNow let b \u2208 B. Then\nr\u22121(b) =\n{\u22c3 i\u2208[n]:bi=b Li if b 6= 0\nT\u03a3 \\ \u22c3 i\u2208[n]:bi 6=0 Li otherwise.\nSince the set of recognizable \u03a3-tree languages is effectively closed under union and complement [GS84, Thm. 2.4.2], in each case we can construct a \u03a3-fta which recognizes r\u22121(b). Thus r has the preimage property.\nProof of (C)\u21d2(B): Let im(r) = {b1, . . . , bn} for some n \u2208 N+ and b1, . . . , bn \u2208 B. By our assumption, for each i \u2208 [n], we can construct a \u03a3-fta Ai with L(Ai) = r\u22121(bi). Then r = \u2295 i\u2208[n] bi\u2297\u03c7(L(Ai)). Hence r is a recognizable step mapping.\nProof of (B)\u21d2(A): Let n \u2208 N+ and r = \u2295\ni\u2208[n] bi\u2297\u03c7(L(Ai)) for some \u03a3-fta A1, . . . , An and coefficients b1, . . . , bn \u2208 B.\nLet i \u2208 [n]. By Theorem 4.3.6, we can construct a crisp deterministic (\u03a3,B)-wta Ai with identity root weights such that [[Ai]] = \u03c7(L(Ai)). By Theorem 10.2.1(4), we can construct a crisp deterministic (\u03a3,B)-\n10.4. CLOSURE UNDER HADAMARD PRODUCT 189\nwta A\u2032i such that [[A \u2032 i]] = bi \u2297 \u03c7(L(Ai)). By Theorem 10.1.1(2), we can construct a crisp deterministic\n(\u03a3,B)-wta A such that [[A]] = \u2295\ni\u2208[n] bi \u2297 \u03c7(L(Ai)).\nWe note that Theorem 10.3.1((B)\u21d2(D)) also follows from Observation 2.14.1.\nCorollary 10.3.2. RecStep(\u03a3,B) is closed under sum and scalar multiplications.\nProof. By Theorem 10.3.1(A)\u21d4(B), RecStep(\u03a3,B) is equal to the set of (\u03a3,B)-weighted tree languages recognizable by crisp deterministic wta. By Theorem 10.1.1(2) the latter is closed under sum. Moreover, by Theorem 10.2.1(3) and (4) it is closed under scalar multiplications from the right and the left, respectively.\nWe finish this section with a characterization of RecStep(\u03a3,B) which results from several closure properties.\nTheorem 10.3.3. Let \u03a3 be a ranked alphabet and B be a strong bimonoid. The set RecStep(\u03a3,B) of (\u03a3,B)-recognizable step mappings is the smallest set of (\u03a3,B)-weighted tree languages which contains, for each recognizable \u03a3-tree language L, the characteristic mapping \u03c7(L) and is closed under sum and scalar multiplication from the left.\nProof. For the sake of convenience, we denote by C the smallest set of (\u03a3,B)-weighted tree languages which contains, for each recognizable \u03a3-tree language L, the characteristic mapping \u03c7(L) and is closed under sum and scalar multiplications from the left.\nFirst we prove that RecStep(\u03a3,B) \u2286 C. Let r \u2208 RecStep(\u03a3,B) with r = \u2295\ni\u2208[n] bi \u2297 \u03c7(Li) for some\nn \u2208 N+, b1, . . . , bn \u2208 B, and L1, . . . , Ln recognizable \u03a3-tree languages. Then, for each i \u2208 [n], we have \u03c7(Li) \u2208 C and bi \u2297 \u03c7(Li) \u2208 C. Since C is closed under sum, we have r \u2208 C.\nSecond we prove that C \u2286 RecStep(\u03a3,B). Obviously, for each recognizable \u03a3-tree language L, the characteristic mapping \u03c7(L) is in RecStep(\u03a3,B). Moreover, by Corollary 10.3.2, RecStep(\u03a3,B) is closed under sum and scalar multiplications from the left. Since C is the smallest set with these properties, we obtain that C \u2286 RecStep(\u03a3,B)."
        },
        {
            "heading": "10.4 Closure under Hadamard product",
            "text": "In this section we will prove that the set Rec(\u03a3,B) is closed under Hadamard product if B is a commutative semiring. A set L of B-weighted tree languages is closed under Hadamard product if the following holds: for every (\u03a3,B)-weighted tree languages r1 and r2, if r1, r2 \u2208 L, then (r1 \u2297 r2) \u2208 L.\nTheorem 10.4.1. Let \u03a3 be a ranked alphabet, B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid, and A1 and A2 be two (\u03a3,B)-wta. Then the following three statements hold. (1) (cf. [Bor04, Cor. 3.9]) If B is a commutative semiring, then we can construct a (\u03a3,B)-wta A such\nthat [[A]] = [[A1]]\u2297 [[A2]]. (2) (cf. [Rad10, Lm. 5.3]) If B is commutative and A1 and A2 are bu deterministic, then we can\nconstruct a bu deterministic (\u03a3,B)-wta A such that [[A]] = [[A1]]\u2297 [[A2]]. (3) If A1 and A2 are crisp deterministic, then we can construct a crisp deterministic (\u03a3,B)-wta A such\nthat [[A]] = [[A1]]\u2297 [[A2]]. Thus, in particular, if B is a commutative semiring, then the set Rec(\u03a3,B) is closed under Hadamard product.\n190 CHAPTER 10. CLOSURE PROPERTIES\nProof. Let A1 = (Q1, \u03b41, F1) and A2 = (Q2, \u03b42, F2). We construct the (\u03a3,B)-wta A = (Q, \u03b4, F ) which we will use in the proof of each of the Statements (1), (2), and (3). We define:\n\u2022 Q = Q1 \u00d7Q2; for each q \u2208 Q we denote its first and second component by q 1 and q2, respectively, \u2022 for every k \u2208 N, \u03c3 \u2208 \u03a3(k), q \u2208 Q, and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Qk we define\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = (\u03b41)k(q 1 1 \u00b7 \u00b7 \u00b7 q 1 k, \u03c3, q 1)\u2297 (\u03b42)k(q 2 1 \u00b7 \u00b7 \u00b7 q 2 k, \u03c3, q 2)\n\u2022 for each q \u2208 Q we define Fq = (F1)q1 \u2297 (F2)q2 .\nObviously, if A1 and A2 are bu deterministic (or crisp deterministic), then so is A.\nProof of (1): We assume that B is a commutative semiring. First, by induction on T\u03a3, we prove that the following statement holds.\nFor every \u03be \u2208 T\u03a3 and q = (q 1, q2) \u2208 Q, we have: hA(\u03be)q = hA1(\u03be)q1 \u2297 hA2(\u03be)q2 . (10.8)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek) and q = (q 1, q2) \u2208 Q. Then:\nhA(\u03be)q = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\nhA(\u03bei)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\n(hA1(\u03bei)q1i \u2297 hA2(\u03bei)q2i ) ) \u2297 (\u2297\nj\u2208[2]\n(\u03b4j)k(q j 1 \u00b7 \u00b7 \u00b7 q j k, \u03c3, q\nj) )\n(by I.H. and construction)\n= \u2295\nq11 \u00b7\u00b7\u00b7q 1 k \u2208(Q1)k\n\u2295\nq21 \u00b7\u00b7\u00b7q 2 k \u2208(Q2)k\n(\u2297\ni\u2208[k]\n(hA1 (\u03bei)q1i \u2297 hA2(\u03bei)q2i ) ) \u2297 (\u2297\nj\u2208[2]\n(\u03b4j)k(q j 1 \u00b7 \u00b7 \u00b7 q j k, \u03c3, q\nj) )\n= \u2295\nq11 \u00b7\u00b7\u00b7q 1 k \u2208(Q1)k\n\u2295\nq21 \u00b7\u00b7\u00b7q 2 k \u2208(Q2)k(\u2297\ni\u2208[k]\nhA1(\u03bei)q1i\n) \u2297 (\u03b41)k(q 1 1 \u00b7 \u00b7 \u00b7 q 1 k, \u03c3, q 1) \u2297 (\u2297\ni\u2208[k]\nhA2(\u03bei)q2i\n) \u2297 (\u03b42)k(q 2 1 \u00b7 \u00b7 \u00b7 q 2 k, \u03c3, q 2)\n(by commutativity)\n= \u2295\nq11 \u00b7\u00b7\u00b7q 1 k \u2208(Q1)k\n[(\u2297\ni\u2208[k]\nhA1(\u03bei)q1i\n) \u2297 (\u03b41)k(q 1 1 \u00b7 \u00b7 \u00b7 q 1 k, \u03c3, q 1) ] \u2297\n( \u2295\nq21 \u00b7\u00b7\u00b7q 2 k \u2208(Q2)k\n(\u2297\ni\u2208[k]\nhA2(\u03bei)q2i\n) \u2297 (\u03b42)k(q 2 1 \u00b7 \u00b7 \u00b7 q 2 k, \u03c3, q 2) )\n(by left-distributivity)\n= ( \u2295\nq11 \u00b7\u00b7\u00b7q 1 k \u2208(Q1)k\n(\u2297\ni\u2208[k]\nhA1(\u03bei)q1i\n) \u2297 (\u03b41)k(q 1 1 \u00b7 \u00b7 \u00b7 q 1 k, \u03c3, q 1) ) \u2297\n( \u2295\nq21 \u00b7\u00b7\u00b7q 2 k \u2208(Q2)k\n(\u2297\ni\u2208[k]\nhA2(\u03bei)q2i\n) \u2297 (\u03b42)k(q 2 1 \u00b7 \u00b7 \u00b7 q 2 k, \u03c3, q 2) )\n(by right-distributivity)\n= hA1(\u03be)q1 \u2297 hA2(\u03be)q2 .\nThis proves (10.8). Then for each \u03be \u2208 T\u03a3:\n[[A]](\u03be) = \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq = \u2295\nq\u2208Q\n( hA1(\u03be)q1 \u2297 hA2(\u03be)q2 ) \u2297 ( (F1)q1 \u2297 (F2)q2 )\n(by Equation (10.8) and construction of F )\n10.4. CLOSURE UNDER HADAMARD PRODUCT 191\n= ( \u2295\nq\u2208Q1\nhA1(\u03be)q \u2297 (F1)q ) \u2297 ( \u2295\nq\u2208Q2\nhA2(\u03be)q \u2297 (F2)q )\n(by commutativity and distributivity of B)\n= [[A1]](\u03be)\u2297 [[A2]](\u03be) .\nProof of (2): Let B be commutative and A1 and A2 be bu deterministic. Then A is bu deterministic. Here we prove (10.8) as follows. Let \u03be = \u03c3(\u03be1, . . . , \u03bek) and q = (q 1, q2) \u2208 Q. As above we obtain\nhA(\u03be)q = \u2295\nq11 \u00b7\u00b7\u00b7q 1 k \u2208(Q1)k\n\u2295\nq21 \u00b7\u00b7\u00b7q 2 k \u2208(Q2)k(\u2297\ni\u2208[k]\nhA1(\u03bei)q1i\n) \u2297 (\u03b41)k(q 1 1 \u00b7 \u00b7 \u00b7 q 1 k, \u03c3, q 1) \u2297 (\u2297\ni\u2208[k]\nhA2(\u03bei)q2i\n) \u2297 (\u03b42)k(q 2 1 \u00b7 \u00b7 \u00b7 q 2 k, \u03c3, q 2) . (10.9)\nWe note that this part uses commutativity and it does not use distributivity. By Lemma 4.2.1(1) (applied to A1 and A2), there are four cases. We can combine the four cases into the following two cases.\nCase (a): (i) There exists an i \u2208 [k] such that, for every q1 \u2208 Q1, we have hA1(\u03bei)q1 = 0 or (ii) there exists a j \u2208 [k] such that, for every q2 \u2208 Q2, we have hA2(\u03bej)q2 = 0.\nDue to (10.9) we have hA(\u03be)q = 0. In Case (i), hA1(\u03be)q1 = 0 by Lemma 4.1.1(1). Similarly, in Case (ii), hA2(\u03be)q2 = 0. In both cases we have hA1(\u03be)q1 \u2297 hA2(\u03be)q2 = 0.\nCase (b): For every i \u2208 [k] there exist exactly one pi1 \u2208 Q1 and exactly one p i 2 \u2208 Q2 such that hA1(\u03bei)pi1 6= 0 and hA2(\u03bei)pi2 6= 0. (The states p i j are unique by Lemma 4.2.1(1).) Then, together with (10.9), we have\nhA(\u03be)q = (\u2297\ni\u2208[k]\nhA1(\u03bei)p1i\n) \u2297 (\u03b41)k(p 1 1 \u00b7 \u00b7 \u00b7 p 1 k, \u03c3, q 1) \u2297 (\u2297\ni\u2208[k]\nhA2(\u03bei)p2i\n) \u2297 (\u03b42)k(p 2 1 \u00b7 \u00b7 \u00b7 p 2 k, \u03c3, q 2)\n= hA1(\u03be)q1 \u2297 hA2(\u03be)q2 .\nThis proves (10.8).\nNow let \u03be \u2208 T\u03a3. We can prove [[A]](\u03be) = [[A1]](\u03be)\u2297 [[A2]](\u03be) by case analysis.\nCase (a): Let (i) hA1(\u03be)q1 = 0 for every q1 \u2208 Q1 or (ii) hA2(\u03be)q2 = 0 for every q2 \u2208 Q2. Then [[A1]](\u03be) = [[A2]](\u03be) = 0. By (10.8) we have that hA(\u03be)(q1,q2) = hA1(\u03be)q1 \u2297 hA2(\u03be)q2 = 0 for every (q1, q2) \u2208 Q, and hence [[A]](\u03be) = 0.\nCase (b): There exist exactly one p1 \u2208 Q1 and exactly one p2 \u2208 Q2 such that hA1(\u03bei)p1 6= 0 and hA2(\u03bei)p2 6= 0. Then, by (10.8), we have that hA(\u03be)(q1,q2) = 0 for each (q1, q2) \u2208 Q \\ {(p1, p2)}. Then\n[[A]](\u03be) = hA(\u03be)(p1,p2) \u2297 F(p1,p2)\n= (hA1(\u03be)p1 \u2297 hA2(\u03be)p2 )\u2297 ((F1)p1 \u2297 (F2)p2) (by Equation (10.8) and construction of F ) = (hA1(\u03be)p1 \u2297 (F1)p1)\u2297 (hA1(\u03be)p1 \u2297 (F2)p2) (by commutativity of B) = [[A1]](\u03be)\u2297 [[A2]](\u03be) .\nProof of (3): Now let A1 and A2 be crisp deterministic. Then also A is crisp deterministic. Let \u03be \u2208 T\u03a3. By Lemma 4.3.1 there exist states p1 \u2208 Q1 and p2 \u2208 Q2 such that hA1(\u03be)p1 = 1 = hA2(\u03be)p2 and for every (q1, q2) \u2208 Q \\ {(p1, p2)} we have hA1(\u03be)q1 = 0 = hA2(\u03be)q2 . Then we can prove (10.8) and [[A]](\u03be) = [[A1]](\u03be)\u2297 [[A2]](\u03be2) as in the proof of Statement (2) but without the use of commutativity.\nWe note that in [Gho22, Thm. 4.2(2)] closure of Recinit(\u03a3,B) under Hadamard product was proved for the particular case that B is a \u03c3-complete distributive orthomodular lattice. Since each \u03c3-complete\n192 CHAPTER 10. CLOSURE PROPERTIES\ndistributive orthomodular lattice is a particular commutative semiring, [Gho22, Thm. 4.2(2)] follows from Theorem 10.4.1 and from [Bor04, Cor. 3.9].\nCorollary 10.4.2. RecStep(\u03a3,B) is closed under Hadamard product.\nProof. By Theorem 10.3.1 (A)\u21d4(B), RecStep(\u03a3,B) is equal to the set of (\u03a3,B)-weighted tree languages recognizable by crisp deterministic wta. By Theorem 10.4.1(3) the latter is closed under Hadamard product.\nThe next theorem can be compared to [DGMM11, Thm. 5.12.1(b)].\nTheorem 10.4.3. Let \u03a3 be a ranked alphabet, B = (B,\u2295,\u2297, 0, 1) a strong bimonoid, A a (\u03a3,B)-wta, and B a crisp deterministic (\u03a3,B)-wta. Moreover, let D be a \u03a3-fta. Then the following three statements hold. (1) If B is right-distributive, then we can construct a (\u03a3,B)-wta C such that [[C]]run = [[A]]run \u2297 [[B]]. (2) We can construct a (\u03a3,B)-wta C such that [[C]]run = [[A]]run \u2297 \u03c7(L(D)). (3) We can construct a (\u03a3,B)-wta C such that [[C]]run = \u03c7(L(D)) \u2297 [[A]]run. (4) [Dro22] If B is left-distributive, then we can construct a (\u03a3,B)-wta C such that [[C]]run = [[B]]\u2297[[A]]run. In Statements (1), (2), and (3), if A is bu deterministic (or crisp deterministic), then so is C.\nProof. Proof of (1): Let B be right-distributive. Moreover, let A = (Q1, \u03b41, F1) and B = (Q2, \u03b42, F2). We construct the (\u03a3,B)-wta C = (Q, \u03b4, F ) in the same way as in the proof of Theorem 10.4.1:\n\u2022 Q = Q1 \u00d7Q2; for each q \u2208 Q we denote its first and second component by q1 and q2, respectively, \u2022 for every k \u2208 N, \u03c3 \u2208 \u03a3(k), q \u2208 Q, and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Qk we define\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = (\u03b41)k(q 1 1 \u00b7 \u00b7 \u00b7 q 1 k, \u03c3, q 1)\u2297 (\u03b42)k(q 2 1 \u00b7 \u00b7 \u00b7 q 2 k, \u03c3, q 2)\n\u2022 for each q \u2208 Q we define Fq = (F1)q1 \u2297 (F2)q2 .\nObviously, if A is bu deterministic (or crisp deterministic), then so is C.\nLet \u03be \u2208 T\u03a3. By Lemma 4.3.1 there exits p \u2208 Q2 and a \u03c1 \u2208 RB(p, \u03be) such that (a) wtB(\u03be, \u03c1) = 1 and (b) for each \u03ba \u2208 RB(\u03be) \\ {\u03c1} we have wtB(\u03be, \u03ba) = 0. Since (a) and (b) determine p and \u03c1 uniquely, we will denote them by p\u03be and \u03c1\u03be, respectively. Then p\u03be = \u03c1\u03be(\u03b5), hence we obtain\n[[B]](\u03be) = ( \u2295\n\u03ba\u2208RB(\u03be)\nwtB(\u03be, \u03ba)\u2297 (F2)\u03ba(\u03b5) ) = wtB(\u03be, \u03c1\u03be)\u2297 (F2)\u03c1\u03be(\u03b5) = (F2)p\u03be . (10.10)\nThen we define the mapping \u03c8 : RA(\u03be)\u2192 RC(\u03be) for every \u03c1 \u2208 RA(\u03be) and w \u2208 pos(\u03be) by\n\u03c8(\u03c1)(w) = (\u03c1(w), p\u03be|w )\n(cf. Figure 10.1). Obviously, \u03c8 is injective. Moreover, we define the mapping \u03c8\u2032 : RA(\u03be) \u2192 im(\u03c8) such that \u03c8\u2032(\u03c1) = \u03c8(\u03c1) for each \u03c1 \u2208 RA(\u03be). It follows that \u03c8 \u2032 is bijective.\nThe following statement is easy to see.\nFor every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RC(\u03be): wtC(\u03be, \u03c1) =\n{ wtA(\u03be, (\u03c8 \u2032)\u22121(\u03c1)) if \u03c1 \u2208 im(\u03c8\u2032)\n0 otherwise (10.11)\nThen, for each \u03be \u2208 T\u03a3, we can compute as follows.\n[[C]]run(\u03be) = \u2295\n\u03c1\u2208RC(\u03be)\nwtC(\u03be, \u03c1)\u2297 F\u03c1(\u03b5)\n10.4. CLOSURE UNDER HADAMARD PRODUCT 193\n= \u2295\n\u03c1\u2208im(\u03c8\u2032)\nwtA(\u03be, (\u03c8 \u2032)\u22121(\u03c1))\u2297 F\u03c1(\u03b5) (by (10.11))\n= \u2295\n\u03c1\u2208im(\u03c8\u2032)\nwtA(\u03be, (\u03c8 \u2032)\u22121(\u03c1))\u2297 (F1)\u03c1(\u03b5)1 \u2297 (F2)\u03c1(\u03b5)2 (by the construction of F )\n= \u2295\n\u03c1\u2208im(\u03c8\u2032)\nwtA(\u03be, (\u03c8 \u2032)\u22121(\u03c1))\u2297 (F1)\u03c1(\u03b5)1 \u2297 (F2)p\u03be (because \u03c1(\u03b5) 2 = p\u03be by the definition of \u03c8)\n= \u2295\n\u03c1\u2032\u2208RA(\u03be)\nwtA(\u03be, (\u03c8 \u2032)\u22121(\u03c8\u2032(\u03c1\u2032)))\u2297 (F1)\u03c8\u2032(\u03c1\u2032)(\u03b5)1 \u2297 (F2)p\u03be (because \u03c8 \u2032 is bijective)\n= \u2295\n\u03c1\u2032\u2208RA(\u03be)\nwtA(\u03be, \u03c1 \u2032)\u2297 (F1)\u03c1\u2032(\u03b5) \u2297 (F2)p\u03be (because \u03c8 \u2032(\u03c1\u2032)(\u03b5)1 = \u03c1\u2032(\u03b5))\n=(\u2217) ( \u2295\n\u03c1\u2032\u2208RA(\u03be)\nwtA(\u03be, \u03c1 \u2032)\u2297 (F1)\u03c1\u2032(\u03b5) ) \u2297 (F2)p\u03be (by right-distributivity)\n= [[A]]run(\u03be)\u2297 [[B]](\u03be) . (by (10.10))\nThe (\u2217) at the last but one equality will be used and explained in the proof of (2).\nProof of (2): By Theorem 4.3.6 we can construct a crisp deterministic (\u03a3,B)-wta B = (Q2, \u03b42, F2) with identity root weights (i.e., im(F2) \u2286 {0, 1}) such that [[B]] = \u03c7(L(D)). We construct the (\u03a3,B)-wta C and define the mappings \u03c8 and \u03c8\u2032 as in the proof of Statement (1). Obviously, (10.11) also holds. Then we can prove that [[C]]run = [[A]]run\u2297\u03c7(L(D)) in the same way as we have proved [[C]]run = [[A]]run\u2297 [[B]] in Statement (1) except that the equality (\u2217) is justified because (F2)p\u03be \u2208 {0, 1}. Thus no right-distributivity of B is used.\nProof of (3): As in the proof of (2), by Theorem 4.3.6 we can construct a crisp deterministic (\u03a3,B)-wta B = (Q2, \u03b42, F2) with identity root weights (i.e., im(F2) \u2286 {0, 1}) such that [[B]] = \u03c7(L(D)). Then, in the same way as in the proof of Statement (1), we construct the (\u03a3,B)-wta C. We mention that we do not have to reverse the order of (\u03b41)k and (\u03b42)k in the right-hand side of the definition of \u03b4k, because im((\u03b42)k) \u2208 {0, 1} and thus\n(\u03b42)k(q 2 1 \u00b7 \u00b7 \u00b7 q 2 k, \u03c3, q 2)\u2297 (\u03b41)k(q 1 1 \u00b7 \u00b7 \u00b7 q 1 k, \u03c3, q 1) = (\u03b41)k(q 1 1 \u00b7 \u00b7 \u00b7 q 1 k, \u03c3, q 1)\u2297 (\u03b42)k(q 2 1 \u00b7 \u00b7 \u00b7 q 2 k, \u03c3, q 2) .\nNext we define the mappings \u03d5 and \u03c8 in the same way as in the proof of (1), and of course, Equality (10.11) holds also in this case. Due to the first six steps in the final calulation of the proof of (1), we obtain:\n[[C]]run(\u03be) = \u2295\n\u03c1\u2032\u2208RA(\u03be)\nwtA(\u03be, \u03c1 \u2032)\u2297 (F1)\u03c1\u2032(\u03b5) \u2297 (F2)p\u03be .\n194 CHAPTER 10. CLOSURE PROPERTIES\nThen we finish the proof as follows:\n\u2295\n\u03c1\u2032\u2208RA(\u03be)\nwtA(\u03be, \u03c1 \u2032)\u2297 (F1)\u03c1\u2032(\u03b5) \u2297 (F2)p\u03be\n= \u2295\n\u03c1\u2032\u2208RA(\u03be)\n(F2)p\u03be \u2297 wtA(\u03be, \u03c1 \u2032)\u2297 (F1)\u03c1\u2032(\u03b5) (because (F2)p\u03be \u2208 {0, 1})\n= (F2)p\u03be \u2297 \u2295\n\u03c1\u2032\u2208RA(\u03be)\nwtA(\u03be, \u03c1 \u2032)\u2297 (F1)\u03c1\u2032(\u03b5) (because (F2)p\u03be \u2208 {0, 1})\n= [[B]](\u03be)\u2297 [[A]]run(\u03be) . (by (10.10))\nThus no commutativity and no left-distributivity of B is used.\nProof of (4): Let B be left-distributive. By Theorem 10.3.1(A)\u21d2(D), we can construct n \u2208 N+, b1, . . . , bn \u2208 B, and \u03a3-fta A1, . . . , An such that [[B]] = \u2295 i\u2208[n] bi \u2297 \u03c7(L(Ai)) and the step languages L(Ai) are pairwise disjoint. Due to the disjointness of the step languages and by associativity of \u2297, we have\n(\u2295\ni\u2208[n]\nbi \u2297 \u03c7(L(Ai)) ) \u2297 [[A]]run = \u2295\ni\u2208[n]\nbi \u2297 ( \u03c7(L(Ai))\u2297 [[A]] run ) .\nBy Theorem 10.4.3(3), we can construct a (\u03a3,B)-wta Bi such that [[Bi]] run = \u03c7(L(Ai))\u2297 [[A]] run. Hence\n\u2295\ni\u2208[n]\nbi \u2297 ( \u03c7(L(Ai))\u2297 [[A]] run ) = \u2295\ni\u2208[n]\nbi \u2297 [[Bi]] run .\nSince B is left-distributive, by Theorem 10.2.1(1) we can construct, for each i \u2208 [n], a (\u03a3,B)-wta Ci such that [[Ci]]run = bi \u2297 [[Bi]]run. Hence\n\u2295\ni\u2208[n]\nbi \u2297 [[Bi]] run =\n\u2295\ni\u2208[n]\n[[Ci]] run .\nBy Theorem 10.1.1 we can construct a (\u03a3,B)-wta C such that [[C]]run = \u2295\ni\u2208[n][[Ci]] run.\nThe next corollary shows that recognizable step mappings are closed under Hadamard product if the weight structure is a semiring. This result is a special instance of Theorem 10.4.3 (the proof of which uses Theorem 10.3.1). Nevertheless, here we show a proof of the weaker result without referring to Theorem 10.3.1; its proof exploits the special structure of recognizable step mappings. The reader may view this proof as an exercise.\nCorollary 10.4.4. (cf. [DGMM11, Thm. 5.12] and [Her20a, Lm. 1.4.22]) Let \u03a3 be a ranked alphabet and B = (B,\u2295,\u2297, 0, 1) be a semiring. Moreover, let r : T\u03a3 \u2192 B and r\n\u2032 : T\u03a3 \u2192 B be recognizable (\u03a3,B)-weighted tree languages. If r or r\u2032 is a recognizable step mapping, then r\u2297 r\u2032 is (\u03a3,B)-recognizable.\nProof. First we assume that r is a recognizable step mapping. Hence, there exist n \u2208 N+, b1, . . . , bn \u2208 B, and recognizable \u03a3-tree languages L1, . . . , Ln such that r = \u2295 i\u2208[n] bi\u2297\u03c7(Li). Then, for each \u03be \u2208 T\u03a3, we can calculate as follows.\n(r \u2297 r\u2032)(\u03be) = (\u2295\ni\u2208[n]\nbi \u2297 \u03c7(Li)(\u03be) ) \u2297 r\u2032(\u03be)\n= \u2295\ni\u2208[n]\nbi \u2297 \u03c7(Li)(\u03be)\u2297 r \u2032(\u03be) (by right-distributivity)\n= (\u2295\ni\u2208[n]\nbi \u2297 ( \u03c7(Li)\u2297 r\n\u2032 ))\n(\u03be) .\n10.5. CLOSURE UNDER TOP-CONCATENATIONS 195\nBy Theorem 10.4.3(3), the weighted tree language \u03c7(Li)\u2297r\u2032 is recognizable. Since B is left-distributive, we can apply Theorem 10.2.1(1a) and obtain that the weighted tree language bi\u2297 ( \u03c7(Li)\u2297r\u2032 ) is recognizable. Finally, by Theorem 10.1.1, the weighted tree language \u2295 i\u2208[n] bi \u2297 ( \u03c7(Li) \u2297 r\u2032 ) is recognizable. Hence r \u2297 r\u2032 is recognizable.\nNow we assume that r\u2032 is a recognizable step mapping. Hence, there are n \u2208 N+, b1, . . . , bn \u2208 B, and recognizable \u03a3-tree languages L1, . . . , Ln such that r \u2032 = \u2295\ni\u2208[n] bi \u2297 \u03c7(Li). Then, for each \u03be \u2208 T\u03a3, we can calculate as follows.\n(r \u2297 r\u2032)(\u03be) = r(\u03be) \u2297 \u2295\ni\u2208[n]\nbi \u2297 \u03c7(Li)(\u03be)\n= \u2295\ni\u2208[n]\nr(\u03be) \u2297 bi \u2297 \u03c7(Li)(\u03be) (by left-distributivity)\n= (\u2295\ni\u2208[n]\n( r \u2297 bi ) \u2297 \u03c7(Li) ) (\u03be) .\nSince B is right-distributive, we can apply Theorem 10.2.1(2) and obtain that the weighted tree language r\u2297 bi is recognizable. By Theorem 10.4.3(2), the weighted tree language ( r\u2297 bi ) \u2297 \u03c7(Li) is recognizable. Finally, by Theorem 10.1.1, the weighted tree language \u2295\ni\u2208[n]\n( r \u2297 bi ) \u2297 \u03c7(Li) is recognizable. Hence\nr \u2297 r\u2032 is recognizable.\nFinally, we show an overview of the closure results for the Hadamard product, cf. Figure 10.2."
        },
        {
            "heading": "10.5 Closure under top-concatenations",
            "text": "Let k \u2208 N, \u03c3 \u2208 \u03a3(k), and r1, . . . , rk be (\u03a3,B)-weighted tree languages. The top-concatenation of r1, . . . , rk with \u03c3 is the (\u03a3,B)-weighted tree language top\u03c3(r1, . . . , rk) : T\u03a3 \u2192 B defined, for each \u03be \u2208 T\u03a3, as follows:\ntop\u03c3(r1, . . . , rk)(\u03be) =\n{ r1(\u03be1)\u2297 \u00b7 \u00b7 \u00b7 \u2297 rk(\u03bek) if \u03be = \u03c3(\u03be1, . . . , \u03bek)\n0 otherwise\nIf \u03b1 \u2208 \u03a3(0), then we call top\u03b1() the top-concatenation with \u03b1. For each \u03be \u2208 T\u03a3, we have\ntop\u03b1()(\u03be) =\n{ 1 if \u03be = \u03b1\n0 otherwise ,\n196 CHAPTER 10. CLOSURE PROPERTIES\ni.e., top\u03b1() = 1.\u03b1. It follows that top\u03c3(r1, . . . , rk)(\u03be) = 0 for each \u03be \u2208 T\u03a3 with \u03be(\u03b5) 6= \u03c3.\nA set L of B-weighted tree languages is closed under top-concatenations if for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and (\u03a3,B)-weighted tree languages r1, . . . , rk in L, the (\u03a3,B)-weighted tree language top\u03c3(r1, . . . , rk) is in L. Thus, in particular, a set L of (\u03a3,B)-weighted tree languages which is closed under top-concatenations contains the (\u03a3,B)-weighted tree language top\u03b1() for each \u03b1 \u2208 \u03a3 (0).\nTheorem 10.5.1. Let B be a semiring. Moreover, let k \u2208 N and \u03c3 \u2208 \u03a3(k). Also, for each i \u2208 [k], let Gi be a (\u03a3,B)-wrtg such that (a) for each i \u2208 [k] the wrtg Gi is finite-derivational or (b) B is \u03c3-complete. We can construct a (\u03a3,B)-wrtg G such that [[G]] = top\u03c3([[G1]], . . . , [[Gk]]).\nThus, in particular, if B is a semiring, then the set Reg(\u03a3,B) is closed under top-concatenations.\nProof. For each i \u2208 [k], let Gi = (Ni, Si, Ri,wti) be a (\u03a3,B)-wrtg such that Ni\u2229Nj = \u2205 for each i, j \u2208 [k] with i 6= j. By Lemma 9.2.1(1), for each i \u2208 [k], we can construct a wrtg which is start-separated and equivalent to Gi. The construction preserves the property finite-derivational. So we can assume that each Gi is start-separated, i.e., Si is a singleton (and then we assume that Si denotes the only initial nonterminal).\nWe let S be a new nonterminal, i.e., S 6\u2208 \u22c3 i\u2208[k]Ni, and construct the (\u03a3,B)-wrtg G = (N,S,R,wt)\nas follows.\n\u2022 N = {S} \u222a \u22c3 i\u2208[k]Ni and \u2022 R is the smallest set R\u2032 of rules which satisfies the following conditions: \u2013 r = (S \u2192 \u03c3(S1, . . . , Sk)) is in R\n\u2032 and wt(r) = 1 and \u2013 for every i \u2208 [k] and r \u2208 Ri, we let r \u2208 R\u2032 and wt(r) = wti(r).\nIn case k = 0 we have N = {S} and R = {r} with r = (S \u2192 \u03c3) and wt(r) = 1.\nIt is obvious that, if for each i \u2208 [k] the wrtg Gi is finite-derivational, then G is finite-derivational. Hence [[G]] is defined.\nNext we prove that\n[[G]](\u03be) = top\u03c3([[G1]], . . . , [[Gk]])(\u03be) for each \u03be \u2208 T\u03a3 . (10.12)\nFor this, we mention some properties which are easy to see.\nFor every \u03be \u2208 T\u03a3 with \u03be(\u03b5) 6= \u03c3 we have RTG(S, \u03be) = \u2205. (10.13)\nFor every \u03be = \u03c3(\u03be1, . . . , \u03bek) in T\u03a3 and d \u2208 RTG(S, \u03be), we have lhs(d(i)) = Si for each i \u2208 [k]. (10.14)\nFor every \u03be \u2208 T\u03a3 and i \u2208 [k], we have RTG(Si, \u03be) = RTGi(Si, \u03be). (10.15)\nFor every \u03be \u2208 T\u03a3, i \u2208 [k], and d \u2208 RTGi(Si, \u03be), we have wtG(d) = wtGi(d). (10.16)\nNow we prove (10.12). Let \u03be \u2208 T\u03a3. Then we have:\n[[G]](\u03be) = \u2295\nd\u2208RTG(\u03be)\nwtG(d) = \u2295\nd\u2208RTG(S,\u03be)\nwtG(\u03be) .\nIf \u03be(\u03b5) 6= \u03c3, then [[G]](\u03be) = 0 by (10.13). Since top\u03c3([[G1]], . . . , [[Gk]])(\u03be) = 0, the equality 10.12 is proved for that case.\nNow we assume that \u03be = \u03c3(\u03be1, . . . , \u03bek). Then we continue with\n\u2295\nd\u2208RTG(S,\u03be)\nwtG(d)\n10.6. CLOSURE UNDER TREE CONCATENATIONS 197\n= \u2295\nd\u2208RTG(S,\u03be): (\u2200i\u2208[k]):lhs(d(i))=Si\nwtG(d) (by (10.14))\n= \u2295\nd\u2208RTG(S,\u03be): (\u2200i\u2208[k]):lhs(d(i))=Si\nwtG(d|1)\u2297 . . .\u2297 wtG(d|k)\u2297 wt(S \u2192 \u03c3(S1, . . . , Sk))\n= \u2295\nd\u2208RTG(S,\u03be): (\u2200i\u2208[k]):lhs(d(i))=Si\nwtG(d|1)\u2297 . . .\u2297 wtG(d|k) (since wt(S \u2192 \u03c3(S1, . . . , Sk)) = 1)\n= \u2295\nd1\u2208RTG(S1,\u03be1)\n. . . \u2295\ndk\u2208RTG(Sk,\u03bek)\nwtG(d1)\u2297 . . .\u2297 wtG(dk)\n= \u2295\nd1\u2208RTG1(S1,\u03be1)\n. . . \u2295\ndk\u2208RTGk (Sk,\u03bek)\nwtG(d1)\u2297 . . .\u2297 wtG(dk) (by (10.15))\n= \u2295\nd1\u2208RTG1(S1,\u03be1)\n. . . \u2295\ndk\u2208RTGk (Sk,\u03bek)\nwtG1(d1)\u2297 . . .\u2297 wtGk(dk) (by (10.16))\n= ( \u2295\nd1\u2208RTG1 (S1,\u03be1)\nwtG1(d1) ) \u2297 . . .\u2297 ( \u2295\ndk\u2208RTGk (Sk,\u03bek)\nwtGk(dk) )\n(by distributivity)\n= [[G1]](\u03be1)\u2297 . . .\u2297 [[Gk]](\u03bek)\n= top\u03c3([[G1]], . . . , [[Gk]])(\u03be) (because \u03be = \u03c3(\u03be1, . . . , \u03bek))\nThis proves (10.12) also in the case that \u03be = \u03c3(\u03be1, . . . , \u03bek).\nCorollary 10.5.2. (cf. [DPV05, Lm. 6.2]) Let \u03a3 be a ranked alphabet and B be a semiring. Moreover, let k \u2208 N and \u03c3 \u2208 \u03a3(k). Also, for each i \u2208 [k], let Ai be a (\u03a3,B)-wta. Then we can construct a (\u03a3,B)-wta A such that [[A]] = top\u03c3([[A1]], . . . , [[Ak]]). Thus, in particular, if B is a semiring, then the set Rec(\u03a3,B) is closed under top-concatenations.\nProof. By Lemma 9.2.6, for each i \u2208 [k], we can construct (\u03a3,B)-wrtg Gi such that Gi is in tree automata form and [[Ai]] = [[Gi]]. Then, in particular, Gi is finite-derivational. By Theorem 10.5.1 we can construct a finite-derivational (\u03a3,B)-wrtg G such that [[G]] = top\u03c3([[G1]], . . . , [[Gk]]). Then, by Lemma 9.2.8, we can construct a (\u03a3,B)-wta A such that [[G]] = [[A]]."
        },
        {
            "heading": "10.6 Closure under tree concatenations",
            "text": "In this section we recall the definition of tree concatenation and show that Rec(\u03a3,B) is closed under tree concatenation. The definition of tree concatenation involves a technical problem which is due to a difference between the concatenation of strings and tree concatenation [TW68, p. 59]. The concatenation of two strings \u03be and \u03b6 is simply the string \u03be\u03b6. This also applies if \u03be and \u03b6 are particular strings, viz. trees. However, \u03be\u03b6 is not a tree. In order to define tree concatenation as operation on trees, in [TW68] a nullary symbol \u03b1 is used and each occurrence of \u03b1 in \u03be is replaced by \u03b6. Hence, tree concatenation consumes the occurrences of \u03b1 in \u03be; in contrast, string concatenation does not consume symbols.\nLet r1 and r2 be (\u03a3,B)-weighted tree languages and \u03b1 \u2208 \u03a3(0). We will recall the definition of the \u03b1-concatenation of r1 and r2, denoted by r1 \u25e6\u03b1 r2. This is a (\u03a3,B)-weighted tree language and hence, for each \u03be \u2208 T\u03a3, the value (r1 \u25e6\u03b1 r2)(\u03be) has to be defined. Thus, intuitively, \u03be has to be decomposed and the resulting parts of \u03be have to be evaluated appropriately in r1 or r2. As preparation for this, we define the concept of \u03b1-cut which helps to identify the mentioned parts of \u03be.\n198 CHAPTER 10. CLOSURE PROPERTIES\nLet \u03b1 \u2208 \u03a3(0) and \u03be \u2208 T\u03a3. Intuitively, an \u03b1-cut through \u03be is a sequence (w1, . . . , wn) of pairwise different positions of \u03be such that neither wi is a prefix of wj nor vice versa (for each index pair i, j with i 6= j); moreover, each \u03b1-labeled position is covered by some wi (see Figure 10.3). Formally, we define the set of \u03b1-cuts through \u03be, denoted by cut\u03b1(\u03be), to be the set\ncut\u03b1(\u03be) = { (w1, . . . , wn) | n \u2208 N, w1, . . . , wn \u2208 pos(\u03be), such that\nw1 <lex . . . <lex wn and\n(\u2200i, j \u2208 [n]): if i 6= j, then wi 6\u2208 prefix(wj) and\n(\u2200w \u2208 pos\u03b1(\u03be)) (\u2203i \u2208 [n]) : wi is a prefix of w } .\nLet w\u0303 = (w1, . . . , wn) be an element of cut\u03b1(\u03be). Then we will abbreviate \u03be[\u03b1]w1 . . . [\u03b1]wn by \u03be[\u03b1]w\u0303. We point out some properties of cut\u03b1(\u03be).\n\u2022 The set cut\u03b1(\u03be) is finite and nonempty; in particular, (\u03b5) \u2208 cut\u03b1(\u03be) and \u03be[\u03b1](\u03b5) = \u03be[\u03b1]\u03b5 = \u03b1. \u2022 For each w\u0303 = (w1, . . . , wn) in cut\u03b1(\u03be), we have pos\u03b1(\u03be[\u03b1]w\u0303) = {w1, . . . , wn}. \u2022 The following equivalence holds: pos\u03b1(\u03be) = \u2205 if, and only if () \u2208 cut\u03b1(\u03be); moreover, \u03be[\u03b1]() = \u03be. \u2022 cut\u03b1(\u03b1) = {(\u03b5)} and, for each \u03b2 \u2208 \u03a3(0) \\ {\u03b1}, we have cut\u03b1(\u03b2) = {(), (\u03b5)}.\nLet r1 : T\u03a3 \u2192 B and r2 : T\u03a3 \u2192 B be weighted tree languages. Moreover, let \u03b1 \u2208 \u03a3(0). The \u03b1-concatenation of r1 and r2 [DPV05] is the weighted tree language (r1 \u25e6\u03b1 r2) : T\u03a3 \u2192 B defined for every \u03be \u2208 T\u03a3 by\n(r1 \u25e6\u03b1 r2)(\u03be) = \u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\nr1(\u03be[\u03b1](w1,...,wn))\u2297 r2(\u03be|w1)\u2297 . . .\u2297 r2(\u03be|wn)\nSince, for each \u03be \u2208 T\u03a3, the index set cut\u03b1(\u03be) is finite, we do not need the condition that B is \u03c3-complete for the summation. Moreover, we have (r1 \u25e6\u03b1 r2)(\u03b1) = r1(\u03b1) \u2297 r2(\u03b1) and, for each \u03b2 \u2208 \u03a3(0) \\ {\u03b1}, we have (r1 \u25e6\u03b1 r2)(\u03b2) = r1(\u03b2)\u2295 r1(\u03b1)\u2297 r2(\u03b2). The tree concatenation of r1 and r2 is the \u03b1-concatenation of r1 and r2 for some \u03b1 \u2208 \u03a3(0).\nA set L of B-weighted tree languages is closed under tree concatenations if the following holds: for every (\u03a3,B)-weighted tree languages r1 and r2 and for each \u03b1 \u2208 \u03a3 (0), if r1, r2 \u2208 L, then (r1 \u25e6\u03b1 r2) \u2208 L.\nTheorem 10.6.1. (cf. [Eng75b, Thm. 3.35], [GS84, Thm. 2.4.6], and [FV22b, Lm. 6.6]) Let B be a commutative semiring and let \u03b1 \u2208 \u03a3(0). Let G1 and G2 be two (\u03a3,B)-wrtg such that G1 and G2 are finite-derivational or B is \u03c3-complete. Then the following two statements hold.\n(1) There exists a (\u03a3,B)-wrtg G such that [[G]] = [[G1]] \u25e6\u03b1 [[G2]]. (2) If G1 and G2 are finite-derivational, then we can construct a finite-derivational (\u03a3,B)-wrtg G such\nthat [[G]] = [[G1]] \u25e6\u03b1 [[G2]].\nProof. Proof of (1): Let G1 = (N1, S1, R1, wt1) and G2 = (N2, S2, R2, wt2) be two (\u03a3,B)-wrtg with N1 \u2229 N2 = \u2205. By Lemmas 9.2.1(1) and 9.2.2, we can assume that G1 and G2 are start-separated and alphabetic. By Lemma 9.2.1(3) we can furthermore assume that G1 and G2 are chain-free. We call a rule A\u2192 \u03b1 of R1 an \u03b1-rule.\nWe define the (\u03a3,B)-wrtg G = (N,S1, R, wt) such that [[G]] = [[G1]] \u25e6\u03b1 [[G2]] as follows. We let N = N1\u222aN2. Moreover, we let R = R1\u222aR2 where R1 is obtained from R1 by replacing each \u03b1-rule r = (A\u2192 \u03b1) by the rule r\u2032 = (A \u2192 S2), and we define wt(r\u2032) = wt1(r). Each rule r \u2208 R which is not of the form A\u2192 S2 keeps the weight from its original grammar. We call each rule of the form A\u2192 S2 a S2-rule. It is obvious that, if G1 and G2 are finite-derivational, then also G is finite-derivational. Hence [[G]] is defined.\nNow we prove that [[G]] = [[G1]] \u25e6\u03b1 [[G2]] (see Figure 10.4). For this, let \u03be \u2208 T\u03a3 and w\u0303 = (w1, . . . , wn) \u2208 cut\u03b1(\u03be). We define\nRTw\u0303G (\u03be) = { d \u2208 RTG(\u03be) | {w1, . . . , wn} = {u \u2208 pos(d) | d(u) is a S2-rule} } ,\nObviously, if () \u2208 cut\u03b1(\u03be), i.e., pos\u03b1(\u03be) = \u2205, then RT () G (\u03be) = RTG1(\u03be). The tree in the lower part of Figure 10.4 illustrates an element of RT (1,22) G (\u03be), where \u03be = \u03c3 ( \u03b3(\u03b2), \u03b4(\u03b2, \u03b3(\u03b2)) ) . The following is obvious:\n(RTw\u0303G (\u03be) | w\u0303 \u2208 cut\u03b1(\u03be)) is a partitioning of RTG(\u03be) . (10.17)\nWe will show that there exists a bijection\n\u03a6 : RTG1(\u03be[\u03b1]w\u0303)\u00d7 RTG2(\u03be|w1 )\u00d7 . . .\u00d7 RTG2(\u03be|wn)\u2192 RT w\u0303 G (\u03be).\n200 CHAPTER 10. CLOSURE PROPERTIES\nFor this, let d \u2208 RTG1(\u03be[\u03b1]w\u0303), d1 \u2208 RTG2(\u03be|w1), . . . , dn \u2208 RTG2(\u03be|wn). Since G1 is alphabetic and chainfree, we have pos(d) = pos(\u03be[\u03b1]w\u0303) and, moreover,\n{w1, . . . , wn} = {u \u2208 pos(d) | d(u) is an \u03b1-rule} .\nFirst we define a tree d\u2032 \u2208 TR by specifying a tree domain and an R-tree mapping and then using the bijective representation of trees as tree domains (cf. Section 2.9). We define the tree domain\nW = pos(d) \u222a \u22c3\ni\u2208[n]\n{wi1v | v \u2208 pos(di)} (10.18)\nand we define the mapping d\u2032 :W \u2192 \u03a3 for each v \u2208 W by\nd\u2032(v) =    d(v) if (\u2200i \u2208 [n]) : \u00ac(wi \u2264pref v) di(u) if (\u2203i \u2208 [n])(\u2203u \u2208 N+) : v = wi1u\nti if (\u2203i \u2208 [n]) : v = wi ,\n(10.19)\nwhere ti is defined as follows: if d(wi) = (A\u2192 \u03b1), then ti = (A\u2192 S2).\nSince W is a tree domain and d\u2032 is an R-tree mapping, we can view d\u2032 as a tree over R, i.e., d\u2032 \u2208 TR. It is obvious that d\u2032 \u2208 RTw\u0303G (\u03be). Then we define \u03a6 by letting\n\u03a6(d, d1, . . . , dk) = d \u2032. (10.20)\nIt is easy to see that \u03a6 is bijective. To show that it is injective, we assume that (10.20) holds and that also \u03a6(d\u0302, d\u03021, . . . , d\u0302k) = d \u2032 for some d\u0302 \u2208 RTG1(\u03be[\u03b1]w\u0303), d\u03021 \u2208 RTG2(\u03be|w1), . . . , d\u0302n \u2208 RTG2(\u03be|wn). We prove that d = d\u0302 by contradiction. If d 6= d\u0302, then there exists an u \u2208 pos(d)\u2229pos(d\u0302) such that d(u) 6= d\u0302(u). We note that d(u), d\u0302(u) \u2208 R1 and that, by (10.18), also u \u2208 pos(d\u2032). The following four cases are possible:\n- Neither d(u) nor d\u0302(u) is an \u03b1-rule. Then, by (10.19), d\u2032(u) = d(u) and d\u2032(u) = d\u0302(u), which is a contradiction. - d(u) = (A\u2192 \u03b1) and d\u0302(u) is not an \u03b1-rule. Then, by (10.19), d\u2032(u) = (A\u2192 S2). On the other hand,\nd\u2032(u) = d\u0302(u) is a rule in R1, a contradiction.\n- d(u) is not an \u03b1-rule and d\u0302(u) is an \u03b1-rule. By symmetry, this also leads to a contradiction. - d(u) = (A\u2192 \u03b1) and d\u0302(u) = (B \u2192 \u03b1), where A 6= B. Then by (10.19), d\u2032(u) = (A\u2192 S2) and also d\u2032(u) = (B \u2192 S2), which is a contradiction.\nSo we have d = d\u0302. Then, by (10.18) and (10.19), di = d\u0302i which proves that \u03a6 is injective. Also, it is surjective, because for each d\u2032 \u2208 RTw\u0303G (\u03be), the positions w1, . . . , wn determine d \u2208 RTG1(\u03be[\u03b1]w\u0303), d1 \u2208 RTG2(\u03be|w1), . . . , dn \u2208 RTG2(\u03be|wn) such that \u03a6(d, d1, . . . , dk) = d \u2032. Thus \u03a6 is bijective.\nMoreover, if (10.20) holds, then\nwtG(d \u2032) = wtG1(d)\u2297\n\u2297\ni\u2208[n]\nwtG2(di) (10.21)\nbecause B is commutative.\nThen we can compute as follows (keeping in mind that G1, G2, and G are finite-derivational if B is not \u03c3-complete):\n([[G1]] \u25e6\u03b1 [[G2]])(\u03be)\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be)\n[[G1]](\u03be[\u03b1]w\u0303)\u2297 [[G2]](\u03be|w1 )\u2297 . . .\u2297 [[G2]](\u03be|wn)\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be)\n( \u2211\u2295\nd\u2208RTG1 (\u03be[\u03b1]w\u0303)\nwtG1(d) ) \u2297 \u2297\ni\u2208[n]\n( \u2211\u2295\ndi\u2208RTG2 (\u03be|wi )\nwtG2(di) )\n10.7. CLOSURE UNDER KLEENE-STARS 201\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be)\n\u2211\u2295\nd\u2208RTG1 (\u03be[\u03b1]w\u0303), (\u2200i\u2208[n]):di\u2208RTG2 (\u03be|wi )\n( wtG1(d)\u2297 \u2297\ni\u2208[n]\nwtG2(di) )\n(by distributivity)\n= \u2295\nw\u0303\u2208cut\u03b1(\u03be)\n\u2211\u2295\nd\u2032\u2208RTw\u0303G (\u03be)\nwtG(d \u2032) (because \u03a6 is a bijection and by (10.21))\n= \u2211\u2295\nd\u2032\u2208RTG(\u03be)\nwtG(d \u2032) (by (10.17))\n= [[G]](\u03be) .\nThus [[G]] = [[G1]] \u25e6\u03b1 [[G2]].\nProof of (2): Now let G1 and G2 finite-derivational. Then, by Lemma 9.2.1(3), we can even construct equivalent chain-free wrtg. Consequently, the definition of G, as it is given in the proof of (1), is constructive. Finally, as pointed out in the proof of (1), the wrtg G is finite-derivational.\nCorollary 10.6.2. (cf. [DPV05, Lm. 6.5]) Let \u03a3 be a ranked alphabet, B be a commutative semiring, and A1 and A2 be two (\u03a3,B)-wta. Moreover, let \u03b1 \u2208 \u03a3(0). Then we can construct a (\u03a3,B)-wta A such that [[A]] = [[A1]] \u25e6\u03b1 [[A2]]. Thus, in particular, if B is a commutative semiring, then the set Rec(\u03a3,B) is closed under tree concatenations.\nProof. By Lemma 9.2.6 we can construct (\u03a3,B)-wrtg G1 and G2 such that G1 and G2 are in tree automata form and [[A1]] = [[G1]] and [[A2]] = [[G2]]. Then, in particular, G1 and G2 are finite-derivational. By Theorem 10.6.1 we can construct a finite-derivational (\u03a3,B)-wrtg G such that [[G]] = [[G1]] \u25e6\u03b1 [[G2]]. Then, by Lemma 9.2.8, we can construct a (\u03a3,B)-wta A such that [[G]] = [[A]]."
        },
        {
            "heading": "10.7 Closure under Kleene-stars",
            "text": "In this section we recall the definition of Kleene-star and show that Rec(\u03a3,B) is closed under Kleene-stars. We follow the approach developed in [BR82, Eng03, DPV05].\nLet r : T\u03a3 \u2192 B and \u03b1 \u2208 \u03a3(0). We define the family (r\u2113\u03b1 | \u2113 \u2208 N) of weighted tree languages r\u2113\u03b1 : T\u03a3 \u2192 B (called the \u2113-th iteration of r at \u03b1) by induction on N as follows: I.B.: r0\u03b1 = 0\u0303 and I.S.: r\u2113+1\u03b1 = (r \u25e6\u03b1 r \u2113 \u03b1)\u2295 \u03c7({\u03b1}) for each \u2113 \u2208 N. We mention that iteration can also be defined in different ways. For instance, if one generalizes the iteration of tree languages as presented in [Eng75b, p. 38] to the weighted case, then this would read (cf. [DPV05, Def. 3.7]):\nI.B.: rE,0\u03b1 = \u03c7({\u03b1}) and I.S.: rE,\u2113+1\u03b1 = r E,\u2113 \u03b1 \u25e6\u03b1 (r \u2295 \u03c7({\u03b1}) for each \u2113 \u2208 N. Another possibility is to generalize the iteration of tree languages as presented in [TW68, p. 66] to the weighted case; this reads as follows (cf. [DPV05, Def. 3.7]):\nI.B.: rTW,0\u03b1 = \u03c7({\u03b1}) and I.S.: rTW,\u2113+1\u03b1 = (r \u2295 \u03c7({\u03b1}) \u25e6\u03b1 r TW,\u2113 \u03b1 for each \u2113 \u2208 N. For the Boolean semiring, all three definitions are equivalent. This is due to the facts that disjunction is idempotent and that tree concatenation is associative. If B is a commutative semiring, then rE,\u2113\u03b1 = rTW,\u2113\u03b1 for each \u2113 \u2208 N (cf. [DPV05, Lm. 3.8]). If B is a commutative and idempotent semiring, then\n202 CHAPTER 10. CLOSURE PROPERTIES\nr\u2113\u03b1 \u2264 r TW,\u2113 \u03b1 \u2264 r \u2113+1 \u03b1 for each \u2113 \u2208 N, where \u2264 is defined componentwise: for every a, b \u2208 B, we let a \u2264 b if a\u2295 b = b. For a more detailed comparison we refer the reader to [DPV05, Sec. 3].\nWe call r : T\u03a3 \u2192 B \u03b1-proper if r(\u03b1) = 0. For each \u03b1-proper weighted tree language r, the application of the iteration of r to a tree \u03be becomes stable after height(\u03be) + 1 steps.\nLemma 10.7.1. (cf. [DPV05, Lm. 3.10]) Let r : T\u03a3 \u2192 B be \u03b1-proper. For every \u03be \u2208 T\u03a3 and \u2113 \u2208 N, if \u2113 \u2265 height(\u03be) + 1, then r\u2113+1\u03b1 (\u03be) = r \u2113 \u03b1(\u03be). In particular, for every \u2113 \u2208 N+ and \u03b2 \u2208 \u03a3\n(0) \\ {\u03b1}, we have r\u2113\u03b1(\u03b1) = 1 and r \u2113 \u03b1(\u03b2) = r(\u03b2).\nProof. We prove the first statement of the lemma by induction on (T\u03a3,\u227a + \u03a3); the second statement of the lemma is proved in the induction base.\nI.B.: Let \u03be \u2208 \u03a3(0). We distinguish two cases.\nCase (a): Let \u03be = \u03b1. First we prove that r\u2113\u03b1(\u03b1) = 1 for each \u2113 \u2208 N+.\nr\u2113\u03b1(\u03b1) = ( (r \u25e6\u03b1 r \u2113\u22121 \u03b1 )\u2295 \u03c7({\u03b1}) ) (\u03b1) = (r \u25e6\u03b1 r \u2113\u22121 \u03b1 )(\u03b1)\u2295 \u03c7({\u03b1})(\u03b1)\n= r(\u03b1) \u2297 r\u2113\u22121\u03b1 (\u03b1) \u2295 1 = 0\u2297 r \u2113\u22121 \u03b1 (\u03b1)\u2295 1 = 1 ,\nwhere the third equality is due to the facts that cut\u03b1(\u03be) = {(\u03b5)} and \u03c7({\u03b1})(\u03b1) = 1. Since height(\u03be)+1 = 1, this implies that, for each \u2113 \u2265 height(\u03be) + 1, we have r\u2113+1\u03b1 (\u03b1) = r \u2113 \u03b1(\u03b1).\nCase (b): Let \u03be 6= \u03b1. First we prove that r\u2113\u03b1(\u03be) = r(\u03be) for each \u2113 \u2208 N+.\nr\u2113\u03b1(\u03be) = ( (r \u25e6\u03be r \u2113\u22121 \u03b1 )\u2295 \u03c7({\u03b1}) ) (\u03be) = (r \u25e6\u03b1 r \u2113\u22121 \u03b1 )(\u03be) \u2295 \u03c7({\u03b1})(\u03be) = (r \u25e6\u03b1 r \u2113\u22121 \u03b1 )(\u03be)\n= r(\u03be) \u2295 r(\u03b1) \u2297 r\u2113\u22121\u03b1 (\u03be) = r(\u03be) \u2295 0\u2297 r \u2113\u22121 \u03b1 (\u03be) = r(\u03be) ,\nwhere the fourth equality is due to the fact that cut\u03b1(\u03be) = {(), (\u03b5)}. Since height(\u03be) + 1 = 1, this implies that, for each \u2113 \u2265 height(\u03be) + 1, we have r\u2113+1\u03b1 (\u03be) = r \u2113 \u03b1(\u03be).\nI.S.: Now let \u03be = \u03c3(\u03be1, . . . , \u03bek) with k \u2208 N+. Let \u2113 \u2208 N with \u2113 \u2265 height(\u03be) + 1.\nr\u2113+1\u03b1 (\u03be) = (r \u25e6 r \u2113 \u03b1)(\u03be)\u2295 \u03c7({\u03b1})(\u03be) = (r \u25e6 r \u2113 \u03b1)(\u03be) (because \u03be 6= \u03b1)\n= \u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\nr(\u03be[\u03b1](w1,...,wn))\u2297 r \u2113 \u03b1(\u03be|w1)\u2297 . . .\u2297 r \u2113 \u03b1(\u03be|wn)\n= r(\u03be[\u03b1](\u03b5))\u2297 r \u2113 \u03b1(\u03be|\u03b5) \u2295\u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\\{(\u03b5)}\nr(\u03be[\u03b1](w1,...,wn))\u2297 r \u2113 \u03b1(\u03be|w1)\u2297 . . .\u2297 r \u2113 \u03b1(\u03be|wn)\n= r(\u03b1) \u2297 r\u2113\u03b1(\u03be|\u03b5) \u2295\u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\\{(\u03b5)}\nr(\u03be[\u03b1](w1,...,wn))\u2297 r \u2113 \u03b1(\u03be|w1)\u2297 . . .\u2297 r \u2113 \u03b1(\u03be|wn)\n= \u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\\{(\u03b5)}\nr(\u03be[\u03b1](w1,...,wn))\u2297 r \u2113 \u03b1(\u03be|w1)\u2297 . . .\u2297 r \u2113 \u03b1(\u03be|wn) (because r(\u03b1) = 0)\n= \u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\\{(\u03b5)}\nr(\u03be[\u03b1](w1,...,wn))\u2297 r \u2113\u22121 \u03b1 (\u03be|w1)\u2297 . . .\u2297 r \u2113\u22121 \u03b1 (\u03be|wn)\n(because, for each i \u2208 [\u2113], we have |wi| \u2265 1 and hence \u2113\u2212 1 \u2265 height(\u03be|wi) + 1, and then by I.H.)\n= \u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\nr(\u03be[\u03b1](w1,...,wn))\u2297 r \u2113\u22121 \u03b1 (\u03be|w1)\u2297 . . .\u2297 r \u2113\u22121 \u03b1 (\u03be|wn)\n(because r(\u03be[\u03b1](\u03b5))\u2297 r \u2113\u22121 \u03b1 (\u03be|\u03b5) = r(\u03b1) \u2297 r \u2113\u22121 \u03b1 (\u03be|\u03b5) = 0 as above)\n10.7. CLOSURE UNDER KLEENE-STARS 203\n= (r \u25e6\u03b1 r \u2113\u22121 \u03b1 )(\u03be) = (r \u25e6 r \u2113\u22121 \u03b1 )(\u03be)\u2295 \u03c7({\u03b1})(\u03be) = r \u2113 \u03b1(\u03be) .\nLemma 10.7.1 justifies to define the operation Kleene-star as follows. Let r : T\u03a3 \u2192 B be \u03b1-proper. The \u03b1-Kleene star of r, denoted by r\u2217\u03b1, is the weighted tree language r \u2217 \u03b1 : T\u03a3 \u2192 B defined, for every \u03be \u2208 T\u03a3, by r\u2217\u03b1(\u03be) = r height(\u03be)+1 \u03b1 (\u03be) [Eng03] (cf. [DPV05, Def. 3.11]). Thus, in particular, by Lemma 10.7.1, we have\nr\u2217\u03b1(\u03b1) = r 1 \u03b1(\u03b1) = 1. (10.22)\nMoreover, for each \u03b2 \u2208 \u03a3(0) with \u03b2 6= \u03b1, by Lemma 10.7.1, we have\nr\u2217\u03b1(\u03b2) = r 1 \u03b1(\u03b2) = r(\u03b2). (10.23)\nExample 10.7.2. Let \u03a3 = {\u03c3(2), \u03b1(0)}. We consider the (\u03a3,Nat)-weighted tree language r = 1.\u03c3(\u03b1, \u03b1), which is a monomial, and compute r\u2217\u03b1(\u03c3(\u03b1, \u03b1)):\nr\u2217\u03b1(\u03c3(\u03b1, \u03b1)) = r 2 \u03b1(\u03c3(\u03b1, \u03b1)) = (r \u25e6\u03b1 r 1 \u03b1)(\u03c3(\u03b1, \u03b1)) + \u03c7({\u03b1})(\u03c3(\u03b1, \u03b1))\n= (r \u25e6\u03b1 r 1 \u03b1)(\u03c3(\u03b1, \u03b1)) = r(\u03b1) \u00b7 r1\u03b1(\u03c3(\u03b1, \u03b1)) + r(\u03c3(\u03b1, \u03b1)) \u00b7 r 1 \u03b1(\u03b1) \u00b7 r 1 \u03b1(\u03b1) (because cut\u03b1(\u03c3(\u03b1, \u03b1)) = {(\u03b5), (1, 2)}) = r(\u03c3(\u03b1, \u03b1)) \u00b7 r1\u03b1(\u03b1) \u00b7 r 1 \u03b1(\u03b1) (because r(\u03b1) = 0) = 1 \u00b7 r1\u03b1(\u03b1) \u00b7 r 1 \u03b1(\u03b1) = 1 . (by Lemma 10.7.1)\nWe might wish to compare the calculation of r2\u03b1(\u03c3(\u03b1, \u03b1)) with that of r 3 \u03b1(\u03c3(\u03b1, \u03b1)):\nr3\u03b1(\u03c3(\u03b1, \u03b1)) = (r \u25e6\u03b1 r 2 \u03b1)(\u03c3(\u03b1, \u03b1)) + \u03c7({\u03b1})(\u03c3(\u03b1, \u03b1))\n= (r \u25e6\u03b1 r 2 \u03b1)(\u03c3(\u03b1, \u03b1)) = r(\u03b1) \u00b7 r2\u03b1(\u03c3(\u03b1, \u03b1)) + r(\u03c3(\u03b1, \u03b1)) \u00b7 r 2 \u03b1(\u03b1) \u00b7 r 2 \u03b1(\u03b1) (because cut\u03b1(\u03c3(\u03b1, \u03b1)) = {(\u03b5), (1, 2)}) = r(\u03c3(\u03b1, \u03b1)) \u00b7 r2\u03b1(\u03b1) \u00b7 r 2 \u03b1(\u03b1) (because r(\u03b1) = 0) = 1 \u00b7 r2\u03b1(\u03b1) \u00b7 r 2 \u03b1(\u03b1) = 1 . (by Lemma 10.7.1)\nNext we compute r\u2217\u03b1(\u03c3(\u03b1, \u03c3(\u03b1, \u03b1))):\nr\u2217\u03b1(\u03c3(\u03b1, \u03c3(\u03b1, \u03b1))) = r 3 \u03b1(\u03c3(\u03b1, \u03c3(\u03b1, \u03b1)))\n= (r \u25e6\u03b1 r 2 \u03b1)(\u03c3(\u03b1, \u03c3(\u03b1, \u03b1))) + \u03c7({\u03b1})(\u03c3(\u03b1, \u03c3(\u03b1, \u03b1))) = (r \u25e6\u03b1 r 2 \u03b1)(\u03c3(\u03b1, \u03c3(\u03b1, \u03b1))) = r(\u03b1) \u00b7 r2\u03b1(\u03c3(\u03b1, \u03c3(\u03b1, \u03b1)))\n+ r(\u03c3(\u03b1, \u03b1)) \u00b7 r2\u03b1(\u03b1) \u00b7 r 2 \u03b1(\u03c3(\u03b1, \u03b1)) + r(\u03c3(\u03b1, \u03c3(\u03b1, \u03b1))) \u00b7 r2\u03b1(\u03b1) \u00b7 r 2 \u03b1(\u03b1) \u00b7 r 2 \u03b1(\u03b1) (because cut\u03b1(\u03c3(\u03b1, \u03c3(\u03b1, \u03b1))) = {(\u03b5), (1, 2), (1, 21, 22)}) = r(\u03c3(\u03b1, \u03b1)) \u00b7 r2\u03b1(\u03b1) \u00b7 r 2 \u03b1(\u03c3(\u03b1, \u03b1)) (because r(\u03b1) = r(\u03c3(\u03b1, \u03c3(\u03b1, \u03b1))) = 0) = r2\u03b1(\u03b1) \u00b7 r 2 \u03b1(\u03c3(\u03b1, \u03b1)) (because r(\u03c3(\u03b1, \u03b1)) = 1) = r2\u03b1(\u03c3(\u03b1, \u03b1)) . (because r 2 \u03b1(\u03b1) = 1) = 1 (as above)\n204 CHAPTER 10. CLOSURE PROPERTIES\nA set L of B-weighted tree languages is closed under Kleene-stars if the following holds: for each (\u03a3,B)-weighted tree language r and for each \u03b1 \u2208 \u03a3(0) such that r is \u03b1-proper, if r \u2208 L, then r\u2217\u03b1 \u2208 L.\nLemma 10.7.3. [DPV05, Lm. 3.13] Let r : T\u03a3 \u2192 B be \u03b1-proper. Then r\u2217\u03b1 = (r \u25e6\u03b1 r \u2217 \u03b1)\u2295 \u03c7({\u03b1}).\nProof. Let \u03be \u2208 T\u03a3 and let \u2113 = height(\u03be) + 1. Then we can calculate as follows.\nr\u2217\u03b1(\u03be) = r \u2113 \u03b1(\u03be) = r \u2113+1 \u03b1 (\u03be) = (r \u25e6\u03b1 r \u2113 \u03b1)(\u03be) \u2295 \u03c7({\u03b1})(\u03be) ,\nwhere the second equality holds by Lemma 10.7.1. Now we proceed with the subexpression (r \u25e6\u03b1 r \u2113 \u03b1)(\u03be) as follows.\n(r \u25e6\u03b1 r \u2113 \u03b1)(\u03be)\n= \u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\nr(\u03be[\u03b1](w1,...,wn))\u2297 r \u2113 \u03b1(\u03be|w1)\u2297 . . .\u2297 r \u2113 \u03b1(\u03be|wn)\n= \u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\\{(\u03b5)}\nr(\u03be[\u03b1](w1,...,wn))\u2297 r \u2113 \u03b1(\u03be|w1)\u2297 . . .\u2297 r \u2113 \u03b1(\u03be|wn)\n(because r(\u03be[\u03b1](\u03b5))\u2297 r \u2113 \u03b1(\u03be|\u03b5) = r(\u03b1) \u2297 r \u2113 \u03b1(\u03be|\u03b5) = 0)\n= \u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\\{(\u03b5)}\nr(\u03be[\u03b1](w1,...,wn))\u2297 r height(\u03be|w1)+1 \u03b1 (\u03be|w1)\u2297 . . .\u2297 r height(\u03be|wn )+1 \u03b1 (\u03be|wn)\n(because, for each i \u2208 [n], we have |wi| \u2265 1 and hence \u2113 \u2265 height(\u03be|wi) + 1,)\n( and then by Lemma 10.7.1.)\n= \u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\\{(\u03b5)}\nr(\u03be[\u03b1](w1,...,wn))\u2297 r \u2217 \u03b1(\u03be|w1)\u2297 . . .\u2297 r \u2217 \u03b1(\u03be|wn) (by definition of \u03b1-Kleene-star)\n= \u2295\n(w1,...,wn)\u2208cut\u03b1(\u03be)\nr(\u03be[\u03b1](w1,...,wn))\u2297 r \u2217 \u03b1(\u03be|w1)\u2297 . . .\u2297 r \u2217 \u03b1(\u03be|wn) (as above)\n= (r \u25e6\u03b1 r \u2217 \u03b1)(\u03be) .\nHence r\u2217\u03b1(\u03be) = (r \u25e6\u03b1 r \u2113 \u03b1)(\u03be) \u2295 \u03c7({\u03b1})(\u03be) = (r \u25e6\u03b1 r \u2217 \u03b1)(\u03be)\u2295 \u03c7({\u03b1})(\u03be), which proves the lemma.\nIn the next theorem we prove that, under certain conditions, the \u03b1-Kleene star of a regular (\u03a3,B)weighted tree language is regular. For the Boolean semiring this was proved in [TW68, Lm. 12] (also cf. [Eng75b, Thm. 3.41] and [GS84, Thm. 2.4.8]) and for wta this was proved in [DPV05, Lm. 6.7]. We follow the construction in [FV22b, Lm. 6.7] (for the trivial storage type) and close a gap in the given correctness proof.\nTheorem 10.7.4. Let B be a commutative semiring and let \u03b1 \u2208 \u03a3(0). Let G be a (\u03a3,B)-wrtg such that (a) [[G]] is \u03b1-proper and (b) G is finite-derivational or B is \u03c3-complete. Then the following two statements hold.\n(1) There exists a (\u03a3,B)-wrtg G\u2032 such that [[G\u2032]] = [[G]]\u2217\u03b1. (2) If G is finite-derivational, then we can construct a finite-derivational (\u03a3,B)-wrtg G\u2032 such that [[G\u2032]] =\n[[G]]\u2217\u03b1.\nProof. Proof of (1): Let G = (N,S,R,wt) be a (\u03a3,B)-wrtg and \u03b1 \u2208 \u03a3(0) such that [[G]] is \u03b1-proper. By Lemmas 9.2.1(1) and 9.2.2, we can assume that G is start-separated and alphabetic. By Lemma 9.2.1(3) we can furthermore assume that G is chain-free. Clearly, each mentioned construction preserves \u03b1-properness. We call a rule of the form A\u2192 \u03b1 in R an \u03b1-rule.\n10.7. CLOSURE UNDER KLEENE-STARS 205\nSince G is chain-free, for each \u03b2 \u2208 \u03a3(0), we have RTG(\u03b2) \u2286 {S \u2192 \u03b2}, i.e., if RTG(\u03b2) 6= \u2205, then d = (S \u2192 \u03b2) is the only rule tree such that \u03c0(d) = \u03b2. Hence, if (S \u2192 \u03b1) is in R, then\nwt(S \u2192 \u03b1) = wtG(S \u2192 \u03b1) = \u2211\u2295\nd\u2208RTG(\u03b1)\nwtG(d) = [[G]](\u03b1) = 0 ,\nwhere the last equality holds because G is \u03b1-proper. Thus, [[G]] = [[G\u0303]] where G\u0303 is the (\u03a3,B)-wrtg\n(N,S, R\u0303, w\u0303t) with R\u0303 = R \\ {S \u2192 \u03b1} and w\u0303t = wt| R\u0303 . Hence we can assume that G does not contain the rule S \u2192 \u03b1. Due to our assumptions on G, for every \u03be \u2208 T\u03a3 and d \u2208 RTG(\u03be), we have pos(d) = pos(\u03be).\nWe define the (\u03a3,B)-wrtg G\u2032 = (N \u2032, {S, S0}, R\u2032, wt\u2032), where S0 6\u2208 N is a new nonterminal, N \u2032 = N \u222a {S0}, and R\u2032 = R \u222aR\u03b1 \u222aRinit, where\n\u2022 For each rule r \u2208 R we let wt\u2032(r) = wt(r). \u2022 R\u03b1: If r = (A\u2192 \u03b1) is in R, then r\u2032 = (A\u2192 S) is in R\u03b1 with wt\u2032(r\u2032) = wt(r). \u2022 Rinit: This set contains the rule S0 \u2192 \u03b1 with wt\u2032(S0 \u2192 \u03b1) = 1.\nWe call each rule of the form A\u2192 S an S-rule.\nFor each \u03be \u2208 T\u03a3, we have\nRTG\u2032(\u03be) =\n{ {S0 \u2192 \u03b1} if \u03be = \u03b1\nRTG\u2032(S, \u03be) otherwise. (10.24)\nMoreover, since G does not contain chain rules and the rule S \u2192 \u03b1, it is easy to see that RTG\u2032(S, \u03b2) = RTG(\u03b2).\nLet \u03be \u2208 T\u03a3 and w\u0303 = (w1, . . . , wn) \u2208 cut\u03b1(\u03be). We define\nRTw\u0303G\u2032(S, \u03be) = {d \u2032 \u2208 RTG\u2032(S, \u03be) |(\u2200i \u2208 [n]) : wi \u2208 pos(d \u2032) \u2227 ( d\u2032(wi) is an \u03b1-rule or a S-rule )\n\u2227 ( (\u2200v \u2208 prefix(wi) \\ {wi}) : d \u2032(v) is not a S-rule ) } .\nWe have that (RTw\u0303G\u2032(S, \u03be) | w\u0303 \u2208 cut\u03b1(\u03be)) is a partitioning of RTG\u2032(S, \u03be) . (10.25)\nIn particular, we have RTG\u2032(S, \u03b1) = RT (\u03b5) G\u2032 (S, \u03b1) = \u2205.\nLet {j1, . . . , j\u2113} be the set of all i \u2208 [n] such that \u03be(wi) 6= \u03b1. We denote the set {j1, . . . , j\u2113} by iter(w\u0303).\nWe define the mapping\n\u03a6w\u0303 : RTG(\u03be[\u03b1]w\u0303)\u00d7 RTG\u2032(S, \u03be|wj1 )\u00d7 . . .\u00d7 RTG\u2032(S, \u03be|wj\u2113 )\u2192 RT w\u0303 G\u2032(S, \u03be)\nas follows. Let d \u2208 RTG(\u03be[\u03b1]w\u0303) and d1 \u2208 RTG\u2032(S, \u03be|wj1 ), . . . , d\u2113 \u2208 RTG\u2032(S, \u03be|wj\u2113 ). We define the tree\nd\u2032 = d[(B1 \u2192 S)(d1)]wj1 \u00b7 \u00b7 \u00b7 [(B\u2113 \u2192 S)(d\u2113)]wj\u2113 ,\nwhere, for each i \u2208 [\u2113], Bi is the nonterminal on the left-hand side of the \u03b1-rule d(wji ). (Since pos(\u03be[\u03b1]w\u0303) = pos(d) and \u03be[\u03b1]w\u0303(wji ) = \u03b1, the rule d(wji ) is an \u03b1-rule.) It is obvious that yd \u2032 \u2208 RTw\u0303G\u2032(S, \u03be). Now we define \u03a6w\u0303(d, d1, . . . , d\u2113) = d \u2032.\nAlso it is easy to see that \u03a6w\u0303 is a bijection. Moreover,\nwtG\u2032(\u03a6w\u0303(d, d1, . . . , d\u2113)) = wtG(d) \u2297 \u2297\ni\u2208[\u2113]\nwtG\u2032(di) (10.26)\nby the definitions of R\u2032 and wtG\u2032 and by the fact that B is commutative.\nBy induction on (T\u03a3,\u227a + \u03a3), we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3, we have: [[G \u2032]](\u03be) = [[G]]\u2217\u03b1(\u03be) . (10.27)\n206 CHAPTER 10. CLOSURE PROPERTIES\n(We recall that G is finite-derivational or B is \u03c3-complete).\nI.B.: Let \u03be \u2208 \u03a3(0). If \u03be 6= \u03b1, then\n[[G\u2032]](\u03be) = \u2211\u2295\nd\u2032\u2208RTG\u2032 (\u03be)\nwtG\u2032(d \u2032) =\n\u2211\u2295\nd\u2032\u2208RTG\u2032 (S,\u03be)\nwtG\u2032(d \u2032) =\n\u2211\u2295\nd\u2208RTG(\u03be)\nwtG(d) = [[G]](\u03be) = [[G]] \u2217 \u03b1(\u03be) ,\nwhere the last equality holds by (10.23).\nNow let \u03be = \u03b1. Then we can calculate as follows:\n[[G\u2032]](\u03b1) = wtG\u2032((S0 \u2192 \u03b1)) = 1 = [[G]] \u2217 \u03b1(\u03b1) ,\nwhere the first equality holds by (10.24) and the last equality holds by (10.22).\nI.S.: Let \u03be \u2208 (T\u03a3 \\ \u03a3(0)). We can calculate as follows.\n[[G\u2032]](\u03be) = \u2211\u2295\nd\u2032\u2208RTG\u2032 (\u03be)\nwtG\u2032(d \u2032)\n= \u2211\u2295\nd\u2032\u2208RTG\u2032 (S,\u03be)\nwtG\u2032(d \u2032) (by (10.24) because \u03be 6= \u03b1)\n= \u2295\nw\u0303\u2208cut\u03b1(\u03be)\n\u2211\u2295\nd\u2032\u2208RTw\u0303 G\u2032 (S,\u03be)\nwtG\u2032(d \u2032) (by (10.25))\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be)\n\u2211\u2295\nd\u2208RTG(\u03be[\u03b1]w\u0303), (\u2200i\u2208[\u2113]):di\u2208RTG\u2032 (S,\u03be|wji )\n( wtG(d)\u2297 \u2297\ni\u2208[\u2113]\nwtG\u2032(di) )\n(because \u03a6w\u0303 is bijective and by (10.26), where iter(w\u0303) = {j1, . . . , j\u2113})\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be)\n( \u2211\u2295\nd\u2208RTG(\u03be[\u03b1]w\u0303)\nwtG(d) ) \u2297 \u2297\ni\u2208[\u2113]\n( \u2211\u2295\ndi\u2208RTG\u2032 (S,\u03be|wji )\nwtG\u2032(di) )\n(by distributivity)\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be)\n[[G]](\u03be[\u03b1]w\u0303) \u2297 \u2297\ni\u2208[\u2113]\n( \u2211\u2295\ndi\u2208RTG\u2032 (S,\u03be|wji )\nwtG\u2032(di) )\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be)\n[[G]](\u03be[\u03b1]w\u0303) \u2297 \u2297\ni\u2208[\u2113]\n( \u2211\u2295\ndi\u2208RTG\u2032 (\u03be|wji )\nwtG\u2032(di) )\n(by (10.24) because \u03be|wji 6= \u03b1)\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be)\n[[G]](\u03be[\u03b1]w\u0303) \u2297 \u2297\ni\u2208[\u2113]\n[[G\u2032]](\u03be|wji )\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be)\n[[G]](\u03be[\u03b1]w\u0303) \u2297 [[G \u2032]](\u03be|w1)\u2297 . . .\u2297 [[G \u2032]](\u03be|wn)\n(because for each i \u2208 [n] \\ iter(w\u0303) we have \u03be|wi = \u03b1 and [[G \u2032]](\u03b1) = 1)\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be): w\u0303 6=(\u03b5)\n[[G]](\u03be[\u03b1]w\u0303) \u2297 [[G \u2032]](\u03be|w1)\u2297 . . .\u2297 [[G \u2032]](\u03be|wn) (because [[G]](\u03be[\u03b1](\u03b5)) = [[G]](\u03b1) = 0)\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be): w\u0303 6=(\u03b5)\n[[G]](\u03be[\u03b1]w\u0303)\u2297 [[G]] \u2217 \u03b1(\u03be|w1)\u2297 . . .\u2297 [[G]] \u2217 \u03b1(\u03be|wn)\n(by I.H.: since w\u0303 6= (\u03b5), we have \u03be|wi \u227a + \u03a3 \u03be for every i \u2208 [n])\n10.8. CLOSURE UNDER YIELD-INTERSECTION 207\n= \u2295\nw\u0303=(w1,...,wn)\u2208cut\u03b1(\u03be)\n[[G]](\u03be[\u03b1]w\u0303)\u2297 [[G]] \u2217 \u03b1(\u03be|w1)\u2297 . . .\u2297 [[G]] \u2217 \u03b1(\u03be|wn) (because [[G]](\u03b1) = 0)\n= ([[G]] \u25e6\u03b1 [[G]] \u2217 \u03b1)(\u03be) = ([[G]] \u25e6\u03b1 [[G]] \u2217 \u03b1 \u2295 \u03c7({\u03b1}))(\u03be) (because \u03be 6= \u03b1) = [[G]]\u2217\u03b1(\u03be) . (by Lemma 10.7.3)\nThis finishes the proof of (10.27). Thus [[G\u2032]] = [[G]]\u2217\u03b1.\nProof of (2): Let G be finite-derivational. Then, by Lemma 9.2.1(3), we can even construct an equivalent chain-free wrtg. Consequently, the definition of G\u2032, as given in the proof of (1), is constructive. Finally, by analysing the construction of G\u2032, we obtain that G\u2032 is finite-derivational.\nNext we give an example of the concepts which appear in the proof of Theorem 10.7.4.\nExample 10.7.5. Let \u03a3 = {\u03c3(2), \u03b1(0)} and G be the (\u03a3,Nat)-wrtg which has the rules\nS \u2192 \u03c3(S,A) : 2\nS \u2192 \u03b2 : 2\nA\u2192 \u03b1 : 2 ,\nand the weight of each rule is 2 (indicated by \u201c: 2\u201d after the rule). If we apply the construction in the proof of Theorem 10.7.4, then we obtain the (\u03a3,Nat)-wrtg G\u2032 with the rules and weights\nS \u2192 \u03c3(S,A) : 2 S0 \u2192 \u03b1 : 1\nS \u2192 \u03b2 : 2 A\u2192 S : 2\nA\u2192 \u03b1 : 2 .\nNow let us consider the tree \u03be \u2208 T\u03a3, the cut w\u0303 = (12, 2) in cut\u03b1(\u03be), and tree \u03be[\u03b1]w\u0303 in Figure 10.5. By definition, we have iter(w\u0303) = {12}. In the upper part of Figure 10.6, there is an example of a tree d\u2032 \u2208 RTw\u0303G\u2032(S, \u03be). Moreover, for the trees d \u2208 RTG(\u03be[\u03b1]w\u0303) and d1 \u2208 RTG\u2032(S, \u03be|12) in the lower part of Figure 10.6, we have\nd\u2032 = \u03a6w\u0303(d, d1) and wtG\u2032(d \u2032) = wtG(d) \u00b7 wtG\u2032(d1) ,\nwhere wtG\u2032(d \u2032) = 28, wtG(d) = 2 5, and wtG\u2032(d1) = 2 3.\nFinally, as a consequence of Theorem 10.7.4, we show that Rec(\u03a3,B) is closed under Kleene-stars.\nCorollary 10.7.6. (cf. [DPV05, Lm. 6.7]) Let \u03a3 be a ranked alphabet, \u03b1 \u2208 \u03a3(0), and B be a commutative semiring. Let A be a (\u03a3,B)-wta such that [[A]] is \u03b1-proper. Then we can construct a (\u03a3,B)-wta A\u2032 such that [[A\u2032]] = [[A]]\u2217\u03b1. Thus, in particular, if B is a commutative semiring, then the set Rec(\u03a3,B) is closed under Kleene-stars.\nProof. By Lemma 9.2.6 we can construct (\u03a3,B)-wrtg G such that G is in tree automata form and [[A]] = [[G]]. Then, in particular, G is finite-derivational. By Theorem 10.7.4 we can construct a finite-derivational (\u03a3,B)-wrtg G\u2032 such that [[G\u2032]] = [[G]]\u2217\u03b1. Then, by Lemma 9.2.8, we can construct a (\u03a3,B)-wta A\n\u2032 such that [[G\u2032]] = [[A\u2032]]."
        },
        {
            "heading": "10.8 Closure under yield-intersection with weighted recogniz-",
            "text": "able languages\nBar-Hillel, Perles, and Shamir [BPS61, Thm. 8.1] proved that the intersection of any context-free language and any recognizable language is again a context-free language. This theorem is very valuable,\n10.8. CLOSURE UNDER YIELD-INTERSECTION 209\nin particular, in natural language processing, where one wishes to have a finite description of the set of all derivations of a string given a context-free grammar [MS09, MS10]. Here we extend this result by replacing (a) the context-free language by a recognizable weighted tree language r, (b) the recognizable language by an r-recognizable weighted language L, and (c) the intersection by the Hadamard product. Roughly speaking, we prove that the Hadamard product of r and L \u25e6 yield is a recognizable weighted tree language if r and L take their weights in a commutative semiring (cf. Theorem 10.8.2). We refer to [MS09, MS10] for even more extended results.\nA set L of B-weighted tree languages is closed under yield-intersection with weighted recognizable languages if for every (\u03a3,B)-weighted tree language r in L, \u0393 \u2286 \u03a3(0), and r-recognizable (\u0393,B)-weighted language L : \u0393\u2217 \u2192 B, the (\u03a3,B)-weighted tree language r \u2297 (L \u25e6 yield\u0393) is in L.\nSince we have already proved that the set Recrun(\u03a3,B) is closed under Hadamard product if B is a commutative semiring, it remains to prove that L \u25e6 yield\u0393 is a recognizable weighted tree language. Indeed, this even holds for commutative strong bimonoids. Our construction is based on the key idea of the proof of [BPS61, Thm. 8.1], cf. also [MS09, Thm. 2]. (We also refer to Example 3.2.7.)\nLemma 10.8.1. Let B be commutative, \u0393 \u2286 \u03a3(0), and B be a (\u0393,B)-wsa. Then we can construct a (\u03a3,B)-wta A such that [[A]]run = [[B]]run \u25e6 yield\u0393.\nProof. Let B = (P, \u03bb, \u00b5, \u03b3). Intuitively, we construct A such that it guesses, at each \u0393-labeled leaf of a given input \u03a3-tree \u03be, a transition of B and, at each (\u03a3(0) \\\u0393)-labeled leaf of \u03be, a pair (p, p) for some p \u2208 P . Then, while moving up towards the root of \u03be, the wta A checks whether subruns of B can be composed to larger runs of B. The first state and the last state of such a subrun are coded as a pair and forms a state of A.\nFormally, we construct the (\u03a3,B)-wta A = (Q, \u03b4, F ) as follows.\n\u2022 Q = P \u00d7 P , \u2022 we let F(p,p\u2032) = \u03bb(p) \u2297 \u03b3(p\n\u2032) for every (p, p\u2032) \u2208 Q, \u2022 for every \u03b1 \u2208 \u0393 and (p, p\u2032) \u2208 Q we let\n\u03b40(\u03b5, \u03b1, (p, p \u2032)) = \u00b5(p, \u03b1, p\u2032)\nand for every \u03b1 \u2208 \u03a3(0) \\ \u0393 and (p, p\u2032) \u2208 Q we let\n\u03b40(\u03b5, \u03b1, (p, p \u2032)) =\n{ 1 if p = p\u2032\n0 otherwise\nand for every k \u2208 N+, \u03c3 \u2208 \u03a3(k), and (p1, p\u20321), (p2, p \u2032 2), . . . , (pk, p \u2032 k), (p, p \u2032) \u2208 Q we let\n\u03b4k((p1, p \u2032 1) \u00b7 \u00b7 \u00b7 (pk, p \u2032 k), \u03c3, (p, p \u2032)) =\n{ 1 if p = p1, p \u2032 i = pi+1 for each i \u2208 [k \u2212 1], and p \u2032 k = p \u2032\n0 otherwise.\nThis finishes the construction of A.\nNext we prove that [[A]]run = [[B]]run \u25e6 yield\u0393, for which we need some auxiliary tools and statements. Let \u03be \u2208 T\u03a3 and \u03c1 \u2208 P |yield\u0393(\u03be)|+1. Then there exist n \u2208 N and p1, . . . , pn \u2208 P such that \u03c1 = p0 \u00b7 \u00b7 \u00b7 pn. Let\nu0, w1, u1, . . . , un\u22121, wn, un\nbe the list of elements of pos\u03a3(0)(\u03be) ordered by the lexicographic order <lex on pos(\u03be), where pos\u0393(\u03be) = {w1, . . . , wn} and, for each i \u2208 [0, n], the ui is the corresponding list of elements in pos(\u03a3(0)\\\u0393)(\u03be).\nWe define the binary relation \u227a on pos(\u03be) by letting w1 \u227a w2 if there is an i \u2208 N such that w1 = w2i . Obviously, \u227a is well-founded and min\u227a(pos(\u03be)) = pos\u03a3(0)(\u03be), i.e., it is the set of leaves of \u03be.\n210 CHAPTER 10. CLOSURE PROPERTIES\nThen we define the mapping\n\u03d5\u03be,\u03c1 : pos(\u03be)\u2192 Q\nby induction on (pos(\u03be),\u227a) for each w \u2208 pos(\u03be) as follows.\n\u03d5\u03be,\u03c1(w) =    (pi, pi) if w \u2208 ui for some i \u2208 [0, n]\n(pi\u22121, pi) if w = wi for some i \u2208 [n]( \u03d5\u03be,\u03c1(w1)1, \u03d5\u03be,\u03c1(wk)2 ) otherwise,\nwhere w \u2208 ui abbreviates that w is an element in the list ui and k = rk\u03be(w). Moreover, \u03d5\u03be,\u03c1(w1)1 denotes the first component of \u03d5\u03be,\u03c1(w1), and \u03d5\u03be,\u03c1(wk)2 denotes the second component of \u03d5\u03be,\u03c1(wk). In the particular case that n = 0, we have \u03d5\u03be,\u03c1(w) = (p0, p0) for each w \u2208 pos(\u03be). Moreover, \u03d5\u03be,\u03c1(\u03b5) = (p0, pn).\nWe demonstrate the definition of \u03c1 in Figures 10.7, 10.8, and 10.9 where \u03b1i = \u03be(wi) for each i \u2208 [n] and hence yield\u0393(\u03be) = \u03b11 \u00b7 \u00b7 \u00b7\u03b1n.\nIn fact, \u03d5\u03be,\u03c1 is a run of A on \u03be, i.e., \u03d5\u03be,\u03c1 \u2208 RA(\u03be). Thus, if \u03be = \u03c3(\u03be1, . . . , \u03bek), then for each l \u2208 [k], the subrun (\u03d5\u03be,\u03c1)|l is defined and we have\n(\u03d5\u03be,\u03c1)|l = \u03d5\u03bel,\u03c1|(il,jl) , (10.28)\nwhere \u03c1|(il,jl) is the subsequence pil \u00b7 \u00b7 \u00b7 pjl of \u03c1 determined by the indices\nil = max(m \u2208 [n] | wm \u2208 l\u22121\u22c3\n\u03ba=1\npos\u0393(\u03be\u03ba)) and jl = max(m \u2208 [n] | wm \u2208 l\u22c3\n\u03ba=1\npos\u0393(\u03be\u03ba))\n10.8. CLOSURE UNDER YIELD-INTERSECTION 211\nand the definition max(\u2205) = 0. Thus i1 = 0, jl = il+1 for each l \u2208 [k \u2212 1], jk = n, and if pos\u0393(\u03bel) = \u2205, then il = jl. (For instance, let \u03be = \u03c3(\u03be1, \u03be2, \u03be3), pos\u0393(\u03be1) = {w1, w2} with w1 <lex w2, pos\u0393(\u03be2) = \u2205, and pos\u0393(\u03be3) = {w3}, and let \u03c1 = p0p1p2p3. Then (i1, j1) = (0, 2), (i2, j2) = (2, 2), and (i3, j3) = (2, 3) and thus the corresponding subsequences are p0p1p2, p2, and p2p3.)\nThis finishes the preparations.\nNow, by induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and \u03c1 \u2208 P |yield\u0393(\u03be)|+1 we have wt\u2212B (yield\u0393(\u03be), \u03c1) = wtA(\u03be, \u03d5\u03be,\u03c1). (10.29)\nI.B.: Let \u03be \u2208 \u03a3(0). We distinguish two cases.\nCase (a): Let \u03be \u2208 \u03a3(0) \\ \u0393. Now let \u03c1 \u2208 P |yield\u0393(\u03be)|+1. Since |yield\u0393(\u03be)| + 1 = 1, there exists a p \u2208 P such that \u03c1 = p. Then \u03d5\u03be,\u03c1(\u03b5) = (p, p). Moreover, due to the construction of \u03b4, we have\nwtA(\u03be, \u03d5\u03be,\u03c1) = \u03b40(\u03b5, \u03b1, (p, p)) = 1 .\nSince wt\u2212B (\u03b5, p) = 1 by definition, we obtain (10.29).\nCase (b): Let \u03be \u2208 \u0393. Now let \u03c1 \u2208 P |yield\u0393(\u03be)|+1. Since |yield\u0393(\u03be)| + 1 = 2, there exist p, p \u2032 \u2208 P such\nthat \u03c1 = pp\u2032. Then \u03d5\u03be,\u03c1(\u03b5) = (p, p \u2032). Moreover, due to the construction of \u03b4, we have\nwtA(\u03be, \u03d5\u03be,\u03c1) = \u03b40(\u03b5, \u03b1, (p, p \u2032)) = \u00b5(p, \u03b1, p\u2032) .\nSince wt\u2212B (\u03b5, p) = \u00b5(p, \u03b1, p \u2032) by definition, we obtain (10.29).\nI.S.: Let \u03be = \u03c3(\u03be1, . . . , \u03bek) with k \u2208 N+. Then we can calculate as follows:\nwt\u2212B (yield\u0393(\u03be), \u03c1) = \u2297\nl\u2208[k]\nwt\u2212B (yield\u0393(\u03bel), \u03c1|(il,jl))\n= \u2297\nl\u2208[k]\nwtA(\u03bel, \u03c1\u03bel,\u03c1|(il,jl)) (by I.H.)\n= (\u2297\nl\u2208[k]\nwtA(\u03bel, (\u03d5\u03be,\u03c1)|l) ) \u2297 \u03b4k(\u03d5\u03be,\u03c1(1) \u00b7 \u00b7 \u00b7\u03d5\u03be,\u03c1(k), \u03c3, \u03d5\u03be,\u03c1(\u03b5)) (by (10.28) and definition of \u03b4)\n= wtA(\u03be, \u03d5\u03be,\u03c1) .\nThis finishes the proof of (10.29).\nLet \u03be \u2208 T\u03a3 and assume that yield\u0393(\u03be) has length n. For each \u03c1A \u2208 RA(\u03be) \\ {\u03d5\u03be,\u03c1 | \u03c1 \u2208 P n+1} there\nexists a w \u2208 pos(\u03be) such that, assuming that rk\u03a3(\u03be(w)) = k, we have\n\u2022 \u03c1A(w)1 6= \u03c1A(w1)1 or \u03c1A(w)2 6= \u03c1A(wk)2 or \u2022 there exists an i \u2208 [k \u2212 1] such that \u03c1A(wi)2 6= \u03c1A(w(i + 1))1 or\n212 CHAPTER 10. CLOSURE PROPERTIES\n\u2022 k = 0, \u03be(w) 6\u2208 \u0393, and \u03c1A(w)1 6= \u03c1A(w)2.\nIn this case, by definition of \u03b4k, we have \u03b4k(\u03c1A(w1) \u00b7 \u00b7 \u00b7 \u03c1A(wk), \u03be(w), \u03c1A(w)) = 0 and thus wtA(\u03be, \u03c1A) = 0. Thus we have\nwtA(\u03be, \u03c1A) = 0 for each \u03c1A \u2208 RA(\u03be) \\ {\u03d5\u03be,\u03c1 | \u03c1 \u2208 P n+1}. (10.30)\nFor each \u03c1 \u2208 Pn+1 we denote the first state of \u03c1 and the last state of \u03c1 by fst(\u03c1) and lst(\u03c1), respectively. Then:\n[[A]]run(\u03be) = \u2295\n\u03c1A\u2208RA(\u03be)\nwtA(\u03be, \u03c1A)\u2297 F\u03c1A(\u03b5)\n= \u2295\n\u03c1\u2208Pn+1\nwtA(\u03be, \u03d5\u03be,\u03c1)\u2297 F(fst(\u03c1),lst(\u03c1)) (by 10.30 and the fact that \u03d5\u03be,\u03c1(\u03b5) = (fst(\u03c1), lst(\u03c1)))\n= \u2295\n\u03c1\u2208Pn+1\nwt\u2212B (yield\u0393(\u03be), \u03c1)\u2297 F(fst(\u03c1),lst(\u03c1)) (by (10.29))\n= \u2295\n(p,p\u2032)\u2208Q\u2032\n\u2295\n\u03c1\u2208Pn+1: fst(\u03c1)=p,lst(\u03c1)=p\u2032\nwt\u2212B (yield\u0393(\u03be), \u03c1)\u2297 F(p,p\u2032)\n= \u2295\n(p,p\u2032)\u2208Q\u2032\n\u2295\n\u03c1\u2208Pn+1: fst(\u03c1)=p,lst(\u03c1)=p\u2032\nwt\u2212B (yield\u0393(\u03be), \u03c1)\u2297 \u03bb(p)\u2297 \u03b3(p \u2032) (by construction)\n= \u2295\n(p,p\u2032)\u2208Q\u2032\n\u2295\n\u03c1\u2208Pn+1: fst(\u03c1)=p,lst(\u03c1)=p\u2032\nwtB(yield\u0393(\u03be), \u03c1) (by commutativity)\n= [[B]]run(yield\u0393(\u03be)) .\nThe next theorem was proved in [MS09, Thm. 2] via a direct construction. We show a modular proof by exploiting Lemma 10.8.1 and closure under Hadamard product (where the latter requires that B is a commutative semiring).\nTheorem 10.8.2. [MS09, Thm. 2] Let \u03a3 be a ranked alphabet, \u0393 \u2286 \u03a3(0), and B = (B,\u2295,\u2297, 0, 1) be a commutative semiring. For every (\u03a3,B)-wta A and every (\u0393,B)-wsa B, we can construct a (\u03a3,B)-wta A\u2032 such that [[A\u2032]] = [[A]]\u2297 ([[B]] \u25e6 yield\u0393) .\nThus, in particular, the set Rec(\u03a3,B) is closed under yield-intersection.\nProof. By Corollary 5.3.3 and by convention on page 121 we have [[A]] = [[A]]run and [[A\u2032]] = [[A\u2032]]run. Moreover, by Corollary 5.3.4 and by convention on page 122 we have [[B]] = [[B]]run. By Lemma 10.8.1, we can construct a (\u03a3,B)-wta C such that [[C]] = [[B]] \u25e6 yield\u0393. Then, by Theorem 10.4.1(1), we can construct a (\u03a3,B)-wta A\u2032 such that [[A\u2032]] = [[A]] \u2297 [[C]].\nFinally, we verify that Theorem 10.8.2 generalizes the classical result of Bar-Hillel, Perles, and Shamir [BPS61, Thm. 8.1]. We achieve this by proving that the latter is equivalent to Theorem 10.8.2 for the case that B is the Boolean semiring.\nCorollary 10.8.3. Let G be a \u0393-cfg and A be a \u0393-fsa. Then we can construct a \u0393-cfg G\u2032 such that L(G\u2032) = L(G) \u2229 L(A).\nProof. By Corollary 8.3.4, we can construct a ranked alphabet \u03a3 with \u0393 \u2286 \u03a3(0) and a \u03a3-fta A\u2032 such that L(G) = yield\u0393(L(A \u2032)). By Corollary 3.4.2, we can construct a (\u03a3,Boole)-wta A\u2032 such that L(G) =\n10.9. CLOSURE UNDER STRONG BIMONOID HOMOMORPHISMS 213\nyield\u0393(supp([[A \u2032]])). Moreover, by Observation 3.3.4, we can construct a (\u0393,Boole)-wsa A such that L(A) = supp([[A]]run). Then we can calculate as follows.\nL(G) \u2229 L(A) = yield\u0393(supp([[A \u2032]])) \u2229 supp([[A]]run)\n= supp(\u03c7(yield\u0393)([[A \u2032]])) \u2229 supp([[A]]run) (by (2.31)) = supp(\u03c7(yield\u0393)([[A \u2032]]) \u2227 [[A]]run) =(\u2217) supp(\u03c7(yield\u0393)([[A \u2032]] \u2227 ([[A]]run \u25e6 yield\u0393))) ,\nwhere at (\u2217) we have used the following subcalculation for each w \u2208 \u0393\u2217:\n(\u03c7(yield\u0393)([[A \u2032]]) \u2227 [[A]]run)(w) = \u03c7(yield\u0393)([[A \u2032]])(w) \u2227 [[A]]run(w)\n= ( \u2211\u2228\n\u03be\u2208yield\u22121\u0393 (w)\n[[A\u2032]](\u03be) ) \u2227 [[A]]run(w)\n= \u2211\u2228\n\u03be\u2208yield\u22121\u0393 (w)\n( [[A\u2032]](\u03be) \u2227 [[A]]run(w) ) (by distributivity)\n= \u2211\u2228\n\u03be\u2208yield\u22121\u0393 (w)\n( [[A\u2032]](\u03be) \u2227 [[A]]run(yield\u0393(\u03be)) )\n= \u2211\u2228\n\u03be\u2208yield\u22121\u0393 (w)\n( [[A\u2032]] \u2227 [[A]]run \u25e6 yield\u0393 ) (\u03be)\n= \u03c7(yield\u0393)([[A \u2032]] \u2227 [[A]]run \u25e6 yield\u0393)(w) .\nBy Theorem 10.8.2, we can construct a (\u03a3,Boole)-wta B such that [[B]]run = [[A\u2032]] \u2227 ([[A]]run \u25e6 yield\u0393). Hence we can continue with:\nsupp(\u03c7(yield\u0393)([[A \u2032]] \u2227 ([[A]]run \u25e6 yield\u0393))) = supp(\u03c7(yield\u0393)([[B]] run))\n= yield\u0393(supp([[B]] run)) . (by (2.31))\nBy Corollary 3.4.2, we can construct a \u03a3-fta C such that supp([[B]]run) = L(C). Moreover, by Corollary 8.3.4, we can construct a \u0393-cfg G\u2032 such that yield\u0393(L(C)) = L(G \u2032)."
        },
        {
            "heading": "10.9 Closure under strong bimonoid homomorphisms",
            "text": "A set L of weighted tree languages is closed under strong bimonoid homomorphisms if for every (\u03a3,B)weighted tree language r \u2208 L, strong bimonoid C = (C,+,\u00d7, 0, 1), and strong bimonoid homomorphism f : B \u2192 C, the (\u03a3,C)-weighted tree language f \u25e6 r is in L.\nLet A = (Q, \u03b4, F ) be a (\u03a3,B)-wta, C be a strong bimonoid, and f : B \u2192 C be a strong bimonoid homomorphism. Then we define the f -image of A, denoted by f(A), to be the (\u03a3,C)-wta (Q, \u03b4\u2032, F \u2032) by defining (\u03b4\u2032)k = f \u25e6 \u03b4k for each k \u2208 N, and F \u2032 = f \u25e6 F .\nNote that, if A is bu deterministic (or crisp deterministic), then so is f(A). Moreover, if A is total and f\u22121(0) = {0}, then f(A) is total. The condition f\u22121(0) = {0} cannot be dropped, which can be seen as follows. Let A = (Q, \u03b4, F ) be a total (\u03a3,Nat)-wta (where Nat is the semiring of natural numbers) such that there exist k \u2208 N, \u03c3 \u2208 \u03a3(k), w \u2208 Qk, and q \u2208 Q with \u03b4k(w, \u03c3, q) = 4 and for each p \u2208 Q\\{q} we have \u03b4k(w, \u03c3, p) = 0. We consider the ring Intmod4 = ({0, 1, 2, 3},+4, \u00b74, 0, 1) of natural numbers modulo 4. Finally, we consider the canonical semiring homomorphism f : N\u2192 {0, 1, 2, 3}. Since f(0) = f(4) = 0, in f(A) we have (\u03b4\u2032)k(w, \u03c3, p) = 0 for every p \u2208 Q. Hence f(A) is not total.\nThe following observation is obvious but useful.\n214 CHAPTER 10. CLOSURE PROPERTIES\nObservation 10.9.1. Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta, C = (C,+,\u00d7, 0, 1) be a strong bimonoid, and f : B \u2192 C be a strong bimonoid homomorphism such that, for each b \u2208 B, the element f(b) in C can be constructed. Then we can construct the (\u03a3,C)-wta f(A).\nNow we can prove the main result of this section.\nLemma 10.9.2. Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta, (C,+,\u00d7, 0, 1) be a strong bimonoid, and f : B \u2192 C be a strong bimonoid homomorphism. Then f \u25e6 [[A]]init = [[f(A)]]init and f \u25e6 [[A]]run = [[f(A)]]run.\nProof. First we show that f \u25e6 [[A]]init = [[f(A)]]init. For this, we define the mapping f\u0303 : BQ \u2192 CQ for every v \u2208 BQ and q \u2208 Q by f\u0303(v)q = f(vq). We prove that f\u0303 is a \u03a3-algebra homomorphism from the vector algebra V(A) = (BQ, \u03b4A) to the vector algebra V(f(A)) = (CQ, \u03b4\u2032f(A)). For this, let k \u2208 N, \u03c3 \u2208 \u03a3 (k), and v1, . . . , vk \u2208 BQ. Then we can calculate as follows.\nf\u0303(\u03b4A(\u03c3)(v1, . . . , vk))q =f(\u03b4A(\u03c3)(v1, . . . , vk)q)\n=f ( \u2295\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n(\u2297\ni\u2208[k]\n(vi)qi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) )\n= + q1\u00b7\u00b7\u00b7qk\u2208Qk ( \u00d7 i\u2208[k] f((vi)qi) ) \u00d7 f(\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q))\n(because f is a strong bimonoid homomorphism)\n= + q1\u00b7\u00b7\u00b7qk\u2208Qk ( \u00d7 i\u2208[k] f\u0303(vi)qi ) \u00d7 (\u03b4\u2032)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) (be definition of f\u0303 and \u03b4\u2032) =\u03b4\u2032f(A)(\u03c3)(f\u0303 (v1), . . . , f\u0303(vk))q .\nHence f\u0303 is a \u03a3-algebra homomorphism. By Theorem 2.6.3, f\u0303 \u25e6 hA is a \u03a3-algebra homomorphism from the \u03a3-term algebra (T\u03a3, \u03b8\u03a3) to the vector algebra V(f(A)) = (CQ, \u03b4\u2032f(A)). Since hf(A) is also a \u03a3-algebra homomorphism of the same type, it follows from Theorem 2.6.5 that hf(A) = f\u0303 \u25e6 hA. Hence, for every \u03be \u2208 T\u03a3 and q \u2208 Q, we have hf(A)(\u03be)q = f(hA(\u03be)q).\nThen for each \u03be \u2208 T\u03a3:\n(f \u25e6 [[A]]init)(\u03be) = f([[A]]init(\u03be)) = f( \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq)\n=+ q\u2208Q f(hA(\u03be)q)\u00d7 f(Fq) =+ q\u2208Q hf(A)(\u03be)q \u00d7 F \u2032 q = [[f(A)]] init(\u03be) .\nNow we show that f \u25e6 [[A]]run = [[f(A)]]run. For this, by induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be), we have: wtf(A)(\u03be, \u03c1) = f(wtA(\u03be, \u03c1)) . (10.31)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). Then\nwtf(A)(\u03be, \u03c1) = ( \u00d7 i\u2208[k] wtf(A)(\u03bei, \u03c1|i) ) \u00d7 \u03b4\u2032k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5))\n= ( \u00d7 i\u2208[k] f(wtA(\u03bei, \u03c1|i)) ) \u00d7 f(\u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)))\n(by I.H. and construction, recall that \u03c1|i \u2208 RA(\u03bei) for 1 \u2264 i \u2264 k)\n=f ((\u2297\ni\u2208[k]\nwtA(\u03bei, \u03c1|i) ) \u2297 \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5)) )\n(by the fact that f is a strong bimonoid homomorphisms)\n10.10. CLOSURE UNDER TREE RELABELINGS 215\n=f(wtA(\u03be, \u03c1)).\nThis proves (10.31). Then for each \u03be \u2208 T\u03a3:\n(f \u25e6 [[A]]run)(\u03be) = f([[A]]run(\u03be)) = f ( \u2295\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5)\n)\n= + \u03c1\u2208RA(\u03be) f(wtA(\u03be, \u03c1)) \u00d7 f(F\u03c1(\u03b5)) = + \u03c1\u2208Rf(A)(\u03be) wtf(A)(\u03be, \u03c1)\u00d7 F \u2032 \u03c1(\u03b5) = [[f(A)]] run(\u03be) ,\nwhere the third equation uses again that h is a strong bimonoid homomorphism and the fourth one uses the fact that RA(\u03be) = Rf(A)(\u03be).\nThe next theorem generalizes [BMS\u030c+06, Lm. 3] and [FV09, Thm. 3.9] from semirings to strong bimonoids. It uses the following abbreviation. Let C be a set of (\u03a3,B)-weighted tree languages, C = (C,+,\u00d7, 0, 1) be a strong bimonoid and f : B \u2192 C be a strong bimonoid homomorphism. We define f \u25e6 C = {f \u25e6 r | r \u2208 C}. Obviously, f \u25e6 C is a set of (\u03a3,C)-weighted tree languages.\nTheorem 10.9.3. Let \u03a3 be a ranked alphabet, B = (B,\u2295,\u2297, 0, 1) and C = (C,+,\u00d7, 0, 1) be strong bimonoids, and f : B \u2192 C be a strong bimonoid homomorphism. Then the following three statements hold. (1) f \u25e6 Recinit(\u03a3,B) \u2286 Recinit(\u03a3,C) and f \u25e6 Recrun(\u03a3,B) \u2286 Recrun(\u03a3,C). (2) If f is surjective, then f \u25e6 Recinit(\u03a3,B) = Recinit(\u03a3,C) and f \u25e6 Recrun(\u03a3,B) = Recrun(\u03a3,C). (3) Statements (1) and (2) also hold for the subsets of Recinit(\u03a3,B), Recinit(\u03a3,C), Recrun(\u03a3,B), and\nRecrun(\u03a3,C) which are recognizable by bu deterministic wta. The same holds if we replace bu deterministic by crisp deterministic.\nThus, in particular, the sets Recinit(\u03a3, ), Recrun(\u03a3, ) and Rec(\u03a3, ) are closed under strong bimonoid homomorphisms.\nProof. Proof of (1): Let A be a (\u03a3,B)-wta such that r = [[A]]init. By Lemma 10.9.2 we have that f \u25e6 [[A]]init = [[f(A)]]init. Hence f \u25e6 r \u2208 Recinit(\u03a3,C). By a similar argument we can prove that r \u2208 Recrun(\u03a3,B) implies f \u25e6 r \u2208 Recrun(\u03a3,C).\nProof of (2): By (1) we have f \u25e6 Recinit(\u03a3,B) \u2286 Recinit(\u03a3,C) and f \u25e6 Recrun(\u03a3,B) \u2286 Recrun(\u03a3,C).\nNext we assume that f is surjective. Then we show that also the other inclusions hold. For this, let A\u2032 = (Q, \u03b4\u2032, F \u2032) be an arbitrary (\u03a3,C)-wta. We construct the (\u03a3,B)-wta A = (Q, \u03b4, F ) such that\n\u2022 for every k \u2208 N, \u03c3 \u2208 \u03a3(k), w \u2208 Qk, and q \u2208 Q we let \u03b4k(w, \u03c3, q) = b where b is determined as follows: if \u03b4\u2032k(w, \u03c3, q) = 0, then we let b = 0, if \u03b4 \u2032 k(w, \u03c3, q) = 1, then we let b = 1, and if \u03b4 \u2032 k(w, \u03c3, q) 6\u2208 {0, 1},\nthen we let b be an arbitrary element in f\u22121(\u03b4\u2032k(w, \u03c3, q)), and \u2022 for each q \u2208 Q, we let Fq = b, for some b \u2208 f\u22121(F \u2032q).\nIn both items such values b exist because f is surjective. We have A\u2032 = f(A) and by Lemma 10.9.2 we conclude f \u25e6 [[A]]init = [[A\u2032]]init and f \u25e6 [[A]]run = [[A\u2032]]run. Hence the other inclusions also hold.\nProof of (3): This statement holds by (1) and (2) and by the fact that the constructions of the f -image f(A) and of A\u2032 (in the proof of (2)) preserve bu determinism and crisp determinism."
        },
        {
            "heading": "10.10 Closure under tree relabelings",
            "text": "In this section we will prove that Recrun( ,B) is closed under tree relabelings. We recall that a (\u03a3,\u2206)-tree relabeling is a family \u03c4 = (\u03c4k | k \u2208 N) such that \u03c4k(\u03c3) \u2286 \u2206(k) for each \u03c3 \u2208 \u03a3(k). A tree relabeling \u03c4 is non-overlapping if \u03c4k(\u03c3) \u2229 \u03c4k(\u03c3\u2032) = \u2205 for every k \u2208 N and \u03c3, \u03c3\u2032 \u2208 \u03a3(k) with \u03c3 6= \u03c3\u2032. Its extension is the\n216 CHAPTER 10. CLOSURE PROPERTIES\nmapping \u03c4 : T\u03a3 \u2192 Pfin(T\u2206), which can be also considered as binary relation \u03c4 \u2286 T\u03a3 \u00d7 T\u2206. Then its characteristic mapping \u03c7(\u03c4) : T\u03a3 \u00d7 T\u2206 \u2192 B is supp-i-finite.\nSince \u03c7(\u03c4) is supp-i-finite, for each r : T\u03a3 \u2192 B, the application \u03c7(\u03c4)(r) is defined by (2.28) and by (2.29) and (2.30), for each \u03b6 \u2208 T\u2206, we have\n\u03c7(\u03c4)(r)(\u03b6) = \u2295\n\u03be\u2208\u03c4\u22121(\u03b6)\nr(\u03be) .\nA set L of B-weighted tree languages is closed under tree relabelings if for every (\u03a3,B)-weighted tree language r \u2208 L and every (\u03a3,\u2206)-tree relabeling \u03c4 , the (\u2206,B)-weighted tree language \u03c7(\u03c4)(r) is in L.\nTheorem 10.10.1. (cf. [SVF09, Lm. 6]) Let \u03a3 and \u2206 be ranked alphabets, B be a strong bimonoid, and A be a (\u03a3,B)-wta. Moreover, let \u03c4 be a (\u03a3,\u2206)-tree relabeling. Then we can construct a (\u2206,B)-wta B such that [[B]]run = \u03c7(\u03c4) ( [[A]]run ) . If, moreover, A is bu deterministic (or: crisp deterministic) and \u03c4 is non-overlapping, then B is bu deterministic (and crisp deterministic, respectively). Thus, in particular, the set Recrun( ,B) is closed under tree relabelings.\nProof. Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta and \u03c4 = (\u03c4k | k \u2208 N) be a (\u03a3,\u2206)-tree relabeling.\nWe construct the (\u2206,B)-wta B = (Q\u2032, \u03b4\u2032, F \u2032) where\n\u2022 Q\u2032 = Q\u00d7 \u03a3 \u2022 for every k \u2208 N, \u03b3 \u2208 \u2206(k), (q, \u03c3), (q1, \u03c31), . . . , (qk, \u03c3k) \u2208 Q \u00d7 \u03a3,\n(\u03b4\u2032)k((q1, \u03c31) \u00b7 \u00b7 \u00b7 (qk, \u03c3k), \u03b3, (q, \u03c3)) =\n{ \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) if \u03b3 \u2208 \u03c4k(\u03c3)\n0 otherwise,\n\u2022 (F \u2032)(q,\u03b3) = Fq for each (q, \u03b3) \u2208 Q \u2032.\nIn general, the above construction does not preserve bu determinism. For instance, let a, b \u2208 B with a 6= 0 6= b, and let A be a bu deterministic (\u03a3,B)-wta with transition mapping \u03b41 such that \u03b41(q, \u03c31, p) = a and \u03b41(q, \u03c32, p\n\u2032) = b. Moreover, let \u03c41(\u03c31) = \u03c41(\u03c32) = {\u03b3} and \u03ba \u2208 \u03a3. Then (\u03b4\u20321)((q, \u03ba), \u03b3, (p, \u03c31)) = a and (\u03b4\u20321)((q, \u03ba), \u03b3, (p \u2032, \u03c32)) = b and hence B is not bu deterministic.\nHowever, if \u03c4 is non-overlapping, then this phenomenon cannot occur. Thus, if A is bu deterministic and \u03c4 is non-overlapping, then B is bu deterministic. Moreover, if A is crisp deterministic and \u03c4 is non-overlapping, then B is crisp deterministic.\nNext we prove that [[B]]run = \u03c7(\u03c4) ( [[A]]run ) . Let \u03be \u2208 T\u03a3 and \u03b6 \u2208 \u03c4(\u03be). We define the mapping \u03d5\u03be,\u03b6 : RA(\u03be) \u2192 RB(\u03b6) for every \u03c1 \u2208 RA(\u03be) and w \u2208 pos(\u03be) by \u03d5\u03be,\u03b6(\u03c1)(w) = (\u03c1(w), \u03be(w)). Obviously, \u03d5\u03be,\u03b6 is injective. Moreover, we define the mapping \u03d5 \u2032 \u03be,\u03b6 : RA(\u03be)\u2192 im(\u03d5\u03be,\u03b6) by \u03d5 \u2032 \u03be,\u03b6(\u03c1) = \u03d5\u03be,\u03b6(\u03c1) for each \u03c1 \u2208 RA(\u03be). Clearly, \u03d5\u2032\u03be,\u03b6 is bijective.\nThe following statements are easy to see.\nFor every \u03b6 \u2208 T\u2206, \u03be \u2208 \u03c4 \u22121(\u03b6), and \u03c1 \u2208 RA(\u03be): wtA(\u03be, \u03c1) = wtB(\u03b6, \u03d5 \u2032 \u03be,\u03b6(\u03c1)). (10.32)\nFor every \u03b6 \u2208 T\u2206 and \u03c1 \u2032 \u2208 RB(\u03b6) \\\n\u22c3\n\u03be\u2208\u03c4\u22121(\u03b6)\nim(\u03d5\u2032\u03be,\u03b6) : wtB(\u03b6, \u03c1 \u2032) = 0. (10.33)\nFor every \u03b6 \u2208 T\u2206 and \u03be1, \u03be2 \u2208 \u03c4 \u22121(\u03b6): if \u03be1 6= \u03be2, then im(\u03d5 \u2032 \u03be1,\u03b6 ) \u2229 im(\u03d5\u2032\u03be2,\u03b6) = \u2205. (10.34)\nLet \u03b6 \u2208 T\u2206. We can calculate as follows.\n[[B]]run(\u03b6) = \u2295\n\u03c1\u2032\u2208RB(\u03b6)\nwtB(\u03b6, \u03c1 \u2032)\u2297 (F \u2032)\u03c1\u2032(\u03b5)\n10.11. CLOSURE UNDER LINEAR AND NONDELETING TREE HOMOMORPHISMS 217\n= \u2295\n\u03c1\u2032\u2208 \u22c3 \u03be\u2208\u03c4\u22121(\u03b6) im(\u03d5 \u2032 \u03be,\u03b6 )\nwtB(\u03b6, \u03c1 \u2032)\u2297 (F \u2032)\u03c1\u2032(\u03b5) (by (10.33))\n= \u2295\n\u03be\u2208\u03c4\u22121(\u03b6)\n\u2295\n\u03c1\u2032\u2208im(\u03d5\u2032 \u03be,\u03b6 )\nwtB(\u03b6, \u03c1 \u2032)\u2297 (F \u2032)\u03c1\u2032(\u03b5) (by (10.34))\n= \u2295\n\u03be\u2208\u03c4\u22121(\u03b6)\n\u2295\n\u03c1\u2208RA(\u03be)\nwtB(\u03b6, \u03d5 \u2032 \u03be,\u03b6(\u03c1)) \u2297 F\u03c1(\u03b5) (because \u03d5 \u2032 \u03be,\u03b6 is bijective)\n= \u2295\n\u03be\u2208\u03c4\u22121(\u03b6)\n\u2295\n\u03c1\u2208RA(\u03be)\nwtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) (by (10.32))\n= \u2295\n\u03be\u2208\u03c4\u22121(\u03b6)\n[[A]]run(\u03be) = \u03c7(\u03c4) ( [[A]]run ) (\u03b6) .\nAs a consequence of Theorem 10.10.1 we reobtain the well-known closure of recognizable tree languages under tree relabelings.\nCorollary 10.10.2. (cf. [Eng75b, Thm. 3.48]) Let A be a \u03a3-fta and \u03c4 a (\u03a3,\u2206)-tree relabeling. Then we can construct a \u2206-fta B such that L(B) = \u03c4(L(A)).\nProof. By Corollary 3.4.2(A)\u21d2(B), we can construct a (\u03a3,Boole)-wta A such that L(A) = supp([[A]]). Then we have\n\u03c4(L(A)) = \u03c4(supp([[A]])) = supp(\u03c7(\u03c4)([[A]]))\nwhere the last equality is due to (2.31). By Theorem 10.10.1 we can construct a (\u2206,Boole)-wta B such that [[B]] = \u03c7(\u03c4)([[A]]). Finally, by Corollary 3.4.2(B)\u21d2(A), we can construct a \u2206-fta B such that L(B) = supp([[B]]). Hence L(B) = \u03c4(L(A))."
        },
        {
            "heading": "10.11 Closure under linear and nondeleting tree homomor-",
            "text": "phisms\nIn this section we will prove that Recrun( ,B) is closed under linear, nondeleting, and productive tree homomorphism. We will even prove a more general closure of regular weighted tree languages under such tree homomorphisms.\nLet h = (hk | k \u2208 N) be a (\u03a3,\u2206)-tree homomorphism. We can view its extension h : T\u03a3 \u2192 T\u2206 as binary relation h \u2286 T\u03a3\u00d7T\u2206; then its characteristic mapping has type \u03c7(h) : T\u03a3\u00d7T\u2206 \u2192 B. We say that h is supp-i-finite if \u03c7(h) : T\u03a3 \u00d7 T\u2206 \u2192 B is supp-i-finite, i.e., for each \u03b6 \u2208 T\u2206, the set h\u22121(\u03b6) is finite.\nIn general, a tree homomorphism h is not supp-i-finite. For instance, if \u03a3 = {\u03b3(1), \u03b1(0)}, \u2206 = {\u03b2(0)}, and h(\u03b3) = x1 and h(\u03b1) = \u03b2, then h\n\u22121(\u03b2) = {\u03b3n(\u03b1) | n \u2208 N} is infinite. However, if h is productive and nondeleting, then h is supp-i-finite.\nNow let h be a (\u03a3,\u2206)-tree homomorphism and r : T\u03a3 \u2192 B such that h is supp-i-finite or B is \u03c3complete. Then the application of \u03c7(h) : T\u03a3 \u00d7T\u2206 \u2192 B to r is defined by (2.28), and by (2.30), for each \u03b6 \u2208 T\u2206, we have\n\u03c7(h)(r)(\u03b6) = \u2211\u2295\n\u03be\u2208h\u22121(\u03b6)\nr(\u03be).\nLet us denote by Hom(\u03a3,\u2206) the set of all tree homomorphisms from \u03a3 to \u2206 and let C be a subset of Hom(\u03a3,\u2206) such that each h \u2208 C is supp-i-finite. A set L of B-weighted tree languages is closed under tree homomorphisms in C if for every (\u03a3,B)-weighted tree language r \u2208 L and every (\u03a3,\u2206)-tree homomorphism h in C, the (\u2206,B)-weighted tree language \u03c7(h)(r) is in C.\nThe next theorem can be compared to [FMV11, Thm. 5.3] where the closure of the set of recognizable B-weighted tree languages under linear and nondeleting weighted extended tree transformations was\n218 CHAPTER 10. CLOSURE PROPERTIES\nproved if B is a \u03c3-complete and commutative semiring. We recall that linear and nondeleting tree homomorphisms are particular linear and nondeleting weighted extended tree transducers. (We also refer to [Boz99, Prop. 25].) This result is weaker than what one might expect when looking at [Eng75b, Thm. 3.65] for the unweighted case. There, it was proved that the set of recognizable tree languages is closed under linear tree homomorphisms (which need not be nondeleting). The underlying construction can be reformulated easily to Boole-weighted tree languages. But we do not know whether it is possible to generalize the latter to B-weighted tree languages because it is not clear how to handle the weights of deleted subtrees.\nTheorem 10.11.1. Let G be a (\u03a3,B)-wrtg such that G is finite-derivational or B is \u03c3-complete. Moreover, let h be a linear and nondeleting tree homomorphism from \u03a3 to \u2206 such that h is productive or B is \u03c3complete. Then we can construct a (\u2206,B)-wrtg G\u2032 such that (a) if G is finite-derivational (chain-free) and h is productive, then G\u2032 is finite-derivational (chain-free) and (b) [[G\u2032]] = \u03c7(h) ( [[G]] ) .\nProof. Let G = (N,S,R,wt) and h = (hk | k \u2208 N). By Lemma 9.2.2 we can assume that G is alphabetic. We construct the (\u2206,B)-wrtg G\u2032 = (N \u2032, S\u2032, R\u2032, wt\u2032), where\n\u2022 N \u2032 = N \u00d7 \u03a3, \u2022 S\u2032 = S \u00d7 \u03a3, and \u2022 R\u2032 is the smallest set of rules satisfying the following conditions:\n\u2013 for each rule r = (A \u2192 \u03c3(A1, . . . , Ak)) in R and for every \u03c31, . . . , \u03c3k \u2208 \u03a3, the rule r\u2032 = ((A, \u03c3)\u2192 hk(\u03c3)[(A1, \u03c31), . . . , (Ak, \u03c3k)]) is in R\u2032 and wt\u2032(r\u2032) = wt(r), and \u2013 for each rule r = (A \u2192 B) in R and each \u03c3 \u2208 \u03a3, the rule r\u2032 = ((A, \u03c3) \u2192 (B, \u03c3)) in R\u2032 and wt\u2032(r\u2032) = wt(r).\nSince h is linear and nondeleting, the tree hk(\u03c3) is a context for each \u03c3 \u2208 \u03a3(k) and k \u2208 N. Hence, for each rule of G\u2032 of the form (A, \u03c3) \u2192 hk(\u03c3)[(A1, \u03c31), . . . , (Ak, \u03c3k)], each nonterminal (Ai, \u03c3i) occurs exactly once in the right-hand side of that rule. Moreover, if G is chain-free and h is productive, then G\u2032 is chain-free.\nWe define the mapping\n\u03d5 : RTG(N,T\u03a3)\u2192 RTG\u2032(N \u2032,T\u2206)\nby induction on the well-founded set (RTG(N,T\u03a3),\u227a) where \u227a=\u227aR \u2229 (RTG(N,T\u03a3) \u00d7 RTG(N,T\u03a3)). Then min\u227a(RTG(N,T\u03a3)) is the set of all rules of R with right-hand side in \u03a3 (0).\nLet d \u2208 RTG(N,T\u03a3). We can distinguish the following two cases\nCase (a): Let d = r(d1, . . . , dk) for some rule r = (A \u2192 \u03c3(A1, . . . , Ak)) and di \u2208 RTG(N,T\u03a3) for\neach i \u2208 [k]. Then we let \u03d5(d) = r\u2032(d\u20321, . . . , d \u2032 k), where r \u2032 = ((A, \u03c3) \u2192 hk(\u03c3)[(A1, \u03c31), . . . , (Ak, \u03c3k)]) with \u03c3i = \u03c0(di)(\u03b5) and d \u2032 i = \u03d5(di) for each i \u2208 [k].\nCase (b): Let d = r(d1) for some rule r = (A \u2192 B) in R and d1 \u2208 RTG(N,T\u03a3). Then we let\n\u03d5(d) = r\u2032(d\u20321), where r \u2032 = ((A, \u03c3)\u2192 (B, \u03c3)) and d\u20321 = \u03d5(d1).\nDue to the construction of G\u2032,\nfor every A \u2208 N and \u03be \u2208 T\u03a3, we have \u03d5(RTG(A, \u03be)) = RTG\u2032((A, \u03be(\u03b5)), h(\u03be)) ,\nand\nfor every (A, \u03c3) \u2208 N \u2032 and \u03b6 \u2208 T\u2206, we have RTG\u2032((A, \u03c3), \u03b6) = \u22c3\n\u03be\u2208h\u22121(\u03b6): \u03be(\u03b5)=\u03c3\n\u03d5(RTG(A, \u03be)) . (10.35)\nIt follows that, if h is productive (and thus it is supp-i-finite) and G is finite-derivational, then G\u2032 is finite-derivational. It is easy to see that\n\u03d5 is a bijection and wtG(d) = wtG\u2032(\u03d5(d)) for each d \u2208 RTG(N,T\u03a3) . (10.36)\n10.12. CLOSURE UNDER INVERSE OF LINEAR TREE HOMOMORPHISMS 219\nMoreover,\nthe family (\u03d5(RTG(A, \u03be)) | \u03be \u2208 h \u22121(\u03b6), \u03be(\u03b5) = \u03c3) is a partitioning of RTG\u2032((A, \u03c3), \u03b6) , (10.37)\nbecause each d \u2208 \u03d5(RTG(A, \u03be)) encodes \u03be, thus \u03be 6= \u03be \u2032 implies \u03d5(RTG(A, \u03be)) \u2229 \u03d5(RTG(A, \u03be \u2032)) = \u2205. Hence the union on right-hand side of (10.35) is a disjoint union.\nNow let \u03b6 \u2208 T\u2206. Then we can compute as follows\n[[G\u2032]](\u03b6) = \u2211\u2295\nd\u2032\u2208RTG\u2032 (\u03b6)\nwtG\u2032(d \u2032) =\n\u2295\n(A,\u03c3)\u2208S\u2032\n\u2211\u2295\nd\u2032\u2208RTG\u2032 ((A,\u03c3),\u03b6)\nwtG\u2032(d \u2032)\n=(\u2217) \u2295\n(A,\u03c3)\u2208S\u2032\n\u2211\u2295\n\u03be\u2208h\u22121(\u03b6),\u03be(\u03b5)=\u03c3 d\u2208RTG(A,\u03be)\nwtG(d) = \u2295\n\u03be\u2208h\u22121(\u03b6)\n\u2211\u2295\nA\u2208S d\u2208RTG(A,\u03be)\nwtG(d)\n= \u2295\n\u03be\u2208h\u22121(\u03b6)\n[[G]](\u03be) = \u03c7(h) ( [[G]] ) (\u03b6) ,\nwhere (\u2217) follows from (10.36) and (10.37).\nCorollary 10.11.2. Let \u03a3 and \u2206 be ranked alphabets, B be a strong bimonoid, and A be a (\u03a3,B)-wta. Moreover, let h be a linear, nondeleting, and productive tree homomorphism from \u03a3 to \u2206. Then we can construct a (\u2206,B)-wta A\u2032 such that [[A\u2032]]run = \u03c7(h) ( [[A]]run ) . Thus, in particular, the set Recrun( ,B) is closed under linear, nondeleting, and productive tree homomorphisms.\nProof. By Lemma 9.2.6 we can construct (\u03a3,B)-wrtg G such that G is in tree automata form and [[A]]run = [[G]]. In particular, G is chain-free. By Theorem 10.11.1 we can construct a chain-free (\u03a3,B)-wrtg G\u2032 such that [[G\u2032]] = \u03c7(h) ( [[G]] ) . Finally, by Lemma 9.2.8(a), we can construct a (\u03a3,B)-wta A\u2032 such that [[G\u2032]] = [[A\u2032]]run."
        },
        {
            "heading": "10.12 Closure under inverse of linear tree homomorphisms",
            "text": "Let h be a (\u03a3,\u2206)-tree homomorphism and r : T\u2206 \u2192 B. Since the extension h : T\u03a3 \u2192 T\u2206 is a particular binary relation h \u2286 T\u03a3\u00d7T\u2206, its inverse h\u22121 \u2286 T\u2206\u00d7T\u03a3 is well defined. Moreover, \u03c7(h\u22121) : T\u2206\u00d7T\u03a3 \u2192 B is supp-i-finite, and hence r is \u03c7(h\u22121)-summable. Thus, the application of \u03c7(h\u22121) to r is defined by (2.28), and by (2.30) we obtain, for each \u03be \u2208 T\u03a3:\n\u03c7(h\u22121)(r)(\u03be) = \u2211\u2295\n\u03b6\u2208h(\u03be)\nr(\u03b6) = r(h(\u03be)) .\nAgain let us denote by Hom(\u03a3,\u2206) the set of all tree homomorphisms from \u03a3 to \u2206. Let C be a subset of the set Hom(\u03a3,\u2206). A set L of B-weighted tree languages is closed under inverse of tree homomorphisms in C if for every (\u2206,B)-weighted tree language r \u2208 L and every (\u03a3,\u2206)-tree homomorphism h in C, the (\u03a3,B)-weighted tree language \u03c7(h\u22121)(r) = r \u25e6 h is in L.\nIn this section we show that, if B is a commutative semiring, then Rec( ,B) is closed under the inverse of linear tree homomorphisms.\nLet A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. We wish to extend the \u03a3-algebra homomorphism hA : T\u03a3 \u2192 BQ to a mapping which can also process trees with variables in Zn (cf. [FV15, p. 85]). Formally, let n \u2208 N and q1, . . . , qn \u2208 Q. We define the mapping f : Zn \u2192 BQ such that, for each zi \u2208 Zn and q \u2208 Q, we let\n220 CHAPTER 10. CLOSURE PROPERTIES\nf(zi)q = 1 if q = qi, and 0 otherwise. Since the \u03a3-term algebra (T\u03a3(Zn), \u03b8\u03a3) over Zn is freely generated by Zn over the set of all \u03a3-algebras (cf. Theorem 2.9.3), there exists a unique extension of f to a \u03a3-algebra homomorphism from (T\u03a3(Zn), \u03b8\u03a3) to the vector algebra V(A) = (BQ, \u03b4A). We denote this \u03a3-algebra homomorphism by hq1\u00b7\u00b7\u00b7qnA . Thus, in particular, for every \u03c3 \u2208 \u03a3\n(k) with k \u2208 N and \u03be1, . . . , \u03bek \u2208 T\u03a3(Zn), we have\nhq1\u00b7\u00b7\u00b7qnA (\u03c3(\u03be, . . . , \u03bek))q = \u2295\np1\u00b7\u00b7\u00b7pk\u2208Qk\n(\u2297\ni\u2208[k]\nhq1\u00b7\u00b7\u00b7qnA (\u03bei)pi ) \u2297 \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, \u03c3, q) .\nObviously, h\u03b5A = hA.\nIn the next lemma, for every \u03b6 \u2208 T\u03a3(Zn) which is linear in Zn and trees \u03be1, . . . , \u03ben \u2208 T\u03a3, we wish to express the value hA(\u03b6[\u03be1, . . . , \u03ben])q \u2208 B by means of the homomorphic images of \u03be1, . . . , \u03ben (cf. Figure 10.10). For this we need some technical tools to identify variables in subterms of \u03b6.\nLet (m1, . . . ,ml) be the sequence of indices of variables occurring in \u03b6 in a left-to-right order; we denote this sequence by seq(\u03b6). Obviously, l \u2264 n and mj \u2264 n for each j \u2208 [l]. For instance, if \u03b6 = \u03c3(\u03c3(\u03b1, z2), \u03c3(z3, z1)), then seq(\u03b6) = (2, 3, 1). We note that, if \u03b6 = \u03c3(\u03b61, . . . , \u03b6k), then seq(\u03b6) = seq(\u03b61) \u00b7 \u00b7 \u00b7 seq(\u03b6k) (by dropping intermediate occurrences of \u201c)(\u201c).\nMoreover, we denote by lin(\u03b6) the tree obtained from \u03b6 by replacing its variables by z1, . . . , zl in a left-to-right order. Hence seq(lin(\u03b6)) = (1, . . . , l). For instance, lin(\u03c3(\u03c3(\u03b1, z2), \u03c3(z3, z1))) = \u03c3(\u03c3(\u03b1, z1), \u03c3(z2, z3)).\nLemma 10.12.1. (cf. [FV15, Lm. 5.4]) Let B be a semiring and A = (Q, \u03b4, F ) a (\u03a3,B)-wta. Moreover, let n \u2208 N. Then, for every \u03b6 \u2208 T\u03a3(Zn) which \u03b6 is linear in Zn, \u03be1, . . . , \u03ben \u2208 T\u03a3, and q \u2208 Q, we have\nhA(\u03b6[\u03be1, . . . , \u03ben])q = \u2295\nq1\u00b7\u00b7\u00b7ql\u2208Ql\n(\u2297\nj\u2208[l]\nhA(\u03bemj )qj ) \u2297 hq1\u00b7\u00b7\u00b7qlA (lin(\u03b6))q ,\nwhere seq(\u03b6) = (m1, . . . ,ml).\nProof. We prove the statement by induction on T\u03a3(Zn). For this, let \u03b6 \u2208 T\u03a3(Zn) such that \u03b6 is linear in Zn.\n10.12. CLOSURE UNDER INVERSE OF LINEAR TREE HOMOMORPHISMS 221\nI.B.: Let \u03b6 = zj for some j \u2208 [n]. Then seq(\u03b6) = (j) and\nhA(zj [\u03be1, . . . , \u03ben])q = hA(\u03bej)q = \u2295\nq1\u2208Q\nhA(\u03bej)q1 \u2297 h q1 A (zj)q .\nLet \u03b6 = \u03c3 for some \u03c3 \u2208 \u03a3(0). The proof of this case is the proof of case k = 0 of the I.S.\nI.S.: Let \u03b6 \u2208 T\u03a3(Zn) \\Zn. Then \u03b6 = \u03c3(\u03b61, . . . , \u03b6k) for some k \u2208 N, \u03c3 \u2208 \u03a3(k), and \u03b61, . . . , \u03b6k \u2208 T\u03a3(Zn). For each j \u2208 [k], we have that \u03b6j \u2208 T\u03a3(Zn) and \u03b6j is linear in Zn. Moreover, let seq(\u03b6) = (m1, . . . ,ml) and let seq(\u03b6i) = (n i 1, . . . , n i \u03bai ) for each i \u2208 [k]. Hence\nl =\nk\u2211\nj=1\n\u03baj and (m1, . . . ,ml) = (n 1 1, . . . , n 1 \u03ba1 , . . . , nl1, . . . , n l \u03bal ) . (10.38)\nThen\nhA(\u03b6[\u03be1, . . . , \u03ben])q\n= \u2295\np1\u00b7\u00b7\u00b7pk\u2208Qk\n[\u2297\ni\u2208[k]\nhA(\u03b6i[\u03be1, . . . , \u03ben])pi ] \u2297 \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, \u03c3, q)\n= \u2295\np1\u00b7\u00b7\u00b7pk\u2208Qk\n[\u2297\ni\u2208[k]\n( \u2295\nqi1\u00b7\u00b7\u00b7q i \u03bai \u2208Q\u03bai\n( \u2297\nj\u2208[\u03bai]\nhA(\u03benij )qij\n) \u2297 h qi1\u00b7\u00b7\u00b7q i \u03bai\nA (lin(\u03b6i))pi )] \u2297 \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, \u03c3, q) (by I.H.)\n= \u2295\np1\u00b7\u00b7\u00b7pk\u2208Qk\n\u2295\nq11 \u00b7\u00b7\u00b7q 1 \u03ba1 \u2208Q\u03ba1\n\u00b7 \u00b7 \u00b7 \u2295\nqk1 \u00b7\u00b7\u00b7q k \u03bak \u2208Q\u03bak\n\u2297\ni\u2208[k]\n(( \u2297\nj\u2208[\u03bai]\nhA(\u03benij )qij\n) \u2297 h qi1\u00b7\u00b7\u00b7q i \u03bai\nA (lin(\u03b6i))pi ) \u2297 \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, \u03c3, q) (by right-distributivity)\n= \u2295\nq11 \u00b7\u00b7\u00b7q 1 \u03ba1 \u2208Q\u03ba1\n\u00b7 \u00b7 \u00b7 \u2295\nqk1 \u00b7\u00b7\u00b7q k \u03bak \u2208Q\u03bak\n(\u2297\ni\u2208[k]\n\u2297\nj\u2208[\u03bai]\nhA(\u03benij )qij\n) \u2297\n\u2295\np1\u00b7\u00b7\u00b7pk\u2208Qk\n(\u2297\ni\u2208[k]\nh qi1\u00b7\u00b7\u00b7q i \u03bai\nA (lin(\u03b6i))pi ) \u2297 \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, \u03c3, q) (by left-distributivity)\n= \u2295\nq1\u00b7\u00b7\u00b7ql\u2208Ql\n(\u2297\nj\u2208[l]\nhA(\u03bemj )qj ) \u2297 hq1\u00b7\u00b7\u00b7qlA (lin(\u03b6))q\nwhere the last equality uses (10.38) and the fact that\n\u2295\np1\u00b7\u00b7\u00b7pk\u2208Qk\n(\u2297\ni\u2208[k]\nh qi1\u00b7\u00b7\u00b7q i \u03bai\nA (lin(\u03b6i))pi ) \u2297 \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, \u03c3, q) = h q1\u00b7\u00b7\u00b7ql A (lin(\u03b6))q ,\nwhere qj = qj1 \u00b7 \u00b7 \u00b7 q j \u03baj .\nIn the next theorem we apply Lemma 10.12.1 to the case where \u03b6 = hk(\u03c3) for some linear tree homomorphism h = (hk | k \u2208 N). It is helpful to view seq(hk(\u03c3)) as a set of indices; then we can write something like i 6\u2208 seq(hk(\u03c3)) with the obvious meaning.\nThe next theorem can be compared to [FMV11, Thm. 5.1] where the closure of the set of recognizable B-weighted tree languages under inverse of linear weighted extended tree transformations was proved if B is a \u03c3-complete and commutative semiring. We recall that linear tree homomorphisms are particular linear weighted extended tree transducers.\n222 CHAPTER 10. CLOSURE PROPERTIES\nTheorem 10.12.2. Let \u03a3 and \u2206 be ranked alphabets, B be a commutative semiring, and A be a (\u2206,B)wta. Moreover, let h be a linear (\u03a3,\u2206)-tree homomorphism. Then we can construct a (\u03a3,B)-wta B such that [[B]] = \u03c7(h\u22121) ( [[A]] ) . Thus, in particular, the set Rec( ,B) is closed under the inverse of linear tree homomorphisms.\nProof. Let A = (Q, \u03b4, F ) and h = (hk | k \u2208 N). For the construction of B we use a technique from [Eng75a, Thm. 2.8]: it adds a new state e which takes care of those subtrees which are deleted by the tree homomorphism h (the latter corresponding to the given linear top-down tree transducer in [Eng75a, Thm. 2.8]).\nFormally, we construct B = (Q\u2032, \u03b4\u2032, F \u2032) such that Q\u2032 = Q \u222a {e} and for every k \u2208 N, \u03c3 \u2208 \u03a3(k), q1, . . . , qk, q \u2208 Q\u2032 we let\n(\u03b4\u2032)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) =    hwA(lin(hk(\u03c3)))q if q \u2208 Q and (\u2200i \u2208 [k]): qi = e iff i 6\u2208 seq(hk(\u03c3)) 1 if q = q1 = . . . = qk = e\n0 otherwise\nwhere w = qm1 \u00b7 \u00b7 \u00b7 qml if seq(hk(\u03c3)) = (m1, . . . ,ml). Moreover, we let (F \u2032)q = Fq for each q \u2208 Q, and (F \u2032)e = 0.\nThe following property is easy to see.\nFor every \u03be \u2208 T\u03a3 we have: hB(\u03be)e = 1. (10.39)\nBy induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and q \u2208 Q we have: hB(\u03be)q = hA(h(\u03be))q . (10.40)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). We assume that seq(hk(\u03c3)) = (m1, . . . ,ml). Then we can compute as follows.\nhB(\u03c3(\u03be1, . . . , \u03bek))q = \u2295\nq1\u00b7\u00b7\u00b7qk\u2208(Q\u2032)k\n(\u2297\ni\u2208[k]\nhB(\u03bei)qi ) \u2297 (\u03b4\u2032)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208(Q\u2032)k\n(\u2297\ni\u2208[k]\n{ hA(h(\u03bei))qi if qi \u2208 Q\n1 otherwise\n) \u2297 (\u03b4\u2032)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\n(by I.H. and (10.39))\n= \u2295\nq1\u00b7\u00b7\u00b7qk\u2208(Q \u2032)k:\nqi=e \u21d0\u21d2 i6\u2208seq(hk(\u03c3))\n(\u2297\ni\u2208[k]\n{ hA(h(\u03bei))qi if qi \u2208 Q\n1 otherwise\n) \u2297 hwA(lin(hk(\u03c3)))q\n(by construction where w = qm1 \u00b7 \u00b7 \u00b7 qml)\n= \u2295\nq1\u00b7\u00b7\u00b7ql\u2208Ql\n(\u2297\nj\u2208[l]\nhA(h(\u03bemj ))qj ) \u2297 hq1\u00b7\u00b7\u00b7qlA (lin(hk(\u03c3)))q (by the commutativity of B)\n= hA(hk(\u03c3)[h(\u03be1), . . . , h(\u03bek)])q (by Lemma 10.12.1)\n= hA(h(\u03c3(\u03be1, . . . , \u03bek))q .\nThen, for each \u03be \u2208 T\u03a3 we can compute as follows.\n[[B]](\u03be) = \u2295\nq\u2208Q\u2032\nhB(\u03be)q \u2297 (F \u2032)q =\n\u2295\nq\u2208Q\nhB(\u03be)q \u2297 Fq\n= \u2295\nq\u2208Q\nhA(h(\u03be))q \u2297 Fq (by (10.40))\n= [[A]](h(\u03be)) = \u03c7(h\u22121) ( [[A]] ) (\u03be) .\n10.13. CLOSURE UNDER WEIGHTED PROJECTIVE BIMORPHISMS 223\nWe note that in [GS84, Thm. 2.4.18] (also cf. [Eng75b, Cor. 4.60]) it was proved that the set of recognizable tree languages is closed under inverse of arbitrary tree homomorphisms. The same is true for crisp deterministically recognizable weighted tree languages over UnitIntu,i [BLB10, Prop. 6] (taking Theorem 4.3.5(A)\u21d4(B) into account). However, in the arbitrary weighted case, the restriction to linear tree homomorphisms is important. In fact, we can give a (nonlinear) tree homomorphism h and a bu deterministic wta A over the semiring Nat such that \u03c7(h\u22121)([[A]]) is not recognizable.\nExample 10.12.3. [FMV11, Ex. 5.1] Let \u03a3 = {\u03b3(1), \u03b1(0)} and \u2206 = {\u03c3(2), \u03b1(0)}. For each n \u2208 N, let \u03b6n be the fully balanced tree of height n over \u2206, which is defined by \u03b60 = \u03b1 and \u03b6n = \u03c3(\u03b6n\u22121, \u03b6n\u22121) for every n \u2265 1. We consider the (\u03a3,\u2206)-tree homomorphism with h1(\u03b3) = \u03c3(z1, z1) and h0(\u03b1) = \u03b1. It is clear that h(\u03b3n(\u03b1)) = \u03b6n for each n \u2208 N where \u03b3n(\u03b1) abbreviates the tree \u03b3(\u03b3(\u00b7 \u00b7 \u00b7 \u03b3(\u03b1) \u00b7 \u00b7 \u00b7 )) containing n times the symbol \u03b3.\nMoreover, we consider the bu deterministic (\u2206,Nat)-wta A = ({q}, \u03b4, F ), where \u03b42(qq, \u03c3, q) = 1, \u03b40(\u03b5, \u03b1, q) = 2, and Fq = 1. For each \u03b6 \u2208 T\u2206, we have [[A]](\u03b6) = 2n, where n is the number of occurrences of \u03b1 in \u03b6. Consequently, we obtain that\n\u03c7(h\u22121) ( [[A]] ) (\u03b3n(\u03b1)) = [[A]](h(\u03b3n(\u03b1))) = [[A]](\u03b6n) = 2 2n\nfor each n \u2208 N.\nNow we can easily show by contradiction that the weighted tree language \u03c7(h\u22121) ( [[A]] ) is not recog-\nnizable. For this, we assume there exists a (\u2206,Nat)-wta B = (Q, \u03b4\u2032, F \u2032) such that [[B]] = \u03c7(h\u22121) ( [[A]] ) .\nBy Lemma 3.5.6, there exists a K \u2208 N such that, for each n \u2208 N, we have [[B]](\u03b3n(\u03b1)) \u2264 Kn+1. Then, for each n \u2208 N, we have 22 n = \u03c7(h\u22121) ( [[A]] ) (\u03b3n(\u03b1)) = [[B]](\u03b3n(\u03b1)) \u2264 Kn+1. But this is not true. Hence, there does not exist a (\u2206,Nat)-wta B = (Q, \u03b4\u2032, F \u2032) such that [[B]] = \u03c7(h\u22121) ( [[A]] ) ."
        },
        {
            "heading": "10.13 Closure under weighted projective bimorphisms",
            "text": "In this section, we let \u03a8 be a ranked alphabet. We define the concept of (\u03a3,\u03a8,B)-weighted projective bimorphism as special weighted regular tree grammar; each such grammarH computes a (\u03a3,\u03a8,B)-weighted tree transformation, denoted by [[H]]tt; we also call [[H]]tt a (\u03a3,\u03a8,B)-weighted projective bimorphism. Intuitively, a weighted projective bimorphism is a tree relabeling in which, additionally, unary input symbols can be deleted without producing output and unary output symbols can be produced without consuming an input symbol.\nThen we prove that, roughly speaking, the sets Reg( ,B) and Rec( ,B) are closed under weighted projective bimorphisms if B is a commutative semiring. Given an alphabetic (\u03a3,B)-wrtg G and a (\u03a3,\u03a8,B)weighted projective bimorphism H, we will proceed in four steps as follows:\n1. we split the semantics of G into an ([R],\u03a3,B)-weighted projective bimorphism HG and a characteristic mapping \u03c7(T[R]) such that [[G]] = [[HG ]]\ntt(\u03c7(T[R])), where R is the set of rules of G viewed as ranked alphabet and [R] is the skeleton alphabet of R (cf. Lemma 10.13.6), 2. we prove that weighted projective bimorphisms are closed under composition (cf. Theorem 10.13.7); thus, in particular, we can construct an ([R],\u03a8,B)-weighted projective bimorphism H\u2032 such that [[H\u2032]]tt = [[HG ]]tt; [[H]]tt, 3. we merge H\u2032 and the characteristic mapping \u03c7(T[R]) into a (\u03a8,B)-wrtg G \u2032 such that [[G\u2032]] =\n[[H\u2032]]tt(\u03c7(T[R])) (cf. Lemma 10.13.8), and 4. finally, we deduce the mentioned closure results for Reg( ,B) and Rec( ,B) (cf. Theorem 10.13.9\nand Corollary 10.13.10).\nOn first glance, this split-compose-merge procedure looks too complicated for the purpose of just showing the closure of recognizable weighted tree languages under weighted projective bimorphisms. However, in Chapter 15 we will need the result of the second step (i.e., closure of weighted projective bimorphisms under composition), and we want to benefit from this result already here in our current setting.\n224 CHAPTER 10. CLOSURE PROPERTIES"
        },
        {
            "heading": "10.13.1 Weighted projective bimorphisms",
            "text": "We define the ranked alphabet [\u03a3\u03a8] such that, for each k \u2208 N, we let [\u03a3\u03a8](k) = \u03a3(k) \u00d7\u03a8(k) if k 6= 1, and we let [\u03a3\u03a8](1) = ( (\u03a3(1) \u222a {\u03b5})\u00d7 (\u03a8(1) \u222a {\u03b5}) ) \\ {(\u03b5, \u03b5)}.\nMoreover, we define the tree homomorphism \u03c01 : T[\u03a3\u03a8] \u2192 T\u03a3 and the tree homomorphism \u03c02 : T[\u03a3\u03a8] \u2192 T\u03a8 which, intuitively, project to the first component of a symbol [\u03c3, \u03c8] and to the second component, respectively. Formally, the tree homomorphism \u03c01 is induced by the family ((\u03c01)k | k \u2208 N) of mappings (\u03c01)k : [\u03a3\u03a8] (k) \u2192 T\u03a3(Xk) such that, for every k \u2208 N and [\u03c3, \u03c8] \u2208 [\u03a3\u03a8] (k), we let\n(\u03c01)k([\u03c3, \u03c8]) =\n{ \u03c3(x1, . . . , xk) if \u03c3 6= \u03b5\nx1 otherwise.\nWe recall that \u03c3 = \u03b5 is possible only in case k = 1. Analogously, we define the family ((\u03c02)k | k \u2208 N) of mappings (\u03c02)k : [\u03a3\u03a8]\n(k) \u2192 T\u03a8(Xk) which induces the tree homomorphism \u03c02. Obviously, \u03c01 and \u03c02 are linear and nondeleting; moreover, for each [\u03c3, \u03c8] \u2208 [\u03a3\u03a8](k), we have height(\u03c01([\u03c3, \u03c8])) \u2264 1 and height(\u03c02([\u03c3, \u03c8])) \u2264 1.\nA B-weighted projective bimorphism over \u03a3 and \u03a8 (for short: (\u03a3,\u03a8,B)-wpb, or just: wpb) is an alphabetic ([\u03a3\u03a8],B)-wrtg H = (N,S,R,wt). The alphabets \u03a3 and \u03a8 are called input alphabet and output alphabet of H, respectively; correspondingly, trees in T\u03a3 and T\u03a8 are called input trees and output trees of H, respectively.\nObviously, a (\u03a3,\u03a8,B)-wpb H can contain two types of rules:\n1. A\u2192 [\u03c3, \u03c8](A1, . . . , Ak) with k \u2208 N and [\u03c3, \u03c8] \u2208 [\u03a3,\u03a8](k), and 2. A\u2192 B (chain rule).\nLet us consider the first type of rules. We call \u03c3 the input of r and \u03c8 the output of r, and we denote them by inp(r) and out(r), respectively. Moreover, we give the names shown in the second column of the following table to such rules depending on whether they read a symbol from the input or not and whether they write a symbol to the output or not; in the last column we show the denotation for the set of all rules of a particular type.\nA\u2192 [\u03c3, \u03c8](A1, . . . , Ak) in R type of the rule denotation for the set r= read, w=write of all rules of that type\n\u03c3 6= \u03b5 and \u03c8 6= \u03b5 rw-rule Rrw \u03c3 = \u03b5 and \u03c8 6= \u03b5 \u03b5w-rule R\u03b5w \u03c3 6= \u03b5 and \u03c8 = \u03b5 r\u03b5-rule Rr\u03b5\nMoreover, we let R w = Rrw \u222a R\u03b5w and Rr = Rrw \u222a Rr\u03b5. By viewing R as a ranked alphabet, both \u03b5w-rules and r\u03b5-rules have rank 1, i.e., R\u03b5w \u222aRr\u03b5 \u2286 R(1), and each chain rule is in R(1). Finally, we note that, since each wpb is a particular wrtg (and in its turn, each wrtg is a particular wcfg; and in its turn, each wcfg is a cfg equipped with a weight mapping, cf. Figure 1.1), we have the concept of rule tree of H available, as well as the abbreviation RTH(N \u2032, \u03b7) for each N \u2032 \u2286 N and \u03b7 \u2208 T[\u03a3\u03a8], cf. page 55.\nNow we define the weighted tree transformation computed by a (\u03a3,\u03a8,B)-wpb H = (N,S,R,wt). For this, let N \u2032 \u2286 N , \u03be \u2208 T\u03a3, and \u03b6 \u2208 T\u03a8. We define\nRTH(N \u2032, \u03be, \u03b6) =\n\u22c3\n\u03b7\u2208T[\u03a3\u03a8]: \u03c01(\u03b7)=\u03be,\u03c02(\u03b7)=\u03b6\nRTH(N \u2032, \u03b7) (10.41)\nand we define RTH(\u03be, \u03b6) = RTH(S, \u03be, \u03b6). Then the family\n(RTH(N \u2032, \u03b7) | \u03b7 \u2208 T[\u03a3\u03a8] : \u03c01(\u03b7) = \u03be, \u03c02(\u03b7) = \u03b6) (10.42)\nis a partitioning of the set RTH(N \u2032, \u03be, \u03b6) because (10.41) holds and \u03b7 6= \u03b7\u2032 implies that RTH(N \u2032, \u03b7) \u2229 RTH(N \u2032, \u03b7\u2032) = \u2205. Moreover, the set {\u03b7 \u2208 T[\u03a3\u03a8] | \u03c01(\u03b7) = \u03be, \u03c02(\u03b7) = \u03b6} is finite, hence (10.42) is a\n10.13. CLOSURE UNDER WEIGHTED PROJECTIVE BIMORPHISMS 225\npartitioning into finitely many subsets. Due to this fact, H is finite-derivational if and only if, for every \u03be \u2208 T\u03a3 and \u03b6 \u2208 T\u03a8, the set RTH(\u03be, \u03b6) is finite.\nWe call H\n\u2022 finite-input if for every \u03b6 \u2208 T\u03a8, the set {\u03be \u2208 T\u03a3 | RTH(\u03be, \u03b6) 6= \u2205} is finite; \u2022 finite-output if for every \u03be \u2208 T\u03a3, the set {\u03b6 \u2208 T\u03a8 | RTH(\u03be, \u03b6) 6= \u2205} is finite.\nIf R = R w, then H is finite-input, and if R = Rr , then H is finite-output.\nIf H is finite-derivational or B is \u03c3-complete, then we define the weighted projective bimorphism computed by H to be the weighted tree transformation [[H]]tt : T\u03a3 \u00d7 T\u03a8 \u2192 B such that, for every \u03be \u2208 T\u03a3 and \u03b6 \u2208 T\u03a8, we have\n[[H]]tt(\u03be, \u03b6) = \u2211\u2295\nd\u2208RTH(\u03be,\u03b6)\nwtH(d) ,\nwhere wtH : TR \u2192 B is the weight mapping defined in (8.1) (viewing H as wcfg).\nIt is easy to see that, if H is finite-input, then [[H]]tt is supp-i-finite, and if H is finite-output, then [[H]]tt is supp-o-finite.\nLet \u03c4 : T\u03a3 \u00d7 T\u03a8 \u2192 B be a weighted tree transformation. We say that \u03c4 is a (\u03a3,\u03a8,B)-weighted projective bimorphism (or just: weighted projective bimorphism) if there exists a (\u03a3,\u03a8,B)-wpb H such that H is finite-derivational if B is not \u03c3-complete, and [[H]]tt = \u03c4 .\nA set L of B-weighted tree languages is closed under weighted projective bimorphisms if for every (\u03a3,B)-weighted tree language r \u2208 L and every (\u03a3,\u03a8,B)-bimorphismH, the (\u03a8,B)-weighted tree language [[H]]tt(r) is in L.\nIn Figure 10.11 we illustrate the relationships between the mappings \u03c0H, \u03c01, and \u03c02.\nUp to syntactic modifications, the concept of (\u03a3,\u03a8,B)-wpb is the same as the concept of B-weighted generalized relabeling tree transducers over \u03a3 and \u03a8 (for short: (\u03a3,\u03a8,B)-transducer) as it was defined in [FV22b]. The syntactic modifications are shown in the following table where we assume that \u03c3 \u2208 \u03a3(k) and \u03c8 \u2208 \u03a8(k):\n226 CHAPTER 10. CLOSURE PROPERTIES\nk \u2208 N rule of a (\u03a3,\u03a8,B)-wpb rule of a (\u03a3,\u03a8,B)-transducer k \u2265 0 A\u2192 [\u03c3, \u03c8](A1, . . . , Ak) (A, \u03c3(x1, . . . , xk), A1 \u00b7 \u00b7 \u00b7Ak, \u03c8(x1, . . . , xk)) k = 1 A\u2192 [\u03c3, \u03b5](A1) (A, \u03c3(x1), A1, x1) k = 1 A\u2192 [\u03b5, \u03c8](A1) (A, x1, A1, \u03c8(x1)) k = 1 A\u2192 A1 (A, x1, A1, x1)\nIn [FV22b] we have assumed that B is a commutative and \u03c3-complete semiring. Here we are more liberal and do not require per se that B is \u03c3-complete (and commutative). As a consequence, we have to be more careful with the definedness of the semantics [[H]]tt of a weighted projective bimorphism H.\nAlso, we refer the reader to Theorem 15.2.1 where the weighted tree transformation [[H]]tt is decomposed into the inverse of a simple tree homomorphism, followed by the Hadamard product with the recognizable weighted tree language [[H]]wrt, followed by a simple tree homomorphism; this decomposition connects our definition of wpb with the classical definition of bimorphisms in [AD76, AD82]. For details we refer to Section 15.2.\nFinally, we note that weighted projective bimorphisms are particular linear and nondeleting weighted extended tree transducers [FMV11] in which each rule processes at most one input symbol and generates at most one output symbol. For a comparison to linear nondeleting recognizable tree transducers [Kui99c] we refer to [FMV11].\nExample 10.13.1. We consider the ranked alphabets \u03a3 = {\u03c3(2), \u03b3(1), \u03b1(0)} and \u03a8 = {\u03c3(2), \u03b3\u2032(1), \u03b1(0)}. As weight algebra we consider the semiring Nat = (N,+, \u00b7, 0, 1) of natural numbers.\nWe wish to define a (\u03a3,\u03a8,Nat)-wpb H such that, for each (\u03be, \u03b6) \u2208 supp([[H]]tt), there exists a tree \u03ba \u2208 T{\u03c3(2),\u03b1(0)} (called kernel of (\u03be, \u03b6)) and (a) \u03be is obtained from \u03ba by inserting above an arbitrary position an arbitrary number of \u03b3-labeled positions and (b) \u03b6 is obtained from \u03ba by inserting above an arbitrary position an arbitrary number of \u03b3\u2032-labeled positions; moreover, the insertions of \u03b3 into \u03be and of \u03b3\u2032 into \u03b6 can happen interleaved and in an arbitrary ordering. Then, we define H such that [[H]]tt(\u03be, \u03b6) is the number of all possible orderings of insertions to obtain the pair (\u03be, \u03b6) from \u03ba by this insertion method.\nFor this we let H = (N,S,R,wt) with N = S = {A} and we let R contain the following rules:\nA\u2192 [\u03c3, \u03c3](A,A) A\u2192 [\u03b1, \u03b1] (for the generation of \u03ba) A\u2192 [\u03b3, \u03b5](A) A\u2192 [\u03b5, \u03b3\u2032](A) (for inserting \u03b3 and \u03b3\u2032) .\nWe let wt(r) = 1 for each r \u2208 R. Obviously, [[H]]tt(\u03be, \u03b6) = |RTH(\u03be, \u03b6)| for every \u03be \u2208 T\u03a3 and \u03b6 \u2208 T\u03a8.\nFor instance, let \u03be = \u03c3(\u03b3(\u03b1), \u03b3\u03b3(\u03b1)) and \u03b6 = \u03b3\u2032(\u03c3(\u03b3\u2032(\u03b1), \u03b3\u2032(\u03b1))). The kernel of (\u03be, \u03b6) is the tree \u03ba = \u03c3(\u03b1, \u03b1). Then (a) above position \u03b5 of \u03ba, H inserts no \u03b3 (for \u03be) and one \u03b3\u2032 (for \u03b6) and there exists one (trivial) ordering of this insertion, (b) above position 1 of \u03ba, H inserts one \u03b3 (for \u03be) and one \u03b3\u2032 (for \u03b6) and there are two orderings of these insertions, and (c) above position 2 of \u03ba, H inserts two \u03b3s (for \u03be) and one \u03b3\u2032 (for \u03b6) and there are three orderings of these insertions. Multiplying up the number of all such orderings yields [[H]]tt(\u03be, \u03b6) = 2 \u00b7 3 = 6. Figure 10.12 illustrates two derivations d1, d2 \u2208 RTH(\u03be, \u03b6), the [\u03a3\u03a8]-trees \u03b71 = \u03c0(d1) and \u03b72 = \u03c0(d2), and the trees \u03be, \u03b6 and \u03ba. The brackets indicate the regions where reordering is possible without changing \u03be and \u03b6.\nExample 10.13.2. We have noted that, if H is finite-input, then [[H]]tt is supp-i-finite. In this example we show that the reverse direction does not hold, even if H is chain-free. That means, there exists a chain-free wpb H such that [[H]]tt is supp-i-finite and H is not finite-input. We let \u03a3 = {\u03b3(1), \u03b1(0)} and \u03a8 = {\u03b2(0)}. We consider the ring Intmod4 = ({0, 1, 2, 3},+4, \u00b74, 0, 1) as defined in Example 2.6.9(5) and the chain-free (\u03a3,\u03a8, Intmod4)-wpb H with set {A,B} of nonterminals, A as only initial nonterminal, and the rules:\nr1 = (A\u2192 [\u03b3, \u03b5](B)) r2 = (B \u2192 [\u03b3, \u03b5](A)) r3 = (A\u2192 [\u03b1, \u03b2])\nand wt(r1) = wt(r2) = 2 and wt(r3) = 1. Obviously, T\u03a8 = {\u03b2} and the set {\u03be \u2208 T\u03a3 | [[H]]tt(\u03be, \u03b2) 6= 0} = {\u03b1} is finite. Hence [[H]]tt is supp-i-finite. Moreover,H is not finite-input, because {\u03be \u2208 T\u03a3 | RTH(\u03be, \u03b2) 6= \u2205} = {\u03b3n\u03b1 | n \u2208 N} is infinite.\n10.13. CLOSURE UNDER WEIGHTED PROJECTIVE BIMORPHISMS 227\nBy definition, each wbp H is a particular wrtg. Thus H has two semantics: the weighted tree language [[H]] and the weighted tree transformation [[H]]tt. The next lemma shows that, under some additional conditions, the equality of the weighted tree languages of two wpb implies the equality of their weighted tree transformations.\nLemma 10.13.3. Let H and H\u2032 be (\u03a3,\u03a8,B)-wpb such that both H and H\u2032 are finite-derivational or B is \u03c3-complete. If [[H]] = [[H\u2032]], then [[H]]tt = [[H\u2032]]tt.\nProof. Let us assume that [[H]] = [[H\u2032]] and let \u03be \u2208 T\u03a3 and \u03b6 \u2208 T\u03a8. Then\n[[H]]tt(\u03be, \u03b6) = \u2211\u2295\nd\u2208RTH(\u03be,\u03b6)\nwtH(d) = \u2295\n\u03b7\u2208T[\u03a3\u03a8]: \u03c01(\u03b7)=\u03be,\u03c02(\u03b7)=\u03b6\n\u2211\u2295\nd\u2208RTH(\u03b7)\nwtH(d) = \u2295\n\u03b7\u2208T[\u03a3\u03a8]: \u03c01(\u03b7)=\u03be,\u03c02(\u03b7)=\u03b6\n[[H]](\u03b7) =\n\u2295\n\u03b7\u2208T[\u03a3\u03a8]: \u03c01(\u03b7)=\u03be,\u03c02(\u03b7)=\u03b6\n[[H\u2032]](\u03b7) = \u2295\n\u03b7\u2208T[\u03a3\u03a8]: \u03c01(\u03b7)=\u03be,\u03c02(\u03b7)=\u03b6\n\u2211\u2295\nd\u2208RTH\u2032(\u03b7)\nwtH\u2032(d) = \u2211\u2295\nd\u2208RTH\u2032(\u03be,\u03b6)\nwtH\u2032(d) = [[H \u2032]]tt(\u03be, \u03b6),\nwhere the second and the sixth equality hold because (10.42) is a partitioning (of RTH(\u03be, \u03b6) and RTH\u2032(\u03be, \u03b6), respectively), the fourth one holds by our assumption, and all other ones hold by definition.\n228 CHAPTER 10. CLOSURE PROPERTIES\nThe next example shows that the reverse of Lemma 10.13.3 does not hold.\nExample 10.13.4. We consider the ranked alphabets \u03a3 = {\u03b3(1), \u03b1(0)} and \u03a8 = {\u03b3\u2032(1), \u03b1(0)}. As weight algebra we consider the semiring Boole = (B,\u2228,\u2227, 0, 1).\nWe consider the two (\u03a3,\u03a8,Boole)-wpbH = (N,S,R,wt) andH\u2032 = (N,S,R\u2032, wt\u2032) withN = {A,B,C}, S = {A}, and the rules shown in the following table.\nrules of H: rules of H\u2032: A\u2192 [\u03b3, \u03b5](B) A\u2192 [\u03b5, \u03b3\u2032](B) B \u2192 [\u03b5, \u03b3\u2032](C) B \u2192 [\u03b3, \u03b5](C) C \u2192 [\u03b1, \u03b1] C \u2192 [\u03b1, \u03b1]\nand each rule has weight 1. Thus, H and H\u2032 differ in the order in which they read the input symbol \u03b3 and write the output symbol \u03b3\u2032. For every \u03be \u2208 T\u03a3 and \u03b6 \u2208 T\u03a8 we have\n[[H]]tt(\u03be, \u03b6) = 1 iff \u03be = \u03b3(\u03b1) and \u03b6 = \u03b3\u2032(\u03b1) iff [[H\u2032]]tt(\u03be, \u03b6) = 1 .\nThus [[H]]tt = [[H\u2032]]tt. However,\nsupp([[H]]) = {[\u03b3, \u03b5][\u03b5, \u03b3\u2032]([\u03b1, \u03b1])} and supp([[H]]) = {[\u03b5, \u03b3\u2032][\u03b3, \u03b5]([\u03b1, \u03b1])}\nand thus [[H]] 6= [[H\u2032]].\nThe next lemma shows that, under certain conditions, we can transform a wpb into an equivalent chain-free wpb (with respect to the computed weighted tree transformations). This lemma is based on the corresponding lemma for wrtg (cf. Lemma 9.2.1) which, in its turn, is based on the corresponding lemma for wcfg (cf. Theorem 8.2.6).\nLemma 10.13.5. (cf. [FV22b, Lm. 4.1]) Let B be a semiring and H be a (\u03a3,\u03a8,B)-wpb such that H is finite-derivational or B is \u03c3-complete. Then the following three statements hold.\n(1) There exists a chain-free (\u03a3,\u03a8,B)-wpb H\u2032 such that [[H]]tt = [[H\u2032]]tt. (2) If H is finite-derivational, then we can construct a chain-free (\u03a3,\u03a8,B)-wpb H\u2032 such that [[H]]tt =\n[[H\u2032]]tt. (3) In both statements (1) and (2) the following holds: if H is finite-input (resp. finite-output), then H\u2032 is finite-input (resp. finite-output).\nProof. Proof of (1): By Lemma 9.2.1(3), there exists an alphabetic and chain-free ([\u03a3\u03a8],B)-wrtg H\u2032 such that [[H]] = [[H\u2032]]. Then, by definition of wpb, H\u2032 is a chain-free (\u03a3,\u03a8,B)-wpb, and by Lemma 10.13.3 we have [[H]]tt = [[H\u2032]]tt.\nProof of (2): Now let H be finite-derivational. Then, Lemma 9.2.1(3) is constructive and hence we can construct a chain-free (\u03a3,\u03a8,B)-wpb H\u2032 such that [[H]]tt = [[H\u2032]]tt.\nProof of (3): By analysing the proof of Theorem 8.2.6 (on which the proof of Lemma 9.2.1(3) is based), it is easy to see that, if H is finite-input (resp. finite-output), then H\u2032 is finite-input (resp. finite-output)."
        },
        {
            "heading": "10.13.2 Split",
            "text": "Next we characterize the weighted tree language [[G]] of a wrtg G in terms of the image of a characteristic mapping under a weighted projective bimorphism. For this we introduce the concept of skeleton alphabet as follows. We define the skeleton alphabet of \u03a3, denoted by [\u03a3], to be the ranked alphabet with\n[\u03a3](k) =\n{ {[k]} if \u03a3(k) 6= \u2205\n\u2205 otherwise\n10.13. CLOSURE UNDER WEIGHTED PROJECTIVE BIMORPHISMS 229\nfor each k \u2208 N (i.e., [\u03a3](k) is a singleton or empty and [\u03a3](0) = {[0]}).\nLet G = (N,S,R,wt) be an arbitrary (\u03a3,B)-wrtg. We define a deterministic tree relabeling \u03b2 which, intuitively, maps each occurrence of rule r of G in a tree d \u2208 TR to the symbol of the skeleton alphabet which corresponds to the rank of r. Formally, we define \u03b2 = (\u03b2k | k \u2208 N) with \u03b2k : R(k) \u2192 [R](k) by\n\u03b2k(r) = [k] for each r \u2208 R (k) .\nFor each d \u2208 TR we call \u03b2(d) the skeleton of d. We note that, for every \u03be \u2208 T\u03a3, the T[R]-indexed family (\u03b2\u22121(b) \u2229 RTG(\u03be) | b \u2208 T[R]) is a partitioning of RTG(\u03be). Moreover, for every \u03be \u2208 T\u03a3 and b \u2208 T[R], the set \u03b2\u22121(b) \u2229RTG(\u03be) is finite.\nLemma 10.13.6. (cf. [FV22b, Lm. 4.3] for the trivial storage type) Let G = (N,S,R,wt) be an alphabetic (\u03a3,B)-wrtg such that G is finite-derivational or B is \u03c3-complete. Then we can construct a chain-free ([R],\u03a3,B)-wpbH such that (a)H is finite-output, (b) H is finite-input if G is finite-derivational, and (c) [[G]] = [[H]]tt(\u03c7(T[R])).\nProof. We construct the chain-free ([R],\u03a3,B)-wpb H = (N,S,R\u2032, wt\u2032) as follows.\n\u2022 For every r = (A\u2192 \u03c3(A1, . . . , Ak)) in R, the rule r\u2032 = (A\u2192 [[k], \u03c3](A1, . . . , Ak)) is in R\u2032 and wt\u2032(r\u2032) = wt(r). \u2022 For every r = (A\u2192 B) in R, the rule r\u2032 = (A\u2192 [[1], \u03b5](B)) is in R\u2032 and wt\u2032(r\u2032) = wt(r).\nWe continue with introducing some useful mappings. We define the deterministic (R\u2032, R)-tree relabeling \u03d5 = (\u03d5k | k \u2208 N) for every k \u2208 N and r\u2032 \u2208 R\u2032(k) by\n\u03d5k(r \u2032) =\n{ A\u2192 \u03c3(A1, . . . , Ak) if r\u2032 = (A\u2192 [[k], \u03c3](A1, . . . , Ak))\nA\u2192 B if r\u2032 = (A\u2192 [[1], \u03b5](B))\nwhere in the second case k = 1. Clearly, the deterministic tree relabeling \u03d5 : TR\u2032 \u2192 TR is bijective. Moreover,\nfor each d \u2208 RTH(N,T[[R]\u03a3]), we have: wtH(d) = wtG(\u03d5(d)) (10.43)\nThis can be proved easily by induction on (RTH(N,T[[R]\u03a3]),\u227a) where\n\u227a=\u227aR\u2032 \u2229 (RTH(N,T[[R]\u03a3])\u00d7 RTH(N,T[[R]\u03a3])) .\nObviously, \u227a is well-founded and min\u227a(RTH(N,T[[R]\u03a3])) = (R \u2032)(0).\nAlso, for every b \u2208 T[R] and \u03be \u2208 T\u03a3, we have \u03d5(RTH(b, \u03be)) = \u03b2 \u22121(b) \u2229 RTG(\u03be). Thus, for every b \u2208 T[R] and \u03be \u2208 T\u03a3, the mapping \u03d5b,\u03be : RTH(b, \u03be) \u2192 \u03b2 \u22121(b) \u2229 RTG(\u03be) defined by \u03d5b,\u03be = \u03d5|RTH(b,\u03be) is bijective. Figure 10.13 illustrates the connection between the mappings \u03b2 and \u03d5.\nNow we prove (a), (b), and (c). Property (a) holds, because R\u2032 = (R\u2032)r and thus H is finite-output (and hence, [[H]]tt is supp-o-finite).\nTo see Property (b), we assume that G is finite-derivational and let \u03be \u2208 T\u03a3. Then the set RTG(\u03be) is finite. Since the family (\u03b2\u22121(b)\u2229RTG(\u03be) | b \u2208 T[R]) is a partitioning of the finite set RTG(\u03be), the set {b \u2208 T[R] | \u03b2\n\u22121(b) \u2229 RTG(\u03be) 6= \u2205} is also finite. Since \u03d5b,\u03be is bijective, also the set {b \u2208 T[R] | RTH(b, \u03be) 6= \u2205} is finite. It means that H is finite-input, which proves Property (b).\nNow we turn to the proof of Property (c). Obviously, H is chain-free and hence finite-derivational; thus, [[H]]tt is well defined. Moreover, if G is finite-derivational, then H is finite-input (due to Property (b)), and thus [[H]]tt is supp-i-finite. Hence [[H]]tt(\u03c7(T[R])) is well defined.\nNow we prove that [[G]] = [[H]]tt(\u03c7(T[R])). For this, let \u03be \u2208 T\u03a3. Then\n( [[H]]tt(\u03c7(T[R])) ) (\u03be) = \u2211\u2295\nb\u2208T[R]\n\u03c7(T[R])(b)\u2297 [[H]] tt(b, \u03be)\n(because [[H]]tt is supp-i-finite if B is not \u03c3-complete)\n= \u2211\u2295\nb\u2208T[R]\n[[H]]tt(b, \u03be)\n= \u2211\u2295\nb\u2208T[R]\n\u2295\nd\u2032\u2208RTH(b,\u03be)\nwtH(d \u2032) (because H is finite-derivational)\n= \u2211\u2295\nb\u2208T[R]\n\u2295\nd\u2032\u2208RTH(b,\u03be)\nwtG(\u03d5b,\u03be(d \u2032)) (by (10.43) and definition of \u03d5b,\u03be)\n= \u2211\u2295\nb\u2208T[R]\n\u2295\nd\u2208\u03b2\u22121(b)\u2229RTG(\u03be)\nwtG(d) (since \u03d5b,\u03be is bijective)\n= \u2211\u2295\nd\u2208RTG(\u03be)\nwtG(d) (because (\u03b2 \u22121(b) \u2229 RTG(\u03be) | b \u2208 T[R]) is a partitioning of RTG(\u03be))\n= [[G]](\u03be). (because G is finite-derivational or B is \u03c3-complete)"
        },
        {
            "heading": "10.13.3 Closure of weighted projective bimorphisms under composition",
            "text": "In this subsection we prove that weighted projective bimorphisms are closed under composition. For the proof, we introduce a notation. For every (\u03a3,\u03a8,B)-bimorphism H = (N,S,R,wt) and N \u2032 \u2286 N , we let\nRTH(N \u2032) =\n\u22c3\n\u03b7\u2208T[\u03a3\u03a8]\nRTH(N \u2032, \u03b7).\n10.13. CLOSURE UNDER WEIGHTED PROJECTIVE BIMORPHISMS 231\nTheorem 10.13.7. [FV22b, Thm. 4.2] Let \u03a3, \u03a8, and \u2206 be ranked alphabets and B be a commutative semiring. Let H1 be a (\u03a3,\u03a8,B)-wpb and H2 be a (\u03a8,\u2206,B)-wpb such that both H1 and H2 are finitederivational or B is \u03c3-complete. Moreover, let [[H1]] tt be supp-o-finite or [[H2]] tt be supp-i-finite or B is \u03c3-complete. Then the following three statements hold. (1) There exists a (\u03a3,\u2206,B)-wpb H such that [[H]]tt = [[H1]]tt; [[H2]]tt. (2) If H1 and H2 are finite-derivational, then we can construct a finite-derivational (\u03a3,\u2206,B)-wpb H\nsuch that [[H]]tt = [[H1]]tt; [[H2]]tt. (3) In both statements (1) and (2) the following holds. If H1 and H2 are finite-input, then H is finite-\ninput.\nProof. Proof of (1). Let H1 = (N1, S1, R1, wt1) and H2 = (N2, S2, R2, wt2). Since H1 and H2 are finitederivational or B is \u03c3-complete, the weighted tree transformations [[H1]]tt and [[H2]]tt are well defined. Moreover, since [[H1]]tt is supp-o-finite or [[H2]]tt is supp-i-finite or B is \u03c3-complete, the weighted tree transformation [[H1]]tt; [[H2]]tt is well defined. By Lemma 10.13.5(1) we can assume that H1 and H2 are chain-free.\nWe define the (\u03a3,\u2206,B)-wpb H = (N,S,R,wt) by using a modification of the usual product construction for tree transducers [Eng75b, Bak79] and for weighted tree transducers in [EFV02]. We have to use a modification for the following reason. Before producing an output symbol \u03c8 \u2208 \u03a8, the wpb H1 can execute a sequence s1 of r\u03b5-rules on some input tree \u03be \u2208 T\u03a3. Also, before reading \u03c8, the wpb H2 can execute a sequence s2 of \u03b5w-rules, thereby producing a part of some output tree \u03b6 \u2208 T\u2206. If we combine each rule in the sequence s1 with each rule in the sequence s2 into one rule for H, then we introduce a number of artificial orderings for the applications of the rules in s1 and s2. As a consequence, for one single summand in ([[H1]]tt; [[H2]]tt)(\u03be, \u03b6), there will be multiple corresponding summands in [[H]]tt(\u03be, \u03b6). Thus, in order to establish a weight balance between [[H]]tt(\u03be, \u03b6) and ([[H1]]tt; [[H2]]tt)(\u03be, \u03b6), we have to forbid artificial orderings in the rule trees of H.\nFor this purpose, we introduce auxiliary control nonterminals as follows. Before H simulates the combination of a rule r1 = (A1 \u2192 [\u03c3, \u03c8](A11, . . . , A1k)) in R w1 and of a rule r2 = (A2 \u2192 [\u03c8, \u03b4](A21, . . . , A2k)) in Rr2 , it first simulates rules in R r\u03b5 1 (using states of the form Lr1, r2M), and second it simulates rules in R\u03b5w2 (using states of the form \u3008r1, r2\u3009).\nFormally, we define H as follows. We let\nN ={Lr1, r2M | r1 \u2208 R1, r2 \u2208 R2} \u222a {\u3008r1, r2\u3009 | r1 \u2208 R w 1 , r2 \u2208 R2}\n\u222a {(r1, r2) | (r1, r2) \u2208 R w 1 \u00d7R r 2 , out(r1) = inp(r2)} and\nS ={Lr1, r2M \u2208 Q | lhs(r1) \u2208 S1, lhs(r2) \u2208 S2} .\nThe set R and the weight mapping wt are defined by the following five cases.\n1. For every r1 = (A1 \u2192 [\u03c3, \u03b5](A\u20321)) in R r\u03b5 1 , r \u2032 1 \u2208 R1 with lhs(r \u2032 1) = A \u2032 1, and r2 \u2208 R2, the rule\nr = (Lr1, r2M\u2192 [\u03c3, \u03b5](Lr \u2032 1, r2M))\nis in R and wt(r) = wt1(r1). 2. For every r1 \u2208 R w1 and r2 \u2208 R2, the rule\nr = (Lr1, r2M\u2192 \u3008r1, r2\u3009)\nis in R and wt(r) = 1. 3. For every r1 \u2208 R w1 , r2 = (A2 \u2192 [\u03b5, \u03c8](A \u2032 2)) in R \u03b5w 2 , and r \u2032 2 \u2208 R2 with lhs(r \u2032 2) = A \u2032 2, the rule\nr = (\u3008r1, r2\u3009 \u2192 [\u03b5, \u03c8](\u3008r1, r \u2032 2\u3009))\nis in R and wt(r) = wt2(r2).\n232 CHAPTER 10. CLOSURE PROPERTIES\n4. For every r1 \u2208 R w1 and r2 \u2208 R r 2 , the rule\nr = (\u3008r1, r2\u3009 \u2192 (r1, r2))\nis in R and wt(r) = 1. 5. For every r1 = (A1 \u2192 [\u03c3, \u03c8](A11, . . . , A1k)) in R w1 , r2 = (A2 \u2192 [\u03c8, \u03b4](A21, . . . , A2k)) in Rr2 , r11, . . . , r1k \u2208 R1 with lhs(r1j) = A1j (j \u2208 [k]), and r21, . . . , r2k \u2208 R2 with lhs(r2j) = A2j (j \u2208 [k]), the rule\nr = ((r1, r2)\u2192 [\u03c3, \u03b4](Lr11, r21M, . . . , Lr1k, r2kM))\nis in R and wt(r) = wt1(r1)\u2297 wt2(r2).\nClearly, each rule r produced in Cases 1-4 has rank 1. Next, we mention that, for each d \u2208 RTH(Lr1, r2M,T[\u03a3\u03a8]) with ri \u2208 Ri for i = {1, 2} and each leaf w \u2208 pos(d) with w = i1 . . . im for some m \u2265 1, the sequence of cases which has produced d(i1) . . . d(im) \u2208 R\u2217, is contained in (1\u211323u45)+ for some \u2113, u \u2208 N (see Figure 10.14).\nWe also note that H is not chain-free due to rules of type 2 and 4. However, it is easy to see that, if H1 and H2 are finite-derivational, then H is finite-derivational, because rules of type 2 and 4 cannot occur arbitrarily often in rule trees. Hence [[H]]tt is well defined.\nFor the rest of the proof we need some preparation. We define a mapping h which retrieves from a rule tree in RTH(N,T[\u03a3\u2206]) the intermediate tree in T\u03a8. Formally, we define the mapping h : RTH(N,T[\u03a3\u2206])\u2192 T\u03a8 by induction on (RTH(N,T[\u03a3\u2206]),\u227a) where\n\u227a=\u227aR \u2229 (RTH(N,T[\u03a3\u2206])\u00d7 RTH(N,T[\u03a3\u2206])) .\nObviously, \u227a is well-founded and min\u227a(RTH(N,T[\u03a3\u2206]) = R (0).\n10.13. CLOSURE UNDER WEIGHTED PROJECTIVE BIMORPHISMS 233\nLet d = r(d1, . . . , dk) be in RTH(N,T[\u03a3\u2206]) with r \u2208 R and d1, . . . , dk \u2208 RTH(N,T[\u03a3\u2206]). Then we let\nh(r(d1, . . . , dk)) =    h(d1) if r is obtained by Cases 1, 2, 3, or 4 \u03c8(h(d1), . . . , h(dk)) if r is obtained by Case 5,\nlhs(r) = (r1, r2) for some r1 and r2, and \u03c8 = out(r1) .\nWe define the set NL.M = {Lr1, r2M | r1 \u2208 R1, r2 \u2208 R2}. Moreover, we define the mapping\n\u03d5 : RTH(NL.M,T[\u03a3\u2206])\u2192 RTH1(N1,T\u03a3)\u00d7 RTH2(N2,T\u03a8)\nby induction on (RTH(NL.M,T[\u03a3\u2206]),\u227a) where\n\u227a=\u227a+R \u2229(RTH(NL.M,T[\u03a3\u2206])\u00d7 RTH(NL.M,T[\u03a3\u2206]))\nas follows. Obviously, \u227a is well-founded and min\u227a(RTH(NL.M,T[\u03a3\u2206])) = {(A \u2192 \u03be) \u2208 R | A \u2208 NL.M, \u03be \u2208 [\u03a3\u2206](0)}.)\nLet d \u2208 RTH(NL.M,T[\u03a3\u2206]). Then there exist r1 \u2208 R1, r2 \u2208 R2, \u03be \u2208 T\u03a3, and \u03b6 \u2208 T\u2206 such that d \u2208 RTH(Lr1, r2M, \u03be, \u03b6).\nDue to the definition of rules ofH, the rule tree d has the form shown in Figure 10.14 for some \u2113, u \u2208 N, rules rji , symbols \u03c3j and \u03c8j (each of appropriate type which can be read off easily from the definition of R), as well as rule (r\u2113+11 , r u+1 2 )\u2192 [\u03c3, \u03b4](Lr11, r21M, . . . , Lr1k, r2kM) in R, and d1, . . . , dk \u2208 RTH(NL.M,T[\u03a3\u2206]); moreover, r1 = r 1 1 and r2 = r 1 2 .\nThen\n\u2022 there exists a \u03c8 \u2208 \u03a8(k) such that h(d) = \u03c8(h(d1), . . . , h(dk)), \u2022 \u03be = \u03c3(\u03c01(d1), . . . , \u03c0(dk)), \u2022 \u03b6 = \u03b4(\u03c02(d1), . . . , \u03c02(dk)), and \u2022 di \u2208 RTH(Lr1i, r2iM, \u03c01(di), \u03c02(di)) for each i \u2208 [k].\nWe define \u03d5(d) = (t1, t2), where t1 and t2 are shown in Figure 10.15 and where for each i \u2208 [k] we let (t1i, t2i) = \u03d5(di).\nNext we introduce a kind of typing for elements of RTH(NL.M,T[\u03a3\u2206]) and for elements of RTH1(N1,T\u03a3) \u00d7 RTH2(N2,T\u03a8). Formally, let r1 \u2208 R1, r2 \u2208 R2, \u03be \u2208 T\u03a3, \u03b8 \u2208 T\u03a8, and \u03b6 \u2208 T\u2206. We define the following two sets:\nRTH(Lr1, r2M, \u03be, \u03b8, \u03b6) = {d \u2208 RTH(Lr1, r2M, \u03be, \u03b6) | h(d) = \u03b8}\nRTH1\u00d7H2(r1, r2, \u03be, \u03b8, \u03b6) = {(t1, t2) \u2208 RTH1(N1, \u03be, \u03b8)\u00d7 RTH2(N2, \u03b8, \u03b6) | t1(\u03b5) = r1, t2(\u03b5) = r2}.\nThen the families\n(RTH(Lr1, r2M, \u03be, \u03b8, \u03b6) | r1, r2, \u03be, \u03b8, \u03b6 as above)\n(RTH1\u00d7H2(r1, r2, \u03be, \u03b8, \u03b6) | r1, r2, \u03be, \u03b8, \u03b6 as above)\nare partitionings of RTH(NL.M,T[\u03a3\u2206]) and of RTH1(N1,T\u03a3) \u00d7 RTH2(N2,T\u03a8), respectively. One might say that an element d \u2208 RTH(Lr1, r2M, \u03be, \u03b8, \u03b6) and an element (t1, t2) \u2208 RTH1\u00d7H2(r1, r2, \u03be, \u03b8, \u03b6) have type (r1, r2, \u03be, \u03b8, \u03b6).\nIt is easy to see that \u03d5 ( RTH(Lr1, r2M, \u03be, \u03b8, \u03b6) ) \u2286 RTH1\u00d7H2(r1, r2, \u03be, \u03b8, \u03b6). Thus, intuitively, \u03d5 is type\npreserving. Based on this property, we define the mapping\n\u03d5r1,r2,\u03be,\u03b8,\u03b6 : RTH(Lr1, r2M, \u03be, \u03b8, \u03b6)\u2192 RTH1\u00d7H2(r1, r2, \u03be, \u03b8, \u03b6)\nfor each d \u2208 RTH(Lr1, r2M, \u03be, \u03b8, \u03b6) by \u03d5r1,r2,\u03be,\u03b8,\u03b6(d) = \u03d5(d).\nWe show that each mapping \u03d5r1,r2,\u03be,\u03b8,\u03b6 is injective. For this, let d and d \u2032 be different trees with\n\u03d5r1,r2,\u03be,\u03b8,\u03b6(d) = (t1, t2) and \u03d5r1,r2,\u03be,\u03b8,\u03b6(d \u2032) = (t\u20321, t \u2032 2). Then there exists a position w \u2208 pos(d) \u2229 pos(d \u2032) with d(w) 6= d\u2032(w). Since the nonterminals of H encode rules of H1 and H2, this yields that the rules in t1 and t \u2032 1 or the rules in t2 and t \u2032 2 corresponding to d(w) and d\n\u2032(w), respectively, are different. Hence (t1, t2) 6= (t\u20321, t \u2032 2), i.e., \u03d5r1,r2,\u03be,\u03b8,\u03b6 is injective.\nNow let (t1, t2) \u2208 RTH1\u00d7H2(r1, r2, \u03be, \u03b8, \u03b6). Since each t1 \u2208 RTH1(N1) and each t2 \u2208 RTH2(N2) have the form as shown in Figure 10.15, we can combine t1 and t2 into a d \u2208 RTH(Lr1, r2M, \u03be, \u03b8, \u03b6) shown in Figure 10.14. For this d we have \u03d5r1,r2,\u03be,\u03b8,\u03b6(d) = (t1, t2), hence each mapping \u03d5r1,r2,\u03be,\u03b8,\u03b6 is also surjective.\nMoreover, by analysing the weights of the rules shown in Figure 10.14 with those shown in Figure 10.15 and taking the commutativity of B into account, we easily obtain that\nwtH(d) = wtH1(t1)\u2297 wtH2(t2)\nfor each d \u2208 RTH(Lr1, r2M, \u03be, \u03b8, \u03b6), where \u03d5r1,r2,\u03be,\u03b8,\u03b6(d) = (t1, t2). Thus, each \u03d5r1,r2,\u03be,\u03b8,\u03b6 is a weight preserving bijection.\nNow we can finish the proof of (a) as follows. For every \u03be \u2208 T\u03a3 and \u03b6 \u2208 T\u2206, we have\n([[H1]] tt; [[H2]] tt)(\u03be, \u03b6) = \u2211\u2295\n\u03b8\u2208T\u03a8\n[[H1]] tt(\u03be, \u03b8)\u2297 [[H2]] tt(\u03b8, \u03b6) (by (2.35))\n= \u2211\u2295\n\u03b8\u2208T\u03a8\n\u2211\u2295\nt1\u2208RTH1(\u03be,\u03b8)\n\u2211\u2295\nt2\u2208RTH2(\u03b8,\u03b6)\nwtH1(t1)\u2297 wtH2(t2) (by distributivity)\n= \u2211\u2295\n\u03b8\u2208T\u03a8\n\u2295\nr1\u2208R1: lhs(r1)\u2208S1\n\u2295\nr2\u2208R2: lhs(r2)\u2208S2\n\u2211\u2295\nt1\u2208RTH1(N1,\u03be,\u03b8): t1(\u03b5)=r1\n\u2211\u2295\nt2\u2208RTH2(N2,\u03b8,\u03b6): t2(\u03b5)=r2\nwtH1(t1)\u2297 wtH2(t2)\n= \u2211\u2295\n\u03b8\u2208T\u03a8\n\u2295\nr1\u2208R1: lhs(r1)\u2208S1\n\u2295\nr2\u2208R2: lhs(r2)\u2208S2\n\u2211\u2295\n(t1,t2)\u2208RTH1\u00d7H2(r1,r2,\u03be,\u03b8,\u03b6)\nwtH1(t1)\u2297 wtH2(t2)\n= \u2211\u2295\n\u03b8\u2208T\u03a8\n\u2295\nr1\u2208R1: lhs(r1)\u2208S1\n\u2295\nr2\u2208R2: lhs(r2)\u2208S2\n\u2211\u2295\nd\u2208RTH(Lr1,r2M,\u03be,\u03b8,\u03b6)\nwtH(d)\n(because \u03d5r1,r2,\u03be,\u03b8,\u03b6 is a weight preserving bijection )\n( from RTH(Lr1, r2M, \u03be, \u03b8, \u03b6) to RTH1\u00d7H2(r1, r2, \u03be, \u03b8, \u03b6))\n= \u2211\u2295\n\u03b8\u2208T\u03a8\n\u2295\nr1\u2208R1: lhs(r1)\u2208S1\n\u2295\nr2\u2208R2: lhs(r2)\u2208S2\n\u2211\u2295\nd\u2208RTH(N,\u03be,\u03b6): h(d)=\u03b8\nlhs(d(\u03b5))=Lr1,r2M\nwtH(d)\n10.13. CLOSURE UNDER WEIGHTED PROJECTIVE BIMORPHISMS 235\n= \u2211\u2295\n\u03b8\u2208T\u03a8\n\u2211\u2295\nd\u2208RTH(\u03be,\u03b6): h(d)=\u03b8\nwtH(d) = \u2211\u2295\nd\u2208RTH(\u03be,\u03b6)\nwtH(d) = [[H]] tt(\u03be, \u03b6) .\nProof of (2): Now let H1 and H2 be finite-derivational. Then, by Lemma 10.13.5(2), we can even construct equivalent chain-free wpb. Consequently, the definition of H, as it is given in the proof of (1), is constructive and H is finite-derivational. Moreover, by the proof of (1), we have [[H]]tt = [[H1]]tt; [[H2]]tt.\nProof of (3). For this we assume that H1 and H2 are finite-input. Let \u03b6 \u2208 T\u2206. Since H1 and H2 are finite-input, the set A = {\u03b8 \u2208 T\u03a8 | RTH2(\u03b8, \u03b6) 6= \u2205} is finite, and for every \u03b8 \u2208 A the set B = {\u03be \u2208 T\u03a3 | RTH1(\u03be, \u03b8) 6= \u2205} is finite. Hence the set C = {\u03be \u2208 T\u03a3 | (\u2203\u03b8 \u2208 T\u03a8) : RTH1(\u03be, \u03b8) 6= \u2205 \u2227 RTH2(\u03b8, \u03b6) 6= \u2205} is finite.\nNext we show that {\u03be \u2208 T\u03a3 | RTH(\u03be, \u03b6) 6= \u2205} \u2286 C. For this, let \u03be \u2208 T\u03a3 and d \u2208 RTH(\u03be, \u03b6). Then there exists Lr1, r2M \u2208 S such that d \u2208 RTH(Lr1, r2M, \u03be, h(d), \u03b6). Since \u03d5r1,r2,\u03be,h(d),\u03b6 is bijective, there exist t1 \u2208 RTH1(N1, \u03be, h(d)) and t2 \u2208 RTH2(N2, h(d), \u03b6). Since lhs(ri) \u2208 Si for i \u2208 {1, 2}, we have t1 \u2208 RTH1(\u03be, h(d)) and t2 \u2208 RTH2(h(d), \u03b6). Hence for h(d) \u2208 T\u03a8 we have RTH1(\u03be, h(d)) 6= \u2205 and RTH2(h(d), \u03b6) 6= \u2205, which means that \u03be \u2208 C.\nSince {\u03be \u2208 T\u03a3 | RTH(\u03be, \u03b6) 6= \u2205} \u2286 C and C is finite, also {\u03be \u2208 T\u03a3 | RTH(\u03be, \u03b6) 6= \u2205} is finite. Hence H is finite-input."
        },
        {
            "heading": "10.13.4 Merge",
            "text": "Here we express the application of a weighted projective bimorphism to a characteristic mapping in terms of a weighted regular tree grammar. Since this process is a kind of inverse to the split in Subsection 10.13.2, we call it merge. We recall that [\u2206] denote the skeleton alphabet of \u2206, defined on page 228.\nLemma 10.13.8. (cf. [FV19, Lm. 4.4]) Let H be a chain-free ([\u2206],\u03a8,B)-wpb such that H is finiteinput or B is \u03c3-complete. Then we can construct an alphabetic (\u03a8,B)-wrtg G such that (a) G is finitederivational if H is finite-input and (b) [[H]]tt(\u03c7(T[\u2206])) = [[G]].\nProof. Let H = (N,S,R,wt). We recall that H is a chain-free and alphabetic ([[\u2206]\u03a8],B)-wrtg. We construct the (\u03a8,B)-wrtg G = (N \u2032, S\u2032, R\u2032, wt\u2032) as follows. We let N \u2032 = R and S\u2032 = {r \u2208 R | lhs(r) \u2208 S}. The set R\u2032 of rules and the weight mapping wt\u2032 are defined as follows.\n1. For every r = (A \u2192 [[k], \u03c8](A1, . . . , Ak)) in R and every r1, . . . , rk \u2208 R with lhs(ri) = Ai for each i \u2208 [k], the rule r\u2032 = (r \u2192 \u03c8(r1, . . . , rk)) is in R\u2032 and wt\u2032(r\u2032) = wt(r). 2. For every r = (A\u2192 [[1], \u03b5](A1)) in R and every r1 \u2208 R with lhs(r1) = A1, the rule r\u2032 = (r \u2192 r1) is in R\u2032 and wt\u2032(r\u2032) = wt(r). 3. For every r = (A\u2192 [\u03b5, \u03c8](A1)) in R and every r1 \u2208 R with lhs(r1) = A1, the rule r\u2032 = (r \u2192 \u03c8(r1)) is in R\u2032 and wt\u2032(r\u2032) = wt(r).\nObviously, G is alphabetic.\nBefore we prove Properties (a) and (b) we need some preparations. We define the mapping \u03b2\u2032 : TR\u2032 \u2192 T[\u2206] by induction on TR\u2032 for each r \u2032(d\u20321, . . . , d \u2032 k) \u2208 TR\u2032 as follows:\n\u03b2\u2032(r\u2032(d\u20321, . . . , d \u2032 k)) =    [k](\u03b2\u2032(d\u20321), . . . , \u03b2 \u2032(d\u2032k)) if r \u2032 is defined by 1. [1](\u03b2\u2032(d\u20321)) if r\n\u2032 is defined by 2. \u03b2\u2032(d\u20321) if r \u2032 is defined by 3.\nIn other words, if the terminal symbol in the right-hand side of lhs(r\u2032) has the form [[k], \u03c8] or [[1], \u03b5], then \u03b2\u2032 outputs the terminal symbol [k] and [1], respectively; if the terminal symbol in the right-hand side of lhs(r\u2032) has the form [\u03b5, \u03c8], then \u03b2\u2032 does not output any terminal symbol.\n(This \u03b2\u2032 is a modification of the mapping \u03b2 defined on page 229.) For instance, if \u03b2\u2032 is applied to the right tree in Figure 10.17, then the left tree in Figure 10.16 is obtained.\nLastly, we define the relation\n\u227a=\u227aR \u2229 ( RTH(N,T[[\u2206]\u03a8])\u00d7 RTH(N,T[[\u2206]\u03a8]) ) .\nIt is easy to see that \u227a is well-founded and min\u227a(RTH(N,T[[\u2206]\u03a8])) is the set of terminal rules of H.\nThen, by induction on (RTH(N,T[[\u2206]\u03a8]),\u227a), we define the mapping\n\u03d5 : RTH(N,T[[\u2206]\u03a8])\u2192 RTG(N \u2032,T\u03a8),\nas follows.\nLet d \u2208 RTH(N,T[[\u2206]\u03a8]). Then there exists r = (A \u2192 [\u03ba, \u03bb](A1, . . . , Ak)) in R and d1, . . . , dk \u2208 RTH(N,T[[\u2206]\u03a8]) such that d = r(d1, . . . , dk).\n\u2022 If \u03ba = [k] for some k 6= 1 and \u03bb \u2208 \u03a8, then we define\n\u03d5(r(d1, . . . , dk)) = (r \u2192 \u03bb(d1(\u03b5), . . . , dk(\u03b5))) ( \u03d5(d1), . . . , \u03d5(dk) ) .\n\u2022 If \u03ba = [1] and \u03bb = \u03b5, then k = 1 and we define\n\u03d5(r(d1)) = (r \u2192 d1(\u03b5)) ( \u03d5(d1) ) .\n\u2022 If \u03ba = \u03b5 and \u03bb \u2208 \u03a8, then k = 1 and we define\n10.13. CLOSURE UNDER WEIGHTED PROJECTIVE BIMORPHISMS 237\n\u03d5(r(d1)) = (r \u2192 \u03c8(d1(\u03b5))) ( \u03d5(d1) ) .\nThe following is easy to see:\nfor every b \u2208 T[\u2206] and \u03be \u2208 T\u03a8, we have \u03d5 ( RTH(N, b, \u03be) ) \u2286 RTG(N \u2032, \u03be) \u2229 (\u03b2\u2032)\u22121(b) .\nThus, for every b \u2208 T[\u2206] and \u03be \u2208 T\u03a8, we can define the mapping\n\u03d5b,\u03be : RTH(N, b, \u03be)\u2192 RTG(N \u2032, \u03be) \u2229 (\u03b2\u2032)\u22121(b)\nby letting \u03d5b,\u03be(d) = \u03d5(d) for each d \u2208 RTH(N, b, \u03be).\nNext we prove that \u03d5b,\u03be is bijective for every b \u2208 T[\u2206] and \u03be \u2208 T\u03a8. For this proof let us abbreviate \u03d5b,\u03be, RTH(N, b, \u03be), and RTG(N\n\u2032, \u03be) \u2229 (\u03b2\u2032)\u22121(b) by \u03d5, RTH, and RTG , respectively. To illustrate our arguments we show examples of b \u2208 T[\u2206] and \u03be \u2208 T\u03a8 in Figure 10.16, and examples of d \u2208 RTH and \u03d5(d) \u2208 RTG in Figure 10.17. First we observe that \u03d5 is shape preserving, i.e., for every d \u2208 RTH, we have pos(\u03d5(d)) = pos(d) (see Figure 10.17). Now let d1, d2 \u2208 RTH such that d1 6= d2. If pos(d1) 6= pos(d2), then \u03d5(d1) 6= \u03d5(d2) because \u03d5 is shape preserving. If pos(d1) = pos(d2), then there exists a w \u2208 pos(d1) such that d1(w) 6= d2(w). But then \u03d5(d1)(w) 6= \u03d5(d2)(w) because the left-hand side nonterminals in \u03d5(d1)(w) and \u03d5(d2)(w) are d1(w) and d2(w), respectively (see Figure 10.17). This means that \u03d5 is injective. Moreover, \u03d5 is surjective because, given a d \u2208 RTG , we can easily reobtain a d \u2208 RTH such that \u03d5(d) = d. In fact, d can be constructed by replacing, at each position u of d, the rule d(u) of G by the rule lhs(d(u)) of H (see again Figure 10.17).\nObviously, it also holds that \u03d5b,\u03be is weight preserving, i.e., wtH(d) = wtG(\u03d5b,\u03be(d)) for every d \u2208 RTH(N, b, \u03be). Then, for every b \u2208 T[\u2206] and \u03be \u2208 T\u03a8, there exists a weight preserving bijection \u03d5b,\u03be : RTH(b, \u03be)\u2192 RTG(\u03be) \u2229 (\u03b2\u2032)\u22121(b).\nNow we prove property (a). Assume that H is finite-input and let \u03be \u2208 T\u03a8. Then the set {b \u2208 T[\u2206] | RTH(b, \u03be) 6= \u2205} is finite. Since H is chain-free, it is also finite-derivational, i.e., the set RTH(b, \u03be) is finite for every b \u2208 T[\u2206]. Since \u03d5b,\u03be is bijective, we obtain that the set RTG(\u03be) \u2229 (\u03b2\n\u2032)\u22121(b) is finite for each b \u2208 T[\u2206] and thus the set {b \u2208 T[\u2206] | RTG(\u03be) \u2229 (\u03b2\n\u2032)\u22121(b) 6= \u2205} is also finite. Moreover, the family (RTG(\u03be) \u2229 (\u03b2\u2032)\u22121(b) | b \u2208 T[\u2206]) is a partitioning of RTG(\u03be). Thus, RTG(\u03be) is finite and hence G is finite-derivational. This proves (a).\nFinally we prove Property (b): [[H]]tt(\u03c7(T[\u2206])) = [[G]]. For this, let \u03be \u2208 T\u03a8. Then\n( [[H]]tt(\u03c7(T[\u2206])) ) (\u03be) = \u2211\u2295\nb\u2208T[\u2206]\n\u03c7(T[\u2206])(b)\u2297 [[H]] tt(b, \u03be)\n(by (2.34) because [[H]] is finite-input or B is \u03c3-complete)\n= \u2211\u2295\nb\u2208T[\u2206]\n[[H]]tt(b, \u03be)\n= \u2211\u2295\nb\u2208T[\u2206]\n\u2295\nd\u2208RTH(b,\u03be)\nwtH(d) (because H is chain-free and hence finite-derivational)\n= \u2211\u2295\nb\u2208T[\u2206]\n\u2295\nd\u2208RTG(\u03be)\u2229(\u03b2\u2032)\u22121(b)\nwtG(d) (because \u03d5b,\u03be is bijective and weight preserving)\n= \u2211\u2295\nd\u2208RTG(\u03be)\nwtG(d) = [[G]](\u03be) . (because G is finite-derivational if [[H]] is finite-input)"
        },
        {
            "heading": "10.13.5 Closure result for wrtg and wta",
            "text": "Finally we can prove the closure results for the sets Reg( ,B) and Rec( ,B).\n238 CHAPTER 10. CLOSURE PROPERTIES\nTheorem 10.13.9. (cf. [FV22b, Thm. 6.3]) Let B be a commutative semiring. Let G be a (\u03a3,B)-wrtg and H be a (\u03a3,\u03a8,B)-wpb such that ( both G and H are finite-derivational and H is finite-input ) or B is \u03c3-complete. Then the following two statements hold.\n(1) Then there exists a (\u03a8,B)-wrtg G\u2032 such that (a) G\u2032 is finite-derivational if G is finite-derivational and H is finite-input and (b) [[H]]tt([[G]]) = [[G\u2032]]. (2) If H is finite-derivational, then we can construct a (\u03a8,B)-wrtg G\u2032 such that (a) G\u2032 is finitederivational if G is finite-derivational and H is finite-input and (b) [[H]]tt([[G]]) = [[G\u2032]].\nProof. Proof of (1): Let G = (N,S,R,wt). By Lemma 9.2.2, we may assume that G is alphabetic. Then, by Lemma 10.13.6, we can construct a chain-free ([R],\u03a3,B)-wpb HG such that HG is finite-output, HG is finite-input if G is finite-derivational, and [[G]] = [[HG ]]tt(\u03c7(T[R])). In particular, since HG is chain-free, it is also finite-derivational. Then\n[[H]]tt([[G]]) = [[H]]tt([[HG ]] tt(\u03c7(T[R]))) = ([[HG ]] tt; [[H]]tt)(\u03c7(T[R])) ,\nwhere the last equality is due to Observation 2.10.3 (recall that B is a semiring). Any of the two conditions that (i) [[HG ]]tt is supp-o-finite and (ii) [[H]]tt is supp-i-finite or B is \u03c3-complete, assures that by Theorem 10.13.7(1) there exists an ([R],\u03a8,B)-wpb H\u2032 such that [[H\u2032]]tt = [[HG ]]tt; [[H]]tt. If H and HG are finiteinput, then by Theorem 10.13.7(3), also H\u2032 is finite-input. By Lemma 10.13.5(1) we can assume that H\u2032 is chain-free and finite-input.\nFinally, by Lemma 10.13.8, if H\u2032 is given, then we can construct a (\u03a8,B)-wrtg G\u2032 such that G\u2032 is finite-derivational H\u2032 is finite-input and [[H\u2032]]tt(\u03c7(T[R])) = [[G \u2032]].\nProof of (2): Now assume that H is finite-derivational. Then we follow the proof of (1) and, instead of Theorem 10.13.7(1) and Lemma 10.13.5(1), we apply Theorem 10.13.7(2) and Lemma 10.13.5(2), respectively. Hence, we can even construct H\u2032. Thus we can also construct G\u2032 with the mentioned properties.\nCorollary 10.13.10. Let \u03a3 and \u03a8 be ranked alphabets, B be a commutative semiring, and A be a (\u03a3,B)wta. Moreover, let H be a (\u03a3,\u03a8,B)-wpb such that (a) H is finite-derivational and finite-input or (b) B is \u03c3-complete. Then we can construct a (\u03a8,B)-wta A\u2032 such that [[H]]tt([[A]]) = [[A\u2032]]. Thus, in particular, if B is a commutative semiring, then Rec( ,B) is closed under weighted projective bimorphisms.\nProof. By Lemma 9.2.6 we can construct a (\u03a3,B)-wrtg G such that G is in tree automata form and [[A]] = [[G]]. Then, in particular, G is finite-derivational. By Theorem 10.13.9 we can construct a finitederivational (\u03a8,B)-wrtg G\u2032 such that [[H]]tt([[G]]) = [[G\u2032]]. Finally, by Lemma 9.2.8, we can construct a (\u03a3,B)-wta A\u2032 such that [[G\u2032]] = [[A\u2032]]."
        },
        {
            "heading": "10.13.6 Closure under Hadamard product: an alternative proof",
            "text": "We have proved that the set of recognizable (\u03a3,B)-weighted tree languages is closed under Hadamard product if B is a commutative semiring (cf. Theorem 10.4.1). This closure also follows from the closure of this set under weighted projective bimorphisms.\nCorollary 10.13.11. (cf. Theorem 10.4.1) Let B be a commutative semiring. Moreover, let A1 and A2 be two (\u03a3,B)-wta. Then we can construct a (\u03a3,B)-wta B such that [[B]] = [[A1]]\u2297 [[A2]].\nProof. Let A2 = (Q, \u03b4, F ). By Theorem 7.3.1 we can assume that A2 is root weight normalized and supp(F ) = {qf}. We construct the (\u03a3,\u03a3,B)-wpb H = (N,S,R,wt) as follows.\n\u2022 N = Q and S = {qf},\n10.13. CLOSURE UNDER WEIGHTED PROJECTIVE BIMORPHISMS 239\n\u2022 For every k \u2208 N, \u03c3 \u2208 \u03a3(k), q \u2208 Q, and q1 \u00b7 \u00b7 \u00b7 qk \u2208 Qk, the rule r = (q \u2192 [\u03c3, \u03c3](q1, . . . , qk)) is in R and wt(r) = \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q). We note that H is in tree automata form and finite-input. Then it is easy to see that [[H]]tt = [[A2]], i.e., [[H]]tt is the diagonalization of [[A2]] (cf. (2.32)). Then by Equation (2.33) we have [[H]]tt([[A1]]) = [[A1]]\u2297 [[A2]] and thus by Corollary 10.13.10 we can construct a (\u03a3,B)-wta B such that [[B]] = [[H]]tt([[A1]])."
        },
        {
            "heading": "10.13.7 Closure under yield-intersection with weighted recognizable languages: an alternative proof",
            "text": "For every (\u03a3,B)-wta A, \u0393 \u2286 \u03a3(0), and (\u0393,B)-wsa B, we have constructed a (\u03a3,B)-wta A\u2032 such that [[A\u2032]] = [[A]] \u2297 ([[B]] \u25e6 yield\u0393), if B is a commutative semiring (cf. Theorem 10.8.2). Here we give an alternative proof which uses the fact that the set of recognizable (\u03a3,B)-weighted tree languages is closed under weighted projective bimorphisms.\nCorollary 10.13.12. (cf. Theorem 10.8.2) Let B be a commutative semiring and \u0393 \u2286 \u03a3(0). For every (\u03a3,B)-wta A and every wsa B over \u0393 and B, we can construct a (\u03a3,B)-wta A\u2032 such that [[A\u2032]] = [[A]]\u2297 ([[B]] \u25e6 yield\u0393). Thus, in particular, the set Rec run(\u03a3,B) is closed under yield-intersection.\nProof. Let B = (P, \u03bb, \u00b5, \u03b3) be a (\u03a3(0),B)-wsa.\nThe idea is to construct a (\u03a3,\u03a3,B)-wpb H such that, for every \u03be, \u03b6 \u2208 T\u03a3 we have\n[[H]]tt(\u03be, \u03b6) =\n{ [[B]](yield\u0393(\u03b6)) if \u03be = \u03b6\n0 otherwise . (10.44)\nWe construct H = (N,S,R,wt) as follows.\n\u2022 N = (P \u00d7 P ) \u222a {S} where S is a new symbol, and \u2022 R and wt are defined as follows:\n\u2013 for each (p, p\u2032) \u2208 N , the rule r = (S \u2192 (p, p\u2032)) is in R and we let wt(r) = \u03bb(p)\u2297 \u03b3(p\u2032), \u2013 for each \u03b1 \u2208 \u0393 and (p, p\u2032) \u2208 P \u00d7 P we let r = ((p, p\u2032) \u2192 [\u03b1, \u03b1]) be a rule in R with wt(r) = \u00b5(p, \u03b1, p\u2032), \u2013 for each \u03b1 \u2208 \u03a3(0) \\\u0393 and p \u2208 P we let r = ((p, p)\u2192 [\u03b1, \u03b1]) be a rule in R with wt(r) = 1, and \u2013 for every k \u2208 N+, \u03c3 \u2208 \u03a3(k), and (p1, p\u20321), (p2, p \u2032 2), . . . , (pk, p \u2032 k), (p, p\n\u2032) \u2208 N we let the rule r = ((p, p\u2032)\u2192 [\u03c3, \u03c3]((p1, p\u20321), . . . , (pk, p \u2032 k))) be in R with\nwt(r) =\n{ 1 if p = p1, p \u2032 i = pi+1 for each i \u2208 [k \u2212 1], and p \u2032 k = p \u2032\n0 otherwise.\nThen H is finite-derivational and finite-input, and hence [[H]]tt is supp-i-finite. Moreover, apart from the chain rules of the form S \u2192 (p, p\u2032), the wpb H closely corresponds to the wta A constructed in the proof of Lemma 10.8.1. Indeed, there exists a bijection between RTH(\u03be, \u03be) and RA(\u03be), which is defined in a similar way as the bijection in the proof of Lemma 9.2.5.\nIt is quite obvious that (10.44) holds. Since [[H]]tt is supp-i-finite, [[A]] is [[H]]tt-summable. Hence [[H]]tt([[A]]) is defined. Then, for each \u03b6 \u2208 T\u03a3, we have\n[[H]]tt([[A]])(\u03b6) = \u2211\u2295\n\u03be\u2208T\u03a3\n[[A]](\u03be) \u2297 [[H]]tt(\u03be, \u03b6)\n= [[A]](\u03b6) \u2297 [[H]]tt(\u03b6, \u03b6) (by the second case of (10.44))\n= ([[A]] \u2297 ([[B]] \u25e6 yield\u0393))(\u03b6) (by the first case of (10.44))\nBy Corollary 10.13.10 we can construct a (\u03a3,B)-wta A\u2032 such that [[A\u2032]] = [[H]]tt([[A]]).\n240 CHAPTER 10. CLOSURE PROPERTIES"
        },
        {
            "heading": "10.13.8 Closure under tree relabelings: an alternative proof",
            "text": "Finally, we show that each tree relabeling can be computed by a particular weighted projective bimorphism. Then, for the case that B is a commutative semiring, the closure of Rec( ,B) under tree relabelings (cf. Theorem 10.10.1) can be reobtained as corollary of Corollary 10.13.10. However, we recall that Theorem 10.10.1 holds for arbitrary strong bimonoids and not only for commutative semirings.\nObservation 10.13.13. Let \u03c4 be a (\u03a3,\u2206)-tree relabeling and r : T\u03a3 \u2192 B. Then we can construct a chain-free, finite-input, and finite-output (\u03a3,\u2206,B)-wpb H such that \u03c4(r) = [[H]]tt(r).\nProof. Let \u03c4 = (\u03c4k | k \u2208 N). We construct the (\u03a3,\u2206,B)-wpb H = ({S0}, S0, R,wt) as follows. For every k \u2208 N, \u03c3 \u2208 \u03a3(k), and \u03b3 \u2208 \u03c4k(\u03c3), the set R contains the rule r = (S0 \u2192 [\u03c3, \u03b3](S0, . . . , S0)) with k occurrences of S0 and wt(r) = 1. Clearly, H has the desired properties. In particular, [[H]]tt is supp-ifinite.\nThen for every \u03be \u2208 T\u03a3 and \u03b6 \u2208 T\u2206: [[H]]tt(\u03be, \u03b6) \u2208 {0, 1}, and [[H]]tt(\u03be, \u03b6) = 1 if and only if \u03b6 \u2208 \u03c4(\u03be). Now let \u03b6 \u2208 T\u2206. Then we can calculate as follows:\n\u03c4(r)(\u03b6) = \u2295\n\u03be\u2208\u03c4\u22121(\u03b6)\nr(\u03be) = \u2295\n\u03be\u2208T\u03a3\nr(\u03be) \u2297 [[H]]tt(\u03be, \u03b6) = ([[H]]tt(r))(\u03b6)\nHence \u03c4(r) = [[H]]tt(r).\nThe following corollary follows from Corollary 10.13.10 and Observation 10.13.13.\nCorollary 10.13.14. Let B be a commutative semiring and A be a (\u03a3,B)-wta. Moreover, let \u03c4 be a (\u03a3,\u2206)-tree relabeling. Then we can construct a (\u2206,B)-wta A\u2032 such that \u03c4([[A]]) = [[A\u2032]] (cf. Theorem 10.10.1). Thus, in particular, if B is a commutative semiring, then the set Rec( ,B) is closed under tree relabelings."
        },
        {
            "heading": "10.14 Summary of some of the closure properties",
            "text": "In the three tables of Figure 10.18 we summarize some of the closure properties of the set of weighted tree languages recognized by wta. Each entry refers to the theorem or corollary where the precise formulation of the closure property can be found; in the figure we only have indicated the additionally required properties of the strong bimonoid. For some of the operations in the first table and the third table, we could only prove the corresponding closure property for the case that B is a semiring; for a few other operations we did not need distributivity from both sides. In the summary, we did not consider the case of bu deterministic and crisp deterministic wta.\n10.14. SUMMARY OF SOME OF THE CLOSURE PROPERTIES 241\n242 CHAPTER 10. CLOSURE PROPERTIES\nChapter 11\nCharacterizations by weighted local systems\nIn this chapter we show two characterization theorems for wta. The first one is Theorem 11.2.6; it is based on a decomposition theorem of wta which is due to [Fu\u0308l15]. The latter result generalizes the fact that each recognizable tree language is the image of a local tree language under a deterministic tree relabeling [Tha67, Prop. 2] (cf. [GS84, Thm. 2.9.5] and [Eng75b, Cor. 3.59(i)\u21d2(ii)]).\nThe second characterization theorem is Theorem 11.3.1, which follows the idea of decomposing a bottom-up tree transducer. In [Eng75a, Thm. 3.5] it was proved that each bottom-up tree transducer can be decomposed into a relabeling, followed by the intersection with a local tree language, followed by a tree homomorphism. Also the reverse composition result holds [Eng75a, p.220]. In Theorem 11.3.1(A)\u21d2 (B) we decompose the run semantics [[A]]run of a (\u03a3,B)-wta A into an inverse deterministic tree relabeling (corresponding to the above relabeling), followed by the intersection with a local tree language, followed by a homomorphism which interprets trees in some evaluation algebra with carrier set B (corresponding to the above tree homomorphism). Similar decompositions were proved for weighted tree automata over multioperator monoids [SVF09, Thm. 1].\nBefore proving the decomposition theorems we recall the definitions of local systems, local tree languages, and weighted local system."
        },
        {
            "heading": "11.1 Local tree languages and weighted local systems",
            "text": "We consider the ranked alphabet Fork(\u03a3) where Fork(\u03a3)(k) = \u03a3k \u00d7 \u03a3(k) for each k \u2208 N. Each element of Fork(\u03a3)(k) has the form (\u03c31 \u00b7 \u00b7 \u00b7\u03c3k, \u03c3) with \u03c31, . . . , \u03c3k \u2208 \u03a3 and \u03c3 \u2208 \u03a3(k), and it is called k-fork or just fork.\nA \u03a3-local system [GS84, Sec. 2.9] is a pair (K,H) where K \u2286 Fork(\u03a3) is a set of forks and H \u2286 \u03a3. The tree language generated by (K,H), denoted by L(K,H), is defined as follows. First, we let\nL(K) = {\u03be \u2208 T\u03a3 | (\u03be(w1) \u00b7 \u00b7 \u00b7 \u03be(wk), \u03be(w)) \u2208 K for each w \u2208 pos(\u03be), where k = rk(\u03be(w))} .\nSecond, we define L(K,H) = {\u03be \u2208 L(K) | \u03be(\u03b5) \u2208 H}.\nFor the particular \u03a3-local system (Fork(\u03a3),\u03a3), we have L(Fork(\u03a3)) = L(Fork(\u03a3),\u03a3) = T\u03a3. Let L \u2286 T\u03a3. We call L a local tree language if there exists a \u03a3-local system (K,H) such that L = L(K,H).\nA (\u03a3,B)-weighted local system (for short: (\u03a3,B)-wls) [Fu\u0308l15] is a tuple S = (g, F ) such that g = (gk | k \u2208 N) is an N-indexed family of mappings gk : Fork(\u03a3)(k) \u2192 B and F : \u03a3 \u2192 B. We say that S has identity root weights if im(F ) \u2286 {0, 1}.\n243\n244 CHAPTER 11. CHARACTERIZATIONS BY WEIGHTED LOCAL SYSTEMS\nWe define the mapping g\u2032 : T\u03a3 \u2192 B by induction on T\u03a3. For every \u03be = \u03c3(\u03be1, . . . , \u03bek), we let\ng\u2032(\u03be) = g\u2032(\u03be1)\u2297 \u00b7 \u00b7 \u00b7 \u2297 g \u2032(\u03bek)\u2297 gk(\u03be1(\u03b5) \u00b7 \u00b7 \u00b7 \u03bek(\u03b5), \u03c3) .\nIn the following we drop the prime from g\u2032 and simply write g for g\u2032. The (\u03a3,B)-weighted tree language determined by S, denoted by [[S]], is the mapping [[S]] : T\u03a3 \u2192 B defined for each \u03be \u2208 T\u03a3 by\n[[S]](\u03be) = g(\u03be)\u2297 F (\u03be(\u03b5)) .\nSince the value g(\u03c3(\u03be1, . . . , \u03bek)) \u2208 B depends on the root labels of \u03be1, . . . , \u03bek, in general there does not exist a \u03a3-algebra (B, \u03bb) such that g is the unique \u03a3-algebra homomorphism from (T\u03a3, \u03b8\u03a3) to (B, \u03bb).\nExample 11.1.1. We consider the ranked alphabet \u03a3 = {\u03c3(2), \u03b3(1), \u03b1(0)} and the weighted tree language #\u03c3(.,\u03b1) : T\u03a3 \u2192 N defined in Example 3.2.11, where #\u03c3(.,\u03b1)(\u03be) is the number of occurrences of the pattern \u03c3(., \u03b1) in \u03be for each \u03be \u2208 T\u03a3.\nWe define the (\u03a3,Natmax,+)-wls S = (g, F ) such that\n\u2022 for every \u03b81, \u03b82 \u2208 \u03a3 we let g2(\u03b81\u03b82, \u03c3) = 1 if \u03b81\u03b82 \u2208 {\u03c3\u03b1, \u03b3\u03b1, \u03b1\u03b1} and 0 otherwise; and we let g1(\u03b81, \u03b3) = 0 and g0(\u03b5, \u03b1) = 0, and \u2022 F (\u03c3) = F (\u03b3) = F (\u03b1) = 0.\nIt should be clear that [[S]](\u03be) = #\u03c3(.,\u03b1)(\u03be) for each \u03be \u2208 T\u03a3.\nLet (K,H) be a \u03a3-local system and \u03ba = (\u03bak | k \u2208 N) an N-indexed family of mappings \u03bak : \u03a3(k) \u2192 B. We interpret the trees in L(K,H) by the unique \u03a3-algebra homomorphism hM(\u03a3,\u03ba) : T\u03a3 \u2192 B, where M(\u03a3, \u03ba) is the (\u03a3, \u03ba)-evaluation algebra defined in Section 2.9. Then we obtain the following (\u03a3,B)weighted tree language:\n(\u03c7(L(K,H)) \u2297 hM(\u03a3,\u03ba)) : T\u03a3 \u2192 B\n\u03be 7\u2192\n{ hM(\u03a3,\u03ba)(\u03be) if \u03be \u2208 L(K,H)\n0 otherwise .\nIn the next lemma we prove that the weighted tree language \u03c7(L(K,H))\u2297 hM(\u03a3,\u03ba) can be computed by a (\u03a3,B)-wls.\nLemma 11.1.2. Let (K,H) be a \u03a3-local system and \u03ba = (\u03bak | k \u2208 N) a family of mappings \u03bak : \u03a3\n(k) \u2192 B. We can construct a (\u03a3,B)-wls S which has identity root weights such that [[S]] = \u03c7(L(K,H))\u2297 hM(\u03a3,\u03ba).\nProof. We define the (\u03a3,B)-wls S = (g, F ) as follows. For every k \u2208 N and \u03c31, . . . , \u03c3k \u2208 \u03a3, and \u03c3 \u2208 \u03a3(k), we have\ngk(\u03c31 \u00b7 \u00b7 \u00b7\u03c3k, \u03c3) =\n{ \u03bak(\u03c3) if (\u03c31 \u00b7 \u00b7 \u00b7\u03c3k, \u03c3) \u2208 K\n0 otherwise and F (\u03c3) =\n{ 1 if \u03c3 \u2208 H\n0 otherwise.\nBy induction on T\u03a3, we prove that the following statement holds:\nFor each \u03be \u2208 T\u03a3, we have g(\u03be) =\n{ hM(\u03a3,\u03ba)(\u03be) if \u03be \u2208 L(K)\n0 otherwise. (11.1)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). Then\ng(\u03be) = (\u2297\ni\u2208[k]\ng(\u03bei) ) \u2297 gk(\u03be1(\u03b5) \u00b7 \u00b7 \u00b7 \u03bek(\u03b5), \u03c3)\n11.1. LOCAL TREE LANGUAGES AND WEIGHTED LOCAL SYSTEMS 245\n=\n{(\u2297 i\u2208[k] hM(\u03a3,\u03ba)(\u03bei) ) \u2297 gk(\u03be1(\u03b5) \u00b7 \u00b7 \u00b7 \u03bek(\u03b5), \u03c3) if (\u2200i \u2208 [k]) : \u03bei \u2208 L(K)\n0 otherwise (by I.H.)\n=    (\u2297 i\u2208[k] hM(\u03a3,\u03ba)(\u03bei) ) \u2297 \u03bak(\u03c3) if (\u2200i \u2208 [k]) : \u03bei \u2208 L(K) and (\u03be1(\u03b5) \u00b7 \u00b7 \u00b7 \u03bek(\u03b5), \u03c3) \u2208 K\n0 otherwise\n(by the definition of gk)\n=\n{ hM(\u03a3,\u03ba)(\u03be) if \u03be \u2208 L(K)\n0 otherwise.\nThis proves (11.1). Now let \u03be \u2208 T\u03a3. Then\n[[S]](\u03be) = g(\u03be)\u2297 F (\u03be(\u03b5)) =    g(\u03be) if \u03be \u2208 L(K) and \u03be(\u03b5) \u2208 H\n0 otherwise\n=\n{ hM(\u03a3,\u03ba)(\u03be) if \u03be \u2208 L(K,H)\n0 otherwise\nwhere the last equality is due to (11.1).\nIt seems that the inverse of Lemma 11.1.2 does not hold, because mappings of the form gk : Fork(\u03a3) (k) \u2192 B cannot be coded by mappings of the form \u03bak : \u03a3 (k) \u2192 B.\nIn the next lemma, we prove that, for each (\u03a3,Boole)-wls S = (g, F ), the support of [[S]] is a local tree language. As preparation, we define the support local system of S, denoted by supp(S), to be the \u03a3-local system (K,H), where K = \u22c3 k\u2208N supp(gk) and H = supp(F ).\nLemma 11.1.3. Let S = (g, F ) be a (\u03a3,Boole)-wls. Then supp([[S]]) = L(supp(S)).\nProof. Let supp(S) = (K,H). By induction on T\u03a3, we prove that the following statement holds:\nFor each \u03be \u2208 T\u03a3, we have \u03be \u2208 supp(g) if and only if \u03be \u2208 L(K). (11.2)\nFor this, let \u03be = \u03c3(\u03be1, . . . , \u03bek). Then\n\u03be \u2208 supp(g) \u21d0\u21d2 g(\u03be1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 g(\u03bek) \u2227 gk(\u03be1(\u03b5) \u00b7 \u00b7 \u00b7 \u03bek(\u03b5), \u03c3) = 1\n\u21d0\u21d2 (\u2200i \u2208 [k]) : \u03bei \u2208 supp(gi) and gk(\u03be1(\u03b5) \u00b7 \u00b7 \u00b7 \u03bek(\u03b5), \u03c3) = 1\n\u21d0\u21d2 (\u2200i \u2208 [k]) : \u03bei \u2208 L(K) and (\u03be1(\u03b5) \u00b7 \u00b7 \u00b7 \u03bek(\u03b5), \u03c3) \u2208 K\n(by I.H. and the definition of K)\n\u21d0\u21d2 \u03be \u2208 L(K).\nThis proves (11.2). Then for each \u03be \u2208 T\u03a3 we have\n\u03be \u2208 supp([[S]]) \u21d0\u21d2 g(\u03be) = 1 and F (\u03be(\u03b5)) = 1 \u21d0\u21d2 \u03be \u2208 L(K) and \u03be(\u03b5) \u2208 H \u21d0\u21d2 \u03be \u2208 L(K,H).\nThe next theorem states that, intuitively, \u03a3-local systems and (\u03a3,Boole)-wls are essentially the same.\nTheorem 11.1.4. Let L \u2286 T\u03a3 be a tree language. The following two statements are equivalent.\n(A) We can construct a \u03a3-local system (K,H) such that L = L(K,H). (B) We can construct a (\u03a3,Boole)-wls S such that L = supp([[S]]).\nProof. Proof of (A)\u21d2(B): Let \u03ba = (\u03bak | k \u2208 N) be a family of mappings \u03bak : \u03a3 (k) \u2192 B such that \u03bak(\u03c3) = 1 for every k \u2208 N and \u03c3 \u2208 \u03a3(k). Then\nL = L(K,H) = supp(\u03c7(L(K,H))) = supp(\u03c7(L(K,H)) \u2297 hM(\u03a3,\u03ba)) .\nBy Lemma 11.1.2, we can construct a (\u03a3,Boole)-wls S such that \u03c7(L(K,H)) \u2297 hM(\u03a3,\u03ba) = [[S]]. Thus L = supp([[S]]).\nProof of (B)\u21d2(A): This follows from Lemma 11.1.3.\n246 CHAPTER 11. CHARACTERIZATIONS BY WEIGHTED LOCAL SYSTEMS"
        },
        {
            "heading": "11.2 Characterization by weighted local system and determinis-",
            "text": "tic relabeling\nIn this section we prove the first characterization theorem for recognizable weighted tree languages. Roughly speaking, it says that each recognizable (\u03a3,B)-weighted tree language can be represented as the application of some deterministic tree relabeling to the weighted rule tree language of some wrtg in tree automata form (cf. Theorem 11.2.6).\nAs preparation, we recall the well known fact that the rule tree language of a context-free grammar is a local tree language (cf. [Tha67, Prop. 1], also cf. [Eng75b, Thm. 3.57] and [GS84, Thm. 3.2.9]).\nLemma 11.2.1. Let G be a \u0393-cfg with rule set R. We can construct an R-local system (K,H) such that L(K,H) = RTG.\nProof. Let G = (N,S,R). We construct the R-local system (K,H) as follows.\nWe construct the set K \u2286 Fork(R) such that, for every r = (A \u2192 u0A1u1 \u00b7 \u00b7 \u00b7Akuk) in R and every r1 = (A1 \u2192 \u03b11), . . . , rk = (Ak \u2192 \u03b1k) in R, the tuple (r1 \u00b7 \u00b7 \u00b7 rk, r) is in K.\nMoreover, we let H = {r | lhs(r) \u2208 S}. It is obvious that L(K,H) = RTG.\nWe note that, due to [Eng75b, Thm. 3.57], the inverse of Lemma 11.2.1 does not hold. Next we generalize Lemma 11.2.1 to the weighted case.\nLemma 11.2.2. Let G be a (\u0393,B)-wcfg with rule set R. The following two statements hold.\n(1) We can construct an R-local system (K,H) such that [[G]]wrt = \u03c7(L(K,H))\u2297 wtG . (2) We can construct an (R,B)-wls S with identity root weights such that [[G]]wrt = [[S]].\nProof. Let G = (N,S,R,wt) and G be the \u0393-cfg underlying G. We construct the R-local system (K,H) as in Lemma 11.2.1 and then, for (K,H) and wt, the (R,B)-wls S as in Lemma 11.1.2. Then we obtain\n[[G]]wrt = \u03c7(RTG)\u2297 wtG (by definition and because wtG \u2297 \u03c7(RTG) = \u03c7(RTG)\u2297 wtG)\n= \u03c7(RTG)\u2297 wtG\n= \u03c7(L(K,H))\u2297 wtG (by Lemma 11.2.1)\n= \u03c7(L(K,H))\u2297 hM(R,wt) (we recall that hM(R,wt) = wtG holds by our convention)\n= [[S]] . (by Lemma 11.1.2)\nIt is known that each local tree language is recognizable [GS84, Thm. 2.9.4]. The following result generalizes this to the weighted case (where [Fu\u0308l15, Lm. 1] requires that B is a semiring).\nLemma 11.2.3. [Fu\u0308l15, Lm. 1] For each (\u03a3,B)-wls S, we can construct a bu deterministic (\u03a3,B)-wta such that [[A]] = [[S]].\nProof. Let S = (g, F ). We construct the (\u03a3,B)-wta A = (Q, \u03b4, FA) as follows:\n\u2022 Q = {\u03c3 | \u03c3 \u2208 \u03a3}, \u2022 for every k \u2208 N, \u03c31 . . . \u03c3k \u2208 \u03a3k, \u03c3 \u2208 \u03a3(k), and \u03c9 \u2208 \u03a3,\n\u03b4k(\u03c31 . . . \u03c3k, \u03c3, \u03c9) = { gk(\u03c31 . . . \u03c3k, \u03c3) if \u03c9 = \u03c3 0 otherwise,\n\u2022 FA(\u03c3) = F (\u03c3) for every \u03c3 \u2208 \u03a3.\n11.2. CHARACTERIZATION BY WEIGHTED LOCAL SYSTEMS 247\nIt is clear that A is bu deterministic. Next, by induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3 and \u03c9 \u2208 \u03a3, we have hA(\u03be)\u03c9 = { g(\u03be) if \u03c9 = \u03be(\u03b5) 0 otherwise.\n(11.3)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). Then\nhA(\u03c3(\u03be1, . . . , \u03bek))\u03c9\n= \u2295\n\u03c31\u00b7\u00b7\u00b7\u03c3k\u2208Qk\nhA(\u03be1)\u03c31 \u2297 . . .\u2297 hA(\u03bek)\u03c3k \u2297 \u03b4k(\u03c31 \u00b7 \u00b7 \u00b7\u03c3k, \u03c3, \u03c9)\n= hA(\u03be1)\u03be1(\u03b5) \u2297 . . .\u2297 hA(\u03bek)\u03bek(\u03b5) \u2297 \u03b4k(\u03be1(\u03b5) \u00b7 \u00b7 \u00b7 \u03bek(\u03b5), \u03c3, \u03c9)\n(because for each \u03c31 \u00b7 \u00b7 \u00b7\u03c3k \u2208 Q k with \u03c31 \u00b7 \u00b7 \u00b7\u03c3k 6= \u03be1(\u03b5) \u00b7 \u00b7 \u00b7 \u03bek(\u03b5)\nthere exists an i \u2208 [k] such that hA(\u03bei)\u03c3i = 0 by I.H.)\n= g(\u03be1)\u2297 . . .\u2297 g(\u03bek)\u2297 \u03b4k(\u03be1(\u03b5) . . . \u03bek(\u03b5), \u03c3, \u03c9) (by I.H.)\n=\n{ g(\u03be1)\u2297 . . .\u2297 g(\u03bek)\u2297 gk(\u03be1(\u03b5) . . . \u03bek(\u03b5), \u03c3) if \u03c9 = \u03c3\n0 otherwise\n=\n{ g(\u03c3(\u03be1, . . . , \u03bek)) if \u03c9 = \u03c3\n0 otherwise.\nThis proves (11.3).\nFinally, let \u03be \u2208 T\u03a3. Then we get\n[[A]](\u03be) = \u2295\n\u03c9\u2208Q\nhA(\u03be)\u03c9 \u2297 FA(\u03c9) = g(\u03be)\u2297 FA(\u03be(\u03b5)) = g(\u03be)\u2297 F (\u03be(\u03b5)) = [[S]](\u03be),\nwhere the second equality follows from (11.3) and the other ones from the corresponding definitions.\nFor example, if we apply the construction in Lemma 11.2.3 to the (\u03a3,Natmax,+)-wls S of Example 11.1.1, then we obtain the bu deterministic (\u03a3,Natmax,+)-wta A of Example 3.2.12.\nNext we verify that Lemma 11.2.3 is a generalization of [GS84, Thm. 2.9.4]. We achieve this by proving that the latter result is equivalent to Lemma 11.2.3 for the case that B is the semiring Boole.\nCorollary 11.2.4. For each \u03a3-local system (K,H), we can construct a bu deterministic \u03a3-fta A such that L(K,H) = L(A). Thus, in particular, each local tree language is recognizable.\nProof. Let (K,H) be a \u03a3-local system. We construct the (\u03a3,Boole)-wls S = (g, F ) by letting gk = \u03c7(K \u2229 Fork(\u03a3)(k)) for each k \u2208 N, and F = \u03c7(H). Then (K,H) = supp(S) and, by Lemma 11.1.3, we have L(K,H) = supp([[S]]). By Lemma 11.2.3, we can construct a bu deterministic (\u03a3,Boole)-wta A such that L(K,H) = supp([[A]]). By Corollary 3.4.2, we can construct a \u03a3-fta A such that L(K,H) = L(A).\nWe can easily demonstrate that bu deterministic wta are more powerful than weighted local systems. For instance, let \u03a3 = {\u03b3(1), \u03b1(0)} and consider the (\u03a3,Boole)-weighted tree language r defined by r ( \u03b3(\u03b3(\u03b1)) ) = 1 and r(\u03be) = 0 for every other \u03be \u2208 T\u03a3. It is easy to show that r \u2208 bud-Rec(\u03a3,Boole) and there does not exist a (\u03a3,Boole)-wls S such that [[S]] = r. To see the latter, we assume that there exists a (\u03a3,Boole)-wls S = (g, F ) such that [[S]] = r. Thus, using \u03be as abbreviation for \u03b3(\u03b3(\u03b1)), we have [[S]](\u03be) = g(\u03be) \u2227 F (\u03b3) = 1. Hence g(\u03be) = F (\u03b3) = 1, and thus, in particular, g1(\u03b3, \u03b3) = g1(\u03b1, \u03b3) = g0(\u03b5, \u03b1) = 1. But this means that, for each n \u2208 N+, we have g(\u03b3n(\u03b1)) = 1 and hence [[S]](\u03b3n(\u03b1)) = 1. This is a contradiction to [[S]] = r.\n248 CHAPTER 11. CHARACTERIZATIONS BY WEIGHTED LOCAL SYSTEMS\nIt is also known that each recognizable tree language is the image of a rule tree language of some context-free grammar under a deterministic tree relabeling (cf. [Tha67, Prop. 2], [Eng75b, Thm. 3.58]). The next lemma generalizes this to the weighted case.\nLemma 11.2.5. Let A be a (\u03a3,B)-wta. We can construct a (\u03a3,B)-wrtg G in tree automata form with rule set R and a deterministic (R,\u03a3)-tree relabeling \u03c4 such that [[A]]run = \u03c7(\u03c4) ( [[G]]wrt ) .\nProof. By Lemma 9.2.6 we can construct a (\u03a3,B)-wrtg G in tree automata form such that [[A]]run = [[G]]. Let R be the set of rules of G. As argued in Section 9.1, the projection \u03c0G : TR \u2192 T\u03a3 is determined by the (R,\u03a3)-tree homomorphism \u03c0G = ((\u03c0G)k | k \u2208 N) defined, for every k \u2208 N and r \u2208 R(k) of the form r = (A \u2192 \u03c3(A1, . . . , Ak)), by (\u03c0G)k(r) = \u03c3(z1, . . . , zk) (note that G is in tree automata form). We construct the deterministic (R,\u03a3)-tree relabeling \u03c4 = (\u03c4k | k \u2208 N) such that, for each rule A\u2192 \u03c3(A1, . . . , Ak), we let\n\u03c4k(A\u2192 \u03c3(A1, . . . , Ak)) = \u03c3 .\nObviously, the mappings \u03c0G : TR \u2192 T\u03a3 and \u03c4 : TR \u2192 T\u03a3 are equal. Then, by definition, we obtain [[G]] = \u03c7(\u03c0G)([[G]]wrt) = \u03c7(\u03c4)([[G]]wrt).\nNow we can prove the first characterization theorem.\nTheorem 11.2.6. Let \u03a3 be a ranked alphabet, B be a strong bimonoid, and r : T\u03a3 \u2192 B. Then the following three statements are equivalent. (A) We can construct a (\u03a3,B)-wta A such that r = [[A]]run. (B) We can construct\n\u2022 a ranked alphabet R, \u2022 a deterministic (R,\u03a3)-tree relabeling \u03c4 , and \u2022 a (\u03a3,B)-wrtg G in tree automata form with rule set R\nsuch that r = \u03c7(\u03c4) ( [[G]]wrt ) .\n(C) We can construct \u2022 a ranked alphabet R, \u2022 a deterministic (R,\u03a3)-tree relabeling \u03c4 , and \u2022 an (R,B)-wls S with identity root weights\nsuch that r = \u03c7(\u03c4) ( [[S]] ) .\nProof. Proof of (A)\u21d2(B): It follows from Lemma 11.2.5.\nProof of (B)\u21d2(C): It follows from the fact that each (\u03a3,B)-wrtg is a (\u03a3\u039e,B)-wcfg and by Lemma 11.2.2(2).\nProof of (C)\u21d2(A): It follows from Lemma 11.2.3 and Theorem 10.10.1 (closure of Recrun( ,B) under tree relabelings).\nNext we verify that Theorem 11.2.6 (A)\u21d2(C) generalizes [GS84, Thm. 2.9.5]. We achieve this by proving that the latter result is equivalent to Theorem 11.2.6 (A)\u21d2(C) for the case that B is the semiring Boole.\nCorollary 11.2.7. Let L \u2286 T\u03a3 be recognizable. We can construct a ranked alphabet R, a deterministic (R,\u03a3)-tree relabeling \u03c4 , and an R-local system (K,H) such that L = \u03c4(L(K,H)).\nProof. Let A be a \u03a3-fta such that L = L(A). By Corollary 3.4.2 (A)\u21d2(B), we can construct a (\u03a3,Boole)wta A such that L = supp([[A]]). By Theorem 11.2.6 (A)\u21d2(C), we can construct a ranked alphabet R, a deterministic (R,\u03a3)-tree relabeling \u03c4 , and an (R,Boole)-wls S (which has identity root weights by definition) such that L = supp(\u03c7(\u03c4) ( [[S]] ) ). By (2.31), we obtain that L = \u03c4(supp([[S]])). By Theorem 11.1.4(B)\u21d2(A), we can construct a \u03a3-local system (K,H) such that L = \u03c4(L(K,H)).\n11.3. CHARACTERIZATION BY LOCAL SYSTEMS 249\nIf one traces back the constructions involved in the proof of Theorem 11.2.6(A)\u21d2(C) and composes them together, then one can eventually find out how a given wta is decomposed into a wls and a deterministic tree relabeling. Here we compose these constructions and show the resulting direct construction (where we start from a wta with identity root weights).\nConstruction 11.2.8. Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta with identity root weights. Then we can construct a ranked alphabet R, a deterministic (R,\u03a3)-tree relabeling \u03c4 , and an (R,B)-wls S such that [[A]]run = \u03c7(\u03c4)([[S]]) as follows.\n\u2022 For each k \u2208 N, we let R(k) = {q \u2192 \u03c3(q1, . . . , qk) | \u03c3 \u2208 \u03a3(k), q, q1, . . . , qk \u2208 Q}, \u2022 \u03c4 = (\u03c4k | k \u2208 N) such that, for every k \u2208 N and q \u2192 \u03c3(q1, . . . , qk) in R(k), we let \u03c4k(q \u2192 \u03c3(q1, . . . , qk)) = \u03c3, and \u2022 S = (g, F \u2032) such that g = (gk | k \u2208 N) and for every k \u2208 N, r1, . . . , rk in R, and r \u2208 R(k), we let\ngk(r1 \u00b7 \u00b7 \u00b7 rk, r) =    \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) if r = (q \u2192 \u03c3(q1, . . . , qk)) and for each i \u2208 [k] we have lhs(ri) = qi\n0 otherwise\nand, for each r in R, we let F \u2032(r) = F (lhs(r)).\nIn fact, we could even give an arbitrary (\u03a3,B)-wta as input to Construction 11.2.8 (i.e., which does not necessarily have identity root weights) and still we would obtain that [[A]]run = \u03c7(\u03c4)([[S]])."
        },
        {
            "heading": "11.3 Characterization by local systems and evaluation algebras",
            "text": "In the next theorem we prove the second characterization result for recognizable weighted tree languages. In particular, (B) and (C) only differ in the way in which the \u0398-tree language is defined: in (B) it is generated by a \u0398-local system and in (C) it is recognized by a bu deterministic \u0398-fta.\nTheorem 11.3.1. Let \u03a3 be a ranked alphabet, B be a strong bimonoid, and r : T\u03a3 \u2192 B. Then the following three statements are equivalent. (A) We can construct a (\u03a3,B)-wta A such that r = [[A]]run. (B) We can construct\n\u2022 a ranked alphabet \u0398, \u2022 a deterministic (\u0398,\u03a3)-tree relabeling \u03c4 , \u2022 a \u0398-local system (K,H), and \u2022 a family \u03ba = (\u03bak | k \u2208 N) of mappings \u03bak : \u0398(k) \u2192 B\nsuch that, for each \u03be \u2208 T\u03a3, the following holds: r(\u03be) = hM(\u0398,\u03ba)(\u03c4 \u22121(\u03be) \u2229 L(K,H)).\n(C) We can construct \u2022 a ranked alphabet \u0398, \u2022 a deterministic (\u0398,\u03a3)-tree relabeling \u03c4 , \u2022 a bu deterministic \u0398-fta A, and \u2022 a family \u03ba = (\u03bak | k \u2208 N) of mappings \u03bak : \u0398(k) \u2192 B\nsuch that, for each \u03be \u2208 T\u03a3, the following holds: r(\u03be) = hM(\u0398,\u03ba)(\u03c4 \u22121(\u03be) \u2229 L(A)).\nProof. Proof of (A)\u21d2(B): Let A be a (\u03a3,B)-wta. By Theorem 11.2.6 (A)\u21d2(B), we construct a ranked alphabet R, a deterministic (R,\u03a3)-tree relabeling \u03c4 , and a (\u03a3,B)-wrtg G in tree automata form with rule set R such that [[A]]run = \u03c7(\u03c4)([[G]]wrt). Let wt be the weight assignment of G.\nThen, as in Lemma 11.2.2(1), we can construct an R-local system (K,H) such that\n[[A]]run = \u03c7(\u03c4)([[G]]wrt) = \u03c7(\u03c4)(\u03c7(L(K,H)) \u2297 hM(R,wt)) .\n250 CHAPTER 11. CHARACTERIZATIONS BY WEIGHTED LOCAL SYSTEMS\nLet \u03be \u2208 T\u03a3. By applying Observation 2.10.1 (choosing \u03a3, \u2206, L, and r to be R, \u03a3, L(K,H), and hM(\u03a3,wt), respectively), we obtain that\n[[A]]run(\u03be) = hM(R,wt)(\u03c4 \u22121(\u03be) \u2229 L(K,H)) .\nBy choosing \u0398 and \u03ba to be R and (wt|R(k) | k \u2208 N), respectively, we have proved (B).\nProof of (B)\u21d2(C): This follows from Corollary 11.2.4, which states that, for each \u0398-local system (K,H), a bu deterministic \u0398-fta A can be constructed such that L(A) = L(K,H).\nProof of (C)\u21d2(A): Let \u0398 be a ranked alphabet, \u03c4 = (\u03c4k | k \u2208 N) be a deterministic (\u0398,\u03a3)-tree relabeling, A = (Q, \u03b4, F ) be a bu deterministic \u0398-fta, and a family \u03ba = (\u03bak | k \u2208 N) of mappings \u03bak : \u0398\n(k) \u2192 B. By Theorem 4.3.6, we can assume that A is total and bu deterministic. Then, for each \u03b6 \u2208 L(A), we denote by \u03c1\u03b6 the unique valid run of A on \u03b6. We will abbreviate hM(\u0398,\u03ba) by h.\nWe construct the (\u03a3,B)-wta A by coding the preimage of \u03c4 into the states ofA. We let A = (Q\u2032, \u03b4\u2032, F \u2032) with Q\u2032 = Q\u00d7\u0398 and, for each (q, \u03b8) \u2208 Q\u2032 we let F \u2032(q,\u03b8) = 1 if q \u2208 F , and F \u2032 (q,\u03b8) = 0 otherwise. Moreover, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and (q1, \u03b81), . . . , (qk, \u03b8k), (q, \u03b8) \u2208 Q \u2032 we define\n(\u03b4\u2032)k((q1, \u03b81) \u00b7 \u00b7 \u00b7 (qk, \u03b8k), \u03c3, (q, \u03b8)) =\n{ \u03bak(\u03b8) if (q1 \u00b7 \u00b7 \u00b7 qk, \u03b8, q) \u2208 \u03b4k and \u03c4k(\u03b8) = \u03c3\n0 otherwise.\nWe let RA = \u22c3 \u03be\u2208T\u03a3\nRA(\u03be), and we define the mapping \u03c4\u0304 : RA \u2192 T\u03a3 such that, for every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be), we let \u03c4\u0304 (\u03c1) be the \u03a3-tree mapping\nt : pos(\u03be)\u2192 \u03a3 with t(w) = \u03c4k(\u03c1(w)2) for each w \u2208 pos(\u03be) where k = rk\u0398(\u03c1(w)2) .\nWe note that t uniquely determines an element in T\u03a3 (cf. Section 2.9). Moreover, there may exist \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be) such that \u03c4\u0304 (\u03c1) 6= \u03be; however, the weight of such a run \u03c1 is 0. Formally,\nfor each \u03c1 \u2208 RA(\u03be): if \u03c4\u0304 (\u03c1) 6= \u03be, then wt(\u03be, \u03c1) = 0 . (11.4)\nFor each \u03be \u2208 T\u03a3, we abbreviate by RA(F \u00d7 \u0398, \u03be) the set \u22c3 q\u2208F,\u03b8\u2208\u0398RA((q, \u03b8), \u03be) and by RA(F \u00d7 \u0398)\nthe set \u22c3 \u03be\u2208T\u03a3 RA(F \u00d7\u0398, \u03be). Then we define the mapping\n\u03d5 : L(A)\u2192 RA(F \u00d7 \u0398)\nfor each \u03b6 \u2208 L(A) and w \u2208 pos(\u03be) by \u03d5(\u03b6)(w) = (\u03c1\u03b6(w), \u03b6(w)). (We recall that \u03c1\u03b6 is the unique valid run of A on \u03b6 \u2208 L(A).) It is easy to see that \u03d5 is a bijection. Moreover, \u03d5(\u03b6) \u2208 RA(F \u00d7\u0398, \u03c4(\u03b6)).\nBy induction on T\u0398, we prove that the following statement holds:\nFor every \u03b6 \u2208 L(A), we have h(\u03b6) = wt(\u03c4(\u03b6), \u03d5(\u03b6)) , (11.5)\ncf. Figure 11.1, where RvA(q, \u03b6) denotes the set of valid q-runs on \u03b6.\nLet \u03b6 = \u03b8(\u03b61, . . . , \u03b6k). Then\nh(\u03b8(\u03b61, . . . , \u03b6k)) = h(\u03b61)\u2297 . . .\u2297 h(\u03b6k)\u2297 \u03bak(\u03b8)\n= (\u2297\ni\u2208[k]\nwt(\u03c4(\u03b6i), \u03d5(\u03b6i)) ) \u2297 \u03bak(\u03b8) (by I.H.)\n= (\u2297\ni\u2208[k]\nwt(\u03c4(\u03b6i), \u03d5(\u03b6i)) ) \u2297 (\u03b4\u2032)k((\u03c1\u03b61 (\u03b5), \u03b61(\u03b5)) \u00b7 \u00b7 \u00b7 (\u03c1\u03b6k(\u03b5), \u03b6k(\u03b5)), \u03c4k(\u03b8), (\u03c1\u03b6(\u03b5), \u03b6(\u03b5)))\n(by definition of \u03b4\u2032)\n= (\u2297\ni\u2208[k]\nwt(\u03c4(\u03b6i), \u03d5(\u03b6)|i) ) \u2297 (\u03b4\u2032)k(\u03d5(\u03b61)(\u03b5) \u00b7 \u00b7 \u00b7\u03d5(\u03b6k)(\u03b5), \u03c4k(\u03b8), \u03d5(\u03b6)(\u03b5))\n(by definition of \u03d5)\n11.3. CHARACTERIZATION BY LOCAL SYSTEMS 251\n\u03b6 \u2208 \u03c4\u22121(\u03be) \u2229 L(A) :\n= (\u2297\ni\u2208[k]\nwt(\u03c4(\u03b6i), \u03d5(\u03b6)|i) ) \u2297 (\u03b4\u2032)k(\u03d5(\u03b6)(1) \u00b7 \u00b7 \u00b7\u03d5(\u03b6)(k), \u03c4k(\u03b8), \u03d5(\u03b6)(\u03b5))\n= wt(\u03c4k(\u03b8)(\u03c4(\u03b61), . . . , \u03c4(\u03b6k)), \u03d5(\u03b6)) (by definition of wt)\n= wt(\u03c4(\u03b8(\u03b61 , . . . , \u03b6k)), \u03d5(\u03b6)) .\nThis proves (11.5). Next we prove that [[A]]run(\u03be) = h(\u03c4\u22121(\u03be) \u2229 L(A)) for each \u03be \u2208 T\u03a3.\nh(\u03c4\u22121(\u03be) \u2229 L(A)) = \u2295\n\u03b6\u2208\u03c4\u22121(\u03be)\u2229L(A)\nh(\u03b6) (by definition)\n= \u2295\n\u03b6\u2208\u03c4\u22121(\u03be)\u2229L(A)\nwt(\u03be, \u03d5(\u03b6)) (by (11.5))\n= \u2295\nq\u2208F,\u03b8\u2208\u0398\n\u2295\n\u03c1\u2208RA((q,\u03b8),\u03be): \u03c4\u0304(\u03c1)=\u03be\nwt(\u03be, \u03c1) (because \u03d5 is bijective)\n= \u2295\nq\u2208F,\u03b8\u2208\u0398\n\u2295\n\u03c1\u2208RA((q,\u03b8),\u03be)\nwt(\u03be, \u03c1) (by (11.4))\n= \u2295\n\u03c1\u2208RA(\u03be)\nwt(\u03be, \u03c1)\u2297 F \u2032\u03c1(\u03b5) = [[A]] run(\u03be)\nAs we have seen, the proof of Theorem 11.3.1(A)\u21d2(B) is based on Theorem 11.2.6 (A)\u21d2(B). Since Observation 2.10.1 is symmetric, one might wonder whether the proof of Theorem 11.2.6 (A)\u21d2(B) could be based on Theorem 11.3.1(A)\u21d2(B). However, this is not possible because there exist local tree languages which are not rule tree languages, see our remark after Lemma 11.2.1.\n252 CHAPTER 11. CHARACTERIZATIONS BY WEIGHTED LOCAL SYSTEMS\nChapter 12\nRational operations and Kleene\u2019s theorem\nIn Chapter 10 we have proved that, in particular, for every commutative semiring B, the set Rec(\u03a3,B) of recognizable (\u03a3,B)-weighted tree languages is closed under the rational operations, i.e., sum, tree concatenations, and Kleene-stars.\nIn Theorem 12.2.3, we will show that each recognizable weighted tree language can be expressed by polynomial weighted tree language and rational operations (cf. [DPV05, Thm. 5.2]). This generalizes the analysis part of Kleene\u2019s result [Kle56] (recognizable implies rational), and the corresponding result for tree languages [TW68, Thm. 9] (cf. [Eng75b, Thm. 3.43] and [GS84, Thm. 2.5.7]) and weighted string languages (cf. [Sch61]). We recall that, in the tree case, extra symbols for tree concatenation were supplied; we will deal with this issue in detail below.\nTaking together the closure results from Chapter 10 and the analysis result from this chapter, we obtain Kleene\u2019s result for recognizable weighted tree languages in Theorem 12.1.2 (cf. [AB87, Thm. 2.3] and [DPV05, Thm. 7.1]). It generalizes the corresponding results for the unweighted case (cf. [TW68, Thm. 8], [Eng75b, Thm. 3.43], and [GS84, Thm. 2.5.8]).\nKleene\u2019s result has been extended both, to structures different from finite trees and to algebras different from semirings, e.g., formal tree series over additive B-\u03a3-algebras for a commutative, \u03c3-complete semiring B [Boz99, p.28] (also cf. [Kui98, Thm. 6.14]), formal power series in partially commuting variables (traces) and semirings [DG99], infinite strings and max-plus semiring [DK03, DK06], strings and lattice-ordered monoids [LP05], pictures and commutative semirings [BG05, Ma\u0308u05, Ma\u0308u07], strings and Conway semirings [E\u0301K, Sect. 1.3], trees over infinite ranked alphabets and continuous and commutative semirings [E\u0301K03, Thm. 4.3], [E\u0301K, Thm. 6.4.3], trees and \u03c3-complete distributive lattices [E\u0301L07], trees and distributive multioperator monoids (which satisfy some closure properties) [FMV09], trees and treevaluation monoids [GFD19], and weighted tree automata with storage over commutative, \u03c3-complete semirings [FV19, DFV21].\nIn this chapter we recall from [DPV05] the proof of the equivalence of recognizable weighted tree languages and rational weighted tree languages for commutative semirings.\nIn the rest of this chapter, B = (B,\u2295,\u2297, 0, 1) denotes an arbitrary commutative semiring."
        },
        {
            "heading": "12.1 Rational weighted tree languages",
            "text": "Here we formally define the concept of rational operations and rational weighted tree languages.\nAn operation on the set of (\u03a3,B)-weighted tree languages is a rational operation if it is the sum, a tree\n253\n254 CHAPTER 12. RATIONAL OPERATIONS AND KLEENE\u2019S THEOREM\nconcatenation, or a Kleene-star. The set of rational (\u03a3,B)-weighted tree languages, denoted by Rat(\u03a3,B), is the smallest set of (\u03a3,B)-weighted tree languages which contains each polynomial (\u03a3,B)-weighted tree language and is closed under the rational operations. We call each weighted tree language in Rat(\u03a3,B) rational.\nFor our main result, we will have to prove, in particular, that the semantics [[A]] of a (\u03a3,B)-wta A = (Q, \u03b4, F ) is rational. We follow the idea of [TW68, Sect. 3] where extra symbols for the tree concatenations are used, and these extra symbols are the states of A. In order to have such extra nullary symbols available for tree concatenations and not to change the type of [[A]] (which is T\u03a3 \u2192 B and not T\u03a3\u222aQ \u2192 B) we use the concept of 0-extension of ranked alphabet and 0-extension of a weighted tree language (cf. [FV19, Def. 1] and [DFV21, Def. 2]).\nFormally, a 0-extension of \u03a3 is a ranked alphabet \u0398 such that \u03a3 \u2286 \u0398, rk\u0398(\u03c3) = rk\u03a3(\u03c3) for each \u03c3 \u2208 \u03a3, and rk\u0398(\u03c3) = 0 for each \u03c3 \u2208 \u0398 \\ \u03a3. If \u0398 is a 0-extension of \u03a3, then we write \u0398 \u22650 \u03a3.\nNow let \u0398 \u22650 \u03a3 and r : T\u03a3 \u2192 B. The 0-extension of r to T\u0398, denoted by r\u21be\u0398,0, is the weighted tree language r\u21be\u0398,0: T\u0398 \u2192 B such that\n(a) (r\u21be\u0398,0)|T\u03a3 = r and (b) (r\u21be\u0398,0)(\u03be) = 0 for every \u03be \u2208 T\u0398 \\ T\u03a3.\nThese concepts have the following transitivity property.\nObservation 12.1.1. Let \u0398 and \u2206 be ranked alphabets such that \u2206 \u22650 \u0398 and \u0398 \u22650 \u03a3. Then \u2206 \u22650 \u03a3. Moreover, let r : T\u03a3 \u2192 B. Then (r\u21be\u0398,0)\u21be\u2206,0= r\u21be\u2206,0.\nThe set of extended rational (\u03a3,B)-weighted tree languages, denoted by Rat(\u03a3,B)ext, contains each (\u03a3,B)-weighted tree language r such that r\u21be\u0398,0\u2208 Rat(\u0398,B) for some 0-extension \u0398 of \u03a3.\nSimilarly, the set of extended recognizable (\u03a3,B)-weighted tree languages, denoted by Rec(\u03a3,B)ext, contains each (\u03a3,B)-weighted tree language r such that r\u21be\u0398,0\u2208 Rec(\u0398,B) for some 0-extension \u0398 of \u03a3.\nIn the next two sections, we will prove that Rec(\u03a3,B) \u2286 Rat(\u03a3,B)ext (cf. Theorem 12.2.3) and Rat(\u03a3,B) \u2286 Rec(\u03a3,B) (cf. Theorem 12.3.1). These theorems imply the following main result of this chapter.\nTheorem 12.1.2. Let \u03a3 be a ranked alphabet and B be a commutative semiring. Then Rec(\u03a3,B)ext = Rat(\u03a3,B)ext.\nProof. Rec(\u03a3,B)ext \u2286 Rat(\u03a3,B)ext: Let r \u2208 Rec(\u03a3,B)ext. Then r\u21be\u0398,0\u2208 Rec(\u0398,B) for some 0-extension \u0398 of \u03a3. By Theorem 12.2.3 (with \u03a3 = \u0398), we have that r\u21be\u0398,0\u2208 Ratext(\u0398,B). Hence (r\u21be\u0398,0)\u21be\u2206,0\u2208 Rat(\u2206,B) for some 0-extension \u2206 of \u0398. Since \u2206 \u22650 \u0398 and \u0398 \u22650 \u03a3, we obtain by Observation 12.1.1 that (r\u21be\u0398,0)\u21be\u2206,0= r\u21be\u2206,0. Hence r\u21be\u2206,0\u2208 Rat(\u2206,B). Since \u2206 \u22650 \u03a3, we obtain r \u2208 Rat(\u03a3,B)ext.\nRat(\u03a3,B)ext \u2286 Rec(\u03a3,B)ext: Let r \u2208 Rat(\u03a3,B)ext. Then r\u21be\u0398,0\u2208 Rat(\u0398,B) for some 0-extension \u0398 of\n\u03a3. By Theorem 12.3.1 (with \u03a3 = \u0398), we have that r\u21be\u0398,0\u2208 Rec(\u0398,B). Hence we have r \u2208 Rec(\u03a3,B)ext.\nWe note that Theorem 12.1.2 is similar to [DPV05, Thm. 7.1], but slightly different in the following way. Theorem 7.1 of [DPV05] says that Brec\u3008\u3008T\u03a3(Q\u221e)\u3009\u3009 = Brat\u3008\u3008T\u03a3(Q\u221e)\u3009\u3009, where\nBrec\u3008\u3008T\u03a3(Q\u221e)\u3009\u3009 is defined to be \u22c3 (Brec\u3008\u3008T\u0398\u3009\u3009 | ranked alphabet \u0398 such that \u0398 \u22650 \u03a3) and Brat\u3008\u3008T\u03a3(Q\u221e)\u3009\u3009 is defined to be \u22c3 (Brat\u3008\u3008T\u0398\u3009\u3009 | ranked alphabet \u0398 such that \u0398 \u22650 \u03a3) and\nBrat\u3008\u3008T\u0398\u3009\u3009 is the smallest set of (\u0398,B)-weighted tree languages which is closed under scalar multiplication, top-concatenations, and rational operations. Moreover, Brec\u3008\u3008T\u0398\u3009\u3009 is just another denotation of the set Rec(\u0398,B).\n12.2. FROM RECOGNIZABLE TO RATIONAL 255\nHowever, this setting yields the following type conflict when trying to prove that Brec\u3008\u3008T\u0398\u3009\u3009 \u2286 Brat\u3008\u3008T\u03a3(Q\u221e)\u3009\u3009 for some 0-extension \u0398 of \u03a3. For each (\u0398,B)-wta A = (Q, \u03b4, F ), its semantics has the type [[A]] : T\u0398 \u2192 B. In [DPV05, Thm. 5.2] it is proved that there exists an r \u2208 Brat\u3008\u3008T\u0398\u222aQ\u3009\u3009 (where \u0398 \u222a Q is a 0-extension of \u0398) such that, for each \u03be \u2208 T\u0398, the equality r(\u03be) = [[A]](\u03be) holds and, for each \u03be \u2208 T\u0398\u222aQ \\ T\u0398, we have r(\u03be) = 0. Nevertheless, by the definition of Brat\u3008\u3008T\u0398\u222aQ\u3009\u3009, r has the type r : T\u0398\u222aQ \u2192 B which is different from the type of [[A]]. Hence [[A]] 6= r and, in fact, there does not exist an r \u2208 Brat\u3008\u3008T\u0398\u222aQ\u3009\u3009 such that [[A]] = r.\nWe solve this type conflict by the concepts of 0-extension and 0-extension. Such a type conflict does not occur in the proof of the analysis theorem [TW68, Thm. 9] because (unweighted) tree languages are not mappings.\nIn [Dro22] the natural question was posed whether Rec(\u03a3,B) \\Rat(\u03a3,B) 6= \u2205, i.e., whether the extra nullary symbols used in Rat(\u03a3,B)ext are really necessary (or just comfortable to use). We claim that, for the ranked alphabet \u03a3 = {\u03c3(2), \u03c3\u2032(2), \u03b1(0)}, the weighted tree language \u03c7Boole(L(K,H)) \u2208 Rec(\u03a3,Boole) \\ Rat(\u03a3,Boole) where (K,H) is the \u03a3-local system with K = {(\u03c3\u03c3\u2032, \u03c3), (\u03b1\u03b1, \u03c3), (\u03b1\u03b1, \u03c3\u2032)} and H = {\u03c3}.\nFinally, we note that there were investigations to overcome the difference between string concatenation and tree concatenation (cf. the discussion at the beginning of Section 10.6) by employing forests and forest concatenation [Str09, Do\u0308r19, Do\u0308r21]. However, since we want to deal with trees, we will not report on these investigations."
        },
        {
            "heading": "12.2 From recognizable to rational",
            "text": "In this section we prove Theorem 12.2.3, i.e., for each (\u03a3,B)-recognizable weighted tree language r there exists a 0-extension \u0398 of \u03a3 such that r\u21be\u0398,0\u2208 Rat(\u0398,B).\nIntuitively, this result shows that the semantics of a wta can be computed in a dynamic programming style. This computation is organized in the same way as the computation of the transitive closure of the edge relation of graphs in [War62], of the all-pairs shortest-path problem in [Flo62], and of the algebraic path problem for idempotent \u03c3-complete semirings [AHU74, Alg. 5.5]. We follow the lines in [DPV05] (which was crucially inspired by [Eng03]).\nAs preparation, we extend the concept of run for trees which may contain states of a wta. If for a position w of a tree \u03be the symbol \u03be(w) is a state, then the extended run assigns the state \u03be(w) to that position. Formally, let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta and \u03be \u2208 T\u03a3(Q). A run of A on \u03be is a mapping \u03c1 : pos(\u03be)\u2192 Q such that \u03c1(w) = \u03be(w) for each w \u2208 posQ(\u03be). In the same way as for runs on trees in T\u03a3, we define the restriction \u03c1|i for a run of A on \u03be \u2208 T\u03a3(Q) and i \u2208 [rk(\u03be(\u03b5))]. Moreover, we denote the set of all runs of A on \u03be by RA(\u03be).\nNext we define, for each \u03be \u2208 T\u03a3(Q), the weight of each run in RA(\u03be). For this we extend the definition of wtA : TR\u2192 B given in (3.1). Formally, we let TRQ = {(\u03be, \u03c1) | \u03be \u2208 T\u03a3(Q), \u03c1 \u2208 RA(\u03be)} and we define the binary relation \u227a on TRQ by\n\u227a= {((\u03be|i, \u03c1|i), (\u03be, \u03c1)) | (\u03be, \u03c1) \u2208 TRQ, i \u2208 [rk(\u03be(\u03b5)]} .\nThen \u227a is well-founded and\nmin\u227a(TRQ) = {(\u03b1, \u03c1) | \u03b1 \u2208 \u03a3 (0), \u03c1 : {\u03b5} \u2192 Q} \u222a {(q, \u03c1) | q \u2208 Q, \u03c1 = {(\u03b5, q)}} .\nWe define the mapping wt\u2032A : TRQ \u2192 B\nby induction on (TRQ,\u227a) as follows. Let (\u03be, \u03c1) \u2208 TRQ. If \u03be \u2208 Q (and hence \u03c1 = {(\u03b5, \u03be)}), then we let wt\u2032A(\u03be, \u03c1) = 1. If \u03be = \u03c3(\u03be1, . . . , \u03bek), then we let\nwt\u2032A(\u03be, \u03c1) = (\u2297\ni\u2208[k]\nwt\u2032A(\u03be|i, \u03c1|i) ) \u2297 \u03b4k ( \u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5) ) , (12.1)\n256 CHAPTER 12. RATIONAL OPERATIONS AND KLEENE\u2019S THEOREM\nwhere k and \u03c3 abbreviate rk(\u03be(\u03b5)) and \u03be(\u03b5), respectively. We call wt\u2032A(\u03be, \u03c1) the weight of \u03c1 (by A on \u03be). If there is no confusion, then we drop the index A from wt\u2032A and write just wt\n\u2032(\u03be, \u03c1) for the weight of \u03c1. Since, for each \u03be \u2208 T\u03a3, we have wt \u2032(\u03be, \u03c1) = wt(\u03be, \u03c1), we drop the prime from wt\u2032 and simply write wt.\nNext we define restrictions on (generalized) runs in the way that we restrict the set of states which may occur at positions different from the root and different from Q-labeled positions. Formally, let q \u2208 Q, P \u2286 Q, and \u03be \u2208 T\u03a3(Q). A q-run of A on \u03be using P is a run \u03c1 : pos(\u03be)\u2192 Q such that\n\u2022 \u03c1(\u03b5) = q, \u2022 \u03c1(w) \u2208 P for each w \u2208 pos(\u03be) \\ ({\u03b5} \u222a posQ(\u03be)).\nThe set of all q-runs of A on \u03be using P is denoted by RPA(q, \u03be). We denote the set \u22c3 q\u2208Q R P A(q, \u03be) by RPA(\u03be).\nNext we recall a particular weighted tree language [Eng03, DPV05] with a slight modification. We consider the 0-extension \u03a3 \u222aQ of \u03a3, i.e., (\u03a3 \u222aQ)(0) = \u03a3(0) \u222a Q. For every P \u2286 Q and q \u2208 Q, we define the weighted tree language SA(P, q) : T\u03a3(Q)\u2192 B for each \u03be \u2208 T\u03a3(Q) by\nSA(P, q)(\u03be) =\n{\u2295 \u03c1\u2208RPA(q,\u03be) wt(\u03be, \u03c1) if \u03be \u2208 T\u03a3(Q) \\Q\n0 otherwise .\nThen, for each q\u2032 \u2208 Q, the weighted tree language SA(P, q) is q\u2032-proper. We recall that in [Eng03, DPV05] the language SA(Q\n\u2032, P, q) was defined where Q\u2032 \u2286 Q. But since we will only use SA(Q,P, q), we refrain from the first parameter and keep it fixed with value Q.\nNext we prove that each SA(P, q) is a rational weighted tree language. For this, we will have to decompose runs of A at particular positions. Formally, let P \u2286 Q, q \u2208 Q, and p \u2208 Q \\ P . Let \u03be \u2208 T\u03a3(Q) \\Q. We define the mapping\n\u03d5 : R P\u222a{p} A (q, \u03be)\u2192 U P\u222a{p}(q, \u03be)\nwhere\nUP\u222a{p}(q, \u03be) = {(v\u0303, \u03c1\u2032, \u03c11, . . . , \u03c1n) | n \u2208 N, v\u0303 = (v1, . . . , vn) in cutp(\u03be) \\ {(\u03b5)}, \u03c1 \u2032 \u2208 RPA(q, \u03be[p]v\u0303),\nand \u03be|vi 6\u2208 Q \\ {p} and \u03c1i \u2208 R P\u222a{p} A (p, \u03be|vi) for each i \u2208 [n]}\nand for every \u03c1 \u2208 R P\u222a{p} A (q, \u03be) we define\n\u03d5(\u03c1) = ((v1, . . . , vn), \u03c1 \u2032, \u03c11, . . . , \u03c1n)\nsuch that the following conditions hold (cf. Figure 12.1):\n1. {w \u2208 \u03c1\u22121(p) \\ {\u03b5} | (\u2200v \u2208 prefix(w) \\ {w}) : \u03c1(v) 6= p} = {v1, . . . , vn}, 2. \u03c1\u2032 : pos(\u03be[p]v\u0303)\u2192 Q is such that \u03c1\n\u2032 = \u03c1|pos(\u03be[p]v\u0303), and 3. for each i \u2208 [n], we have \u03c1i = \u03c1|vi .\nBy the first condition we have \u03be|vi 6\u2208 Q \\ {p}, because otherwise \u03c1(vi) \u2208 Q \\ {p}, and hence vi 6\u2208 \u03c1 \u22121(p).\nObviously, \u03d5 is bijective and, if \u03d5(\u03c1) = ((v1 . . . , vn), \u03c1 \u2032, \u03c11, . . . , \u03c1n), then\nwt(\u03be, \u03c1) = wt(\u03be[p]v\u0303, \u03c1 \u2032)\u2297\n\u2297\ni\u2208[n]\nwt(\u03be|vi , \u03c1i) . (12.2)\nWe note that (12.2) uses (12.1), Observation 3.1.1, and the assumption that B is commutative.\nThe next lemma shows how the weighted tree languages in the family\n(SA(P, q) | P \u2286 Q, q \u2208 Q)\ncan be computed in a dynamic programming style (cf. Figure 12.2)).\n12.2. FROM RECOGNIZABLE TO RATIONAL 257\n258 CHAPTER 12. RATIONAL OPERATIONS AND KLEENE\u2019S THEOREM\nLemma 12.2.1. (cf. [Eng03, Lm. 12] and [DPV05, Lm. 5.1]) For every P \u2286 Q, p \u2208 Q \\ P , and q \u2208 Q, we have\nSA(P \u222a {p}, q) = SA(P, q) \u25e6p SA(P, p) \u2217 p .\nProof. Let P \u2286 Q and p \u2208 Q \\ P . By induction on T\u03a3(Q), we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3(Q) and q \u2208 Q, we have SA(P \u222a {p}, q)(\u03be) = ( SA(P, q) \u25e6p SA(P, p) \u2217 p ) (\u03be) .\nI.B.: Let \u03be \u2208 Q. Then SA(P \u222a {p}, q)(\u03be) = 0 = (SA(P, q) \u25e6p SA(P, p)\u2217p)(\u03be), because SA(P, q) is\nq\u2032-proper for each q\u2032 \u2208 Q. The case that \u03be \u2208 \u03a3(0) is covered in the I.S.\nI.S.: Let \u03be = \u03c3(\u03be1, . . . , \u03bek). For each v\u0303 = (v1, . . . , vn) in cutp(\u03be), we denote vi also by v\u0303i.\nSA(P \u222a {p}, q)(\u03be)\n= \u2295\n\u03c1\u2208R P\u222a{p} A (q,\u03be)\nwt(\u03be, \u03c1) (by definition and the fact that \u03be 6\u2208 Q)\n= \u2295\n(v\u0303,\u03c1\u2032,\u03c11,...,\u03c1n)\u2208UP\u222a{p}(q,\u03be)\nwt(\u03be[p]v\u0303, \u03c1 \u2032)\u2297\n\u2297\ni\u2208[n]\nwt(\u03be|v\u0303i , \u03c1i) (because \u03d5 is a weight preserving bijection)\n= \u2295\nv\u0303=(v1,...,vn)\u2208cutp(\u03be)\\{(\u03b5)}: \u03be[p]v\u0303 6\u2208Q\n(\u2200i\u2208[n]):\u03be|vi 6\u2208Q\\{p}\n\u2295\n\u03c1\u2032\u2208RPA(q,\u03be[p]v\u0303)\n\u2295\n\u03c11\u2208R P\u222a{p} A (p,\u03be|v1)\n\u00b7 \u00b7 \u00b7 \u2295\n\u03c1n\u2208R P\u222a{p} A (p,\u03be|vn )\nwt(\u03be[p]v\u0303, \u03c1 \u2032)\u2297\n\u2297\ni\u2208[n]\nwt(\u03be|vi , \u03c1i)\n(by definition of UP\u222a{p}(q, \u03be))\n= \u2295\nv\u0303=(v1,...,vn)\u2208cutp(\u03be)\\{(\u03b5)}: \u03be[p]v\u0303 6\u2208Q\n(\u2200i\u2208[n]):\u03be|vi 6\u2208Q\\{p}\n( \u2295\n\u03c1\u2032\u2208RPA(q,\u03be[p]v\u0303)\nwt(\u03be[p]v\u0303, \u03c1 \u2032) ) \u2297 \u2297\ni\u2208[n]\n( \u2295\n\u03c1i\u2208R P\u222a{p} A (p,\u03be|vi )\nwt(\u03be|vi , \u03c1i) )\n(by distributivity)\n12.2. FROM RECOGNIZABLE TO RATIONAL 259\n= \u2295\nv\u0303=(v1,...,vn)\u2208cutp(\u03be)\\{(\u03b5)}: \u03be[p]v\u0303 6\u2208Q,\n(\u2200i\u2208[n]):\u03be|vi 6\u2208Q\\{p}\nSA(P, q)(\u03be[p]v\u0303)\u2297 \u2297\ni\u2208[n]\n( (SA(P \u222a {p}, p)\u2295 1.p ) (\u03be|vi)\nIn the previous equality we have used the following argument (for the second factor up to the (n+ 1)-st factor). If, for some i \u2208 [n], we have \u03be|vi = p, then R P\u222a{p} A (p, \u03be|vi) contains exactly one run, say \u03c1, and\n\u03c1(\u03b5) = p. Then \u2295\n\u03c1i\u2208R P\u222a{p} A (p,\u03be|vi )\nwt(\u03be|vi , \u03c1i) = 1. On the other hand, then we have SA(P\u222a{p}, p)(\u03be|vi) =\n0. Thus, we have to add 1.p.\nThen we can continue as follows: \u2295\n(v1,...,vn)\u2208cutp(\u03be)\\{(\u03b5)}: \u03be[p](v1,...,vn) 6\u2208Q,\n(\u2200i\u2208[n]):\u03be|vi 6\u2208Q\\{p}\nSA(P, q)(\u03be[p](v1,...,vn))\u2297 \u2297\ni\u2208[n]\n( (SA(P \u222a {p}, p)\u2295 1.p ) (\u03be|vi)\n= \u2295\n(v1,...,vn)\u2208cutp(\u03be)\\{(\u03b5)}: \u03be[p](v1,...,vn) 6\u2208Q,\n(\u2200i\u2208[n]):\u03be|vi 6\u2208Q\\{p}\nSA(P, q)(\u03be[p](v1,...,vn))\u2297 \u2297\ni\u2208[n]\n( (SA(P, p) \u25e6p SA(P, p) \u2217 p)\u2295 1.p ) (\u03be|vi)\nThe previous equality uses, for each i \u2208 [n], the following facts. If \u03be|vi 6\u2208 Q, then we have used the I.H. with q = p. This is possible because \u03be|vi is a subtree of \u03be due to the condition \u03be[p](v1,...,vn) 6= p. If \u03be|vi = p, then we have used that\n( (SA(P \u222a {p}, p)\u2295 1.p ) (\u03be|vi) = 1 = ( (SA(P, p) \u25e6p SA(P, p) \u2217 p)\u2295 1.p ) (\u03be|vi) .\nThen we can continue as follows: \u2295\n(v1,...,vn)\u2208cutp(\u03be)\\{(\u03b5)}: \u03be[p](v1,...,vn) 6\u2208Q,\n(\u2200i\u2208[n]):\u03be|vi 6\u2208Q\\{p}\nSA(P, q)(\u03be[p](v1,...,vn))\u2297 \u2297\ni\u2208[n]\n( (SA(P, p) \u25e6p SA(P, p) \u2217 p)\u2295 1.p ) (\u03be|vi)\n= \u2295\n(v1,...,vn)\u2208cutp(\u03be)\\{(\u03b5)}: \u03be[p](v1,...,vn) 6\u2208Q,\n(\u2200i\u2208[n]):\u03be|vi 6\u2208Q\\{p}\nSA(P, q)(\u03be[p](v1,...,vn))\u2297 \u2297\ni\u2208[n]\nSA(P, p) \u2217 p(\u03be|vi ) (by Lemma 10.7.3)\n= \u2295\n(v1,...,vn)\u2208cutp(\u03be)\nSA(P, q)(\u03be[p](v1,...,vn))\u2297 \u2297\ni\u2208[n]\nSA(P, p) \u2217 p(\u03be|vi )\n(by definition of SA(P, q) and because SA(P, p) \u2217 p(q) = 0 for each q \u2208 Q \\ {p})\n= ( SA(P, q) \u25e6p SA(P, p) \u2217 p ) (\u03be) (by definition of \u25e6p)\nWith the help of Lemma 12.2.1 we can show that weighted languages of the form SA(P, q) are rational.\nLemma 12.2.2. For every P \u2286 Q and q \u2208 Q we have SA(P, q) \u2208 Rat(\u03a3 \u222aQ,B).\nProof. We prove the statement by induction on (P(Q),\u227a), where for every P, P \u2032 \u2208 P(Q) we define P \u2032 \u227a P if there exists a p \u2208 Q \\P \u2032 such that P = P \u2032 \u222a {p}. Obviously, \u227a is well-founded and min\u227a(P(Q)) = {\u2205}.\nI.B.: Let P = \u2205. For every k \u2208 N, \u03c3 \u2208 \u03a3(k), q, q1, . . . , qk \u2208 Q, we define the run \u03c1\u03c3q1\u00b7\u00b7\u00b7qk,q : pos(\u03c3(q1, . . . , qk))\u2192 Q by \u03c1\u03c3q1\u00b7\u00b7\u00b7qk,q(\u03b5) = q and \u03c1 \u03c3 q1\u00b7\u00b7\u00b7qk,q(i) = qi for each i \u2208 [k]. Then for each \u03be \u2208 T\u03a3(Q) we have\nR\u2205A(q, \u03be) =\n{ {\u03c1\u03c3q1\u00b7\u00b7\u00b7qk,q} if \u03be = \u03c3(q1, . . . , qk)\n\u2205 otherwise .\n260 CHAPTER 12. RATIONAL OPERATIONS AND KLEENE\u2019S THEOREM\nLet \u03a3(Q) = {\u03c3(q1, . . . , qk) | k \u2208 N, \u03c3 \u2208 \u03a3(k), q1, . . . , qk \u2208 Q}. Then\nSA(\u2205, q) = \u2295\n\u03c3(q1,...,qk)\u2208\u03a3(Q)\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q).\u03c3(q1, . . . , qk) .\nSince SA(\u2205, q) is polynomial, we have that SA(\u2205, q) is rational.\nI.S.: Let P = P \u2032 \u222a {p} for some p \u2208 Q \\ P \u2032. For the induction step, we assume that SA(P \u2032, q) is rational for each q \u2208 Q. By Lemma 12.2.1, we have SA(P \u2032 \u222a {p}, q) = SA(P \u2032, q) \u25e6p SA(P \u2032, p)\u2217p. Thus, by I.H. and the definition of rational weighted tree languages, we obtain that SA(P \u2032 \u222a{p}, q) is rational.\nTheorem 12.2.3. (cf. [DPV05, Thm. 5.2]) Rec(\u03a3,B) \u2286 Rat(\u03a3,B)ext.\nProof. Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta with Q = {q1, . . . , qn}. By Theorem 7.3.1 we can assume that A is root weight normalized. Let qf \u2208 Q such that supp(F ) = {qf} and F (qf ) = 1.\nWe will prove that [[A]] \u2208 Rat(\u03a3,B)ext. For this we want to employ Lemma 12.2.2 (for P = Q and q = qf ). We observe that SA(Q, qf )(\u03be) = [[A]](\u03be) for each \u03be \u2208 T\u03a3. Since supp(SA(Q, qf )) may contain trees in T\u03a3(Q) \\ T\u03a3, the weighted tree language SA(Q, qf) may not be the 0-extension of [[A]] to T\u03a3\u222aQ. In order to make it so, we annihilate those trees from supp(SA(Q, qf )).\nTherefore, we define r : T\u03a3(Q)\u2192 B for each \u03be \u2208 T\u03a3(Q) by\nr(\u03be) = (\u00b7 \u00b7 \u00b7 (SA(Q, qf ) \u25e6q1 0\u0303) \u00b7 \u00b7 \u00b7 \u25e6qn 0\u0303)(\u03be) .\nIt is obvious that, for each \u03be \u2208 T\u03a3(Q), we have\nr(\u03be) =\n{ [[A]](\u03be) if \u03be \u2208 T\u03a3\n0 otherwise\ni.e., r = [[A]]\u21be\u03a3\u222aQ,0.\nIt remains to prove that r \u2208 Rat(\u03a3\u222aQ,B). By Lemma 12.2.2 we have that SA(Q, qf ) \u2208 Rat(\u03a3\u222aQ,B). By definition, 0\u0303 is a polynomial, hence 0\u0303 \u2208 Rat(\u03a3 \u222a Q,B). Since Rat(\u03a3 \u222a Q,B) is closed under qiconcatenation, we obtain that r \u2208 Rat(\u03a3 \u222aQ,B). Hence [[A]] \u2208 Rat(\u03a3,B)ext.\nWe finish this section by an informal comparison. If we analyse the proofs of Theorem 12.2.3 and of Lemmas 12.2.1 and 12.2.2, then we realize that, for each wta A, we can represent the weighted tree language [[A]] in terms of polynomials and the operations tree concatenation and Kleene-stars; in particular, the summation \u2295 is not needed. This is different from the situation for (unweighted) string languages. In the following we explain the reason of this difference.\nIn the string case, assuming that the set Q of states of some finite-state string automaton A is {1, . . . , n}, the dynamic programming equality which we use in the analysis of the behaviour of A is\nL (k+1) i,j = L (k) i,j \u222a L (k) i,k+1(L (k) k+1,k+1) \u2217L (k) k+1,j (12.3)\n[Har78, p. 58], where i, j, and k are states; and L (k) i,j is the set of strings which lead A from state i to state j and, intermediately, may only visit states in {1, . . . , k}.\nGeneralizing this scenario to the (unweighted) tree case means to turn the input string 90o counterclockwise, i.e., the starting state is at the leaf, and to extend this monadic tree into a \u201creal\u201d tree by allowing arbitrary ranks. This implies that the computation does not only start at one point (leaf) in one state i but at each leaf, and hence i must be replaced by a whole set P of possible starting states. Then (12.3) turns into\nL (k+1) P,j = L (k) P,j \u222a L (k) P\u222a{k+1},j \u25e6k+1 (L (k) P\u222a{k+1},k+1) \u2217 k+1 \u25e6k+1 L (k) P,k+1 (12.4)\nwhere we assume that k+1 6\u2208 P (and by keeping in mind that the order of arguments of tree concatenation is reversed with respect to that order in string concatenation). This corresponds to (\u2217) on page 78 of [GS84]. Now we can realize that the first part of the union, i.e., the set L (k) P,j, is a subset of L (k) P\u222a{k+1},j and, since the state k + 1 does not occur in trees in L (k) P,j, we obtain that\nL (k) P,j \u2286 L (k) P\u222a{k+1},j \u25e6k+1 (L (k) P\u222a{k+1},k+1) \u2217 k+1 \u25e6k+1 L (k) P,k+1 .\nHence (12.4) turns into\nL (k+1) P,j = L (k) P\u222a{k+1},j \u25e6k+1 (L (k) P\u222a{k+1},k+1) \u2217 k+1 \u25e6k+1 L (k) P,k+1 (12.5)\nand the union disappeared. Then (12.5) corresponds to the equality in [Eng75b, p. 21] where we have to identify the set {1, . . . , k} of states with the set Q of nonterminals, the state k + 1 with the nonterminal B, and the state j with the nonterminal A. Hence, we can represent each recognizable tree language in terms of finite tree languages and the operations tree concatenation and Kleene-stars; in particular, the union is not needed. And we generalized this scenario to recognizable weighted tree languages."
        },
        {
            "heading": "12.3 From rational to recognizable",
            "text": "Here we prove Theorem 12.3.1, i.e., Rat(\u03a3,B) \u2286 Rec(\u03a3,B), or in words: each rational (\u03a3,B)-weighted tree language is recognizable.\nTheorem 12.3.1. Rat(\u03a3,B) \u2286 Rec(\u03a3,B).\nProof. Let r be a polynomial (\u03a3,B)-weighted tree language. Then there exist n \u2208 N+, b1, . . . , bn \u2208 B, and \u03be1, . . . , \u03bek \u2208 T\u03a3 such that r = b1.\u03be1 \u2295 . . . \u2295 bn.\u03ben. Since for each i \u2208 [n] the singleton {\u03bei} is a recognizable \u03a3-tree language, the weighted tree language r is a recognizable step mapping. By Theorem 10.3.1, there exists a crisp deterministic (\u03a3,B)-wta A such that [[A]] = r. Hence r \u2208 Rec(\u03a3,B).\nBy Theorem 10.1.1 and Corollaries 10.6.2 and 10.7.6, the set Rec(\u03a3,B) is closed under the rational operations. Since Rat(\u03a3,B) is the smallest set which contains each polynomial (\u03a3,B)-weighted tree language and is closed under the rational operations, the statement follows."
        },
        {
            "heading": "12.4 Alternative definition of rational weighted tree languages",
            "text": "In Figure 12.3 we give an overview of the relevant sets of rational weighted tree languages where the sets Brat+Pol\u3008\u3008T\u03a3\u3009\u3009 and B rat\u3008\u3008T\u03a3\u3009\u3009ext will be defined below.\n262 CHAPTER 12. RATIONAL OPERATIONS AND KLEENE\u2019S THEOREM\nIn this section we will prove the following: including polynomial weighted tree languages into Brat\u3008\u3008T\u03a3\u3009\u3009 (yielding the set Brat+Pol\u3008\u3008T\u03a3\u3009\u3009) does not enrich the set B\nrat\u3008\u3008T\u03a3\u3009\u3009 (cf. Observation 12.4.2 and [DPV05, Obs. 3.19]). Moreover, we prove that the extensions of the sets Brat\u3008\u3008T\u03a3\u3009\u3009 and Rat(\u03a3,B) are equal when using our concept of 0-extension (cf. Theorem 12.4.7).\nAs preparation, we characterize the set Pol(\u03a3,B) of polynomial (\u03a3,B)-weighted tree languages in terms of closure properties.\nLemma 12.4.1. The set Pol(\u03a3,B) is the smallest set of (\u03a3,B)-weighted tree languages which is closed under sum, scalar multiplications, and top-concatenations. Hence, in particular, Pol(\u03a3,B) \u2286 Brat\u3008\u3008T\u03a3\u3009\u3009.\nProof. For convenience, we denote by C the smallest set of (\u03a3,B)-weighted tree languages which is closed under sum, scalar multiplications, and top-concatenations.\nFirst we prove that each polynomial (\u03a3,B)-weighted tree language is in C. As preparation we prove by induction on T\u03a3 that the monomial 1.\u03be is in C for each \u03be \u2208 T\u03a3. Let \u03be = \u03c3(\u03be1, . . . , \u03bek) and assume that 1.\u03bei is in Pol(\u03a3,B) for each i \u2208 [k]. Obviously,\n1.\u03be = top\u03c3(1.\u03be1, . . . , 1.\u03bek)\nand hence 1.\u03be is in C because C is closed under top-concatenations.\nNow let r : T\u03a3 \u2192 B be polynomial. We distinguish two cases.\nCase (a): Let supp(r) = \u2205. Let \u03b1 \u2208 \u03a3(0) (recall that \u03a3(0) 6= \u2205 by our general assumption on ranked alphabets). Then r = 0\u2297 1.\u03b1, and since 1.\u03b1 is in C and C is closed under scalar multiplications, we have that r is in C.\nCase (b): Let supp(r) = {\u03be1, . . . , \u03ben} for some n \u2208 N+. Then r = \u2295\ni\u2208[n] r(\u03bei)\u2297 (1.\u03bei). By the above, 1.\u03bei is in C. Since C is closed under scalar multiplications and sum, we have that r is in C.\nNext we prove that each r \u2208 C is polynomial, i.e., supp(r) is finite. This is easy to see, because the application of top-concatenations, scalar multiplications, and sum preserve the property of finite support.\nThus Pol(\u03a3,B) = C. The inclusion Pol(\u03a3,B) \u2286 Brat\u3008\u3008T\u03a3\u3009\u3009 follows from the definition of Brat\u3008\u3008T\u03a3\u3009\u3009.\nWe denote by Brat+Pol\u3008\u3008T\u03a3\u3009\u3009 the smallest set of (\u03a3,B)-weighted tree languages which contains Pol(\u03a3,B) and is closed under scalar multiplications, top-concatenations, and the rational operations.\nObservation 12.4.2. [DPV05, Obs. 3.19] Brat\u3008\u3008T\u03a3\u3009\u3009 = B rat +Pol\u3008\u3008T\u03a3\u3009\u3009.\nProof. The inclusion Brat\u3008\u3008T\u03a3\u3009\u3009 \u2286 Brat+Pol\u3008\u3008T\u03a3\u3009\u3009 is obvious. The inclusion B rat +Pol\u3008\u3008T\u03a3\u3009\u3009 \u2286 B rat\u3008\u3008T\u03a3\u3009\u3009 holds because Pol(\u03a3,B) \u2286 Brat\u3008\u3008T\u03a3\u3009\u3009 (by Lemma 12.4.1), the fact that B\nrat\u3008\u3008T\u03a3\u3009\u3009 is closed under scalar multiplications, top-concatenations, and the rational operations, and the fact that Brat+Pol\u3008\u3008T\u03a3\u3009\u3009 is the smallest such set.\nNext we prove that the extensions of the sets Brat\u3008\u3008T\u03a3\u3009\u3009 and Rat(\u03a3,B) (using our concepts of 0- extension) are equal.\nThe set of extended DPV-rational (\u03a3,B)-weighted tree languages, denoted by Brat\u3008\u3008T\u03a3\u3009\u3009ext, contains each (\u03a3,B)-weighted tree language r such that r\u21be\u0398,0\u2208 Brat\u3008\u3008T\u0398\u3009\u3009 for some 0-extension \u0398 of \u03a3.\nThus, we wish to show that Rat(\u03a3,B)ext = Brat\u3008\u3008T\u03a3\u3009\u3009 ext. Intuitively, this means that, for the extended sets, closure under scalar multiplications and top-concatenations can be traded for polynomials, and vice versa. We prove the two directions in separate lemmas.\nLemma 12.4.3. Rat(\u03a3,B)ext \u2286 Brat\u3008\u3008T\u03a3\u3009\u3009ext.\nProof. Let r \u2208 Rat(\u03a3,B)ext. Hence r\u21be\u0398,0\u2208 Rat(\u0398,B) for some 0-extension \u0398 of \u03a3.\nAs next step we prove that r\u21be\u0398,0\u2208 Brat\u3008\u3008T\u0398\u3009\u3009. By Lemma 12.4.1, we have that Pol(\u0398,B) \u2286 Brat\u3008\u3008T\u0398\u3009\u3009. Hence Brat\u3008\u3008T\u0398\u3009\u3009 is a set of (\u0398,B)-weighted tree languages which contains Pol(\u0398,B) and is closed under\n12.4. ALTERNATIVE DEFINITION OF RATIONAL WEIGHTED TREE LANGUAGES 263\nthe rational operations. Since Rat(\u0398,B) is the smallest such set, we obtain Rat(\u0398,B) \u2286 Brat\u3008\u3008T\u0398\u3009\u3009. Hence r\u21be\u0398,0\u2208 Brat\u3008\u3008T\u0398\u3009\u3009. Thus, by definition, we obtain that r \u2208 Brat\u3008\u3008T\u03a3\u3009\u3009ext.\nFor the other direction, i.e., Brat\u3008\u3008T\u03a3\u3009\u3009ext \u2286 Rat(\u03a3,B)ext, we first prove an auxiliary technical lemma.\nLemma 12.4.4. Let \u2206 be a 0-extension of \u03a3 and let r : T\u03a3 \u2192 B. If r \u2208 Rat(\u03a3,B), then r \u21be\u2206,0\u2208 Rat(\u2206,B).\nProof. First, we characterize Rat(\u03a3,B) by means of Theorem 2.6.17 such that we can prove a statement on Rat(\u03a3,B) by induction on N. For this, we consider the \u03c3-complete lattice (P(BT\u03a3),\u2286) and the mapping f : P(BT\u03a3)\u2192 P(BT\u03a3) defined for each C \u2208 P(BT\u03a3) by\nf(C) = C \u222a Pol(\u03a3,B) \u222a {r1 \u2295 r2 | r1, r2 \u2208 C} \u222a {r1 \u25e6\u03b1 r2 | r1, r2 \u2208 C,\u03b1 \u2208 \u03a3 (0)} \u222a\n{(r)\u2217\u03b1 | r \u2208 C,\u03b1 \u2208 \u03a3 (0), and r is \u03b1-proper} .\nThe mapping f is continuous and, by definition,\nRat(\u03a3,B) = \u22c2 (C | C \u2208 P(BT\u03a3) such that f(C) \u2286 C) .\nThen, by Theorem 2.6.17, we have\nRat(\u03a3,B) = \u22c3 (fn(\u2205) | n \u2208 N) . (12.6)\nNow, by induction on N, we prove that the following statement holds:\nFor every n \u2208 N and r : T\u03a3 \u2192 B: if r \u2208 f n(\u2205), then r\u21be\u2206,0\u2208 Rat(\u2206,B). (12.7)\nI.B.: Let n = 0. Since fn(\u2205) = f0(\u2205) = \u2205, statement (12.7) trivially holds.\nI.S.: Let n = n\u2032 + 1 for some n\u2032 \u2208 N. Moreover, let r \u2208 fn(\u2205). We assume that (12.7) holds for each r\u2032 \u2208 fn \u2032 (\u2205). We proceed by case analysis.\nCase (a): Let r \u2208 fn \u2032 (\u2205). Then our statement holds by I.H.\nCase (b): Let r \u2208 Pol(\u03a3,B). Then obviously r\u21be\u2206,0 is a (\u2206,B)-polynomial, hence r\u21be\u2206,0\u2208 Rat(\u2206,B).\nCase (c): Let r = r1 \u2295 r2 for some (\u03a3,B)-weighted tree languages r1 and r2 in fn \u2032 (\u2205). By I.H., we have r1\u21be \u2206,0\u2208 Rat(\u2206,B) and r2\u21be\u2206,0\u2208 Rat(\u2206,B). Obviously, r\u21be\u2206,0= r1\u21be\u2206,0 \u2295r2\u21be\u2206,0. Since Rat(\u2206,B) is closed under sum, we have that r\u21be\u2206,0\u2208 Rat(\u2206,B).\nCases (d) and (e): Let r = r1 \u25e6\u03b1 r2 and r = (r1)\u2217\u03b1, respectively, for some r1 and r2 in f n\u2032(\u2205) and \u03b1 \u2208 \u03a3.\nThe proofs of the cases are similar to the proof of Case (c).\nThis finishes the proof of (12.7). The statement of the lemma follows from (12.7) and (12.6).\nIn the proof of Brat\u3008\u3008T\u03a3\u3009\u3009ext \u2286 Rat(\u03a3,B)ext we will use the fact that, for each 0-extension \u0398 of \u03a3, the set Rat(\u0398,B)ext is closed under scalar-multiplications, top-concatenations, and the rational operations. One way to prove this is to use Rat(\u0398,B)ext \u2286 Rec(\u0398,B)ext (by Theorem 12.1.2), to exploit closure properties of Rec(\u0398,B)ext, and to use Rec(\u0398,B)ext \u2286 Rat(\u0398,B)ext (again by Theorem 12.1.2). But here we show an alternative proof, in which we stay inside the area of rational weighted tree languages.\nLemma 12.4.5. Let \u0398 be an arbitrary ranked alphabet. Then Rat(\u0398,B)ext is closed under (a) scalarmultiplications, (b) top-concatenations, and the (c) rational operations.\nProof. (a) Here we prove that Rat(\u0398,B)ext is closed under scalar-multiplications. Let r \u2208 Rat(\u0398,B)ext and b \u2208 B. We have to prove that b\u2297 r \u2208 Rat(\u0398,B)ext.\n264 CHAPTER 12. RATIONAL OPERATIONS AND KLEENE\u2019S THEOREM\nBy our assumption, r\u21be\u2206,0\u2208 Rat(\u2206,B) for some 0-extension \u2206 of \u0398. Let \u03b1 \u2208 \u2206(0) be an arbitrary nullary symbol (recall that \u2206(0) 6= \u2205 by definition of ranked alphabets.) We define the (\u2206,B)-weighted tree language s by\ns = (b.\u03b1) \u25e6\u03b1 (r\u21be \u2206,0) .\nSince b.\u03b1 \u2208 Rat(\u2206,B) and Rat(\u2206,B) is closed under tree concatenations, we have that s \u2208 Rat(\u2206,B). Moreover, for each \u03be \u2208 T\u2206, we have\ns(\u03be) = b\u2297 ( r\u21be\u2206,0 (\u03be) ) .\nHence s = b\u2297 r\u21be\u2206,0, and since b\u2297 r\u21be\u2206,0= (b \u2297 r)\u21be\u2206,0 we obtain that b\u2297 r \u2208 Rat(\u0398,B)ext.\n(b) We prove that Rat(\u0398,B)ext is closed under top-concatenations. Let k \u2208 N, \u03c3 \u2208 \u0398(k), and r1, . . . , rk be (\u0398,B)-weighted tree languages in Rat(\u0398,B)ext. We have to prove that top\u03c3(r1, . . . , rk) \u2208 Rat(\u0398,B) ext.\nFor each i \u2208 [k] let ri \u21be\u2206i,0\u2208 Rat(\u2206i,B) for some 0-extension \u2206i of \u0398. Without loss of generality we can assume that (\u2206i \\ \u0398) \u2229 (\u2206j \\ \u0398) = \u2205 for every i, j \u2208 [k] with i 6= j. We define the ranked alphabet \u2206 = \u22c3 i\u2208[k] \u2206i. Obviously, \u2206 \u22650 \u2206i for each i \u2208 [k]. By Observation 12.1.1 we have that (ri\u21be \u2206i,0)\u21be\u2206,0= ri\u21be \u2206,0 and hence, by Lemma 12.4.4, we have that ri\u21be \u2206,0\u2208 Rat(\u2206,B).\nLet P = {p1, . . . , pk} be a set disjoint with \u2206. We view \u2206 \u222a P as 0-extension of \u2206. We define the (\u2206 \u222a P,B)-weighted tree language r by\nr = (. . . (1.\u03c3(p1, . . . , pk) \u25e6p1 r1\u21be \u2206\u222aP,0) . . .) \u25e6pk rk\u21be \u2206\u222aP,0 .\nSince 1.\u03c3(p1, . . . , pk) \u2208 Rat(\u2206 \u222a P,B) and ri\u21be\u2206\u222aP,0\u2208 Rat(\u2206 \u222a P,B) (for each i \u2208 [k] by Lemma 12.4.4) and Rat(\u2206 \u222a P,B) is closed under tree concatenations, we have that r \u2208 Rat(\u2206 \u222a P,B).\nWe will show that, for each \u03be \u2208 T\u2206\u222aP , we have\nr(\u03be) =\n{ top\u03c3(r1, . . . , rk)(\u03be) if \u03be = \u03c3(\u03be1, . . . , \u03bek) for some \u03be1, . . . , \u03bek \u2208 T\u0398\n0 otherwise . (12.8)\nHence r = top\u03c3(r1, . . . , rk)\u21be \u2206\u222aP,0. Since \u2206 \u222a P \u22650 \u0398, we obtain that top\u03c3(r1, . . . , rk) \u2208 Rat(\u0398,B) ext.\nFor the proof of (12.8), for each i \u2208 [0, k] we define\nsi = (. . . (1.\u03c3(p1, . . . , pk) \u25e6p1 r1\u21be) . . .) \u25e6pi ri\u21be ,\nwhere rj\u21be is an abbreviation of rj\u21be \u2206\u222aP,0 for each j \u2208 [i]. (We note that s0 = 1.\u03c3(p1, . . . , pk).) Then, by induction on ([0, k], <), we prove that the following statement holds:\nFor each i \u2208 [0, k] and \u03be \u2208 T\u2206\u222aP , we have\nsi(\u03be) =\n{\u2297 j\u2208[i] rj(\u03bej) if \u03be = \u03c3(\u03be1, . . . , \u03bei, pi+1, . . . , pk) for some \u03be1, . . . , \u03bei \u2208 T\u0398\n0 otherwise .\n(12.9)\nLet \u03be \u2208 T\u2206\u222aP .\nI.B.: Let i = 0. The statement is obvious because s0 = 1.\u03c3(p1, . . . , pk) and the product of an \u2205-indexed family over B is defined to be 1.\nI.S.: Let i = i\u2032 + 1: Then we have si(\u03be) = (si\u2032 \u25e6pi ri\u21be)(\u03be) = \u2295\n(w1,...,wn)\u2208cutpi (\u03be)\nsi\u2032(\u03be[pi](w1,...,wn))\u2297 ri\u21be (\u03be|w1)\u2297 . . .\u2297 ri\u21be (\u03be|wn) . (12.10)\nBy the I.H. we obtain\nsi\u2032(\u03be[pi](w1,...,wn)) =    \u2297 j\u2208[i\u2032] rj(\u03bej) if \u03be[pi](w1,...,wn) = \u03c3(\u03be1, . . . , \u03bei\u2032 , pi, . . . , pk) for some \u03be1, . . . , \u03bei\u2032 \u2208 T\u0398\n0 otherwise .\n12.4. ALTERNATIVE DEFINITION OF RATIONAL WEIGHTED TREE LANGUAGES 265\nNow we observe that the condition \u03be[pi](w1,...,wn) = \u03c3(\u03be1, . . . , \u03bei\u2032 , pi, . . . , pk) for some \u03be1, . . . , \u03bei\u2032 \u2208 T\u0398 implies that n = 1, w1 = i and there exists \u03bei \u2208 T\u2206\u222aP such that \u03be = \u03c3(\u03be1, . . . , \u03bei\u2032 , \u03bei, pi, . . . , pk).\nHence (12.10) continues as\n=    (\u2297 j\u2208[i\u2032] rj(\u03bej) ) \u2297 ri\u21be (\u03be|i) if \u03be = \u03c3(\u03be1, . . . , \u03bei\u2032 , \u03bei, pi+1, . . . , pk) for some \u03be1, . . . , \u03bei\u2032 \u2208 T\u0398 and \u03bei \u2208 T\u2206\u222aP\n0 otherwise .\nSince \u03be = \u03c3(\u03be1, . . . , \u03bei\u2032 , \u03bei, pi+1, . . . , pk) implies that \u03be|i = \u03bei, and ri\u21be is the 0-extension of ri to T\u2206\u222aP , we obtain\n=    \u2297 j\u2208[i] rj(\u03bej) if \u03be = \u03c3(\u03be1, . . . , \u03bei\u2032 , \u03bei, pi+1, . . . , pk) for some \u03be1, . . . , \u03bei \u2208 T\u0398\n0 otherwise .\nThis proves (12.9). From this latter, in case i = k and using the definition of top\u03c3(r1, . . . , rk) we obtain (12.8).\n(c) We prove that Rat(\u0398,B)ext is closed under the rational operations, i.e., sum, tree concatenations, and Kleene-stars.\nClosure under sum: Let r1, r2 \u2208 Rat(\u0398,B)ext. We show that r1 \u2295 r2 \u2208 Rat(\u0398,B)ext. Let r1 \u21be \u22061,0\u2208 Rat(\u22061,B) for some 0-extension \u22061 of \u0398. Also let r2 \u21be\u22062,0\u2208 Rat(\u22062,B) for some 0- extension \u22062 of \u0398. Without loss of generality we can assume that (\u22061 \\ \u0398) \u2229 (\u22062 \\ \u0398) = \u2205. We define the ranked alphabet \u2206 = \u22061 \u222a\u22062. Let i \u2208 [2]. Obviously, \u2206 \u22650 \u2206i, and hence \u2206 \u22650 \u0398. By Observation 12.1.1, we have that (ri\u21be \u2206i,0)\u21be\u2206,0= ri\u21be \u2206,0 and hence, by Lemma 12.4.4, we have that ri\u21be \u2206,0\u2208 Rat(\u2206,B).\nSince Rat(\u2206,B) is closed under sum, we obtain that r1\u21be \u2206,0 \u2295r2\u21be\u2206,0\u2208 Rat(\u2206,B). Since (r1 \u2295 r2)\u21be\u2206,0 (\u03be) = r1 \u21be \u2206,0 (\u03be) \u2295 r2 \u21be\u2206,0 (\u03be) for each \u03be \u2208 T\u2206, we have (r1 \u2295 r2)\u21be\u2206,0\u2208 Rat(\u2206,B). Hence r1 \u2295 r2 \u2208 Rat(\u0398,B)ext.\nClosure under tree concatenations: Let r1, r2 \u2208 Rat(\u0398,B)ext and \u03b1 \u2208 \u0398(0). We show that r1 \u25e6\u03b1 r2 \u2208 Rat(\u0398,B)ext. In the same way as above we have that r1\u21be\n\u2206,0\u2208 Rat(\u2206,B) and r2\u21be\u2206,0\u2208 Rat(\u2206,B) for some 0-extension \u2206 of \u0398.\nSince Rat(\u2206,B) is closed under tree concatenations, we obtain that r1\u21be \u2206,0 \u25e6\u03b1r2\u21be\u2206,0\u2208 Rat(\u2206,B). Since (r1 \u25e6\u03b1 r2)\u21be\u2206,0 (\u03be) = r1\u21be\u2206,0 (\u03be) \u25e6\u03b1 r2\u21be\u2206,0 (\u03be) for each \u03be \u2208 T\u2206, we have (r1 \u25e6\u03b1 r2)\u21be\u2206,0\u2208 Rat(\u2206,B). Hence r1 \u25e6\u03b1 r2 \u2208 Rat(\u0398,B)ext.\nClosure under Kleene-stars: Let \u03b1 \u2208 \u0398(0) and r \u2208 Rat(\u0398,B)ext be an \u03b1-proper weighted tree language. We show that r\u2217\u03b1 \u2208 Rat(\u0398,B)\next. By definition, we have that r\u21be\u2206,0\u2208 Rat(\u2206,B) for some 0-extension \u2206 of \u0398.\nSince Rat(\u2206,B) is closed under Kleene stars, we obtain that (r\u21be\u2206,0)\u2217\u03b1 \u2208 Rat(\u2206,B). Since (r \u2217 \u03b1)\u21be \u2206,0\n(\u03be) = (r\u21be\u2206,0)\u2217\u03b1(\u03be) for each \u03be \u2208 T\u2206, we have (r \u2217 \u03b1)\u21be \u2206,0\u2208 Rat(\u2206,B). Hence r\u2217\u03b1 \u2208 Rat(\u0398,B) ext.\nLemma 12.4.6. Brat\u3008\u3008T\u03a3\u3009\u3009ext \u2286 Rat(\u03a3,B)ext.\nProof. Let r \u2208 Brat\u3008\u3008T\u03a3\u3009\u3009 ext. Hence r\u21be\u0398,0\u2208 Brat\u3008\u3008T\u0398\u3009\u3009 for some 0-extension \u0398 of \u03a3.\nBy Lemma 12.4.5, the set Rat(\u0398,B)ext is closed under (a) scalar-multiplications, (b) topconcatenations, and the (c) rational operations. Since Brat\u3008\u3008T\u0398\u3009\u3009 is the smallest set which has these closure properties, we obtain that Brat\u3008\u3008T\u0398\u3009\u3009 \u2286 Rat(\u0398,B)ext, and hence r \u21be\u0398,0\u2208 Rat(\u0398,B)ext. Thus (r\u21be\u0398,0)\u21be\u2206,0\u2208 Rat(\u2206,B) for some 0-extension \u2206 of \u0398. Since \u2206 \u22650 \u0398 and \u0398 \u22650 \u03a3 and (r\u21be\u0398,0)\u21be\u2206,0= r\u21be\u2206,0 by Observation 12.1.1, we obtain that r\u21be\u2206,0\u2208 Rat(\u2206,B). Thus, by definition, we have r \u2208 Rat(\u03a3,B)ext.\nThen the next theorem follows from Lemmas 12.4.3 and 12.4.6.\n266 CHAPTER 12. RATIONAL OPERATIONS AND KLEENE\u2019S THEOREM\nTheorem 12.4.7. Let \u03a3 be a ranked alphabet and B be a commutative semiring. Then Rat(\u03a3,B)ext = Brat\u3008\u3008T\u03a3\u3009\u3009ext.\nChapter 13\nElementary operations and Me\u0301dve\u0301dje\u0301v\u2019s theorem\nIn his paper [Me\u0301d56] (cf. also [Bli65]), Me\u0301dve\u0301dje\u0301v proved a characterization of the set of regular string languages as the smallest set of string languages which contains some elementary sets and is closed under some elementary operations. He considered this as an alternative to Kleene\u2019s characterization in terms of finite languages and the rational operations. This characterization has been generalized to the tree case in [GS84, Thm. 2.8.6] and to the weighted case for semirings in [Her17] and [Her20b, Ch. 5]. In this chapter we will report on the generalization to the weighted tree case following [Her20b, Ch. 5], and we will go slightly beyond this.\nWe will prove the main theorem for semirings. However, some of the lemmas also hold for arbitrary strong bimonoids because distributivity is not needed. We note that we will use these lemmas in Chapter 19 (for bounded lattices)."
        },
        {
            "heading": "13.1 Representable weighted tree languages",
            "text": "In this section we define the generalizations of the mentioned elementary sets and elementary operations to the weighted tree case. First we define the set of B-representations. It is a family of sets RepEx(\u03a3,B) of expressions where \u03a3 is an arbitrary ranked alphabet; this provides the type of these expressions.\nFormally, the family of B-representations, denoted by RepEx(B), is the family\nRepEx(B) = (RepEx(\u03a3,B) | \u03a3 ranked alphabet)\ndefined as the smallest family R = (R(\u03a3) | \u03a3 ranked alphabet) of expressions such that Conditions (1)-(6) hold. (We recall that \u2206 is an arbitrary ranked alphabet.)\n(1) For every \u03c3 \u2208 \u03a3 and b \u2208 B, the expression RT\u03a3,\u03c3,b is in R(\u03a3). (2) For every k \u2208 N+, element \u03b3\u0303 = (\u03b31, . . . , \u03b3k) of \u03a3k, and b \u2208 B, the expression NXT\u03a3,\u03b3\u0303,b is in R(\u03a3). (3) If e1, e2 \u2208 R(\u03a3), then e1 + e2 \u2208 R(\u03a3). (4) If e1, e2 \u2208 R(\u03a3), then e1 \u00d7 e2 \u2208 R(\u03a3). (5) If e \u2208 R(\u2206) and \u03c4 is a (\u2206,\u03a3)-tree relabeling, then \u03c4(e) \u2208 R(\u03a3). (6) If e \u2208 R(\u03a3), then REST(e) \u2208 R(\u03a3).\nWe note that in Case (5) the type of the representation changes from \u2206 to \u03a3 according to the type of the tree relabeling. Moreover, in [Her17] and [Her20b, Ch. 5], only deterministic tree relabelings are allowed. But since the set of recognizable weighted tree languages is closed under arbitrary tree relabelings (cf. Theorem 10.10.1), we can prove the main theorem also for a larger set of representations.\n267\n268 CHAPTER 13. ELEMENTARY OPERATIONS AND ME\u0301DVE\u0301DJE\u0301V\u2019S THEOREM\nInformally, we might understand the set RepEx(B) as the set of expressions generated by the following EBNF; it uses the infinite family (e\u03a3 | \u03a3 ranked alphabet) of nonterminals, and for each nonterminal e\u03a3 it has the following rule:\ne\u03a3 ::= RT\u03a3,\u03c3,b | NXT\u03a3,\u03b3\u0303,b | e\u03a3 + e\u03a3 | e\u03a3 \u00d7 e\u03a3 | \u03c4(e\u2206) | REST(e\u03a3) (13.1)\nwhere \u03c3 \u2208 \u03a3, \u03b3\u0303 \u2208 \u03a3k for some k \u2208 N+, b \u2208 B, and \u03c4 is a (\u2206,\u03a3)-tree relabeling.\nIn order to perform inductive proofs or to define objects by induction, we will consider the well-founded set\n(RepEx(B),\u227a)\nwhere \u227a is the binary relation on RepEx(B) defined as follows. For every e1, e2 \u2208 RepEx(B) we let e1 \u227a e2 if e1 is a direct subexpression of e2 in the sense of (13.1). The relation \u227a is well-founded, and min\u227a(RepEx(B)) is the set of all representations of the form RT\u03a3,\u03c3,b or NXT\u03a3,\u03b3\u0303,b.\nNext we define the semantics of B-expressions by induction on (RepEx(B),\u227a). In particular, for each e \u2208 RepEx(\u03a3,B), the semantics of e is a weighted tree language [[e]] : T\u03a3 \u2192 B.\n(1) Let \u03c3 \u2208 \u03a3 and b \u2208 B. We define [[RT\u03a3,\u03c3,b]] : T\u03a3 \u2192 B by\n[[RT\u03a3,\u03c3,b]] = b\u2297 \u03c7(L\u03a3,\u03c3)\nwhere L\u03a3,\u03c3 = {\u03be \u2208 T\u03a3 | \u03be(\u03b5) = \u03c3}. That is, for every \u03be \u2208 T\u03a3, we have\n[[RT\u03a3,\u03c3,b]](\u03be) =\n{ b if \u03be \u2208 L\u03a3,\u03c3\n0 otherwise .\nA weighted tree language of the form [[RT\u03a3,\u03c3,b]] is called (\u03a3, \u03c3, b)-root mapping or simply root mapping.\n(2) Let k \u2208 N+, \u03b3\u0303 = (\u03b31, . . . , \u03b3k) be an element of \u03a3k, and b \u2208 B. We define [[NXT\u03a3,\u03b3\u0303,b]] : T\u03a3 \u2192 B by\nNXT\u03a3,\u03b3\u0303,b = b\u2297 \u03c7(L\u03a3,\u03b3\u0303)\nwhere L\u03a3,\u03b3\u0303 = {\u03be \u2208 T\u03a3 | rk(\u03be(\u03b5)) = k \u2227 (\u2200i \u2208 [k]) : \u03be(i) = \u03b3i}. That is, for every \u03be \u2208 T\u03a3, we have\n[[NXT\u03a3,\u03b3\u0303,b]](\u03be) = { b if \u03be \u2208 L\u03a3,\u03b3\u0303 0 otherwise .\nIn particular, if \u03a3(k) = \u2205, then L\u03a3,\u03b3\u0303 = \u2205 and thus [[NXT\u03a3,\u03b3\u0303,b]] = 0\u0303. A weighted tree language of the form [[NXT\u03a3,\u03b3\u0303,b]] is called (\u03a3, \u03b3\u0303, b)-next mapping or simply next mapping.\n(3) Let e1, e2 \u2208 RepEx(\u03a3,B). We define [[e1 + e2]] : T\u03a3 \u2192 B by [[e1 + e2]] = [[e1]]\u2295 [[e2]].\n(4) Let e1, e2 \u2208 RepEx(\u03a3,B). We define [[e1 \u00d7 e2]] : T\u03a3 \u2192 B by [[e1 \u00d7 e2]] = [[e1]]\u2297 [[e2]].\n(5) Let e \u2208 RepEx(\u2206,B) and \u03c4 is a (\u2206,\u03a3)-tree relabeling. We define [[\u03c4(e)]] : T\u03a3 \u2192 B by [[\u03c4(e)]] = \u03c7(\u03c4)([[e]]).\n(6) Let e \u2208 RepEx(\u03a3,B). We define [[REST(e)]] : T\u03a3 \u2192 B for each \u03be \u2208 T\u03a3 by\n[[REST(e)]](\u03be) = \u2297\nw\u2208pos(\u03be) in \u2264dp order\n[[e]](\u03be|w) ,\ni.e., the factors of the product are ordered by depth-first post-order <dp on pos(\u03be). The weighted tree language [[REST(e)]] is called the restriction of [[e]].\n13.1. REPRESENTABLE WEIGHTED TREE LANGUAGES 269\nWe extend the binary operation + on the set of B-expressions in the natural way to an operation with a finite set I of arguments ei with i \u2208 I, and we denote this expression by +i\u2208I ei. The weighted tree language [[+i\u2208I ei]] is well defined, because \u2295 is associative and commutative.\nLet r : T\u03a3 \u2192 B be a weighted tree language. We say that r is elementary if r is a root mapping or a next mapping. Since each of the \u03a3-tree languages L\u03a3,\u03c3 and L\u03a3,\u03b3\u0303 is recognizable, each elementary (\u03a3,B)-weighted tree language is a (\u03a3,B)-recognizable one-step mapping. The operations sum, Hadamard product, tree relabeling, and restriction (cf. (3)-(6), respectively) are called elementary operations.\nA weighted tree language r : T\u03a3 \u2192 B is representable if there exists an e \u2208 RepEx(\u03a3,B) such that r = [[e]]. The set of all representable (\u03a3,B)-weighted tree languages is denoted by Rep(\u03a3,B). Moreover, Rep( ,B) denotes the set of all representable (\u03a3,B)-weighted tree languages for some ranked alphabet \u03a3. Hence, Rep( ,B) is the smallest set of B-weighted tree languages which contains the elementary weighted tree languages and is closed under the elementary operations.\nNext we give an example of a recognizable (\u03a3,Natmax,+)-weighted tree language which is representable.\nExample 13.1.1. We consider the ranked alphabet \u03a3 = {\u03c3(2), \u03b3(1), \u03b1(0)}, the arctic semiring Natmax,+ = (N\u2212\u221e,max,+,\u2212\u221e, 0), and the weighted tree language #\u03c3(.,\u03b1) : T\u03a3 \u2192 N defined in Example 3.2.11. We recall that, for each \u03be \u2208 T\u03a3, the value #\u03c3(.,\u03b1)(\u03be) is the number of occurrences of the pattern \u03c3(., \u03b1) in \u03be. In Example 3.2.12 we gave a bu deterministic (\u03a3,Natmax,+)-wta A such that [[A]](\u03be) = #\u03c3(.,\u03b1)(\u03be) for each \u03be \u2208 T\u03a3.\nNow we give an Natmax,+-representation e such that [[e]] = [[A]]. We define\ne = REST (( +\u03ba\u2208\u03a3NXT\u03a3,\u03ba\u03b1,0 ) \u00d7 RT\u03a3,\u03c3,1 ++\u03ba\u2208\u03a3RT\u03a3,\u03ba,0 )\nwhere we have assumed that \u00d7 has higher binding priority than +, and we have abbreviated (\u03ba, \u03b1) by \u03ba\u03b1.\nFirst, we observe that, for each \u03be \u2208 T\u03a3, we have [[+ \u03ba\u2208\u03a3 RT\u03a3,\u03ba,0]](\u03be) = 0. Second, by using the abbrevi-\nation e\u2032 = ( +\u03ba\u2208\u03a3NXT\u03a3,\u03ba\u03b1,0 ) \u00d7 RT\u03a3,\u03c3,1 ,\nwe prove by case analysis that, for each \u03be \u2208 T\u03a3,\n[[e\u2032]](\u03be) =\n{ 1 if \u03be = \u03c3(\u03be\u2032, \u03b1) for some \u03be\u2032 \u2208 T\u03a3\n\u2212\u221e otherwise .\nCase (a): Let \u03be(\u03b5) = \u03b1. Then\n[[e\u2032]](\u03be) = [[+\u03ba\u2208\u03a3NXT\u03a3,\u03ba\u03b1,0]](\u03be) + [[RT\u03a3,\u03c3,1]](\u03be) = [[+\u03ba\u2208\u03a3NXT\u03a3,\u03ba\u03b1,0]](\u03be) +\u2212\u221e (because \u03be(\u03b5) = \u03b1) = \u2212\u221e .\nCase (b): Let \u03be(\u03b5) = \u03b3. In a similar way as in Case (a), we can calculate that [[e\u2032]](\u03be) = \u2212\u221e.\nCase (c): Let \u03be(\u03b5) = \u03c3 and \u03be(2) 6= \u03b1. Then\n[[e\u2032]](\u03be) = max([[NXT\u03a3,\u03c3\u03b1,0]](\u03be), [[NXT\u03a3,\u03b3\u03b1,0]](\u03be), [[NXT\u03a3,\u03b1\u03b1,0]](\u03be)) + [[RT\u03a3,\u03c3,1]](\u03be)\n= max(\u2212\u221e,\u2212\u221e,\u2212\u221e) + 1 = \u2212\u221e .\nCase (d): Let \u03be(\u03b5) = \u03c3, \u03be(2) = \u03b1, and \u03be(1) = \u03c3. Then\n[[e\u2032]](\u03be) = max([[NXT\u03a3,\u03c3\u03b1,0]](\u03be), [[NXT\u03a3,\u03b3\u03b1,0]](\u03be), [[NXT\u03a3,\u03b1\u03b1,0]](\u03be)) + [[RT\u03a3,\u03c3,1]](\u03be)\n= max(0,\u2212\u221e,\u2212\u221e) + 1 = 0 + 1 = 1 .\n270 CHAPTER 13. ELEMENTARY OPERATIONS AND ME\u0301DVE\u0301DJE\u0301V\u2019S THEOREM\nCase (e): Let \u03be(\u03b5) = \u03c3, \u03be(2) = \u03b1, and \u03be(1) = \u03b3. Then\n[[e\u2032]](\u03be) = max([[NXT\u03a3,\u03c3\u03b1,0]](\u03be), [[NXT\u03a3,\u03b3\u03b1,0]](\u03be), [[NXT\u03a3,\u03b1\u03b1,0]](\u03be)) + [[RT\u03a3,\u03c3,1]](\u03be)\n= max(\u2212\u221e, 0,\u2212\u221e) + 1 = 0 + 1 = 1 .\nCase (f): Let \u03be(\u03b5) = \u03c3, \u03be(2) = \u03b1, and \u03be(1) = \u03b1. Then\n[[e\u2032]](\u03be) = max([[NXT\u03a3,\u03c3\u03b1,0]](\u03be), [[NXT\u03a3,\u03b3\u03b1,0]](\u03be), [[NXT\u03a3,\u03b1\u03b1,0]](\u03be)) + [[RT\u03a3,\u03c3,1]](\u03be)\n= max(\u2212\u221e,\u2212\u221e, 0) + 1 = 0 + 1 = 1 .\nHence, for each \u03be \u2208 T\u03a3, we have\n[[e\u2032 ++\u03ba\u2208\u03a3RT\u03a3,\u03ba,0]](\u03be) = { 1 if \u03be = \u03c3(\u03be\u2032, \u03b1) for some \u03be\u2032 \u2208 T\u03a3 0 otherwise . (13.2)\nFinally, for each \u03be \u2208 T\u03a3, we can calculate as follows:\n[[e]](\u03be) = [[REST(e\u2032 ++\u03ba\u2208\u03a3RT\u03a3,\u03ba,0)]](\u03be) = + w\u2208pos(\u03be) [[e\u2032 ++\u03ba\u2208\u03a3RT\u03a3,\u03ba,0]](\u03be|w) = +\nw\u2208pos(\u03be): \u03be(w)=\u03c3,\u03be(w2)=\u03b1\n1 (by (13.2))\n= #\u03c3(.,\u03b1)(\u03be) .\nIt turns out that each recognizable (\u03a3,B)-weighted tree language is representable, but not vice versa as the next example shows.\nExample 13.1.2. [Her20b, Ex. 5.2.1] We consider the string ranked alphabet \u03a3 = {\u03b3(1), \u03b1(0)} and the semiring Nat = (N,+, \u00b7, 0, 1) of natural numbers. Moreover, we let r : T\u03a3 \u2192 N such that r(\u03b3n(\u03b1)) = 2(n+1) 2 for each n \u2208 N.\nWe show that there does not exist a (\u03a3,Nat)-wta A such that [[A]] = r. For this, we assume that there exists such a (\u03a3,N)-wta. Then, by Lemma 3.5.6, there exists K \u2208 N such that, for each n \u2208 N, we have [[A]](\u03b3n(\u03b1)) = [[e]](\u03b3n(\u03b1)) = 2(n+1) 2 \u2264 Kn+1. However, this is a contradiction, because if n is big enough, then 2(n+1) 2 > Kn+1.\nNext we consider the N-representation\ne = REST(RT\u03a3,\u03b3,2 +RT\u03a3,\u03b1,2)\u00d7 REST(REST(RT\u03a3,\u03b3,4 +RT\u03a3,\u03b1,1))\nLet n \u2208 N. Then we can calculate as follows (where we denote by \u220f\nthe extension of the binary operation \u00b7 to finite numbers of arguments):\n[[REST(RT\u03a3,\u03b3,2 +RT\u03a3,\u03b1,2)]](\u03b3 n(\u03b1))\n= \u220f\nw\u2208pos(\u03be)\n[[RT\u03a3,\u03b3,2 +RT\u03a3,\u03b1,2]](\u03b3 n(\u03b1)|w) (note that \u00b7 is commutative)\n=[[RT\u03a3,\u03b3,2 +RT\u03a3,\u03b1,2]](\u03b1) \u00b7 \u220f\nw\u2208pos(\u03be)\\{1n}\n[[RT\u03a3,\u03b3,2 +RT\u03a3,\u03b1,2]](\u03b3 n(\u03b1)|w)\n=[[RT\u03a3,\u03b1,2]](\u03b1) \u00b7 \u220f\nw\u2208pos(\u03be)\\{1n}\n[[RT\u03a3,\u03b3,2]](\u03b3 n(\u03b1)|w)\n=2 \u00b7 \u220f\nw\u2208pos(\u03be)\\{1n}\n2 = 2n+1 .\n13.1. REPRESENTABLE WEIGHTED TREE LANGUAGES 271\nIn a similar way we can calculate that [[REST(RT\u03a3,\u03b3,4 + RT\u03a3,\u03b1,1)]](\u03b3 n(\u03b1)) = 4n. Using Gaussian sum, we have\nREST(REST(RT\u03a3,\u03b3,4 +RT\u03a3,\u03b1,1))(\u03b3 n(\u03b1)) =\n\u220f\nw\u2208pos(\u03be)\nREST(RT\u03a3,\u03b3,4 +RT\u03a3,\u03b1,1)(\u03b3 n(\u03b1)|w)\n= 1 \u00b7 41 \u00b7 42 \u00b7 . . . \u00b7 4n = 4 n2+n 2 = 2n 2+n .\nFinally, [[e]](\u03b3n(\u03b1)) = 2n+1 \u00b7 2n 2+n = 2(n+1) 2 .\nHence, for a characterization of Rec(\u03a3,B) in terms of representations, we have to restrict the set Rep(\u03a3,B) (cf. [Her20b, Sec. 5.2]). We define the restriction in a purely syntactic way (in contrast to [Her17, Her20b]). In fact, we define two restrictions: restricted representations and \u00d7-restricted representations. Intuitively,\n\u2022 in a restricted representation, (a) REST may not occur nested and (b) each tree relabeling occurring in a subexpression of the form REST(e) must be non-overlapping, and \u2022 a \u00d7-restricted representation is a restricted representation such that, in each subexpression of the form e1 \u00d7 e2, there exists at least one i \u2208 {1, 2} such that ei does not contain REST and each tree relabeling in ei is non-overlapping.\nFormally, let RepExr(B) be the subset of RepEx(B) generated by the following EBNF; it uses the infinite family (er\u03a3 | \u03a3 ranked alphabet) \u222a (f r \u03a3 | \u03a3 ranked alphabet) of nonterminals, and for every nonterminals er\u03a3 and f r \u03a3 it has the following rules:\ner\u03a3 ::= RT\u03a3,\u03c3,b | NXT\u03a3,\u03b3\u0303,b | e r \u03a3 + e r \u03a3 | e r \u03a3 \u00d7 e r \u03a3 | \u03c4(e r \u2206) | REST(f r \u03a3) f r\u03a3 ::= RT\u03a3,\u03c3,b | NXT\u03a3,\u03b3\u0303,b | f r \u03a3 + f r \u03a3 | f r \u03a3 \u00d7 f r \u03a3 | \u03c4 \u2032(f r\u2206) (13.3)\nwhere \u03c3 \u2208 \u03a3, \u03b3\u0303 \u2208 \u03a3k for some k \u2208 N+, b \u2208 B, \u03c4 is a (\u2206,\u03a3)-tree relabeling, and \u03c4 \u2032 is a non-overlapping (\u2206,\u03a3)-tree relabeling. We call each element of RepExr(B) a restricted representation.\nLet RepEx\u00d7r(B) be the subset of RepExr(B) generated by the following EBNF; it uses the infinite family (e\u00d7r\u03a3 | \u03a3 ranked alphabet)\u222a (f r \u03a3 | \u03a3 ranked alphabet) of nonterminals, and for every nonterminals e\u00d7r\u03a3 and f r \u03a3 it has the following rules:\ne\u00d7r\u03a3 ::= RT\u03a3,\u03c3,b | NXT\u03a3,\u03b3\u0303,b | e \u00d7r \u03a3 + e \u00d7r \u03a3 | e \u00d7r \u03a3 \u00d7 f r \u03a3 | f r \u03a3 \u00d7 e \u00d7r \u03a3 | f r \u03a3 \u00d7 f r \u03a3 | \u03c4(e \u00d7r \u2206 ) | REST(f r \u03a3)\nf r\u03a3 ::= RT\u03a3,\u03c3,b | NXT\u03a3,\u03b3\u0303,b | f r \u03a3 + f r \u03a3 | f r \u03a3 \u00d7 f r \u03a3 | \u03c4 \u2032(f r\u2206) (13.4)\nwhere \u03c3 \u2208 \u03a3, \u03b3\u0303 \u2208 \u03a3k for some k \u2208 N+, b \u2208 B, \u03c4 is a (\u2206,\u03a3)-tree relabeling, and \u03c4 \u2032 is a non-overlapping (\u2206,\u03a3)-tree relabeling. We call each element of RepEx\u00d7r(B) a \u00d7-restricted representation. We note that the rules for the nonterminals f r\u03a3 in (13.3) and (13.4) are identical. Clearly, RepEx\n\u00d7r(B) \u2282 RepExr(B) \u2282 RepEx(B).\nA weighted tree language r : T\u03a3 \u2192 B is restricted representable (and \u00d7-restricted representable) if there exists an e \u2208 RepExr(\u03a3,B) (and an e \u2208 RepEx\u00d7r(\u03a3,B), respectively) such that r = [[e]].\nCorollary 13.1.3. Let e \u2208 RepExr(\u03a3,B) be generated by nonterminals of the form f r\u03a3 using the rules in (13.3). Then we can construct n \u2208 N+, b1, . . . , bn \u2208 B, and \u03a3-fta A1, . . . , An such that [[e]] =\u2295\ni\u2208[n] bi \u2297 \u03c7(L(Ai)). Thus, in particular, [[e]] is a recognizable step mapping.\nProof. We prove the statement by induction on (RepEx(B)\u2032,\u227a\u2032), where RepEx(B)\u2032 is the set of all representations which can be generated by nonterminals of the form f r\u03a3 using the rules in (13.3), and \u227a\u2032=\u227a |RepEx(B)\u2032\u00d7RepEx(B)\u2032 .\nI.B.: For each e \u2208 RepEx(B)\u2032 of the form e = RT\u03a3,\u03c3,b or e = NXT\u03a3,\u03b3\u0303,b, we can easily construct the \u03a3-fta A\u03a3,\u03c3 and A\u03a3,\u03b3\u0303 such that L(A\u03a3,\u03c3) = L\u03a3,\u03c3 and L(A\u03a3,\u03b3\u0303) = L\u03a3,\u03b3\u0303 . Then [[RT\u03a3,\u03c3,b]] = b \u2297 \u03c7(L(A\u03a3,\u03c3)) and [[NXT\u03a3,\u03b3\u0303,b]] = b\u2297 \u03c7(L(A\u03a3,\u03b3\u0303)).\nI.S.: It follows from Theorem 10.3.1(B)\u21d2(A) and\n272 CHAPTER 13. ELEMENTARY OPERATIONS AND ME\u0301DVE\u0301DJE\u0301V\u2019S THEOREM\n\u2022 Theorem 10.1.1(2) (for the sum), \u2022 Theorem 10.4.1(3) (for the Hadamard product), and \u2022 Theorem 10.10.1 (for the non-overlapping tree relabeling).\nFor instance, the Natmax,+-representation\ne = REST (( +\u03ba\u2208\u03a3NXT\u03a3,\u03ba\u03b1,0 ) \u00d7 RT\u03a3,\u03c3,1 ++\u03ba\u2208\u03a3RT\u03a3,\u03ba,0 )\nshown in Example 13.1.1 is \u00d7-restricted.\nNow we can formulate the main result of this chapter.\nTheorem 13.1.4. (cf. [Her17, Thm. 6] and [Her20b, Thm. 5.2.2]) Let \u03a3 be a ranked alphabet, B be a semiring, and r : T\u03a3 \u2192 B. Then the following two statements are equivalent. (A) We can construct a (\u03a3,B)-wta A such that [[A]] = r. (B) We can construct an e \u2208 RepEx\u00d7r(\u03a3,B) such that [[e]] = r. Moreover, if B is commutative, then (A) and (B) are equivalent to: (C) We can construct an e \u2208 RepExr(\u03a3,B) such that [[e]] = r.\nThe proof of this theorem follows from Lemmas 13.2.2 and 13.3.2, which will be shown in the next two sections.\nWe note that in [Her17] and [Her20a, Sect. 5.3], a comparison between representable weighted tree languages and weighted tree languages defined by the weighted MSO-logic of [DG05, DG07, DG09] has been started."
        },
        {
            "heading": "13.2 From recognizable to restricted representable",
            "text": "Since each wta can be decomposed into a deterministic tree relabeling and a weighted local system (cf. Theorem 11.2.6) and the set Rep( ,B) is closed under tree relabelings (by definition), we first prove that each weighted tree language determined by a weighted local system is \u00d7-restricted representable.\nLemma 13.2.1. Let S be a (\u03a3,B)-wls. Then we can construct an e \u2208 RepEx\u00d7r(\u03a3,B) such that [[e]] = [[S]].\nProof. Let S = (g, F ) be a (\u03a3,B)-wls. The idea for the construction of e \u2208 RepEx\u00d7r(\u03a3,B) is to simulate the weight gk((\u03c31 \u00b7 \u00b7 \u00b7\u03c3k, \u03c3)) of the fork (\u03c31 \u00b7 \u00b7 \u00b7\u03c3k, \u03c3) by the representation NXT\u03a3,(\u03c31,...,\u03c3k),1 \u00d7 RT\u03a3,\u03c3,gk(\u03c31\u00b7\u00b7\u00b7\u03c3k,\u03c3) if k \u2265 1, and by the representation RT\u03a3,\u03c3,g0(\u03b5,\u03c3) if k = 0.\nFormally, we define the B-representation e = REST(e1 + e2)\u00d7 e3 where\ne1 =+\u03c3\u2208\u03a3(0) RT\u03a3,\u03c3,g0(\u03b5,\u03c3) and e2 =+k\u22651,\u03c3\u2208\u03a3(k) , \u03c31,...,\u03c3k\u2208\u03a3 (NXT\u03a3,(\u03c31,...,\u03c3k),1 \u00d7 RT\u03a3,\u03c3,gk(\u03c31\u00b7\u00b7\u00b7\u03c3k,\u03c3))\nand e3 =+\u03c3\u2208\u03a3 RT\u03a3,\u03c3,F (\u03c3) . It is easy to see that e is \u00d7-restricted. It remains to show that [[S]] = [[e]]. Obviously,\nfor every \u03be \u2208 T\u03a3, we have [[e3]](\u03be) = F (\u03be(\u03b5)). (13.5)\nMoreover,\nfor every \u03be \u2208 T\u03a3 and w \u2208 pos(\u03be), we have [[e1 + e2]](\u03be|w) = grk(\u03be(w))(\u03be(w1) \u00b7 \u00b7 \u00b7 \u03be(w rk(\u03be(w))), \u03be(w)). (13.6)\n13.3. FROM RESTRICTED REPRESENTABLE TO RECOGNIZABLE 273\nThen, for each \u03be \u2208 T\u03a3, we can calculate as follows.\n[[REST(e1 + e2)\u00d7 e3]](\u03be) = ( \u2297\nw\u2208pos(\u03be), in \u2264dp order\n[[e1 + e2]](\u03be|w) ) \u2297 [[e3]](\u03be)\n= ( \u2297\nw\u2208pos(\u03be), in \u2264dp order\ngrk(\u03be(w)) ( \u03be(w1) \u00b7 \u00b7 \u00b7 \u03be(w rk(\u03be(w))), \u03be(w) )) \u2297 [[e3]](\u03be) (by (13.6))\n= g(\u03be)\u2297 F (\u03be(\u03b5)) (by definition of g and (13.5))\n= [[S]](\u03be) .\nLemma 13.2.2. (cf. [Her17, Lm. 12] and [Her20b, Thm. 5.2.8]) Let A be a (\u03a3,B)-wta. Then we can construct an e \u2208 RepEx\u00d7r(\u03a3,B) such that [[A]]run = [[e]].\nProof. By Theorem 11.2.6, we can construct a ranked alphabet \u0398, a deterministic (\u0398,\u03a3)-tree relabeling \u03c4 , and a (\u0398,B)-weighted local system S with unit root weights such that [[A]]run = \u03c7(\u03c4)([[S]]). By Lemma 13.2.1, we can construct an e\u2032 \u2208 RepEx\u00d7r(\u03a3,B) such that [[e\u2032]] = [[S]]. Since e\u2032 is a \u00d7-restricted representation, also \u03c4(e\u2032) is a \u00d7-restricted representation. Moreover, [[A]]run = \u03c7(\u03c4)([[S]]) = \u03c7(\u03c4)([[e\u2032]]) = [[\u03c4(e\u2032)]]. Thus we can choose e = \u03c4(e\u2032)."
        },
        {
            "heading": "13.3 From restricted representable to recognizable",
            "text": "Here we prove that each \u00d7-restricted representable weighted tree language is recognizable; moreover, if B is commutative, then each restricted representable weighted tree language is recognizable (cf. Lemma 13.3.2). As to be expected, the proof is by induction on the structure of representations.\nWe start with a lemma which shows the effect of the restriction of recognizable step mappings. One might compare the construction of this lemma with the one of [DV06, Lm. 5.5] (based in [DG07, Lm. 4.4]) in which the following is proved for a formula \u03d5 of weighted monadic second order logic: if [[\u03d5]] is a recognizable step mapping, then [[\u2200x.\u03d5]] is recognizable (cf. Lemma 14.4.16).\nLemma 13.3.1. (cf. [Her17, Lm. 10] and [Her20b, Lm. 5.2.5]) Let e \u2208 RepEx(\u03a3,B) such that there exists a crisp deterministic (\u03a3,B)-wta with [[A]] = [[e]]. We can construct a (\u03a3,B)-wta B such that [[B]]run = [[REST(e)]].\nProof. By Lemma 4.3.1, for each \u03be \u2208 T\u03a3, there exists q \u2208 Q such that Q RA(\u03be) 6=0 = {q} and there exists exactly one \u03c1 \u2208 RA(q, \u03be) such that wtA(\u03be, \u03c1) 6= 0 and for this \u03c1 we have wtA(\u03be, \u03c1) = 1. We denote this unique run by \u03c1\u03be. Thus,\nfor every \u03be \u2208 T\u03a3 and w \u2208 pos(\u03be), we have \u03b4rk(\u03be(w))(\u03c1\u03be(w1) \u00b7 \u00b7 \u00b7 \u03c1\u03be(w rk(\u03be(w))), \u03be(w), \u03c1\u03be (w)) = 1 and wtA(\u03be|w, (\u03c1\u03be)|w) = 1. (13.7)\nHence,\nfor every \u03be \u2208 T\u03a3 and w \u2208 pos(\u03be), we have [[A]](\u03be|w) = F\u03c1\u03be(w) . (13.8)\nWe construct the (\u03a3,B)-wta B such that [[B]]run = [[REST(e)]] using the following idea. On a given input tree \u03be, the wta B simulates the state behaviour of A and, at each position w of \u03be, the weight of the transition t which A applies at w, is the product of \u03b4k(t) \u2208 {0, 1} (where k = rk(\u03be(w))) and the root weight of the target state of t. Formally, we let B = (Q, \u03b4\u2032, F \u2032) with (F \u2032)q = 1 for each q \u2208 Q, and for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and q, q1, . . . , qk \u2208 Q we let\n(\u03b4\u2032)k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) \u2297 Fq .\n274 CHAPTER 13. ELEMENTARY OPERATIONS AND ME\u0301DVE\u0301DJE\u0301V\u2019S THEOREM\nWe recall that \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) \u2208 {0, 1}. Obviously, B is bu deterministic, but it is not crisp deterministic, and not even total (because B need not be zero-divisor free). Also, for each \u03be \u2208 T\u03a3, we have RA(\u03be) = RB(\u03be) and\nfor each \u03c1 \u2208 RB(\u03be): if \u03c1 6= \u03c1\u03be, then wtB(\u03be, \u03c1) = 0. (13.9)\nThen, for each \u03be \u2208 T\u03a3, we can calculate as follows:\n[[B]]run(\u03be) = \u2295\n\u03c1\u2208RB(\u03be)\nwtB(\u03be, \u03c1)\u2297 (F \u2032)\u03c1(\u03b5)\n= wtB(\u03be, \u03c1\u03be) (by (13.9)) = \u2297\nw\u2208pos(\u03be) in \u2264dp order\n(\u03b4\u2032)rk(\u03be(w))(\u03c1\u03be(w1) \u00b7 \u00b7 \u00b7 \u03c1\u03be(w rk(\u03be(w))), \u03be(w), \u03c1\u03be(w)) (by Observation 3.1.1)\n= \u2297\nw\u2208pos(\u03be) in \u2264dp order\n\u03b4rk(\u03be(w))(\u03c1\u03be(w1) \u00b7 \u00b7 \u00b7 \u03c1\u03be(w rk(\u03be(w))), \u03be(w), \u03c1\u03be(w)) \u2297 F\u03c1\u03be(w)\n= \u2297\nw\u2208pos(\u03be) in \u2264dp order\nF\u03c1\u03be(w) (by (13.7))\n= \u2297\nw\u2208pos(\u03be) in \u2264dp order\n[[A]](\u03be|w) (by (13.8))\n= \u2297\nw\u2208pos(\u03be) in \u2264dp order\n[[e]](\u03be|w) = [[REST(e)]](\u03be) .\nIn the next lemma, we will need distributivity, because the Hadamard product is one of the elementary operations, and distributivity is needed in order to guarantee closure of the set of recognizable weighted tree languages under Hadamard product.\nLemma 13.3.2. (cf. [Her17, Lm. 11] and [Her20b, Thm. 5.2.7]) Let B be a semiring and r : T\u03a3 \u2192 B. Then the following two statements hold.\n(1) For each e \u2208 RepEx\u00d7r(\u03a3,B), we can construct a (\u03a3,B)-wta A such that [[A]] = [[e]]. (2) Let B be commutative. For each e \u2208 RepExr(\u03a3,B), we can construct a (\u03a3,B)-wta A such that\n[[A]] = [[e]].\nProof. Proof of (1): We prove the statement by induction on the well-founded set (RepEx\u00d7r(B),\u227a\u2032) which is defined in an obvious way as restriction of (RepEx(B),\u227a).\nI.B.: Let e = RT\u03a3,\u03c3,b or e = NXT\u03a3,\u03b3\u0303,b. Then the statement follows from Corollary 13.1.3 and Theorem 10.3.1(B)\u21d2(A).\nI.S.: We distinguish four cases. Case (a): Let e = e1 + e2 for some e1, e2 \u2208 RepEx \u00d7r(\u03a3,B), and let A1 and A2 be (\u03a3,B)-wta such that [[e1]] = [[A1]] and [[e2]] = [[A2]]. Then by Theorem 10.1.1(1) we can construct a (\u03a3,B)-wta A such that [[A]] = [[A1]]\u2295 [[A2]] = [[e1]]\u2295 [[e2]] = [[e1 + e2]] = [[e]].\nCase (b): Let e = e1 \u00d7 e2 for some e1, e2 \u2208 RepEx \u00d7r(\u03a3,B). We distinguish three cases.\nCase (b1): Let A1 be a (\u03a3,B)-wta such that [[A1]] = [[e1]] and let e2 be generated by nonterminals of the form f r\u03a3 using the rules in (13.3).\nBy Corollary 13.1.3, we can construct n \u2208 N+, b1, . . . , bn \u2208 B, and \u03a3-fta A1, . . . , An such that [[e2]] = \u2295 i\u2208[n] bi \u2297 \u03c7(L(Ai)). By Theorem 10.3.1(B)\u21d2(A), we can construct a crisp deterministic (\u03a3,B)wta A2 such that [[A2]] = [[e2]]. Since B is right-distributive, by Theorem 10.4.3(1), we can construct a (\u03a3,B)-wta A such that [[A]] = [[A1]]\u2297 [[A2]]. Then [[A]] = [[A1]]\u2297 [[A2]] = [[e1]]\u2297 [[e2]] = [[e1 \u00d7 e2]] = [[e]].\n13.3. FROM RESTRICTED REPRESENTABLE TO RECOGNIZABLE 275\nCase (b2): Let e1 be generated by nonterminals of the form f r \u03a3 using the rules in (13.3) and let A2\nbe a (\u03a3,B)-wta such that [[A2]] = [[e2]].\nAs for e2 in Case (b1), we can construct a crisp deterministic (\u03a3,B)-wta A1 such that [[A1]] = [[e1]]. Then, by using Theorem 10.4.3(4) instead of Theorem 10.4.3(1), we can finish the proof in the same way as in Case (b1).\nCase (b3): Let e1 and e2 be generated by nonterminals of the form f r \u03a3 using the rules in (13.3). As indicated in the previous cases, we can construct crisp deterministic (\u03a3,B)-wta A1 and A2 such that [[e1]] = [[A1]] and [[e2]] = [[A2]]. By Theorem 10.4.1(3), we can construct a crisp deterministic (\u03a3,B)-wta A such that [[A]] = [[A1]]\u2297 [[A2]].\nCase (c): Let e = \u03c4(e\u2032) for some e\u2032 \u2208 RepEx\u00d7r(\u2206,B) and (\u2206,\u03a3)-tree relabeling. Moreover, let A\u2032 be a (\u2206,B)-wta such that [[A\u2032]] = [[e\u2032]]. Then by Theorem 10.10.1, we can construct a (\u03a3,B)-wta A such that [[A]] = \u03c7(\u03c4)([[A\u2032]]). Then [[A]] = \u03c7(\u03c4)([[A\u2032]]) = \u03c7(\u03c4)([[e\u2032]]) = [[\u03c4(e\u2032)]] = [[e]].\nCase (d): Let e = REST(e\u2032) for some e\u2032 \u2208 RepEx\u00d7r(\u03a3,B) which is generated by nonterminals of the form f r\u03a3 using the rules in (13.3). By Corollary 13.1.3 and Theorem 10.3.1(B) \u21d2 (A), we can construct a crisp deterministic (\u03a3,B)-wta A = (Q, \u03b4, F ) such that [[A]] = [[e]]. Then by Lemma 13.3.1, we can construct a (\u03a3,B)-wta B such that [[B]] = [[REST(e\u2032)]].\nProof of (2): The proof of this statement proceeds in the same way as the proof of (1) except that, in the case that e = e1 \u00d7 e2, we use Theorem 10.4.1(1) (which needs commutativity) instead of Theorems 10.4.3(1) and 10.4.1(3) for closure under Hadamard product.\n276 CHAPTER 13. ELEMENTARY OPERATIONS AND ME\u0301DVE\u0301DJE\u0301V\u2019S THEOREM\nChapter 14\nWeighted MSO-logic and Bu\u0308chi-Elgot-Trakhtenbrot\u2019s theorem\nThe Bu\u0308chi-Elgot-Trakhtenbrot\u2019s theorem (B-E-T\u2019s theorem1) [Bu\u0308c60, Elg61, Tra61], cf. also [Str94], states that regular string languages and string languages definable in monadic second-order logic coincide. In this chapter we prove the corresponding B-E-T\u2019s theorem for the set Rec(\u03a3,B) of recognizable (\u03a3,B)weighted tree languages for an arbitrary strong bimonoid B (cf. Theorem 14.3.1). The theorem states that, for every (\u03a3,B)-weighted tree language r the following equivalence holds: r is r-recognizable if and only if r is definable by a sentence of MSO(\u03a3,B)-logic.\nThe first approach for a weighted version of B-E-T\u2019s theorem appeared in [DG05, DG07, DG09] where they generalized from the unweighted version (i.e., B-weighted string languages) to the weighted version (i.e., B-weighted string languages where B is an arbitrary semiring). Then the interpretation of a formula \u03d5 on a string w does not deliver the Boolean-valued answer to the question whether w is a model of \u03d5, but it delivers an arbitrary element in B as truth value. A first problem in the design of the weighted logic was to give a semantics to the negation of a formula, because in a semiring (or strong bimonoid) it is not clear whether a value has a kind of complement. The solution published in [DG05, DG07, DG09] can be understood as follows: start from the usual MSO-logic with atomic formulas (i.e., tests Pa(x) on labels, next relation x \u2264 y, and membership x \u2208 X), negation, disjunction, first-order existential quantification, and second-order existential quantification; turn each formula into a semantically equivalent formula in which the negations are applied to atomic formulas only; this can be achieved by introducing conjunction, first-order universal quantification, and second-order universal quantification as part of the logic and by replacing\n\u2022 \u00ac(\u03d5 \u2228 \u03c8) by \u00ac\u03d5 \u2227 \u00ac\u03c8, \u2022 \u00ac\u2203x.\u03d5 by \u2200x.\u00ac\u03d5, and \u2022 \u00ac\u2203X.\u03d5 by \u2200X.\u00ac\u03d5.\nAs a part of the solution, the truth value of each atomic formula can only be 0 or 1 (i.e., the unit elements of B); thus, its truth value can be complemented. Moreover, each b \u2208 B is added as new atomic formula, and this has the semantics b. Disjunction and existential quantification are semantically expressed by the summation of the semiring B, and conjunction and universal quantification are expressed by the multiplication of B. Overall, the following EBNF shows the syntax of the weighted MSO-logic (where now \u03d5 is a nonterminal and not a formula):\n\u03d5 ::= b | Pa(x) | x \u2264 y | x \u2208 X | \u00acPa(x) | \u00ac(x \u2264 y) | \u00ac(x \u2208 X) |\n\u03d5 \u2228 \u03d5 | \u03d5 \u2227 \u03d5 | \u2203x.\u03d5 | \u2200x.\u03d5 | \u2203X.\u03d5 | \u2200X.\u03d5 . (14.1)\n1where \u201c\u2019s\u201d distributes over \u201c-\u201d\n277\n278 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nIn fact, the first-order fragment of (14.1) is a subset of the fuzzy predicate calculus [Wec78, Sec. 1.2.2]. Since Wechler uses fuzzy algebras [Wec78, Def. 1.2] as weight algebras, atomic formulas can have any truth value (not only 0 and 1) and the negation can be applied to any formula. The interpretation of the propositional connectives and quantifiers as it is defined in [DG05, DG07, DG09] is essentially the same as in the fuzzy predicate calculus [Wec78, Def. 1.8 and 1.10].\nIt turned out that the weighted MSO-logic generated by (14.1) is too strong for B-E-T\u2019s theorem. Hence, in [DG05, DG07, DG09] restrictions are defined which, roughly speaking, amount to (a) having a kind of commutativity of the semiring multiplication (for exchanging values which appear in conjunctions), (b) restricting the application of first-order universal quantification to formulas of which the semantics is a recognizable step mapping, and (c) dropping second-order universal quantification. Indeed, this restricted weighted MSO-logic characterizes recognizable weighted string languages [DG09, Thm. 4.7]. In the proof (at least) two technical difficulties were mastered.\n(A) The proof of \u201crecognizable implies definable\u201d follows the well-known idea of expressing runs of an automaton by formulas. Since the resulting formulas just check structural properties, i.e., have semantic value 0 or 1, it was important to disambiguate subformulas which involve disjunction or existential quantification, because the underlying semiring is not necessarily additively idempotent.\n(B) Since conjunction and first-order universal quantification are part of the weighted logic, preservation of recognizability under these constructs had to be proven. The main problem showed up with first-order universal quantification, because there exists a non recognizable weighted language which is definable by a formula of the form \u2200x.\u03d5 in that weighted logic [DG05, Ex. 3.4]. Thus, appropriate restrictions on the form of the body formula \u03d5 had to be found (cf. restriction (b) above), and then a new automaton construction had to be invented. This problem did not arise in classical unweighted MSO logic, because in classical logic universal quantification can be expressed using existential quantification and negations.\nThis approach to weighted MSO-logic has been generalized to a number of structures (different from strings) and weight algebras (different from semirings), e.g. for Mazurkiewicz traces and semirings [Mei06], ranked and unranked trees and semirings [DV06, DV11b], finite and infinite strings with discounting and semirings [DR07], nested words and semirings [Mat08, Mat10], timed words and semirings [Qua09], pictures and semirings [Fic11], strings and infinite strings and valuation monoids [DM12], ranked und unranked trees and tree-valuation monoids [DGMM11, DHV15]. In [BGMZ14] (see also [BGMZ10]) an approach different to [DG09] was taken: there, not the logic was restricted but the automaton model was extended. Indeed, the set of weighted string languages recognizable by pebble two-way weighted automata is equal to the set of weighted string languages definable by, roughly speaking, a first-order fragment of the unrestricted weighted MSO-logic of [DG09] enriched by a transitive closure operator. In [FV15] semiring-weighted tree automata were characterized by a weighted transitive closure logic. For a survey we refer to [GM18]. The disambiguation reported in (A) above is cumbersome. This has been overcome in [BGMZ10, FSV12, BGMZ14] by allowing explicitly (Boolean-valued) MSO-formulas as guards of weighted formulas. Finally, we mention that, in [Li08b], B-E-T\u2019s theorem has been proved for mv-algebra.\nIn this chapter we follow the approach of [FSV12] in which B-E-T\u2019s theorem was proved for recognizable weighted tree languages over absorptive multioperator monoids [FSV12, Thm. 4.1]. In particular, each strong bimonoid (and hence, each semiring) is an absorptive multioperator monoid. In the MSOlogic proposed in that paper, formulas of classical MSO-logic on trees can be used to guard weighted formulas. Moreover, a universal quantification over some recognizable step mapping (as it appears in the restricted MSO-logic of [DG05]) is represented by a guarded atomic formula where the guard simulates the step languages and the atomic formula is interpreted as a unique algebra homomorphism (cf. Lemma 14.4.12). For semirings, each formula of the restricted weighted MSO-logic of [DV06] (which is a straightforward generalization of [DG09]) can be transformed syntactically into an equivalent formula of the logic in [FSV12] (cf. [FSV12, Lm. 5.10]), and vice versa (cf. [FSV12, Lm. 5.12]). We note that the approach of [FSV12] has been generalized in [FHV18] to weighted tree grammars with storage over complete M-monoids, and B-E-T\u2019s theorem was proved in [FHV18, Thm. 7.4] (for the string case cf.\n14.1. MONADIC SECOND-ORDER LOGIC 279\n[VDH16, Thm. 8]).\nThe goal of this chapter is to report on B-E-T\u2019s theorem [FSV12, Thm. 4.1] for the particular case of strong bimonoids (cf. Theorem 14.3.1). Moreover, we prove that extending the logic by weighted conjunction and weighted first-order universal quantification on recognizable step formulas does not increase its expressive power if the underlying weight algebra is a commutative semiring (cf. Theorem 14.4.11). Finally, in Section 14.5 we show a strong relationship between a decomposition result of wta (proved in Chapter 11) and the fact that, for weighted tree languages, r-recognizable implies definable (cf. Theorems 14.5.2 and 14.5.4)."
        },
        {
            "heading": "14.1 Monadic second-order logic",
            "text": "We recall the monadic second-order logic on trees (cf. [TW68, Don70, GS97]) and make several formal definitions, constructions, and proofs explicit.\nAs first-order variables we use small letters from the end of the Latin alphabet, e.g., x, x1, x2, . . . , y, z, and as second-order variables we use capital letters, like X,X1, X2, . . . , Y, Z. The set of monadic secondorder formulas over \u03a3, denoted by MSO(\u03a3), is the set of all expressions generated by the following EBNF with nonterminal \u03d5:\n\u03d5 ::= label\u03c3(x) | edgei(x, y) | x \u2208 X | \u00ac\u03d5 | (\u03d5 \u2228 \u03d5) | \u2203x.\u03d5 | \u2203X.\u03d5 , (14.2)\nwhere \u03c3 \u2208 \u03a3 and i \u2208 [maxrk(\u03a3)].\nIn order to perform inductive proofs or to define objects for MSO(\u03a3) by induction, we will consider the well-founded set\n(MSO(\u03a3),\u227aMSO(\u03a3))\nwhere \u227aMSO(\u03a3) is the binary relation on MSO(\u03a3) defined as follows. For every \u03d51, \u03d52 \u2208 MSO(\u03a3), we let \u03d51 \u227aMSO(\u03a3) \u03d52 if \u03d51 is a direct subformula of \u03d52 in the sense of (14.2). Then \u227aMSO(\u03a3) is well-founded and min\u227aMSO(\u03a3)(MSO(\u03a3)) is the set of formulas of the form label\u03c3(x), edgei(x, y), and x \u2208 X .\nNext we prepare the definition of the semantics of MSO(\u03a3)-formulas. Let V be a finite set of variables; we abbreviate by V(1) and V(2) the set of first-order variables in V and the set of second-order variables in V , respectively. Let \u03be \u2208 T\u03a3. A V-assignment for \u03be is a mapping \u03b7 with domain V which maps each first-order variable in V to a position of \u03be and each second-order variable to a subset of pos(\u03be). By \u03a6V,\u03be we denote the set of all V-assignments for \u03be. Let \u03b7 \u2208 \u03a6V,\u03be, x be a first-order variable, and w \u2208 pos(\u03be). By \u03b7[x 7\u2192 w] we denote the (V \u222a {x})-assignment for \u03be that agrees with \u03b7 on V \\ {x} and that satisfies \u03b7[x 7\u2192 w](x) = w. Similarly, if X is a second-order variable and W \u2286 pos(\u03be), then \u03b7[X 7\u2192 W ] denotes the (V \u222a {X})-assignment for \u03be that agrees with \u03b7 on V \\ {X} and that satisfies \u03b7[X 7\u2192W ](X) =W .\nSince a \u03a3-fta recognizes \u03a3-trees and not pairs (\u03be, \u03b7) \u2208 T\u03a3 \u00d7 \u03a6V,\u03be, we code a V-assignment for \u03be into the labels of \u03be in the usual way. Formally, we define the ranked alphabet \u03a3V by letting\n(\u03a3V) (k) = \u03a3(k) \u00d7 P(V) for each k \u2208 N .\nInstead of (\u03a3V) (k) we will write \u03a3 (k) V . We identify the sets \u03a3 and \u03a3\u2205. A tree \u03b6 \u2208 T\u03a3V is called valid if for each x \u2208 V(1) there exists a unique w \u2208 pos(\u03b6) such that x is contained in the second component of \u03b6(w). We denote by Tv\u03a3V the set of all valid trees in T\u03a3V .\nThe two sets {(\u03be, \u03b7) | \u03be \u2208 T\u03a3, \u03b7 \u2208 \u03a6V,\u03be} and Tv\u03a3V are in a one-to-one correspondence via (\u03be, \u03b7) 7\u2192 \u03b6, where pos(\u03b6) = pos(\u03be) and\n\u03b6(w) = ( \u03be(w), {x \u2208 V(1) | w = \u03b7(x)} \u222a {X \u2208 V(2) | w \u2208 \u03b7(X)} ) .\nIn the sequel, we will not distinguish between the sets {(\u03be, \u03b7) | \u03be \u2208 T\u03a3, \u03b7 \u2208 \u03a6V,\u03be} and Tv\u03a3V . In particular, sometimes we call pairs (\u03be, \u03b7) in the first set also trees.\n280 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nLet (\u03be, \u03b7) \u2208 Tv\u03a3V , x be a first-order variable, and w \u2208 pos(\u03be). By (\u03be, \u03b7)[x 7\u2192 w] we denote the valid tree (\u03be, \u03b7[x 7\u2192 w]) over \u03a3V\u222a{x}. Similarly, if X is a second-order variable andW \u2286 pos(\u03b6), then (\u03be, \u03b7)[X 7\u2192W ] denotes the valid tree (\u03be, \u03b7[X 7\u2192 W ]) over \u03a3V\u222a{X}. Moreover, let U \u2286 V . Then \u03b7|U is a U-assignment and we denote the tree (\u03be, \u03b7|U ) also by (\u03be, \u03b7)|U .\nFor the definition of the semantics of MSO(\u03a3)-formulas, we need the notion of free variable; for later purpose, we also define the notion of bound variables. Formally, for each \u03d5 \u2208 MSO(\u03a3), we define the set Free(\u03d5) of free variables of \u03d5 and the set Bound(\u03d5) of bound variables of \u03d5 by induction on (MSO(\u03a3),\u227aMSO(\u03a3)) as follows:\n\u2022 Free(label\u03c3(x)) = {x} and Bound(label\u03c3(x)) = \u2205, \u2022 Free(edgei(x, y)) = {x, y} and Bound(edgei(x, y)) = \u2205, \u2022 Free(x \u2208 X) = {x,X} and Bound(x \u2208 X) = \u2205, \u2022 Free(\u00ac\u03d5) = Free(\u03d5) and Bound(\u00ac\u03d5) = Bound(\u03d5), \u2022 Free(\u03d51 \u2228 \u03d52) = Free(\u03d51) \u222a Free(\u03d52) and Bound(\u03d51 \u2228 \u03d52) = Bound(\u03d51) \u222a Bound(\u03d52), and \u2022 Free(\u2203x.\u03d5) = Free(\u03d5) \\ {x} and Free(\u2203X.\u03d5) = Free(\u03d5) \\ {X} and Bound(\u2203x.\u03d5) = Bound(\u03d5) \u222a {x} and Bound(\u2203X.\u03d5) = Bound(\u03d5) \u222a {X}.\nIf a formula \u03d5 has the free variables, say, x, y, and X and no others, then we also write \u03d5(x, y,X). As usual, we abbreviate formulas like \u2203x.\u2203y.\u2203z.\u03d5 by \u2203x, y, z.\u03d5. A formula \u03d5 \u2208 MSO(\u03a3) is called MSO(\u03a3)sentence (or just: sentence) if Free(\u03d5) = \u2205.\nLet \u03d5 \u2208 MSO(\u03a3) and V be a finite set such that Free(\u03d5) \u2286 V . For every \u03be \u2208 T\u03a3 and \u03b7 \u2208 \u03a6V,\u03be, the relation \u201c(\u03be, \u03b7) satisfies \u03d5\u201d, denoted by (\u03be, \u03b7) |= \u03d5, is defined by induction on (MSO(\u03a3),\u227aMSO(\u03a3)) as follows.\n(\u03be, \u03b7) |= label\u03c3(x) iff \u03c3 = \u03be(\u03b7(x)) (\u03be, \u03b7) |= edgei(x, y) iff \u03b7(y) = \u03b7(x).i (\u03be, \u03b7) |= (x \u2208 X) iff \u03b7(x) \u2208 \u03b7(X) (\u03be, \u03b7) |= (\u03d51 \u2228 \u03d52) iff (\u03be, \u03b7) |= \u03d51 or (\u03be, \u03b7) |= \u03d52 (\u03be, \u03b7) |= (\u00ac\u03d5) iff (\u03be, \u03b7) |= \u03d5 is not true (\u03be, \u03b7) |= (\u2203x.\u03d5) iff there exists a w \u2208 pos(\u03be) such that (\u03be, \u03b7)[x\u2192 w] |= \u03d5 (\u03be, \u03b7) |= (\u2203X.\u03d5) iff there exists a set W \u2286 pos(\u03be) such that (\u03be, \u03b7)[X \u2192W ] |= \u03d5.\nWe denote by LV(\u03d5) the set {(\u03be, \u03b7) \u2208 Tv\u03a3V | (\u03be, \u03b7) |= \u03d5}, and we will simply write L(\u03d5) instead of LFree(\u03d5)(\u03d5). A tree language L \u2286 T\u03a3 is called MSO definable if there exists a sentence \u03d5 \u2208 MSO(\u03a3) such that L = L(\u03d5).\nFor every formula \u03d5, finite set V of variables with Free(\u03d5) \u2286 V , and tree \u03b6, the membership \u03b6 \u2208 LV(\u03d5) is independent from the values assigned to variables outside of Free(\u03d5). This is formally expressed in the following consistency lemma.\nLemma 14.1.1. Let \u03d5 \u2208 MSO(\u03a3) and V be a finite set of variables containing Free(\u03d5). Then for every (\u03be, \u03b7) \u2208 Tv\u03a3V , the following equivalence holds: (\u03be, \u03b7) \u2208 LV(\u03d5) iff (\u03be, \u03b7|Free(\u03d5)) \u2208 L(\u03d5).\nProof. We prove the statement by induction on (MSO(\u03a3),\u227aMSO(\u03a3)). Let (\u03be, \u03b7) \u2208 T v \u03a3V .\nI.B.: For the induction base we distinguish three cases.\nCase (a): Let \u03d5 = label\u03c3(x). Then Free(\u03d5) = {x} and we have\n(\u03be, \u03b7) |= \u03d5 iff \u03c3 = \u03be(\u03b7(x)) iff \u03c3 = \u03be(\u03b7|{x}(x)) iff (\u03be, \u03b7|{x}) |= \u03d5 iff (\u03be, \u03b7|Free(\u03d5)) |= \u03d5 .\nCase (b): Let \u03d5 = edgei(x, y). Then Free(\u03d5) = {x, y} and we have\n(\u03be, \u03b7) |= \u03d5 iff \u03b7(y) = \u03b7(x).i iff \u03b7|{x,y}(y) = \u03b7|{x,y}(x).i iff (\u03be, \u03b7|{x,y}) |= \u03d5 iff (\u03be, \u03b7|Free(\u03d5)) |= \u03d5 .\nCase (c): Let \u03d5 = (x \u2208 X). Then Free(\u03d5) = {x,X} and the proof of this case is very similar to the proof of Case (b).\nI.S.: For the induction step we distinguish four cases.\n14.1. MONADIC SECOND-ORDER LOGIC 281\nCase (a): Let \u03d5 = \u03d51 \u2228 \u03d52. Then Then Free(\u03d5) = Free(\u03d51) \u222a Free(\u03d52) and we have\n(\u03be, \u03b7) |= \u03d5 iff (\u03be, \u03b7) |= \u03d51 or (\u03be, \u03b7) |= \u03d52\niff (\u03be, \u03b7|Free(\u03d51)) |= \u03d51 or (\u03be, \u03b7|Free(\u03d52)) |= \u03d52 (by I.H.) iff (\u03be, \u03b7|Free(\u03d5)) |= \u03d51 or (\u03be, \u03b7|Free(\u03d5)) |= \u03d52 (by I.H.)\niff (\u03be, \u03b7|Free(\u03d5)) |= \u03d5 .\nCase (b): Let \u03d5 = \u00ac\u03d5\u2032. This is similar to Case (a).\nCase (c): Let \u03d5 = (\u2203x.\u03d5\u2032). Then Free(\u03d5) = Free(\u03d5\u2032) \\ {x} and we have\n(\u03be, \u03b7) |= \u03d5 iff (\u2203w \u2208 pos(\u03be)) : (\u03be, \u03b7[x\u2192 w]) |= \u03d5\u2032\niff (\u2203w \u2208 pos(\u03be)) : (\u03be, (\u03b7[x\u2192 w])|Free(\u03d5\u2032)) |= \u03d5 \u2032 (by I.H.) iff (\u2203w \u2208 pos(\u03be)) : (\u03be, ((\u03b7|Free(\u03d5\u2032))[x\u2192 w])|Free(\u03d5\u2032)) |= \u03d5 \u2032\n(because (\u03b7[x\u2192 w])|Free(\u03d5\u2032) = ( (\u03b7|Free(\u03d5\u2032))[x\u2192 w] ) |Free(\u03d5\u2032))\niff (\u2203w \u2208 pos(\u03be)) : (\u03be, (\u03b7|Free(\u03d5\u2032))[x\u2192 w]) |= \u03d5 \u2032 (by I.H.) iff (\u2203w \u2208 pos(\u03be)) : (\u03be, (\u03b7|Free(\u03d5))[x\u2192 w]) |= \u03d5 \u2032 (by (*))\niff (\u03be, \u03b7|Free(\u03d5)) |= \u03d5 .\nwhere at (*) we have used that either (i) x 6\u2208 Free(\u03d5\u2032) and thus Free(\u03d5\u2032) = Free(\u03d5) or (ii) x \u2208 Free(\u03d5\u2032) and thus Free(\u03d5\u2032) = Free(\u03d5) \u222a {x}. In both cases we have (\u03b7|Free(\u03d5\u2032))[x\u2192 w] = (\u03b7|Free(\u03d5))[x\u2192 w].\nCase (d): Let \u03d5 = (\u2203X.\u03d5\u2032). This case is similar to Case (c).\nWe will use the following macros:\n\u03d5 \u2227 \u03c8 := \u00ac(\u00ac\u03d5 \u2228 \u00ac\u03c8)\n\u03d5\u2192 \u03c8 := \u00ac\u03d5 \u2228 \u03c8\n\u03d5\u2194 \u03c8 := (\u03d5\u2192 \u03c8) \u2227 (\u03c8 \u2192 \u03d5)\n\u2200x.\u03d5 := \u00ac(\u2203x.\u00ac\u03d5)\n\u2200X.\u03d5 := \u00ac(\u2203X.\u00ac\u03d5) \u2228\ni\u2208I\n\u03d5i := \u03d5i1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03d5in and\n\u2227\ni\u2208I\n\u03d5i := \u03d5i1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03d5in for each finite family (\u03d5i | i \u2208 I) with I = {i1, . . . , in}\nlabel\u2206(x) := \u2228\n\u03c3\u2208\u2206\nlabel\u03c3(x) for each \u2206 \u2286 \u03a3\nedge(x, y) := \u2228\ni\u2208[maxrk(\u03a3)]\nedgei(x, y)\n(x = y) := \u2200X.(x \u2208 X)\u2194 (y \u2208 X)\nroot(x) := \u00ac\u2203y.edge(y, x)\nSince disjunction and conjunction are associative, the placement of parentheses in the expressions \u03d5i1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03d5in and \u03d5i1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03d5in is irrelevant and hence not shown.\nExample 14.1.2. (cf. e.g. [CE12, Sec. 1.3.1]) We consider the following formulas in MSO(\u03a3):\nclosed(X) = \u2200z1.\u2200z2.(edge(z1, z2) \u2227 (z1 \u2208 X))\u2192 (z2 \u2208 X)\npath(x, y) = \u2200X.(closed(X) \u2227 (x \u2208 X))\u2192 (y \u2208 X) .\n282 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nWe claim that\nL{x,y}(path(x, y)) = {(\u03be, {(x, u), (y, v)}) \u2208 T v \u03a3{x,y} | u, v \u2208 pos(\u03be) such that u \u2208 prefix(v)} . (14.3)\n(a) First we prove the inclusion from left to right. Let \u03be \u2208 T\u03a3, u, v \u2208 pos(\u03be), and \u03b7 = {(x, u), (y, v)} such that (\u03be, \u03b7) \u2208 L{x,y}(path(x, y)). Then (\u03be, \u03b7) \u2208 T\nv \u03a3{x,y} and (\u03be, \u03b7) |= path(x, y).\nMoreover, we have:\nfor each set U \u2286 pos(\u03be): if (\u03be, \u03b7 \u222a {(X,U)}) |= closed(X) and u \u2208 U , then v \u2208 U . (14.4)\nMoreover, we have (\u03be, \u03b7 \u222a {(X, pos(\u03be|u)}) |= closed(X) and u \u2208 pos(\u03be|u). Hence, by (14.4) with U = pos(\u03be|u), we have that v \u2208 pos(\u03be|u). Thus u \u2208 prefix(v).\n(b) Next we prove the inclusion from right to left. For this, let \u03be \u2208 T\u03a3, u, v \u2208 pos(\u03be), and \u03b7 = {(x, u), (y, v)} such that (\u03be, \u03b7) \u2208 Tv\u03a3{x,y} and u \u2208 prefix(v). Thus there exist n \u2208 N, j1, . . . , jn \u2208 N+ such that v = uj1 \u00b7 \u00b7 \u00b7 jn. Now let U \u2286 pos(\u03be) such that (\u03be, {(X,U)}) |= closed(X) and u \u2208 U .\nFirst, by induction on ([0, n], <), we prove that the following statement holds:\nFor each \u2113 \u2208 [0, n], we have uj1 \u00b7 \u00b7 \u00b7 j\u2113 \u2208 U . (14.5)\nI.B.: Let \u2113 = 0. The statement trivially holds, because u \u2208 U .\nI.S.: Let \u2113 = \u2113\u2032 + 1 for some \u2113\u2032 \u2208 N. We assume that (14.5) holds for \u2113\u2032 \u2208 [0, n\u2212 1]. By I.H., we have uj1 \u00b7 \u00b7 \u00b7 j\u2113\u2032 \u2208 U . Since (\u03be, {(X,U)}) |= closed(X) and\n(\u03be, {(X,U), (z1, uj1 \u00b7 \u00b7 \u00b7 j\u2113\u2032), (z2, uj1 \u00b7 \u00b7 \u00b7 j\u2113\u2032j\u2113)}) |= (edge(z1, z2) \u2227 z1 \u2208 X) ,\nwe have that (\u03be, {(X,U), (z1, uj1 \u00b7 \u00b7 \u00b7 j\u2113\u2032), (z2, uj1 \u00b7 \u00b7 \u00b7 j\u2113\u2032j\u2113)}) |= (z2 \u2208 X)\nand hence uj1 \u00b7 \u00b7 \u00b7 j\u2113\u2032j\u2113 \u2208 U . This proves (14.5).\nThen (14.5) implies (by choosing \u2113 = n) that uj1 \u00b7 \u00b7 \u00b7 jn \u2208 U , and hence v \u2208 U . Thus (\u03be, \u03b7) |= path(x, y) and hence (\u03be, \u03b7) \u2208 L{x,y}(path(x, y)). This finishes the proof of (14.3).\nFinally, we recall B-E-T\u2019s theorem for recognizable tree languages. It follows from Lemmas 14.1.4 and 14.1.9.\nTheorem 14.1.3. [TW68, Don70]: Let L \u2286 T\u03a3. Then the following two statements are equivalent. (A) We can construct an fta A over \u03a3 such that L(A) = L. (B) We can construct a sentence \u03d5 \u2208 MSO(\u03a3) such that L(\u03d5) = L.\nLemma 14.1.4. For each \u03a3-fta A, we can construct a sentence \u03d5 \u2208MSO(\u03a3) such that L(A) = L(\u03d5).\nProof. Let A = (Q, \u03b4, F ) be a \u03a3-fta. Without loss of generality we can assume that there exists an n \u2208 N such that Q = [n]. We let U = {X1, . . . , Xn}.\nNow we construct a sentence \u03d5 \u2208MSO(\u03a3) such that L(\u03d5) = L(A). The following relationship will be the key for this construction. Let \u03be \u2208 T\u03a3. We can relate\n(a) mappings from pos(\u03be) into Q (i.e., runs of A on \u03be) and (b) Q-indexed partitionings over P(pos(\u03be))\nin the following way. Let \u03c1 : pos(\u03be)\u2192 Q and P = (Pq | q \u2208 Q) be a Q-indexed partitioning over P(pos(\u03be)). Then \u03c1 and P are related iff Pq = \u03c1\n\u22121(q) for every q \u2208 Q. Obviously, this relationship is a one-to-one correspondence.\nWe define the sentence \u03d5 \u2208MSO(\u03a3) by\n\u03d5 = \u2203X1 . . . \u2203Xn. \u03d5part \u2227 \u03d5valid \u2227 \u03d5final\nwhere\n14.1. MONADIC SECOND-ORDER LOGIC 283\n\u2022 \u03d5part = \u2200x. \u2228 q\u2208Q ( (x \u2208 Xq) \u2227 \u2227 p\u2208Q: p6=q \u00ac(x \u2208 Xp) ) ,\n\u2022 \u03d5valid = \u03d5valid, 6=0 \u2227 \u03d5valid,=0 with\n\u03d5valid, 6=0 = \u2200x. \u2227\nk\u2208N+,\u03c3\u2208\u03a3 (k)\nlabel\u03c3(x)\u2192\n\u2200y1, . . . , yk. ( edge1(x, y1) \u2227 . . . \u2227 edgek(x, yk)\u2192\n\u2228 q,q1,...,qk\u2208Q:\n(q1...qk,\u03c3,q)\u2208\u03b4k\n( (y1 \u2208 Xq1)\u2227 . . .\u2227 (yk \u2208 Xqk)\u2227 (x \u2208 Xq) )) and\n\u03d5valid,=0 = \u2200x. \u2227\n\u03b1\u2208\u03a3(0) label\u03b1(x)\u2192 ( \u2228 q\u2208Q:\n(\u03b5,\u03b1,q)\u2208\u03b40\n(x \u2208 Xq) ) , and\n\u2022 \u03d5final = \u2200x. ( root(x)\u2192 \u2228 q\u2208F (x \u2208 Xq) ) .\nFor every \u03be \u2208 T\u03a3 and \u03b7 \u2208 \u03a6U ,\u03be, the following statement is obvious.\n(\u03be, \u03b7) |= \u03d5part \u2227 \u03d5valid \u2227 \u03d5final iff the Q-indexed family \u03a8 = (\u03b7(Xq) | q \u2208 Q) is a partitioning of pos(\u03be)\nand the run related to \u03a8 is accepting .\nFinally, we can calculate as follows:\n\u03be \u2208 L(\u03d5) iff there exists a \u03b7 \u2208 \u03a6U ,\u03be such that\nthe Q-indexed family \u03a8 = (\u03b7(Xq) | q \u2208 Q) is a partitioning of pos(\u03be)\nand the run related to \u03a8 is accepting\niff RaA(\u03be) 6= \u2205\niff \u03be \u2208 L(A) .\nNext we will prove that definable implies recognizable. For this we need a few preparations. First, we observe that, for each finite set V of variables, the set Tv\u03a3V is a recognizable \u03a3V -tree language.\nLemma 14.1.5. Let \u03a3 be a ranked alphabet and V be a finite set of first-order variables. Then we can construct a total and bu deterministic \u03a3V-fta A such that L(A) = T\nv \u03a3V .\nProof. Let V = {x1, . . . , xm}. Obviously, Tv\u03a3V = \u22c2 j\u2208[m] Lj where\nLj = {\u03be \u2208 T\u03a3V | xj occurs exactly once in \u03be} .\nFirst, for each j \u2208 [m], we construct a total and bu deterministic \u03a3V -fta Bj = (Q, \u03b4, F ) such that Lj = L(Bj). The idea for this is to count the number of occurrences of xj up to 2 while traversing the tree from the leaves towards the root. If xj is encountered twice, then the tree automaton reaches a non-final state which is propagated towards the root.\nFormally, we let Q = {0, 1, 2} and F = {1}. For every k \u2208 N, (\u03c3, U) \u2208 \u03a3 (k) V , and q1, . . . , qk \u2208 Q we let\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3, U)) =    2 if ( +i\u2208[k] qi \u2265 2 ) \u2228 ( (+i\u2208[k] qi = 1) \u2227 (xj \u2208 U) ) 1 if ( (+i\u2208[k] qi = 1) \u2227 (xj 6\u2208 U) ) \u2228 ( (+i\u2208[k] qi = 0) \u2227 (xj \u2208 U) )\n0 otherwise ,\n284 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nwhere + denotes the extension of + to finite sums in the monoid (N,+, 0). It is clear that L(A) = Lj . Then, by Theorems 2.13.2 and 2.13.3, we can construct a total and bu deterministic \u03a3V -fta A such\nthat L(A) = \u22c2 j\u2208[m] L(Bj). Then\nL(A) = \u22c2\nj\u2208[m]\nL(Bj) = \u22c2\nj\u2208[m]\nLj = T v \u03a3V .\nAs second preparation we prove that two particular tree languages are recognizable.\nLemma 14.1.6. Let \u2206 be a ranked alphabet, \u0393 \u2286 \u2206, and L\u0393 = {\u03be \u2208 T\u2206 | (\u2203w \u2208 pos(\u03be)) : \u03be(w) \u2208 \u0393}. Then we can construct a total and bu deterministic \u2206-fta A such that L(A) = L\u0393.\nProof. We construct the \u2206-fta A = (Q, \u03b4, F ) with Q = {0, 1} (and each state is viewed as natural number), F = {1}, and for every k \u2265 0, \u03c3 \u2208 \u2206(k), q1, . . . , qk \u2208 Q we define\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3) =\n{ 1 if ( + i\u2208[k] qi \u2265 1 ) \u2228 (\u03c3 \u2208 \u0393)\n0 otherwise .\nIt is obvious that A is total and deterministic, and that L(A) = L\u0393.\nLemma 14.1.7. Let \u2206 be a ranked alphabet, \u03931,\u03932 \u2286 \u2206, j \u2208 N with j \u2265 1, and L\u03931,\u03932,j = {\u03be \u2208 T\u2206 | (\u2203w1, w2 \u2208 pos(\u03be)) : w2 = w1j, \u03be(w1) \u2208 \u03931, \u03be(w2) \u2208 \u03932}. Then we can construct a \u2206-fta A such that L(A) = L\u03931,\u03932,j .\nProof. We construct the \u2206-fta A = (Q, \u03b4, F ) with Q = {0, 1, 2}, F = {2}, and for every k \u2265 0, we define \u03b4k to be the smallest set \u03b4 \u2032 k such that (q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) \u2208 \u03b4 \u2032 k iff (at least) one of the following four conditions is satisfied:\n\u2022 q = 0, \u2022 \u03c3 \u2208 \u03932 and q = 1, \u2022 j \u2264 k, qj = 1, \u03c3 \u2208 \u03931, and q = 2, or \u2022 (\u2203l \u2208 [k]) : ql = 2 and q = 2.\nIt is obvious that L(A) = L\u03931,\u03932,j.\nWe will prove that definable implies recognizable. As preparation, we prove a consistency lemma for fta.\nLemma 14.1.8. Let \u03d5 \u2208 MSO(\u03a3) with Free(\u03d5) = V , and A be a \u03a3V -fta such that L(A) = L(\u03d5). Moreover, let V be a first-order variable or a second-order variable. Then we can construct a \u03a3V\u222a{V }-fta A\u2032 such that L(A\u2032) = LV\u222a{V }(\u03d5).\nProof. Case (a): Let V \u2208 V . Then we can choose A\u2032 = A and we are ready.\nCase (b): Let V 6\u2208 V . Moreover, let A = (Q, \u03b4, F ). First we construct the \u03a3V\u222a{V }-fta B = (Q, \u03b4 \u2032, F )\nsuch that, for every k \u2208 N, (\u03c3,W) \u2208 (\u03a3V\u222a{V }) (k), and q1, . . . , qk, q \u2208 Q we define\n\u03b4\u2032k(q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3,W), q) = \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3,W \\ {V }), q) .\nObviously, for each \u03be \u2208 T\u03a3V\u222a{V } , we have pos(\u03be) = pos(\u03be|V) and R a B(\u03be) = R a A(\u03be|V ). Hence, we have\n\u03be \u2208 L(B) iff RaB(\u03be) 6= \u2205 iff R a A(\u03be|V ) 6= \u2205 iff \u03be|V \u2208 L(A) . (14.6)\nNext we show that L(B) \u2229 Tv\u03a3V\u222a{V } = LV\u222a{V }(\u03d5) . (14.7)\n14.1. MONADIC SECOND-ORDER LOGIC 285\nFor this, let \u03be \u2208 T\u03a3V\u222a{V } . Then we have\n\u03be \u2208 L(B) \u2229 Tv\u03a3V\u222a{V } iff (\u03be|V \u2208 L(A)) \u2227 (\u03be \u2208 T v \u03a3V\u222a{V } ) (by (14.6))\niff (\u03be|V \u2208 L(\u03d5)) \u2227 (\u03be \u2208 T v \u03a3V\u222a{V } )\niff \u03be \u2208 LV\u222a{V }(\u03d5) (by Lemma 14.1.1)\nNow, by Lemma 14.1.5, we can construct a \u03a3V\u222a{V }-fta C such that L(C) = T v \u03a3V\u222a{V } . By Theorem 2.13.3, we can construct and \u03a3V\u222a{V }-fta A \u2032 with L(A\u2032) = L(B) \u2229 L(C). Then, by (14.7) we have L(A\u2032) = LV\u222a{V }(\u03d5).\nNow we can prove that definable implies recognizable.\nLemma 14.1.9. For every finite set V of variables and formula \u03d5 \u2208 MSO(\u03a3) with Free(\u03d5) \u2286 V , we can construct a \u03a3V -fta A such that L(A) = LV(\u03d5).\nProof. First, by induction on the well-founded set (MSO(\u03a3),\u227aMSO(\u03a3)), we prove the following.\nFor each \u03d5 \u2208 MSO(\u03a3), we can construct a \u03a3Free(\u03d5)-fta B such that L(B) = L(\u03d5). (14.8)\nI.B.: For the induction base we distinguish three cases.\nCase (a): Let \u03d5 = label\u03c3(x). Then Free(\u03d5) = {x}. Moreover, let \u0393 = {(\u03c3, {x})}. Clearly L(\u03d5) = L\u0393 \u2229 Tv\u03a3{x} . By Lemma 14.1.6 we can construct a \u03a3{x}-fta C such that L(C) = L\u0393. By Lemma 14.1.5 we can construct a \u03a3V -fta D such that L(D) = T v \u03a3{x} . By Theorem 2.13.3, we can construct a \u03a3{x}-fta B such that L(B) = L(C) \u2229 L(D).\nCase (b): Let \u03d5 = edgej(x, y). Then Free(\u03d5) = {x, y}. Moreover, let \u03931 = {(\u03c3, {x}) | \u03c3 \u2208 \u03a3} and \u03932 = {(\u03c3, {y}) | \u03c3 \u2208 \u03a3}. Clearly L(\u03d5) = L\u03931,\u03932,j \u2229 T v \u03a3{x,y} . By Lemma 14.1.7, we can construct a \u03a3{x,y}-fta C such that L(C) = L\u03931,\u03932,j . Then we proceed as in Case (a).\nCase (c): Let \u03d5 = (x \u2208 X). Then Free(\u03d5) = {x,X}. Moreover, let \u0393 = {(\u03c3, {x,X}) | \u03c3 \u2208 \u03a3}. Clearly L(\u03d5) = L\u0393 \u2229 Tv\u03a3{x,X} . Then we proceed as in Case (a).\nI.S.: For the induction step we distinguish four cases.\nCase (a): Let \u03d5 = (\u00ac\u03c8). We note that L(\u03d5) = Tv\u03a3Free(\u03d5) \\ L(\u03c8). By Lemma 14.1.5 we can construct\na \u03a3Free(\u03d5)-fta D such that L(D) = T v \u03a3Free(\u03d5) . By I.H. we can construct a \u03a3Free(\u03d5)-fta C such that L(C) = L(\u03c8). By Theorem 2.13.3, we can construct a \u03a3Free(\u03d5)-fta B such that L(B) = L(D) \\ L(C).\nCase (b): Let \u03d5 = \u03c81\u2228\u03c82. We note that L(\u03d5) = LFree(\u03d5)(\u03c81)\u222aLFree(\u03d5)(\u03c82). By I.H. we can construct \u03a3Free(\u03c8i)-fta Ci such that L(Ci) = L(\u03c8i) for i \u2208 {1, 2}. Then, by Lemma 14.1.8 we can construct \u03a3Free(\u03d5)fta Di such that L(Di) = LFree(\u03d5)(\u03c8i) for i \u2208 {1, 2}. Lastly, by Theorem 2.13.3, we can construct a \u03a3Free(\u03d5)-fta B such that L(B) = L(D1) \u222a L(D2).\nCase (c): Let \u03d5 = (\u2203x.\u03c8). By I.H. we can construct a \u03a3Free(\u03c8)-fta C such that L(C) = L(\u03c8). Then, by Lemma 14.1.8, we can construct a \u03a3Free(\u03c8)\u222a{x}-fta C \u2032 such that L(C\u2032) = LFree(\u03c8)\u222a{x}(\u03c8). By Theorem 2.13.2, we can construct a total and bu deterministic \u03a3Free(\u03c8)\u222a{x}-fta D = (Q, \u03b4, F ) such that L(D) = LFree(\u03c8)\u222a{x}(\u03c8).\nLastly, we construct the \u03a3Free(\u03d5)-fta B = (Q \u2032, \u03b4\u2032, F \u2032) such that Q\u2032 = Q \u00d7 {0, 1} (where each state is\nviewed as natural number), F \u2032 = F \u00d7 {1}, and for each k \u2208 N, we have\n\u03b4\u2032k = { ( (q1, 0) \u00b7 \u00b7 \u00b7 (qk, 0), (\u03c3, U), (q, 0) ) | (\u03c3, U) \u2208 \u03a3 (k) Free(\u03d5), (q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3, U), q) \u2208 \u03b4k}\n\u222a { ( (q1, 0) \u00b7 \u00b7 \u00b7 (qk, 0), (\u03c3, U), (q, 1) ) | (\u03c3, U) \u2208 \u03a3 (k) Free(\u03d5), (q1 . . . qk, (\u03c3, U \u222a {x}), q) \u2208 \u03b4k} \u222a { ( (q1, p1) \u00b7 \u00b7 \u00b7 (qk, pk), (\u03c3, U), (q, 1) ) | (\u03c3, U) \u2208 \u03a3 (k) Free(\u03d5), (q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3, U), q) \u2208 \u03b4k,+i\u2208[k] pi = 1}.\n286 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nNow we prove that L(\u03d5) = L(B). For this, let \u03b6 = (\u03be, \u03b7) be in Tv\u03a3Free(\u03d5) . For each \u03c1 : pos(\u03be) \u2192 Q \u2032, we define \u03c01(\u03c1) : pos(\u03be)\u2192 Q and \u03c02(\u03c1) : pos(\u03be)\u2192 {0, 1} such that, for each w \u2208 pos(\u03be), we let \u03c01(\u03c1)(w) and \u03c02(\u03c1)(w) be the first component of \u03c1(w) and the second component of \u03c1(w), respectively.\n\u03b6 \u2208 L(\u03d5)\niff \u03b6 |= (\u2203x.\u03c8)\niff (\u2203w \u2208 pos(\u03be)) : (\u03be, \u03b7[x 7\u2192 w]) |= \u03c8\niff (\u2203w \u2208 pos(\u03be)) : (\u03be, \u03b7[x 7\u2192 w]) \u2208 L(D) iff (\u2203w \u2208 pos(\u03be), \u03c11 \u2208 R v D((\u03be, \u03b7[x 7\u2192 w]))) : \u03c11(\u03b5) \u2208 F iff (\u2203w \u2208 pos(\u03be), \u03c1 \u2208 RvB(\u03b6)) : \u03c01(\u03c1) \u2208 R v D((\u03be, \u03b7[x 7\u2192 w])) \u2227 \u03c01(\u03c1)(\u03b5) \u2208 F\u2227\n(\u2200v \u2208 prefix(w)) : \u03c02(\u03c1)(v) = 1 \u2227 (\u2200v \u2208 pos(\u03be) \\ prefix(w)) : \u03c02(\u03c1)(v) = 0\niff (\u2203\u03c1 \u2208 RvB(\u03b6)) : \u03c1(\u03b5) \u2208 F \u2032 iff \u03b6 \u2208 L(B) .\nWe can also give an alternative proof as follows (using closure under tree relabelings). We observe that L(\u03d5) = \u03c4(LFree(\u03c8)\u222a{x}(\u03c8)) where \u03c4 = (\u03c4k | k \u2208 N) is the deterministic (\u03a3Free(\u03c8)\u222a{x},\u03a3Free(\u03d5))-tree relabeling defined, for each k \u2208 N and (\u03c3, U) \u2208 \u03a3 (k) Free(\u03c8)\u222a{x} by \u03c4((\u03c3, U)) = (\u03c3, U \u2229 Free(\u03d5)). This can be seen as follows:\n(\u03be, \u03c1) \u2208 L(\u03d5) iff (\u03be, \u03c1) |= \u03d5\niff (\u2203w \u2208 pos(\u03be)) : (\u03be, \u03c1[x\u2192 w]) |= \u03c8 iff (\u2203\u03b6\u2032 \u2208 Tv\u03a3Free(\u03c8)\u222a{x}) : \u03c4(\u03b6 \u2032) = (\u03be, \u03c1) and \u03b6\u2032 |= \u03c8 iff (\u2203\u03b6\u2032 \u2208 LFree(\u03c8)\u222a{x}(\u03c8)) : \u03c4(\u03b6 \u2032) = (\u03be, \u03c1)\niff (\u03be, \u03c1) \u2208 \u03c4(LFree(\u03c8)\u222a{x}(\u03c8)).\nBy I.H. we can construct a \u03a3Free(\u03c8)-fta C such that L(C) = L(\u03c8). Hence, by Lemma 14.1.8, we can also construct a \u03a3Free(\u03c8)\u222a{x}-fta D such that L(D) = LFree(\u03c8)\u222a{x}(\u03c8). Then, by the fact that L(\u03d5) = \u03c4(LFree(\u03c8)\u222a{x}(\u03c8)) and by Theorem 10.10.1, we can construct a \u03a3Free(\u03d5)-fta B such that L(B) = L(\u03d5).\nCase (d): Let \u03d5 = (\u2203X.\u03c8). By I.H. we can construct a \u03a3Free(\u03c8)-fta C such that L(C) = L(\u03c8). Then, by Lemma 14.1.8, we can construct a \u03a3Free(\u03c8)\u222a{X}-fta C \u2032 = (Q, \u03b4, F ) such that L(C\u2032) = LFree(\u03c8)\u222a{X}(\u03c8).\nLastly, we construct the \u03a3Free(\u03d5)-fta B = (Q, \u03b4 \u2032, F ) such that, for every k \u2208 N, we let\n\u03b4\u2032k = {(q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3, U), q) |(\u03c3, U) \u2208 \u03a3 (k) Free(\u03d5) and\n((q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3, U), q) \u2208 \u03b4k or (q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3, U \u222a {X}), q) \u2208 \u03b4k}\nThen it is easy to see that L(B) = L(\u03d5).\nAlso here we can give an alternative proof as follows. Now we observe that L(\u03d5) = \u03c4(LFree(\u03c8)\u222a{X}(\u03c8)) where \u03c4 = (\u03c4k | k \u2208 N) is the (\u03a3Free(\u03c8)\u222a{X},\u03a3Free(\u03d5))-tree relabeling defined, for every k \u2208 N and (\u03c3, U) \u2208 \u03a3 (k) Free(\u03c8)\u222a{X} by \u03c4((\u03c3, U)) = (\u03c3, U \u2229 Free(\u03d5)). Then the proof can be finished similarly as in Case (c).\nThis finishes the proof of (14.8). Finally, by applying Lemma 14.1.8 to the fta B an appropriate number of times, we obtain the desired \u03a3V -fta A with L(A) = LV(\u03d5)."
        },
        {
            "heading": "14.2 Adding weights",
            "text": "Now we add weights to MSO(\u03a3) in the following way. As atomic formulas of the weighted logic MSO(\u03a3,B) we use formulas of the form H(\u03ba), where \u03ba is an N-indexed family of mappings \u03bak : (\u03a3U ) (k) \u2192 B. This\n14.2. ADDING WEIGHTS 287\nintroduces the weights into the logic. Roughly speaking, the semantics of H(\u03ba) is the unique \u03a3-algebra homomorphism hM(\u03a3,\u03ba) from the \u03a3U -term algebra to the (\u03a3, \u03ba)-evaluation algebra (cf. Section 2.9 and Equation (2.27)). In the setting of the weighted logics of [DG05], the formula H(\u03ba) can be simulated by a weighted first-order universal quantification over a recognizable step formula (cf. Lemma 14.4.9).\nWe define the set of MSO formulas over \u03a3 and B, denoted by MSO(\u03a3,B), by the following EBNF with nonterminal e: e ::= H(\u03ba) | (\u03d5\u22b2 e) | (e + e) |+x e |+X e , (14.9) where\n\u2022 there exists a finite set U of variables such that \u03ba = (\u03bak | k \u2208 N) is an N-indexed family of mappings \u03bak : (\u03a3U )\n(k) \u2192 B, \u2022 \u03d5 \u2208MSO(\u03a3).\nWe will drop parentheses whenever no confusion arises. We call formulas of the form H(\u03ba) atomic formulas, formulas of the form \u03d5 \u22b2 e guarded formulas, and formulas of the form +x e and +X e the weighted first-order existential quantification (of e) and weighted second-order existential quantification (of e), respectively.\nAs for MSO(\u03a3)-formulas in Section 14.1, in order to perform inductive proofs or to define objects by induction, we will consider the well-founded set\n(MSO(\u03a3,B),\u227aMSO(\u03a3,B))\nwhere \u227aMSO(\u03a3,B) is the binary relation on MSO(\u03a3,B) defined as follows. For every e1, e2 \u2208 MSO(\u03a3,B), we let e1 \u227aMSO(\u03a3,B) e2 if e1 is a direct subformula of e2 in the sense of (14.9). Then \u227aMSO(\u03a3,B) is well-founded and min\u227aMSO(\u03a3,B)(MSO(\u03a3,B)) is the set of formulas of the form H(\u03ba).\nNext we define the semantics of MSO formulas over \u03a3 and B. For this purpose, we need the notion of free variable; for later purpose, we also define the notion of bound variables. Formally, for each e \u2208 MSO(\u03a3,B), we define the set Free(e) of free variables of e and the set Bound(e) of bound variables of e by induction on (MSO(\u03a3,B),\u227aMSO(\u03a3,B)) as follows:\n\u2022 If U is a finite set of variables and \u03ba = (\u03bak | n \u2208 N) with \u03bak : (\u03a3U ) (k) \u2192 B, then Free(H(\u03ba)) = U\nand Bound(H(\u03ba)) = \u2205, \u2022 Free(\u03d5\u22b2 e) = Free(\u03d5) \u222a Free(e) and Bound(\u03d5\u22b2 e) = Bound(\u03d5) \u222a Bound(e), \u2022 Free(e1 + e2) = Free(e1) \u222a Free(e2) and Bound(e1 + e2) = Bound(e1) \u222a Bound(e2), and \u2022 Free(+x e) = Free(e) \\ {x} and Free(+X e) = Free(e) \\ {X} and Bound(+x e) = Bound(e) \u222a {x} and Bound(+X e) = Bound(e) \u222a {X}.\nIf Free(e) = \u2205, then we call e a sentence.\nSince the semantics of an atomic formula uses the concept of evaluation algebra, we briefly recall it from Section 2.9. For a given N-indexed family \u03ba = (\u03bak | k \u2208 N) with \u03bak : \u03a3(k) \u2192 B, the (\u03a3,B)-evaluation algebra (B, \u03ba) with \u03ba(\u03c3)(b1, . . . , bk) = b1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 bk \u2297 \u03bak(\u03c3), is denoted by M(\u03a3, \u03ba), and the \u03a3-algebra homomorphism from the \u03a3-term algebra to M(\u03a3, \u03ba) is denoted by hM(\u03a3,\u03ba). We will employ this concept for various ranked alphabets when defining the semantics of atomic formulas.\nIn the sequel we will abbreviate hM(\u03a3,\u03ba) by h\u03ba.\nNow let U and V be finite sets of variables such that U \u2286 V . Moreover, let \u03ba = (\u03bak | k \u2208 N) with \u03bak :\n\u03a3 (k) U \u2192 B. We define the N-indexed family \u03ba[U V ] = (\u03ba[U V ]k | k \u2208 N) with \u03ba[U V ]k : \u03a3 (k) V \u2192 B such that, for every \u03c3 \u2208 \u03a3(k) and W \u2286 V , we have\n\u03ba[U V ]k(\u03c3,W) = \u03bak(\u03c3,U \u2229W) .\nLet e \u2208 MSO(\u03a3,B) and V be a finite set of variables such that V \u2287 Free(e). We define the semantics of e with respect to V , denoted by [[e]]V , to be a (\u03a3V ,B)-weighted tree language. In other words, for each\n288 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\ne \u2208 MSO(\u03a3,B), we define the family ([[e]]V | V \u2287 Free(e),V finite). Since [[e]]V depends on the semantics of the subformulas of e (each with respect to its own set of variables), we define the family\n(( [[e]]V | V \u2287 Free(e),V finite ) | e \u2208MSO(\u03a3,B) )\nby induction on (MSO(\u03a3,B),\u227aMSO(\u03a3,B)) as follows.\n\u2022 Let U be a finite set of variables and \u03ba = (\u03bak | k \u2208 N) be an N-indexed family with \u03bak : (\u03a3U )(k) \u2192 B. Let V \u2287 Free(H(\u03ba)) be a finite set of variables. Then, for each \u03b6 \u2208 T\u03a3V , we define\n[[H(\u03ba)]]V (\u03b6) =\n{ h\u03ba[U V](\u03b6) if \u03b6 \u2208 T v \u03a3V\n0 otherwise .\n\u2022 Let \u03d5 \u2208 MSO(\u03a3) and e \u2208 MSO(\u03a3,B). Let V \u2287 Free(\u03d5 \u22b2 e) be a finite set of variables. Then, for each \u03b6 \u2208 T\u03a3V , we define\n[[\u03d5 \u22b2 e]]V(\u03b6) =\n{ [[e]]V(\u03b6) if \u03b6 \u2208 LV(\u03d5)\n0 otherwise .\n\u2022 Let e1, e2 \u2208 MSO(\u03a3,B). Let V \u2287 Free(e1 + e2) be a finite set of variables. Then, for each \u03b6 \u2208 T\u03a3V , we define\n[[e1 + e2]]V(\u03b6) =\n{( [[e1]]V(\u03b6) \u2295 [[e2]]V(\u03b6) if \u03b6 \u2208 Tv\u03a3V\n0 otherwise .\n\u2022 Let x be a first-order variable and e \u2208 MSO(\u03a3,B). Let V \u2287 Free(+x e) be a finite set of variables. Then, for each \u03b6 \u2208 T\u03a3V , we define\n[[+x e]]V(\u03b6) = {\u2295 w\u2208pos(\u03b6)[[e]]V\u222a{x}(\u03b6[x 7\u2192 w]) if \u03b6 \u2208 T v \u03a3V\n0 otherwise .\n\u2022 Let X be a second-order variable and e \u2208 MSO(\u03a3,B). Let V \u2287 Free(+X e) be a finite set of variables. Then, for each \u03b6 \u2208 T\u03a3V , we define\n[[+X e]]V(\u03b6) = {\u2295 W\u2286pos(\u03b6)[[e]]V\u222a{X}(\u03b6[X 7\u2192W ]) if \u03b6 \u2208 T v \u03a3V\n0 otherwise .\nBy definition, it is clear that the following holds:\nfor every finite set V of variables, \u03d5 \u2208 MSO(\u03a3), and e \u2208MSO(\u03a3,B) such that V \u2287 Free(\u03d5\u22b2 e), we have [[\u03d5\u22b2 e]]V = \u03c7(LV(\u03d5)) \u2297 [[e]]V . (14.10)\nWe abbreviate [[e]]Free(e) by [[e]]. We say that a (\u03a3,B)-weighted tree language r is definable by a formula in MSO(\u03a3,B)-logic (or: definable) if there exists a sentence e \u2208MSO(\u03a3,B) with [[e]] = r.\nNext we show a consistency lemma for formulas in MSO(\u03a3,B).\nLemma 14.2.1. (cf. [FSV12, Lm. 3.8]) Let e \u2208 MSO(\u03a3,B) and let V and W be finite sets of variables with Free(e) \u2286 W \u2286 V . Then, for each (\u03be, \u03b7) \u2208 Tv\u03a3V , we have [[e]]V(\u03be, \u03b7) = [[e]]W(\u03be, \u03b7|W ).\nProof. We prove the statement by induction on (MSO(\u03a3,B),\u227aMSO(\u03a3,B)).\nI.B.: Let e = H(\u03ba). Let U be a finite set of variables and \u03ba = (\u03bak | k \u2208 N) an N-indexed family of mappings \u03bak : (\u03a3U )\n(k) \u2192 B. Moreover, let V and W be finite sets of variables with U \u2286 W \u2286 V and (\u03be, \u03b7) \u2208 Tv\u03a3V . Then\n[[H(\u03ba)]]V (\u03be, \u03b7) = h\u03ba[U V](\u03be, \u03b7) = (\u2217) h\u03ba[U W](\u03be, \u03b7|W) = [[H(\u03ba)]]W (\u03be, \u03b7|W) ,\n14.2. ADDING WEIGHTS 289\nwhere the equality (\u2217) can be proved as follows. Let \u03b6 \u2208 Tv\u03a3V and \u03b6 \u2032 \u2208 Tv\u03a3W be the trees which correspond to (\u03be, \u03b7) and (\u03be, \u03b7|W ), respectively. We have to show that\nh\u03ba[U V](\u03b6) = h\u03ba[U W](\u03b6 \u2032) . (14.11)\nObviously, \u03b6\u2032 can be obtained from \u03b6 by replacing each symbol (\u03c3,V \u2032) in \u03b6 by (\u03c3,W \u2229 V \u2032). By 2.27, h\u03ba[U V](\u03b6) is the product of the weights of the symbols of \u03b6, where the factors are ordered according to the depth-first post-order of the positions. The product h\u03ba[U W](\u03b6\n\u2032) is defined analogously. Since pos(\u03b6) = pos(\u03b6\u2032), there exists a bijection between the lists of the factors of the two products. Moreover, the factors which correspond to each other are equal, because for every k \u2208 N, \u03c3 \u2208 \u03a3(k), and V \u2032 \u2286 V , by definition we have\n\u03ba[U V ]k(\u03c3,V \u2032) = \u03bak(\u03c3,U \u2229 V \u2032) = \u03bak(\u03c3,U \u2229 (W \u2229 V \u2032)) = \u03ba[U W ]k(\u03c3,W \u2229 V \u2032) .\nThis proves (14.11) and hence (\u2217).\nI.S.: For each form of e, the induction step is straightforward, hence we do not show the details. We note that in case e = (\u03d5\u22b2 e\u2032) we use Lemma 14.1.1.\nExample 14.2.2. Let b \u2208 B and x be a first-order variable.\n1. We define the family \u03ba(b) = (\u03ba(b)k | k \u2208 N) of mappings \u03ba(b)k : \u03a3 (k) {x} \u2192 B such that, for each\n(\u03c3, U) \u2208 \u03a3 (k) {x}, we let\n\u03ba(b)k((\u03c3, U)) =\n{ b if U = {x}\n1 otherwise .\nThen,\nfor every \u03be \u2208 T\u03a3 and w \u2208 pos(\u03be), we have [[H(\u03ba(b))]]{x}(\u03be, [x 7\u2192 w]) = b . (14.12)\nThis can be seen as follows:\n[[H(\u03ba(b))]]{x}(\u03be, [x 7\u2192 w]) = h\u03ba(b)[{x} {x}](\u03be, [x 7\u2192 w]) = h\u03ba(b)(\u03be, [x 7\u2192 w])\n= \u2297\nv\u2208pos(\u03be) in \u2264dp order\n\u03ba(b)rk(\u03be(v))((\u03be, [x 7\u2192 w])(v)) (by (2.27))\n= 1\u2297 \u00b7 \u00b7 \u00b7 \u2297 1\ufe38 \ufe37\ufe37 \ufe38 n\u22121 \u2297 b\u2297 1\u2297 \u00b7 \u00b7 \u00b7 \u2297 1 = b ,\nwhere we assume that w occurs at the n-th position in the \u2264dp order of pos(\u03be).\n2. Let us consider the MSO(\u03a3,B)-sentence \u3008b\u3009 defined by\n\u3008b\u3009 =+x(root(x) \u22b2H(\u03ba(b))) where the family \u03ba(b) is defined in the first part of this example. It is clear that L{x}(root(x)) = {(\u03be, [x 7\u2192 \u03b5]) | \u03be \u2208 T\u03a3}. Then, for each \u03be \u2208 T\u03a3, we have\n[[\u3008b\u3009]](\u03be) = [[+x(root(x)\u22b2H(\u03ba(b)))]](\u03be) = \u2295\nw\u2208pos(\u03be)\n[[root(x)\u22b2H(\u03ba(b))]]{x}(\u03be, [x 7\u2192 w])\n= \u2295\nw\u2208pos(\u03be)\n\u03c7 ( L{x}(root(x)) ) (\u03be, [x 7\u2192 w]) \u2297 [[H(\u03ba(b))]]{x}(\u03be, [x 7\u2192 w]) (by (14.10))\n= \u2295\nw\u2208pos(\u03be): (\u03be,[x 7\u2192w])\u2208L{x}(root(x))\n[[H(\u03ba(b))]]{x}(\u03be, [x 7\u2192 w]) = [[H(\u03ba(b))]]{x}(\u03be, [x 7\u2192 \u03b5])\n290 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\n= b . (by (14.12))\nHence [[\u3008b\u3009]] = b\u0303.\n3. Now let \u03d5 be an MSO(\u03a3)-formula. We consider the MSO(\u03a3,B)-formula \u03d5 \u22b2 \u3008b\u3009. Then, for each finite set V of variables with Free(\u03d5) \u2286 V and \u03be \u2208 T\u03a3V , we have\n[[\u03d5\u22b2 \u3008b\u3009]]V(\u03be) = \u03c7(LV(\u03d5))(\u03be) \u2297 [[\u3008b\u3009]]V (\u03be) (by (14.10))\n= [[\u3008b\u3009]]V(\u03be) \u2297 \u03c7(LV(\u03d5))(\u03be) (because \u03c7(L(\u03d5))(\u03be) \u2208 {0, 1})\n= [[\u3008b\u3009]](\u03be) \u2297 \u03c7(LV(\u03d5))(\u03be) (by Lemma 14.2.1) = ( b\u2297 \u03c7(LV(\u03d5)) ) (\u03be) . (because [[\u3008b\u3009]](\u03be) = b)\nHence [[\u03d5\u22b2 \u3008b\u3009]]V = b\u2297 \u03c7(LV(\u03d5)).\nNow we will define particular MSO(\u03a3,B)-formulas called recognizable step formulas. We show that the semantics of recognizable step sentences are recognizable step mappings, and vice versa, each recognizable step mapping is the semantics of such a recognizable step sentence.\nA (\u03a3,B)-recognizable step formula is a formula in MSO(\u03a3,B) of the form\n(\u03d51 \u22b2 \u3008b1\u3009) + . . .+ (\u03d5n \u22b2 \u3008bn\u3009) , (14.13)\nwhere \u03d5i is an MSO(\u03a3)-formula and \u3008bi\u3009 is an MSO(\u03a3,B)-sentence defined in Example 14.2.2(2) for each i \u2208 [n]. If, in addition, \u03d51, . . . , \u03d5n are sentences, then (14.13) is called a (\u03a3,B)-recognizable step sentence.\nBy Example 14.2.2(3), for each finite set V of variables such that V \u2287 \u22c3 i\u2208[n] Free(\u03d5i), we have\n[[(\u03d51 \u22b2 \u3008b1\u3009) + . . .+ (\u03d5n \u22b2 \u3008bn\u3009)]]V = \u2295\ni\u2208[n]\nbi \u2297 \u03c7(LV(\u03d5i)) . (14.14)\nLemma 14.2.3. Let r : T\u03a3 \u2192 B be a weighted tree language, n \u2208 N+, and b1, . . . , bn \u2208 B. Then the following two statements are equivalent.\n(A) We can construct \u03a3-fta A1, . . . , An such that r = \u2295 i\u2208[n] bi \u2297 \u03c7(L(Ai)). (B) We can construct sentences \u03d51, . . . , \u03d5n in MSO(\u03a3) such that, for each i \u2208 [n], we have r = [[(\u03d51 \u22b2 \u3008b1\u3009) + . . .+ (\u03d5n \u22b2 \u3008bn\u3009)]].\nProof. The proof follows from Theorem 14.1.3(A)\u21d4(B) and (14.14).\nExample 14.2.4. In this example, the weight algebra is the semiring Nat = (N,+, \u00b7, 0, 1).\n1. We consider the MSO(\u03a3,Nat)-sentence\ne =+x(\u03d5(x) \u22b2H(\u03ba(1))) , where \u03d5(x) = ( label\u03c3(x)\u2228\u00aclabel\u03c3(x) ) for some \u03c3 \u2208 \u03a3, and the N-indexed family \u03ba(1) of mappings is defined in Example 14.2.2.\nObviously, L{x}(\u03d5(x)) = T v \u03a3{x} . Then, for each \u03be \u2208 T\u03a3, we have\n[[e]](\u03be) = [[+x(\u03d5(x) \u22b2H(\u03ba(1)))]](\u03be) = + w\u2208pos(\u03be) [[\u03d5(x) \u22b2H(\u03ba(1))]]{x}(\u03be, [x 7\u2192 w])\n= + w\u2208pos(\u03be)\n\u03c7 ( L{x}(\u03d5(x)) ) (\u03be, [x 7\u2192 w]) \u00b7 [[H(\u03ba(1))]]{x}(\u03be, [x 7\u2192 w]) (by (14.10))\n= + w\u2208pos(\u03be)\n\u03c7 ( Tv\u03a3{x} ) (\u03be, [x 7\u2192 w]) \u00b7 [[H(\u03ba(1))]]{x}(\u03be, [x 7\u2192 w])\n14.2. ADDING WEIGHTS 291\n= + w\u2208pos(\u03be) [[H(\u03ba(1))]]{x}(\u03be, [x 7\u2192 w]) (because (\u03be, [x 7\u2192 w]) \u2208 T v \u03a3{x} )\n= + w\u2208pos(\u03be) 1 (by (14.12))\n= size(\u03be) .\nHence [[e]] = size.\n2. Now let \u03a3 = {\u03c3(2), \u03b3(1), \u03b1(0)} and consider the MSO(\u03a3,Nat)-sentence\ne =+x(\u03d5(x) \u22b2H(\u03ba(1))) , where \u03d5(x) = ( label\u03c3(x) \u2227 \u2200y.(edge2(x, y)\u2192 label\u03b1(y)) ) . It is easy to see that\nL{x}(\u03d5(x)) = {(\u03be, [x 7\u2192 w]) | \u03be \u2208 T\u03a3, w \u2208 pos(\u03be), \u03be(w) = \u03c3 and \u03be(w2) = \u03b1} .\nThen for each \u03be \u2208 T\u03a3, we have\n[[e]](\u03be) = + w\u2208pos(\u03be)\n\u03c7 ( L{x}(\u03d5(x)) ) (\u03be, [x 7\u2192 w]) \u00b7 [[H(\u03ba(1))]]{x}(\u03be, [x 7\u2192 w]) (as above)\n= + w\u2208pos(\u03be):\n\u03be(w)=\u03c3,\u03be(w2)=\u03b1\n[[H(\u03ba(1))]]{x}(\u03be, [x 7\u2192 w])\n= + w\u2208pos(\u03be):\n\u03be(w)=\u03c3,\u03be(w2)=\u03b1\n1 (by (14.12))\n= #\u03c3(.,\u03b1)(\u03be) . (for #\u03c3(.,\u03b1), see Example 3.2.11)\nHence [[e]] = #\u03c3(.,\u03b1).\nExample 14.2.5. Here we show that the weighted tree language height : T\u03a3 \u2192 N is definable over the arctic semiring Natmax,+ = (N\u2212\u221e,max,+,\u2212\u221e, 0). We let \u03d5 be the following MSO(\u03a3)-formula with Free(\u03d5) = {x,X}:\n\u03d5(x,X) = leaf(x) \u2227 Path(X, x), where\nleaf(x) = \u00ac\u2203y.edge(x, y),\nPath(X, x) = \u2200y.(y \u2208 X)\u2194 path(y, x),\nand path(y, x) is the formula defined in Example 14.1.2.\nThe following is obvious:\nL{x,X}(\u03d5) = {(\u03be, [x 7\u2192 w,X 7\u2192 prefix(w)]) | \u03be \u2208 T\u03a3, w \u2208 pos(\u03be), \u03be(w) \u2208 \u03a3 (0)} (14.15)\nThen we consider the MSO(\u03a3,Natmax,+)-formula\neheight =+x+X(\u03d5(x,X)\u22b2H(\u03ba)) where \u03ba = (\u03bak | k \u2208 N) and \u03bak : (\u03a3{x,X}) (k) \u2192 B defined, for each (\u03c3, U) \u2208 (\u03a3{x,X}) (k), by\n\u03bak((\u03c3, U)) =\n{ 1 if X \u2208 U and k \u2265 1\n0 otherwise .\n292 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nIt is clear that, for every (\u03be, [x 7\u2192 w,X 7\u2192 prefix(w)]) \u2208 L{x,X}(\u03d5), we have\n[[H(\u03ba)]]{x,X}(\u03be, [x 7\u2192 w,X 7\u2192 prefix(w)]) = |w| . (14.16)\nThen, for each \u03be \u2208 T\u03a3, we have\n[[eheight]](\u03be) = [[+x+X(\u03d5(x,X)\u22b2H(\u03ba))]](\u03be) = max ( max ( [[\u03d5(x,X)\u22b2H(\u03ba)]]{x,X}(\u03be[x 7\u2192 w,X 7\u2192W ]) | W \u2286 pos(\u03be) ) | w \u2208 pos(\u03be) )\n= max ( [[\u03d5(x,X)\u22b2H(\u03ba)]]{x,X}(\u03be[x 7\u2192 w,X 7\u2192W ]) |W \u2286 pos(\u03be), w \u2208 pos(\u03be) ) = max ( [[H(\u03ba)]]{x,X}(\u03be[x 7\u2192 w,X 7\u2192 prefix(w)]) | w \u2208 pos(\u03be), \u03be(w) \u2208 \u03a3 (0) ) (by (14.15))\n= max(|w| | w \u2208 pos(\u03be), \u03be(w) \u2208 \u03a3(0)) (by (14.16))\n= height(\u03be) .\nWe finish this section with two easy properties. Roughly speaking, they say that weighted existential quantification can be expressed by deterministic tree relabelings, where in the first-order case we have to take care of preserving validity.\nLemma 14.2.6. Let e \u2208MSO(\u03a3,B).\n(1) Let V = Free(+x e). Then [[+x e]] = \u03c7(\u03c4)([[e]]V\u222a{x}) \u2297 \u03c7(Tv\u03a3V ), where \u03c4 = (\u03c4k | k \u2208 N) is the deterministic (\u03a3V\u222a{x},\u03a3V)-tree relabeling such that, for every k \u2208 N, \u03c3 \u2208 \u03a3\n(k), and W \u2286 V \u222a {x}, we let \u03c4k((\u03c3,W)) = {(\u03c3,W \\ {x})}. (2) Let V = Free(+X e). Then [[+X e]] = \u03c7(\u03c4)([[e]]V\u222a{X}), where \u03c4 = (\u03c4k | k \u2208 N) is the deterministic (\u03a3V\u222a{X},\u03a3V)-tree relabeling such that, for every k \u2208 N, \u03c3 \u2208 \u03a3\n(k), and W \u2286 V \u222a {X}, we let \u03c4k((\u03c3,W)) = {(\u03c3,W \\ {X})}.\nProof. Proof of (1): Let V = Free(+x e) and \u03be \u2208 T\u03a3V . We note that x 6\u2208 V . We distinguish the following two cases.\nCase (a): Let \u03be 6\u2208 Tv\u03a3V . Then [[+x e]](\u03be) = 0 = \u03c7(\u03c4)([[e]]V\u222a{x})(\u03be)\u2297 \u03c7(Tv\u03a3V )(\u03be). Case (b): Let \u03be \u2208 Tv\u03a3V . Then we can calculate as follows:\n[[+x e]](\u03be) = \u2295\nw\u2208pos(\u03be)\n[[e]]V\u222a{x}(\u03be[x 7\u2192 w])\n= \u2295\n\u03b6\u2208{\u03be[x 7\u2192w]|w\u2208pos(\u03be)}\n[[e]]V\u222a{x}(\u03b6) (because \u03be[x 7\u2192 w] 6= \u03be[x 7\u2192 w \u2032] for w 6= w\u2032)\n= \u2295\n\u03b6\u2208\u03c4\u22121(\u03be)\u2229Tv\u03a3V\u222a{x}\n[[e]]V\u222a{x}(\u03b6) (by definition of \u03c4)\n= \u2295\n\u03b6\u2208\u03c4\u22121(\u03be)\n[[e]]V\u222a{x}(\u03b6) (because [[e]]V\u222a{x}(\u03b6) = 0 for \u03b6 \u2208 \u03c4 \u22121(\u03be) \\ Tv\u03a3V\u222a{x})\n= \u03c7(\u03c4)([[e]]V\u222a{x})(\u03be) (by (2.30)) = ( \u03c7(\u03c4)([[e]]V\u222a{x})\u2297 \u03c7(T v \u03a3V ) ) (\u03be) . (because \u03c7(Tv\u03a3V )(\u03be) = 1)\nProof of (2): Let V = Free(+X e) and \u03be \u2208 T\u03a3V . We note that X 6\u2208 V . Since U (1) = V(1) (i.e., the set of first-order variables of U is the same as the set of first-order variables of V), we have\nfor every \u03be \u2208 T\u03a3V and \u03b6 \u2208 \u03c4 \u22121(\u03be): \u03be \u2208 Tv\u03a3V iff \u03b6 \u2208 T v \u03a3V\u222a{X} . (14.17)\nWe distinguish the following two cases.\n14.3. THE MAIN RESULT 293\nCase (a): Let \u03be 6\u2208 Tv\u03a3V . Then [[+X e]](\u03be) = 0 = \u03c7(\u03c4)([[e]]V\u222a{x})(\u03be) where the second equality holds by (14.17).\nCase (b): Let \u03be \u2208 Tv\u03a3V . Then we can calculate as follows:\n[[+X e]](\u03be) = \u2295\nW\u2286pos(\u03be)\n[[e]]V\u222a{X}(\u03be[X 7\u2192W ])\n= \u2295\n\u03b6\u2208{\u03be[X 7\u2192W ]|W\u2286pos(\u03be)}\n[[e]]V\u222a{X}(\u03b6) (because \u03be[X 7\u2192W ] 6= \u03be[X 7\u2192W \u2032] for W 6=W \u2032)\n= \u2295\n\u03b6\u2208\u03c4\u22121(\u03be)\n[[e]]V\u222a{X}(\u03b6) (by definition of \u03c4)\n= \u03c7(\u03c4)([[e]]V\u222a{X})(\u03be) (by (2.30))"
        },
        {
            "heading": "14.3 The main result",
            "text": "The main theorem of this chapter will be the following B-E-T theorem for weighted tree languages over strong bimonoids.\nTheorem 14.3.1. Let \u03a3 be a ranked alphabet, B be a strong bimonoid, and r : T\u03a3 \u2192 B. Then the following two statements are equivalent. (A) We can construct a (\u03a3,B)-wta A such that r = [[A]]run. (B) We can construct a sentence e \u2208MSO(\u03a3,B) such that r = [[e]].\nThis theorem follows from Theorems 14.3.2 and 14.3.8, which we will prove in the next two subsections."
        },
        {
            "heading": "14.3.1 From recognizable to definable",
            "text": "We prove that, for each (\u03a3,B)-wta A, we can construct a sentence e \u2208 MSO(\u03a3,B) such that the run semantics [[A]]run is equal to [[e]]. In the usual way, we use second-order quantifications to label positions of the given tree \u03be \u2208 T\u03a3 by transitions of A; by means of a formula of MSO(\u03a3)-logic we can check whether this labeling corresponds to a run on \u03be. Finally, we define a mapping \u03ba which translates each transition into its weight.\nTheorem 14.3.2. [FSV12, Lm. 4.2] For each (\u03a3,B)-wta A, we can construct a sentence e \u2208 MSO(\u03a3,B) such that [[e]] = [[A]]run.\nProof. Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. By Theorem 7.3.1 we can assume that A is root weight normalized. Thus supp(F ) contains exactly one element, say, qf , and Fqf = 1.\nWe define the set U = \u22c3 (Qk \u00d7Q | k \u2208 N such that rk\u22121(k) 6= \u2205) .\nLet n \u2208 N+ be the cardinality of U . Then we choose an arbitrary bijection \u03bd : U \u2192 {X1, . . . , Xn} and fix it for the rest of the proof. In the sequel, we will not distinguish between a state behaviour (q1 \u00b7 \u00b7 \u00b7 qk, q) \u2208 U and the second-order variable \u03bd((q1 \u00b7 \u00b7 \u00b7 qk, q)). Thus, it is legitimate to consider each (q1 \u00b7 \u00b7 \u00b7 qk, q) \u2208 U as a second-order variable. Then, in particular, U = U (2) and hence T\u03a3U = T v \u03a3U .\nMoreover, for every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be), we define the U-assignment \u03b7\u03be,\u03c1 \u2208 \u03a6U ,\u03be as follows. For each (q1 \u00b7 \u00b7 \u00b7 qk, q) \u2208 U , we let\n\u03b7\u03be,\u03c1((q1 \u00b7 \u00b7 \u00b7 qk, q)) = {w \u2208 pos(\u03be) | \u03c1(w) = q, rk(\u03be(w)) = k, (\u2200i \u2208 [k]) : \u03c1(wi) = qi} .\n294 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nNow we define the formula \u03d5 \u2208MSO(\u03a3) where Free(\u03d5) = U with the following intention:\nThe mapping f : RA(qf , \u03be)\u2192 {\u03b7 \u2208 \u03a6U ,\u03be | (\u03be, \u03b7) \u2208 LU(\u03d5)} which is defined for each \u03c1 \u2208 RA(qf , \u03be) by f(\u03c1) = \u03b7\u03be,\u03c1, is bijective. (14.18)\nFor this, we let \u03d5 = \u03d5part \u2227 \u03d5run \u2227 \u03d5suc (14.19)\nwhere\n\u2022 \u03d5part checks whether the family (\u03b7(X) | X \u2208 U) forms a partitioning of pos(\u03be), i.e., whether each position of \u03be is assigned to exactly one transition, \u2022 \u03d5run checks whether \u03b7 codes a run in RA(\u03be), and \u2022 \u03d5suc checks whether the target state of the transition associated to the root of \u03be is qf .\nFormally, we define\n\u03d5part = \u2200x. ( \u2228\nX\u2208U\n( x \u2208 X \u2227\n\u2227\nY \u2208U\\{X}\n\u00ac(x \u2208 Y ) ))\n\u03d5run = \u2200x. \u2227\n(q1\u00b7\u00b7\u00b7qk,q)\u2208U\n[ (x \u2208 (q1 \u00b7 \u00b7 \u00b7 qk, q))\u2192 \u2227\ni\u2208[k]\n( \u2200y.edgei(x, y)\u2192\n\u2228\n(q\u20321\u00b7\u00b7\u00b7q \u2032 \u2113 ,qi)\u2208U\ny \u2208 (q\u20321 \u00b7 \u00b7 \u00b7 q \u2032 \u2113, qi)\n)]\n\u03d5suc = \u2200x.root(x)\u2192 \u2228\n(q1\u00b7\u00b7\u00b7qk,qf )\u2208U\nx \u2208 (q1 \u00b7 \u00b7 \u00b7 qk, qf )\nIt is easy to check that (14.18) holds.\nNow we define the N-indexed family (\u03bak | k \u2208 N) with \u03bak : \u03a3 (k) U \u2192 B which supplies the weights. For\nevery k \u2208 N, \u03c3 \u2208 \u03a3(k), and W \u2286 U we let\n\u03bak((\u03c3,W)) =\n{ \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) if W = {(q1 \u00b7 \u00b7 \u00b7 qk, q)}\n0 otherwise (14.20)\nLet \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be) be arbitrary but fixed. We consider (\u03be, \u03b7\u03be,\u03c1) to be an element of Tv\u03a3U (by the identification which we discussed in Section 14.1).\nFor the inductive proof of the next statement, we define the well-founded set\n(pos(\u03be),\u227a)\nwhere the binary relation \u227a on pos(\u03be) is defined as follows. For every w1, w2 \u2208 pos(\u03be), we let w1 \u227a w2 if there exists i \u2208 N such that w1 = w2i. Obviously, \u227a is well-founded and min\u227a(pos(\u03be)) = pos\u03a3(0)(\u03be), i.e., it is the set of leaves of \u03be (cf. the proof of Lemma 10.8.1). Then we can prove the next statement by induction on (pos(\u03be),\u227a).\nFor every w \u2208 pos(\u03be): h\u03ba((\u03be, \u03b7\u03be,\u03c1)|w) = wtA(\u03be|w, \u03c1|w) . (14.21)\nFor this, let w \u2208 pos(\u03be) with \u03c3 = \u03be(w), and k = rk\u03a3(\u03c3). Then we have\n(\u03be, \u03b7\u03be,\u03c1)(w) = (\u03c3, {X \u2208 U | w \u2208 \u03b7\u03be,\u03c1(X)}) = (\u03c3, {(\u03c1(w1) \u00b7 \u00b7 \u00b7 \u03c1(wk), \u03c1(w))}) .\nUsing t as abbreviation for (\u03c1(w1) \u00b7 \u00b7 \u00b7 \u03c1(wk), \u03c1(w)) we obtain\nh\u03ba((\u03be, \u03b7\u03be,\u03c1)|w) = (\u2297\ni\u2208[k]\nh\u03ba((\u03be, \u03b7\u03be,\u03c1)|wi) ) \u2297 \u03bak(t) (by (2.26))\n14.3. THE MAIN RESULT 295\n= (\u2297\ni\u2208[k]\nwtA(\u03be|wi, \u03c1|wi)) ) \u2297 \u03b4k(t) (by I.H. and the definition of \u03ba)\n= wtA(\u03be|w, \u03c1|w)) . (by Observation 3.1.1)\nNow we define the sentence e \u2208 MSO(\u03a3,B) and prove that it simulates A (we recall that we do not distinguish between elements of U and elements of {X1, . . . , Xn}):\ne =+X1 \u00b7 \u00b7 \u00b7+Xn(\u03d5\u22b2H(\u03ba)) . (14.22) Then, for each \u03be \u2208 T\u03a3, we have:\n[[e]](\u03be) = \u2295\nW1,...,Wn\u2286pos(\u03be)\n[[\u03d5\u22b2H(\u03ba)]]U (\u03be[X1 7\u2192W1, . . . , Xn \u2192Wn])\n= \u2295\n\u03b7\u2208\u03a6U,\u03be\n[[\u03d5\u22b2H(\u03ba)]]U (\u03be, \u03b7) = \u2295\n\u03b7\u2208\u03a6U,\u03be : (\u03be,\u03b7)\u2208LU(\u03d5)\n[[H(\u03ba)]]U (\u03be, \u03b7)\n= \u2295\n\u03b7\u2208\u03a6U,\u03be : (\u03be,\u03b7)\u2208LU (\u03d5)\nh\u03ba((\u03be, \u03b7)) (because \u03ba[U U ] = \u03ba)\n= \u2295\n\u03c1\u2208RA(qf ,\u03be)\nh\u03ba((\u03be, \u03b7\u03be,\u03c1)) (by (14.18))\n= \u2295\n\u03c1\u2208RA(qf ,\u03be)\nwtA(\u03be, \u03c1) (by (14.21) for w = \u03b5)\n= [[A]]run(\u03be) .\nExample 14.3.3. We illustrate the definition of the MSO(\u03a3,B)-formula (14.22) in the proof of Theorem 14.3.2. For this we consider the root weight normalized (\u03a3,Natmax,+)-wta A = (Q, \u03b4, F ) from Example 3.2.4, which i-recognizes the (\u03a3,Natmax,+)-weighted tree language height. We recall that \u03a3 = {\u03c3(2), \u03b1(0)}, Natmax,+ = (N\u2212\u221e,max,+,\u2212\u221e, 0), Q = {h, 0}, \u03b40(\u03b5, \u03b1, h) = \u03b40(\u03b5, \u03b1, 0) = 0 and for every q1, q2, q \u2208 Q,\n\u03b42(q1q2, \u03c3, q) =    1 if q1q2q \u2208 {h0h, 0hh} , 0 if q1q2q = 000 ,\n\u2212\u221e otherwise ,\nand Fh = 0 and F0 = \u2212\u221e.\nThe set U of second-order variables is the following:\nU = {(\u03b5, \u03b1, h), (\u03b5, \u03b1, 0),\n(00, \u03c3, 0), (0h, \u03c3, 0), (h0, \u03c3, 0), (hh, \u03c3, 0),\n(00, \u03c3, h), (0h, \u03c3, h), (h0, \u03c3, h), (hh, \u03c3, h)} .\nLet \u03d5 \u2208 MSO(\u03a3) be the instance of the MSO formula (14.19) for the particular (\u03a3,Natmax,+)-wta A above. We will not give further details of \u03d5. Instead, in Figure 14.2, we show the tree (\u03be, \u03b72) \u2208 T v \u03a3U which satisfies \u03d5, where \u03be = \u03c3(\u03c3(\u03b1, \u03b1), \u03b1) and the assignment \u03b72 is defined in Figure 14.1.\nNext we instantiate the family of (14.20) to the particular (\u03a3,Natmax,+)-wta A above. This provides the following N-indexed family \u03ba = (\u03bak | k \u2208 N) with \u03bak : (\u03a3U )(k) \u2192 N\u2212\u221e:\n\u03ba0((\u03b1, {(\u03b5, \u03b1, h)}) = \u03b40(\u03b5, \u03b1, h) = 0\n\u03ba0((\u03b1, {(\u03b5, \u03b1, 0)}) = \u03b40(\u03b5, \u03b1, 0) = 0\n296 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\n\u03ba2((\u03c3, {(h0, \u03c3, h)}) = \u03b42(h0, \u03c3, h) = 1\n\u03ba2((\u03c3, {(0h, \u03c3, h)}) = \u03b42(0h, \u03c3, h) = 1\n\u03ba2((\u03c3, {(00, \u03c3, 0)}) = \u03b42(00, \u03c3, 0) = 0\nand for each other argument, \u03ba0 and \u03ba2 yield \u2212\u221e. Then we instantiate the formula (14.22) to be the MSO(\u03a3,Natmax,+)-formula e is defined by\ne =+(\u03b5,\u03b1,h)+(\u03b5,\u03b1,0)+(00,\u03c3,0) \u00b7 \u00b7 \u00b7+(hh,\u03c3,h) \u03d5\u22b2H(\u03ba) . Next we compute [[e]](\u03be) for the tree \u03be = \u03c3(\u03c3(\u03b1, \u03b1), \u03b1). First, we note that\n{(\u03be, \u03b7) \u2208 T\u03a3U | (\u03be, \u03b7) |= \u03d5} = {(\u03be, \u03b71), (\u03be, \u03b72), (\u03be, \u03b73)}\nwhere the U-assignments \u03b71, \u03b72, and \u03b73 for \u03be are defined in the table shown in Figure 14.1 (where X \u2208 U).\nBy applying the unique \u03a3U -algebra homomorphism h\u03ba to (\u03be, \u03b72), we obtain\nh\u03ba((\u03be, \u03b72)) = h\u03ba((\u03be, \u03b72)|1) + h\u03ba((\u03be, \u03b72)|2) + \u03ba2((\u03c3, {(h0, \u03c3, h)}))\n= h\u03ba((\u03be, \u03b72)|1) + h\u03ba((\u03be, \u03b72)|2) + 1 = ( h\u03ba((\u03be, \u03b72)|11) + h\u03ba((\u03be, \u03b72)|12) + \u03ba2((\u03c3, {(0h, \u03c3, h)})) ) + h\u03ba((\u03be, \u03b72)|2) + 1 = ( h\u03ba((\u03be, \u03b72)|11) + h\u03ba((\u03be, \u03b72)|12) + 1 ) + h\u03ba((\u03be, \u03b72)|2) + 1 = ( \u03ba0((\u03b1, {(\u03b5, \u03b1, 0)}) + \u03ba0((\u03b1, {(\u03b5, \u03b1, h)}) + 1 ) + \u03ba0((\u03b1, {(\u03b5, \u03b1, 0)}) + 1 = ( 0 + 0 + 1 ) + 0 + 1 = 2 .\nBy similar computations we obtain h\u03ba((\u03be, \u03b71)) = 2 and h\u03ba((\u03be, \u03b73)) = 1. Finally,\n[[e]](\u03be) = max([[H(\u03ba)]]U (\u03be, \u03b71), [[H(\u03ba)]]U (\u03be, \u03b72), [[H(\u03ba)]]U (\u03be, \u03b73))\n= max(h\u03ba((\u03be, \u03b71)), h\u03ba((\u03be, \u03b72)), h\u03ba((\u03be, \u03b73)))\n= max(2, 2, 1) = 2 = height(\u03be) ."
        },
        {
            "heading": "14.3.2 From definable to recognizable",
            "text": "By induction on (MSO(\u03a3,B),\u227aMSO(\u03a3,B)), we prove that, for each formula e \u2208 MSO(\u03a3,B), we can construct a (\u03a3Free(e),B)-wta A such that [[A]] run = [[e]].\nFor this we make some preparation. As first preparation, we prove a consistency lemma for wta.\nLemma 14.3.4. Let e \u2208 MSO(\u03a3,B) with Free(e) = V , and A be a (\u03a3V ,B)-wta such that [[A]] run = [[e]]. Moreover, let V be a first-order variable or a second-order variable. Then we can construct a (\u03a3V\u222a{V },B)wta A\u2032 such that [[A\u2032]]run = [[e]]V\u222a{V }.\nProof. Case (a): Let V \u2208 V . Then we can choose A\u2032 = A and we are ready.\nCase (b): Let V 6\u2208 V . Moreover, let A = (Q, \u03b4, F ). First we construct the (\u03a3V\u222a{V },B)-wta B =\n(Q, \u03b4\u2032, F ) such that, for every k \u2208 N, (\u03c3,W) \u2208 (\u03a3V\u222a{V }) (k), and q1, . . . , qk, q \u2208 Q we define\n\u03b4\u2032k(q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3,W), q) = \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3,W \\ {V }), q) .\nObviously, for each \u03be \u2208 T\u03a3V\u222a{V } , we have pos(\u03be) = pos(\u03be|V) and RB(\u03be) = RA(\u03be|V). Moreover, for each \u03c1 \u2208 RB(\u03be), we have wtB(\u03be, \u03c1) = wtA(\u03be|V , \u03c1). Then\n[[B]]run(\u03be) = \u2295\n\u03c1\u2208RB(\u03be)\nwtB(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = \u2295\n\u03c1\u2208RA(\u03be|V)\nwtA(\u03be|V , \u03c1)\u2297 F\u03c1(\u03b5) = [[A]] run(\u03be|V ) .\nNow we prove the following statement.\nFor each \u03be \u2208 T\u03a3V\u222a{V } we have [[B]] run(\u03be)\u2297 \u03c7(Tv\u03a3V\u222a{V })(\u03be) = [[e]]V\u222a{V }(\u03be). (14.23)\nFor this, let \u03be \u2208 T\u03a3V\u222a{V } .\nCase (i): Let \u03be not be valid. Then both sides of (14.23) evaluate to 0.\nCase (ii): Let \u03be be valid. Then we obtain\n[[B]]run(\u03be)\u2297 \u03c7(Tv\u03a3V\u222a{V })(\u03be) = [[B]] run(\u03be) (because \u03be is valid)\n= [[A]]run(\u03be|V)\n= [[e]](\u03be|V)\n= [[e]]V\u222a{V }(\u03be) (by Lemma 14.2.1)\nThis finishes the proof of (14.23).\nBy Lemma 14.1.5, we can construct a \u03a3V\u222a{V }-fta A such that L(A) = T v \u03a3V\u222a{V } . Finally, by Theorem\n10.4.3, we can construct a (\u03a3V\u222a{V },B)-wta A \u2032 such that [[A\u2032]]run = [[B]]run\u2297\u03c7(Tv\u03a3V\u222a{V }). Hence [[A \u2032]]run = [[e]]V\u222a{V }.\nNow we proceed by transforming atomic formulas, guarded formulas, and weighted existential quantifications into a wta. (For formulas of the form e1 + e2 we will exploit a closure result.)\nLemma 14.3.5. [FSV12, Lm. 4.5] For every finite sets V of variables and family \u03ba = (\u03bak | k \u2208 N) of mappings \u03bak : (\u03a3V) (k) \u2192 B, we can construct a bu deterministic (\u03a3V ,B)-wta B such that [[H(\u03ba)]] = [[B]].\n298 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nProof. We recall that Free(H(\u03ba)) = V . It is easy to see that [[H(\u03ba)]] = h\u03ba\u2297\u03c7(Tv\u03a3V ). In Example 3.2.17 we have constructed a bu deterministic (\u03a3V ,B)-wta A such that [[A]] = h\u03ba. Then, by Lemma 14.1.5 and by Theorem 10.4.3(2), we can construct a bu deterministic (\u03a3V ,B)-wta B such that [[B]] = h\u03ba\u2297\u03c7(Tv\u03a3V ).\nIn the next lemma we prove that adding a guard to a formula preserves r-recognizability.\nLemma 14.3.6. (cf. [FSV12, Lm. 4.10]) Let \u03d5 \u2208 MSO(\u03a3) and e \u2208 MSO(\u03a3,B). We let U = Free(\u03d5) and V = Free(e). If there exists a (\u03a3V ,B)-wta A such that [[A]]run = [[e]], then we can construct a (\u03a3U\u222aV ,B)-wta B such that [[B]]run = [[\u03d5\u22b2 e]].\nProof. Starting with A, we can apply Lemma 14.3.4 an appropriate number of times; thereby we can construct a (\u03a3U\u222aV ,B)-wta A\n\u2032 such that [[A\u2032]]run = [[e]]U\u222aV . Moreover, by Lemma 14.1.9, we can construct a \u03a3U\u222aV-fta D which recognizes LU\u222aV(\u03d5), i.e., L(D) = LU\u222aV(\u03d5). Then, by Theorem 10.4.3(2), we can construct a (\u03a3U\u222aV ,B)-wta B such that [[B]]run = \u03c7(L(D))\u2297 [[A\u2032]]run. Finally, we can calculate as follows.\n[[\u03d5\u22b2 e]] = \u03c7(LU\u222aV(\u03d5)) \u2297 [[e]]U\u222aV (by (14.10))\n= \u03c7(L(D))\u2297 [[A\u2032]]run = [[B]]run .\nThe next lemma shows that weighted existential quantification preserves r-recognizability.\nLemma 14.3.7. [FSV12, Lm. 4.9] Let e \u2208MSO(\u03a3,B). Then the following two statements hold.\n(1) If V = Free(+x e), U = Free(e), and there exists a (\u03a3U ,B)-wta A with [[A]]run = [[e]], then we can construct a (\u03a3V ,B)-wta B such that [[B]]run = [[+x e]]. (2) If V = Free(+X e), U = Free(e), and there exists a (\u03a3U ,B)-wta A with [[A]]run = [[e]], then we can construct a (\u03a3V ,B)-wta B such that [[B]]run = [[+X e]].\nProof. Proof of (1). Assume that V = Free(+x e), U = Free(e), and there exists a (\u03a3U ,B)-wta A such that [[A]]run = [[e]]. We note that V = U \\ {x}, thus x 6\u2208 V .\nWe define the deterministic (\u03a3V\u222a{x},\u03a3V)-tree relabeling \u03c4 = (\u03c4k | k \u2208 N) such that, for every k \u2208 N,\n\u03c3 \u2208 \u03a3(k), and W \u2286 V \u222a {x} we let \u03c4k((\u03c3,W)) = {(\u03c3,W \\ {x})}.\nThen, starting from the (\u03a3U ,B)-wta A, by Lemma 14.3.4, we can construct a (\u03a3U\u222a{x},B)-wta A \u2032 such that [[A\u2032]]run = [[e]]U\u222a{x}. Since U \u222a {x} = (U \\ {x}) \u222a {x} = V \u222a {x}, we obtain that [[A \u2032]]run = [[e]]V\u222a{x}. By using A\u2032 and Theorem 10.10.1, we can construct a (\u03a3V ,B)-wta which r-recognizes \u03c7(\u03c4)([[e]]V\u222a{x}). By Lemma 14.1.5, we can construct a \u03a3V -fta which recognizes T\nv \u03a3V . By Theorem 10.4.3(2), we can construct a (\u03a3V ,B)-wta B such that [[B]]run = \u03c7(\u03c4)([[e]]V\u222a{x}) \u2297 \u03c7(T v \u03a3V\n). Finally, by Lemma 14.2.6(1), we obtain [[B]]run = [[+x e]].\nProof of (2). Assume that V = Free(+X e), U = Free(e), and there exists a (\u03a3U ,B)-wta A such that [[A]]run = [[e]]. We note that V = U \\ {X}, this X 6\u2208 V .\nWe define the (\u03a3V\u222a{X},\u03a3V)-tree relabeling \u03c4 = (\u03c4k | k \u2208 N) such that, for every k \u2208 N, \u03c3 \u2208 \u03a3 (k), and\nW \u2286 V \u222a {X} we let \u03c4k((\u03c3,W)) = {(\u03c3,W \\ {X})}.\nSimilarly as above, starting from the (\u03a3U ,B)-wtaA, by Lemma 14.3.4, we can construct a (\u03a3U\u222a{X},B)wta A\u2032 such that [[A\u2032]]run = [[e]]U\u222a{X}. Since U \u222a {X} = (U \\ {X}) \u222a {X} = V \u222a {X}, we obtain that [[A\u2032]]run = [[e]]V\u222a{X}. By using A\n\u2032 and Theorem 10.10.1, we can construct a (\u03a3V ,B)-wta B such that [[B]]run = \u03c7(\u03c4)([[e]]V\u222a{X}). Finally, by Lemma 14.2.6(2), we obtain [[B]] run = [[+X e]].\nNow we can prove that definability implies recognizability.\nTheorem 14.3.8. For every e \u2208 MSO(\u03a3,B) and V = Free(e), we can construct a (\u03a3V ,B)-wta B such that [[B]]run = [[e]].\nProof. By induction on (MSO(\u03a3,B),\u227aMSO(\u03a3,B)), we prove the statement of the theorem.\n14.4. ADDING WEIGHTED CONJUNCTION AND UNIVERSAL QUANTIFICATION 299\nI.B.: Let e = H(\u03ba) where \u03ba : \u03a3V \u2192 B for some finite set V of variables. By Lemma 14.3.5, we can construct a bu deterministic (\u03a3V ,B)-wta B such that [[B]] = [[H(\u03ba)]].\nI.S.: Case (a): Let e = (\u03d5 \u22b2 e\u2032) and V = Free(\u03d5 \u22b2 e\u2032). By I.H., we can construct a (\u03a3Free(e\u2032),B)-wta\nA such that [[A]]run = [[e\u2032]]. By Lemma 14.3.6, we can construct a (\u03a3V ,B)-wta B such that [[B]]run = [[e]].\nCase (b): Let e = e1 + e2 and let V = Free(e1 + e2). By I.H., we can construct a (\u03a3Free(e1),B)-wta A1 and a (\u03a3Free(e2),B)-wta A2 such that [[A1]]\nrun = [[e1]] and [[A2]]run = [[e2]]. Starting from A1, we can apply Lemma 14.3.4 an appropriate number of times; thereby we can construct a (\u03a3V ,B)-wta A\u20321 such that [[A\u20321]] run = [[e1]]V . Similarly we can construct a (\u03a3V ,B)-wta A\u20322 such that [[A \u2032 2]]\nrun = [[e2]]V . By Theorem 10.1.1 we can construct a (\u03a3V ,B)-wta B such that [[B]]run = [[A\u20321]] run + [[A\u20322]] run. Then [[B]]run = [[A\u20321]] run + [[A\u20322]] run = [[e1]]V + [[e2]]V = [[e1 + e2]]V .\nCase (c): Let e = +x e\u2032 and let V = Free(+x e\u2032). By I.H., we can construct a (\u03a3Free(e\u2032),B)-wta A such that [[A]]run = [[e\u2032]]. By Lemma 14.3.7(1), we can construct a (\u03a3V ,B)-wta B such that [[B]]run = [[e]].\nCase (d): Let e = +X e\u2032 and let V = Free(+X e\u2032). We can finish the proof as in Case (d), except that we use Lemma 14.3.7(2)."
        },
        {
            "heading": "14.4 Adding weighted conjunction and weighted universal quan-",
            "text": "tification\nIn this section we extend MSO(\u03a3,B) by weighted conjunction, weighted first-order universal quantification, and weighted second-order universal quantification [DG05, DG07, DG09]; the resulting logic is denoted by MSOext(\u03a3,B). Since MSOext(\u03a3,B) is more powerful than run recognizability, we identify a fragment of MSOext(\u03a3,B) which characterizes the set of run recognizable (\u03a3,B)-weighted tree languages, if B is a commutative semiring (cf. Theorem 14.4.11). Roughly speaking, in that fragment of MSOext(\u03a3,B), (a) the weighted first-order universal quantification may only be applied to a recognizable step formula, and (b) the weighted second-order universal quantification is forbidden. The latter restriction corresponds to the restriction (c) of the weighted MSO-logic in [DG05, DG07, DG09] which is discussed in the preface of this chapter. Our restriction (a) is more severe than the corresponding restriction (b) there, because it forbids nesting of weighted first-order universal quantification. In Section 19.8 we will prove that, for each bounded lattice B, the full extended weighted logic MSOext(\u03a3,B) characterizes the set of run recognizable (\u03a3,B)-weighted tree languages (cf. Theorem 19.8.4).\nIn this section, we assume that B is commutative.\n14.4.1 The extended weighted MSO-logic MSOext(\u03a3,B)\nWe define the set of extended MSO formulas over \u03a3 and B, denoted by MSOext(\u03a3,B), by the following EBNF with nonterminal e:\ne ::= H(\u03ba) | (\u03d5\u22b2 e) | (e + e) | (e\u00d7 e) |+x e |+X e |\u00d7x e |\u00d7X e , (14.24) where\n\u2022 there exists a finite set U of variables such that \u03ba = (\u03bak | k \u2208 N) is an N-indexed family of mappings \u03bak : (\u03a3U )\n(k) \u2192 B, \u2022 \u03d5 \u2208MSO(\u03a3).\nFormulas of the form (e1 \u00d7 e2),\u00d7x e, and\u00d7X e are called weighted conjunction, weighted firstorder universal quantification, and weighted second-order universal quantification, respectively. Obviously, MSO(\u03a3,B) \u2282MSOext(\u03a3,B).\nFor each e \u2208 MSOext(\u03a3,B), the set Free(e) of free variables of e and set Bound(e) of bound variables of e are defined in the same way as for MSO(\u03a3,B)-formulas and additionally we have:\n300 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\n\u2022 Free(e1 \u00d7 e2) = Free(e1) \u222a Free(e2) and Bound(e1 \u00d7 e2) = Bound(e1) \u222a Bound(e2), \u2022 Free(\u00d7x e) = Free(e) \\ {x} and Bound(\u00d7x e) = Bound(e) \u222a {x}, and \u2022 Free(\u00d7X e) = Free(e) \\ {X} and Bound(\u00d7X e) = Bound(e) \u222a {X}. As in Section 14.2, in order to perform inductive proofs or to define objects by induction, we will\nconsider the well-founded set\n(MSOext(\u03a3,B),\u227aMSOext(\u03a3,B))\nwhere\u227aMSOext(\u03a3,B) is the binary relation on MSO ext(\u03a3,B) defined as follows. Already in the definition and also in the rest of this chapter, we abbreviate \u227aMSOext(\u03a3,B) by \u227aMSOext . For every e1, e2 \u2208 MSO ext(\u03a3,B), we let e1 \u227aMSOext e2 if e1 is a direct subformula of e2 in the sense of (14.24). Then \u227aMSOext is well-founded, and min\u227aMSOext (MSO ext(\u03a3,B)) is the set of all formulas of the form H(\u03ba).\nBy induction on (MSOext(\u03a3,B),\u227aMSOext), we define the MSO ext(\u03a3,B)-indexed family\n( ([[e]]V | V \u2287 Free(e),V finite) | e \u2208MSO ext(\u03a3, B) )\nas follows, where [[e]]V is a (\u03a3V ,B)-weighted tree language which is called the semantics of e with respect to V .\n\u2022 Let e = H(\u03ba), e = (\u03d5 \u22b2 e\u2032), e = e1 + e2, e =+x e\u2032, or e =+X e\u2032. Let V \u2287 Free(e) be a finite set of variables. The definition of [[e]]V is the same as in Section 14.2.\n\u2022 Let e1, e2 \u2208 MSO ext(\u03a3,B). Let V \u2287 Free(e1 \u00d7 e2) be a finite set of variables. Then, for each\n\u03b6 \u2208 T\u03a3V , we define\n[[e1 \u00d7 e2]]V(\u03b6) =\n{( [[e1]]V(\u03b6) \u2297 [[e2]]V(\u03b6) if \u03b6 \u2208 Tv\u03a3V\n0 otherwise .\n\u2022 Let x be a first-order variable and e \u2208 MSOext(\u03a3,B). Let V \u2287 Free(\u00d7x e) be a finite set of variables. Then, for each \u03b6 \u2208 T\u03a3V , we define\n[[\u00d7x e]]V(\u03b6) = {\u2297 w\u2208pos(\u03b6)[[e]]V\u222a{x}(\u03b6[x 7\u2192 w]) if \u03b6 \u2208 T v \u03a3V\n0 otherwise .\n\u2022 Let X be a second-order variable and e \u2208 MSOext(\u03a3,B). Let V \u2287 Free(\u00d7X e) be a finite set of variables. Then, for each \u03b6 \u2208 T\u03a3V , we define\n[[\u00d7X e]]V(\u03b6) = {\u2297 W\u2286pos(\u03b6)[[e]]V\u222a{X}(\u03b6[X 7\u2192W ]) if \u03b6 \u2208 T v \u03a3V\n0 otherwise .\nWe note that the definitions of [[\u00d7x e]]V and [[\u00d7X e]]V use the fact that \u2297 is commutative (cf. page 21). Next we show that the extension of an assignment does not change the semantics of extended MSO formulas.\nLemma 14.4.1. (cf. Lemma 14.2.1) Let e \u2208 MSOext(\u03a3,B) and let V and W be finite sets of variables with Free(e) \u2286 W \u2286 V . Then for every (\u03be, \u03b7) \u2208 Tv\u03a3V , we have [[e]]V(\u03be, \u03b7) = [[e]]W(\u03be, \u03b7|W).\nProof. We prove the statement by induction on (MSOext(\u03a3,B),\u227aMSOext). The proof is very similar to that of Lemma 14.2.1 and thus it is dropped.\nWe will prove the main theorem of this section (cf. Theorem 14.4.11) by replacing subformulas of a formula in MSOext(\u03a3,B) by equivalent formulas in MSO(\u03a3,B). Next we will formalize this replacement.\nLet \u03d5 be an MSO(\u03a3)-formula and V and W be two first-order variables or two second-order variables. Intuitively, we let \u03d5[V/W ] be the MSO(\u03a3)-formula obtained from \u03d5 by replacing each free occurrence\n14.4. ADDING WEIGHTED CONJUNCTION AND UNIVERSAL QUANTIFICATION 301\nof V by W (similar to \u03b1-conversion in \u03bb-calculus). Formally, we define the MSO(\u03a3)-formula \u03d5[V/W ] by induction on (MSO(\u03a3),\u227aMSO(\u03a3)) (cf. (14.2)) as follows:\nlabel\u03c3(x)[V/W ] =\n{ label\u03c3(W ) if x = V\nlabel\u03c3(x) otherwise edgei(x, y)[V/W ] =    edgei(W, y) if x = V , y 6= V edgei(x,W ) if y = V , x 6= V edgei(W,W ) if x = y = V\nedgei(x, y) otherwise\n(x \u2208 X)[V/W ] =    (W \u2208 X) if x = V (x \u2208W ) if X = V\n(x \u2208 X) otherwise\n(\u00ac\u03d5)[V/W ] = \u00ac(\u03d5[V/W ]) (\u03d51 \u2228 \u03d52)[V/W ] = \u03d51[V/W ] \u2228 \u03d52[V/W ]\n(\u2203x.\u03d5)[V/W ] =\n{ (\u2203x.\u03d5) if x = V\n\u2203x.(\u03d5[V/W ]) otherwise (\u2203X.\u03d5)[V/W ] =\n{ (\u2203X.\u03d5) if X = V\n\u2203X.(\u03d5[V/W ]) otherwise.\nNext by induction on (MSOext(\u03a3,B),\u227aMSOext) we define e[V/W ] for each MSO ext(\u03a3,B)-formula e\nand first-order or second order variables V and W .\nCase (a): Let e = H(\u03ba) and \u03ba = (\u03bak | k \u2208 N) with \u03bak : \u03a3 (k) U \u2192 B. Then\nH(\u03ba)[V/W ] =\n{ H(\u03ba) if V 6\u2208 U\nH(\u03ba\u2032) otherwise,\nwhere, for each k \u2208 N, the mapping \u03ba\u2032k : \u03a3 (k) V \u2192 B is defined as follows: V = (U \\ {V }) \u222a {W} and for every (\u03c3,W) \u2208 \u03a3 (k) V , we have\n\u03ba\u2032k((\u03c3,W)) =\n{ \u03bak((\u03c3,W)) if W 6\u2208 W\n\u03bak ( (\u03c3, (W \\ {W}) \u222a {V }) ) otherwise.\nCase (b): Let e = (\u03d5\u22b2 e\u2032). Then e[V/W ] = (\u03d5[V/W ] \u22b2 e\u2032[V/W ]).\nThe definition of e[V/W ] for the other cases of e is left to the reader.\nWe observe that renaming a bound variable in a formula does not change the semantics of that formula.\nObservation 14.4.2. The following two statements hold.\n(1) Let \u2203V.\u03d5 be an MSO(\u03a3)-formula, where V is a variable, and V be a finite set of variables with Free(\u2203V.\u03d5) \u2286 V . Moreover, let W be a variable of the same type as V with W 6\u2208 V . Then LV(\u2203V.\u03d5) = LV(\u2203W.\u03d5[V/W ]).\n(2) Let QV e be an MSO ext(\u03a3,B)-formula for some Q \u2208 {+,\u00d7}, where V is a variable, and V be a\nfinite set of variables with Free(QV e) \u2286 V . Moreover, let W be a variable of the same type as V with W 6\u2208 V . Then [[QV e]]V = [[QW e[V/W ]]]V .\nMoreover, we formalize three variants of the observation that, for each formula, the replacement of a subformula by an equivalent formula does not change the semantics of the original formula.\nObservation 14.4.3. Let \u03d5 \u2208 MSO(\u03a3) and let V \u2287 Free(\u03d5) be a finite set of variables. Moreover, let \u03c8 be a subformula of \u03d5. Also let \u03c8\u2032 \u2208 MSO(\u03a3) such that Free(\u03c8\u2032) = Free(\u03c8) and L(\u03c8\u2032) = L(\u03c8). Then LV(\u03d5) = LV(\u03d5[\u03c8/\u03c8\n\u2032]), where \u03d5[\u03c8/\u03c8\u2032] is the formula in MSO(\u03a3) obtained from \u03d5 by replacing each occurrence of the subformula \u03c8 by \u03c8\u2032.\n302 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nObservation 14.4.4. Let e \u2208 MSOext(\u03a3,B) and let V \u2287 Free(e) be a finite set of variables. Moreover, let \u03c8 be an MSO(\u03a3)-subformula of e. Also let \u03c8\u2032 \u2208 MSO(\u03a3) such that Free(\u03c8\u2032) = Free(\u03c8) and L(\u03c8\u2032) = L(\u03c8). Then [[e]]V = [[e[\u03c8/\u03c8 \u2032]]]V , where e[\u03c8/\u03c8 \u2032] is the formula in MSOext(\u03a3,B) obtained from e by replacing each occurrence of the subformula \u03c8 by \u03c8\u2032.\nObservation 14.4.5. Let e \u2208 MSOext(\u03a3,B) and let V \u2287 Free(e) be a finite set of variables. Moreover, let t be an MSOext(\u03a3,B) subformula of e. Also let t\u2032 \u2208 MSOext(\u03a3,B) such that Free(t\u2032) = Free(t) and [[t\u2032]] = [[t]]. Then [[e]]V = [[e[t/t \u2032]]]V , where e[t/t \u2032] is the formula in MSOext(\u03a3,B) obtained from e by replacing each occurrence of the subformula t by t\u2032.\nLet e be an MSOext(\u03a3,B)-formula. We say that e is in normal form if Free(e) \u2229 Bound(e) = \u2205.\nNext we show that each MSOext(\u03a3,B)-formula can be transformed into an equivalent one which is in normal form (cf. rectified formula in [Gal87] and [Sch89]).\nLemma 14.4.6. Let e be an MSOext(\u03a3,B)-formula and V be a finite set of variables with Free(e) \u2286 V . We can construct an MSOext(\u03a3,B)-formula e\u2032 such that e\u2032 is in normal form, Free(e) = Free(e\u2032), and [[e]]V = [[e \u2032]]V .\nProof. We obtain e\u2032 by performing an iteration on the following steps (a), (b), and (c).\n(a) If e is already in normal form, then we are ready. Otherwise, let us perform one of the following steps (b) or (c).\n(b) Choose a subformula of e of the form \u03d5 = \u2203V.\u03c8 such that V \u2208 Free(e) \u2229 Bound(e) and Free(e) \u2229 Bound(\u03c8) = \u2205. Then take a variable W of the same type as V with W 6\u2208 Free(e) \u222a Bound(e), and let \u03d5\u2032 = \u2203W.\u03c8[V/W ]. Note that Free(\u03d5\u2032) = Free(\u03d5) and by Observation 14.4.2(1), we have L(\u03d5\u2032) = L(\u03d5). Hence, by Observation 14.4.4, we have [[e]]V = [[e[\u03d5/\u03d5 \u2032]]]V . Then continue at (a) with e[\u03d5/\u03d5 \u2032] instead of e.\n(c) Choose a subformula of e of the form t = QV u for some Q \u2208 {+,\u00d7} such that V \u2208 Free(e) \u2229 Bound(e) and Free(e) \u2229 Bound(u) = \u2205. Then take a variable W of the same type as V with W 6\u2208 Free(e) \u222a Bound(e), and let t\u2032 = QWu[V/W ]. Note that Free(t\u2032) = Free(t) and by Observation 14.4.2(2), we have [[t\u2032]] = [[t]]. Hence, by Observation 14.4.5, we have [[e]]V = [[e[t/t\n\u2032]]]V . Then continue at (a) with e[t/t\u2032] instead of e.\nThe next example shows the usefulness of weighted conjunction and weighted universal first-order quantification as specification tool.\nExample 14.4.7. In this example we show that, for each (\u03a3,B)-weighted local system S (cf. Section 11.1) we can construct a sentence eS \u2208 MSO\next(\u03a3,B) such that (a) [[eS ]] = [[S]] and (b) eS does not contain weighted second-order universal or existential quantification. For the definition of the macro \u3008b\u3009 (with b \u2208 B) we refer to Example 14.2.2. In an obvious way, we extend the syntax of MSOext(\u03a3,B) by allowing that + can combine finitely many formulas (and not just two). Hence, for each finite family (ei | i \u2208 I) of formulas ei \u2208 MSO ext(\u03a3,B) we may write\n+ i\u2208I ei .\nThis formula has the obvious semantics.\nLet S = (g, F ). We construct the sentence eS = e1 \u00d7 e2 in MSO ext(\u03a3,B) where the intuition behind\ne1 and e2 is that they simulate g and F , respectively. Formally, we let\ne1 =\u00d7x ( +\nk\u2208maxrk(\u03a3), f\u2208Fork(\u03a3)(k)\n( \u03d5f (x) \u22b2 \u3008g(f)\u3009\n))\ne2 =+x ( + \u03c3\u2208\u03a3 ( root(x) \u2227 label\u03c3(x)\u22b2 \u3008F (\u03c3)\u3009 ))\n14.4. ADDING WEIGHTED CONJUNCTION AND UNIVERSAL QUANTIFICATION 303\nand, for each fork (\u03c31 \u00b7 \u00b7 \u00b7\u03c3k, \u03c3) \u2208 Fork(\u03a3)(k), the formula \u03d5(\u03c31\u00b7\u00b7\u00b7\u03c3k,\u03c3)(x) in MSO(\u03a3{x}) defined by\n\u03d5(\u03c31\u00b7\u00b7\u00b7\u03c3k,\u03c3)(x) = label\u03c3(x) \u2227 \u2200y. \u2227\ni\u2208[k]\n( edgei(x, y)\u2192 label\u03c3i(y) ) .\nClearly, the subformulas\n+ k\u2208maxrk(\u03a3), f\u2208Fork(\u03a3)(k)\n( \u03d5f (x) \u22b2 \u3008g(f)\u3009 ) and +\n\u03c3\u2208\u03a3\n( root(x) \u2227 label\u03c3(x)\u22b2 \u3008F (\u03c3)\u3009 )\nof e1 and e2, respectively, are recognizable step formulas.\nNow we consider the semantics of eS . The following is easy to see:\nFor every \u03be \u2208 T\u03a3 and w \u2208 pos(\u03be), we have that\n(\u03be, [x 7\u2192 w]) |= \u03d5(\u03c31\u00b7\u00b7\u00b7\u03c3k,\u03c3)(x) iff( \u03be(w) = \u03c3 and \u03be(wi) = \u03c3i for each i \u2208 [rk(\u03be(w))] ) .\n(14.25)\nSince for every \u03be \u2208 T\u03a3 and w \u2208 pos(\u03be), there exists exactly one fork f which occurs in \u03be at w, we can also see the following easily (using (14.25)).\nFor every \u03be \u2208 T\u03a3 and w \u2208 pos(\u03be), we have that\n[[ + k\u2208maxrk(\u03a3),\nf\u2208Fork(\u03a3)(k)\n( \u03d5f (x)\u22b2 \u3008g(f)\u3009 ) ]](\u03be, [x 7\u2192 w]) = g ( (\u03be(w1) \u00b7 \u00b7 \u00b7 \u03be(w rk(\u03be(w))), \u03be(w)) ) . (14.26)\nNow let \u03be \u2208 T\u03a3. Then we can calculate as follows.\n[[e1]](\u03be) = [[\u00d7x . ( +\nk\u2208maxrk(\u03a3), f\u2208Fork(\u03a3)(k)\n( \u03d5f (x)\u22b2 \u3008g(f)\u3009 )) ]](\u03be)\n= \u2297\nw\u2208pos(\u03be)\n[[ ( +\nk\u2208maxrk(\u03a3), f\u2208Fork(\u03a3)(k)\n( \u03d5f (x)\u22b2 \u3008g(f)\u3009 )) ]]{x}(\u03be, [x 7\u2192 w])\n= \u2297\nw\u2208pos(\u03be)\ng ( (\u03be(w1) \u00b7 \u00b7 \u00b7 \u03be(w rk(\u03be(w))), \u03be(w)) ) (by (14.26))\n= g(\u03be) .\nMoreover, we can calculate as follows.\n[[e2]](\u03be) = [[+x . ( + \u03c3\u2208\u03a3 ( root(x) \u2227 label\u03c3(x) \u22b2 \u3008F (\u03c3)\u3009 )) ]](\u03be)\n= \u2295\nw\u2208pos(\u03be) [[+ \u03c3\u2208\u03a3\n( root(x) \u2227 label\u03c3(x)\u22b2 \u3008F (\u03c3)\u3009 ) ]]{x}(\u03be, [x 7\u2192 w])\n= [[\u3008F (\u03be(\u03b5))\u3009]] (because (\u03be, [x 7\u2192 w]) |= (root(x) \u2227 label\u03c3(x)) iff w = \u03b5 and \u03c3 = \u03be(w))\n= F (\u03be(\u03b5)) .\nHence [[e]](\u03be) = [[e1 \u00d7 e2]](\u03be) = [[e1]](\u03be)\u2297 [[e2]](\u03be) = g(\u03be)\u2297 F (\u03be(\u03b5)) = [[S]](\u03be).\n304 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\n14.4.2 The carefully extended weighted MSO-logic MSOcext(\u03a3,B)\nSimilar to the situation of the weighted MSO formulas defined in [DV06] (also cf. [DG05, Ex. 3.4]), there exists an extended MSO formula e \u2208 MSOext(\u03a3,Nat) such that [[e]] is not recognizable. In fact, we can give an atomic formula such that its weighted first-order universal quantification is not recognizable. The same holds for the weighted second-order universal quantification.\nExample 14.4.8. Let \u03a3 = {\u03b3(1), \u03b1(0)}. We consider the semiring Nat of natural numbers and the formula e \u2208 MSOext(\u03a3,Nat), where e =\u00d7xH(\u03ba) and \u03ba = (\u03bak | k \u2208 N) with \u03bak : \u03a3 (k) {x} \u2192 N and \u03bak((\u03c3,U)) = 2 for each (\u03c3,U) \u2208 \u03a3 (k) {x}.\nThen, for each n \u2208 N, we have (using \u220f\nas notation for the generalization of \u00b7 to a finite number of arguments)\n[[\u00d7xH(\u03ba)]](\u03b3n(\u03b1)) = \u220f\nw\u2208pos(\u03b3n(\u03b1))\n[[H(\u03ba)]]{x}(\u03b3 n(\u03b1)[x 7\u2192 w])\n= \u220f\nw\u2208pos(\u03b3n(\u03b1))\nh\u03ba(\u03b3 n(\u03b1)[x 7\u2192 w]) =\n\u220f\nw\u2208pos(\u03b3n(\u03b1))\n2n+1 = 2(n+1) 2 .\nIn Example 13.1.2 we have shown that there does not exist a (\u03a3,Nat)-wta A such that [[A]] = [[e]].\nAlso weighted second-order universal quantification grows too fast for being recognizable; it grows even faster than weighted first-order universal quantification. To see this, we consider the formula f \u2208 MSOext(\u03a3,Nat), where f =\u00d7X H(\u03ba) and \u03ba = (\u03bak | k \u2208 N) with \u03bak : \u03a3 (k) {X} \u2192 N and \u03bak((\u03c3,U)) = 2 for each (\u03c3,U) \u2208 \u03a3 (k) {X}.\nThen, for each n \u2208 N, we have [[\u00d7X H(\u03ba)]](\u03b3n(\u03b1)) = \u220f\nW\u2286pos(\u03b3n(\u03b1))\n[[H(\u03ba)]]{X}(\u03b3 n(\u03b1)[X 7\u2192W ]) =\n\u220f\nW\u2286pos(\u03b3n(\u03b1))\n2n+1 = 2(n+1)\u00b72 n+1 .\nAs in Example 13.1.2, we can prove that there does not exist a (\u03a3,Nat)-wta A such that [[A]] = [[f ]].\nIn order to decrease the computational power, we define the above mentioned fragment of MSOext(\u03a3,B). Formally, we define the set of carefully extended MSO formulas over \u03a3 and B, denoted by MSOcext(\u03a3,B), to be the set of all formulas e \u2208MSOext(\u03a3,B) such that the following two conditions hold:\n\u2022 if e contains a subformula\u00d7x e\u2032, then e\u2032 is a recognizable step formula, i.e., a formula in MSO(\u03a3,B) of the form (\u03d51 \u22b2 \u3008b1\u3009) + . . .+ (\u03d5n \u22b2 \u3008bn\u3009) as specified in (14.13) and\n\u2022 e does not have a subformula of the form\u00d7X e\u2032. Thus, in particular, weighted first-order universal quantification cannot be nested. Moreover, obviously, MSO(\u03a3,B) \u2282MSOcext(\u03a3,B) \u2282MSOext(\u03a3,B).\nAs contribution to the comparison of MSO(\u03a3,B) and the weighted MSO-logics of [DG05, DG07, DG09], we prove that each atomic formula of the form H(\u03ba) can be expressed by a weighted first-order quantification over a recognizable step formula.\nLemma 14.4.9. (cf. [FSV12, Lm. 5.12]) Let U be a finite set of variables and \u03ba = (\u03bak | k \u2208 N) be an N-indexed family with \u03bak : \u03a3 (k) U \u2192 B. Moreover, let x 6\u2208 U . We can construct a recognizable step formula e such that Free(e) = U \u222a {x} and [[H(\u03ba)]] = [[\u00d7x e]].\n14.4. ADDING WEIGHTED CONJUNCTION AND UNIVERSAL QUANTIFICATION 305\nProof. Let \u03a3U = {(\u03c31, U1), . . . , (\u03c3n, Un)}. We define the recognizable step formula\ne = ( \u03d5(\u03c31,U1)({x} \u222a U1)\u22b2 \u3008b(\u03c31,U1)\u3009 ) + . . .+ ( \u03d5(\u03c3n,Un)({x} \u222a Un)\u22b2 \u3008b(\u03c3n,Un)\u3009 )\nwhere, for each i \u2208 [n], we let\n\u2022 b(\u03c3i,Ui) = \u03bark((\u03c3i,Ui)((\u03c3i, Ui)) and \u2022 \u03d5(\u03c3i,Ui)({x} \u222a Ui) is the MSO(\u03a3)-formula\nlabel\u03c3i(x) \u2227 ( \u2227\ny\u2208Ui\n(x = y) ) \u2227 ( \u2227\ny\u2208U\\Ui\n\u00ac(x = y) ) \u2227 ( \u2227\nX\u2208Ui\n(x \u2208 X) ) \u2227 ( \u2227\nX\u2208U\\Ui\n\u00ac(x \u2208 X) ) .\nObviously, for every \u03b6 \u2208 Tv\u03a3U , w \u2208 pos(\u03b6), and (\u03c3i, Ui) \u2208 U , we have\n\u03b6[x 7\u2192 w] \u2208 LU (\u03d5(\u03c3i,Ui)) iff \u03b6(w) = (\u03c3i, Ui) , (14.27)\nand hence (LU (\u03d5(\u03c3i,Ui)) | i \u2208 [n]) is a partitioning of T v \u03a3U\u222a{x} . Thus we have\n[[\u03d5(\u03c3i,Ui)({x} \u222a Ui)\u22b2 \u3008b(\u03c3i,Ui)\u3009]](\u03b6[x 7\u2192 w]) =\n{ b(\u03c3i,Ui) if \u03b6(w) = (\u03c3i, Ui)\n0 otherwise . (14.28)\nLet \u03b6 \u2208 T\u03a3U . If \u03b6 is not valid, then [[H(\u03ba)]](\u03b6) = 0 = [[\u00d7x e]](\u03b6). Now let \u03b6 be valid. Then we have\n[[\u00d7x e]](\u03b6) = \u2297\nw\u2208pos(\u03b6)\n[[e]]U\u222a{x}(\u03b6[x 7\u2192 w])\n= \u2297\nw\u2208pos(\u03b6)\nb\u03b6(w) (by (14.28))\n= \u2297\nw\u2208pos(\u03b6)\n\u03bark(\u03b6(w))(\u03b6(w)) (by definition of b\u03b6(w))\n= [[H(\u03ba)]](\u03b6) (by (2.27))\nIn Lemma 14.4.12 we show how formulas of the form\u00d7x e, where e is a recognizable step formula, can be simulated by a formulas in MSO(\u03a3,B) (cf. t in (14.29)). Here we prove that atomic formulas alone are not powerful enough to simulate recognizable step formulas.\nLemma 14.4.10. For the ranked alphabet \u03a3 = {\u03b1(2), \u03b3(1), \u03b1(0)} we can construct a recognizable step sentence e over \u03a3 and Nat such that [[e]] 6= [[H(\u03ba)]] for any family \u03ba = (\u03bak | k \u2208 N) of mappings \u03bak : \u03a3 (k) \u2192 N.\nProof. By Theorem 10.3.1(A)\u21d2(B) and Lemma 14.2.3(A)\u21d2(B), it is sufficient to construct a crisp deterministic (\u03a3,Nat)-wta A such that [[A]] 6= [[H(\u03ba)]] for any family \u03ba = (\u03bak | k \u2208 N) of mappings \u03bak : \u03a3 (k) \u2192 N.\nWe consider the crisp deterministic (\u03a3,Nat)-wta A constructed in Example 3.2.16. There it was shown that [[A]] = twothree, where the weighted tree language twothree : T\u03a3 \u2192 N is defined by\ntwothree(\u03be) =\n{ 2 if |pos(\u03be)| is even\n3 otherwise\nfor each \u03be \u2208 T\u03a3.\n306 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nWe show by contradiction that A has the desired property. For this, we assume that there is a family \u03ba = (\u03bak | k \u2208 N) of mappings \u03bak : \u03a3(k) \u2192 N with [[H(\u03ba)]] = [[A]]. By definition,\n[[H(\u03ba)]](\u03b3n(\u03b1)) = \u03ba0(\u03b1) \u00b7 (\u03ba1(\u03b3)) n\nfor each n \u2208 N. Since im([[A]]) = {2, 3}, i.e., a finite set, it follows that \u03ba1(\u03b3) = 0 or \u03ba1(\u03b3) = 1. In the first case [[H(\u03ba)]](\u03b3n(\u03b1)) = 0 for each n \u2208 N+. In the second case [[H(\u03ba)]](\u03b3n(\u03b1)) = \u03ba0(\u03b1) for each n \u2208 N. Thus, in both cases, we have [[H(\u03ba)]](\u03b32(\u03b1)) = [[H(\u03ba)]](\u03b3(\u03b1)). This contradicts [[H(\u03ba)]] = [[A]], because [[A]](\u03b32(\u03b1)) = 2 6= 3 = [[A]](\u03b3(\u03b1))."
        },
        {
            "heading": "14.4.3 The main result for MSOcext(\u03a3,B)",
            "text": "In this subsection we prove that the two weighted logics MSO(\u03a3,B) and MSOcext(\u03a3,B) are equivalent (cf. Theorem 14.4.11). This theorem follows directly from Lemmas 14.4.12 and Lemma 14.4.15. For each bounded lattice B, we will prove that even the two weighted logics MSO(\u03a3,B) and MSOext(\u03a3,B) are equivalent (cf. Theorem 19.8.4).\nTheorem 14.4.11. Let \u03a3 be a ranked alphabet and B be a commutative semiring. Moreover, let e \u2208 MSOcext(\u03a3,B) and V \u2287 Free(e) be a finite set of variables. Then we can construct an MSO(\u03a3,B)-formula f such that Free(e) = Free(f) and [[e]]V = [[f ]]V .\nIn the next lemma we get rid of weighted first-order universal quantification. We follow the proof of [FSV12, Lm. 5.10]; in its turn, the construction in the proof of the latter lemma was inspired by the construction in the proof of [DG09, Lm. 5.4].\nLemma 14.4.12. (cf. [FSV12, Lm. 5.10]) Let e \u2208 MSOcext(\u03a3,B) and V \u2287 Free(e) be a finite set of variables. Then we can construct an MSOcext(\u03a3,B)-formula f such that (a) Free(e) = Free(f), (b) [[e]]V = [[f ]]V , and (c) f does not contain a subformula of the form\u00d7x e\u2032.\nProof. If e does not contain a subformula of the form\u00d7x e\u2032, then we can choose f to be e and we are ready. Otherwise, we choose an occurrence of a weighted first-order universal quantification in e. More precisely, let\u00d7x e\u2032 be an occurrence of a subformula of e. By definition of MSOcext(\u03a3,B), the subformula e\u2032 is a recognizable step formula, i.e., there exist n \u2208 N+, b1, . . . , bn \u2208 B, and \u03d51, . . . , \u03d5n \u2208MSO(\u03a3) such that\ne\u2032 = (\u03d51 \u22b2 \u3008b1\u3009) + . . .+ (\u03d5n \u22b2 \u3008bn\u3009) .\nLet Free(\u00d7x e\u2032) = V \u2032. Then Free(e\u2032) \u2286 V \u2032 \u222a {x}. Next we define the formula t by which we will replace the selected occurrence of the subformula\u00d7x e\u2032\nlater. Intuitively, the MSO(\u03a3)-formula (\u2227 i\u2208[n] \u2200x. ( (x \u2208 Xi) \u2194 \u03d5i )) is a part of t and guarantees that, for each i \u2208 [n], the set of positions assigned to Xi is exactly the set of positions for which \u03d5i is true (cf. (14.30)). Formally, we let\nt =+X1 . . .+Xn ((\u2227 i\u2208[n] \u2200x. ( (x \u2208 Xi)\u2194 \u03d5i )) \u22b2H(\u03ba) ) (14.29)\nbe the formula in MSO(\u03a3,B) where\n\u2022 X1, . . . , Xn are second-order variables which do not occur in Free(e) \u222a Bound(e) and \u2022 \u03ba is the N-indexed family (\u03bak | k \u2208 N) of mappings \u03bak : \u03a3 (k) U \u2192 B, where U = V \u2032 \u222a {X1, . . . , Xn},\nsuch that, for each (\u03c3,W) \u2208 \u03a3 (k) U , we define\n\u03bak((\u03c3,W)) = \u2295\ni\u2208[n]:Xi\u2208W\nbi .\n14.4. ADDING WEIGHTED CONJUNCTION AND UNIVERSAL QUANTIFICATION 307\nOn purpose, we use the variable x, which might occur in \u03d5i, also as variable for the universal quantification; thereby we \u201csynchronize\u201d the sequence X1, . . . , Xn with the formulas \u03d51, . . . , \u03d5n. Obviously, Free(t) = V \u2032 and hence Free(\u00d7x e\u2032) = Free(t). Next we analyse the semantics of the MSO(\u03a3)-subformula (\u2227 i\u2208[n] \u2200x.((x \u2208 Xi)\u2194 \u03d5i) ) . Let (\u03be, \u00b5) \u2208 Tv\u03a3V\u2032 and let V \u2032 1 , . . . , V \u2032 n \u2286 pos(\u03be). Obviously, the following equivalence holds:\n(\u03be, \u00b5[X1 7\u2192 V \u2032 1 , . . . , Xn 7\u2192 V \u2032 n]) |= (\u2227 i\u2208[n] \u2200x.((x \u2208 Xi)\u2194 \u03d5i) ) iff (\u2200i \u2208 [n]) : V \u2032i = {w \u2208 pos(\u03be) | (\u03be, \u00b5[x 7\u2192 w]) \u2208 LV\u2032\u222a{x}(\u03d5i)} . (14.30)\nFor every i \u2208 [n], we abbreviate the set {w \u2208 pos(\u03be) | (\u03be, \u00b5[x 7\u2192 w]) \u2208 LV\u2032\u222a{x}(\u03d5i)} by W (\u03be, \u00b5, i).\nNext we prove that\n[[t]] = [[\u00d7x e\u2032]] . (14.31) For this, let (\u03be, \u00b5) \u2208 T\u03a3V\u2032 . If (\u03be, \u00b5) is not valid, then both sides of (14.31) evaluate to 0. Now let (\u03be, \u00b5) \u2208 Tv\u03a3V\u2032 . Then we obtain\n[[t]](\u03be, \u00b5) = \u2295\nV \u20321 ,...,V \u2032 n\u2286pos(\u03be)\n((\u2227 i\u2208[n] \u2200x.((x \u2208 Xi)\u2194 \u03d5i) ) \u22b2H(\u03ba) ) (\u03be, \u00b5[X1 7\u2192 V \u2032 1 , . . . , Xn 7\u2192 V \u2032 n])\n= [[H(\u03ba)]]U (\u03be, \u00b5[X1 7\u2192W (\u03be, \u00b5, 1), . . . , Xn 7\u2192W (\u03be, \u00b5, n)]) (by (14.30))\n= h\u03ba[U U ]((\u03be, \u00b5[X1 7\u2192W (\u03be, \u00b5, 1), . . . , Xn 7\u2192W (\u03be, \u00b5, n)]))\n= h\u03ba((\u03be, \u00b5[X1 7\u2192W (\u03be, \u00b5, 1), . . . , Xn 7\u2192W (\u03be, \u00b5, n)])) = \u2297\nw\u2208pos(\u03be)\n\u03bak ( (\u03be(w), {Xj | w \u2208 W (\u03be, \u00b5, j)}) ) (by (2.27) and the fact that B is commutative)\nwhere k = rk(\u03b6(w)). Let w \u2208 pos(\u03be). Clearly,\n\u03bak((\u03be(w), {Xj | w \u2208 W (\u03be, \u00b5, j)})) = \u2295\ni\u2208[n]: Xi\u2208{Xj |w\u2208W (\u03be,\u00b5,j)}\nbi = \u2295\ni\u2208[n]: w\u2208W (\u03be,\u00b5,i)\nbi\n= \u2295\ni\u2208[n]: (\u03be,\u00b5[x 7\u2192w])\u2208LV\u2032\u222a{x}(\u03d5i)\nbi = \u2295\ni\u2208[n]: (\u03be,\u00b5[x 7\u2192w])\u2208Li\nbi\n= \u2295\ni\u2208[n]\nbi \u2297 \u03c7(Li)((\u03be, \u00b5[x 7\u2192 w])) = [[e \u2032]]V\u2032\u222a{x}(\u03be, \u00b5[x 7\u2192 w]) .\nHence,\n[[t]](\u03be, \u00b5) = \u2297\nw\u2208pos(\u03be)\n[[e\u2032]]V\u2032\u222a{x}(\u03be, \u00b5[x 7\u2192 w]) = [[\u00d7x e\u2032]]V\u2032(\u03be, \u00b5) = [[\u00d7x e\u2032]](\u03be, \u00b5) .\nThis proves that [[t]] = [[\u00d7x e\u2032]]. Then, by Observation 14.4.5, we obtain [[e]]V = [[g]]V where g is obtained from e by replacing the subformula\u00d7x e\u2032 by t. Since t \u2208 MSO(\u03a3,B), we have g \u2208 MSOcext(\u03a3,B). Obviously, g contains one occurrence of a weighted first-order universal quantification less than e.\nIf g does not contain a subformula of the form\u00d7x e\u2032, then we are ready and we can choose f to be g. Otherwise, we proceed as before by starting with g and by replacing one occurrence of a weighted first-order universal quantification. Since each replacement reduces the number of weighted first-order universal quantifications, this procedure will terminate. Since each replacement preserves the semantics, we eventually obtain a formula f with the desired properties.\n308 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nExample 14.4.13. In this example we want to illustrate the construction defined in the proof of Lemma 14.4.12. We consider the string ranked alphabet \u03a3 = {\u03b3(1), \u03b1(0)} and the semiring Nat = (N,+, \u00b7, 0, 1). Moreover, we let e = (\u00d7x label\u03b1(x) \u22b2 \u30082\u3009). Obviously, Free(e) = \u2205; we let V = \u2205.\nThen the formula t in MSO(\u03a3,Nat) (cf. (14.29)) has the following form (with n = 1 and \u03d51 = label\u03b1(x)):\nt =+X1 (( \u2200x. ( (x \u2208 X1)\u2194 label\u03b1(x) )) \u22b2H(\u03ba) ) ,\nwhere \u03ba is the N-indexed family of mappings \u03bak : \u03a3 (k) {X1} \u2192 N such that\n\u2022 \u03ba0((\u03b1, \u2205)) = \u03ba1((\u03b3, \u2205)) =+X1\u2208\u2205 2 = 0 and \u2022 \u03ba0((\u03b1, {X1})) = \u03ba1((\u03b3, {X1}) =+X1\u2208{X1} 2 = 2 .\nFor the tree \u03b3(\u03b1) \u2208 Tv\u03a3\u2205 , we can calculate as follows:\n[[(\u00d7x label\u03b1(x)\u22b2 \u30082\u3009)]]\u2205(\u03b3(\u03b1)) = [[label\u03b1(x) \u22b2 \u30082\u3009]]{x}(\u03b3(\u03b1), [x 7\u2192 1]) \u00b7 [[label\u03b1(x)\u22b2 \u30082\u3009]]{x}(\u03b3(\u03b1), [x 7\u2192 \u03b5])\n= [[\u30082\u3009]]{x}(\u03b3(\u03b1), [x 7\u2192 1]) \u00b7 0 = 2 \u00b7 0 = 0 .\nUsing the above mentioned instance of t, we can calculate as follows:\n[[+X1 (( \u2200x. ( (x \u2208 X1)\u2194 label\u03b1(x) )) \u22b2H(\u03ba) ) ]]\u2205(\u03b3(\u03b1))\n= + W\u2286{\u03b5,1}\n[[ ( \u2200x. ( (x \u2208 X1)\u2194 label\u03b1(x) )) \u22b2H(\u03ba)\ufe38 \ufe37\ufe37 \ufe38\ng\n]]{X1}(\u03b3(\u03b1), [X1 7\u2192W ])\n= [[g]]{X1}(\u03b3(\u03b1), [X1 7\u2192 {\u03b5, 1}]) + [[g]]{X1}(\u03b3(\u03b1), [X1 7\u2192 {1}])\n+ [[g]]{X1}(\u03b3(\u03b1), [X1 7\u2192 {\u03b5}]) + [[g]]{X1}(\u03b3(\u03b1), [X1 7\u2192 \u2205]) .\nDue to (14.30), we have\n(\u03b3(\u03b1), [X1 7\u2192 V \u2032 1 ]) |= ( \u2200x.((x \u2208 X1)\u2194 label\u03b1(x) ) iff V \u20321 = {w \u2208 pos(\u03be) | (\u03b3(\u03b1), [x 7\u2192 w]) \u2208 L{x}(label\u03b1(x))} . (14.32)\nSince V \u20321 = {1}, we can continue as follows:\n[[g]]{X1}(\u03b3(\u03b1), [X1 7\u2192 {\u03b5, 1}]) + [[g]]{X1}(\u03b3(\u03b1), [X1 7\u2192 {1}])\n+ [[g]]{X1}(\u03b3(\u03b1), [X1 7\u2192 {\u03b5}]) + [[g]]{X1}(\u03b3(\u03b1), [X1 7\u2192 \u2205])\n= [[H(\u03ba)]]{X1}(\u03b3(\u03b1), [X1 7\u2192 {1}]) = \u03ba0((\u03b1, {X1}) \u00b7 \u03ba1((\u03b3, \u2205))\n= 2 \u00b7 0 = 0 .\nNow we start to prepare the elimination of weighted conjunction in formulas which do not contain weighted first-order universal quantification. First, for each e1, e2 \u2208 MSO(\u03a3,B) with Free(e1) = U1 and Free(e2) = U2, we define the MSO(\u03a3,B)-formula hp(e1, e2) (where hp stands for Hadamard product) with Free(hp(e1, e2)) = U1 \u222a U2 (cf. proof of [FSV12, Lm. 5.7]).\nFor the inductive definition of hp(e1, e2) we define the well-founded set\n(MSO(\u03a3,B) \u00d7MSO(\u03a3,B),\u227a)\nwhere for every (e\u20321, e \u2032 2), (e1, e2) \u2208MSO(\u03a3,B) we let (e \u2032 1, e \u2032 2) \u227a (e1, e2) if\n\u2022 e\u20321 \u227aMSO(\u03a3,B) e1 (i.e., e \u2032 1 is a direct subformula of e1, cf. Section 14.2)) and e \u2032 2 = e2 or \u2022 e\u20321 = e1 = H(\u03ba) for some N-indexed family \u03ba = (\u03bak | k \u2208 N) and e \u2032 2 \u227aMSO(\u03a3,B) e2.\nClearly, \u227a is well-founded and min\u227a(MSO(\u03a3,B) \u00d7 MSO(\u03a3,B)) is the set of all pairs of the form (H(\u03ba1),H(\u03ba2)) where for each i \u2208 [2], \u03bai = ((\u03bai)k | k \u2208 N) is an N-indexed family of mappings (\u03bai)k : \u03a3 (k) Vi \u2192 B for some finite sets Vi. In Figure 14.3 we illustrate the well-founded order \u227a by means of an example.\nThen we define the MSO(\u03a3,B)-formula hp(e1, e2) by induction on (MSO(\u03a3,B) \u00d7MSO(\u03a3,B),\u227a) as follows.\n(a) Let e1 = H(\u03ba1) and e2 = H(\u03ba2) where for each i \u2208 [2], the members of the N-indexed family\n\u03bai = ((\u03bai)k | k \u2208 N) have the type (\u03bai)k : \u03a3 (k) Ui \u2192 B. Then we define hp(e1, e2) = H(\u03ba), where \u03ba = (\u03bak | k \u2208 N) and for every k \u2208 N we define the mapping \u03bak : \u03a3 (k) U1\u222aU2 \u2192 B for each (\u03c3, V ) \u2208 \u03a3 (k) U1\u222aU2 by \u03bak((\u03c3, V )) = (\u03ba1)k((\u03c3, V \u2229 U1))\u2297 (\u03ba2)k((\u03c3, V \u2229 U2)).\n(b) Let e1 = g1 + g2. We define hp((g1 + g2), e2) = hp(g1, e2) + hp(g2, e2).\n(c) Let e1 =+x g. Then x 6\u2208 U2. We define hp(+x g, e2) =+x hp(g, e2).\n(d) Let e1 =+X g. Then X 6\u2208 U2. We define hp(+X g, e2) =+X hp(g, e2).\n(e) Let e1 = (\u03d5\u22b2 g). We define hp(\u03d5\u22b2 g, e2) = (\u03d5\u22b2 hp(g, e2)).\nIn each of the following cases, let e1 = H(\u03ba1) with \u03ba1 = ((\u03ba1)k | k \u2208 N) and (\u03ba1)k : \u03a3 (k) U1 \u2192 B.\n(f) Let e2 = g1 + g2. We define hp(H(\u03ba1), g1 + g2)) = hp(H(\u03ba1), g1) + hp(H(\u03ba1), g2).\n(g) Let e2 =+x g. Then x 6\u2208 U1. We define hp(H(\u03ba1),+x g) =+x hp(H(\u03ba1), g).\n(h) Let e2 =+X g. Then X 6\u2208 U1. We define hp(H(\u03ba1),+X g) =+X hp(H(\u03ba1), g).\n(i) Let e1 = (\u03d5\u22b2 g). We define hp(H(\u03ba1), \u03d5\u22b2 g) = (\u03d5\u22b2 hp(H(\u03ba1), g)).\nNext we prove that, roughly speaking, e1 \u00d7 e2 and hp(e1, e2) are equivalent, if B is distributive.\nLemma 14.4.14. (cf. [FSV12, Lm. 5.7]) Let B be distributive and let e1, e2 \u2208 MSO(\u03a3,B) with Free(e1) = U1 and Free(e2) = U2 such that e1\u00d7e2 is in normal form. For each finite set V of variables which contains U1 \u222a U2 we have [[e1 \u00d7 e2]]V = [[hp(e1, e2)]]V .\n310 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nProof. We prove by induction on (MSO(\u03a3,B)\u00d7MSO(\u03a3,B),\u227a). In the proof we refer to Cases (a)\u2013(i) of the definition of hp(e1, e2). Let \u03b6 \u2208 Tv\u03a3V .\nLet e1 and e2 be as in Case (a). Then we can calculate as follows:\n[[H(\u03ba1)\u00d7H(\u03ba2)]]V (\u03b6) = [[H(\u03ba1)]]V (\u03b6)\u2297 [[H(\u03ba2)]]V (\u03b6) = h\u03ba1[U1 V](\u03b6)\u2297 h\u03ba2[U2 V](\u03b6)\n= h\u03ba[U1\u222aU2 V](\u03b6) = [[H(\u03ba)]]V (\u03b6) = [[hp(H(\u03ba1),H(\u03ba2))]]V (\u03b6) ,\nwhere the third equality holds because\n\u2297\nw\u2208pos(\u03b6), \u03b6(w)=(\u03c3,V )\n\u03ba1((\u03c3,U1 \u2229 V )\u2297 \u2297\nw\u2208pos(\u03b6), \u03b6(w)=(\u03c3,V )\n\u03ba2((\u03c3,U2 \u2229 V ))\n= \u2297\nw\u2208pos(\u03b6), \u03b6(w)=(\u03c3,V )\n\u03ba1((\u03c3,U1 \u2229 V ))\u2297 \u03ba2((\u03c3,U2 \u2229 V ))\nwhere the latter equality holds because B is commutative.\nLet e1 be as in Case (b). Then our statement holds due to right-distributivity of B.\nLet e1 be as in Case (c). Then\n[[(+x g)\u00d7 e2)]]V (\u03b6) = [[+x g]]V(\u03b6) \u2297 [[e2]]V(\u03b6) = ( \u2295\nw\u2208pos(\u03b6)\n[[g]]V\u222a{x}(\u03b6[x 7\u2192 w]) ) \u2297 [[e2]]V(\u03b6)\n= \u2295\nw\u2208pos(\u03b6)\n( [[g]]V\u222a{x}(\u03b6[x 7\u2192 w])\u2297 [[e2]]V(\u03b6) ) (by right-distributivity)\n= \u2295\nw\u2208pos(\u03b6)\n( [[g]]V\u222a{x}(\u03b6[x 7\u2192 w])\u2297 [[e2]]V\u222a{x}(\u03b6[x 7\u2192 w]) )\n(by Lemma 14.4.1; we note that e1 \u00d7 e2 is in normal form)\n= \u2295\nw\u2208pos(\u03b6)\n( [[g]]V\u222a{x} \u2297 [[e2]]V\u222a{x} ) (\u03b6[x 7\u2192 w])\n= \u2295\nw\u2208pos(\u03b6)\n[[hp(g, e2)]]V\u222a{x}(\u03b6[x 7\u2192 w]) (by I.H.)\n= [[+x hp(g, e2)]]V (\u03b6) (by definition of semantics) = [[hp(+x g, e2)]]V (\u03b6) . (by definition of hp)\nLet e1 be as in Case (d). Then the corresponding equation for hp(+X g, e2) can be verified in a similar way as for hp(+x g, e2).\nLet e1 be as in Case (e). Then\n[[(\u03d5\u22b2 g)\u2297 e2]]V(\u03b6) = [[\u03d5\u22b2 g]]V(\u03b6) \u2297 [[e2]]V(\u03b6) =\n{ [[g]]V(\u03b6)\u2297 [[e2]]V (\u03b6) if \u03b6 \u2208 LV(\u03d5)\n0 otherwise\n=\n{ [[hp(g, e2)]]V(\u03b6) if \u03b6 \u2208 LV(\u03d5)\n0 otherwise (by I.H.)\n= [[\u03d5\u22b2 hp(g, e2)]]V (\u03b6) = [[hp(\u03d5\u22b2 g, e2)]]V(\u03b6) .\nLet e1 and e2 be as in Case (f). Then our statement holds by left-distributivity.\n14.4. ADDING WEIGHTED CONJUNCTION AND UNIVERSAL QUANTIFICATION 311\nLet e1 and e2 be as in Case (g). Then the proof is analogous to the proof of Case (c) except that we use left-distributivity instead of right-distributivity.\nLet e1 and e2 be as in Case (h). Then the proof is analogous to the proof of Case (d) except that we use left-distributivity instead of right-distributivity.\nLet e1 and e2 be as in Case (i). Then the proof is analogous to the proof of Case (e).\nIn Lemma 14.4.14, we assume that e1 \u00d7 e2 is in normal form. We have used this condition in the proof for the case that e1 =+x g (cf. Case (c) of the definition of hp(e1, e2)). More precisely, it is used in the justification of the equality:\n\u2295\nw\u2208pos(\u03b6)\n( [[g]]V\u222a{x}(\u03b6[x 7\u2192 w]) \u2297 [[e2]]V(\u03b6) ) = \u2295\nw\u2208pos(\u03b6)\n( [[g]]V\u222a{x}(\u03b6[x 7\u2192 w])\u2297 [[e2]]V\u222a{x}(\u03b6[x 7\u2192 w]) )\n(14.33) Here we show that, in general, Equation (14.33) is wrong if we drop the condition that ( +x g ) \u00d7 e2 is in normal form. For this we let \u03a3 = {\u03b3(1), \u03b1(0)}, V = {x}, \u03be = \u03b3(\u03b1), \u03b7(x) = \u03b5, \u03b6 = (\u03be, \u03b7) in Tv\u03a3V (i.e., \u03b6 = (\u03b3, {x})((\u03b1, \u2205))), and\n\u2022 \u03ba = (\u03bak | k \u2208 N) with \u03ba1((\u03b3, {x})) = \u03ba0((\u03b1, \u2205)) = 1 and \u03ba1((\u03b3, \u2205)) = \u03ba0((\u03b1, {x})) = 0 and \u2022 \u03bd = (\u03bdk | k \u2208 N) with \u03bd1((\u03b3, {x})) = \u03bd0((\u03b1, \u2205)) = 0 and \u03bd1((\u03b3, \u2205) = \u03bd0((\u03b1, {x})) = 1.\nWe let g = H(\u03bd) and e2 = H(\u03ba). We note that Bound(+x g) \u2229 Free(e2) = {x}, hence Free (( +x g ) \u00d7\ne2 ) \u2229 Free (( +x g ) \u00d7 e2 ) 6= \u2205. We can calculate the left-hand side of (14.33) as follows:\n\u2295\nw\u2208pos(\u03b6)\n( [[g]]V\u222a{x}(\u03b6[x 7\u2192 w])\u2297 [[e2]]V(\u03b6) )\n= \u2295\nw\u2208{\u03b5,1}\n( [[H(\u03bd)]]{x}(\u03b6[x 7\u2192 w])\u2297 [[H(\u03ba)]]{x}(\u03b6) )\n= \u2295\nw\u2208{\u03b5,1}\n( [[H(\u03bd)]]{x}(\u03b6[x 7\u2192 w])\u2297 1 )\n= [[H(\u03bd)]]{x}(\u03b6[x 7\u2192 \u03b5])\u2295 [[H(\u03bd)]]{x}(\u03b6[x 7\u2192 1])\n= [[H(\u03bd)]]{x}((\u03b3, {x})((\u03b1, \u2205))) \u2295 [[H(\u03bd)]]{x}((\u03b3, \u2205)((\u03b1, {x}))) = 0\u2295 1 = 1 .\nAnd we can calculate the right-hand side of (14.33) as follows:\n\u2295\nw\u2208pos(\u03b6)\n( [[g]]V\u222a{x}(\u03b6[x 7\u2192 w]) \u2297 [[H(\u03ba)]]V\u222a{x}(\u03b6[x 7\u2192 w) )\n= \u2295\nw\u2208{\u03b5,1}\n( [[H(\u03bd)]]{x}(\u03b6[x 7\u2192 w])\u2297 [[H(\u03ba)]]{x}(\u03b6[x 7\u2192 w) )\n= ( [[H(\u03bd)]]{x}((\u03b3, {x})((\u03b1, \u2205))) \u2297 [[H(\u03ba)]]{x}((\u03b3, {x})((\u03b1, \u2205))) ) \u2295\n( [[H(\u03bd)]]{x}((\u03b3, \u2205)((\u03b1, {x}))) \u2297 [[H(\u03ba)]]{x}((\u03b3, \u2205)((\u03b1, {x}))) )\n=(0\u2297 1)\u2295 (1\u2297 0) = 0 .\nThus, without the mentioned property, Equation (14.33) does not hold in general.\nIn the next lemma we get rid of weighted conjunction in formulas which do not contain weighted firstorder universal quantification. Here we will need commutativity and distributivity of B. We repeatedly apply Lemma 14.4.14.\nLemma 14.4.15. Let B be distributive and let e \u2208 MSOcext(\u03a3,B) and V \u2287 Free(e) be a finite set of variables. If e does not contain a subformula of the form\u00d7x e\u2032, then there exists an MSO(\u03a3,B)-formula f such that Free(e) = Free(f) and [[e]]V = [[f ]]V .\n312 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nProof. If e does not contain a subformula of the form e1 \u00d7 e2, then e \u2208MSO(\u03a3,B) and we are done and we can choose f = e.\nOtherwise, we choose a subformula e1\u00d7e2 of e with Free(e1) = U1 and Free(e2) = U2 such that e1, e2 \u2208 MSO(\u03a3,B), i.e., neither e1 nor e2 contains a weighted conjunction. Clearly, such a subformula exists. By Lemma 14.4.6, we can construct e\u20321\u00d7e \u2032 2 \u2208 MSO(\u03a3,B) in normal form such that Free(e1\u00d7e2) = Free(e \u2032 1\u00d7e \u2032 2) and [[e1\u00d7e2]] = [[e\u20321\u00d7e \u2032 2]]. By the latter fact and by Lemma 14.4.14, we have Free(e1\u00d7e2) = Free(hp(e \u2032 1, e \u2032 2)) and [[e1 \u00d7 e2]] = [[hp(e\u20321, e \u2032 2)]].\nThen we replace the subformula e1 \u00d7 e2 in e by the MSO(\u03a3,B)-formula hp(e \u2032 1, e \u2032 2). Let e \u2032 be the formula obtained in this way. Obviously, Free(e) = Free(e\u2032) and e\u2032 contains one occurrence of \u00d7 less than e. Moreover, by Observation 14.4.5, we have [[e]]V = [[e \u2032]]V .\nIf e\u2032 does not contain a subformula of the form e\u2032\u20321 \u00d7 e \u2032\u2032 2 , then we are ready, and e \u2032 is the desired formula f \u2208 MSO(\u03a3,B) with Free(e) = Free(f) and [[e]]V = [[f ]]V . Otherwise we repeat the transformation described above by replacing some subformula e\u2032\u20321 \u00d7 e \u2032\u2032 2 . Since, in each step, the number of occurrences of \u00d7 becomes smaller, the iteration of the transformation terminates, and after termination, the result is the desired formula f \u2208 MSO(\u03a3,B) with Free(e) = Free(f) and [[e]]V = [[f ]]V ."
        },
        {
            "heading": "14.4.4 Weighted first-order universal quantification of recognizable step mappings",
            "text": "In Example 14.4.8 we gave an atomic formula such that its weighted first-order universal quantification is not recognizable. Here we show that if the semantics of a weighted MSOext-formula is a recognizable step mapping, then its weighted first-order universal quantification is run recognizable.\nLemma 14.4.16. (cf. [DG05, Lm. 4.2], [DG07, Lm. 4.4], and [DV06, Lm. 5.5]) Let e \u2208 MSOext(\u03a3,B) with U = Free(e). Moreover, let n \u2208 N+, b1, . . . , bn \u2208 B, and \u03a3U\u222a{x}-fta A1, . . . , An such that [[e]]U\u222a{x} =\u2295\nj\u2208[n] bj\u2297\u03c7(L(Aj)). Then we can construct a (\u03a3V ,B)-wta B, where V = Free(\u00d7x e), such that [[B]]run = [[\u00d7x e]].\nProof. Since V = U \\ {x}, we have V \u222a {x} = U \u222a {x}. By Theorem 10.3.1(B)\u21d2(D) we can assume that (L(Aj) | j \u2208 [n]) is a partitioning of T\u03a3V\u222a{x} .\nFirst, for each \u03be \u2208 T\u03a3V , we define the relation \u03bd\u03be \u2286 pos(\u03be)\u00d7 [n] by\n\u03bd\u03be = {(w, j) \u2208 pos(\u03be)\u00d7 [n] | \u03be[x 7\u2192 w] \u2208 L(Aj)} .\nSince (L(Aj) | j \u2208 [n]) is a partitioning of T\u03a3V\u222a{x} , this relation is a mapping \u03bd\u03be : pos(\u03be)\u2192 [n].\nIn order to understand the idea for the construction of B, let us perform a few steps in the calculation of [[\u00d7x e]](\u03be) where \u03be \u2208 T\u03a3V .\n[[\u00d7x e]](\u03be) = \u2297\nw\u2208pos(\u03be)\n[[e]]V\u222a{x}(\u03be[x 7\u2192 w]) = \u2297\nw\u2208pos(\u03be)\n( \u2295\nj\u2208[n]\nbj \u2297 \u03c7(L(Aj)) ) (\u03be[x 7\u2192 w]) = \u2297\nw\u2208pos(\u03be)\nb\u03bd\u03be(w) .\nBefore constructing B, we wish to construct a bu deterministic wta C which computes \u2297\nw\u2208pos(\u03be) b\u03bd\u03be(w);\nas input C receives the information \u03be and \u03bd\u03be. Since C can only read trees (and not pairs of the form (\u03be, \u03bd)), we encode each pair (\u03be, \u03bd) where \u03be \u2208 T\u03a3V and \u03bd : pos(\u03be)\u2192 [n] into one tree. For this purpose, we introduce the new ranked alphabet n\u03a3V by letting\n(n\u03a3V) (k) = \u03a3 (k) V \u00d7 [n] for each k \u2208 N .\nInstead of (n\u03a3V) (k) we write n\u03a3V (k). Moreover, for ((\u03c3, U), j) \u2208 n\u03a3V we also write (\u03c3, U, j).\nNow it is clear that the two sets Tn\u03a3V and T +steps \u03a3V , where T+steps\u03a3V = {(\u03be, \u03bd) | \u03be \u2208 T\u03a3V , \u03bd : pos(\u03be)\u2192 [n]}, are in a one-to-one correspondence. Indeed,\n14.4. ADDING WEIGHTED CONJUNCTION AND UNIVERSAL QUANTIFICATION 313\n\u2022 each tree \u03b6 \u2208 Tn\u03a3V corresponds to the pair (\u03be, \u03bd), where pos(\u03be) = pos(\u03b6) and, for each w \u2208 pos(\u03be), if \u03b6(w) = (\u03c3, U, j), then \u03be(w) = (\u03c3, U) and \u03bd(w) = j and \u2022 each pair (\u03be, \u03bd) \u2208 T+steps\u03a3V corresponds to the tree \u03b6 \u2208 Tn\u03a3V where pos(\u03b6) = pos(\u03be) and, for each w \u2208 pos(\u03b6), we let \u03b6(w) = (\u03be(w), \u03bd(w)).\nDue to this one-to-one correspondence, we can assume that elements of Tn\u03a3V have the form (\u03be, \u03bd) and, vice versa, that each pair (\u03be, \u03bd) with \u03be \u2208 T\u03a3V and \u03bd : pos(\u03be)\u2192 [n] is an element of Tn\u03a3V .\nNow we can turn back to the expression \u2297\nw\u2208pos(\u03be) b\u03bd\u03be(w) above and can be more precise with respect\nto the type and the semantics of C. We will construct a bu deterministic (n\u03a3V ,B)-wta C such that, for each (\u03be, \u03bd) \u2208 Tn\u03a3V , we have\n[[C]]((\u03be, \u03bd)) =\n{\u2297 w\u2208pos(\u03be) b\u03bd\u03be(w) if \u03bd = \u03bd\u03be\n0 otherwise . (14.34)\nFor the time being, let us assume that we have constructed such a C already. Then, by using the deterministic tree relabeling \u03c4 : n\u03a3V \u2192 \u03a3V defined, for each (\u03c3, U, j) by \u03c4((\u03c3, U, j)) = (\u03c3, U), we can continue the calculation as follows: for each \u03be \u2208 T\u03a3V , we have\n\u2297\nw\u2208pos(\u03be)\nb\u03bd\u03be(w) = [[C]]((\u03be, \u03bd\u03be)) = \u2295\n(\u03be,\u03bd)\u2208\u03c4\u22121(\u03be)\n[[C]]((\u03be, \u03bd)) = \u03c7(\u03c4) ( [[C]] ) (\u03be) .\nLastly, by Theorem 10.10.1 (closure of Recrun( ,B) under tree relabelings), we can construct the desired (\u03a3V ,B)-wta B such that [[B]]run = \u03c7(\u03c4) ( [[C]] ) and we have proved the lemma. (We note that, since \u03c4 is overlapping, in general B is not bu deterministic.)\nThus it remains to construct the bu deterministic (n\u03a3V ,B)-wta C such that (14.34) holds. For this purpose we first construct an (unweighted) total and bu deterministic n\u03a3V -fta C such that L(C) = L where\nL = {(\u03be, \u03bd\u03be) | \u03be \u2208 T\u03a3V} .\nAssume that C = (Q\u0303, \u03b4\u0303, F\u0303 ) is such an n\u03a3V -fta. Then we construct the bu deterministic (n\u03a3V ,B)-wta C = (Q\u0303, \u03b4, F ) such that, for every k \u2208 N, (\u03c3, U, j) \u2208 n\u03a3(k), and q1, . . . , qk, q \u2208 Q\u0303, we let\n\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3, U, j), q) =\n{ bj if \u03b4\u0303k(q1 \u00b7 \u00b7 \u00b7 qk, (\u03c3, U, j)) = q\n0 otherwise\nand Fq = 1 if q \u2208 F\u0303 and 0 otherwise. It is obvious that (14.34) holds.\nThus it remains to construct a total and bu deterministic n\u03a3V-fta C such that L(C) = L.\nWe observe the following:\nL = {(\u03be, \u03bd\u03be) | \u03be \u2208 T\u03a3V }\n= {(\u03be, \u03bd) \u2208 Tn\u03a3V | (\u2200j \u2208 [n], w \u2208 pos(\u03be)) : if \u03bd(w) = j, then \u03be[x\u2192 w] \u2208 L(Aj)} = \u22c2\nj\u2208[n]\n{(\u03be, \u03bd) \u2208 Tn\u03a3V | (\u2200w \u2208 pos(\u03be)) : if \u03bd(w) = j, then \u03be[x\u2192 w] \u2208 L(Aj)} .\nThus, due to Theorems 2.13.3(2) and 2.13.2, it suffices to construct, for each j \u2208 [n], a total and bu deterministic n\u03a3V-fta Cj such that L(Cj) = Lj where\nLj = {(\u03be, \u03bd) \u2208 Tn\u03a3V | (\u2200w \u2208 pos(\u03be)) : if \u03bd(w) = j, then \u03be[x\u2192 w] \u2208 L(Aj)} .\nLet j \u2208 [n]. The idea behind the construction of Cj follows the one in the proof of [DG07, Lm. 4.4] and it is roughly described as follows. On an input tree \u03b6 = (\u03be, \u03bd), the n\u03a3V -fta Cj simulates the work of\n314 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nAj on \u03be and, whenever a position w of \u03b6 is encountered for which \u03bd(w) = j holds, then, additionally, Cj splits off a copy of Aj ; this copy behaves as if at w the x would occur (or, in other words: as if Aj would have \u03be[x 7\u2192 w] as input tree). Moreover, since we have to guarantee that the placement of x is done at most once in \u03be, we maintain a bit d in every state of Cj which indicates whether the x was placed (d = 1) or not (d = 0).\nIn the sequel, we will reuse the standard notations \u03b4, F , Q\u0303, \u03b4\u0303, and F\u0303 , which occurred already in the specification of C and C, for other purposes. This will be harmless because below we will not deal with C and C anymore.\nFormally, let Aj = (Q, \u03b4, F ) be the \u03a3V\u222a{x}-fta given in the statement of the lemma. By Theorem 2.13.2, we may assume that Aj is total and bu deterministic. We construct the total and bu deterministic n\u03a3V -fta Cj = (Q\u0303, \u03b4\u0303, F\u0303 ), where\n\u2022 Q\u0303 = P(Q\u00d7 {0, 1}),\n\u2022 F\u0303 = {P \u2286 Q\u00d7 {0, 1} | P \u2229 (Q \u00d7 {1}) \u2286 F \u00d7 {1}}, and\n\u2022 \u03b4\u0303 is defined such that, for every k \u2208 N, (\u03c3, U, l) \u2208 n\u03a3 (k) V , and P1, . . . , Pk \u2208 Q\u0303, we let\n\u03b4\u0303k(P1 \u00b7 \u00b7 \u00b7Pk, (\u03c3, U, l)) = P where P =\n{ P \u2032 if l 6= j\nP \u2032 \u222a P \u2032\u2032 otherwise\nand\nP \u2032 = {( \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, (\u03c3, U)),+i\u2208[k] di ) | (\u2200i \u2208 [k]) : (pi, di) \u2208 Pi and +i\u2208[k] di \u2264 1 }\nand\nP \u2032\u2032 = {( \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, (\u03c3, U \u222a {x})), 1 ) | (\u2200i \u2208 [k]) : (pi, 0) \u2208 Pi } .\nSince Aj is total and bu deterministic, the states \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, (\u03c3, U)) and \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, (\u03c3, U \u222a {x})) are defined. Obviously, P \u2032 formalizes the propagation of the bit value 0 if+i\u2208[k] di = 0, and the propagation of the bit value 1 if +i\u2208[k] di = 1. If l = j, then additionally to this propagation, Cj can change from the bit vector (0, . . . , 0) to the bit value 1, thereby placing the x to this position; the union with P \u2032\u2032 can be described as \u201csplitting off a new copy of Aj\u201d. Also it is clear that Cj is total and bu deterministic. Now we will show that Cj recognizes Lj .\nSince Aj and Cj are total and bu deterministic, for each (\u03be, \u03bd) \u2208 Tn\u03a3V and w \u2208 pos(\u03be), the sets of valid runs RvAj (\u03be), R v Aj (\u03be[x\u2192 w]), and RvCj ((\u03be, \u03bd)) are singletons. We denote these runs by letting\nRvAj (\u03be) = {\u03c1\u03be}, R v Aj (\u03be[x\u2192 w]) = {\u03c1\u03be[x\u2192w]}, and R v Cj ((\u03be, \u03bd)) = {\u03c1(\u03be,\u03bd)} .\nBy induction on Tn\u03a3V , we prove the following statement.\nFor each (\u03be, \u03bd) \u2208 Tn\u03a3V , we have \u03c1(\u03be,\u03bd)(\u03b5) = {(\u03c1\u03be(\u03b5), 0)} \u222a {(\u03c1\u03be[x\u2192w](\u03b5), 1) | w \u2208 pos(\u03be), \u03bd(w) = j} . (14.35)\nLet \u03b6 = (\u03c3, U, l)(\u03b61, . . . , \u03b6k) be in Tn\u03a3V with \u03b6 = (\u03be, \u03bd) and \u03b6i = (\u03bei, \u03bdi) for every i \u2208 [k]. Thus \u03be = (\u03c3, U)(\u03be1, . . . , \u03bek). By I.H., (14.35) holds for \u03b61, . . . , \u03b6k. First we prove that\n{( \u03b4k(p1 . . . pk, (\u03c3, U)),+i\u2208[k] di ) | (\u2200i \u2208 [k]) : (pi, di) \u2208 \u03c1(\u03bei,\u03bdi)(\u03b5) and +i\u2208[k] di \u2264 1 }\n= {(\u03c1\u03be(\u03b5), 0)} \u222a {(\u03c1\u03be[x\u2192uw](\u03b5), 1) | u \u2208 [k], w \u2208 pos(\u03beu), and \u03bdu(w) = j} (14.36)\nas follows: {( \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, (\u03c3, U)),+i\u2208[k] di ) | (\u2200i \u2208 [k]) : (pi, di) \u2208 \u03c1(\u03bei,\u03bdi)(\u03b5) and +i\u2208[k] di \u2264 1 }\n14.4. ADDING WEIGHTED CONJUNCTION AND UNIVERSAL QUANTIFICATION 315\n= {( \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, (\u03c3, U)),+i\u2208[k] di ) | (\u2200i \u2208 [k]) :\n[ (pi, di) = (\u03c1\u03bei(\u03b5), 0) or (pi, di) = (\u03c1\u03bei[x\u2192w](\u03b5), 1), w \u2208 pos(\u03bei), \u03bdi(w) = j ] and +i\u2208[k] di \u2264 1\n}\n(by I.H.)\n= {( \u03b4k ( \u03c1\u03be1(\u03b5) \u00b7 \u00b7 \u00b7 \u03c1\u03bek(\u03b5), (\u03c3, U) ) , 0 )}\n\u222a {( \u03b4k ( \u03c1\u03be1(\u03b5) \u00b7 \u00b7 \u00b7 \u03c1\u03beu[x\u2192w](\u03b5) \u00b7 \u00b7 \u00b7 \u03c1\u03bek(\u03b5), (\u03c3, U) ) , 1 ) | u \u2208 [k], w \u2208 pos(\u03beu), \u03bdu(w) = j }\n= {(\u03c1\u03be(\u03b5), 0)} \u222a {( \u03c1\u03be[x\u2192uw](\u03b5), 1 ) | u \u2208 [k], w \u2208 pos(\u03beu), \u03bdu(w) = j } .\nThis finishes the proof of (14.36). Now we can complete the proof of (14.35).\nCase (i): Let l 6= j. Then\n\u03c1(\u03be,\u03bd)(\u03b5) = \u03b4\u0303k(\u03c1(\u03be,\u03bd)(1) . . . \u03c1(\u03be,\u03bd)(k), (\u03c3, U, l)) = \u03b4\u0303k(\u03c1(\u03be1,\u03bd1)(\u03b5) . . . \u03c1(\u03bek,\u03bdk)(\u03b5), (\u03c3, U, l))\n= {( \u03b4k ( p1 . . . pk, (\u03c3, U) ) ,+i\u2208[k] di ) | (\u2200i \u2208 [k]) : (pi, di) \u2208 \u03c1(\u03bei,\u03bdi)(\u03b5) and +i\u2208[k] di \u2264 1 }\n= {(\u03c1\u03be(\u03b5), 0)} \u222a {(\u03c1\u03be[x\u2192uw](\u03b5), 1) | u \u2208 [k], w \u2208 pos(\u03beu), \u03bdu(w) = j} (by (14.36))\n= {(\u03c1\u03be(\u03b5), 0)} \u222a {(\u03c1\u03be[x\u2192w](\u03b5), 1) | w \u2208 pos(\u03be), \u03bd(w) = j} . (because \u03bd(\u03b5) = l 6= j)\nCase (ii): Let l = j. Then\n\u03c1(\u03be,\u03bd)(\u03b5) = \u03b4\u0303k(\u03c1(\u03be1,\u03bd1)(\u03b5) . . . \u03c1(\u03bek,\u03bdk)(\u03b5), (\u03c3, U, l))\n= {( \u03b4k(p1 . . . pk, (\u03c3, U)),+i\u2208[k] di ) | (\u2200i \u2208 [k]) : (pi, di) \u2208 \u03c1(\u03bei,\u03bdi)(\u03b5) and +i\u2208[k] di \u2264 1 }\n\u222a {(\u03b4k(\u03c1\u03be1(\u03b5) . . . \u03c1\u03bek(\u03b5), (\u03c3, U \u222a {x})), 1)} (by definition of \u03b4\u0303 and (14.36) for reducing P \u2032\u2032)\n= {(\u03c1\u03be(\u03b5), 0)} \u222a {(\u03c1\u03be[x\u2192uw](\u03b5), 1) | u \u2208 [k], w \u2208 pos(\u03beu), \u03bdu(w) = j} \u222a {(\u03c1\u03be[x\u2192\u03b5](\u03b5), 1)}\n(by (14.36) and definition of run)\n= {(\u03c1\u03be(\u03b5), 0)} \u222a {(\u03c1\u03be[x\u2192w](\u03b5), 1) | w \u2208 pos(\u03be), \u03bd(w) = j} .\nThis finishes the proof of (14.35).\nFinally, let (\u03be, \u03bd) \u2208 Tn\u03a3V . Then we can calculate as follows.\n(\u03be, \u03bd) \u2208 Lj iff (\u2200w \u2208 pos(\u03be)) : \u03bd(w) = j implies \u03be[x\u2192 w] \u2208 L(Aj)\niff (\u2200w \u2208 pos(\u03be)) : \u03bd(w) = j implies \u03c1\u03be[x\u2192w](\u03b5) \u2208 F\niff {(\u03c1\u03be[x 7\u2192w](\u03b5), 1) | w \u2208 pos(\u03be), \u03bd(w) = j} \u2286 F \u00d7 {1}\niff \u03c1(\u03be,\u03bd)(\u03b5) \u2208 F\u0303 (by (14.35))\niff (\u03be, \u03bd) \u2208 L(Cj) .\nHence L(Cj) = Lj , and this finishes the proof of the lemma.\nFinally, we point out the close relationship between Lemma 14.4.16 and Lemma 14.4.12: both show how to eliminate weighted first-order universal quantification. The difference is that in Lemma 14.4.16 we end up in a wta, whereas in Lemma 14.4.12 we end up in an MSO(\u03a3,B)-formula.\n316 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM"
        },
        {
            "heading": "14.5 Relationship between a decomposition theorem of wta and",
            "text": "B-E-T\u2019s theorem\nIn this final section we want to show a strong relationship between the following two results which we have proved already:\n(1) the decomposition of a (\u03a3,B)-wta A (cf. Theorem 11.3.1(A) \u21d2 (B), roughly): we can construct \u03c4 , (G,H), \u0398, and \u03ba such that, for each \u03be \u2208 T\u03a3: [[A]]run(\u03be) = hM(\u0398,\u03ba)(\u03c4 \u22121(\u03be) \u2229 L(G,H)),\n(2) the definability of [[A]]run for each (\u03a3,B)-wta A (cf. Theorem 14.3.2): we can construct a sentence e \u2208 MSO(\u03a3,B) such that [[e]] = [[A]]run.\nWe will show that (1) can be used to prove (2) (cf. Theorem 14.5.2) and vice versa (cf. Theorem 14.5.4). Thus Theorem 14.5.2 can be seen as an alternative proof of \u201cr-recognizable implies definable\u201d (cf. Subsection 14.5.1); also, Theorem 14.5.4 can be seen as an alternative proof of the decomposition result Theorem 11.3.1(A) \u21d2 (B) (cf. Subsection 14.5.2).\nThis section elaborates the ideas of [HVD19, Sec. 7.5] for the particular case of the trivial storage type and strong bimonoids as weight algebras."
        },
        {
            "heading": "14.5.1 Alternative proof of \u201cr-recognizable implies definable\u201d",
            "text": "We start with an auxiliary lemma which states that the set of definable weighted tree languages is closed under tree relabelings. Actually, we have proved this result already: each definable weighted tree language is r-recognizable (by Theorem 14.3.8), r-recognizable weighted tree languages are closed under tree relabelings (cf. Theorem 10.10.1), and each r-recognizable weighted tree language is definable (by Theorem 14.3.2). But we do not want to use Theorem 14.3.2 for this closure result. So we show a proof with a direct construction.\nEssentially the next lemma has been proved in [Her17, Lm. 15] and [Her20a, Lm. 5.3.2]. We follow this proof, but we mention that the notion of \u201cdefinable\u201d in [Her17] and [Her20a] refers to the weighted logic in [DG05, DV06], and this is different from the one in the present chapter.\nLemma 14.5.1. Let \u0398 be a ranked alphabet, e \u2208 MSO(\u0398,B) be a sentence, and \u03c4 = (\u03c4k | k \u2208 N) be a (\u0398,\u03a3)-tree relabeling. Then we can construct a sentence f \u2208 MSO(\u03a3,B) such that [[f ]] = \u03c7(\u03c4)([[e]]).\nProof. Let (\u03b81, . . . , \u03b8n) be an arbitrary, but fixed enumeration of \u0398. For each i \u2208 [n], we let ki = rk\u0398(\u03b8i). Moreover, we let V = {X\u03b8 | \u03b8 \u2208 \u0398} be a set of second-order variables. The idea is\n\u2022 to code, for each \u03b6 \u2208 T\u03a3, each preimage \u03be \u2208 \u03c4 \u22121(\u03b6) as a tree in T\u03a3V where the second order variable\nX\u03b8 represents the symbol \u03b8 \u2208 \u0398, and \u2022 to evaluate e\u2032 on \u03be where e\u2032 is obtained from e by replacing each subformula of the form label\u03b8(x) by (x \u2208 X\u03b8).\nFormally, we construct the MSO(\u03a3,B)-formula\nf = ( +X\u03b81 \u00b7 \u00b7 \u00b7+X\u03b8n (\u03c8part \u2227 \u03c8relab)\u22b2 e \u2032 )\nwhere\n\u2022 \u03c8part = \u2200x. (\u2228\ni\u2208[n] ( (x \u2208 X\u03b8i) \u2227 \u2227 j\u2208[n]: i6=j \u00ac(x \u2208 X\u03b8j ) )) ,\n\u2022 \u03c8relab = \u2200x. (\u2227\ni\u2208[n] ( \u00ac(x \u2208 X\u03b8i) \u2228 label\u03c4ki (\u03b8i)(x) )) , and\n\u2022 e\u2032 is obtained from e by replacing each subformula of the form label\u03b8(x) by (x \u2208 X\u03b8).\n14.5. RELATIONSHIP BETWEEN DECOMPOSITIONS AND B-E-T\u2019S THEOREM 317\nWe note that \u03c8part and \u03c8relab are in MSO(\u03a3) and e \u2032 is in MSO(\u03a3,B). Moreover, Free(\u03c8part) = Free(\u03c8relab) = V and Free(e\u2032) \u2286 V , hence the formula f is a sentence.\nFirst we analyse the semantics of \u03c8part and \u03c8relab. The following two statements are obvious:\nfor every \u03b6 \u2208 T\u03a3 and \u03b7 \u2208 \u03a6\u03b6,V : (\u03b6, \u03b7) |= \u03c8part iff\n{\u03b7(X\u03b81), . . . , \u03b7(X\u03b8n)} is a partitioning of pos(\u03b6) (14.37)\nand\nfor every \u03b6 \u2208 T\u03a3 and \u03b7 \u2208 \u03a6\u03b6,V : (\u03b6, \u03b7) |= \u03c8relab iff\n(\u2200w \u2208 pos(\u03b6), i \u2208 [n]) : (w \u2208 \u03b7(X\u03b8i))\u2192 (\u03b6(w) \u2208 \u03c4ki(\u03b8i)) . (14.38)\nIn the following, for every \u03b6 \u2208 T\u03a3 and U1, . . . , Un \u2286 pos(\u03b6), we abbreviate the V-assignment [X\u03b81 7\u2192 U1, . . . , X\u03b8n 7\u2192 Un] for \u03b6 by [X\u03b8i 7\u2192 Ui | i \u2208 [n]]. Then, putting (14.37) and (14.38) together, we obtain the statement:\nfor every \u03b6 \u2208 T\u03a3 and \u03b7 \u2208 \u03a6\u03b6,V : (\u03b6, \u03b7) |= (\u03c8part \u2227 \u03c8relab) iff\n(\u2203\u03be \u2208 T\u0398) : (\u03b6 \u2208 \u03c4(\u03be)) \u2227 (\u03b7 = [X\u03b8i 7\u2192 pos\u03b8i(\u03be) | i \u2208 [n]]) . (14.39)\nWe note that pos(\u03b6) = pos(\u03be). Moreover, by construction of e\u2032, we have\nfor every \u03b6 \u2208 T\u03a3 and \u03be \u2208 \u03c4 \u22121(\u03b6) : [[e]](\u03be) = [[e\u2032]](\u03b6, [X\u03b8i 7\u2192 pos\u03b8i(\u03be) | i \u2208 [n]]) . (14.40)\nNow we prove that [[f ]] = \u03c7(\u03c4)(r). Let \u03b6 \u2208 T\u03a3. Then\n[[f ]](\u03b6)\n= [[+X\u03b81 \u00b7 \u00b7 \u00b7+X\u03b8n (\u03c8part \u2227 \u03c8relab)\u22b2 e \u2032]](\u03b6) = \u2295\nW1,...,Wn\u2286pos(\u03b6)\n[[(\u03c8part \u2227 \u03c8relab)\u22b2 e \u2032]](\u03b6, [X\u03b8i 7\u2192Wi | i \u2208 [n]])\n=\n{\u2295 W1,...,Wn\u2286pos(\u03b6) [[e\u2032]](\u03b6, [X\u03b8i 7\u2192 Wi | i \u2208 [n]]) if (\u03b6, [X\u03b8i 7\u2192Wi | i \u2208 [n]]) |= (\u03c8part \u2227 \u03c8relab)\n0 otherwise\n= \u2295\n\u03be\u2208\u03c4\u22121(\u03b6)\n[[e\u2032]](\u03b6, [X\u03b8i 7\u2192 pos\u03b8i(\u03be) | i \u2208 [n]]) (by (14.39))\n= \u2295\n\u03be\u2208\u03c4\u22121(\u03b6)\n[[e]](\u03be) (by (14.40))\n= \u03c7(\u03c4)([[e]])(\u03b6) (by (2.30) and the fact that \u03c4\u22121(\u03b6) is finite)\nNow we can show the alternative proof of the fact that r-recognizable implies definable.\nTheorem 14.5.2. For each (\u03a3,B)-wta A, we can construct a sentence f \u2208 MSO(\u03a3,B) such that [[f ]] = [[A]]run.\nProof. By Theorem 11.3.1(A) \u21d2 (B), we can construct a ranked alphabet \u0398, a deterministic (\u0398,\u03a3)-tree relabeling \u03c4 , a \u0398-local system (K,H), and a family \u03ba = (\u03bak | k \u2208 N) of mappings \u03bak : \u0398(k) \u2192 B such that, for each \u03be \u2208 T\u03a3, we have [[A]]run(\u03be) = hM(\u0398,\u03ba)(\u03c4 \u22121(\u03be) \u2229 L(K,H)). By Observation 2.10.1 we have\n[[A]]run(\u03be) = \u03c7(\u03c4)(\u03c7(L(K,H)) \u2297 hM(\u0398,\u03ba)) . (14.41)\n318 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nBy Corollary 11.2.4, we can construct a bu deterministic \u03a3-fta A such that L(K,H) = L(A). By Lemma 14.1.4, we can construct a sentence \u03d5 \u2208 MSO(\u0398) such that L(A) = L(\u03d5). Then\n\u03c7(L(K,H))\u2297 hM(\u0398,\u03ba) = \u03c7(L(A))\u2297 hM(\u0398,\u03ba) = \u03c7(L(\u03d5))\u2297 hM(\u0398,\u03ba)\n= \u03c7(L(\u03d5))\u2297 [[H(\u03ba)]] (because H(\u03ba) is a sentence)\n= [[\u03d5\u22b2H(\u03ba)]] . (by (14.10))\nBy Lemma 14.5.1, we can construct a sentence f \u2208 MSO(\u03a3,B) such that [[f ]] = \u03c7(\u03c4)([[\u03d5 \u22b2 H(\u03ba)]]). Finally, by (14.41), we obtain [[f ]] = [[A]]run."
        },
        {
            "heading": "14.5.2 Alternative proof of the decomposition Theorem 11.3.1(A) \u21d2 (B)",
            "text": "The alternative proof uses the fact that, for each (\u03a3,B)-wta A, we can construct a sentence e \u2208 MSO(\u03a3,B) such that [[A]]run = [[e]] (cf. Theorem 14.3.2) and two easy technical lemmas. The first lemma claims that the set of models of the MSO(\u03a3)-formula \u03d5 in (14.19) is a local tree language.\nLemma 14.5.3. Let A = (Q, \u03b4, F ) be a root weight normalized (\u03a3,B)-wta with supp(F ) = {qf} and U = \u22c3 (Qk \u00d7 Q | k \u2208 N such that rk\u22121(k) 6= \u2205). Moreover, let \u03d5 be the MSO(\u03a3)-formula \u03d5 in (14.19). Then we can construct a \u03a3U -local system (G,H) such that L(G,H) = LU (\u03d5).\nProof. We define the \u03a3U -local system (G,H) such that G is the set of all forks\n( (\u03c31, {(w1, q1)}) \u00b7 \u00b7 \u00b7 (\u03c3k, {(wk, qk)}), (\u03c3, {(w, q)}) )\nin Fork(\u03a3U ) such that\n\u2022 \u03c3 \u2208 \u03a3(k) and \u03c31, . . . , \u03c3k \u2208 \u03a3 for some k \u2208 N, \u2022 q, q1, . . . , qk \u2208 Q, and \u2022 w = q1 \u00b7 \u00b7 \u00b7 qk and for each i \u2208 [k] we have wi \u2208 Qrk(\u03c3i).\nMoreover, H = {(\u03c3, {(w, qf )}) | k \u2208 N, \u03c3 \u2208 \u03a3(k), w \u2208 Qk}. Then it is easy to see that L(G,H) = LU(\u03d5).\nNow we can give an alternative proof of Theorem 11.3.1(A)\u21d2(B).\nTheorem 14.5.4. Let A be a (\u03a3,B)-wta. Then we can construct\n\u2022 a ranked alphabet \u0398, \u2022 a deterministic (\u0398,\u03a3)-tree relabeling \u03c4 , \u2022 a \u0398-local system (G,H), and \u2022 a family \u03ba = (\u03bak | k \u2208 N) of mappings \u03bak : \u0398 (k) \u2192 B\nsuch that, for each \u03be \u2208 T\u03a3, the following holds: [[A]]run(\u03be) = hM(\u0398,\u03ba)(\u03c4 \u22121(\u03be) \u2229 L(G,H)).\nProof. LetA = (Q, \u03b4, F ). By Theorem 7.3.1 we can assume thatA is root weight normalized, i.e., supp(F ) contains exactly one element qf and F (qf ) = 1.\nWe define U = \u22c3 (Qk \u00d7 Q | k \u2208 N such that rk\u22121(k) 6= \u2205) and \u0398 = \u03a3U . We recall the MSO(\u03a3,B)-\nformula defined in (14.22): e =+X1 \u00b7 \u00b7 \u00b7+Xn(\u03d5\u22b2H(\u03ba)) and \u03ba = (\u03bak | k \u2208 N) with \u03bak : (\u03a3U )(k) \u2192 B. By the proof of Theorem 14.3.2, we have [[A]]run = [[e]].\nFor each i \u2208 [n], we consider the subformula\nei =+Xi \u00b7 \u00b7 \u00b7+Xn(\u03d5\u22b2H(\u03ba)) .\n14.5. RELATIONSHIP BETWEEN DECOMPOSITIONS AND B-E-T\u2019S THEOREM 319\nObviously, Free(ei) = {X1, . . . , Xi\u22121} and Xi 6\u2208 {X1, . . . , Xi\u22121}. Thus we can apply Lemma 14.2.6(2) (with V = Free(ei)) and thereby construct the deterministic (\u03a3{X1,...,Xi},\u03a3{X1,...,Xi\u22121})-tree relabeling \u03c4i such that\n[[+Xi \u00b7 \u00b7 \u00b7+Xn(\u03d5\u22b2 H(\u03ba))]]{X1,...,Xi\u22121} = \u03c7(\u03c4i) ( [[+Xi+1 \u00b7 \u00b7 \u00b7+Xn(\u03d5\u22b2H(\u03ba))]]{X1,...,Xi} ) .\nHence, by the n-fold application of Lemma 14.2.6(2), we can construct deterministic tree relabelings \u03c41, . . . , \u03c4n such that\n[[e]] = [[+X1 \u00b7 \u00b7 \u00b7+Xn(\u03d5\u22b2H(\u03ba))]] = \u03c7(\u03c41) ( . . . \u03c7(\u03c4n)([[\u03d5 \u22b2H(\u03ba)]]U ) . . . ) .\nThen we construct the deterministic tree relabeling \u03c4 such that \u03c4 = \u03c41\u25e6\u0302 . . . \u25e6\u0302\u03c4n (cf. Section 2.9) and, by Theorem 2.9.6, we have\n\u03c7(\u03c41) ( . . . \u03c7(\u03c4n)([[\u03d5 \u22b2H(\u03ba)]]U ) . . . ) = \u03c7(\u03c4) ( [[\u03d5\u22b2H(\u03ba)]]U ) .\nNow let \u03be \u2208 T\u03a3. We can calculate as follows (where we abbreviate the \u0398-algebra homomorphism hM(\u0398,\u03ba) by h\u03ba).\n\u03c7(\u03c4) ( [[\u03d5\u22b2H(\u03ba)]]U ) (\u03be) = \u03c7(\u03c4) ( \u03c7(LU(\u03d5)) \u2297 [[H(\u03ba)]]U ) (\u03be) (by (14.10))\n= \u03c7(\u03c4) ( \u03c7(LU(\u03d5)) \u2297 h\u03ba[U U ] \u2297 \u03c7(T v \u03a3U ) ) (\u03be) (by definition of [[H(\u03ba)]]U ) = \u03c7(\u03c4) ( \u03c7(LU(\u03d5)) \u2297 h\u03ba \u2297 \u03c7(T v \u03a3U ) ) (\u03be) (because h\u03ba[U U ] = h\u03ba) = \u03c7(\u03c4) ( \u03c7(LU(\u03d5)) \u2297 h\u03ba ) (\u03be) (because LU(\u03d5) \u2286 Tv\u03a3U ) = h\u03ba(\u03c4 \u22121(\u03be) \u2229 LU(\u03d5)) . (by Observation 2.10.1)\nBy Lemma 14.5.3, we can construct a \u03a3U -local system (G,H) such that LU (\u03d5) = L(G,H). Hence we obtain [[A]]run(\u03be) = h\u03ba(\u03c4\u22121(\u03be) \u2229 L(G,H)).\n320 CHAPTER 14. WEIGHTED MSO-LOGIC AND B-E-T\u2019S THEOREM\nChapter 15\nAbstract families of weighted tree languages\nIn the 60\u2019s and 70\u2019s of the previous century, Ginsburg, Greibach, and Hopcroft proposed a unifying concept for the study of closure properties of sets of formal languages [GG67, GG69, GGH69, Gin75]. This is the concept of abstract family of languages (AFL). Roughly speaking, an AFL is a set of formal languages which is closed under intersection with regular languages, inverse homomorphisms, \u03b5-free homomorphisms, union, concatenation, and Kleene star. An AFL is full if it is closed under arbitrary homomorphisms. Of particular interest are principal AFL; an AFL is principal if it is generated from one formal language by using the mentioned closure properties. For instance, the sets of regular languages, context-free languages, stack languages, nested-stack languages, and recursively enumerable languages are full principal AFL [GG70, Sec. 2].\nThe importance of principal AFL shows up in one of the main theorems of AFL-theory [Gin75, Thm. 5.2.1]: a set L is a full principal AFL if and only if there exists a finitely encoded abstract family of acceptors (AFA) D such that L is set of all formal languages accepted by D. Roughly speaking, an acceptor D is a one-way nondeterministic finite-state automaton which uses an additional storage (indicated by the type D) such as, e.g. counter, pushdown, stack, or nested-stack. Thus, in other words, \u201ceach family of languages defined by a set of \u2019well-behaving\u2019 one-way nondeterministic acceptors of a same \u2019type\u2019 is a full principal AFL\u201d (cited from [ESvL80, p. 109].\nIn this chapter we define the concept of abstract family of weighted tree languages. It is inspired by the definitions of abstract family of languages [GG67, GG69, GG70, GGH69, Gin75], abstract family of formal power series [KS86], abstract family of fuzzy languages [Asv03] (also cf. [Wec78, Ch. 3]), abstract family of tree series [Kui99a, Thm. 3.5] and [E\u0301K03, Sect. 7], and sheaf of forests [BR94].\nIn the rest of this chapter, B denotes an arbitrary commutative and \u03c3-complete semiring.\nThus, by Theorem 9.2.9, we have that Rec(\u03a3,B) = Reg(\u03a3,B), and, in particular, the closure results developed in Chapter 10 for Rec(\u03a3,B) also hold for Reg(\u03a3,B).\nIn this chapter we follow the notions and definitions in [FV22b]. The main theorem is the following (cf. Theorem 15.4.5): for each n \u2208 N, the set Reg(n,B) of all (n,B)-weighted tree languages is the smallest principal abstract family of (n,B)-weighted tree languages."
        },
        {
            "heading": "15.1 The basic definitions",
            "text": "For each n \u2208 N, an (n,B)-weighted tree language is a (\u03a3,B)-weighted tree language for some ranked alphabet \u03a3 with maxrk(\u03a3) \u2264 n.\n321\n322 CHAPTER 15. ABSTRACT FAMILIES OF WEIGHTED TREE LANGUAGES\nIn this chapter we will often consider a set L of (n,B)-weighted tree languages and write that \u201cL is closed under some operation\u201d, like scalar multiplication, sum, tree concatenations, or weighted projective bimorphisms (wpb). If we consider a binary operation, then we always assume that the two arguments of the operation are based on the same ranked alphabet. For instance, if we write that a set L of (n,B)weighted tree languages is closed under sum, then this means that, for every ranked alphabet \u03a3 with maxrk(\u03a3) \u2264 n, and r1 : T\u03a3 \u2192 B and r2 : T\u03a3 \u2192 B in L, the weighted tree language r1 \u2295 r2 is in L.\nAs a consequence of the definition of an (n,B)-weighted tree language, we have that a regular (n,B)weighted tree language is a regular (\u03a3,B)-weighted tree language for some ranked alphabet \u03a3 with maxrk(\u03a3) \u2264 n. We denote the set of all regular (n,B)-weighted tree languages by Reg(n,B). That is\nReg(n,B) = \u22c3 (Reg(\u03a3,B) | \u03a3 is a ranked alphabet such that maxrk(\u03a3) \u2264 n) .\nSimilarly to the unweighted string case, we require that a family of weighted tree languages contains at least one element. Here we let this element be a recognizable step mapping which is unit-valued, one-step, and over a very simple ranked alphabet. Formally, let L be a set of (n,B)-weighted tree languages. We call L a family of (n,B)-weighted tree languages if there exists a ranked alphabet \u2206 such that\n\u2022 maxrk(\u2206) = n, \u2022 |\u2206(k)| = 1 for each k \u2208 [0, n], and \u2022 \u03c7(T\u2206) \u2208 L.\nIf \u2206 is such a ranked alphabet, then for each ranked alphabet \u03a3 with maxrk(\u03a3) \u2264 n and \u03be \u2208 T\u03a3, there exists a unique \u03b6 \u2208 T\u2206 such that pos(\u03b6) = pos(\u03be). We will exploit this obvious fact later.\nLet L be a family of (n,B)-weighted tree languages. We call L an (n,B)-tree cone if it is closed under wpb. (For the definition of wpb, we refer to cf. Section 10.13. For related concepts, we refer to [Ber79, p. 136] for rational cones, to [Kui99a, p. 8] for recognizable tree cones, and to [E\u0301K03, Sect. 7] for recognizable tree series cones.)\nWe call L an abstract family of (n,B)-weighted tree languages (for short: (n,B)-AFwtL, or just: AFwtL) if L is an (n,B)-tree cone which is closed under the rational operations, i.e., under sum, tree concatenations, and Kleene-stars.\nThe above definition of (n,B)-AFwtL is equivalent to the one in [FV22b] where additionally closure under scalar multiplication was required. However, scalar multiplication of some (\u03a3,B)-weighted tree language r with some b \u2208 B can be simulated as the Hadamard product of r and the constant weighted tree language b\u0303. In its turn, the Hadamard product of r and b\u0303, can be expressed as application [[H]]tt(r) for some (\u03a3,\u03a3,B)-wpb H such that [[H]]tt(\u03be, \u03b6) = b if \u03be = \u03b6, and 0 otherwise (cf. (2.28)). It is obvious how to construct such an H. Thus, scalar multiplication can be simulated by wpb, and hence closure under scalar multiplication can be neglected in the definition of (n,B)-AFwtL. We note that the concept of full abstract family of languages [GG67, GG69, GGH69, Gin75] is a particular instance of the concept of AFwtL (cf. [FV22b, Sec. 7]).\nLet S be a set of (n,B)-weighted tree languages. We denote the smallest (n,B)-AFwtL which contains S by F(S).\nNow assume that L is an (n,B)-AFwtL. Then it is principal if there exists an (n,B)-weighted tree language g \u2208 L such that L = F({g}); and if this is the case, then g is called generator (of L)."
        },
        {
            "heading": "15.2 Characterization of tree cones",
            "text": "As defined above, a family of (n,B)-weighted tree languages is an (n,B)-tree cone if it is closed under wpb. Here we characterize the property of being an (n,B)-tree cone by decomposing each wpb into (a) the inverse of a linear and nondeleting tree homormorphism, (b) the Hadamard product with a recognizable weighted tree language, and (c) a linear and nondeleting tree homomorphism. In other words, we make the two homomorphisms and the center language of a wpb explicit (cf. Corollary 15.2.2).\n15.2. CHARACTERIZATION OF TREE CONES 323\nThe characterization resembles Nivat\u2019s decomposition theorem of gsm [Niv68], Arnold\u2019s and Dauchet\u2019s bimorphism [AD76, AD82], Ginsburg\u2019s decomposition of a-transducers [Gin75, Lm. 3.2.2], and Engelfriet\u2019s decomposition of bottom-up tree transducers [Eng75a, Thm. 3.5]. Moreover, it is an instance of [FMV11, Thm. 4.2].\nLet H = (N,S,R,wt) be a (\u03a3,\u03a8,B)-wpb. We recall that H is a particular ([\u03a3\u03a8],B)-wrtg and hence, we have defined the (R, [\u03a3\u03a8])-tree homomorphism \u03c0 : TR \u2192 T[\u03a3\u03a8], which extracts from a rule tree the derived [\u03a3\u03a8]-tree. Moreover, for the wbpH, we have defined the ([\u03a3\u03a8],\u03a3)-tree homomorphism \u03c01 and the ([\u03a3\u03a8],\u03a8)-tree homomorphism \u03c02, which project a [\u03a3\u03a8]-tree to its first and second component, respectively. Each of the three tree homomorphisms \u03c0, \u03c01, and \u03c02 is linear and nondeleting. Now we compose (a) \u03c0 and \u03c01 and (b) \u03c0 and \u03c02, and thereby obtain two linear and nondeleting tree homomorphisms h H 1 and hH2 .\nFormally, we define hH1 = \u03c01\u25e6\u0302\u03c0 and h H 2 = \u03c02\u25e6\u0302\u03c0, where \u25e6\u0302 is the syntactic composition of tree homomorphisms defined in Section 2.9. For the convenience of the reader, we recall that hH1 = ((h H 1 )k | k \u2208 N) is the (R,\u03a3)-tree homomorphism and hH2 = ((h H 2 )k | k \u2208 N) is an (R,\u03a8)-tree homomorphism such that the following holds.\n\u2022 For every k \u2208 N and rule r = (A\u2192 [\u03c3, \u03c8](A1, . . . , Ak)) with [\u03c3, \u03c8] \u2208 [\u03a3\u03a8] (k), we have\n(hH1 )k(r) =\n{ \u03c3(x1, . . . , xk) if \u03c3 6= \u03b5\nx1 otherwise and (hH2 )k(r) =\n{ \u03c8(x1, . . . , xk) if \u03c8 6= \u03b5\nx1 otherwise .\n\u2022 For each chain-rule r = (A\u2192 B), we have (hH1 )1(r) = x1 and (h H 2 )1(r) = x1.\nIn fact, hH1 and h H 2 are simple, i.e., linear, nondeleting, alphabetic, and ordered tree homomorphisms. Moreover, by Theorem 2.9.7, we have hH1 = \u03c01 \u25e6 \u03c0 and h H 2 = \u03c02 \u25e6 \u03c0.\nNow we can prove the characterization of wpb reported above. We mention that the composition of weighted tree transformations involved in the following theorem is associative due to Observation 2.10.2. Moreover, we will use the concepts of characteristic mapping and diagonalization as follows (cf. Subsections 2.10.2 and 2.10.3). Since hH1 and h H 2 are particular binary relations, i.e., h H 1 \u2286 TR \u00d7 T\u03a3 and hH2 \u2286 TR \u00d7 T\u03a8, we can consider the characteristic mappings \u03c7((h H 1 )\n\u22121) : T\u03a3 \u00d7 TR \u2192 B and \u03c7(hH2 ) : TR \u00d7 T\u03a8 \u2192 B. Also we will use the diagonalization [[H]] wrt : TR \u00d7 TR \u2192 B of [[H]]wrt.\nTheorem 15.2.1. Let H be a (\u03a3,\u03a8,B)-wpb. Then [[H]]tt = \u03c7((hH1 ) \u22121); [[H]]wrt;\u03c7(hH2 ).\nProof. Let \u03be \u2208 T\u03a3 and \u03b6 \u2208 T\u03a8. By the definition of RTH(T[\u03a3\u03a8]) in Section 8.1 (notice the fact that each wpb in a particular weighted context-free grammar) and by (10.41), we have\nRTH(\u03be, \u03b6) = {d \u2208 TR | (\u03be, \u03b6) = (h H 1 (d), h H 2 (d)), d \u2208 RTH(T[\u03a3\u03a8])} . (15.1)\nThen we can calculate as follows.\n[[H]]tt(\u03be, \u03b6) = \u2211\u2295\nd\u2208RTH(\u03be,\u03b6)\nwtH(d)\n= \u2211\u2295\nd\u2208TR: (\u03be,\u03b6)=(hH1 (d),h H 2 (d))\nwtH(d)\u2297 \u03c7(RTH(T[\u03a3\u03a8]))(d) (by (15.1))\n= \u2211\u2295\nd\u2208TR: (\u03be,\u03b6)=(hH1 (d),h H 2 (d))\n[[H]]wrt(d) (by definition of [[H]]wrt)\n= \u2211\u2295\nd\u2208TR\n\u03c7(hH1 )(d, \u03be) \u2297 [[H]] wrt(d, d)\u2297 \u03c7(hH2 )(d, \u03b6)\n= \u2211\u2295\nd,d\u2032\u2208TR\n\u03c7(hH1 )(d, \u03be) \u2297 [[H]] wrt(d, d\u2032)\u2297 \u03c7(hH2 )(d \u2032, \u03b6) (because [[H]]wrt(d, d\u2032) = 0 if d 6= d\u2032)\n324 CHAPTER 15. ABSTRACT FAMILIES OF WEIGHTED TREE LANGUAGES\n= \u2211\u2295\nd,d\u2032\u2208TR\n\u03c7((hH1 ) \u22121)(\u03be, d) \u2297 [[H]]wrt(d, d\u2032)\u2297 \u03c7(hH2 )(d \u2032, \u03b6)\n= (\u03c7((hH1 ) \u22121); [[H]]wrt;\u03c7(hH2 ))(\u03be, \u03b6) . (by definition of composition, see Subsection 2.10.3)\nAn n-tree homomorphism is a (\u03a3,\u03a8)-tree homomorphism where \u03a3 and \u03a8 are ranked alphabets and maxrk(\u03a3) \u2264 n and maxrk(\u03a8) \u2264 n. The closure under n-tree homomorphisms and closure under inverse n-tree homomorphisms are defined in a way analogous to the corresponding closure under tree homomorphisms and inverse tree homomorphisms (cf. Sections 10.11 and 10.12).\nA set L of (n,B)-weighted tree languages is closed under Hadamard product with recognizable (n,B)weighted tree languages if, for every (\u03a3,B)-weighted tree language r in L and for each recognizable (\u03a3,B)-weighted tree language r\u2032, we have r \u2297 r\u2032 is in L.\nCorollary 15.2.2. Let B be a commutative and \u03c3-complete semiring. Let n \u2208 N and L be a family of (n,B)-weighted tree languages. Then the following three statements are equivalent. (A) L is an (n,B)-tree cone. (B) L is closed under (a) simple n-tree homomorphisms, (b) inverse of simple n-tree homomorphisms,\nand (c) Hadamard product with recognizable (n,B)-weighted tree languages. (C) L is closed under (a) simple n-tree homomorphisms, (b) inverse of simple n-tree homomorphisms,\nand (c) Hadamard product with bu deterministically recognizable (n,B)-weighted tree languages.\nProof. Proof of (A)\u21d2(B): (a) Let h = (hk | k \u2208 N) be a simple (\u03a3,\u03a8)-tree homomorphism with maxrk(\u03a3) \u2264 n and maxrk(\u03a8) \u2264 n. Then we construct the (\u03a3,\u03a8,B)-wpb H = (N,S,R,wt) as follows. We let N = S = {A} and, for every k \u2208 N and \u03c3 \u2208 \u03a3(k), we have the following.\nIf hk(\u03c3) = \u03c8(x1, . . . , xk), then r = (A\u2192 [\u03c3, \u03c8](A, . . . , A)) is in R and wt(r) = 1.\nIf k = 1 and hk(\u03c3) = x1, then r = (A\u2192 [\u03c3, \u03b5](A)) is in R and wt(r) = 1.\nIt is obvious that [[H]]tt = \u03c7(h). Since L is closed under (n,B)-wpb, we obtain that L is closed under simple n-tree homomorphisms.\n(b) This can be proved in the same way as (a) except that the order of \u03c3 and \u03c8 (and \u03c3 and \u03b5) in the rules of R are exchanged.\n(c) Let r : T\u03a3 \u2192 B be a weighted tree language in L andA be a (\u03a3,B)-wta. By definition, maxrk(\u03a3) \u2264 n. By the proof of Corollary 10.13.11, we can construct a (\u03a3,\u03a3,B)-wpb H such that [[H]]tt = [[A]], i.e., [[H]]tt is the diagonalization of [[A]] (cf. page 51). Then by Equation (2.33) we have [[H]]tt(r) = r \u2297 [[A]]. Since L is closed under wpb, we can conclude that L is closed under Hadamard product with recognizable (n,B)-weighted tree languages.\nProof of (B)\u21d2(C): It is obvious.\nProof of (C)\u21d2(A): Let r : T\u03a3 \u2192 B be in L and let H be a (\u03a3,\u03a8,B)-wpb with maxrk(\u03a8) \u2264 n. Let R be the set of rules of H. By Theorem 15.2.1, we have\n[[H]]tt(r) = ( \u03c7((hH1 ) \u22121); [[H]]wrt;\u03c7(hH2 ) ) (r)\nand thus, by Observation 2.10.3, we have\n[[H]]tt(r) = \u03c7(hH2 ) ( [[H]]wrt ( \u03c7((hH1 ) \u22121) ( r ))) .\nLet us denote the weighted tree language \u03c7((hH1 ) \u22121)(r) by r\u2032 Since L is closed under inverse of simple n-tree homomorphism, r\u2032 is in L. Then, by Equation (2.33), we have\n[[H]]wrt(r\u2032) = r\u2032 \u2297 [[H]]wrt .\n15.3. REG(N,B) IS AN AFWTL 325\nBy Lemma 11.2.2(2) and Lemma 11.2.3, the weighted tree language [[H]]wrt is bu deterministically recognizable. Since L is closed under Hadamard product with bu deterministically recognizable n-weighted tree languages, we obtain that [[H]]wrt(r\u2032) is in L. Let us denote this weighted tree language by r\u2032\u2032. Finally, since L is closed under simple n-tree homomorphism, the weighted tree language \u03c7(hH2 )(r\n\u2032\u2032) is in L. Hence [[H]]tt(r) is in L.\n15.3 Reg(n,B) is an AFwtL\nHere we prove that the set of regular (n,B)-weighted tree languages is an AFwtL. For each n \u2208 N, we define the ranked alphabet \u2206n by\n\u2206n = \u22c3\nk\u2208[0,n]\n\u2206(k)n and \u2206 (k) n = {[k]} for each k \u2208 [0, n] .\nWe note that, for each ranked alphabet \u03a3 with maxrk(\u03a3) = n for some n \u2208 N, the skeleton alphabet of \u03a3 is a subset of \u2206n, i.e., [\u03a3] \u2286 \u2206n. For the definition of the skeleton alphabet we refer to page 228.\nLemma 15.3.1. [FV22b, Lm. 6.2,6.9] The (\u2206n,B)-weighted tree language \u03c7(T\u2206n) is in Reg(n,B). Moreover, Reg(n,B) is a family of (n,B)-weighted tree languages.\nProof. We construct the (\u2206n,B)-wrtg G = ({\u2217}, {\u2217}, R,wt) such that, for each k \u2208 [0, n], R contains the rule r = (\u2217 \u2192 [k](\u2217, . . . , \u2217)) with k occurrences of \u2217 in the right-hand side and wt(r) = 1. Since [[G]] = \u03c7(T\u2206n), we have \u03c7(T\u2206n) \u2208 Reg(n,B).\nSince maxrk(\u2206n) = n, |\u2206 (k) n | = 1 for each k \u2208 [0, n], and \u03c7(T\u2206n) \u2208 Reg(n,B), we have that Reg(n,B)\nis a family of (n,B)-weighted tree languages.\nTheorem 15.3.2. [FV22b, Thm. 6.8] Reg(n,B) is an AFwtL.\nProof. By Lemma 15.3.1, the set Reg(n,B) is a family of (n,B)-weighted tree languages.\nBy Theorem 10.13.9, Reg(n,B) is closed under wpb, and hence Reg(n,B) is a tree cone. We note that the image of an (n,B)-weighted tree language under a wpb is again an (n,B)-weighted tree language.\nLet r, r1, r2, s \u2208 Reg(\u03a3,B) for some ranked alphabet \u03a3 with maxrk(\u03a3) \u2264 n. Moreover, let \u03b1 \u2208 \u03a3(0). We require that s is \u03b1-proper. By Theorems 10.1.1, 10.6.1, and 10.7.4, the (\u03a3,B)-weighted tree languages r1 \u2295 r2, r1 \u25e6\u03b1 r2, and s \u2217 \u03b1 are in Reg(\u03a3,B), respectively. (We recall that Rec(\u03a3,B) = Reg(\u03a3,B) because we assumed that B is a \u03c3-complete semiring.) Hence Reg(n,B) is closed under the rational operations, i.e., under sum, tree concatenations, and Kleene stars. Hence, Reg(n,B) is an AFwtL.\n15.4 The AFwtL Reg(n,B) is principal\nWe will prove that the (\u2206n,B)-weighted tree language \u03c7(T\u2206n) is the generator of Reg(n,B).\nLemma 15.4.1. [FV22b, Lm. 6.10] Let G be a (\u03a3,B)-wrtg with maxrk(\u03a3) \u2264 n. Then there exists a (\u2206n,\u03a3)-wpb H such that [[G]] = [[H]] tt(\u03c7(T\u2206n)).\nProof. Let G = (N,S,R,wt) with maxrk(\u03a3) \u2264 n. By Lemma 9.2.3, we can assume that G is in tree automata form. Thus [R] = [\u03a3] and hence [R] \u2286 \u2206n (also for n = 0).\nBy Lemma 10.13.6, there exists a chain-free ([R],\u03a3,B)-wpb H\u2032 such that [[G]] = [[H\u2032]]tt(\u03c7(T[R])). Since [R] \u2286 \u2206n, we can view H\u2032 as a (\u2206n,\u03a3,B)-wbp H. Obviously, [[H\u2032]] = [[H]]|T[R]\u00d7T\u03a3 and, for each (b, \u03be) \u2208 (T\u2206n\u00d7T\u03a3)\\ (T[R]\u00d7T\u03a3), we have that [[H]](b, \u03be) = 0. Thus [[H\n\u2032]](\u03c7(T[R])) = [[H]](\u03c7(T\u2206n)). Hence [[G]] = [[H]]tt(\u03c7(T\u2206n)).\n326 CHAPTER 15. ABSTRACT FAMILIES OF WEIGHTED TREE LANGUAGES\nLemma 15.4.2. [FV22b, Lm. 6.11] Let maxrk(\u03a3) \u2264 n and r : T\u03a3 \u2192 B. The following statements are equivalent.\n(A) r \u2208 Reg(n,B). (B) There exists a (\u2206n,\u03a3)-wpb H such that r = [[H]]tt(\u03c7(T\u2206n)). (C) r \u2208 F({\u03c7(T\u2206n)}).\nProof. Proof of (A)\u21d2(B): This follows from Lemma 15.4.1.\nProof of (B)\u21d2(C): This holds by definition of F({\u03c7(T\u2206n)}).\nProof of (C)\u21d2(A): By Theorem 15.3.2, the set Reg(n,B) is an AFwtL. By Lemma 15.3.1, we have that \u03c7(T\u2206n) is in Reg(n,B). Since F({\u03c7(T\u2206n)}) is the smallest AFwtL containing \u03c7(T\u2206n), we obtain that r \u2208 Reg(n,B).\nThe equivalence of (A) and (C) of Lemma 15.4.2 implies the following theorem.\nTheorem 15.4.3. [FV22b, Thm. 6.12] The AFwtL Reg(n,B) is principal with generator \u03c7(T\u2206n).\nNext we prove that the set Reg(n,B) is contained in each (n,B)-tree cone.\nCorollary 15.4.4. [FV22b, Cor. 6.13] For each (n,B)-tree cone L we have Reg(n,B) \u2286 L.\nProof. Let G by a (\u03a3,B)-wrtg with maxrk(\u03a3) \u2264 n. By Lemma 15.4.1, there exists a (\u2206n,\u03a3)-wpb H such that\n[[G]] = [[H]]tt(\u03c7(T\u2206n)) .\nNow let L be an (n,B)-tree cone. Since L is a family of (n,B)-weighted tree languages, there exists a ranked alphabet \u2206 such that maxrk(\u2206) = n, |\u2206(k)| = 1 for each k \u2208 [0, n], and \u03c7(T\u2206) is in L. The only difference between \u2206 and \u2206n is the fact that the symbols look different. Let \u3008k\u3009 denote the unique element in \u2206(k).\nWe construct the (\u2206,\u2206n,B)-wpb N = ({\u2217}, {\u2217}, R,wt) such that for each k \u2208 [0, n], the rule\n\u2217 \u2192 [\u3008k\u3009, [k]](\u2217, . . . , \u2217)\nis in R with k occurrences of \u2217. Obviously, \u03c7(T\u2206n) = [[N ]] tt(\u03c7(T\u2206)). Hence,\n[[G]] = [[H]]tt([[N ]]tt(\u03c7(T\u2206))) .\nBy Theorem 10.13.7, wpb are closed under composition. Hence there exists a (\u2206,\u03a3)-wpb H\u2032 such that\n[[G]] = [[H\u2032]]tt(\u03c7(T\u2206)) .\nSince \u03c7(T\u2206) is in L and L is an (n,B)-tree cone, we obtain that [[G]] is in L.\nTheorem 15.4.5. Let B be a commutative and \u03c3-complete semiring and n \u2208 N. Then Reg(n,B) is the smallest principal abstract family of (n,B)-weighted tree languages.\nProof. By Theorem 15.4.3, the set Reg(n,B) is a principal (n,B)-AFwtL. Now let L be an arbitrary principal (n,B)-AFwtL. Since, in particular, L is an (n,B)-tree cone, by Corollary 15.4.4, we have Reg(n,B) \u2286 L.\nOther examples of principal abstract families of (n,B)-weighted tree languages are the members of the infinite family (Reg(P\u2113, n,B) | \u2113 \u2208 N) (cf. [FV22b, Thm. 8.1]). Here Reg(P\u2113, n,B) is the set of all (n,B)weighted tree languages which are generated by weighted regular tree grammars with additional storage P\u2113, the \u2113-iterated pushdown storage [Gre70, Mas76, Eng86]. The particular instance (Reg(P\u2113, n,Boole) | \u2113 \u2208 N) is known as the OI-hierarchy [Wan74, Dam82, ES77, ES78, DG82, Eng91], which starts with the set of regular tree languages (\u2113 = 0) and the set of OI context-free tree languages (\u2113 = 1).\nChapter 16\nCrisp determinization\nWe recall that, in a crisp deterministic (\u03a3,B)-wta B, the weight of each transition is one of the unit weights 0 and 1 of the strong bimonoid B; weights different from these units may only occur as root weights. Also, since crisp determinism implies bu determinism, the two semantics of B coincide, i.e., [[B]]init = [[B]]run (cf. Theorem 5.3.1). We denoted the semantics of B by [[B]].\nIn this chapter we will investigate the question under which conditions a given wta can be transformed into an equivalent crisp deterministic wta. More precisely, a (\u03a3,B)-wta A is initial algebra crisp determinizable if there exists an i-equivalent crisp deterministic (\u03a3,B)-wta, i.e., there exists a crisp deterministic (\u03a3,B)-wta B such that [[A]]init = [[B]]. It is run crisp determinizable if there exists an r-equivalent crisp deterministic (\u03a3,B)-wta, i.e., there exists a crisp deterministic (\u03a3,B)-wta B such that [[A]]run = [[B]]. It follows from the previous definitions that, if B is semiring, then A is initial algebra crisp determinizable if and only if it is run crisp determinizable (because by Corollary 5.3.3 [[A]]init = [[A]]run).\nIn the sequel we will identify conditions under which a given (\u03a3,B)-wta A is initial algebra crisp determinizable and under which conditions it is run crisp determinizable. We approach the answers by recalling that each crisp deterministic (\u03a3,B)-wta B recognizes a (\u03a3,B)-recognizable step mapping, and vice versa, each (\u03a3,B)-recognizable step mapping can be obtained in this way (cf. Theorem 10.3.1). Hence, A is initial algebra crisp determinizable if and only if [[A]]init is a recognizable step mapping, i.e., im([[A]]init) is finite and [[A]]init has the preimage property (and similarly for run crisp determinizable).\nThus, Theorem 10.3.1 provides a blue-print for the answers to the crisp determinization problems. On the negative side, if we consider a (\u03a3,B)-wta A for which [[A]]init is not a recognizable step mapping, then A is not initial algebra crisp determinizable, and similarly for [[A]]run and run crisp determinizability. For instance, let A be the (\u03a3,Natmax,+)-wta from Example 3.2.4 for which [[A]]init = height. Since im(height) is not finite, [[A]]init is not a recognizable step mapping (by definition). Hence, by Theorem 10.3.1 and the fact that Natmax,+ is a semiring, A is neither initial algebra crisp determinizable nor run crisp determinizable. On the positive side, each (\u03a3,B)-wta A for which [[A]]init is a recognizable step mapping, is initial algebra crisp determinizable, and similarly for the run semantics and run crisp determinizability.\nIn Section 16.1 we will deal with initial algebra crisp determinization and in Section 16.2 with run crisp determinization. This chapter is based on results and constructions in [FKV21], [DFKV20], and [DFKV22]."
        },
        {
            "heading": "16.1 Initial algebra crisp determinization",
            "text": "In this section we will show an equivalence between local finiteness and initial algebra crisp determinizability (cf. Theorem 16.1.6).\n327\n328 CHAPTER 16. CRISP DETERMINIZATION\nIf we recall the way in which a (\u03a3,B)-wta A computes hA(\u03be) for some input tree \u03be \u2208 T\u03a3, then we see that the summation and multiplication of B are used in an alternating way. One possibility to guarantee that these computations only produce finitely many values in B, is to assume that B is locally finite. Indeed, for each locally finite strong bimonoid B, the set Recinit(\u03a3,B) contains only recognizable step mappings (cf. [BMS\u030c+06, Thm. 9], [DV06, Lm. 6.1], [FV09, Cor. 3.16], and [CDIV10, p. 9]). Since each distributive bounded lattice is a particular locally finite semiring (cf. Subsection 2.6.6), the next lemma can also be compared to [Rah09, Thm. 3.8].\nLemma 16.1.1. (cf. [FKV21, Cor. 6.10]) Let (a) B be locally finite or (b) let B be weakly locally finite and \u03a3 is monadic. Moreover, let A be a (\u03a3,B)-wta. Then im(hA) is finite and A is initial algebra crisp determinizable.\nProof. Let A = (Q, \u03b4, F ). We recall that im(\u03b4) = \u22c3 k\u2208N im(\u03b4k).\nFirst we show that the set H = {hA(\u03be)q | \u03be \u2208 T\u03a3, q \u2208 Q} is finite.\nCase (a): Let B be locally finite. Since H \u2286 \u3008im(\u03b4)\u3009{\u2295,\u2297} and \u3008im(\u03b4)\u3009{\u2295,\u2297} is finite, the set H is finite.\nCase (b): Let B be weakly locally finite and \u03a3 be monadic. By induction on T\u03a3, we prove that the following statement holds (where Cl(im(\u03b4)) is defined in Subsection 2.6.5).\nFor every \u03be \u2208 T\u03a3 and q \u2208 Q, we have: hA(\u03be)q \u2208 Cl(im(\u03b4)) . (16.1)\nThe proof for \u03be \u2208 \u03a3(0) is trivial. Let \u03be = \u03c3(\u03be1). Then hA(\u03be1)p \u2297 \u03b41(p, \u03c3, q) \u2208 Cl(im(\u03b4)) for each p \u2208 Q because hA(\u03be1)p \u2208 Cl(im(\u03b4)) by I.H. and \u03b41(p, \u03c3, q) \u2208 im(\u03b4). Moreover, hA(\u03be)q = \u2295 p\u2208Q hA(\u03be1)p \u2297 \u03b41(p, \u03c3, q) is also in Cl(im(\u03b4)) because Cl(im(\u03b4)) is closed under \u2295. This finishes the proof of (16.1).\nDue to (16.1), we obtain that H \u2286 Cl(im(\u03b4)). Since B is weakly locally finite, we have that H is finite.\nHence, in both Cases (a) and (b), the set H is finite. Then the set im(hA) is also finite because hA(\u03be) \u2208 HQ for every \u03be \u2208 T\u03a3. Hence the congruence ker(hA) of A has finite index. Thus, by Theorem 4.3.5(C)\u21d2(B), the (\u03a3,B)-wta A is initial algebra crisp determinizable.\nLemma 16.1.1 states that each (\u03a3,B)-wta is initial algebra crisp determinizable if one of its conditions (a) and (b) holds. In fact, if one traces back the proofs of Lemma 16.1.1, Theorem 4.3.5, and Lemma 4.3.4, then one can construct the corresponding crisp deterministic wta. Since its construction is rather hidden, we want to show this explicitly here (cf. Definition 16.1.2).\nIn fact, the construction of the corresponding crisp deterministic wta generalizes the well-known subset method which transforms an fta into an equivalent bu deterministic fta (cf. [TW68, Thm. 1], [Eng75b, Thm. 3.8], and [GS84, Thm. 2.2.6]). The set of states of the bu deterministic fta is the set of all subsets of the state set of the given fta. Here, for a given wta A = (Q, \u03b4, F ), we represent the states of the equivalent bu deterministic wta by vectors in BQ. However, we do not use all vectors in BQ, but only those which are images of trees under hA. This corresponds to using the reachable subsets in the subset method. We generalize the subset method for any wta and strong bimonoid B, and we keep the name \u201csubset method\u201d also for the generalized version.\nA special case of this subset method was given in the proof of [Be\u030cl02, Thm. 2.1] for the case of string ranked alphabets (i.e., weighted automata) and complete distributive lattices. (We note that distributivity is not assumed in [Be\u030cl02], but it is needed because the many-fold composition of matrices in the definition of the acceptance degree, i.e., run semantics, assumes associativity of matrix multiplication, and in its turn, this assumes distributivity [Be\u030cl08]). In fact, the notion of deterministic fuzzy automata in [Be\u030cl02] corresponds to our notion of crisp deterministic wta over some string ranked alphabet and some complete distributive lattice due to Lemma 3.3.3 and Theorem 4.3.5(A)\u21d4(B). In [BLB10, Thm. 5 and 8] the subset method was presented for wta over UnitIntu,i where (u, i) are particular pairs of t-conorm u and t-norm i. Another special case of the subset method is given in [MZA11, Thm. 3.5] for wta over ([0, 1],\u2207,\u2206, 0, 1) where \u2207 and \u2206 are some t-conorm and t-norm, respectively, such that (\u2207,\u2206) are finite range. The latter property implies that ([0, 1],\u2207,\u2206, 0, 1) is locally finite (but not vice versa).\n16.1. INITIAL ALGEBRA CRISP DETERMINIZATION 329\nDefinition 16.1.2. Let \u03a3 be a ranked alphabet and B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid. Moreover, let A be a (\u03a3,B)-wta. The subset method transforms A into the triple sub(A) = (Q\u2032, \u03b4\u2032, F \u2032), where\n\u2022 Q\u2032 = im(hA), \u2022 \u03b4\u2032 = (\u03b4\u2032k | k \u2208 N) is the family of mappings \u03b4 \u2032 k : (Q \u2032)k \u00d7 \u03a3(k) \u00d7Q\u2032 \u2192 B defined by\n\u03b4\u2032k(u1 . . . uk, \u03c3, u) =\n{ 1 if \u03b4A(\u03c3)(u1, . . . , uk) = u\n0 otherwise\nfor every k \u2208 N, \u03c3 \u2208 \u03a3(k), u1, . . . , uk \u2208 Q\u2032, and u \u2208 Q\u2032, \u2022 F \u2032 : Q\u2032 \u2192 B is a mapping defined by (F \u2032)u = \u2295 q\u2208Q uq \u2297 Fq for every u \u2208 Q \u2032.\nThus, sub(A) is merely a triple and, in general, not a wta. In particular, Q\u2032 can be an infinite set. However, sub(A) is a crisp deterministic wta if and only if Q\u2032 is finite. But assuming one of the conditions of Lemma 16.1.1, we can prove that sub(A) is a crisp deterministic wta which is i-equivalent to A.\nTheorem 16.1.3. Let \u03a3 be a ranked alphabet and B = (B,\u2295,\u2297, 0, 1) be a strong bimonoid such that (a) B is locally finite or (b) B is weakly locally finite and \u03a3 is monadic. Then the following two statements hold. (1) For each (\u03a3,B)-wta A, the triple sub(A) can be constructed; moreover, sub(A) is a crisp determin-\nistic (\u03a3, B)-wta and [[A]]init = [[sub(A)]]. (2) Recinit(\u03a3,B) \u2286 Recrun(\u03a3,B).\nProof. Proof of (1): By Observation 2.9.4, we have im(hA) = \u3008\u2205\u3009\u03b4A(\u03a3) and by Lemma 16.1.1, the set im(hA) is finite. Hence \u3008\u2205\u3009\u03b4A(\u03a3) is finite and by Lemma 2.6.1, it can be constructed. Thus im(hA) can be constructed. It is easy to see that sub(A) is a crisp deterministic (\u03a3, B)-wta.\nMoreover, the subset method is the composition of the constructions in the proofs of Theorem 4.3.5(C) \u21d2 (A) and Lemma 4.3.4. Indeed, in Theorem 4.3.5(C) \u21d2 (A) we construct the finite algebra (im(hA), \u03b4aV(A)) and the mapping F\n\u2032. Then, using this as input, Lemma 4.3.4 constructs the crisp deterministic (\u03a3,B)-wta (im(hA), \u03b4\n\u2032, F \u2032), which is nothing else but sub(A). Hence it follows that [[A]]init = [[sub(A)]].\nProof of (2): Let A be a (\u03a3,B)-wta. By (1) we have [[A]]init = [[sub(A)]], where [[sub(A)]] is a crisp deterministic (\u03a3,B)-wta. Since, by Theorem 5.3.1, [[sub(A)]] = [[sub(A)]]run, we have Recinit(\u03a3,B) \u2286 Recrun(\u03a3,B).\nAs a consequence of Theorem 16.1.3, we show a preimage theorem. In general, a preimage theorem states, for some modifier x \u2208 {run, init}, under which conditions on B, for each (\u03a3,B)-wta A, the weighted tree language [[A]]x has the preimage property (i.e., for each b \u2208 B we have that ([[A]]x)\u22121(b) is a recognizable tree language, cf. Section 2.10.2). Clearly, if B is a semiring, then we can disregard the modifier x (cf. Corollary 5.3.3). The next preimage theorem concerns the initial algebra semantics (i.e., x = init).\nCorollary 16.1.4. Let (a) B be locally finite or (b) let B be weakly locally finite and \u03a3 monadic. Moreover, let A be a (\u03a3,B)-wta. Then [[A]]init has the preimage property. Moreover, for each b \u2208 B, we can construct a \u03a3-fta A such that L(A) = ([[A]]init)\u22121(b).\nProof. By Theorem 16.1.3 we can construct the crisp deterministic (\u03a3,B)-wta sub(A) such that [[A]]init = [[sub(A)]]. Then our statements follow from Theorem 10.3.1(A)\u21d2(C).\nA special case of Corollary 16.1.4(a) was proved in [DV06, Lm. 6.1] for locally finite commutative semirings (taking into account that for wta over semirings the run semantics and the initial algebra\n330 CHAPTER 16. CRISP DETERMINIZATION\nsemantics coincide cf. Corollary 5.3.3(2)).\nAlso a kind of reverse of Lemma 16.1.1 holds.\nCorollary 16.1.5. [Rad10, Lm. 6.1] If for each ranked alphabet \u03a3, each (\u03a3,B)-wta A is initial algebra crisp determinizable, then B is locally finite.\nProof. Let A \u2286 B be a finite set. Let \u03a3 be a ranked alphabet such that |\u03a3(0)| \u2265 |A \u222a {0, 1}| and |\u03a3(2)| \u2265 2. By Theorem 3.1.5, we can construct a (\u03a3,B)-wta A such that im([[A]]init) = \u3008A\u3009{\u2295,\u2297,0,1}. Since, by assumption, A is initial algebra crisp determinizable, we have that [[A]]init is a recognizable step mapping (by Theorem 10.3.1). Thus the set im([[A]]init) is finite (by definition). Hence \u3008A\u3009{\u2295,\u2297,0,1} is finite, which means that B is locally finite.\nHence we obtain the following equivalence between local finiteness and initial algebra crisp determinizability (where the equivalence with Statement (C) is due to [Dro22]).\nTheorem 16.1.6. Let B be a strong bimonoid. Then the following three statements are equivalent. (A) B is locally finite. (B) For each ranked alphabet \u03a3 and each (\u03a3,B)-wta A, we can construct a crisp deterministic (\u03a3,B)-\nwta B such that [[A]]init = [[B]]. (C) For each ranked alphabet \u03a3 and each (\u03a3,B)-wta A, the set im([[A]]init) is finite.\nProof. Proof of (A)\u21d2(B): This follows from Theorem 16.1.3.\nProof of (B)\u21d2(C): This follows from Theorem 10.3.1.\nProof of (C)\u21d2(A): We prove by contraposition. Assume that B is not locally finite. Then there exists a finite subset A \u2286 B such that \u3008A\u3009{\u2295,\u2297,0,1} is infinite. Let \u03a3 be a ranked alphabet such that |\u03a3(0)| \u2265 |A \u222a {0, 1}| and |\u03a3(2)| \u2265 2. By Theorem 3.1.5, we can construct a (\u03a3,B)-wta A such that im([[A]]init) = \u3008A\u3009{\u2295,\u2297,0,1}. Hence (C) does not hold.\nA special case of Theorem 16.1.6 was proved in [Be\u030cl02, Thm. 2.1] for the case of string ranked alphabets (i.e., weighted automata) and complete distributive lattices (cf. the remark on p.328). Moreover, it is easy to see that the Viterbi semiring ([0, 1],max, \u00b7, 0, 1) is not locally finite. Hence, by Theorem 16.1.6, there exists a ranked alphabet \u03a3 and a (\u03a3,Viterbi)-wta A such that im([[A]]) is infinite. The wsa in [LP05, Ex. 3.1] can be thought of as such a wta. Also we note that [LP05, Thm. 3.4] is a special case of Theorem 16.1.6(A)\u21d4(B) for lattice-ordered monoids."
        },
        {
            "heading": "16.2 Run crisp determinization",
            "text": "In this section we will prove a sufficient condition under which a (\u03a3,B)-wta A is run crisp determinizable (cf. Theorem 16.2.6). We will continue with two characterizations of this property (cf. Theorems 16.2.7 and 16.2.13), where the first one deals with arbitrary strong bimonoids and the second one with past-finite monotonic strong bimonoids."
        },
        {
            "heading": "16.2.1 Sufficient condition for run crisp determinizability",
            "text": "Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. We recall that, for each \u03be \u2208 T\u03a3, we have\n[[A]]run(\u03be) = \u2295\n\u03c1\u2208RA(\u03be)\nwt(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) .\n16.2. RUN CRISP DETERMINIZATION 331\nIn contrast to the initial algebra semantics, multiplication and summation are not used alternatingly but first multiplication is used (for the computation of wt(\u03be, \u03c1) \u2297 F\u03c1(\u03b5)) and second summation is used. In the following we will formulate a sufficient condition for run crisp determinizability of A which is based on the values which occur in the computation of [[A]]run and on structural properties of A.\nFor the following discussion we recall the definition H(A) = {wt(\u03be, \u03c1) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be)} (cf. (7.15 of Section 7.4) and define the set\nC(A) = {wt(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be)} . (16.2)\nClearly, if the set H(A) is finite, then C(A) is also finite, because C(A) \u2286 H(A) \u2297 im(F ).\nLemma 16.2.1. [DFKV22, Lm. 6.5] Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. If H(A) is finite, then we can construct the set C(A).\nProof. Let H(A) be finite. By Lemma 7.4.1, we construct the set H(A). We recall that in the proof of that lemma, for every n \u2208 N and q \u2208 Q, we construct the set\nHn,q = {wt(\u03be, \u03c1) | \u03be \u2208 T\u03a3, height(\u03be) \u2264 n, \u03c1 \u2208 RA(q, \u03be)} ,\nand denote by nm \u2208 N the least number such that Hnm,q = Hnm+1,q for each q \u2208 Q.\nNow we prove that the set C(A) can be constructed. Let nm be the number as before and\nC = {wt(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) | \u03be \u2208 T\u03a3, height(\u03be) \u2264 nm, \u03c1 \u2208 RA(\u03be)} .\nIt suffices to show that C = C(A) because we can construct the set C. It is obvious that C \u2286 C(A). For the proof of the other inclusion, let b \u2208 C(A), i.e., b = wt(\u03be, \u03c1) \u2297 Fq for some \u03be \u2208 T\u03a3, q \u2208 Q, and \u03c1 \u2208 RA(q, \u03be). Since wt(\u03be, \u03c1) \u2208 H(A), by the proof of constructing the set H(A) (cf. Lemma 7.4.1), we have wt(\u03be, \u03c1) \u2208 Hnm,q, i.e., there exist \u03be\n\u2032 \u2208 T\u03a3 with height(\u03be\u2032) \u2264 nm, and \u03c1\u2032 \u2208 RA(q, \u03be\u2032) such that wt(\u03be, \u03c1) = wt(\u03be\u2032, \u03c1\u2032). Hence b \u2208 C.\nWe continue with an analysis of im([[A]]run). We can achieve that im([[A]]run) is finite if we guarantee that (a) the set C(A) is finite and (b) there exists an upper bound K such that each b \u2208 C(A) is summed up at most K times. To express this more precisely, for each b \u2208 C(A), we define the mapping fA,b : T\u03a3 \u2192 N, called complete run number mapping of b, such that for each \u03be \u2208 T\u03a3 we let\nfA,b(\u03be) = |{\u03c1 \u2208 RA(\u03be) | wt(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = b}| .\nWe recall from (2.15) that, for each n \u2208 N, the value nb is the sum b\u2295 . . .\u2295 b with n summands. Finally, we define the (\u03a3,B)-weighted tree language\nrA,b : T\u03a3 \u2192 B with rA,b(\u03be) = (fA,b(\u03be))b for each \u03be \u2208 T\u03a3 .\nThus, if C(A) is finite, then for each \u03be \u2208 T\u03a3, we have\n[[A]]run(\u03be) = \u2295\nb\u2208C(A)\n(fA,b(\u03be))b = \u2295\nb\u2208C(A)\nrA,b(\u03be) . (16.3)\nOverall, if C(A) is finite and rA,b is a recognizable step mapping for each b \u2208 C(A), then [[A]]run is a recognizable step mapping (because recognizable step mappings are closed under sum, cf. Corollary 10.3.2).\nIn order to find out under which conditions rA,b is a recognizable step mapping (cf. Lemma 16.2.5), we first prove that fA,b is an r-recognizable (\u03a3,N)-weighted tree language. For this we use the set H(A). The next lemma generalizes [DSV10, Thm. 11] and [DGMM11, Thm. 6.2(a)] from the string case to the tree case.\n332 CHAPTER 16. CRISP DETERMINIZATION\nLemma 16.2.2. [DFKV22, Thm. 6.6] Let A be a (\u03a3,B)-wta. If H(A) is finite, then for each b \u2208 C(A) we can construct a (\u03a3,N)-wta A\u2032b such that [[A \u2032 b]] = fA,b.\nProof. Let H(A) be finite. By Lemma 7.4.1, we construct H(A). Let b \u2208 C(A). We define the (\u03a3,N)-wta A\u2032b = (Q \u2032, \u03b4\u2032, F \u2032b) as follows: Q \u2032 = Q\u00d7H(A) and for every k \u2208 N, \u03c3 \u2208 \u03a3(k) and (q1, y1), . . . , (qk, yk), (q, y) \u2208 Q\u2032, let\n\u03b4\u2032k ( (q1, y1) \u00b7 \u00b7 \u00b7 (qk, yk), \u03c3, (q, y) ) =\n{ 1 if (\u2297 i\u2208[k] yi ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) = y\n0 otherwise,\nand let\n(F \u2032b)(q,y) =\n{ 1 if y \u2297 Fq = b\n0 otherwise.\nLet \u03be \u2208 T\u03a3 and b \u2208 C(A). It is obvious that,\nfor each \u03c1 \u2208 RA\u2032 b (\u03be), we have wtA\u2032 b (\u03be, \u03c1) \u00b7 (F \u2032b)\u03c1\u2032(\u03b5) \u2208 {0, 1} . (16.4)\nNext we observe that there exists a bijection between the two sets\n{\u03c1 \u2208 RA(\u03be) | wtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = b} and {\u03c1 \u2032 \u2208 RA\u2032 b (\u03be) ) | wtA\u2032 b (\u03be, \u03c1\u2032) \u00b7 (F \u2032b)\u03c1\u2032(\u03b5) = 1} .\nThen it follows that\nfA,b(\u03be) = |{\u03c1 \u2208 RA(\u03be) | wtA(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) = b}|\n= |{\u03c1\u2032 \u2208 RA\u2032 b (\u03be) | wtA\u2032 b (\u03be, \u03c1\u2032) \u00b7 (F \u2032b)\u03c1\u2032(\u03b5) = 1}| = \u2295\n\u03c1\u2032\u2208RA\u2032 b (\u03be):\nwtA\u2032 b (\u03be,\u03c1\u2032)\u00b7(F \u2032b)\u03c1\u2032(\u03b5)=1\n1\n= \u2295\n\u03c1\u2032\u2208RA\u2032 b (\u03be)\nwtA\u2032 b (\u03be, \u03c1\u2032) \u00b7 (F \u2032b)\u03c1\u2032(\u03b5) (by (16.4))\n= [[A\u2032b]](\u03be)\nNext we analyse the preimage of fA,b = [[A\u2032b]], where A \u2032 b is the (\u03a3,Nat)-wta of Lemma 16.2.2. For this we prove two preimage theorems for the case that B is the semiring of natural numbers (cf. Lemmas 16.2.3 and 16.2.4) where the first one is generalization of [BR88, Cor. III.2.5].\nLemma 16.2.3. (cf. [DV06, Lm. 6.3(2)] and [DFKV22, Lm. 6.3]) Let A be a (\u03a3,Nat)-wta. Then [[A]] has the preimage property and, for each n \u2208 N, we can construct a \u03a3-fta A such that L(A) = [[A]]\u22121(n).\nProof. Let n \u2208 N and M = {k \u2208 N | k > n}. Moreover, we let \u223c be the equivalence relation on the set N defined such that its n+ 2 classes are the singleton sets {k} for each k \u2208 [0, n] and the set M .\nAs is well known, \u223c is a congruence relation on the semiring of natural numbers, which can be seen as follows. Let n1, n2, n \u2032 1, n \u2032 2 \u2208 N such that n1 \u223c n \u2032 1 and n2 \u223c n \u2032 2. Since, for each k \u2208 N with k \u2264 n, the equivalence class {k} is a singleton and Nat is commutative, the only interesting case arises if n1, n\u20321 \u2208M . So we assume that n1, n \u2032 1 \u2208 M . For the summation, we obviously have n1 \u2264 n1 + n2 and n \u2032 1 \u2264 n \u2032 1 + n \u2032 2, and hence n1 + n2 \u2208 M and n\u20321 + n \u2032 2 \u2208 M . For the multiplication, if n2 6= 0 6= n \u2032 2, then similarly we obtain that n1 \u00b7 n2 \u2208M and n\u20321 \u00b7 n \u2032 2 \u2208M . If n2 = 0 = n \u2032 2, then n1 \u00b7 n2 \u2208 {0} and n \u2032 1 \u00b7 n \u2032 2 \u2208 {0}. Hence \u223c is a congruence relation on Nat.\nSince \u223c has finite index, the quotient semiring Nat/\u223c is finite. Let h : N \u2192 N/\u223c be the canonical semiring homomorphism, i.e., h(n) = [n]\u223c for each n \u2208 N. Then, by Theorem 10.9.3, the (\u03a3,Nat/\u223c)weighted tree language h \u25e6 [[A]] is recognizable, and by Corollary 16.1.4 we have that (h \u25e6 [[A]])\u22121({n}) is\n16.2. RUN CRISP DETERMINIZATION 333\na \u03a3-recognizable tree language for each n \u2208 N. Since (h \u25e6 [[A]])\u22121({n}) = [[A]]\u22121(n) for each n \u2208 N, we obtain that [[A]] has the preimage property.\nClearly, we can give effectively the congruence classes of \u223c, i.e., the elements of N/\u223c, by choosing only one representative for each congruence class. By Lemma 10.9.2 and the obvious fact that h(A) is constructable, we can construct the (\u03a3,Nat/\u223c)-wta h(A) such that [[h(A)]] = h \u25e6 [[A]]. Since N/\u223c is finite, by Corollary 16.1.4, we can construct a finite-state \u03a3-tree automatonA which recognizes [[h(A)]]\u22121({n}) = [[A]]\u22121(n).\nIn the next lemma we deal with the preimage of a set under a recognizable weighted tree language over the semiring of natural numbers. For the sake of simplicity, we call this theorem also preimage theorem. It is a generalization of [BR88, Cor. III.2.4]. For every m \u2208 N and n \u2208 N+, we define\nm+ n \u00b7 N = {m+ n \u00b7 j | j \u2208 N} .\nMoreover, for each m \u2208 N, we let m = m + nN, the equivalence class of m modulo n. The semiring of natural numbers modulo n is the semiring Nat/nNat = ({0, . . . , n\u2212 1},+n, \u00b7n, 0, 1}), where for every k, \u2113 \u2208 [0, n\u2212 1] we define k +n \u2113 = k + \u2113 mod (n) and k \u00b7n \u2113 = k \u00b7 \u2113 mod (n).\nLemma 16.2.4. (cf. [DV06, Lm. 6.3(2)] and [DFKV22, Lm. 6.4]) Let A be a (\u03a3,Nat)-wta. Moreover, let m \u2208 N and n \u2208 N+. Then (a) the \u03a3-tree language [[A]]\u22121(m + n \u00b7 N) is recognizable and (b) we can construct a \u03a3-fta A such that L(A) = [[A]]\u22121(m+ n \u00b7 N).\nProof. Proof of (a): Let m \u2208 N and n \u2208 N+. If m < n, then, by Theorem 10.9.3, (h \u25e6 [[A]]) \u2208 Rec(\u03a3,Nat/nNat), where h : N \u2192 N/nN is the canonical semiring homomorphism. Moreover, [[A]]\u22121(m+ n \u00b7N) = [[A]]\u22121 ( h\u22121(m) ) = (h \u25e6 [[A]])\u22121(m). Since Nat/nNat is a finite semiring, by Corollary 16.1.4, the \u03a3-tree language (h \u25e6 [[A]])\u22121(m) is recognizable. Now assume that m \u2265 n. Then there exist m\u2032 \u2208 [0, n\u2212 1] and k \u2208 N+ such that m = m\u2032 + n \u00b7 k. Then\n[[A]]\u22121(m+ n \u00b7 N) = [[A]]\u22121(m\u2032 + n \u00b7 N) \\ k\u22121\u22c3\nj=0\n[[A]]\u22121(m\u2032 + n \u00b7 j) . (16.5)\nAs we saw, the \u03a3-tree language [[A]]\u22121(m\u2032 + n \u00b7 N) is recognizable because m\u2032 < n. Moreover, by Lemma 16.2.3, for each j \u2208 [0, k \u2212 1], the \u03a3-tree language [[A]]\u22121(m\u2032 + n \u00b7 j) is also recognizable. Finally, \u03a3-tree languages are closed under union and subtraction (cf. Theorem 2.13.3). Thus, also in this case, the \u03a3-tree language [[A]]\u22121(m+ n \u00b7 N) is recognizable.\nProof of (b): We follow the proof of (a). Let m \u2208 N. Assume that m < n. Obviously, we can give effectively the equivalence classes modulo n, i.e., the elements of N/nN, by choosing only one representative for each equivalence class. Then we can construct the (\u03a3,Nat/nNat)-wta h(A) (cf. page 213). By Lemma 10.9.2 we have [[h(A)]] = h \u25e6 [[A]].\nSince Nat/nNat is a finite semiring, by Corollary 16.1.4, we can construct a \u03a3-fta which recognizes (h \u25e6 [[A]])\u22121(m) = [[A]]\u22121(m+ n \u00b7 N).\nNow assume that m \u2265 n. Since m\u2032 < n, by the above, we can construct a \u03a3-fta which recognizes [[A]]\u22121(m\u2032 + n \u00b7 N). Moreover, by Lemma 16.2.3, for each j \u2208 [0, k \u2212 1], we can also construct a \u03a3-fta which recognizes [[A]]\u22121(m\u2032 + n \u00b7 j). Thus, for each tree language which occurs on the right-hand side of (16.5) a \u03a3-fta can be constructed. Hence, by Theorem 2.13.3, we can construct a \u03a3-fta which recognizes [[A]]\u22121(m+ n \u00b7 N).\nNow we have collected the necessary preimage theorems to show that, for each (\u03a3,B)-wta A and b \u2208 C(A), the mapping rA,b is a recognizable step mapping if fA,b is bounded or b has finite additive order (cf. Lemma 16.2.5).\nWe call the mapping fA,b bounded if there exists K \u2208 N such that fA,b(\u03be) \u2264 K for each \u03be \u2208 T\u03a3.\nAn element b \u2208 B has finite additive order if \u3008b\u3009{\u2295} is finite. If this is the case, then there exists a least number i \u2208 N+ such that ib = (i + k)b for some k \u2208 N+, and there exists a least number p \u2208 N+ such that ib = (i + p)b. We call i and p the index (of b) and the period (of b), respectively, and denote them by i(b) and p(b), respectively. Moreover, we call i+p\u22121, i.e., the number of elements of \u3008b\u3009{\u2295}, the additive order of b (cf. Figure 16.1). In particular, the additive order of 0 is 1 because i(0) = p(0) = 1.\nLemma 16.2.5. [DFKV22, Thm. 6.6] Let A be a (\u03a3,B)-wta such that H(A) is finite and let b \u2208 C(A). If the mapping fA,b is bounded or b has finite additive order, then we can construct a crisp deterministic (\u03a3,B)-wta Bb such that [[Bb]] = rA,b.\nProof. By performing Algorithm 3, a crisp deterministic (\u03a3,B)-wta Bb is constructed.\nWe prove that [[Bb]] = rA,b. If, before execution of line 3, the variable i has the value \u2113, then the family (Ab,j | j \u2208 [0, \u2113\u2212 1]) of \u03a3-fta has already been constructed by using Lemma 16.2.3; in particular, if \u2113 = 0, then this family is empty. Thus, after execution of line 3, the family (Ab,j | j \u2208 [0, \u2113]) of \u03a3-fta has been constructed (where Ab,\u2113 is also constructed by Lemma 16.2.3).\nThen, line 4 asks whether the mapping fA,b is bounded by \u2113 (i.e., T\u03a3 \u2286 \u22c3 j\u2208[0,\u2113] L(Ab,j); due to [GS84,\nThm. 2.10.3] this is decidable). If so, then the for-loop is exited with K = \u2113.\nIf not, then line 6 asks whether b has finite additive order \u2113 (i.e., \u2113b = jb for some j < \u2113). If so, then \u2113 = min(\u2113\u2032 | \u2203j < \u2113\u2032 : \u2113\u2032b = jb) and the index i(b) of b and the period p(b) of b are constructed and, due to lines 8-10, the upper part (Ab,j | j \u2208 [i(b), i(b) + p(b) \u2212 1]) of the family of \u03a3-fta (generated in line 3 is reconstructed by using Lemma 16.2.4. Thereafter the for-loop is exited with K = \u2113. (We note that K = i(b) + p(b)\u2212 1, i.e., K is the finite additive order of b.)\nSince, by our assumption, the mapping fA,b is bounded or b has finite additive order, the for-loop in lines 2-13, will eventually terminate.\nIf the for-loop in lines 2-13 was terminated due to the exit in line 4, then the family (Ab,j | j \u2208 [0,K]) of \u03a3-fta was constructed such that L(Ab,j) = [[A\u2032b]]\n\u22121(j) for each j \u2208 [0,K]. Thus, due to line 1, for each j \u2208 [0,K] and \u03be \u2208 T\u03a3, we have: \u03be \u2208 L(Ab,j) iff fA,b(\u03be) = j. Hence L(Ab,j) \u2229 L(Ab,j\u2032) = \u2205 for every j, j\u2032 \u2208 [0,K] with j 6= j\u2032, and for each \u03be \u2208 T\u03a3 there exists j \u2208 [0,K] such that \u03be \u2208 L(Ab,j); that means that the family (L(Ab,j) | j \u2208 [0,K]) is a partitioning of T\u03a3. Since rA,b(\u03be) = (fA,b(\u03be))b for each \u03be \u2208 T\u03a3, we finally obtain\nrA,b = \u2295\nj\u2208[0,K]\n(jb)\u2297 \u03c7(L(Ab,j)) .\nIf the for-loop in lines 2-13 was terminated due to the exit in line 11, then the family (Ab,j | j \u2208 [0,K]) of \u03a3-fta was constructed such that\n\u2022 L(Ab,j) = [[A \u2032 b]] \u22121(j) for each j \u2208 [0, i(b)\u2212 1] and \u2022 L(Ab,j) = [[A\u2032b]] \u22121(j + p(b) \u00b7 N) for each j \u2208 [i(b),K].\nThus, due to line 1,\n\u2022 for each j \u2208 [0, i(b)\u2212 1] and \u03be \u2208 T\u03a3, we have: \u03be \u2208 L(Ab,j) iff fA,b(\u03be) = j.\n16.2. RUN CRISP DETERMINIZATION 335\nAlgorithm 3 Construction of the cd (\u03a3,B)-wta Bb such that [[Bb]] = rA,b (cd=crisp deterministic)\nInput: (a) (\u03a3,B)-wta A such that H(A) is finite and (b) b \u2208 C(A) such that fA,b is bounded or b has finite additive order Output: cd (\u03a3,B)-wta Bb 1: by applying Lemma 16.2.2 to A, we construct the (\u03a3,Nat)-wta A\u2032b s.t. [[A \u2032 b]] = fA,b;\n2: for each i = 0, 1, 2, . . . do 3: by applying Lemma 16.2.3 to A\u2032b, we construct the \u03a3-fta Ab,i s.t. L(Ab,i) = [[A \u2032 b]]\n\u22121(i); 4: if T\u03a3 \u2286 \u22c3 j\u2208[0,i] L(Ab,j) then let K \u2190 i and exit the for-loop; \u22b2 fb,A is bounded by K 5: end if 6: if ib = jb for some j < i then 7: i(b)\u2190 min(j \u2208 N+ | j < i and jb = ib) and p(b)\u2190 i\u2212 i(b); \u22b2 construct the index and period of b 8: for each j \u2208 [i(b), i(b) + p(b)\u2212 1] do 9: by applying Lemma 16.2.4 to A\u2032b, we construct the \u03a3-fta Ab,j s.t. L(Ab,j) = [[A \u2032 b]]\n\u22121(j+p(b) \u00b7N) 10: end for 11: let K \u2190 i(b) + p(b)\u2212 1 and exit the for-loop \u22b2 b has additive order K 12: end if 13: end for\n14: for each j \u2208 [0,K] do 15: by applying Theorem 4.3.6(B)\u21d2(C) to Ab,j , we construct the cd (\u03a3,B)-wta Cb,j s.t.\n[[Cb,j ]] = \u03c7(L(Ab,j)) ;\n16: by applying Theorem 10.2.1(4) to jb and Cb,j , we construct the cd (\u03a3,B)-wta Db,j s.t.\n[[Db,j ]] = (jb)\u2297 [[Cb,j ]] ;\n17: end for 18: by applying iteratively Theorem 10.1.1(2) to the members of the finite family (Db,j | j \u2208 [0,K]), we\nconstruct the cd (\u03a3,B)-wta Bb s.t.\n[[Bb]] = \u2295\nj\u2208[0,K]\n[[Db,j ]] .\n19: return Bb\n\u2022 for each j \u2208 [i(b),K] and \u03be \u2208 T\u03a3, we have: \u03be \u2208 L(Ab,j) iff fA,b(\u03be) \u2208 (j + p(b) \u00b7 N).\nHence also in this case the family (L(Ab,j) | j \u2208 [0,K]) is a partitioning of T\u03a3 and as above we obtain\nrA,b = \u2295\nj\u2208[0,K]\n(jb)\u2297 \u03c7(L(Ab,j)) .\nIn lines 14-17, the family (Db,j | j \u2208 [0,K]) of crisp deterministic (\u03a3,B)-wta is constructed such that\n[[Db,j ]] = (jb)\u2297 \u03c7(L(Ab,j)) .\nFinally, in line 18, the crisp deterministic (\u03a3,B)-wta Bb is constructed such that [[Bb]] = \u2295\nj\u2208[0,K][[Db,j ]]. Hence\n[[Bb]] = \u2295\nj\u2208[0,K]\n(jb)\u2297 \u03c7(L(Ab,j)) = rA,b .\n336 CHAPTER 16. CRISP DETERMINIZATION\nNext we can show the main theorem of this section. It originated from [DSV10, Thm. 11].\nTheorem 16.2.6. [DFKV22, Thm. 6.6] Let \u03a3 be a ranked alphabet, B be a strong bimonoid, and A be a (\u03a3,B)-wta such that H(A) is finite. If, for each b \u2208 C(A), the mapping fA,b is bounded or b has finite additive order, then we can construct a crisp deterministic (\u03a3,B)-wta B such that [[A]]run = [[B]].\nProof. Since H(A) is finite, also C(A) is finite. By Lemma 16.2.1, we construct C(A). Then, by Lemma 16.2.5, for each b \u2208 C(A), we construct a crisp deterministic (\u03a3,B)-wta Bb such that [[Bb]] = rA,b. Then by (16.3), we have [[A]]run = \u2295 b\u2208C(A)[[Bb]]. Hence, by Theorem 10.1.1(2), we can construct a crisp deterministic (\u03a3,B)-wta B such that [[A]]run = [[B]].\nThere is a slight alternative to the construction in the proof of Theorem 16.2.6 if B is bi-locally finite. Instead of computing the sets H(A) and C(A) (by Lemmas 7.4.1 and 16.2.1), we can construct the set \u3008wts(A)\u3009{\u2297} (by Lemma 2.6.1). Then we could replace, in Lemmas 16.2.2 and 16.2.5, the sets H(A) and C(A) by the set \u3008wts(A)\u3009{\u2297}, and we are also able to construct a crisp deterministic wta which is run-equivalent to A. However, this modified construction has the disadvantage that, in the construction of A\u2032b in Lemma 16.2.2, its state space contains, in general, too many useless states, because many of the elements of \u3008wts(A)\u3009{\u2297} cannot be generated by A. Note, however, that bi-local finiteness is a very strong restriction. In contrast, Theorem 16.2.6 holds for all strong bimonoids and gives a structural condition for the wta A which ensures its crisp determinizability."
        },
        {
            "heading": "16.2.2 Equivalence of bi-local finiteness and run crisp determinizability",
            "text": "First we recall, for a (\u03a3,B)-wta A = (Q, \u03b4, F ), the definitions\nH(A) = {wt(\u03be, \u03c1) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be)} and C(A) = {wt(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be)} .\nThen we can prove the following characterization of bi-locally finiteness in terms of crisp determinization, where the equivalence with Statement (C) is due to [Dro22]. It can be compared directly to Theorem 16.1.6. For the comparison we recall that each locally finite strong bimonoid is bi-locally finite, but not vice versa (cf. the Euler diagram in Figure 2.5). We note that in Lemma 3.1.2 we have already proved that (A)\u21d2(C).\nTheorem 16.2.7. (cf. [FKV21, Cor. 7.7]) Let B be a strong bimonoid. Then the following three statements are equivalent. (A) B is bi-locally finite. (B) For every ranked alphabet \u03a3 and (\u03a3,B)-wta A, we can construct a crisp deterministic (\u03a3,B)-wta B\nsuch that [[A]]run = [[B]]. (C) For every ranked alphabet \u03a3 and (\u03a3,B)-wta A, the set im([[A]]run) is finite.\nThus, in particular, if B is bi-locally finite, then Recrun(\u03a3,B) \u2286 Recinit(\u03a3,B). Moreover, if B is locally finite, then Recrun(\u03a3,B) = Recinit(\u03a3,B).\nProof. Proof of (A)\u21d2(B): Since B is bi-locally finite, the set H(A) is finite and each b \u2208 C(A) has finite additive order. Hence the statement follows from Theorem 16.2.6.\nProof of (B)\u21d2(C): It follows from Theorem 10.3.1(A)\u21d2(C).\nProof of (C)\u21d2(A): This can be obtained by an easy adaptation of [DSV10, Lm. 12] from weighted string automata to wta over string ranked alphabet as follows.\nFirst we show that the additive monoid (B,\u2295, 0) is locally finite. Since \u2295 is commutative and associative, it suffices to show that, for each b \u2208 B, the monoid \u3008b\u3009{\u2295} is finite. Thus, let b \u2208 B and\n16.2. RUN CRISP DETERMINIZATION 337\n\u03a3 = {\u03b3(1), \u03b1(0)}. We construct the (\u03a3,B)-wta A = (Q, \u03b4, F ), where Q = {p, q}, Fp = 0, Fq = 1, and \u03b4 is defined as follows (cf. Figure 16.2):\n\u2022 \u03b40(\u03b5, \u03b1, p) = \u03b41(p, \u03b3, p) = \u03b41(q, \u03b3, q) = 1, \u2022 \u03b41(p, \u03b3, q) = b, and \u2022 \u03b40(\u03b5, \u03b1, q) = \u03b41(q, \u03b3, p) = 0.\nThen, for each n \u2208 N, we have [[A]]run(\u03b3n(\u03b1)) = nb (cf. (2.15)). Hence, \u3008b\u3009{\u2295} \u2286 im([[A]] run). By (C), the set im([[A]]run) is finite. Hence \u3008b\u3009{\u2295} is also finite.\nNext we prove that the multiplicative monoid (B,\u2297, 1) is locally finite. Let n \u2208 N and b1, . . . , bn \u2208 B. We show that the set\nB\u2032 = {bl1 \u2297 . . .\u2297 blm | m \u2208 N, l1, . . . , lm \u2208 [n]}\nis finite. Let \u03a3 = {\u03b3 (1) 1 , \u03b3 (1) 2 , \u03b2 (0)}. We construct the (\u03a3,B)-wta A\u2032 = (Q\u2032, \u03b4\u2032, F \u2032) with Q\u2032 = {q0, . . . , qn}, F \u2032q0 = 1 and F \u2032 q = 0 for every q \u2208 Q \\ {q0}, and \u03b4 \u2032 is defined as follows (cf. Figure 16.3):\n\u2022 \u03b4\u20320(\u03b5, \u03b2, q0) = 1, \u2022 \u03b4\u20321(qi\u22121, \u03b31, qi) = 1 for each i \u2208 [n], \u2022 \u03b4\u20321(qi, \u03b32, q0) = bi for each i \u2208 [n], and \u2022 \u03b4\u2032k(q \u2032 1 \u00b7 \u00b7 \u00b7 q \u2032 k, \u03c3, q \u2032) = 0 for each other combination of k \u2208 N, \u03c3 \u2208 \u03a3(k) and q\u20321 \u00b7 \u00b7 \u00b7 q \u2032 k \u2208 Q k and q\u2032 \u2208 Q\u2032.\nHence, [[A\u2032]]run(\u03b32\u03b3 lm 1 \u03b32\u03b3 lm\u22121 1 \u03b32 . . . \u03b3 l1 1 \u03b2) = bl1 \u2297 . . . \u2297 blm for every m \u2208 N and l1, . . . , lm \u2208 [n]. Thus B\u2032 \u2286 im([[A\u2032]]run). By (C), the set im([[A\u2032]]run) is finite, and therefore B\u2032 is finite. Hence (C)\u21d2 (A).\nFor the proof of the next statement, let A be a (\u03a3,B)-wta. If B is bi-locally finite, then by (A)\u21d2(B) we can construct a crisp deterministic (\u03a3,B)-wta B such that [[A]]run = [[B]]. Since, in particular, [[B]] = [[B]]init, we have Recrun(\u03a3,B) \u2286 Recinit(\u03a3,B).\nIf B is locally finite, then this inclusion together with Theorem 16.1.3(2) imply that Recrun(\u03a3,B) = Recinit(\u03a3,B).\nAs a consequence of Theorem 16.2.7(A)\u21d2(B) and Theorem 10.3.1 (A)\u21d2(C), we show one more preimage theorem.\n338 CHAPTER 16. CRISP DETERMINIZATION\nCorollary 16.2.8. [DFKV22, Cor. 6.9] Let B be bi-locally finite and A a (\u03a3,B)-wta. Then, for each b \u2208 B, we can construct a \u03a3-fta A such that L(A) = ([[A]]run)\u22121(b)."
        },
        {
            "heading": "16.2.3 Characterization of run crisp determinizability for past-finite monotonic strong bimonoids",
            "text": "In this subsection we show a characterization of run crisp determinizability for wta over past-finite monotonic strong bimonoids (cf. Theorem 16.2.13). Each past-finite monotonic strong bimonoid shares many properties with the semiring of natural numbers, like (a) having a partial order on its carrier set (which is not necessarily total), (b) being zero-sum free and zero-divisor free, (c) monotonicity of its operations with respect to that partial order, and (d) a strong kind of well-foundedness (called pastfiniteness). However, in general, distributivity is not required and also does not follow from the axioms. The idea of past-finite strong bimonoids and the characterization stems from [DFKV22].\nFirst we define these strong bimonoids. Let (B, ) be a partially ordered set. We say that is past-finite if for each b \u2208 B the set past(b) = {a \u2208 B | a b} is finite. In the sequel, we write a \u227a b if a b and a 6= b.\nThus, for each past-finite partial order , the relation \u227a is well-founded. However, there exists a well-founded relation \u227a such that the relation (defined by a b if a \u227a b or a = b) is a partial order and it is not past-finite. For instance, let B = {b, a1, a2, . . .} and \u227a= {(a1, b), (a2, b), . . .}.\nLet us consider a strong bimonoid B and let be a partial order on B. We say that B is monotonic with respect to (cf. [BFGM05, Def. 5] and [DFKV22]) if\nfor every a, b \u2208 B, we have a a\u2295 b and (16.6)\nfor every a, b, c \u2208 B \\ {0} with b 6= 1 we have: a\u2297 c \u227a a\u2297 b\u2297 c . (16.7)\nFrom (16.7) we easily obtain that\nfor every a, b \u2208 B \\ {0} with b 6= 1 we have: a \u227a a\u2297 b and a \u227a b\u2297 a . (16.8)\nIf B is monotonic with respect to , then we also write that (B, ) = (B,\u2295,\u2297, 0, 1, ) is a monotonic strong bimonoid. A monotonic strong bimonoid (B, ) has several properties [BFGM05, Lm. 14].\nLemma 16.2.9. If (B, ) is a monotonic strong bimonoid, then\n(1) 0 b for each b \u2208 B, and 1 b for each b \u2208 B \\ {0}, (2) B is positive, i.e., zero-sum free and zero-divisor free, (3) B is one-summand free, i.e., for every a, b \u2208 B if a\u2295 b = 1, then a, b \u2208 {0, 1}, and (4) B is one-product free, i.e., for every a, b \u2208 B if a\u2297 b = 1, then a = b = 1.\nProof. Let a, b \u2208 B.\nProof of (1): By (16.6), we obtain 0 0\u2295 b = b. If b 6= 0, then by (16.8), 1 1\u2297 b = b.\nProof of (2): First we prove zero-sum freeness. Let b \u2208 B \\ {0}. Then, by Item (1) and (16.6), we have 0 \u227a b a\u2295 b. Hence B is zero-sum free.\nNext we show zero-divisor freeness. Let a, b \u2208 B \\ {0}. Then, by Item (1) and (16.8), 0 \u227a a a\u2297 b. Thus B is zero-divisor free.\nProof of (3): Assume that a /\u2208 {0, 1}. Then, by (1) and (16.6), we obtain 1 \u227a a a\u2295 b. Hence B is one-summand free.\nProof of (4): We show by contradiction that a\u2297 b = 1 implies a = 1 and b = 1. Assume that a 6= 1 or b 6= 1 and a\u2297 b = 1. Apparently, a, b \u2208 B \\ {0}. Hence by (1) and (16.8) we obtain 1 b \u227a a\u2297 b or 1 a \u227a a\u2297 b. This contradicts to a\u2297 b = 1. Consequently, B is one-product free.\n16.2. RUN CRISP DETERMINIZATION 339\nLemma 16.2.9(1) and (16.8) imply that, for each b \u2208 B \\{0, 1} and n \u2208 N, we have 0 \u227a 1 \u227a bn \u227a bn+1, i.e.,\n0 \u227a 1 \u227a b \u227a b\u2297 b \u227a b\u2297 b\u2297 b \u00b7 \u00b7 \u00b7 .\nHence, if (B, ) is a finite monotonic strong bimonoid, then B has only two elements 0 and 1, we have 0 \u227a 1 and 1\u2295 1 = 1. Thus B is isomorphic to the Boolean semiring Boole.\nWe call a monotonic strong bimonoid (B,\u2295,\u2297, 0, 1, ) past-finite if (B, ) is past-finite. In [DFKV22, Ex. 2.2-2.4] a number of past-finite monotonic strong bimonoids are shown. Here we only mention the following examples:\n(a) the semiring (Boole,\u2264), where 0 \u2264 1, (b) the semiring (Nat,\u2264) of natural numbers, where \u2264 is the common relation \u201cless than or equal to\u201d\non N, (c) the semiring (Natmax,+,\u2264), where \u2264 is the natural extension of \u2264 to N\u2212\u221e, (d) the semiring (Pf(\u0393 \u2217),\u222a, \u00b7, \u2205, {\u03b5}, ) where Pf(\u0393 \u2217) is the set of finite subsets of \u0393\u2217 and L1 L2 if\nthere exists an injective mapping f : L1 \u2192 L2 such that w is a substring of f(w) for each w \u2208 L1, (e) the semiring (Pf(N),\u222a,+, \u2205, {0}, ) where Pf(N) is the set of finite subsets of N, the operation + is\nextended in the usual way to sets, and N1 N2 if there exists an injective mapping f : N1 \u2192 N2 such that n \u2264 f(n) for each n \u2208 N1, and (f) the plus-plus strong bimonoid (PPN,\u2264) = (N0,\u2295,+, 0, 0,\u2264) of natural numbers (cf. Example 2.6.10), where \u2264 is the usual order on N together with 0 \u2264 x for each x \u2208 N. Then (PPN,\u2264) is a past-finite monotonic strong bimonoid which is not a semiring.\nThe set of past-finite monotonic strong bimonoids shares another property with the semiring of natural numbers (cf. Lemma 16.2.3).\nTheorem 16.2.10. [DFKV22, Thm. 6.10] Let (B, ) be past-finite monotonic strong bimonoid and A a (\u03a3,B)-wta and b \u2208 B.\n(1) The tree language ([[A]]run)\u22121(b) is recognizable. Hence [[A]]run has the preimage property. (2) If the set past(b) can be constructed, then we can construct a finite-state \u03a3-tree automaton which\nrecognizes [[A]]\u22121(b).\nProof. Let b \u2208 B.\nProof of (1): We define the set C = B\\past(b) = {a \u2208 B | a b}. Moreover, we define the equivalence relation \u223c on the set B such that its classes are the singleton sets {a} for each a \u2208 past(b) and the set C.\nWe claim that \u223c is a congruence. To show this let c, c\u2032 \u2208 C and d \u2208 B. Since (B, ) is monotonic, we have c c\u2295 d and c\u2032 c\u2032 \u2295 d. Hence c\u2295 d \u2208 C and c\u2032 \u2295 d \u2208 C. By commutativity of \u2295 we also have d \u2295 c \u2208 C and d \u2295 c\u2032 \u2208 C. Thus \u2295 obeys the structure of the equivalence classes. Now let d 6= 0. Then we obtain c c \u2297 d and c d\u2297 c, showing that c\u2297 d \u2208 C and d\u2297 c \u2208 C, and similarly c\u2032 \u2297 d \u2208 C and d\u2297 c\u2032 \u2208 C. Hence \u223c is a congruence on the strong bimonoid B.\nBy definition, the quotient strong bimonoid of B modulo \u223c is finite. Let h : B \u2192 B/\u223c be the canonical strong bimonoid homomorphism, i.e., for each c \u2208 B we let h(c) = [c]\u223c. By Lemma 10.9.3, we obtain (h \u25e6 [[A]]run) \u2208 Recrun(\u03a3,B/\u223c). Moreover ([[A]]run)\u22121(b) = (h \u25e6 [[A]]run)\u22121({b}). Since B/\u223c is finite, by Corollary 16.2.8, the \u03a3-tree language (h \u25e6 [[A]]run)\u22121({b}) is recognizable. Thus [[A]]run has the preimage property.\nProof of (2): Assume that past(b) is constructed. Then we can construct the congruence \u223c as defined in the proof of Statement 1 and the canonical strong bimonoid homomorphism h : B \u2192 B/\u223c. Since B/\u223c is finite, by Observation 10.9.1, we can construct the (\u03a3,B/\u223c)-wta h(A) such that [[h(A)]]run = h\u25e6 [[A]]run. Since B/\u223c is finite, by Corollary 16.2.8, we can construct a finite-state \u03a3-tree automaton which recognizes ([[h(A)]]run)\u22121({b}).\nBy Theorems 10.3.1 and 16.2.10(1), A is run crisp determinizable if and only if im([[A]]run) is finite. As first step towards our characterization theorem we analyse the impact of this finiteness property on\n340 CHAPTER 16. CRISP DETERMINIZATION\nthe structure of a (\u03a3,B)-wta A where (B, ) is a past-finite monotonic strong bimonoid. In particular, we consider local-non-zero runs and small loops of A. (We recall that the definition of a run on a context and the weight of such a run can be found in Section 6.1.)\nFor each \u03be \u2208 T\u03a3({z}), we call a run \u03c1 \u2208 RA(\u03be) local-non-zero if for each w \u2208 pos\u03a3(\u03be) we have \u03b4k(\u03c1(w1) \u00b7 \u00b7 \u00b7 \u03c1(wk), \u03c3, \u03c1(w)) 6= 0 where k = rk(\u03be(w)) and \u03c3 = \u03be(w). We note that, for every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be), the run \u03c1 is local-successful (cf. Subsection 7.1.1) if it is local-non-zero and F\u03c1(\u03b5) 6= 0.\nWe say that small loops of A have weight 1 if, for every q \u2208 Q, c \u2208 C\u03a3, and local-non-zero \u03c1 \u2208 RA(q, c, q), if height(c) < |Q|, then wt(c, \u03c1) = 1.\nTheorem 16.2.11. [DFKV22, Thm. 7.1] Let (B, ) be a past-finite monotonic strong bimonoid and A be a local-trim (\u03a3,B)-wta. If im([[A]]run) is finite, then small loops of A have weight 1.\nProof. We prove by contraposition. Suppose there exist q \u2208 Q, c \u2208 C\u03a3, and local-non-zero \u03c1 \u2208 RA(q, c, q) such that height(c) < |Q| and wt(c, \u03c1) 6= 1. Since \u03c1 is local-non-zero and (B, ) is monotonic, we have that 1 \u227a wt(c, \u03c1). Since A is local-trim, the state q is local-useful and thus there exist \u03be \u2208 T\u03a3, \u03b8 \u2208 RA(q, \u03be), c\u2032 \u2208 C\u03a3, q \u2032 \u2208 Q with Fq\u2032 6= 0, and \u03c1 \u2032 \u2208 RA(q\n\u2032, c\u2032, q), and \u03b8 and \u03c1\u2032 are local-non-zero. By Theorem 6.1.3, for each n \u2208 N, we have\nwt(c\u2032 [ cn[\u03be] ] , \u03c1\u2032 [ \u03c1n[\u03b8] ] ) = lc\u2032,\u03c1\u2032 \u2297 (lc,\u03c1) n \u2297 wt(\u03be, \u03b8)\u2297 (rc,\u03c1) n \u2297 rc\u2032,\u03c1\u2032 .\nSince 1 \u227a wt(c, \u03c1) = lc,\u03c1 \u2297 rc,\u03c1 , we have 1 \u227a lc,\u03c1 or 1 \u227a rc,\u03c1, because B is one-product free. Thus, by monotonicity of (B, ), we obtain\nwt(c\u2032 [ c0[\u03be] ] , \u03c1\u2032 [ \u03c10[\u03b8] ] ) \u227a wt(c\u2032 [ c1[\u03be] ] , \u03c1\u2032 [ \u03c11[\u03b8] ] ) \u227a . . . . (16.9)\nNext we define a sequence \u03be1, \u03be2, \u03be3, . . . of trees in T\u03a3 such that the elements [[A]]run(\u03be1), [[A]]run(\u03be2), [[A]]run(\u03be3), . . . are pairwise different as follows. We let \u03be1 = c\u2032 [ c[\u03be] ] . Since (B, ) is past-finite, the set P1 = past([[A]] run(\u03be1)) is finite. By (16.9) we choose n2 such that wt(c \u2032 [ cn2 [\u03be] ] , \u03c1\u2032 [ \u03c1n2 [\u03b8] ] ) 6\u2208 P1 and let\n\u03be2 = c \u2032 [ cn2 [\u03be] ] . Since \u03c1\u2032 [ \u03c1n2 [\u03b8] ] \u2208 RA(q\u2032, \u03be2) and (B, ) is monotonic, we have\nwt(\u03be2, \u03c1 \u2032 [ \u03c1n2 [\u03b8] ] ) wt(\u03be2, \u03c1 \u2032 [ \u03c1n2 [\u03b8] ] )\u2297 Fq\u2032\n\u2295\n\u03ba\u2208RA(\u03be2)\nwt(\u03be2, \u03ba)\u2297 F\u03ba(\u03b5) = [[A]] run(\u03be2).\n(Note that Fq\u2032 may be 1.) Hence [[A]]run(\u03be2) /\u2208 P1. Put P2 = past([[A]]run(\u03be2)). Then we choose n3 \u2208 N such that wt(c\u2032 [ cn3 [\u03be] ] , \u03c1\u2032 [ \u03c1n3 [\u03b8] ] ) 6\u2208 P1 \u222a P2 and let \u03be3 = c\u2032 [ cn3 [\u03be] ] . As before, we have [[A]]run(\u03be3) /\u2208 P1 \u222a P2. Continuing this process, we obtain the desired sequence of trees. It means that im([[A]]run) is infinite.\nWe recall, for a (\u03a3,B)-wta A = (Q, \u03b4, F ), the definitions\nH(A) = {wt(\u03be, \u03c1) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be)} and C(A) = {wt(\u03be, \u03c1)\u2297 F\u03c1(\u03b5) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be)} .\nAlso a kind of inverse of Theorem 16.2.11 holds.\nLemma 16.2.12. [DFKV22, Lm. 5.5, 6.7] Let B be a one-product free strong bimonoid and A be a (\u03a3,B)-wta. If small loops of A have weight 1, then\n(1) for every \u03be \u2208 T\u03a3, q\u2032 \u2208 Q, and local-non-zero \u03ba \u2208 RA(q\u2032, \u03be), there exist \u03be\u2032 \u2208 T\u03a3 and \u03ba\u2032 \u2208 RA(q\u2032, \u03be\u2032) such that height(\u03be\u2032) < |Q| and wt(\u03be, \u03ba) = wt(\u03be\u2032, \u03ba\u2032) and (2) the set H(A) is finite.\nProof. Proof of (1): The idea is to cut out iteratively local-non-zero, small loops with weight 1. Formally, let \u03be \u2208 T\u03a3, q\u2032 \u2208 Q, and \u03ba \u2208 RA(q\u2032, \u03be) be a local-non-zero run. We may assume that height(\u03be) \u2265 |Q|. Applying Theorem 6.1.4 (for n = 1 and n = 0), there exist c, c\u2032 \u2208 C\u03a3, \u03b6 \u2208 T\u03a3, q \u2208 Q, \u03c1\u2032 \u2208 RA(q\u2032, c\u2032, q),\n16.2. RUN CRISP DETERMINIZATION 341\n\u03c1 \u2208 RA(q, c, q), and \u03b8 \u2208 RA(q, \u03b6) such that \u03be = c\u2032 [ c[\u03b6] ] , \u03ba = \u03c1\u2032 [ \u03c1[\u03b8] ] , height(c) > 0, height ( c[\u03b6] ) < |Q|, and\nwt(\u03be, \u03ba) =wt(c\u2032 [ c[\u03b6] ] , \u03c1\u2032 [ \u03c1[\u03b8] ] ) = lc\u2032,\u03c1\u2032 \u2297 lc,\u03c1 \u2297 wt(\u03b6, \u03b8) \u2297 rc,\u03c1 \u2297 rc\u2032,\u03c1\u2032 (for n = 1) ,\nwt(c\u2032[\u03b6], \u03c1\u2032[\u03b8]) = lc\u2032,\u03c1\u2032 \u2297 wt(\u03b6, \u03b8) \u2297 rc\u2032,\u03c1\u2032 (for n = 0) .\nSince \u03ba is local-non-zero, also the runs \u03c1\u2032, \u03c1, and \u03b8 are local-non-zero. Thus wt(c, \u03c1) = 1 by our assumption.\nMoreover, by Observation 6.1.1, we have wt(c, \u03c1) = lc,\u03c1 \u2297 rc,\u03c1. Since B is one-product free, we have lc,\u03c1 = rc,\u03c1 = 1. Hence we have wt(\u03be, \u03ba) = wt(c \u2032[\u03b6], \u03c1\u2032[\u03b8]).\nObviously, \u03c1\u2032[\u03b8] \u2208 RA(q\u2032, c\u2032[\u03b6]) and size(c\u2032[\u03b6]) < size(\u03be). If height(c\u2032[\u03b6]) < |Q|, then we are ready. Otherwise we continue with c\u2032[\u03b6], q\u2032, and \u03c1\u2032[\u03b8] as before. After finitely many steps, we obtain \u03be\u2032 \u2208 T\u03a3 and \u03ba\u2032 \u2208 RA(q\u2032, \u03be\u2032) with height(\u03be\u2032) < |Q| as required.\nProof of (2): If small loops of A have weight 1, then by Statement 1 of this lemma we have\nH(A) = {wt(\u03be, \u03c1) | \u03be \u2208 T\u03a3, height(\u03be) < |Q|, and \u03c1 \u2208 RA(\u03be)} .\nHence H(A) is finite.\nNow we can prove the main result of this subsection.\nTheorem 16.2.13. [DFKV22, Thm. 6.10, 7.1] Let \u03a3 be a ranked alphabet, (B, ) = (B,\u2295,\u2297, 0, 1, ) be a past-finite monotonic strong bimonoid, and A be a local-trim (\u03a3,B)-wta. Then the following two statements are equivalent. (A) A is run crisp determinizable. (B) Small loops of A have weight 1 and, for each b \u2208 C(A), the mapping fA,b is bounded or b has finite\nadditive order.\nProof. Proof of (A)\u21d2(B): Since A is run crisp determinizable, the set im([[A]]run) is finite by Theorem 10.3.1. Thus, by Theorem 16.2.11, small loops of A have weight 1.\nNow let b \u2208 C(A). If the mapping fA,b is not bounded, then there exists an infinite sequence \u03be1, \u03be2, . . . of trees in T\u03a3 such that fA,b(\u03be1) < fA,b(\u03be2) < . . .. By Equality (16.3), we have ( fA,b(\u03bei) ) b [[A]]run(\u03bei)\nfor each i \u2208 N. Thus ( fA,b(\u03bei) ) b \u2208 P , where P = \u22c3 a\u2208im([[A]]run) past(a). Since im([[A]] run) is finite and\n(B, ) is past-finite, the set P is also finite. Hence ( fA,b(\u03bei) ) b = ( fA,b(\u03bej) ) b for some i, j \u2208 N with i < j, which implies that b has finite additive order.\nProof of (B)\u21d2(A): This implication follows from Lemma 16.2.12 (we recall that each monotonic strong bimonoid is one-product free) and Theorem 16.2.6.\nFinally we show an application of Theorem 16.2.13.\nTheorem 16.2.14. [DFKV20, Thm. 10] Let (B, ) be an additively locally finite and past-finite monotonic strong bimonoid. Moreover, let A be a (\u03a3,B)-wta which contains at least one local-useful state. It is decidable whether A is run crisp determinizable.\nProof. Let A = (Q,\u03a3, \u03b4). By Theorem 7.1.4, we can construct a (\u03a3,B)-wta A\u2032 such that A\u2032 is local-trim and [[A\u2032]]run = [[A]]run. Hence we may assume that A is local-trim. Since B is additively locally finite, each b \u2208 C(A) has finite additive order. Thus, by Theorem 16.2.13, A is run crisp determinizable if and only if small loops of A have weight 1. The latter property is decidable because (a) there exist only finitely many c \u2208 C\u03a3 such that height(c) < |Q|, and (b) since (B, ) is monotonic, for every c \u2208 C\u03a3, q \u2208 Q, and \u03c1 \u2208 RA(q, c, q) we have wt(c, \u03c1) = 1 if and only if for each v \u2208 pos(c) we have \u03b4k(\u03c1(v1) \u00b7 \u00b7 \u00b7 \u03c1(vk), \u03c3, \u03c1(v)) = 1 where \u03c3 = c(v) and k = rk(\u03c3), and (c) this is decidable because B has an effective test for 1.\n342 CHAPTER 16. CRISP DETERMINIZATION\nThe decidability problem addressed in Theorem 16.2.14 is meaningful, because there exists an additively locally finite and past-finite monotonic semiring and a wta over that semiring which is not run crisp determinizable. Such a semiring and wta is the arctic semiring Natmax,+ and the (\u03a3,Natmax,+)-wta A in Example 3.2.4, respectively. We recall that [[A]]init = [[A]]run = height (cf. Theorem 5.3.1). As we mentioned A is not run crisp determinizable because im(height) is not finite.\nWe refer the reader to [DFKV20, DFKV22] for further decidability and undecidability results for wta and wsa over past-finite monotonic strong bimonoids.\nChapter 17\nDeterminization of wta over semirings\nIn this chapter, we consider as weight algebras only semirings. A (\u03a3,B)-wta A over some semiring B is bu determinizable (or just: determinizable) if there exists an equivalent bu deterministic (\u03a3,B)-wta B, i.e., [[A]] = [[B]]. 1\nIf B is locally finite (e.g., finite), then we can apply the subset method of Definition 16.1.2 to A and obtain an i-equivalent crisp deterministic (\u03a3,B)-wta B. In Section 17.1, it will turn out that, in general, the subset method will not yield a bu deterministic wta, i.e., it is not able to determinize each wta. One might think that there exist other, successful approaches. However, there are recognizable weighted tree languages which are not bu deterministically recognizable (as already in the string case, cf. [KLMP04, pp.354]). Hence, if r is such a weighted tree language, then each wta A with [[A]] = r is not bu determinizable. For example, the mapping height : T\u03a3 \u2192 N is recognizable by a (\u03a3,Natmax,+)-wta (cf. Example 3.2.4) but it is not bu deterministically recognizable (cf. Corollary 6.1.5). In Section 17.2 we show two further recognizable weighted tree languages which are not bu deterministically recognizable.\nIn Section 17.3 we show an advanced version of the subset method which is based on factorization and it is called determinization by factorization (cf. Definition 17.3.1). We elaborate sufficient conditions under which determinization by factorization transforms a given wta into a bu deterministic wta which is equivalent to the given wta. More precisely, if B is an extremal and commutative semiring for which there exists a maximal factorization, and the given (\u03a3,B)-wta A has the twinning property, then A is bu determinizable (cf. Theorem 17.3.2) and a bu deterministic wta equivalent to A can be obtained by applying determinization by factorization to A. The approach of bu determinization of wta by factorization was published in [BVM10] (also cf. [Bu\u0308c14, Sec. 5]), and it is based on the determinization by factorization of wsa [KM05]. In its turn, the latter is a generalization of determinization of wsa over the tropical semiring [Moh97].\nWe mention that in [Pau20, Sect. 4.5] the decidability of the determinization of (\u03a3,Realmax,+)-wta was considered, where Realmax,+ is the semifield (R\u2212\u221e,max,+,\u2212\u221e, 0). One of the main results is [Pau20, Thm. 4.33] which states the following. For a finitely ambiguous (\u03a3,Realmax,+)-wta A it is decidable whether there exists a deterministic (\u03a3,Realmax,+)-wta A\u2032 such that [[A]] = [[A\u2032]]. If such an automaton [[A\u2032]] exists, then it can be constructed. Here finitely ambiguous means that there exists an integerM \u2265 1 such that, for each tree \u03be \u2208 T\u03a3, there are at most M accepting runs of A on \u03be. We also mention that the base of the construction of A\u2032 is not the factorization as in this chapter.\nAlso, we mention that in [DSF21] wta over particular semirings were considered which are based on groups. Let G = (G,\u2297, 1) be a group. Then Sem(G) = (Pfin(G),\u222a,\u2297, \u2205, {1}) is a semiring where \u2297 is\n1We recall that [[A]] = [[A]]init = [[A]]run because B is a semiring.\n343\n344 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS\nlifted to finite subsets of G in the straightforward way (cf. Example 2.6.9(17)). A group-weighted tree automaton over \u03a3 and G (for short: (\u03a3,G)-gwta) is a (\u03a3, Sem(G))-wta. In [DSF21, Thm. 1] it is proved that each (\u03a3,G)-gwta is sequentializable if it has the twinning property. A (\u03a3,G)-gwta is sequential if it is bu deterministic and for each transition (q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) we have that |\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)| \u2264 1. It is easy to see that each crisp deterministic (\u03a3,G)-gwta is sequential, and each sequential (\u03a3,G)-gwta is bu deterministic. Moreover, both inclusions are strict.\nFinally, we mention that in [Do\u0308r22] a general framework for the determinization was established, which is based on a theory of factorizations in (multiplicative) monoids [Do\u0308r22, Sec. 3.3]). Roughly speaking, the main determinization result [Do\u0308r22, Thm. 3.78] says the following. Let B = (B,\u2295,\u2297, 0, 1) be a semiring; moreover, let M = (M,\u2297, 1) be a finitely generated submonoid of (B,\u2297, 1) which satisfies a certain monotonicity property and admits centering factorizations; then B\u2032 = (\u3008M\u3009\u2295,\u2295,\u2297, 0, 1) is a semiring. Moreover, let A be a (\u03a3,B\u2032)-wta which satisfies a certain twinning property. Then [Do\u0308r22, Thm. 3.78] says that, if A is finitelyM -ambiguous or B\u2032 is additively idempotent, then A is M-sequentializable, which means sequential and the transition weights are in M . As illustrated in [Do\u0308r22, Ex. 3.95], the twinning properties of [BVM10] and of [Do\u0308r22, Thm. 3.78] are incomparable.\nIn this chapter B is a semiring and A = (Q, \u03b4, F ) denotes an arbitrary (\u03a3,B)-wta unless specified otherwise."
        },
        {
            "heading": "17.1 Applying the subset method to wta over arbitrary semir-",
            "text": "ings\nOne can be tempted to apply the subset method (cf. Definition 16.1.2) to a (\u03a3,B)-wta A where B is a not necessarily locally finite semiring. Then one obtains the triple sub(A) = (Q\u2032, \u03b4\u2032, F \u2032). We note that Q\u2032 is finite if and only if sub(A) is crisp deterministic wta which is equivalent to A.\nLemma 17.1.1. If sub(A) is a crisp deterministic (\u03a3,B)-wta, then [[A]] is a recognizable step mapping.\nProof. Let sub(A) be a crisp deterministic (\u03a3,B)-wta. Then by Theorem 16.1.3(1) we have [[sub(A)]] = [[A]]. Hence the statement follows from Theorem 10.3.1.\nThis lemma shows the limit of the subset method: if [[A]] is not a recognizable step mapping, then sub(A) is not a crisp determinisitic wta, i.e., the subset method does not yield a wta. In the following we give an example of a (not bu deterministic) (\u03a3,B)-wta A which cannot be determinized by the subset method because [[A]] is not a recognizable step mapping (also cf. [BVM10, Ex. 4.1]).\nExample 17.1.2. We consider the tropical semifield Ratmin,+ = (Q\u221e,min,+,\u221e, 0) and the ranked alphabet \u03a3 = {\u03c3(2), \u03b1(0)}. Moreover, we let A = (Q, \u03b4, F ) be the (\u03a3,Ratmin,+)-wta given by\n\u2022 Q = {p, p\u2032} and Fp = 0 and Fp\u2032 =\u221e and \u2022 \u03b40(\u03b5, \u03b1, p) = 1, \u03b42(pp, \u03c3, p) = 1, \u03b42(pp, \u03c3, p \u2032) = 0.5, and \u03b42(p \u2032p, \u03c3, p) = 1.5, and all other values of \u03b40\nand \u03b42 are \u221e.\nFigure 17.1 shows the fta-hypergraph of A. Obviously, A is not bu deterministic. Moreover, for each \u03be \u2208 T\u03a3, we have\nhA(\u03be)p\u2032 =\n{ \u221e if \u03be = \u03b1\nsize(\u03be) \u2212 0.5 otherwise and hA(\u03be)p = size(\u03be) .\nThus, for each \u03be \u2208 T\u03a3, we have [[A]](\u03be) = [[A]](\u03be) = size(\u03be).2 Obviously, size is not a recognizable step mapping, because im(size) is an infinite set. Thus, by the contraposition of Lemma 17.1.1 sub(A) =\n2Indeed, we obtained A by starting from the bu deterministic wta shown in Example 3.2.3 and by \u201cunfolding\u201d the transition on \u03c3.\n17.2. NEGATIVE RESULTS FOR DETERMINIZATION 345\n(Q\u2032, \u03b4\u2032, F \u2032) is not a crisp deterministic wta. In particular, the set Q\u2032 is not finite. We obtain that, in general, the subset method is not appropriate to determinize wta.\nFinally, we note that the reverse of Lemma 17.1.1 does not hold. For instance, consider the (\u03a3,Natmax,+)-wta A of Example 3.2.4 which recognizes the weighted tree language height : T\u03a3 \u2192 N. In the definition of A, let us change the mapping F by defining Fh = \u2212\u221e, and let us denote the obtained wta by A\u2032. Obviously, [[A\u2032]] = \u2212\u0303\u221e, i.e., a recognizable step mapping. On the other hand, Q\u2032 = { ( n 0 ) | n \u2208 N}, i.e., an infinite set. Hence sub(A) is not a crisp deterministic (\u03a3,Natmax,+)-wta."
        },
        {
            "heading": "17.2 Negative results for determinization",
            "text": "We have seen that the subset method does not yield the desired determinization. Actually, there is no determinization which works for each (\u03a3,B)-wta because there exist recognizable weighted tree languages which are not bu deterministically recognizable. For instance, the weighted tree language height is not bu deterministically recognizable (cf. Corollary 6.1.5). In this section we show two further examples of such weighted tree languages.\nTheorem 17.2.1. [Den17] The weighted tree language zigzag : T\u03a3 \u2192 N defined in Example 3.2.15 is in Rec(\u03a3,Natmax,+), but not in bud-Rec(\u03a3,Natmax,+). Hence, each (\u03a3,Natmax,+)-wta which recognizes zigzag is not bu determinizable.\nProof. We recall that \u03a3 = {\u03c3(2), \u03b1(0)} and Natmax,+ = (N\u2212\u221e,max,+,\u2212\u221e, 0). We prove the claim by contradiction. For this we assume that there exists a bu deterministic (\u03a3,Natmax,+)-wta A = (Q, \u03b4, F ) such that [[A]] = zigzag.\nBy Lemma 4.2.1(1), for every \u03be \u2208 T\u03a3 we have |Q hA 6=\u2212\u221e(\u03be)| \u2264 1. If there exists a tree \u03be \u2208 T\u03a3 such that |QhA6=\u2212\u221e(\u03be)| = 0, then [[A]](\u03be) = \u2212\u221e 6= zigzag(\u03be). Thus for every \u03be \u2208 T\u03a3 we have |Q hA 6=\u2212\u221e(\u03be)| = 1. Let us denote, for each \u03be \u2208 T\u03a3, the unique element in Q hA 6=\u2212\u221e(\u03be) by q\u03be.\nIf there exists a \u03be \u2208 T\u03a3 such that Fq\u03be = \u2212\u221e, then [[A]](\u03be) = \u2212\u221e 6= zigzag(\u03be). Thus Fq\u03be 6= \u2212\u221e for every \u03be \u2208 T\u03a3. In conclusion we know:\n(\u2200\u03be \u2208 T\u03a3) : ( [[A]](\u03be) = hA(\u03be)q\u03be + Fq\u03be = zigzag(\u03be) ) \u2227 ( (\u2200q \u2208 Q) : if q 6= q\u03be, then hA(\u03be)q = \u2212\u221e ) . (17.1)\nSince Q is finite and zigzag(T\u03a3) is not, there exist trees \u03be1, \u03be2 \u2208 T\u03a3 such that q\u03be1 = q\u03be2 and zigzag(\u03be1) 6= zigzag(\u03be2). Since A is bu deterministic, we have q\u03c3(\u03b1,\u03be1) = q\u03c3(\u03b1,\u03be2). Let us abbreviate\n346 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS\nq\u03be1 by q and q\u03c3(\u03b1,\u03be1) by q \u2032, respectively. Due to the definition of zigzag we have that zigzag(\u03c3(\u03b1, \u03be1)) = zigzag(\u03c3(\u03b1, \u03be2)) = 1.\nThen we can derive the following sequence of implications:\nzigzag(\u03c3(\u03b1, \u03be1)) = zigzag(\u03c3(\u03b1, \u03be2))\n\u21d2 hA(\u03c3(\u03b1, \u03be1))q\u2032 + Fq\u2032 = hA(\u03c3(\u03b1, \u03be2))q\u2032 + Fq\u2032 (by (17.1) and because q\u03c3(\u03b1,\u03be1) = q\u03c3(\u03b1,\u03be2))\n\u21d2 hA(\u03c3(\u03b1, \u03be1))q\u2032 = hA(\u03c3(\u03b1, \u03be2))q\u2032 (because Fq\u2032 6= \u2212\u221e)\n\u21d2 hA(\u03b1)q\u03b1 + hA(\u03be1)q + \u03b42(q\u03b1q, \u03c3, q \u2032) = hA(\u03b1)q\u03b1 + hA(\u03be2)q + \u03b42(q\u03b1q, \u03c3, q \u2032) (by definition of hA and because q = q\u03be1 = q\u03be2)\n\u21d2 hA(\u03be1)q = hA(\u03be2)q (because hA(\u03b1)q\u03b1 6= \u2212\u221e 6= \u03b42(q\u03b1q, \u03c3, q \u2032))\n\u21d2 hA(\u03be1)q + Fq = hA(\u03be2)q + Fq (because Fq 6= \u2212\u221e)\n\u21d2 zigzag(\u03be1) = zigzag(\u03be2) (by (17.1))\nThis is a contradiction. Thus zigzag 6\u2208 bud-Rec(\u03a3,Natmax,+). As a consequence, each (\u03a3,Natmax,+)-wta which recognizes zigzag (including the one in Example 3.2.15) is not bu determinizable.\nTheorem 17.2.2. (cf. [BV03, Thm. 6.3]) The weighted tree language (exp + 1) : T\u03a3 \u2192 N defined in Example 3.2.9 is in Rec(\u03a3,Rat), but not in bud-Rec(\u03a3,Rat), where Rat = (Q,+, \u00b7, 0, 1) is the field over the rational numbers. Hence, each (\u03a3,Rat)-wta which recognizes (exp+1) is not bu determinizable.\nProof. We recall that \u03a3 = {\u03b3(1), \u03b1(0)}. In Example 3.2.9, we gave a (\u03a3,Nat)-wta over the semiring Nat = (N,+, \u00b7, 0, 1) of natural numbers which recognizes (exp+1). We can view this wta as a (\u03a3,Rat)wta (cf. Section 3.7), which we denote by AQ in this proof. Hence (exp+1) \u2208 Rec(\u03a3,Rat).\nNext we prove that (exp+1) 6\u2208 bud-Rec(\u03a3,Rat), and we prove this by contradiction. We assume that (exp + 1) \u2208 bud-Rec(\u03a3,Rat). Then, by Theorem 7.3.3 there exists a bu deterministic (\u03a3,Rat)-wta A = (Q, \u03b4, F ) with identity root weights such that [[A]] = (exp + 1).\nBy Lemma 4.2.1(1), for every n \u2208 N we have |QhA6=0(\u03b3 n(\u03b1))| \u2264 1. If |QhA6=0(\u03b3 n(\u03b1))| = 0 or QhA6=0(\u03b3 n(\u03b1))\u2229 supp(F ) = \u2205, then [[A]](\u03b3n(\u03b1)) = 0 which is a contradiction. Thus |QhA6=0(\u03b3 n(\u03b1)) \u2229 supp(F )| = 1. We denote the state in the set QhA6=0(\u03b3 n(\u03b1)) \u2229 supp(F ) by qn. Thus\n[[A]](\u03b3n(\u03b1)) = hA(\u03b3 n(\u03b1))qn = 2 n + 1 . (17.2)\nIt is an easy exercise to show that, for every q \u2208 Q and n \u2265 1:\n\u03b40(\u03b5, \u03b1, q) = { 2 if q = q0 0 otherwise\nand\n\u03b41(qn\u22121, \u03b3, q) = { (2n\u22121 + 1)\u22121 \u00b7 (2n + 1) if q = qn 0 otherwise .\nSince Q is finite, there exist n, i \u2208 N such that 0 \u2264 i < n and qi = qn. Then we can calculate as follows:\n[[A]](\u03b3n+1(\u03b1)) = hA(\u03b3 n(\u03b1))qn \u00b7 \u03b41(qn, \u03b3, qn+1) = (2 n + 1) \u00b7 \u03b41(qn, \u03b3, qn+1)\n= (2n + 1) \u00b7 \u03b41(qi, \u03b3, qi+1) = (2 n + 1) \u00b7 (2i + 1)\u22121 \u00b7 (2i+1 + 1) 6= 2n+1 + 1 .\nwhere the inequality follows from a straightforward calculation. However, [[A]](\u03b3n+1(\u03b1)) 6= 2n+1+1 which contradicts Equation (17.2). Hence (exp + 1) 6\u2208 bud-Rec(\u03a3,Rat). As a consequence, each (\u03a3,Rat)-wta which recognizes (exp+1) (including AQ from the beginning of the proof) is not bu determinizable.\n17.3. POSITIVE RESULT FOR DETERMINIZATION 347"
        },
        {
            "heading": "17.3 Positive result for determinization",
            "text": "In this section we recall the approach of [BVM10] (based on [KM05]) and adapt it to our notations.\nWe recall that V(A) = (BQ, \u03b4A) is the vector algebra of A, and that 0Q \u2208 B Q is the Q-vector over B which contains 0 in each component (cf. Section 2.7). We assume that there exists \u03b1 \u2208 \u03a3(0) such that \u03b4A(\u03b1)() 6= 0Q.\nIn this section we use the addition of BQ-vectors and the multiplication of a Q-vector with a scalar both from the left and the right (cf. Section 2.7). Also we recall that, for every \u03be \u2208 T\u03a3 and q \u2208 Q we have hA(\u03be)q = \u2295 \u03c1\u2208RA(q,\u03be) wt(\u03be, \u03c1) (cf. (5.2)).\nIn Subsection 17.3.1, we start by defining the concepts of factorization and twinning property, we show the construction of the triple det(f,g)(A) for some wta A and some factorization (f, g), and we show the main determinization theorem of this section (cf. Theorem 17.3.2) and an application to a particular wta. In Subsections 17.3.2 and 17.3.3, we elaborate properties and examples of factorizations and of the twinning property, respectively. Finally, in Subsection 17.3.4, we show the proof of Theorem 17.3.2."
        },
        {
            "heading": "17.3.1 Determinization by factorization",
            "text": "The idea of factorization is to represent each Q-vector u \u2208 BQ as a scalar product b \u00b7 u\u2032 where b \u2208 B and u\u2032 \u2208 BQ; moreover, the way in which Q-vectors are split into elements of B and remaining Q-vectors in BQ should be uniform. Formally, a factorization over BQ (or: factorization) is a pair (f, g) of mappings, where\nf : BQ \\ {0Q} \u2192 B Q and g : BQ \\ {0Q} \u2192 B\nsuch that u = g(u) \u00b7 f(u) for every u \u2208 BQ \\ {0Q}. Thus 0Q 6\u2208 im(f) and 0 6\u2208 im(g). We call g(u) the common factor of u and f(u) the remainder of u. The factorization (f, g) is called\n- maximal if, for every u \u2208 BQ \\ {0Q} and b \u2208 B with b \u00b7 u 6= 0Q, we have f(u) = f(b \u00b7 u), and - trivial if f(u) = u and g(u) = 1 for every u \u2208 BQ \\ {0Q}.\nWe recall from Section 6.1 that, for every c \u2208 C\u03a3 and p, q \u2208 Q, we denote the set of all runs of A on c and the set of all (q, p)-runs of A on c by RA(c) and RA(q, c, p), respectively. Also the weight of a run on a context is defined in Section 6.1. Moreover, for every \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be), and w \u2208 pos(\u03be), we defined the run \u03c1|w on the context \u03be|w.\nAdditionally, for each \u03be \u2208 T\u03a3 \u222aC\u03a3 and R \u2286 RA(\u03be), we define\nwt(R) = \u2295\n\u03c1\u2208R\nwt(\u03be, \u03c1) .\nBy Observation 2.6.7, if B is extremal, then there exists \u03c1 \u2208 R such that wt(\u03be, \u03c1) = wt(R). We call such a run victorious in R.\nThe wta A has the twinning property if, for every p, q \u2208 Q, \u03be \u2208 T\u03a3, and c \u2208 C\u03a3, the following holds:\nIf wt(RA(p, c, p)) 6= 0 and wt(RA(p, \u03be)) 6= 0 and\nwt(RA(q, c, q)) 6= 0 and wt(RA(q, \u03be)) 6= 0 ,\nthen wt(RA(p, c, p)) = wt(RA(q, c, q)) .\nThe following determinization by factorization is based on [KM05, Sect. 3.3] and [BVM10, p. 11]. Roughly speaking, it differs from the subset method as follows. In the subset method, for every u1, . . . , uk \u2208 BQ and \u03c3 \u2208 \u03a3(k), the transition\n(u1 \u00b7 \u00b7 \u00b7uk, \u03c3, \u03b4A(\u03c3)(u1, . . . , uk)) with weight 1\n348 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS\nis constructed. In the determinization by factorization, the Q-vector \u03b4A(\u03c3)(u1, . . . , uk) is factorized as\n\u03b4A(\u03c3)(u1, . . . , uk) = g(\u03b4A(\u03c3)(u1, . . . , uk))\ufe38 \ufe37\ufe37 \ufe38 common factor in B \u00b7 f(\u03b4A(\u03c3)(u1, . . . , uk))\ufe38 \ufe37\ufe37 \ufe38 remainder in BQ\nand the transition\n(u1 \u00b7 \u00b7 \u00b7uk, \u03c3, f(\u03b4A(\u03c3)(u1, . . . , uk))) with weight g(\u03b4A(\u03c3)(u1, . . . , uk))\nis constructed. Thus, the remainder f(\u03b4A(\u03c3)(u1, . . . , uk)) is the target state of the transition and the common factor g(\u03b4A(\u03c3)(u1, . . . , uk)) is its weight. We do this because, as we will see, in certain cases the set of remainders will be a finite set, while the set of vectors produced by the subset method is infinite.\nIn the following we give the definition of determinization by factorization. Like the subset method, it is not a construction in the sense described in the Introduction, because the set Q\u2032 might be infinite and in this case the triple (Q\u2032, \u03b4\u2032, F \u2032) is not a bu deterministic wta. We will need further conditions to assure that (Q\u2032, \u03b4\u2032, F \u2032) is a bu determinstic wta (cf. Theorem 17.3.2).\nDefinition 17.3.1. [BVM10, p. 11] Let \u03a3 be a ranked alphabet and B = (B,\u2295,\u2297, 0, 1) be a semiring. Moreover, let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta and (f, g) be a factorization over BQ. The determinization by factorization transforms A and (f, g) into the triple det(f,g)(A) = (Q \u2032, \u03b4\u2032, F \u2032) where\n\u2022 Q\u2032 is the smallest set P \u2286 BQ such that, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), u1, . . . , uk \u2208 P : if \u03b4A(\u03c3)(u1, . . . , uk) 6= 0Q, then f(\u03b4A(\u03c3)(u1, . . . , uk)) \u2208 P , \u2022 \u03b4\u2032 = (\u03b4\u2032k | k \u2208 N) is the family of mappings \u03b4 \u2032 k : (Q\n\u2032)k \u00d7 \u03a3(k) \u00d7 Q\u2032 \u2192 B defined for every k \u2208 N, \u03c3 \u2208 \u03a3(k), u1, . . . , uk \u2208 Q\u2032, and u \u2208 Q\u2032 by\n\u03b4\u2032k(u1 . . . uk, \u03c3, u) =    g(\u03b4A(\u03c3)(u1, . . . , uk)) if \u03b4A(\u03c3)(u1, . . . , uk) 6= 0Q and u = f(\u03b4A(\u03c3)(u1, . . . , uk)) ,\n0 otherwise ,\n\u2022 F \u2032u = \u2295 q\u2208Q uq \u2297 Fq for every u \u2208 Q \u2032.\nWe call the triple det(f,g)(A) the determinization of A by (f, g).\nIn the following, we list some properties of determinization by factorization.\n(1) Since 0Q 6\u2208 im(f), we have 0Q 6\u2208 Q\u2032. (2) If Q\u2032 is finite, then det(f,g)(A) is a bu deterministic (\u03a3,B)-wta. However, even in this case det(f,g)(A)\nis not necessarily crisp deterministic. (3) If (f, g) is the trivial factorization, then the determinization by factorization is the same as the\nsubset method except that the latter may generate the state 0Q. (4) If (f, g) is the trivial factorization and B is locally finite, then the determinization by factorization\nis the same as the subset method except that the latter may generate the state 0Q; in particular, the state set Q\u2032 is finite. Hence det(f,g)(A) is a bu deterministic (\u03a3,B)-wta. Moreover, sub(A) and det(f,g)(A) are equivalent, because the state 0Q is useless for sub(A). More precisely, (a) the operation \u03b4A(\u03c3) yields 0Q if there exists an argument which is 0Q (cf. (3.2)) and (b) F\n\u2032(0Q) = 0. Thus, if 0Q \u2208 im(hA), then we can also drop 0Q from the state set without changing the semantics of sub(A). Then, by applying the construction of Theorem 7.2.1 to det(f,g)(A) (which transforms a given wta into an equivalent total one such that bu determinism is preserved), we obtain a crisp deterministic wta which is equivalent to det(f,g)(A). This construction can be compared to the construction of the Nerode wsa in [CDIV10, Sec. 6]. (5) If B is the semiring Boole, then there exists exactly one factorization (f, g), viz. the trivial and maximal factorization defined by g(u) = 1 and f(u) = u. Since B is finite, determinization by factorization is a particular case of the one described in (4).\nThe main result of this chapter will be the following theorem.\n17.3. POSITIVE RESULT FOR DETERMINIZATION 349\nTheorem 17.3.2. [BVM10, Thm. 5.2] Let \u03a3 be a ranked alphabet, B be an extremal and commutative semiring, A be a (\u03a3,B)-wta with the twinning property, and (f, g) be a maximal factorization over BQ. Then (1) det(f,g)(A) is a bu deterministic (\u03a3,B)-wta (finiteness), (2) [[det(f,g)(A)]] = [[A]] (correctness), and (3) det(f,g)(A) is minimal with respect to the number of states among all bu deterministic (\u03a3,B)-wta\nwhich are obtained from A by determinization by factorization (minimality).\nProof. It follows from Theorems 17.3.17, 17.3.18, and 17.3.19, which are proved in the next subsections.\nWe show six examples of extremal and commutative semirings:\n\u2022 the semiring Boole = (B,\u2228,\u2227, 0, 1), \u2022 the arctic semiring Natmax,+ = (N\u2212\u221e,max,+,\u2212\u221e, 0), \u2022 the semiring Natmax,+,n = ([0, n]\u2212\u221e,max, +\u0302n,\u2212\u221e, 0) where [0, n]\u2212\u221e is an abbreviation of [0, n] \u222a {\u2212\u221e} (defined in Example 2.6.9(9)), \u2022 the tropical semifield Ratmin,+ = (Q\u221e,min,+,\u221e, 0), \u2022 the semifield (R\u22650,max, \u00b7, 0, 1), and \u2022 the semiring Viterbi = ([0, 1],max, \u00b7, 0, 1).\nWe note that, due to Lemma 17.3.6 (below), Theorem 17.3.2 cannot be used to determinize a (\u03a3,B)wta (Q, \u03b4, F ) with at least two states if B is not zero-divisor free, because in this case there does not exist a maximal factorization of BQ.\nExample 17.3.3. Again, we consider the (\u03a3,Ratmin,+)-wta A = (Q, \u03b4, F ) given in Example 17.1.2. For convenience, we recall that\n\u2022 Q = {p, p\u2032} and Fp = 0 and Fp\u2032 =\u221e and \u2022 \u03b40(\u03b5, \u03b1, p) = 1, \u03b42(pp, \u03c3, p) = 1, \u03b42(pp, \u03c3, p \u2032) = 0.5, and \u03b42(p \u2032p, \u03c3, p) = 1.5, and all other values of \u03b40\nand \u03b42 are \u221e.\nAs it turned out in Example 17.1.2, the subset method is not applicable to determinize A. Now we determinize A by factorization according to Definition 17.3.1.\nFor this, we define the mappings f : (Q\u221e) Q \\ {\u221eQ} \u2192 (Q\u221e)Q and g : (Q\u221e)Q \\ {\u221eQ} \u2192 Q\u221e defined\nfor each u = ( up up\u2032 ) in (Q\u221e) Q \\ {\u221eQ} by\nf(u)q = uq \u2212 g(u) for each q \u2208 Q and g(u) = min(up, up\u2032) .\nThen (f, g) is a maximal factorization.\nThen det(f,g)(A) = (Q \u2032, \u03b4\u2032, F \u2032), which we will abbreviate by A\u2032 in the sequel, is defined by (cf. Figure\n17.2)\n\u2022 Q\u2032 = { (\n0 \u221e ) , ( 0.5 0 ) } and F \u2032( ( 0 \u221e ) ) = 0 and F \u2032( ( 0.5 0 ) ) = 0.5\n\u2022 \u03b4\u20320(\u03b5, \u03b1, ( 0 \u221e ) ) = 1 and\n\u03b4\u20322( ( 0 \u221e )( 0 \u221e ) , \u03c3, ( 0.5 0 ) ) = 0.5, \u03b4\u20322( ( 0 \u221e )( 0.5 0 ) , \u03c3, ( 0.5 0 ) ) = 1,\n\u03b4\u20322( ( 0.5 0 )( 0 \u221e ) , \u03c3, ( 0.5 0 ) ) = 1, \u03b4\u20322( ( 0.5 0 )( 0.5 0 ) , \u03c3, ( 0.5 0 ) ) = 1.5 ,\nand \u03b4\u20320(\u03b5, \u03b1, p) = \u03b4 \u2032 2(pq, \u03c3, r) =\u221e for every other combination of p, q, r \u2208 Q \u2032.\nSince Q\u2032 is finite, det(f,g)(A) is a bu deterministic (\u03a3,Ratmin,+)-wta. For two transitions of det(f,g)(A),\nwe illustrate the way in which they are constructed. We abbreviate vectors of the form ( a\u2212c b\u2212c ) by ( a b ) \u2212 c for every a, b, c \u2208 Q\u22650.\n350 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS\n\u03b4\u20320(\u03b5, \u03b1, ( 0 \u221e ) ): We have \u03b4A(\u03b1)() = ( 1 \u221e ) 6= ( \u221e \u221e ) and g( ( 1 \u221e ) ) = 1. Thus\nf(\u03b4A(\u03b1)()) = f( ( 1 \u221e ) ) = ( 1 \u221e ) \u2212 g( ( 1 \u221e ) ) = ( 1 \u221e ) \u2212 1 = ( 0 \u221e ) .\nThus \u03b4\u20320(\u03b5, \u03b1, ( 0 \u221e ) ) = g(\u03b4A(\u03b1)()) = g( ( 1 \u221e ) ) = 1 .\n\u03b4\u20322( ( 0 \u221e )( 0.5 0 ) , \u03c3, ( 0.5 0 ) ): We have\n\u03b4A(\u03c3)( ( 0 \u221e )( 0.5 0 ) ) = ( min(0+0.5+1,\u221e+0.5+1.5)\n0+0.5+0.5\n) = ( 1.5 1 ) .\nSince g( ( 1.5 1 ) ) = 1, we have\nf(\u03b4A(\u03c3)( ( 0 \u221e ) , ( 0.5 0 ) )) = f( ( 1.5 1 ) ) = ( 1.5 1 ) \u2212 g( ( 1.5 1 ) ) = ( 1.5 1 ) \u2212 1 = ( 0.5 0 ) .\nThus we obtain \u03b4\u20322( ( 0 \u221e )( 0.5 0 ) , \u03c3, ( 0.5 0 ) ) = g(\u03b4A(\u03c3)( ( 0 \u221e )( 0.5 0 ) )) = g( ( 1.5 1 ) ) = 1 . Finally we show how the value of F \u2032( ( 0.5 0 ) ) is obtained.\nF \u2032( ( 0.5 0 ) ) = ( 0.5 0 ) \u00b7 ( 0 \u221e ) = min(0.5 + 0, 0 +\u221e) = 0.5 .\nIndeed, [[det(f,g)(A)]](\u03be) = size(\u03be) for each \u03be \u2208 T\u03a3 which can be seen as follows. Let us abbreviate\nhdet(f,g)(A) by h, and the states ( 0 \u221e ) and ( 0.5 0 ) by q1 and q2, respectively. Then for each \u03be \u2208 T\u03a3 we have\nh(\u03be)q1 =\n{ 1 if \u03be = \u03b1\n\u221e otherwise and h(\u03be)q2 =\n{ \u221e if \u03be = \u03b1\nsize(\u03be)\u2212 0.5 otherwise .\nThis can be proved easily by induction on T\u03a3. Then\n[[det(f,g)(A)]](\u03be) = min(h(\u03be)q1 + F \u2032(q1), h(\u03be)q2 + F \u2032(q2)) = size(\u03be)\nwhere the last equality follows from case analysis \u03be = \u03b1 or \u03be 6= \u03b1.\nIn [BVM10, Ex. 3.1] another example of a wta A is shown for which sub(A) is not finite, but det(f,g)(A) is a bu deterministic wta which is equivalent to A.\n17.3. POSITIVE RESULT FOR DETERMINIZATION 351"
        },
        {
            "heading": "17.3.2 Examples and properties of factorizations",
            "text": "We start with some examples of factorizations for extremal and commutative semirings.\nExample 17.3.4. In the following list we show pairs where each pair consists of an extremal and commutative semiring B and a maximal factorization (f, g) over BQ. We assume that u \u2208 BQ \\ {0Q}.\n1. the semiring Boole = (B,\u2228,\u2227, 0, 1) and the trivial factorization\n2. Natmax,+ = (N\u2212\u221e,max,+,\u2212\u221e, 0) and g(u) = min(uq | q \u2208 Q, uq 6= \u2212\u221e) and f(u)q = uq \u2212 g(u) for each q \u2208 Q\n3. Natmax,+,n = ([0, n]\u2212\u221e,max, +\u0302n,\u2212\u221e, 0) where n \u2208 N+ and g(u) = min(uq | q \u2208 Q, uq 6= \u2212\u221e) and f(u)q = uq \u2212 g(u) for every q \u2208 Q\n4. Ratmin,+ = (Q\u221e,min,+,\u221e, 0) and g(u) = min(uq | q \u2208 Q) and f(u)q = uq \u2212 g(u) for each q \u2208 Q\n5. (R\u22650,max, \u00b7, 0, 1) and g(u) = max(uq | q \u2208 Q) and f(u) = 1\ng(u) \u00b7 u\n6. the semiring Viterbi = ([0, 1],max, \u00b7, 0, 1) and g(u) = max(uq | q \u2208 Q) and f(u) = 1\ng(u) \u00b7 u\nNext we will show some properties of factorizations.\nThe last two examples in Example 17.3.4 show particular semifields with maximal factorizations. In fact, for each zero-sum free semifield, we can show a general construction of a maximal factorization.\nLemma 17.3.5. [BVM10, Lm. 4.2] Let B be a zero-sum free semifield. Then (f, g) is a maximal factorization where g(u) = \u2295 q\u2208Q uq and f(u) = g(u) \u22121 \u00b7 u for each u \u2208 BQ \\ {0Q}.\nProof. First we show that (f, g) is a factorization. Let u \u2208 BQ \\ {0Q}. Since B is zero-sum free, g(u) 6= 0 and hence g(u) \u00b7 f(u) = g(u) \u00b7 (g(u)\u22121 \u00b7 u) = (g(u)\u2297 g(u)\u22121) \u00b7 u = u.\nSecond we show that (f, g) is maximal. Let b \u2208 B such that b \u00b7 u 6= 0Q. Moreover let q \u2208 Q. Then\n( f(b \u00b7 u) ) q = ( g(b \u00b7 u)\u22121 \u00b7 (b \u00b7 u) ) q = ( \u2295\nq\u2032\u2208Q\nb\u2297 uq\u2032) \u22121 \u2297 b\u2297 uq\n=(b\u2297 \u2295\nq\u2032\u2208Q\nuq\u2032) \u22121 \u2297 b\u2297 uq = (\n\u2295\nq\u2032\u2208Q\nuq\u2032) \u22121 \u2297 b\u22121 \u2297 b\u2297 uq\n=g(u)\u22121 \u2297 uq = ( f(u) ) q .\nThe next lemma shows that, for a commutative semiring with zero-divisors and |Q| \u2265 2, there does not exist a maximal factorization.\nLemma 17.3.6. [BVM10, Lm. 4.4] If B is commutative and (f, g) is a maximal factorization, then |Q| = 1 or B is zero-divisor free.\nProof. If |Q| = 1, then the statement holds. So assume that |Q| \u2265 2 and let a1 \u2208 B \\ {0} and a2 \u2208 B be such that a1 \u2297 a2 = 0. We choose a pair q1, q2 \u2208 Q such that q1 6= q2. For each i \u2208 {1, 2}, we define the Q-vector ui \u2208 BQ as the Q-vector whose qi-component is 1 while the other components are 0. Since (f, g) is maximal and a1 \u2297 a2 = 0, we have that\nf(u1) = f(a1 \u00b7 u1) = f(a1 \u00b7 u1 + (a1 \u2297 a2) \u00b7 u2) = f(a1 \u00b7 (u1 + a2 \u00b7 u2))\n= f(u1 + a2 \u00b7 u2) .\n352 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS\nLet u = u1 + a2 \u00b7 u2. Since f(u1) = f(u) and (f, g) is a factorization, we obtain the equalities\ng(u1)\u2297 f(u1)q1 = (u1)q1 = 1 (I) g(u1)\u2297 f(u1)q2 = (u1)q2 = 0 (II)\ng(u)\u2297 f(u1)q1 = uq1 = 1 (III) g(u)\u2297 f(u1)q2 = uq2 = a2. (IV)\nBy (I) and (III), and using commutativity, we derive\ng(u1) = g(u1)\u2297 ( g(u)\u2297 f(u1)q1 ) = ( g(u1)\u2297 f(u1)q1 ) \u2297 g(u) = g(u) .\nThen by (II) and (IV) we obtain that a2 = 0. Hence B is zero-divisor free.\nIf |Q| = 1, then A is already bu deterministic and there is no need to determinize it. Thus, as a consequence of Lemma 17.3.6, if we want to determinize by means of maximal factorization a (\u03a3,B)-wta which is not bu deterministic, then B has to be zero-divisor free.\nThe next lemma shows that, e.g., in the representation\nf(\u03b4A(\u03c3)(f(\u03b4A(\u03b1)()), f(\u03b4A(\u03b1)())))\nof a state of Q\u2032, the inner two occurrences of f can be dropped without changing the value of the expression, i.e.,\nf(\u03b4A(\u03c3)(f(\u03b4A(\u03b1)()), f(\u03b4A(\u03b1)()))) = f(\u03b4A(\u03c3)(\u03b4A(\u03b1)(), \u03b4A(\u03b1)())) = f(hA(\u03c3(\u03b1, \u03b1))) .\nThe next lemma also says that dropping the f from \u03b4A(\u03c3)(. . . , f(ui), . . .) 6= 0Q preserves the non-zero property if B is zero-divisor free.\nLemma 17.3.7. [BVM10, Lm. 5.5] Let B be commutative and (f, g) be a maximal factorization. Furthermore, let k \u2208 N, \u03c3 \u2208 \u03a3(k), and u1, . . . , uk \u2208 BQ \\ {0Q}. Then the following two statements hold.\n(1) If \u03b4A(\u03c3)(u1, . . . , uk) 6= 0Q, then \u03b4A(\u03c3)(f(u1), . . . , f(uk)) 6= 0Q and f(\u03b4A(\u03c3)(u1, . . . , uk)) = f(\u03b4A(\u03c3)(f(u1), . . . , f(uk))). (2) If B is zero-divisor free and \u03b4A(\u03c3)(f(u1), . . . , f(uk)) 6= 0Q, then \u03b4A(\u03c3)(u1, . . . , uk) 6= 0Q.\nProof. Clearly we have (\u22c6)\n\u03b4A(\u03c3)(u1, . . . , uk) = \u03b4A(\u03c3)(g(u1) \u00b7 f(u1), . . . , g(uk) \u00b7 f(uk)) ((f, g) factorization)\n= ( g(u1)\u2297 \u00b7 \u00b7 \u00b7 \u2297 g(uk) ) \u00b7 \u03b4A(\u03c3)(f(u1), . . . , f(uk)) . (Lemma 3.6.4)\nProof of (1). Let \u03b4A(\u03c3)(u1, . . . , uk) 6= 0Q. By (\u22c6) also \u03b4A(\u03c3)(f(u1), . . . , f(uk)) 6= 0Q. Applying f to (\u22c6) and using that (f, g) is maximal, we obtain that f(\u03b4A(\u03c3)(u1, . . . , uk)) = f(\u03b4A(\u03c3)(f(u1), . . . , f(uk))).\nProof of (2). We assume that \u03b4A(\u03c3)(f(u1), . . . , f(uk)) 6= 0Q. Since g(ui) 6= 0 for every i \u2208 [k], and since B is zero-divisor free, (\u22c6) yields that \u03b4A(\u03c3)(u1, . . . , uk) 6= 0Q.\nLet B be commutative and (f, g) a maximal factorization. Then the set Q\u2032 of states of det(f,g)(A) can be enumerated by enumerating T\u03a3 in the sense that Q\n\u2032 \u2286 f(hA(T\u03a3) \\ {0Q}) (cf. Lemma 17.3.9). As preparation we have the following easy observation.\nLemma 17.3.8. [BVM10, Obs. 4.5] Let det(f,g)(A) = (Q \u2032, \u03b4\u2032, F \u2032). Moreover, let (Q\u2032n | n \u2208 N) be the family defined by Q\u20320 = \u2205, and for every n \u2208 N we let\nQ\u2032n+1 = Q \u2032 n \u222a {f(\u03b4A(\u03c3)(u1, . . . , uk)) | k \u2208 N, \u03c3 \u2208 \u03a3 (k), u1, . . . , uk \u2208 Q \u2032 n, \u03b4A(\u03c3)(u1, . . . , uk) 6= 0Q} .\nThen Q\u2032 = \u22c3 (Q\u2032n | n \u2208 N). Moreover, Q \u2032 is finite iff there exists an N \u2208 N with Q\u2032N+1 = Q \u2032 N .\n17.3. POSITIVE RESULT FOR DETERMINIZATION 353\nProof. We define the mapping h : P(BQ)\u2192 P(BQ) for each U \u2208 P(BQ) by\nh(U) = U \u222a {f(\u03b4A(\u03c3)(u1, . . . , uk)) | k \u2208 N, \u03c3 \u2208 \u03a3 (k), u1, . . . , uk \u2208 U, \u03b4A(\u03c3)(u1, . . . , uk) 6= 0Q} .\nIt is easy to see that h is continuous. Moreover, we have\nQ\u2032 = \u22c2 (U | U \u2208 P(BQ), h(U) \u2286 U) (by definition of Q\u2032 and h)\n= \u22c3 (hn(\u2205) | n \u2208 N) (by Theorem 2.6.17) = \u22c3\n(Q\u2032n | n \u2208 N) . (by definition of Q \u2032 n and h)\nThe second statement of the lemma is obvious.\nThen we can show the following enumeration lemma (which is based on [KM05, Lm. 2]). Intuitively, it is obtained by iterating Lemma 17.3.7, thereby pulling out f from Q\u20321, then from Q \u2032 2, then from Q \u2032 3, and so on.\nLemma 17.3.9. [BVM10, Lm. 5.8] Let B be commutative, (f, g) a maximal factorization, and det(f,g)(A) = (Q \u2032, \u03b4\u2032, F \u2032). Then Q\u2032 \u2286 f(hA(T\u03a3) \\ {0Q}).\nProof. Again, we prove by case analysis on the cardinality of Q.\nCase (a): Let |Q| = 1. We can identify BQ with B. Then,\nfor each u \u2208 B \\ {0}, we have f(u) = f(1). (17.3)\nTo see this we compute:\nf(u) = f(u \u00b7 1) (where on the left-hand side u \u2208 BQ and on the right-hand side u \u2208 B)\n= f(1) . (because (f, g) is maximal)\nBy our assumption on A, there exists an \u03b1 \u2208 \u03a3(0) such that \u03b4A(\u03b1)() 6= 0. Hence\nhA(\u03b1) = \u03b4A(\u03b1)() 6= 0\nand thus, by (17.3), we have f(hA(\u03b1)) = f(1) and f(hA(T\u03a3) \\ {0}) = {f(1)}.\nNext, by induction on N+, we show that Q \u2032 n = {f(1)} for each n \u2208 N+. The I.B. follows from\nf ( \u03b4A(\u03b1)() ) = f(1) and (17.3); then the I.S. can be proved by using (17.3).\nThus Q\u2032 = {f(1)} and we obtain Q\u2032 = f(hA(T\u03a3) \\ {0}).\nCase (b): Let |Q| > 1. By Lemma 17.3.6, B is zero-divisor free. Using Lemma 17.3.8, it suffices to prove the following statement by induction on N:\nfor each n \u2208 N, we have Q\u2032n \u2286 f(hA(T\u03a3) \\ {0Q}). (17.4)\nI.B.: Let n = 0. Then (17.4) is trivially true.\nI.S.: Let n = n\u2032 + 1 for some n\u2032 \u2208 N. We assume that (17.4) holds for n\u2032. Let u \u2208 Q\u2032n. If u \u2208 Q\u2032n\u2032 , then we are done. Otherwise, there exist k \u2208 N, \u03c3 \u2208 \u03a3\n(k), and u1, . . . , uk \u2208 Q\u2032n\u2032 such that \u03b4A(\u03c3)(u1, . . . , uk) 6= 0Q and u = f(\u03b4A(\u03c3)(u1, . . . , uk)). By I.H., for each i \u2208 [k] there exists \u03bei \u2208 T\u03a3 such that ui = f(hA(\u03bei)). Hence\nu = f(\u03b4A(\u03c3)(u1, . . . , uk)) = f(\u03b4A(\u03c3)(f(hA(\u03be1)), . . . , f(hA(\u03bek)))) .\nBy assumption \u03b4A(\u03c3)(u1, . . . , uk) 6= 0Q, i.e., \u03b4A(\u03c3)(f(hA(\u03be1)), . . . , f(hA(\u03bek))) 6= 0Q. By Lemma 17.3.7(2) (using zero-divisor freeness), \u03b4A(\u03c3)(hA(\u03be1), . . . , hA(\u03bek)) 6= 0Q. Thus, we can continue with:\nf(\u03b4A(\u03c3)(f(hA(\u03be1)), . . . , f(hA(\u03bek)))) = f(\u03b4A(\u03c3)(hA(\u03be1), . . . , hA(\u03bek))) (Lemma 17.3.7(1))\n= f(hA(\u03c3(\u03be1, . . . , \u03bek))) \u2208 f(hA(T\u03a3) \\ {0Q}) .\n354 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS"
        },
        {
            "heading": "17.3.3 On the twinning property",
            "text": "Obviously, there exist (\u03a3,B)-wta which do not have the twinning property. For example, consider the (\u03a3,Natmax,+)-wta A = (Q, \u03b4, F ) with \u03a3 = {\u03b3(1), \u03b1(0)}, Q = {p, q}, and\n\u03b40(\u03b5, \u03b1, p) = 2 \u03b41(p, \u03b3, p) = 5\n\u03b40(\u03b5, \u03b1, q) = 3 \u03b41(q, \u03b3, q) = 7\nand the weight of each other transition is \u2212\u221e. Then, for \u03be = \u03b1 and context c = \u03b3(z), we have\nwt(RA(p, \u03be)) = 2 6= \u2212\u221e wt(RA(p, c, p)) = 5 6= \u2212\u221e\nwt(RA(q, \u03be)) = 3 6= \u2212\u221e wt(RA(q, c, q)) = 7 6= \u2212\u221e\nand wt(RA(p, c, p)) 6= wt(RA(q, c, q)).\nBut, in particular, each bu deterministic wta has the twinning property.\nObservation 17.3.10. The conditions wt(RA(p, \u03be)) 6= 0 and wt(RA(q, \u03be)) 6= 0 imply that p, q \u2208 Q RA 6=0 (\u03be) (cf. Section 4.1). If A is bu deterministic, then by Lemma 4.2.1(2) it follows that p = q. Hence, each bu deterministic wta has the twinning property.\nIn the next example we illustrate that proving the twinning property can be a tedious task even for a small wta.\nExample 17.3.11. We prove that the wta A given in Example 17.1.2 has the twinning property. For the sake of convenience, we repeat the definition of that (\u03a3,Ratmin,+)-wta.\nWe recall that Ratmin,+ = (Q\u221e,min,+,\u221e, 0) is the tropical semifield. We consider the ranked alphabet \u03a3 = {\u03c3(2), \u03b1(0)} and the (\u03a3,Ratmin,+)-wta A = (Q, \u03b4, F ) given by\n\u2022 Q = {p, p\u2032} and Fp = 0 and Fp\u2032 =\u221e and\n\u2022 \u03b40(\u03b5, \u03b1, p) = 1, \u03b42(pp, \u03c3, p) = 1, \u03b42(pp, \u03c3, p \u2032) = 0.5, and \u03b42(p \u2032p, \u03c3, p) = 1.5, and all other values of \u03b40 and \u03b42 are \u221e.\nNext we show thatA has the twinning property. First, by induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(p, \u03be), and \u03c1 \u2032 \u2208 RA(p \u2032, \u03be) we have\n(1) wt(\u03be, \u03c1) =\u221e or wt(\u03be, \u03c1) = size(\u03be) and (2) wt(\u03be, \u03c1\u2032) =\u221e or wt(\u03be, \u03c1\u2032) = size(\u03be)\u2212 0.5.\n(17.5)\nI.B.: Let \u03be = \u03b1. Then (1) holds because RA(p, \u03be) = {\u03c1}, where \u03c1(\u03b5) = p. Hence wt(\u03be, \u03c1) = \u03b40(\u03b5, \u03b1, p) = 1 = size(\u03be). Also, (2) holds because RA(p\n\u2032, \u03be) = {\u03c1}, where \u03c1(\u03b5) = p\u2032. Hence wt(\u03be, \u03c1) = \u03b40(\u03b5, \u03b1, p \u2032) =\u221e.\nI.S.: Let \u03be = \u03c3(\u03be1, \u03be2). For the proof, let \u03c1 \u2208 RA(p, \u03be). Then\nwt(\u03be, \u03c1) = wt(\u03be1, \u03c1|1) + wt(\u03be2, \u03c1|2) + \u03b42(\u03c1(1)\u03c1(2), \u03c3, p), (17.6)\nwhere \u03c1|i is the run induced by \u03c1 at position i for each i \u2208 [2]; in particular, \u03c1|i \u2208 RA(\u03c1(i), \u03bei).\nFor the proof of (17.5)(1), we distinguish three cases as follows.\nCase (a): Let \u03c1(1)\u03c1(2) = pp. By I.H., part (1), wt(\u03bei, \u03c1|i) =\u221e or wt(\u03bei\u03c1|i) = size(\u03bei) for each i \u2208 [2]. If wt(\u03bei, \u03c1|i) =\u221e for some i \u2208 [2], then by (17.6) we have wt(\u03be, \u03c1) =\u221e. Otherwise, again by (17.6), we have wt(\u03be, \u03c1) = size(\u03be1) + size(\u03be2) + \u03b42(pp, \u03c3, p) = size(\u03be1) + size(\u03be2) + 1 = size(\u03be).\nCase (b): Let \u03c1(1)\u03c1(2) = p\u2032p. By I.H., part (2), wt(\u03be1, \u03c1|1) =\u221e or wt(\u03be1, \u03c1|1) = size(\u03be1)\u2212 0.5, and by I.H., part (1), wt(\u03be2, \u03c1|2) =\u221e or wt(\u03be2, \u03c1|2) = size(\u03be2). If wt(\u03bei\u03c1|i) =\u221e for some i \u2208 [2], then by (17.6)\n17.3. POSITIVE RESULT FOR DETERMINIZATION 355\nwe have wt(\u03be, \u03c1) =\u221e. Otherwise, also by (17.6), we have wt(\u03be, \u03c1) = size(\u03be1)\u22120.5+size(\u03be2)+\u03b42(p\u2032p, \u03c3, p) = size(\u03be1)\u2212 0.5 + size(\u03be2) + 1.5 = size(\u03be).\nCase (c): Let \u03c1(1)\u03c1(2) 6\u2208 {pp, p\u2032p}. Then \u03b42(\u03c1(1)\u03c1(2), \u03c3, p) =\u221e and thus by (17.6) we have wt(\u03be, \u03c1) = \u221e.\nFor the proof of (17.5)(2), we distinguish two cases.\nCase (a): Let \u03c1(1)\u03c1(2) = pp. By I.H., part (1), wt(\u03bei, \u03c1|i) =\u221e or wt(\u03bei, \u03c1|i) = size(\u03bei) for each i \u2208 [2]. If wt(\u03bei, \u03c1|i) = \u221e for some i \u2208 [2], then by (17.6) we have wt(\u03be, \u03c1) = \u221e. Otherwise, by (17.6), we have wt(\u03be, \u03c1) = size(\u03be1) + size(\u03be2) + \u03b42(pp, \u03c3, p \u2032) = size(\u03be1) + size(\u03be2) + 0.5 = size(\u03be)\u2212 0.5.\nCase (b): Let \u03c1(1)\u03c1(2) 6= pp. Then \u03b42(\u03c1(1)\u03c1(2), \u03c3, p\u2032) =\u221e and thus by (17.6) we have wt(\u03be, \u03c1) =\u221e.\nThis finishes the proof of (17.5).\nNext we prove the following statement for contexts. For every c \u2208 C\u03a3 \\ {z}:\n(1) for every \u03c1 \u2208 RA(p, c, p): wt(c, \u03c1) =\u221e or wt(c, \u03c1) = size(c)\u2212 1 and (2) for every \u03c1 \u2208 RA(p, c, p \u2032): wt(c, \u03c1) =\u221e or wt(c, \u03c1) = size(c)\u2212 0.5 and (3) for every \u03c1 \u2208 RA(p \u2032, c, p): wt(c, \u03c1) =\u221e or wt(c, \u03c1) = size(c)\u2212 1.5, and (4) for every \u03c1 \u2208 RA(p \u2032, c, p\u2032): wt(c, \u03c1) =\u221e or wt(c, \u03c1) = size(c)\u2212 1.\n(17.7)\nFor the proof, we recall the relation \u227aC\u03a3 on C\u03a3 defined in Chapter 6: for every c1, c2 \u2208 C\u03a3 we have c1 \u227aC\u03a3 c2 if there exists an elementary context c \u2208 eC\u03a3 such that c2 = c[c1]. We denote the restriction of \u227aC\u03a3 to C\u03a3 \\ {z} also by \u227aC\u03a3 and we note that \u227aC\u03a3 is well-founded and min\u227aC\u03a3 (C\u03a3 \\ {z}) = eC\u03a3, i.e., the set of elementary contexts.\nWe prove (17.7) by induction on (C\u03a3 \\ {z},\u227aC\u03a3)\nI.B.: We distinguish the two cases that (a) c = \u03c3(z, \u03be) and (b) c = \u03c3(\u03be, z) for some \u03be \u2208 T\u03a3. Then we proceed as follows.\n(1) Let \u03c1 \u2208 RA(p, c, p). If wt(c, \u03c1) 6=\u221e, then the following two cases are possible:\n\u2022 c has the form (a), \u03c1(1) = \u03c1(2) = p, and \u03c1|2 \u2208 RA(p, \u03be). By (17.5)(1), we have wt(\u03be, \u03c1|2) = size(\u03be). Hence wt(c, \u03c1) = 0 + wt(\u03c1|2) + \u03b42(pp, \u03c3, p) = size(\u03be) + 1 = size(c)\u2212 1. \u2022 c has the form (b), ( \u03c1(1) = \u03c1(2) = p and \u03c1|1 \u2208 RA(p, \u03be) ) or ( \u03c1(1) = p\u2032, \u03c1(2) = p, and\n\u03c1|1 \u2208 RA(p \u2032, \u03be) ) . In the first case, by symmetry, we get as before wt(c, \u03c1) = size(c)\u2212 1. In the\nsecond case, by (17.5)(2), we have wt(\u03be, \u03c1|1) = size(\u03be) \u2212 0.5. Hence wt(c, \u03c1) = wt(\u03c1|1) + 0 + \u03b42(p \u2032p, \u03c3, p) = size(\u03be)\u2212 0.5 + 1.5 = size(\u03be) + 1 = size(c)\u2212 1.\n(2) Let \u03c1 \u2208 RA(p, c, p\u2032). If wt(c, \u03c1) 6=\u221e, then\n\u2022 c has the form (a), \u03c1(1) = p\u2032, \u03c1(2) = p and \u03c1|2 \u2208 RA(p, \u03be). By (17.5)(1), we have wt(\u03be, \u03c1|2) = size(\u03be). Hence wt(c, \u03c1) = 0 + wt(\u03c1|2) + \u03b42(p\u2032p, \u03c3, p) = size(\u03be) + 1.5 = size(c)\u2212 0.5.\n(3) Let \u03c1 \u2208 RA(p\u2032, c, p). If wt(c, \u03c1) 6=\u221e, then the following two cases are possible:\n\u2022 c has the form (a), \u03c1(1) = \u03c1(2) = p, and \u03c1|2 \u2208 RA(p, \u03be). By (17.5)(1), we have wt(\u03be, \u03c1|2) = size(\u03be). Hence wt(c, \u03c1) = 0 + wt(\u03c1|2) + \u03b42(pp, \u03c3, p\u2032) = size(\u03be) + 0.5 = size(c)\u2212 1.5.\n\u2022 c has the form (b), \u03c1(1) = \u03c1(2) = p, and \u03c1|1 \u2208 RA(p, \u03be). By symmetry with the previous case, we obtain wt(c, \u03c1) = size(c)\u2212 1.5.\n(4) Let \u03c1 \u2208 RA(p\u2032, c, p\u2032). We have wt(c, \u03c1) =\u221e because \u03b42(p\u2032q, \u03c3, p) = \u03b42(qp\u2032, \u03c3, p) =\u221e for each q \u2208 Q.\nI.S.: We distinguish the two cases that (a) c = \u03c3(c\u2032, \u03be) and (b) c = \u03c3(\u03be, c\u2032) for some c\u2032 \u2208 C\u03a3 and \u03be \u2208 T\u03a3. Then we proceed as follows.\n356 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS\n(1) Let \u03c1 \u2208 RA(p, c, p). If wt(c, \u03c1) 6=\u221e, then the following two cases are possible:\n\u2022 c has the form (a), \u03c1(1) = \u03c1(2) = p, \u03c1|1 \u2208 RA(p, c\u2032, p), and \u03c1|2 \u2208 RA(p, \u03be). By I.H., part (1), we have wt(c\u2032, \u03c1|1) = size(c\u2032) \u2212 1 and by (17.5)(1), we have wt(\u03be, \u03c1|2) = size(\u03be). Hence wt(c, \u03c1) = wt(c\u2032, \u03c1|1) + wt(\u03be, \u03c1|2) + \u03b42(pp, \u03c3, p) = size(c\u2032)\u2212 1 + size(\u03be) + 1 = size(c)\u2212 1.\n\u2022 c has the form (a), \u03c1(1) = p\u2032, \u03c1(2) = p, \u03c1|1 \u2208 RA(p\u2032, c\u2032, p), and \u03c1|2 \u2208 RA(p, \u03be). By I.H., part (3) we have wt(c\u2032, \u03c1|1) = size(c\n\u2032) \u2212 1.5 and by (17.5)(1), we have wt(\u03be, \u03c1|2) = size(\u03be). Hence wt(c, \u03c1) = wt(c\u2032, \u03c1|1) + wt(\u03be, \u03c1|2) + \u03b42(p\u2032p, \u03c3, p) = size(c\u2032)\u2212 1.5 + size(\u03be) + 1.5 = size(c)\u2212 1.\n\u2022 c has the form (b), \u03c1(1) = \u03c1(2) = p, \u03c1|1 \u2208 RA(p, \u03be), and \u03c1|2 \u2208 RA(p, c\u2032, p). By symmetry with the previous case, we obtain wt(c, \u03c1) = size(c)\u2212 1.\n\u2022 c has the form (b), \u03c1(1) = p\u2032, \u03c1(2) = p, \u03c1|1 \u2208 RA(p\u2032, \u03be) and \u03c1|2 \u2208 RA(p, c\u2032, p). By (17.5)(2), we have wt(\u03be, \u03c1|1) = size(\u03be) \u2212 0.5 and by I.H., part (1), we have wt(c\u2032, \u03c1|2) = size(c\u2032)\u2212 1. Hence wt(c, \u03c1) = wt(\u03be, \u03c1|1) +wt(c\u2032, \u03c1|2) + \u03b42(p\u2032p, \u03c3, p) = size(\u03be)\u2212 0.5+ size(c\u2032)\u2212 1+ 1.5 = size(c)\u2212 1.\n(2) Let \u03c1 \u2208 RA(p, c, p\u2032). If wt(c, \u03c1) 6=\u221e, then we have the following cases.\n\u2022 c has the form (a), \u03c1(1) = p\u2032, \u03c1(2) = p, \u03c1|1 \u2208 RA(p\u2032, c\u2032, p\u2032), and \u03c1|2 \u2208 RA(p, \u03be). By I.H., part (4) and by (17.5)(1), we have wt(c\u2032, \u03c1|1) = size(c\u2032)\u22121 and wt(\u03be, \u03c1|2) = size(\u03be), respectively. Hence wt(c, \u03c1) = wt(c\u2032, \u03c1|1) + wt(\u03be, \u03c1|2) + \u03b42(p\u2032p, \u03c3, p) = size(c\u2032)\u2212 1 + size(\u03be) + 1.5 = size(c)\u2212 0.5.\n\u2022 c has the form (a), \u03c1(1) = \u03c1(2) = p, \u03c1|1 \u2208 RA(p, c\u2032, p\u2032), and \u03c1|2 \u2208 RA(p, \u03be). By I.H., part (2) and by (17.5)(1), we have wt(c\u2032, \u03c1|1) = size(c\u2032) \u2212 0.5 and wt(\u03be, \u03c1|2) = size(\u03be), respectively. Hence wt(c, \u03c1) = wt(c\u2032, \u03c1|1)+wt(\u03be, \u03c1|2)+\u03b42(pp, \u03c3, p) = size(c\u2032)\u22120.5+size(\u03be)+1 = size(c)\u22120.5.\n\u2022 c has the form (b), \u03c1(1) = p\u2032, \u03c1(2) = p, \u03c1|1 \u2208 RA(p \u2032, \u03be), and \u03c1|2 \u2208 RA(p, c \u2032, p\u2032). By (17.5)(2) and by I.H., part (2) wt(\u03be, \u03c1|1) = size(\u03be) \u2212 0.5 and wt(c\u2032, \u03c1|2) = size(c\u2032)\u2212 0.5, respectively. Hence wt(c, \u03c1) = wt(\u03be, \u03c1|1)+wt(c\u2032, \u03c1|2)+\u03b42(p\u2032p, \u03c3, p) = size(\u03be)\u22120.5+size(c\u2032)\u22120.5+1.5 = size(c)\u22120.5.\n\u2022 c has the form (b), \u03c1(1) = \u03c1(2) = p, \u03c1|1 \u2208 RA(p, \u03be), and \u03c1|2 \u2208 RA(p, c\u2032, p\u2032). By symmetry, we have wt(c, \u03c1) = size(c)\u2212 0.5.\n(3) Let \u03c1 \u2208 RA(p\u2032, c, p). If wt(c, \u03c1) 6=\u221e, then the following two cases are possible:\n\u2022 c has the form (a), \u03c1(1) = \u03c1(2) = p, \u03c1|1 \u2208 RA(p, c\u2032, p), and \u03c1|2 \u2208 RA(p, \u03be). By I.H., part (1) and by (17.5)(1), we have wt(c\u2032, \u03c1|1) = size(c\u2032)\u22121 and wt(\u03be, \u03c1|2) = size(\u03be), respectively. Hence wt(c, \u03c1) = wt(c\u2032, \u03c1|1) + wt(\u03be, \u03c1|2) + \u03b42(pp, \u03c3, p\u2032) = size(c\u2032)\u2212 1 + size(\u03be) + 0.5 = size(c)\u2212 1.5.\n\u2022 c has the form (b), \u03c1(1) = \u03c1(2) = p, \u03c1|1 \u2208 RA(p, \u03be), and \u03c1|2 \u2208 RA(p, c\u2032, p). By symmetry with the previous case, we obtain wt(c, \u03c1) = size(c)\u2212 1.5.\n(4) Let \u03c1 \u2208 RA(p \u2032, c, p\u2032). If wt(c, \u03c1) 6=\u221e, then the following two cases are possible:\n\u2022 c has the form (a), \u03c1(1) = \u03c1(2) = p, \u03c1|1 \u2208 RA(p, c\u2032, p\u2032), and \u03c1|2 \u2208 RA(p, \u03be). By I.H., part (2) and by (17.5)(1), we have wt(c\u2032, \u03c1|1) = size(c\u2032) \u2212 0.5 and wt(\u03be, \u03c1|2) = size(\u03be), respectively. Hence wt(c, \u03c1) = wt(c\u2032, \u03c1|1)+wt(\u03be, \u03c1|2)+\u03b42(pp, \u03c3, p \u2032) = size(c\u2032)\u22120.5+size(\u03be)+0.5 = size(c)\u22121.\n\u2022 c has the form (b), \u03c1(1) = \u03c1(2) = p, \u03c1|1 \u2208 RA(p, \u03be), and \u03c1|2 \u2208 RA(p, c\u2032, p\u2032). By symmetry with the previous case, we obtain wt(c, \u03c1) = size(c)\u2212 1.\nThis finishes the proof of the statement 17.7.\nNow we prove that A has the twinning property. In fact, we show that even the following stronger property holds: for every context c \u2208 C\u03a3, if wt(RA(p, c, p)) 6= \u221e and wt(RA(p\u2032, c, p\u2032)) 6= \u221e, then wt(RA(p, c, p)) = wt(RA(p\n\u2032, c, p\u2032)). The proof is as follows. If c = z, then RA(p, c, p) = {\u03c1} with \u03c1(\u03b5) = p and RA(p\n\u2032, c, p\u2032) = {\u03c1\u2032} with \u03c1\u2032(\u03b5) = p\u2032. Hence wt(RA(p, c, p)) = 0 = wt(RA(p\u2032, c, p\u2032)). If c 6= z, then the condition wt(RA(p, c, p)) 6= \u221e implies that there exists a run \u03c1 \u2208 RA(p, c, p) with wt(c, \u03c1) 6=\u221e. By (17.7)(1) we know that wt(c, \u03c1) = size(c)\u22121 for every such \u03c1, hence by the fact that summation of Ratmin,+\n17.3. POSITIVE RESULT FOR DETERMINIZATION 357\nis min, we obtain that wt(RA(p, c, p)) = size(c) \u2212 1. Similarly, the conditions wt(RA(p\u2032, c, p\u2032)) 6= \u221e and (17.7)(4) imply that wt(RA(p \u2032, c, p\u2032)) = size(c)\u2212 1.\nThis ends the proof of the fact that A has the twinning property.\nThus, the (\u03a3,Ratmin,+)-wta A given in Example 17.1.2 has the twinning property. Also the other requirements of Theorem 17.3.2 are satisfied, because Ratmin,+ = (Q\u221e,min,+,\u221e, 0) is an extremal semiring and the pair (f, g) is a maximal factorization with f : (Q\u221e)\nQ \\ {\u221eQ} \u2192 (Q\u221e)Q and g : (Q\u221e) Q \\ {\u221eQ} \u2192 Q\u221e defined for each u = ( up up\u2032 ) in QQ\u221e \\ {\u221eQ} by\nf(u)q = uq \u2212 g(u) for each q \u2208 Q and g(u) = min(up, up\u2032) .\nHence, for the bu deterministic (\u03a3,Ratmin,+)-wta det(f,g)(A) (cf. Figure 17.2), Theorem 17.3.2 guarantees that\n\u2022 [[det(f,g)(A)]] = [[A]] = size and \u2022 det(f,g)(A) is minimal with respect to the number of states among all bu deterministic (\u03a3,Ratmin,+)wta which are equivalent to A and obtained by determinization by factorization.\nWe note that the bu deterministic (\u03a3,Natmin,+)-wta of Example 3.2.3, which also recognizes size, has only one state, and hence it is smaller than det(f,g)(A) (where, in this comparison, we disregard the difference between Natmin,+ and Ratmin,+). However, by means of two transformations, viz. weight pushing and forward bisimulation, we can transform det(f,g)(A) into the (\u03a3,Ratmin,+)-wta of Example 3.2.3 (cf. Figure 17.3). Let us briefly explain these transformations.\nSince Ratmin,+ is a commutative semifield, we can apply weight pushing to det(f,g)(A) (cf. Section 7.3).\nMore precisely, we define the mapping \u03bb( ( 0 \u221e ) ) = 0 and \u03bb( ( 0.5 0 ) ) = 0.5. Then Figure 17.3 shows the (\u03a3,Ratmin,+)-wta push\u03bb(det(f,g)(A)). By Lemma 7.3.2 we have that [[det(f,g)(A)]] = [[push\u03bb(det(f,g)(A))]].\nFor the second transformation (viz., forward bisimulation, cf. [HMM07]), we define the equivalence relation R = Q\u00d7Q. Thus, the factor set Q/R contains one equivalence class, namely Q. One can easily check that R is a forward bisimulation on push\u03bb(det(f,g)(A)) in the sense of [HMM07, Def. 1]. Thus we can construct the forward aggregate (\u03a3,Ratmin,+)-wta (push\u03bb(det(f,g)(A)))/R (cf. [HMM07, Def. 3]). By [HMM07, Thm. 6] we have [[push\u03bb(det(f,g)(A))]] = [[(push\u03bb(det(f,g)(A)))/R]]. (We note that the relation\nR is not a forward bisimulation on det(f,g)(A) because F ( ( 0 \u221e ) ) = 0 6= 0.5 = F ( ( 0.5 0 ) ).) It is obvious that the forward aggregate (\u03a3,Ratmin,+)-wta (push\u03bb(det(f,g)(A)))/R is exactly the (\u03a3,Ratmin,+)-wta A of Example 3.2.3 (modulo state renaming and the change of the weight algebra from Natmin,+ to Ratmin,+).\nFinally, we mention that in [BVM10, Sect. 5.5], [BF12], and [Bu\u0308c14, Sect. 5.4] the question of deciding the twinning property is investigated."
        },
        {
            "heading": "17.3.4 Proof of Theorem 17.3.2",
            "text": "We organize the proof of Theorem 17.3.2 as follows:\n(1) finiteness of det(f,g)(A) (cf. Theorem 17.3.17), (2) correctness of det(f,g)(A) (cf. Theorem 17.3.18), and (3) minimality of det(f,g)(A) (cf. Theorem 17.3.19).\nFiniteness of det(f,g)(A) (proof of Theorem 17.3.2(1))\nHere we show sufficient conditions under which det(f,g)(A) is a (\u03a3,B)-wta (cf. Theorem 17.3.17).\nLet \u03be \u2208 T\u03a3, w \u2208 pos(\u03be), and \u03c1 \u2208 RA(\u03be) such that \u03c1(w) = \u03c1(\u03b5) and assume that B is extremal and commutative. Then the following kind of Bellman optimality property holds (where \u201coptimality\u201d has to be replaced by \u201cvictory\u201d): If \u03c1 is victorious in RA(\u03c1(\u03b5), \u03be)), then \u03c1|w is victorious for RA(\u03c1(\u03b5), \u03be|w , \u03c1(w))\n358 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS\n17.3. POSITIVE RESULT FOR DETERMINIZATION 359\n(modulo right multiplication with wt(\u03be|w, \u03c1|w)). The property is based on the following trivial fact.\nLet B be extremal, b \u2208 B, and B1, B2 \u2286 B be finite subsets. If b \u2208 B1, B1 \u2286 B2, and b = \u2295\nb\u2032\u2208B2\nb\u2032, then b = \u2295\nb\u2032\u2208B1\nb\u2032. (17.8)\nObservation 17.3.12. [BVM10, Obs. 5.12] Let B be extremal and commutative. Moreover, let \u03be \u2208 T\u03a3, w \u2208 pos(\u03be), and \u03c1 \u2208 RA(\u03be) such that \u03c1(w) = \u03c1(\u03b5) and wt(\u03be, \u03c1) = wt(RA(\u03c1(\u03b5), \u03be)). Then\nwt(\u03be, \u03c1) = wt(\u03be|w , \u03c1|w)\u2297 wt(\u03be|w, \u03c1|w) = wt(RA(\u03c1(\u03b5), \u03be| w , \u03c1(\u03b5)))\u2297 wt(\u03be|w, \u03c1|w) .\nProof. We have\nwt(RA(\u03c1(\u03b5), \u03be| w , \u03c1(\u03b5)))\u2297 wt(\u03be|w, \u03c1|w)\n= (\u2295\n\u03bd\u2208RA(\u03c1(\u03b5),\u03be|w,\u03c1(\u03b5)) wt(\u03be|w, \u03bd)\n) \u2297 wt(\u03be|w, \u03c1|w)\n= \u2295\n\u03bd\u2208RA(\u03c1(\u03b5),\u03be|w ,\u03c1(\u03b5)) wt(\u03be|w, \u03bd)\u2297 wt(\u03be|w, \u03c1|w) (by distributivity)\n= wt(\u03be, \u03c1) (\u22c6)\n= wt(\u03be|w, \u03c1|w)\u2297 wt(\u03be|w, \u03c1|w) . (by commutativity)\nAt (\u22c6) we have used (17.8) with\n\u2022 b = wt(\u03be, \u03c1), \u2022 B1 = {wt(\u03be|w, \u03bd)\u2297 wt(\u03be|w, \u03c1|w) | \u03bd \u2208 RA(\u03c1(\u03b5), \u03be|w , \u03c1(\u03b5))}, and \u2022 B2 = {wt(\u03be, \u03bd) | \u03bd \u2208 RA(\u03c1(\u03b5), \u03be)}.\nObviously, (a) b \u2208 B1, (b) by commutativity we have B1 \u2286 B2, and (c) by assumption (viz. wt(\u03be, \u03c1) = wt(RA(\u03c1(\u03b5), \u03be))) we have b = \u2295 b\u2032\u2208B2 b\u2032.\nThe next definitions are taken from [BVM10, Def. 5.13]. Let S \u2286 Q. Then we define\nC\u2032(S) = {(\u03be, \u03ba) | \u03be \u2208 T\u03a3, \u03ba : S \u2192 RA(\u03be), (\u2200q \u2208 S) : \u03baq \u2208 RA(q, \u03be),wt(\u03be, \u03baq) 6= 0} .\nWe set C\u2032 = \u22c3 S\u2286Q C \u2032(S).\nIn the following, we define (a) the mapping wt : C\u2032 \u2192 BQ and (b) for each S \u2286 Q, the family (U(\u03be, \u03ba) | (\u03be, \u03ba) \u2208 C\u2032(S)) and (c) the sets C(S) \u2286 C\u2032(S) and C. To this end, let S \u2286 Q and (\u03be, \u03ba) \u2208 C\u2032(S). Then\n\u2022 for each q \u2208 Q we set wt(\u03be, \u03ba)q = wt(\u03be, \u03baq) if q \u2208 S, otherwise we set wt(\u03be, \u03ba)q = 0,\n\u2022 we define U(\u03be, \u03ba) to be the set of all pairs (w1, w2) \u2208 pos(\u03be)\u00d7 pos(\u03be) such that w1 <pref w2 and for every q \u2208 S we have \u03baq(w1) = \u03baq(w2), and\n\u2022 we have (\u03be, \u03ba) \u2208 C(S) iff for every (w1, w2) \u2208 U(\u03be, \u03ba) and q \u2208 S we have\nwt(\u03be|w1 , \u03baq|w1) = wt(RA(\u03baq(w1), \u03be|w1))\ni.e., \u03baq|w1 is victorious in RA(\u03baq(w1), \u03be|w1)). We set C = \u22c3 S\u2286Q C(S).\nLemma 17.3.13. [BVM10, Lm. 5.14] Let B be commutative and extremal. For each \u03be \u2208 T\u03a3 there exists (\u03be, \u03ba) \u2208 C such that, for each q \u2208 Q, we have wt(\u03be, \u03ba)q = wt(RA(q, \u03be)).\nProof. We begin by showing the following statement:\nfor each \u03be \u2208 T\u03a3 there exists a \u03ba : Q\u2192 RA(\u03be) such that (17.9)\nfor each q \u2208 Q we have \u03baq \u2208 RA(q, \u03be) and P (\u03be, \u03ba, q) holds,\n360 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS\nwhere P (\u03be, \u03ba, q) is the abbreviation of the statement\nfor every w \u2208 pos(\u03be) : wt(\u03be|w, \u03baq|w) = wt(RA(\u03baq(w), \u03be|w)).\nWe prove (17.9) by induction on T\u03a3. Let \u03be = \u03c3(\u03be1, . . . , \u03bek). By I.H., for each i \u2208 [k], there exists a \u03bai : Q\u2192 RA(\u03bei) such that, for each q \u2208 Q, we have (\u03bai)q \u2208 RA(q, \u03bei) and the statement P (\u03bei, \u03bai, q) holds. We define \u03ba as follows: for every q \u2208 Q, we let \u03baq \u2208 RA(\u03be) be such that\n\u2022 \u03baq(\u03b5) = q, \u2022 for every i \u2208 [k] and w \u2208 pos(\u03bei), we let \u03baq(iw) = (\u03bai)pi(w), where the states p1, . . . , pk are defined such that(\u2297\ni\u2208[k]\nwt(\u03bei, (\u03bai)pi) ) \u2297\u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, \u03c3, q) = \u2295\nq1,...qk\u2208Q\n(\u2297\ni\u2208[k]\nwt(\u03bei, (\u03bai)qi) ) \u2297\u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q), (17.10)\nwhere, for each i \u2208 [k], the state pi is defined such that \u2295\nqi\u2208Q\nwt(\u03bei, (\u03bai)qi) = wt(\u03bei, (\u03bai)pi) . (17.11)\nWe recall that such a choice of pi exists by Observation 2.6.7.\nLet q \u2208 Q. We show that P (\u03be, \u03ba, q) holds. For this, let w \u2208 pos(\u03be). We proceed by case analysis.\nCase (a): Let w = \u03b5. Then\nwt(\u03be, \u03baq) = (\u2297\ni\u2208[k]\nwt(\u03be|i, \u03baq|i) ) \u2297 \u03b4k(\u03baq(1) \u00b7 \u00b7 \u00b7\u03baq(k), \u03c3, \u03baq(\u03b5))\n= (\u2297\ni\u2208[k]\nwt(\u03bei, (\u03bai)pi) ) \u2297 \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, \u03c3, q) (by definition of \u03ba)\n= (\u2297\ni\u2208[k]\n\u2295\nqi\u2208Q\nwt(\u03bei, (\u03bai)qi ) ) \u2297 \u03b4k(p1 \u00b7 \u00b7 \u00b7 pk, \u03c3, q) (by (17.11))\n= \u2295\nq1,...,qk\u2208Q\n(\u2297\ni\u2208[k]\nwt(\u03bei, (\u03bai)qi) ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) (by distributivity)\n= \u2295\nq1,...,qk\u2208Q\n(\u2297\ni\u2208[k]\nwt(RA(qi, \u03bei)) ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) (by P (\u03bei, \u03bai, qi) for w = \u03b5)\n= \u2295\nq1,...,qk\u2208Q\n\u2295\n\u03c11\u2208RA(q1,\u03be1)\n. . . \u2295\n\u03c1k\u2208RA(qk,\u03bek)\n(\u2297\ni\u2208[k]\nwt(\u03bei, \u03c1i) ) \u2297 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) (by distributivity)\n= \u2295\n\u03c1\u2208RA(q,\u03be)\nwt(\u03be, \u03c1) = wt(RA(q, \u03be)) = wt(RA(\u03baq(\u03b5), \u03be)) .\nCase (b): Let w = iv. Then wt(\u03be|iv, \u03baq|iv) = wt(\u03bei|v, (\u03bai)pi |v)) = wt(RA((\u03bai)pi(v), \u03bei|v)) = wt(RA(\u03baq(iv), \u03be|iv)), where the second equality holds by P (\u03bei, \u03bai, pi) for v.\nThis finishes the proof of (17.9).\nNow we prove the statement of our lemma. Let \u03be \u2208 T\u03a3. By (17.9) there exists a \u03ba : Q\u2192 RA(\u03be) such that for every q \u2208 Q we have \u03baq \u2208 RA(q, \u03be) and P (\u03be, \u03ba, q). Let S = {q \u2208 Q | wt(RA(q, \u03be)) 6= 0} and \u03ba\u2032 = \u03ba|S . We note that (\u03be, \u03ba \u2032) \u2208 C(S) (and hence, (\u03be, \u03ba\u2032) \u2208 C), because\n\u2022 for every q \u2208 S: \u03ba\u2032q \u2208 RA(q, \u03be) and wt(\u03be, \u03ba \u2032 q) = wt(RA(q, \u03be)) 6= 0 (hence (\u03be, \u03ba \u2032) \u2208 C\u2032(S)) and \u2022 for every w \u2208 pos(\u03be): wt(\u03be|w, \u03ba\u2032q|w) = wt(RA(\u03ba \u2032 q(w), \u03be|w)) by (17.9) (hence (\u03be, \u03ba \u2032) \u2208 C(S)).\nThen, for each q \u2208 S, we have \u03ba\u2032q \u2208 RA(q, \u03be) and P (\u03be, \u03ba \u2032, q). Moreover, for each q \u2208 S:\nwt(\u03be, \u03ba\u2032)q = wt(\u03be, \u03ba \u2032 q) =wt(RA(q, \u03be)).\nIf q \u2208 Q \\ S, then also wt(\u03be, \u03ba\u2032)q = 0 = wt(RA(q, \u03be)) by definitions of wt and of S.\n17.3. POSITIVE RESULT FOR DETERMINIZATION 361\nThe next lemma shows how one slice can be cut out.\nLemma 17.3.14. [BVM10, Lm. 5.15] Let B be extremal and commutative and A have the twinning property. Moreover, let S \u2286 Q and (\u03be, \u03ba) \u2208 C(S) such that U(\u03be, \u03ba) 6= \u2205. Then there exist (\u03be\u2032, \u03ba\u2032) \u2208 C(S) and b \u2208 B such that wt(\u03be, \u03ba) = b \u00b7 wt(\u03be\u2032, \u03ba\u2032) and |U(\u03be, \u03ba)| > |U(\u03be\u2032, \u03ba\u2032)|.\nProof. Since U(\u03be, \u03ba) 6= \u2205, there exists a pair (w1, w2) \u2208 U(\u03be, \u03ba) such that for every (w\u20321, w \u2032 2) \u2208 U(\u03be, \u03ba), if w\u20321 \u2264pref w1, then w \u2032 1 = w1. (Thus, intuitively, there does not exist a repetition of states above w1.) We construct \u03be\u2032 = \u03be[\u03be|w2 ]w1 and, for every q \u2208 S and w \u2208 pos(\u03be \u2032), we set \u03ba\u2032q(w) = \u03baq(w2v) if w = w1v and \u03ba\u2032q(w) = \u03baq(w) otherwise. Before defining b \u2208 B, we show that \u03ba has the following property:\n(\u2200q\u2032, q \u2208 S) : wt(RA(\u03baq\u2032(w1), (\u03be| w2)|w1 , \u03baq\u2032(w2))) = wt(RA(\u03baq(w1), (\u03be| w2)|w1 , \u03baq(w2))). (17.12)\nWe prove (17.12) by using the twinning property of A. Roughly speaking, the twinning property is an implication where the premise has two conditions, viz., (i) certain states repeat and (ii) certain weights are not 0. For (i) we remark that (w1, w2) \u2208 U(\u03be, \u03ba) and thus \u03baq\u2032(w1) = \u03baq\u2032(w2) and \u03baq(w1) = \u03baq(w2). For (ii), by definition, we have wt(\u03be, \u03baq\u2032) 6= 0 and wt(\u03be, \u03baq) 6= 0. Thus, using commutativity,\n\u2022 0 6= wt(\u03be, \u03baq\u2032 ) = wt(\u03bew1 , \u03baq\u2032 |w1)\u2297 wt((\u03be| w2)|w1 , (\u03baq\u2032 | w2)|w1)\u2297 wt(\u03be|w2 , \u03baq\u2032 |w2) and \u2022 0 6= wt(\u03be, \u03baq) = wt(\u03bew1 , \u03baq|w1)\u2297 wt((\u03be| w2)|w1 , (\u03baq| w2)|w1)\u2297 wt(\u03be|w2 , \u03baq|w2)\nand hence\n\u2022 wt((\u03be|w2)|w1 , (\u03baq\u2032 | w2)|w1)\u2297 wt(\u03be|w2 , \u03baq\u2032 |w2) 6= 0 and \u2022 wt((\u03be|w2)|w1 , (\u03baq| w2)|w1)\u2297 wt(\u03be|w2 , \u03baq|w2) 6= 0.\nSince 0 is annihilating, each of the four values\nwt((\u03be|w2)|w1 , (\u03baq\u2032 | w2)|w1), wt(\u03be|w2 , \u03baq\u2032 |w2), wt((\u03be| w2 )|w1 , (\u03baq| w2)|w1), and wt(\u03be|w2 , \u03baq|w2)\nis different from 0. Since B is extremal, and hence by Observation 2.6.11(3,4) it is zero-sum free, we obtain that\n\u2022 wt(RA(\u03baq\u2032(w1), (\u03be|w2)|w1 , \u03baq\u2032(w2))) 6= 0 and wt(RA(\u03baq\u2032(w2), \u03be|w2)) 6= 0 and \u2022 wt(RA(\u03baq(w1), (\u03be| w2 )|w1 , \u03baq(w2))) 6= 0 and wt(RA(\u03baq(w2), \u03be|w2)) 6= 0.\nHence (17.12) follows by the twinning property of A.\nNext we define b by case analysis as follows:\nb =\n{ 0 if S = \u2205\nwt(RA(\u03baq(w1), (\u03be| w2)|w1 , \u03baq(w2))) for some q \u2208 S otherwise.\nWe note that, by (17.12), b does not depend on the choice of q. Now we show that the following three stataments hold:\n(1) (\u03be\u2032, \u03ba\u2032) \u2208 C(S), (2) wt(\u03be, \u03ba) = b \u00b7 wt(\u03be\u2032, \u03ba\u2032), and (3) |U(\u03be, \u03ba)| > |U(\u03be\u2032, \u03ba\u2032)|.\nWe begin with the proof of Statement (1). It is easy to see that (\u03be\u2032, \u03ba\u2032) \u2208 C\u2032(S). Now let (w\u20321, w \u2032 2) \u2208\nU(\u03be\u2032, \u03ba\u2032) and q \u2208 S. We show that wt(\u03be\u2032|w\u20321 , \u03ba \u2032 q|w\u20321) = wt(RA(\u03ba \u2032 q(w \u2032 1), \u03be \u2032|w\u20321)). Note that w \u2032 1 6<pref w1. We distinguish two cases.\nCase (a): There exist v1, v2 \u2208 N\u2217 such that w\u20321 = w1v1 and w \u2032 2 = w1v2 (cf. Fig. 17.4(a)). Since\n\u03ba\u2032q|w1 = \u03baq|w2 for every q \u2208 S, we obtain that (w2v1, w2v2) \u2208 U(\u03be, \u03ba). Hence\nwt(\u03be\u2032|w\u20321 , \u03ba \u2032 q|w\u20321) = wt(\u03be|w2v1 , \u03baq|w2v1) = wt(RA(\u03baq(w2v1), \u03be|w2v1)) = wt(RA(\u03ba \u2032 q(w \u2032 1), \u03be \u2032|w\u20321)) .\nCase (b): Otherwise, \u03ba\u2032q|w\u20321 = \u03baq|w\u20321 (cf. Fig. 17.4(b)). Thus (w \u2032 1, w \u2032 2) \u2208 U(\u03be, \u03ba) and\nwt(\u03be\u2032|w\u20321 , \u03ba \u2032 q|w\u20321) = wt(\u03be|w\u20321 , \u03baq|w\u20321) = wt(RA(\u03baq(w \u2032 1), \u03be|w\u20321)) = wt(RA(\u03ba \u2032 q(w \u2032 1), \u03be \u2032|w\u20321)) .\n362 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS\nNow we prove Statement (2) for the non-trivial case of b, i.e., S 6= \u2205. Let q \u2208 S. Then\nwt(\u03be, \u03baq)\n= wt(\u03be|w1 , \u03baq| w1)\u2297 wt((\u03be|w2 )|w1 , (\u03baq| w2)|w1)\u2297 wt(\u03be|w2 , \u03baq|w2) (because B is commutative) = wt(\u03be|w1 , \u03baq| w1)\u2297 wt(RA(\u03baq(w1), (\u03be| w2)|w1 , \u03baq(w2)))\u2297 wt(\u03be|w2 , \u03baq|w2) (Observation 17.3.12) = b\u2297 wt(\u03be|w1 , \u03baq| w1)\u2297 wt(\u03be|w2 , \u03baq|w2) (because B is commutative) = b\u2297 wt(\u03be\u2032, \u03ba\u2032q) .\nFinally, for the proof of Statement (3), we remark that \u03ba\u2032 is obtained from \u03ba by removing the cycle (w1, w2), and that this process does not introduce new cycles. Hence |U(\u03be, \u03ba)| > |U(\u03be\u2032, \u03ba\u2032)|.\nThe following lemma is used for the proof that our cutting process can only end in a finite set of trees. For this we define the finite set\nF = {(\u03be, \u03ba) \u2208 C\u2032 | height(\u03be) < |Q||Q|} .\nNext we will use U\u22121(\u2205) as shorthand for the set {(\u03be, \u03ba) | U(\u03be, \u03ba) = \u2205}.\nLemma 17.3.15. [BVM10, Lm. 5.16] U\u22121(\u2205) \u2286 F .\nProof. Let (\u03be, \u03ba) \u2208 C\u2032 \\ F . We show that U(\u03be, \u03ba) 6= \u2205 follows. First of all, there exists an S \u2286 Q such that (\u03be, \u03ba) \u2208 C\u2032(S). Since (\u03be, \u03ba) 6\u2208 F , there exists a w \u2208 pos(\u03be) such that |w| \u2265 |Q||S|. Hence, there exist k \u2208 N, w1, . . . , wk \u2208 N\u2217, and u1, . . . , uk \u2208 QS such that k > |Q||S|, wi \u2208 pos(\u03be) for every i \u2208 [k], w1 <pref w2 <pref . . . <pref wk, and \u03baq|wi \u2208 RA((ui)q, \u03be) for every i \u2208 [k] and q \u2208 S. By the pigeon-hole principle, there exist i, j \u2208 [k] such that i < j and ui = uj. Hence \u03baq(wi) = (ui)q = (uj)q = \u03baq(wj) for every q \u2208 S, which means that (wi, wj) \u2208 U(\u03be, \u03ba).\nWe recall that det(f,g)(A) = (Q \u2032, \u03b4\u2032, F \u2032), and by Lemma 17.3.9 we have that Q\u2032 \u2286 f(hA(T\u03a3) \\ {0Q}) if B is commutative and (f, g) is a maximal factorization. If we could show that hA(T\u03a3) is finite, then we have shown that Q\u2032 is finite. In the next lemma we prove that hA(T\u03a3) is finite under the conditions that B is commutative and extremal and A has the twinning property. The idea of the proof is the following. Let us consider a large tree \u03be \u2208 T\u03a3 for which we want to compute hA(\u03be), which is nothing else but the Q-vector (wt(RA(q, \u03be)) | q \u2208 Q). Then, by Lemma 17.3.13, there exists \u03ba : Q \u2192 RA(\u03be) such that, for each q \u2208 Q, we have wt(RA(q, \u03be)) = wt(\u03be, \u03baq) = wt(\u03be, \u03ba)q (which needs extremality), i.e., \u03baq is victorious for RA(q, \u03be). If \u03be is large enough, then there exists a pair (w1, w2) \u2208 pos(\u03be) \u00d7 pos(\u03be) such that \u03baq(w1) = \u03baq(w2). Now we can cut out the slice of \u03be which is determined by w1 and w2. By Lemma 17.3.14, we obtain a pair (\u03be\u2032, \u03ba\u2032) such that wt(\u03be, \u03ba) = b \u00b7 wt(\u03be\u2032, \u03ba\u2032) where b is the weight of the victorious run on the slice which we cut out, and \u03be\u2032 contains one less pair of positions with repeating\n17.3. POSITIVE RESULT FOR DETERMINIZATION 363\nstates. After repeating this cutting process, we end up in a pair (\u03be\u2032\u2032, \u03ba\u2032\u2032) such that \u03be\u2032\u2032 does not contain a pair of positions with repeating states, i.e., (\u03be\u2032\u2032, \u03ba\u2032\u2032) \u2208 U\u22121(\u2205). By Lemma 17.3.15, the set U\u22121(\u2205) is finite.\nThe following lemma is based on [KM05, Thm. 5].\nLemma 17.3.16. [BVM10, Lm. 5.9] If B is commutative and extremal and A has the twinning property, then there exists a finite set P \u2286 BQ with hA(T\u03a3) \u2286 {b \u00b7 u | b \u2208 B, u \u2208 P}.\nProof. Let \u03be \u2208 T\u03a3. We set P = {wt(\u03be, \u03ba) | (\u03be, \u03ba) \u2208 F).\nLet n \u2208 N be maximal such that there exist (\u03be1, \u03ba1), . . . , (\u03ben, \u03ban) \u2208 C and b1, . . . , bn \u2208 B such that\n\u2022 \u03be = \u03be1, \u2022 hA(\u03be) = wt(\u03be1, \u03ba1) and wt(\u03be1, \u03ba1) = bi \u00b7 wt(\u03bei, \u03bai) for every i \u2208 [n], and \u2022 |U(\u03bei+1, \u03bai+1)| < |U(\u03bei, \u03bai)| for every i \u2208 [n\u2212 1].\nWe claim that\nn > 0 (17.13)\nand\n(\u03ben, \u03ban) \u2208 F , (17.14)\nwhich allows us to derive\nhA(\u03be) = wt(\u03be1, \u03ba1) = bn \u00b7 wt(\u03ben, \u03ban) \u2208 {b \u00b7 u | b \u2208 B, u \u2208 P} .\nClaim (17.13) follows from Lemma 17.3.13 if we set b1 = 1. Finally, we prove (17.14). Assume that U(\u03ben, \u03ban) 6= \u2205. By Lemma 17.3.14, there exist (\u03be\u2032, \u03ba\u2032) and b\u2032 such that wt(\u03ben, \u03ban) = b\u2032 \u00b7 wt(\u03be\u2032, \u03ba\u2032) and |U(\u03be\u2032, \u03ba\u2032)| < |U(\u03ben, \u03ban)|. Using \u03ban+1 = \u03ba\u2032 and bn+1 = b\u2032 \u00b7 bn, we see that n was not maximal. Hence, U(\u03ben, \u03ban) = \u2205, and by Lemma 17.3.15, (\u03ben, \u03ban) \u2208 F .\nTheorem 17.3.17. [BVM10, Thm. 5.10] Let B be commutative and extremal and let (f, g) be a maximal factorization of BQ. Moreover, let A have the twinning property. Then det(f,g)(A) is a (\u03a3,B)-wta.\nProof. Let det(f,g)(A) = (Q \u2032, \u03b4\u2032, F \u2032). By Lemma 17.3.9, we have Q\u2032 \u2286 f(hA(T\u03a3) \\ {0Q}). We show that Q\u2032 is finite. Lemma 17.3.16 yields that there exists a finite set P \u2286 BQ such that hA(T\u03a3) \u2286 {b \u00b7 u | b \u2208 B, u \u2208 P}. We calculate\nQ\u2032 \u2286 f(hA(T\u03a3) \\ {0Q}) \u2286 f({b \u00b7 u | b \u2208 B, u \u2208 P} \\ {0Q}) \u2286 f(P \\ {0Q})\nbecause (f, g) is maximal. Hence, Q\u2032 is finite.\nCorrectness of det(f,g)(A) (proof of Theorem 17.3.2(2))\nTheorem 17.3.18. [BVM10, Thm. 5.4] Let (f, g) be a factorization and B be commutative. If det(f,g)(A) is a wta, then [[A]] = [[det(f,g)(A)]].\nProof. Let det(f,g)(A) = (Q \u2032, \u03b4\u2032, F \u2032) be a wta, i.e., Q\u2032 be finite. We abbreviate det(f,g)(A) by A \u2032. By induction on T\u03a3, we prove that the following statement holds:\nFor every \u03be \u2208 T\u03a3, we have: hA(\u03be) =+ u\u2208Q\u2032 hA\u2032(\u03be)u \u00b7 u . (17.15)\n364 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek). Since A\u2032 is bu deterministic, by Lemma 4.2.1(1) there are u\u20321, . . . , u \u2032 k \u2208 Q \u2032 such that, for every i \u2208 [k] and u \u2208 Q\u2032 \\ {u\u2032i}, we have hA\u2032(\u03bei)u = 0. We derive (\u22c6):\nhA(\u03be) = \u03b4A(\u03c3)(hA(\u03be1), . . . , hA(\u03bek))\n= \u03b4A(\u03c3)(+ u1\u2208Q\u2032 hA\u2032(\u03be1)u1 \u00b7 u1, . . . ,+ uk\u2208Q\u2032 hA\u2032(\u03bek)uk \u00b7 uk) (by I.H.) = \u03b4A(\u03c3)(hA\u2032 (\u03be1)u\u20321 \u00b7 u \u2032 1, . . . , hA\u2032(\u03bek)u\u2032k \u00b7 u \u2032 k) = (hA\u2032(\u03be1)u\u20321 \u2297 . . .\u2297 hA\u2032(\u03bek)u\u2032k) \u00b7 \u03b4A(\u03c3)(u \u2032 1, . . . , u \u2032 k), (Lemma 3.6.4)\nwhere Lemma 3.6.4 uses the assumption that B is commutative.\nMoreover, we derive (\u2020): for every u \u2208 Q\u2032\nhA\u2032 (\u03be)u = \u03b4A\u2032(\u03c3)(hA\u2032 (\u03be1), . . . hA\u2032(\u03bek))u\n= \u2295\nu1,...,uk\u2208Q\u2032 hA\u2032(\u03be1)u1 \u2297 . . .\u2297 hA\u2032(\u03bek)uk \u2297 \u03b4 \u2032 k(u1 . . . uk, \u03c3, u)\n= hA\u2032(\u03be1)u\u20321 \u2297 . . .\u2297 hA\u2032(\u03bek)u\u2032k \u2297 \u03b4 \u2032 k(u \u2032 1 . . . u \u2032 k, \u03c3, u) .\nNow we distinguish two cases.\nCase (a): Let \u03b4A(\u03c3)(u \u2032 1, . . . , u \u2032 k) = 0Q. Then (\u22c6) implies hA(\u03be) = 0Q. By definition of \u03b4 \u2032, we have\n\u03b4\u2032k(u \u2032 1 . . . u \u2032 k, \u03c3, u) = 0 for every u \u2208 Q \u2032. Hence, (\u2020) implies hA\u2032(\u03be) = 0Q.\nCase (b): Let \u03b4A(\u03c3)(u \u2032 1, . . . , u \u2032 k) 6= 0Q. Then we set u \u2032 = f(\u03b4A(\u03c3)(u \u2032 1, . . . , u \u2032 k)) and derive\nhA(\u03be) = (hA\u2032 (\u03be1)u\u20321 \u2297 . . .\u2297 hA\u2032(\u03bek)u\u2032k) \u00b7 \u03b4A(\u03c3)(u \u2032 1, . . . , u \u2032 k) (by (\u22c6))\n= (hA\u2032 (\u03be1)u\u20321 \u2297 . . .\u2297 hA\u2032(\u03bek)u\u2032k \u2297 g(\u03b4A(\u03c3)(u \u2032 1, . . . , u \u2032 k))) \u00b7 u \u2032 ((f, g) is a factorization) = hA\u2032 (\u03be)u\u2032 \u00b7 u \u2032 (by definition of \u03b4\u2032k(u \u2032 1 \u00b7 \u00b7 \u00b7u \u2032 k, \u03c3, u \u2032) and by (\u2020)) =+ u\u2208Q\u2032 hA\u2032(\u03be)u \u00b7 u . (Lemma 4.2.1(1))\nNow we show that [[A]](\u03be) = [[A\u2032]](\u03be) for every \u03be \u2208 T\u03a3.\n[[A\u2032]](\u03be) = \u2295\nu\u2208Q\u2032\nhA\u2032(\u03be)u \u2297 F \u2032 u\n= \u2295\nu\u2208Q\u2032\nhA\u2032(\u03be)u \u2297 (\u2295\nq\u2208Q\nuq \u2297 Fq )\n(by construction of det(f,g)(A))\n= \u2295\nu\u2208Q\u2032\n\u2295\nq\u2208Q\n( hA\u2032(\u03be)u \u2297 uq \u2297 Fq ) (by left-distributivity)\n= \u2295\nq\u2208Q\n\u2295\nu\u2208Q\u2032\n( hA\u2032(\u03be)u \u2297 uq \u2297 Fq ) (by commutativity of \u2295)\n= \u2295\nq\u2208Q\n[( \u2295\nu\u2208Q\u2032\nhA\u2032(\u03be)u \u2297 uq ) \u2297 Fq ] (by right-distributivity)\n= \u2295\nq\u2208Q [(+ u\u2208Q\u2032 hA\u2032(\u03be)u \u00b7 u ) q \u2297 Fq ]\n= \u2295\nq\u2208Q\nhA(\u03be)q \u2297 Fq (by (17.15))\n= [[A]](\u03be) .\nMinimality of det(f,g)(A) (proof of Theorem 17.3.2(3))\nThe following theorem corresponds to [KM05, Thm. 3].\n17.3. POSITIVE RESULT FOR DETERMINIZATION 365\nTheorem 17.3.19. [BVM10, Thm. 5.6] Let B be commutative and let (f, g) and (f\u0303 , g\u0303) be factorizations such that (f, g) is maximal. Moreover, let det(f,g)(A) = (Q \u2032, \u03b4\u2032, F \u2032) and det(f\u0303 ,g\u0303)(A) = (Q\u0303, \u03b4\u0303, F\u0303 ). Then Q\u2032 = f(Q\u0303); hence |Q\u2032| \u2264 |Q\u0303|, and if det(f\u0303 ,g\u0303)(A) is a wta, then so is det(f,g)(A).\nProof. We prove by case analysis on the cardinality of Q.\nCase (a): Let |Q| = 1. Then we can identify BQ with B. Since (f, g) is maximal, we have that\nf(B \\ {0}) = {f(1)}. Since Q\u2032 6= \u2205, Q\u0303 6= \u2205, and Q\u0303 \u2286 B \\ {0}, we obtain that Q\u2032 = {f(1)} = f(Q\u0303).\nCase (b): Let |Q| > 1. By Lemma 17.3.6, B is zero-divisor free. Note that (\u22c6) for every u \u2208 BQ \\{0Q},\nwe have g\u0303(u)\u00b7f\u0303(u) = u = g(u)\u00b7f(u), and by applying f we obtain f(f\u0303(u)) = f(u) = f(f(u)) because (f, g) is maximal.\nWe begin with the proof of f(Q\u0303) \u2286 Q\u2032. Using Lemma 17.3.8, it suffices to prove the following statement by induction on N:\nfor every n \u2208 N, we have f(Q\u0303n) \u2286 Q \u2032.\nI.B.: Since Q\u03030 = \u2205, the statement holds trivially.\nI.S.: Let n \u2208 N and u\u0303 \u2208 f(Q\u0303n+1). If u\u0303 \u2208 f(Q\u0303n), then we are ready. Otherwise, there exist k \u2208 N, \u03c3 \u2208 \u03a3(k), and u\u03031, . . . , u\u0303k \u2208 Q\u0303n such that u\u0303 = f(f\u0303(\u03b4A(\u03c3)(u\u03031, . . . , u\u0303k))). Hence\nu\u0303 = f(f\u0303(\u03b4A(\u03c3)(u\u03031, . . . , u\u0303k)))\n= f(\u03b4A(\u03c3)(u\u03031, . . . , u\u0303k)) (\u22c6)\n= f(\u03b4A(\u03c3)(f(u\u03031), . . . , f(u\u0303k))) (Lemma 17.3.7(2) and Lemma 17.3.7(1)) \u2208 Q\u2032 . (I.H. and def. of Q\u2032)\nNow we prove Q\u2032 \u2286 f(Q\u0303). Using Lemma 17.3.8 again, it suffices to prove the following statement by induction on N:\nfor every n \u2208 N, we have Q\u2032n \u2286 f(Q\u0303).\nI.B.: Since Q\u20320 = \u2205, the statement holds trivially. I.S.: Let n \u2208 N and u\u2032 \u2208 Q\u2032n+1. Then there are k \u2208 N, \u03c3 \u2208 \u03a3 (k), and u\u20321, . . . , u \u2032 k \u2208 Q \u2032 n such that\nu\u2032 = f(\u03b4A(\u03c3)(u \u2032 1, . . . , u \u2032 k)). By I.H., there exist u\u03031, . . . , u\u0303k \u2208 Q\u0303 such that u \u2032 i = f(u\u0303i) for every i \u2208 [k]. Hence\nu\u2032 = f(\u03b4A(\u03c3)(f(u\u03031), . . . , f(u\u0303k)))\n= f(\u03b4A(\u03c3)(u\u03031, . . . , u\u0303k)) (Lemma 17.3.7(2) and Lemma 17.3.7(1))\n= f(f\u0303(\u03b4A(\u03c3)(u\u03031, . . . , u\u0303k))) (\u22c6)\n\u2208 f(Q\u0303) ."
        },
        {
            "heading": "17.3.5 Applying determinization by factorization to bu deterministic wta",
            "text": "In this subsection let A = (Q, \u03b4, F ) be a bu deterministic (\u03a3,B)-wta. Then of course there is no need to determinize A. However, in order to show the robustness of determinization by factorization, we apply it to A and a maximal factorization (f, g). We prove that the resulting triple det(f,g)(A) = (Q\n\u2032, \u03b4\u2032, F \u2032) is indeed a bu deterministic wta (i.e., Q\u2032 is finite) by showing that |Q\u2032| \u2264 |Q|. This is due to the fact that hA(T\u03a3) consists of single-valued elements of B\nQ and that f takes single-valued Q-vectors to q-unit vectors. We note that we do not require that B is extremal (which we do in Theorem 17.3.17).\nFormally, for every b \u2208 B and q \u2208 Q, we let bq be the element of B Q such that (bq)q = b and (bq)p = 0 for each p \u2208 Q\\ {q}. Then we define the set of single-valued Q-vectors over B, denoted by BQsv, as the set\nBQsv = {bq \u2208 B Q | q \u2208 Q, b \u2208 B} .\n366 CHAPTER 17. DETERMINIZATION OF WTA OVER SEMIRINGS\nBy Lemma 4.2.1(1), the following is obvious.\nObservation 17.3.20. hA(T\u03a3) \u2286 BQsv.\nThen we can prove the following result.\nCorollary 17.3.21. [Bu\u0308c14, Lm. 5.3.11] Let B be commutative and A = (Q, \u03b4, F ) be a bu deterministic (\u03a3,B)-wta. Moreover, let (f, g) be a maximal factorization and det(f,g)(A) = (Q\n\u2032, \u03b4\u2032, F \u2032). Then we have |Q\u2032| \u2264 |Q|.\nProof. By Lemma 17.3.9 and Observation 17.3.20, we have\nQ\u2032 \u2286 f(hA(T\u03a3) \\ {0Q}) \u2286 f(B Q sv \\ {0Q}) .\nSince (f, g) is maximal, for each q \u2208 Q and bq \u2208 BQsv, we have f(bq) = f(b \u00b7 1q) = f(1q). Hence |f(BQsv \\ {0Q})| \u2264 |f({1q | q \u2208 Q})| \u2264 |Q|, which proves our lemma.\nChapter 18\nSupport of recognizable weighted tree languages\nIn this chapter we will consider the question whether the support of a recognizable (\u03a3,B)-weighted tree language is a recognizable \u03a3-tree language. We will start with a negative result by showing a string ranked alphabet and a (\u03a3, Int)-wta A (where Int is the ring of integers) such that supp([[A]]) is not recognizable. We will continue with positive results and show support theorems ; a support theorem states conditions under which the support of a recognizable weighted tree language is a recognizable tree language. The support theorems concern the run semantics or the initial algebra semantics; moreover, they are based on additional requirements on the wta or on the strong bimonoid."
        },
        {
            "heading": "18.1 Negative result for support",
            "text": "Lemma 18.1.1. [BR88, Ex. III. 3.1] For the (\u03a3, Int)-wta A in Example 3.2.14, we have supp([[A]]) 6\u2208 Rec(\u03a3).\nProof. We recall that \u03a3 = {\u03c3(1), \u03b3(1), \u03b1(0)} and that [[A]](\u03be) = |pos\u03b3(\u03be)| \u2212 |pos\u03c3(\u03be)| for each \u03be \u2208 T\u03a3. Hence\nsupp([[A]]) = {\u03be \u2208 T\u03a3 | |pos\u03b3(\u03be)| 6= |pos\u03c3(\u03be)|}.\nBy contradiction, we can easily prove that supp([[A]]) is not recognizable. For this, we assume that supp([[A]]) \u2208 Rec(\u03a3). The complement of supp([[A]])) is the tree language\nL = {\u03be \u2208 T\u03a3 | |pos\u03b3(\u03be)| = |pos\u03c3(\u03be)|} .\nSince, by Theorem 2.13.3, recognizable \u03a3-tree languages are closed under complement, L is also recognizable. However, this contradicts to Example 6.1.7 in which we proved that L is not a recognizable \u03a3-tree language. Hence supp([[A]]) is not recognizable.\nThe following result immediately follows from Lemma 18.1.1.\nTheorem 18.1.2. There exists a string ranked alphabet \u03a3 such that supp(Rec(\u03a3, Int)) \\ Rec(\u03a3) 6= \u2205."
        },
        {
            "heading": "18.2 Positive results for support",
            "text": "In this section we elaborate some support theorems. By a support theorem we mean a result which, for a certain set of recognizable weighted tree languages, guarantees that the support of each element of\n367\n368 CHAPTER 18. SUPPORT OF RECOGNIZABLE WEIGHTED TREE LANGUAGES\nthat set is a recognizable tree language. We start with a support theorem which can be derived from the preimage theorems. Then we consider (arbitrary) wta and classify the support theorem according to two criteria: the type of semantics of the wta (initial algebra semantics or run semantics) and the set of strong bimonoids. Finally, we compare some of the sets of strong bimonoids for which we have a support theorem."
        },
        {
            "heading": "18.2.1 Consequences of preimage theorems",
            "text": "In Chapter 16 we have proved some preimage theorems. Roughly speaking, each of them states conditions such that the following implication holds: if a recognizable weighted tree language r : T\u03a3 \u2192 B satisfies the conditions, then for each b \u2208 B, the \u03a3-tree language r\u22121(b) is recognizable. In a straightforward way, each of these preimage theorems implies a support theorem. In the next corollary we merely collect these support theorems (without dealing with their relationship).\nCorollary 18.2.1. Let \u03a3 be a ranked alphabet, B be a strong bimonoid, and r : T\u03a3 \u2192 B. If one of the following conditions is satisfied: (1) r is a recognizable step mapping, (2) r \u2208 Recinit(\u03a3,B) and (a) B is locally finite or (b) B is weakly locally finite and \u03a3 is monadic, (3) r \u2208 Recrun(\u03a3,B) and B is bi-locally finite, (4) r \u2208 Recrun(\u03a3,B) and (B, ) is a past-finite monotonic strong bimonoid, then supp(r) \u2208 Rec(\u03a3). Moreover, if r is given effectively, then in each case we can construct a \u03a3-fta A such that supp(r) = L(A).\nProof. Since supp(r) = T\u03a3 \\ r\u22121(0) and the set of \u03a3-recognizable tree languages is closed under complement (cf. Theorem 2.13.3), the following equivalence holds:\nr\u22121(0) is recognizable if and only if supp(r) is recognizable. (18.1)\nThen, each of the four implications is justified by equivalence (18.1) and the corresponding preimage theorem: (1) Theorem 10.3.1(B) \u21d2 (C), (2) Corollary 16.1.4, (3) Corollary 16.2.8, and (4) Theorem 16.2.10(1).\nNow let r be given effectively. Then, in each of the Cases (1)-(3), by the corresponding preimage theorem and Theorem 2.13.3 we can construct a \u03a3-fta A such that supp(r) = L(A). In Case(4) we use Theorem 16.2.10(2) and Theorem 2.13.3 to construct the \u03a3-fta A; note that past(0) = {0}."
        },
        {
            "heading": "18.2.2 Both semantics and positive strong bimonoids",
            "text": "Corollary 3.4.2 is a support theorem for the Boolean semiring. If we analyse the proof of the underlying Theorem 3.4.1, then we realize that we have used the fact that the semiring Boole is positive, i.e., zerosum free and zero-divisor free. In this subsection we generalize Corollary 3.4.2 from Boole to an arbitrary positive strong bimonoid.\nWe define the particular mapping sgn : B \u2192 B for each b \u2208 B by\nsgn(b) =\n{ 1 if b 6= 0\n0 otherwise\nLemma 18.2.2. Let B be positive. Then sgn : B \u2192 B is a strong bimonoid homomorphism from B to Boole.\n18.2. POSITIVE RESULTS FOR SUPPORT 369\nProof. Let b1, b2 \u2208 B. Then\nsgn(b1 \u2295 b2) = 1 iff b1 \u2295 b2 6= 0 iff \u2217 b1 6= 0 \u2228 b2 6= 0\niff (sgn(b1) = 1) \u2228 (sgn(b2) = 1) iff (sgn(b1) \u2228 sgn(b2)) = 1\nwhere at equivalence iff\u2217 from right to left we have used the fact that B is zero-sum free. Thus sgn(b1 \u2295 b2) = sgn(b1) \u2228 sgn(b2). Also\nsgn(b1 \u2297 b2) = 1 iff b1 \u2297 b2 6= 0 iff \u2217 b1 6= 0 \u2227 b2 6= 0\niff (sgn(b1) = 1) \u2227 (sgn(b2) = 1) iff (sgn(b1) \u2227 sgn(b2)) = 1\nwhere at equivalence iff\u2217 from right to left we have used the fact that B is zero-divisor free. Hence sgn(b1 \u2297 b2) = sgn(b1) \u2227 sgn(b2). Moreover, sgn(0) = 0 and sgn(1) = 1. Thus sgn is a strong bimonoid homomorphism.\nOur next support theorem can be compared to [FV09, Thm. 3.12]. In Lemma 18.2.3 we prove that the support of the run semantics of a wta is the same as the support of its initial algebra semantics if the strong bimonoid is positive. Moreover, an fta can be constructed which recognizes the support. Since each monotonic strong bimonoid is positive (cf. Subsection 16.2.3), it contains Corollary 18.2.1(4). In [GV22, Thm. 4.1] a direct proof of the Lemma 18.2.3(1) is given.\nLemma 18.2.3. Let B be positive and A be a (\u03a3,B)-wta. Then the following two statements hold.\n(1) supp([[A]]init) = supp([[A]]run). (2) We can construct a \u03a3-fta A such that L(A) = supp([[A]]init) = supp([[A]]run).\nHence both supp([[A]]run) and supp([[A]]init) are recognizable \u03a3-tree languages.\nProof. Proof of (1): We consider the strong bimonoid homomorphism sgn : B \u2192 B (cf. Lemma 18.2.2). Then we have\nsupp([[A]]init) = supp(sgn \u25e6 [[A]]init)\n= supp([[sgn(A)]]init) (by Lemma 10.9.2) = supp([[sgn(A)]]run) (by Theorem 3.4.1) = supp(sgn \u25e6 [[A]]run) (by Lemma 10.9.2) = supp([[A]]run) .\nProof of (2): By the above, we have supp([[A]]init) = supp([[sgn(A)]]init). Now we construct the (\u03a3,Boole)-wta sgn(A) (cf. Observation 10.9.1). Then we apply Corollary 3.4.2 (B) \u21d2 (A) to sgn(A) and construct a \u03a3-fta A such that L(A) = supp([[sgn(A)]]init). By Statement (1), we also have L(A) = supp([[sgn(A)]]run).\nIt is clear that Lemma 18.2.3 generalizes also Corollary 3.4.2, because Boole is positive. However, we have used Corollary 3.4.2 for the proof of Lemma 18.2.3.\nWe note that, in spite of Lemma 18.2.3(1), there exists a positive strong bimonoid B and (\u03a3,B)-wta A such that [[A]]init 6= [[A]]run; witnesses of this fact are shown in Examples 5.2.1 and 5.2.2, as well as in the proof of Theorem 5.2.5.\nThe following theorem is a generalization of [FV09, Thm. 3.12] from positive semirings to positive strong bimonoids.\nTheorem 18.2.4. Let \u03a3 be a ranked alphabet and B be positive. Then\nRec(\u03a3) = supp(Recinit(\u03a3,B)) = supp(Recrun(\u03a3,B)) .\n370 CHAPTER 18. SUPPORT OF RECOGNIZABLE WEIGHTED TREE LANGUAGES\nProof. The inclusion Rec(\u03a3) \u2286 supp(Recinit(\u03a3,B)) follows from (B) \u21d2 (C) of Theorem 4.3.6 (without using that B is positive). The inclusion supp(Recinit(\u03a3,B)) \u2286 Rec(\u03a3) follows from Lemma 18.2.3(2). Lastly, the second equality follows from Lemma 18.2.3(1).\nAt this point we can prove that Int is not a Fatou extension of Nat (cf. Section 3.7).\nLemma 18.2.5. [KS86, Ex. 8.1 on p. 129] The ring Int is not a Fatou extension of the semiring Nat.\nProof. Let r = [[A]], where A is the (\u03a3, Int)-wta in Example 3.2.14. By Theorem 10.4.1 , r\u2032 = r \u2297 r is also (\u03a3, Int)-recognizable. Moreover, im(r\u2032) \u2286 N, hence r\u2032 \u2208 Rec(\u03a3, Int) \u2229 NT\u03a3 . Next we observe that supp(r\u2032) = supp(r) and hence, by Lemma 18.1.1, the \u03a3-tree language supp(r\u2032) is not recognizable. Since the semiring Nat is positive, by Theorem 18.2.4, we obtain that r\u2032 6\u2208 Rec(\u03a3,Nat)."
        },
        {
            "heading": "18.2.3 Both semantics and commutative semirings which are not rings",
            "text": "Here we show a support theorem which deals with commutative semirings which are not rings. It is based on the following result.\nTheorem 18.2.6. [Wan97, Thm. 2.1] (also cf. [DK21, Lm. 9.3]) Let B be a commutative semiring which is not a ring. Then there exists a semiring homomorphism from B onto the Boolean semiring.\nTheorem 18.2.7. Let \u03a3 be a ranked alphabet and B be a commutative semiring which is not a ring. Moreover, let L \u2286 T\u03a3 be a tree language. If \u03c7B(L) \u2208 Rec(\u03a3,B), then L is in Rec(\u03a3).\nProof. Let \u03c7B(L) \u2208 Rec(\u03a3,B). By Theorem 18.2.6, there exists a semiring homomorphism h : B \u2192 B. Clearly, h(\u03c7B(L)) = \u03c7Boole(L). Then, by Theorem 10.9.3, we have \u03c7Boole(L) \u2208 Rec(\u03a3,Boole). Thus, since L = supp(\u03c7Boole(L)), we have L \u2208 supp(Rec(\u03a3,Boole)). By Corollary 3.4.2 we obtain that L \u2208 Rec(\u03a3)."
        },
        {
            "heading": "18.2.4 Run semantics and commutative, zero-sum free strong bimonoids",
            "text": "In [Kir11, Thm. 3.1] (also cf. [Kir09, Thm. 1]) it was proved that the support of every recognizable (\u0393,B)-weighted string language is a recognizable string language provided that the weight algebra B is a commutative zero-sum free semiring. This generalizes [Wan98, Cor. 5.2] where this result was proved for commutative quasi-positive semirings, because each commutative quasi-positive semiring is a commutative zero-sum free semiring by definition. Here we generalize [Kir11, Thm. 3.1] to the tree case by adapting the proof technique from [Kir11] (also cf. [DH15], [Go\u0308t17, Thm. 4.6], and [FHV18, Thm. 4.3(1)]). Distributivity is not needed.\nIn this subsection we assume that B is commutative.\nLet us consider a (\u03a3,B)-wta A, a tree \u03be \u2208 T\u03a3, and a run \u03c1 \u2208 RA(\u03be). By definition, wtA(\u03be, \u03c1) is the product of some occurrences of elements of im(\u03b4) (cf. Observation 3.1.1). Since im(\u03b4) is finite, we can sort its elements in a vector of n components, where n = |im(\u03b4)|. Then, since \u2297 is commutative, we can represent wtA(\u03be, \u03c1) as a vector z\u0304 \u2208 Nn of the multiplicities of these occurrences. Next we will formalize this representation.\nLet ~b = (b1, . . . , bn) be an arbitrary, but fixed enumeration of im(\u03b4). Then bi 6= bj for i 6= j. Let (z1, . . . , zn), (z \u2032 1, . . . , z \u2032 n) \u2208 N n. Then we define\n(z1, . . . , zn) + (z \u2032 1, . . . , z \u2032 n) = (z1 + z \u2032 1, . . . , zn + z \u2032 n) .\n18.2. POSITIVE RESULTS FOR SUPPORT 371\nIt is clear that the binary operation + is associative. By identifying each bj \u2208 im(\u03b4) with (0, . . . , 0\ufe38 \ufe37\ufe37 \ufe38\nj\u22121 , bj , 0, . . . , 0\ufe38 \ufe37\ufe37 \ufe38 n\u2212j ), we have\n(z1, . . . , zn) + bj = (z1, . . . , zj\u22121, zj + 1, zj+1, . . . , zn) .\nFor the inductive definition of the representation, we use the well-founded set (TR,\u227a) defined in Section 3.1 on p. 63. For the sake of convenience we recall that TR = {(\u03be, \u03c1) | \u03be \u2208 T\u03a3, \u03c1 \u2208 RA(\u03be)} and that the well-founded relation \u227a on TR is the binary relation\n\u227a= { ( (\u03be|i, \u03c1|i), (\u03be, \u03c1) ) | (\u03be, \u03c1) \u2208 TR, i \u2208 [rk(\u03be(\u03b5))]} .\nClearly min\u227a(TR) = {(\u03b1, \u03c1) | \u03b1 \u2208 \u03a3(0), \u03c1 : {\u03b5} \u2192 Q}. Then we define the mapping (.) : TR \u2192 Nn by induction on (TR,\u227a) for every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be) by\n(\u03be, \u03c1) = (0, . . . , 0) + (\u03be|1, \u03c1|1) + . . .+ (\u03be|k, \u03c1|k) + \u03b4k(\u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03be(\u03b5), \u03c1(\u03b5))\nwhere k = rk(\u03be(\u03b5)). We have added the vector (0, . . . , 0) in order to have (\u03be, \u03c1) well defined for the case k = 0.\nMoreover, each vector ~z = (z1, . . . , zn) \u2208 Nn represents an element of B. Formally, we define the mapping [[.]] : Nn \u2192 B for each ~z = (z1, . . . , zn) \u2208 N n by\n[[~z ]] = bz11 \u2297 . . .\u2297 b zn n .\nSince B is commutative,\nfor every \u03be \u2208 T\u03a3 and \u03c1 \u2208 RA(\u03be), we have wtA(\u03be, \u03c1) = [[(\u03be, \u03c1)]] . (18.2)\nIn other words, wtA = [[.]] \u25e6 (.). In this sense, the vector (\u03be, \u03c1) represents wtA(\u03be, \u03c1).\nNext we will analyse the set [[.]]\u22121(0) of vectors ~z \u2208 Nn which are mapped to 0. (We note that (0, . . . , 0) 6\u2208 [[.]]\u22121(0), because b01 \u2297 . . .\u2297 b 0 n = 1.)\nFor this, we consider the partially ordered set (Nn,\u2264), where the binary relation \u2264 is defined as follows: for all vectors ~z = (z1, . . . , zn) \u2208 Nn and ~y = (y1, . . . , yn) \u2208 Nn, we define ~z \u2264 ~y if zi \u2264 yi for each i \u2208 [n]. We note that, for every ~z , ~y \u2208 Nn, if [[~z ]] = 0 and ~z \u2264 ~y , then [[~y ]] = 0 (because 0 is annihilating). Let M \u2286 Nn. An element ~z \u2208 M is minimal in M if, for each ~y \u2208 M , the assumption ~y \u2264 ~z implies ~y = ~z. We denote by min(M) the set of all minimal elements in M . Thus, in particular, min(\u2205) = \u2205. The following result is called Dickson\u2019s Lemma.\nLemma 18.2.8. [Dic13] (cf. also [Kir11, Lm. 2.1] and [KR08]) For each M \u2286 Nn, the set min(M) is finite.\nBy Lemma 18.2.8, the set min([[.]]\u22121(0)) is finite. Hence there exists a smallest number m \u2208 N satisfying min([[.]]\u22121(0)) \u2286 {0, . . . ,m}n, and we call this number m the degree of ~b and denote it by dg(~b ). (We note that if B is zero-divisor free and 0 6\u2208 im(\u03b4), then [[.]]\u22121(0) = \u2205, hence dg(~b ) = 0. We also note that, for any other enumeration ~b\u2032 of im(\u03b4), we have dg(~b) = dg(~b\u2032).)\nThe next lemma states that, if [[~z ]] = 0 for some ~z , then also the evaluation of ~z \u2032 results in 0 where ~z \u2032 is obtained from ~z by restricting the components to dg(~b). Formally, for every ~z \u2208 Nn, we define the cut of ~z , denoted by \u230a~z \u230bdg(~b), to be the vector \u230a~z \u230bdg(~b) \u2208 N n with\n(\u230a~z \u230bdg(~b))i = min{zi, dg( ~b)}\nas i-th component for each i \u2208 [n].\n372 CHAPTER 18. SUPPORT OF RECOGNIZABLE WEIGHTED TREE LANGUAGES\nLemma 18.2.9. ([Kir11, Lm. 4.1]) For every ~z \u2208 Nn, we have [[~z ]] = 0 iff [[\u230a~z \u230bdg(~b)]] = 0.\nProof. Let [[\u230a~z \u230bdg(~b)]] = 0. Since \u230a~z \u230bdg(~b) \u2264 ~z and 0 is an annihilator for \u2297, we have [[~z ]] = 0.\nNow let [[~z ]] = 0. Then there exists a ~y \u2208 min([[.]]\u22121(0)) such that ~y \u2264 ~z . We prove that y\u0304 \u2264 \u230a~z \u230bdg(~b). For this let y\u0304 = (y1, . . . , yn), ~z = (z1, . . . , zn), and i \u2208 [n]. If zi \u2264 dg(~b), then yi \u2264 zi = (\u230a~z \u230bdg(~b))i. If zi > dg(~b), then yi \u2264 dg(~b) = (\u230a~z \u230bdg(~b))i. Hence ~y \u2264 \u230a~z \u230bdg(~b) and thus [[\u230a~z \u230bdg(~b)]] = 0.\nIn Figure 18.1 we indicate the partial order on N3. We assume that min([[.]]\u22121(0)) = {~z1, ~z2, ~z3}. For each i \u2208 {1, 2, 3} we indicate the set {~y | ~zi \u2264 ~y } by a shaded filter. Clearly, for each ~y in one of these filters we have [[~y ]] = 0. We also indicate the set {0, . . . , j}n for j = 0, j = 1, and j = dg(~b).\nNow we can prove the main support theorem of this subsection. We follow the proof of the corresponding result [Kir11, Thm. 3.1] for weighted string automata over semirings. This result has been generalized to (a) weighted unranked tree automaton over zero-sum free, commutative strong bimonoids [DH15] and (b) weighted unranked tree automata over zero-sum free, commutative, zero-preserving tvmonoids [Go\u0308t17, Thm. 4.7]. We also refer to [FHV18, Thm. 4.4] where the support theorem was proved for weighted tree automata over \u03c3-complete and commutative strong bimonoids1.\n1(We note that, by Observation 2.6.11(7), \u03c3-completeness implies zero-sum freeness.)\n18.2. POSITIVE RESULTS FOR SUPPORT 373\nTheorem 18.2.10. Let \u03a3 be a ranked alphabet, B be a commutative strong bimonoid, and A be a (\u03a3,B)wta. If (a) B is zero-sum free or (b) A is bu deterministic and root weight normalized, then supp([[A]]run) \u2208 Rec(\u03a3).\nProof. Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. If A is not root weight normalized, then by Theorem 7.3.1 we can construct a run equivalent and root weight normalized (\u03a3,B)-wta. Hence, in both cases (a) and (b) we may assume that A is root weight normalized. Thus, there exists qf \u2208 Q such that Fqf = 1 and Fq = 0 for each q \u2208 Q \\ {qf}. Let ~b = (b1, . . . , bn) \u2208 Bn be an arbitrary but fixed enumeration of im(\u03b4).\nThen we define the \u03a3-fta A = (Q\u2032, \u03b4\u2032, F \u2032) which counts, up to the threshold dg(~b ), the number of\noccurrences of the bj \u2019s in the runs of A. Formally, we let T = {0, . . . , dg(~b )} and we define\n\u2022 Q\u2032 = Q\u00d7 T n, \u2022 F \u2032 = {(qf , ~z ) \u2208 Q\u2032 | [[~z ]] 6= 0}, \u2022 we define for each k \u2208 N\n\u03b4\u2032k = {((q1, ~z1) \u00b7 \u00b7 \u00b7 (qk, ~zk), \u03c3, (q, ~z)) | \u03c3 \u2208 \u03a3 (k), ((q1, ~z1) \u00b7 \u00b7 \u00b7 (qk, ~zk)) \u2208 (Q \u2032)k, (q, ~z) \u2208 Q\u2032,\n~z = \u230a(0, . . . , 0) + ~z1 + . . .+ ~zk + \u03b4k(q1 . . . qk, \u03c3, q)\u230bdg(~b)} .\nNow we prove that supp([[A]]run) = L(A). First, for each \u03be \u2208 T\u03a3, we define the mapping\n\u03d5 : RA(\u03be)\u2192 R v A(\u03be)\nas follows. For every \u03c1 \u2208 RA(\u03be), we define the family (\u03d5(\u03c1)(w) | w \u2208 pos(\u03be)) of states \u03d5(\u03c1)(w) \u2208 Q\u2032.\nFor this definition, we recall the binary relation \u227a on pos(\u03be) defined by w1 \u227a w2 if there exists i \u2208 N such that w1 = w2i, for every w1, w2 \u2208 pos(\u03be) (cf. the proof of Lemma 10.8.1). Then \u227a is well-founded and min\u227a(pos(\u03be)) = pos\u03a3(0)(\u03be), i.e., it is the set of leaves of \u03be.\nNow we define \u03d5(\u03c1) by induction on (pos(\u03be),\u227a) as follows. Let w \u2208 pos(\u03be) with \u03be(w) = \u03c3 for some \u03c3 \u2208 \u03a3(k) with k \u2208 N. We assume that \u03d5(\u03c1)(wi) = (qi, ~zi) for each i \u2208 [k]. Then we define\n\u03d5(\u03c1)(w) = ( \u03c1(w), \u230a(0, . . . , 0) + ~z1 + . . .+ ~zk + \u03b4k(q1 . . . qk, \u03c3, \u03c1(w))\u230bdg(~b) ) .\nIt is clear that \u03d5 is bijective. Moreover, by induction on T\u03a3, we can prove the following:\nfor every \u03be \u2208 T\u03a3, (q, ~z) \u2208 Q \u2032, and \u03c1\u2032 \u2208 RvA((q, ~z), \u03be): ~z = \u230a(\u03be, \u03d5 \u22121(\u03c1\u2032))\u230bdg(~b) (18.3)\nLet \u03be = \u03c3(\u03be1, . . . , \u03bek), (q, ~z) \u2208 Q\u2032, and \u03c1\u2032 \u2208 RvA((q, ~z), \u03be). Then, for each i \u2208 [k], there exist (qi, ~zi) \u2208 Q \u2032 such that \u03c1\u2032|i \u2208 RvA((qi, ~zi), \u03bei) and\n~z = \u230a(0, . . . , 0) + ~z1 + . . .+ ~zk + \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\u230bdg(~b) . (18.4)\nThen we can calculate as follows (where we abbreviate \u230a.\u230bdg(~b) by \u230a.\u230b):\n\u230a(\u03c3(\u03be1, . . . , \u03bek), \u03d5\u22121(\u03c1\u2032))\u230b\n= \u230a(0, . . . , 0) + (\u03be1, \u03d5\u22121(\u03c1\u2032|1)) + . . .+ (\u03bek, \u03d5\u22121(\u03c1\u2032|k) + \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\u230b (by definition of (.))\n= \u230a(0, . . . , 0) + \u230a(\u03be1, \u03d5\u22121(\u03c1\u2032|1))\u230b + . . .+ \u230a(\u03bek, \u03d5\u22121(\u03c1\u2032|k)\u230b + \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\u230b (because \u230a~y1 + ~y2\u230b = \u230a~y1 + \u230a~y2\u230b\u230b = \u230a\u230a~y1\u230b + \u230a~y2\u230b\u230b for every ~y1, ~y2 \u2208 T n)\n= \u230a(0, . . . , 0) + ~z1 + . . .+ ~zk + \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q)\u230b (by I.H.)\n= ~z . (by (18.4))\nThis proves (18.3).\n374 CHAPTER 18. SUPPORT OF RECOGNIZABLE WEIGHTED TREE LANGUAGES\nNow let \u03be \u2208 T\u03a3. We note that, if B is not zero-sum free, then A is bu deterministic. Then\n\u03be \u2208 supp([[A]]run) iff [[A]]run(\u03be) 6= 0\niff \u2295\n\u03c1\u2208RA(qf ,\u03be)\nwtA(\u03be, \u03c1) 6= 0 (because supp(F ) = {qf} and Fqf = 1)\niff (\u2203\u03c1 \u2208 RA(qf , \u03be)) : wtA(\u03be, \u03c1) 6= 0 (because B is zero-sum free or A is bu deterministic) iff (\u2203~z \u2208 T n)(\u2203\u03c1\u2032 \u2208 RvA((qf , ~z), \u03be)) : wtA(\u03be, \u03d5 \u22121(\u03c1\u2032)) 6= 0 (because \u03d5 is bijective) iff (\u2203~z \u2208 T n)(\u2203\u03c1\u2032 \u2208 RvA((qf , ~z), \u03be)) : [[(\u03be, \u03d5 \u22121(\u03c1\u2032))]] 6= 0 (by 18.2) iff (\u2203~z \u2208 T n)(\u2203\u03c1\u2032 \u2208 RvA((qf , ~z), \u03be)) : [[\u230a(\u03be, \u03d5 \u22121(\u03c1\u2032))\u230bdg(~b )]] 6= 0 (Lemma 18.2.9) iff (\u2203~z \u2208 T n)(\u2203\u03c1\u2032 \u2208 RvA((qf , ~z), \u03be)) : [[~z ]] 6= 0 (by 18.3) iff (\u2203q\u2032 \u2208 F \u2032) : RvA(q \u2032, \u03be) 6= \u2205 (by construction of F \u2032) iff \u03be \u2208 L(A) .\nAs a direct consequence of Theorem 18.2.10 we obtain a support theorem for wta over each strong bimonoid in which the summation is a t-conorm (cf. Example 2.6.10(4) and thus, in particular, for wta over UnitIntu,i where u is a t-conorm and i is a t-norm. The latter consequence generalizes the case \u03bb = 0 of [San68, Thm. 7] from UnitIntmax,min to UnitIntu,i for each tuple (u, i) of t-conorm u and t-norm i.\nCorollary 18.2.11. Let B = ([0, 1], u,\u2297, 0, 1) be a commutative strong bimonoid such that u is a tconorm. Moreover, let A be a (\u03a3,B)-wta. Then supp([[A]]run) \u2208 Rec(\u03a3).\nProof. We show that B = ([0, 1], u,\u2297, 0, 1) is zero-sum free. Then the statement follows from Theorem 18.2.10.\nLet a, b \u2208 [0, 1] and u(a, b) = 0. Using the boundary condition and monotonicity condition of u (cf. Example 2.6.10(4)), we have\na = u(a, 0) (by the boundary condition for u)\n\u2264 u(a, b) (by monotonicity condition for u)\n= 0 . (by assumption)\nThis implies that a = 0. In a similar way we can derive that b = 0. Hence B = ([0, 1], u,\u2297, 0, 1) is zero-sum free.\nIn Theorem 18.2.10(a), the strong bimonoid B is assumed to be commutative and zero-sum free. The theorem is not constructive because, in order to construct an fta which accepts the support of a run recognizable weighted tree language, we should construct dg(~b). However, it is not clear how to construct dg(~b). We mention that in [Kir11] the zero generation problem (ZGP) is considered, and the decidability of the ZGP implies that dg(~b) can be constructed and hence the fta in the support theorem can be constructed.\nIn the following theorem, we require additionally that B is multiplicatively idempotent. Then we do not need to compute dg(~b) and we can construct the desired fta. We note that our assumption on B implies that the ZGP is decidable. However, we do not wish to include the ZGP in our proof. For more details on ZGP we refer to, e.g., [Kir11, DH15, Go\u0308t17, FHV18].\nTheorem 18.2.12. Let \u03a3 be a ranked alphabet and B be a zero-sum free, commutative, and multiplicatively idempotent strong bimonoid. Then, for each (\u03a3,B)-wta A, we can construct a \u03a3-fta A such that L(A) = supp([[A]]run).\n18.2. POSITIVE RESULTS FOR SUPPORT 375\nProof. Let A = (Q, \u03b4, F ) be a (\u03a3,B)-wta. By Theorem 7.3.1 we can assume that A is root weight normalized and Fqf = 1 and Fq = 0 for each q \u2208 Q \\ {qf}. Let ~b = (b1, . . . , bn) \u2208 Bn be an arbitrary but fixed enumeration of im(\u03b4).\nSince B is commutative and multiplicatively idempotent, it is clear that min([[.]]\u22121(0)) \u2286 {0, 1}n. Hence, instead of dg(~b), we can use 1 as threshold for the frequency with which an element of im(\u03b4) can occur in the weight of a run. More precisely, we construct the \u03a3-fta A in the same way as in the proof of Theorem 18.2.10 except that we define the set Q\u2032 of states of A by Q\u2032 = Q \u00d7 {0, 1}n. We obtain L(A) = supp([[A]]run).\nFinally we mention that in [Kir14, Thm. 3.5] the following characterization result was shown: for each semiring B, the supports of all recognizable B-weighted string languages are recognizable if and only if in every finitely generated subsemiring of B, there exists a congruence of finite index such that {0} is a singleton congruence class. We refer the reader for further support theorems for wsa to [BR88, DK21]."
        },
        {
            "heading": "18.2.5 Comparison of support theorems",
            "text": "Finally, we will make two comparisons of the support theorems shown in Figure 18.2. First we compare some support theorems concerning run semantics, then we do the same for initial algebra semantics. Since each such support theorem requires a particular subset of strong bimonoids, we compare these support theorems by comparing the corresponding sets of strong bimonoids with respect to set inclusion. We denote the involved sets of strong bimonoids as follows:\nC: set of all strong bimonoids, C1: set of all positive strong bimonoids, C2: set of all commutative semirings which are not rings, C3: set of all commutative, zero-sum free strong bimonoids, C4: set of all locally finite strong bimonoids, C5: set of all bi-locally finite strong bimonoids.\nHence, first we compare the sets C, C1, C2, C3, and C5 (cf. Theorem 18.2.14), and second the sets C, C1, C2, and C4 (cf. Theorem 18.2.15).\nThe following is observation is trivial, but useful.\nObservation 18.2.13. (C1 \u2229 C2) \u2286 C3.\nTheorem 18.2.14. [DM20, Dro22] Figure 18.3 shows the Euler diagram of the sets C1, C2, and C3. Moreover, for each of the shown seven nonempty regions X, we show two strong bimonoids Bi and Bj in the form of the fraction Bi\nBj such that Bi \u2208 X \u2229 C5 and Bj \u2208 X \\ C5.\n376 CHAPTER 18. SUPPORT OF RECOGNIZABLE WEIGHTED TREE LANGUAGES\nProof. For the sake of a more complete picture, we also show the set C of all strong bimonoids in Figure 18.3. In the following, we prove that each of the seven regions X which are shown in the figure is not empty. Together with Observation 18.2.13 this proves that Figure 18.3 is the Euler diagram of C1, C2, and C3. Interleaved, we prove the existence of Bi and Bj with the desired properties.\nWe organize the proof as follows. Since there are four sets involved (viz. C1, C2, C3, and C5) there exist 16 Boolean combinations of these sets. Each Boolean combination is identified by an expression of the form D \\E where D is the intersection of some of the sets in {C1, C2, C3, C5} and E is the union of those sets in {C1, C2, C3, C5} which do not occur in D. We order the 16 Boolean combinations by increasing number of sets occurring in E, starting with E = \u2205.\nC1 \u2229 C2 \u2229 C3 \u2229 C5 6= \u2205: By Observation 18.2.13, C1 \u2229 C2 \u2229 C3 \u2229 C5 = C1 \u2229 C2 \u2229 C5. The Boolean semiring B1 = Boole = (B,\u2228,\u2227, 0, 1) is in C1 \u2229 C2 \u2229 C5.\n(C2 \u2229 C3 \u2229 C5) \\ C1 6= \u2205: Let A = {a, b} be a set. The commutative semiring\nB2 = PSA = (P(A),\u222a,\u2229, \u2205, A)\nis not zero-divisor free, because, e.g., {a} \u2229 {b} = \u2205 and {a} 6= \u2205 and {b} 6= \u2205. Hence B2 6\u2208 C1. Since B2 is zero-sum free, finite, and not a ring, we have B2 \u2208 C2 \u2229 C3 \u2229 C5.\n(C1 \u2229 C3 \u2229 C5) \\ C2 6= \u2205: We consider the algebra\nB3 = ({0, 1, 2, 3, 4},+ \u2032,min, 0, 4)\nwhere a+\u2032 b = min(a+ b, 4). Obviously B3 is a commutative strong bimonoid. Since B3 is also finite and positive, it is in C1\u2229C3\u2229C5. B3 is not distributive, because min(2, 2+\n\u2032 2) = 2 and min(2, 2)+\u2032min(2, 2) = 2 +\u2032 2 = 4. Hence B3 6\u2208 C2.\n(C1 \u2229 C2 \u2229 C5) \\ C3 = \u2205: This follows from Observation 18.2.13.\n(C1 \u2229 C2 \u2229 C3) \\ C5 6= \u2205: By Observation 18.2.13, (C1 \u2229 C2 \u2229 C3) \\ C5 = (C1 \u2229 C2) \\ C5. The semiring\nB4 = Nat = (N,+, \u00b7, 0, 1)\nof natural numbers is positive and commutative, it is not a ring and not bi-locally finite.\n(C3 \u2229 C5) \\ (C1 \u222a C2) 6= \u2205: We consider the algebra\nB5 = ({0, 1, 2, 3},+ \u2032, \u00b74, 0, 1)\nwhere a +\u2032 b = min(a + b, 3) and \u00b74 is multiplication modulo 4. Obviously, B5 is a commutative strong bimonoid. Since B5 is commutative, finite, and zero-sum free, we have B5 \u2208 C3 \u2229 C5. Since 2 \u00b74 2 = 0,\n18.2. POSITIVE RESULTS FOR SUPPORT 377\nB5 6\u2208 C1. The strong bimonoid B5 is not distributive, because 2 \u00b74 (3 +\u2032 1) = 2 and 2 \u00b74 3 +\u2032 2 \u00b74 1 = 3. Thus B5 6\u2208 C2.\n(C2 \u2229 C5) \\ (C1 \u222a C3) 6= \u2205: The semiring\nB6 = PS{a,b} = (P({a, b}),\u2229,\u222a, {a, b}, \u2205)\nis commutative, not a ring, and finite; hence B6 \u2208 C2 \u2229 C5. Moreover, B6 is not zero-sum free; hence B6 6\u2208 C1 \u222a C3.\n(C2 \u2229 C3) \\ (C1 \u222a C5) 6= \u2205: We consider the commutative semiring\nB7 = (N\u00d7 N,+,\u00d7, (0, 0), (1, 1))\nwith componentwise addition and multiplication. This is not a ring (hence B7 \u2208 C2), and it is zero-sum free (hence B7 \u2208 C3). Moreover, B7 is not zero-divisor free because, e.g., (1, 0) \u00d7 (0, 1) = (0, 0) (hence B7 6\u2208 C1) and not bi-locally finite (hence B7 6\u2208 C5).\n(C1 \u2229 C5) \\ (C2 \u222a C3) 6= \u2205: By Observation 18.2.13, (C1 \u2229 C5) \\ (C2 \u222a C3) = (C1 \u2229 C5) \\ C3. We consider the algebra\nB8 = ({0, a, b, 1},+, \u00b7, 0, 1)\nwhere + is defined as supremum with respect to the partial order 0 < a < b < 1; moreover, the operation \u00b7 is determined by x \u00b7 y = x for every x, y \u2208 {a, b}. Then ({0, a, b, 1},+, 0) and ({0, a, b, 1}, \u00b7, 1) are commutative monoids and x \u00b7 0 = 0. Hence B8 is a strong bimonoid.\nMoreover, B8 is zero-sum free and zero-divisor free (hence B8 \u2208 C1) and B8 is finite (hence B8 \u2208 C5). Since \u00b7 is not commutative (a \u00b7 b 6= b \u00b7 a), we have B8 6\u2208 C3.\n(C1 \u2229 C3) \\ (C2 \u222a C5) 6= \u2205: The tropical bimonoid\nB9 = TropBM = (N\u221e,+,min, 0,\u221e)\nis positive and commutative, hence B9 \u2208 C1 \u2229 C3. But B9 is neither distributive nor bi-locally finite.\n(C1 \u2229 C2) \\ (C3 \u222a C5) = \u2205: This follows from Observation 18.2.13.\nC1 \\ (C2 \u222a C3 \u222a C5) 6= \u2205: By Observation 18.2.13, C1 \\ (C2 \u222a C3 \u222a C5) = C1 \\ (C3 \u222a C5). Let \u03a3 be an alphabet. We consider the formal language semiring\nB10 = Lang\u03a3 = (P(\u03a3 \u2217),\u222a, \u25e6, \u2205, {\u03b5}) .\nThis is a positive, non-commutative, and not bi-locally finite semiring.\nC2 \\ (C1 \u222a C3 \u222a C5) 6= \u2205: By Observation 18.2.13, C2 \\ (C1 \u222a C3 \u222a C5) = C2 \\ (C3 \u222a C5). We consider the commutative semiring\nB11 = (Z\u00d7 N,+, \u00b7, (0, 0), (1, 1))\nwith pointwise addition and pointwise multiplication. B11 is not a ring, not zero-sum free, and not bi-locally finite.\nC3 \\ (C1 \u222a C2 \u222a C5) 6= \u2205: We consider the strong bimonoid\nB12 = (N,+, \u00b74, 0, 1)\nwith a \u00b74 b = (a \u00b7 b)mod4. Then B12 is commutative and zero-sum free, i.e., B12 \u2208 C3. Since 2 \u00b74 2 = 0, B12 contains zero-divisors, and hence B12 6\u2208 C1. B12 is not a semiring, because, e.g., 2 \u00b74 (3 + 1) = 0 and 2 \u00b74 3 + 2 \u00b74 1 = 2 + 2 = 4). Hence B12 6\u2208 C2. Also B12 is not bi-locally finite (because \u30081\u3009+ is not finite). Thus B12 \u2208 C3 \\ (C1 \u222a C2 \u222a C5).\nC5 \\ (C1 \u222a C2 \u222a C3) 6= \u2205: We consider the ring\nB13 = Intmod4 = ({0, 1, 2, 3},+4, \u00b74, 0, 1)\n378 CHAPTER 18. SUPPORT OF RECOGNIZABLE WEIGHTED TREE LANGUAGES\nas defined in Example 2.6.9(5). Since B13 is finite, B13 \u2208 C5. Since B13 is a ring and is not zero-sum free, B13 6\u2208 C1 \u222a C2 \u222a C3.\nC \\ (C1 \u222a C2 \u222a C3 \u222a C5): The ring B14 = Int = (Z,+, \u00b7, 0, 1)\nis neither zero-sum free nor bi-locally finite.\nIn particular, it follows from the proof of Theorem 18.2.14 that each of the support theorems Theorem 18.2.4, Theorem 18.2.7, Theorem 18.2.10, and Corollary 18.2.1(3), for C1, C2, C3, and C5 respectively, has its own benefit with respect to run semantics. More precisely, let i \u2208 {1, 2, 3, 5}. Then there exists B \u2208 Ci \\ (Cj \u222a Ck \u222a C\u2113) with pairwise different j, k, \u2113 \u2208 {1, 2, 3, 5} \\ {i} such that the support theorem for Ci implies the property supp([[A]]\nrun) \u2208 Rec(\u03a3) for each (\u03a3,B)-wta A, and this property does not follow from the support theorems for Cj , Ck, and C\u2113.\nNext we compare the sets C1, C2, and C4.\nTheorem 18.2.15. [DM20, Dro22] Figure 18.4 shows the Euler diagram of the sets C1, C2, and C4. Thus, for every D1 \u2208 {C1, C \\ C1}, D2 \u2208 {C2, C \\ C2}, and D4 \u2208 {C4, C \\ C4}, we have D1 \u2229 D2 \u2229 D4 6= \u2205.\nProof. C1 \u2229 C2 \u2229 C4 6= \u2205: The Boolean semiring\nB1 = Boole = (B,\u2228,\u2227, 0, 1)\nis in C1 \u2229 C2 \u2229 C4.\n(C1 \u2229 C2) \\ C4 6= \u2205: The commutative semiring\nB2 = Nat = (N,+, \u00b7, 0, 1)\nis positive and not a ring and not locally finite.\n(C1 \u2229 C4) \\ C2 6= \u2205: We consider the strong bimonoid\nB3 = ({0, a, b, 1},+, \u00b7, 0, 1)\nwhich is the same as B8 on page 377, i.e., + is defined as supremum with respect to the partial order 0 < a < b < 1; moreover, the operation \u00b7 is determined by x \u00b7 y = x for every x, y \u2208 {a, b}.\nThis B3 is zero-sum free and zero-divisor free (hence B3 \u2208 C1) and B3 is finite (hence B3 \u2208 C4). Since \u00b7 is not commutative (a \u00b7 b 6= b \u00b7 a), we have B3 6\u2208 C2.\n(C2 \u2229 C4) \\ C1 6= \u2205: We consider the algebra\nB4 = ({\u22121, 0, 1} \u00d7 {0, 1},+ \u2032, \u00b7, (0, 0), (1, 1))\nwhere (a1, a2) + \u2032 (b1, b2) = (max(\u22121,min(a1 + b1, 1)),min(a2 + b2, 1)) (i.e., + \u2032 is defined componentwise by using the usual addition except that the first component is truncated by 1 from above and by \u22121 from below, and the second component is truncated by 1 from above). The multiplication is defined componentwise. Obviously, B4 is a finite commutative semiring.\nSince there does not exist an element (a1, a2) such that (0, 1) + \u2032 (a1, a2) = (0, 0), B4 is not a ring.\nHence B4 \u2208 C2. B4 is not zero-sum free, because (\u22121, 0) + \u2032 (1, 0) = (0, 0). Hence B4 6\u2208 C1.\nC1 \\ (C2 \u222a C4) 6= \u2205: Let \u03a3 be an alphabet. We consider the formal language semiring\nB5 = Lang\u03a3 = (P(\u03a3 \u2217),\u222a, \u25e6, \u2205, {\u03b5}) .\nThis is a positive, non-commutative and not locally finite semiring.\nC2 \\ (C1 \u222a C4) 6= \u2205: We consider the commutative semiring\nB6 = (Z \u00d7 N,+, \u00b7, (0, 0), (1, 1))\n18.2. POSITIVE RESULTS FOR SUPPORT 379\nwith pointwise addition and pointwise multiplication. B6 is not a ring, not zero-sum free, and not locally finite.\nC4 \\ (C1 \u222a C2) 6= \u2205: The ring\nB7 = Intmod4 = ({0, 1, 2, 3},+4, \u00b74, 0, 1)\nas defined in Example 2.6.9(5), is in C4 \\ (C1 \u222a C2).\nC \\ (C1 \u222a C2 \u222a C4): The ring B8 = Int = (Z,+, \u00b7, 0, 1)\nis neither zero-sum free nor locally finite.\nIn particular, it follows from the proof of Theorem 18.2.15 that each of the support theorems Theorem 18.2.4, Theorem 18.2.7, and Corollary 18.2.1(2), for C1, C2, and C4 respectively, has its own benefit with respect to initial algebra semantics. More precisely, let i \u2208 {1, 2, 4}. Then there exists B \u2208 Ci \\ (Cj \u222a Ck) with different j, k \u2208 {1, 2, 4}\\{i} such that the support theorem for Ci implies the property supp([[A]]init) \u2208 Rec(\u03a3) for each (\u03a3,B)-wta A, and this property does not follow from the support theorems for Cj and Ck.\n380 CHAPTER 18. SUPPORT OF RECOGNIZABLE WEIGHTED TREE LANGUAGES\nChapter 19\nCorollaries and theorems for wta over bounded lattices\nIn the literature, (\u03a3, L)-wta have been investigated where L is a bounded lattice (or a bounded lattice with some further restrictions, like distributivity), e.g., [IF75, MM02, E\u0301L07, BLB10, MZA11, GZ12, GZA12, GZ16, GZ17, Gho18, Gho22] and for the string case [DV10, DV12]; for a survey we refer to [Rah09]. We also refer to [Asv96] for a bibliography on fuzzy automata, grammars, and languages. In this chapter, we will present some part of the theory of wta over bounded lattices which follows from the results of the previous chapters. This attempt is reasonable because, due to Observation 2.6.13(2) and (3), i.e.,\n\u2022 each bounded lattice is a particular bi-locally finite and commutative strong bimonoid, and \u2022 each distributive bounded lattice is a particular locally finite and commutative semiring,\nrespectively. We will use the above facts without reference in the proofs of the corollaries and theorems in this chapter. For each lattice-oriented result that we present here, we will only refer to the covering strong bimonoid-oriented result of some previous chapter; there the reader can find references to the literature.\nIn this chapter, L = (L,\u2228,\u2227, 0, 1) denotes a bounded lattice."
        },
        {
            "heading": "19.1 Definition of wta over bounded lattices",
            "text": "Since a bounded lattice is a particular strong bimonoid, Section 3.1 provides the definition of a (\u03a3, L)-wta. This definition coincides with the definition of weighted tree automata over bounded lattices as it is given in the literature, e.g. [E\u0301L07] (apart from notational variations). In the same way, the notions of crisp deterministic (\u03a3, L)-wta and bu deterministic (\u03a3, L)-wta are defined. The definitions of the run semantics and initial algebra semantics of a (\u03a3, L)-wta are also given in Section 3.1. For the sake of convenience, we repeat their main parts here.\nLet A = (Q, \u03b4, F ) be a (\u03a3, L)-wta. We note that, due to (3.1), for each \u03be = \u03c3(\u03be1, . . . , \u03bek) and \u03c1 \u2208 RA(\u03be), we have\nwtA(\u03be, \u03c1) = ( \u2227\ni\u2208[k]\nwtA(\u03bei, \u03c1|i) ) \u2227 \u03b4k ( \u03c1(1) \u00b7 \u00b7 \u00b7 \u03c1(k), \u03c3, \u03c1(\u03b5) ) , (19.1)\nand the run semantics of A is defined, for each \u03be \u2208 T\u03a3, by\n[[A]]run(\u03be) = \u2228\n\u03c1\u2208RA(\u03be)\nwt(\u03be, \u03c1) \u2227 F\u03c1(\u03b5) .\n381\n382 CHAPTER 19. COROLLARIES AND THEOREMS FOR WTA OVER BOUNDED LATTICES\nMoreover, due to (3.2), the interpretation function \u03b4A of the vector algebra V(A) = (LQ, \u03b4A) is defined, for every k \u2208 N, \u03c3 \u2208 \u03a3(k), v1, . . . , vk \u2208 LQ, and q \u2208 Q, by\n\u03b4A(\u03c3)(v1, . . . , vk)q = \u2228\nq1\u00b7\u00b7\u00b7qk\u2208Qk\n( \u2227\ni\u2208[k]\n(vi)qi ) \u2227 \u03b4k(q1 \u00b7 \u00b7 \u00b7 qk, \u03c3, q) . (19.2)\nWe recall that the unique \u03a3-algebra homomorphism from T\u03a3 to V(A) is denoted by hA. Then the initial algebra semantics of A is defined, for each \u03be \u2208 T\u03a3, by\n[[A]]init(\u03be) = \u2228\nq\u2208Q\nhA(\u03be)q \u2227 Fq .\nFor instance, in [Asv03, E\u0301L07] and in [Gho22] the initial algebra semantics was used (where L is a \u03c3-complete distributive lattice and a \u03c3-complete orthomodular lattice, respectively). In [Be\u030cl02] the run semantics was used (for wsa where L is a complete distributive lattice, cf. the remark on page 328).\nAs we have seen in Example 5.2.4, there exists a (\u03a3,N5)-wta A such that [[A]]run 6= [[A]]init. We recall that A is not bu deterministic and that N5 (cf. Figure 2.3) is not distributive. However, in the following cases run semantics and initial algebra semantics coincide.\nCorollary 19.1.1. Let \u03a3 be a ranked alphabet and L be a bounded lattice. For each (\u03a3, L)-wta A the following two statements hold. (1) If A is bu deterministic, then [[A]]run = [[A]]init. (2) If L is distributive, then [[A]]run = [[A]]init.\nProof. Proof of (1) and (2) follows from Theorem 5.3.1 and Corollary 5.3.3(2), respectively.\nDue to Corollary 19.1.1, for each (\u03a3, L)-wta A, if A is bu deterministic or L is distributive, then we write [[A]] instead of [[A]]run and [[A]]init. Moreover, if L is distributive, then for an i-recognizable or r-recognizable weighted tree language r, we say that r is recognizable and we denote the set Recrun(\u03a3, L) (and hence, Recinit(\u03a3, L)) by Rec(\u03a3, L)."
        },
        {
            "heading": "19.2 Crisp determinization",
            "text": "Corollary 19.2.1. Let \u03a3 be a ranked alphabet and L be a bounded lattice. For each (\u03a3, L)-wta A the following statements hold. (1) We can construct a crisp deterministic (\u03a3, L)-wta B such that [[A]]run = [[B]]. (2) If L is locally finite, then we can construct a crisp deterministic (\u03a3, L)-wta B such that [[A]]init = [[B]]. Thus, in particular, Recrun(\u03a3, L) = cd-Rec(\u03a3, L) and, if L is locally finite, then Recinit(\u03a3, L) = cd-Rec(\u03a3, L).\nProof. Proof of (1): Since L is a particular bi-locally finite strong bimonoid, the set H(A) (cf. (7.15)) is finite and each b \u2208 L has finite additive order. Hence we can apply Theorem 16.2.6 and obtain the desired crisp deterministic (\u03a3, L)-wta B with [[A]]run = [[B]].\nProof of (2): It follows from Theorem 16.1.3.\nFinally, the equality of the sets follow from Statements (1) and (2) and the trivial fact that cd-Rec(\u03a3, L) \u2286 Recrun(\u03a3, L) \u2229 Recinit(\u03a3, L).\n19.2. CRISP DETERMINIZATION 383\nCorollary 19.2.1(2) can be applied, e.g., to the locally finite bounded lattice (N\u221e,max,min, 0,\u221e). Moreover, it can be applied to each finite lattice and to each distributive bounded lattice.\nA direct consequence of Corollary 19.2.1 and Corollary 4.3.3 is the stability of the set of run recognizable weighted tree languages under changing the bounded lattice L1 into the bounded lattice L2 if L1 and L2 have the same carrier set (as, e.g., N5 and M3) and similarly for initial algebra recognizable weighted tree languages over locally finite bounded lattices. Moreover, the expressive power of wta with run semantics over bounded lattices is the same as that of wta with initial algebra semantics over locally finite bounded lattices [Dro22].\nCorollary 19.2.2. Let L1 and L2 be bounded lattices with the same carrier set. Then the following three statements hold.\n(1) Recrun(\u03a3, L1) = cd-Rec(\u03a3, L1) = cd-Rec(\u03a3, L2) = Rec run(\u03a3, L2). (2) If L1 and L2 are locally finite, then Rec init(\u03a3, L1) = cd-Rec(\u03a3, L1) = cd-Rec(\u03a3, L2) = Rec\ninit(\u03a3, L2). (3) If L2 is locally finite, then Rec run(\u03a3, L1) = Rec init(\u03a3, L2).\nProof. Proof of (1): The equalities Recrun(\u03a3, L1) = cd-Rec(\u03a3, L1) and cd-Rec(\u03a3, L2) = Rec run(\u03a3, L2) follow from Corollary 19.2.1. The equality cd-Rec(\u03a3, L1) = cd-Rec(\u03a3, L2) follows from Corollary 4.3.3 (and Theorem 5.3.1, and the convention on page 117).\nProof of (2): This proof is analogous to the proof of (1). Proof of (3): By (1) we have Recrun(\u03a3, L1) = cd-Rec(\u03a3, L2). Then, by (2), we obtain Rec run(\u03a3, L1) =\nRecinit(\u03a3, L2).\nWe recall from Section 2.14 that a (\u03a3, L)-weighted tree language r is a recognizable step mapping if there exist n \u2208 N+, b1, . . . , bn \u2208 L, and recognizable \u03a3-tree languages L1, . . . , Ln such that\nr = \u2228\ni\u2208[n]\nbi \u2227 \u03c7(Li) .\nCorollary 19.2.3. Let \u03a3 be a ranked alphabet and L = (L,\u2228,\u2227, 0, 1) be a bounded lattice. For each (\u03a3, L)-wta A, the following statements hold. (1) [[A]]run is a recognizable step mapping. (2) If L is locally finite, then [[A]]init is a recognizable step mapping. Moreover, in (1) we can construct n \u2208 N+, b1, . . . , bn \u2208 L, and \u03a3-fta A1, . . . , An such that [[A]]run =\u2228 i\u2208[n] bi \u2227 \u03c7(L(Ai)). The same holds for [[A]] init in (2).\nProof. The proof follows from Corollary 19.2.1 and Theorem 10.3.1 (A)\u21d4(B). We note that (1) also was already proved in Corollary 7.4.4.\nCorollary 19.2.4. Let \u03a3 be a ranked alphabet, L = (L,\u2228,\u2227, 0, 1) be a bounded lattice, and r : T\u03a3 \u2192 L. Then the following two statements are equivalent. (A) We can construct a (\u03a3, L)-wta A such that r = [[A]]run. (B) r is a recognizable step mapping and we can construct n \u2208 N+, b1, . . . , bn \u2208 L and \u03a3-fta A1, . . . , An\nsuch that r = \u2228n i=1 bi \u2227 \u03c7(L(Ai)).\nMoreover, if L is distributive, then [[A]]run in condition (A) can be replaced by [[A]].\nProof. Proof of (A)\u21d2(B): This follows from Corollary 19.2.3(1) and Theorem 10.3.1(A)\u21d2(B).\nProof of (B)\u21d2(A): By Theorem 10.3.1(B)\u21d2(A), we can construct a crisp deterministic (\u03a3, L)-wta A such that r = [[A]]. By the convention on page 382, [[A]] is an abbreviation of [[A]]run.\nLet L be distributive. Then the statement follows from Corollary 19.1.1(2).\n384 CHAPTER 19. COROLLARIES AND THEOREMS FOR WTA OVER BOUNDED LATTICES"
        },
        {
            "heading": "19.3 Relationship between several sets of recognizable weighted",
            "text": "tree languages\nHere we study the relationship between several sets of r-recognizable, i-recognizable, or crisp deterministically recognizable weighted tree languages where the weight algebra is a bounded lattice, locally finite bounded lattice, distributive bounded lattice, or finite chain. By combining these modes of recognizability and weight algebras, we obtain twelve sets of recognizable weighted tree languages.\nIt will turn out that eleven of the twelve sets are equal; let us denote this set by C. The exception is the set of i-recognizable weighted tree languages over bounded lattices. Moreover, we show that C is a subset of the latter set and, if the ranked alphabet is large enough, then the inclusion is strict. Thus, roughly speaking, using initial algebra semantics over bounded lattices, one can specify strictly more weighted tree languages than using another combination. The results of this section are taken from [FV22a].\nMore precisely, we consider the set\nQ = {Recy(\u03a3, Z) | y \u2208 {run, init}, Z \u2208 {BL, lfBL, dBL,FC}}\u222a{cd-Rec(\u03a3, Z) | Z \u2208 {BL, lfBL, dBL,FC}},\nwhere\n\u2022 BL, lfBL, dBL, FC denote the sets of bounded lattices, locally finite bounded lattices, distributive bounded lattices, and finite chains, \u2022 Recy(\u03a3, Z) = \u22c3\nL\u2208Z Rec y(\u03a3, L), i.e., the set of all mappings r : T\u03a3 \u2192 L where L is the carrier set\nof some L \u2208 Z and r is a y-recognizable (\u03a3, L)-weighted tree language, and \u2022 cd-Rec(\u03a3, Z) = \u22c3 L\u2208Z cd-Rec(\u03a3, L), i.e., the set of all mappings r : T\u03a3 \u2192 L where L is the carrier\nset of some L \u2208 Z and r is a crisp deterministically recognizable (\u03a3, L)-weighted tree language.\nOur goal is to present the inclusion diagram of Q (cf. Theorem 19.3.5), i.e., the Hasse diagram of Q with set inclusion as partial order.\nBy definition we have FC \u2282 dBL and by Observation 2.6.16, we have dBL \u2282 lfBL \u2282 BL. Thus\nfor each y \u2208 {run, init}, we have Recy(\u03a3,FC) \u2286 Recy(\u03a3, dBL) \u2286 Recy(\u03a3, lfBL) \u2286 Recy(\u03a3,BL) (19.3)\nand we have cd-Rec(\u03a3,FC) \u2286 cd-Rec(\u03a3, dBL) \u2286 cd-Rec(\u03a3, lfBL) \u2286 cd-Rec(\u03a3,BL). (19.4)\nIn Figure 19.1 (ignoring the ovals for the time being) we show all the twelve elements of Q, organized according to their known subset relationships; these relationships follow from (a) Equations (19.3) and (19.4), (b) the trivial fact that each crisp deterministic wta is a wta, and (c) Theorem 5.3.1. We note that this is not a Hasse diagram; in particular, the edges do not show strict inclusions but merely inclusions.\nFrom the trivial fact that cd-Rec(\u03a3,BL) \u2286 Recrun(\u03a3,BL)\u2229Recinit(\u03a3, lfBL) and from Corollary 19.2.1, we directly obtain four equalities (corresponding to the four ovals in Figure 19.1)\nCorollary 19.3.1. [FV22a] The following four statements hold.\n(1) Recrun(\u03a3,BL) = cd-Rec(\u03a3,BL). (2) Recrun(\u03a3, lfBL) = cd-Rec(\u03a3, lfBL) = Recinit(\u03a3, lfBL). (3) Recrun(\u03a3, dBL) = cd-Rec(\u03a3, dBL) = Recinit(\u03a3, dBL). (4) Recrun(\u03a3,FC) = cd-Rec(\u03a3,FC) = Recinit(\u03a3,FC).\nNext we prove that cd-Rec(\u03a3,BL) \u2286 cd-Rec(\u03a3,FC).\nLemma 19.3.2. [Dro22] [FV22a] For every crisp deterministic (\u03a3, L)-wta A we can construct a finite chain L\u2032 with carrier set wts(A)\u222a{0} and a crisp deterministic (\u03a3, L\u2032)-wta B such that [[A]] = [[B]]. Thus, in particular, cd-Rec(\u03a3,BL) \u2286 cd-Rec(\u03a3,FC).\nProof. LetA = (Q, \u03b4, F ). We note that 1 \u2208 wts(A) because \u03a3(0) 6= \u2205 6= Q andA is crisp deterministic. We construct the finite chain L\u2032 = (wts(A)\u222a{0},\u2264, 0, 1) where \u2264 is an arbitrary linear order on wts(A)\u222a{0}.\n19.3. RELATIONSHIP BETWEEN SEVERAL SETS OF RECOGNIZABLE WTL 385\nIt is obvious that, for the crisp deterministic (\u03a3, L\u2032)-wta B = (Q, \u03b4, F ), we have [[A]] = [[B]]. This also proves that cd-Rec(\u03a3,BL) \u2286 cd-Rec(\u03a3,FC).\nFrom the previous results, we obtain an intermediate answer to our goal.\nCorollary 19.3.3. [FV22a] Let Q\u2032 = Q \\ {Recinit(\u03a3,BL)}, i.e., the set of the following eleven elements of Q:\n\u2022 Recrun(\u03a3,BL), Recrun(\u03a3, lfBL), Recrun(\u03a3, dBL), Recrun(\u03a3,FC), \u2022 Recinit(\u03a3, lfBL), Recinit(\u03a3, dBL), Recinit(\u03a3,FC), and \u2022 cd-Rec(\u03a3,BL), cd-Rec(\u03a3, lfBL), cd-Rec(\u03a3, dBL), and cd-Rec(\u03a3,FC).\nThen all elements of Q\u2032 are equal.\nProof. By Lemma 19.3.2, cd-Rec(\u03a3,BL) \u2286 cd-Rec(\u03a3,FC). Hence, by the inclusions shown in Figure 19.1 and Corollary 19.3.1, all elements of Q\u2032 are equal.\nNext we prove that Recinit(\u03a3,BL) \\ Recinit(\u03a3, lfBL) 6= \u2205 under some mild conditions on \u03a3. For this, we consider the bounded lattice FL(2 + 2) in Example 2.6.15(9).\nLemma 19.3.4. [FV22a] If |\u03a3(0)| \u2265 6 and |\u03a3(2)| \u2265 2, then we can construct a (\u03a3,FL(2+2))-wta A such that [[A]]init 6\u2208 Recinit(\u03a3, lfBL). In particular, for such a \u03a3 we have Recinit(\u03a3,BL) \\ Recinit(\u03a3, lfBL) 6= \u2205.\nProof. We consider the finite set A = {a, b, c, d} of generators of FL(2+2) (cf. Figure 2.4). Since b\u2228d = 1 and a \u2227 c = 0 and FL(2 + 2) is generated by A, we have \u3008A\u3009{\u2228,\u2227,0,1} = \u3008A\u3009{\u2228,\u2227} = FL(2 + 2), which is an infinite set. By Theorem 3.1.5, we can construct a (\u03a3,FL(2 + 2))-wta A such that im([[A]]init) = \u3008A\u3009{\u2228,\u2227,0,1}, i.e., im([[A]] init) is an infinite set.\nOn the other hand, by Corollary 19.2.3, each element r \u2208 Recinit(\u03a3, lfBL) is a recognizable step mapping, and hence im(r) is finite. Thus [[A]]init 6\u2208 Recinit(\u03a3, lfBL).\n386 CHAPTER 19. COROLLARIES AND THEOREMS FOR WTA OVER BOUNDED LATTICES\nFrom Corollary 19.3.3, the fact that Recinit(\u03a3, lfBL) \u2286 Recinit(\u03a3,BL), and Lemma 19.3.4 we obtain the final picture of the Hasse diagram for Q.\nTheorem 19.3.5. [FV22a] Let \u03a3 be a ranked alphabet. Let Q = {Recy(\u03a3, Z) | y \u2208 {run, init}, Z \u2208 {BL, lfBL, dBL,FC}} \u222a {cd-Rec(\u03a3, Z) | Z \u2208 {BL, lfBL, dBL,FC}}. Then the following three statements hold. (1) Recrun(\u03a3,BL) = Recrun(\u03a3, lfBL) = Recrun(\u03a3, dBL) = Recrun(\u03a3,FC) = Recinit(\u03a3, lfBL) =\nRecinit(\u03a3, dBL) = Recinit(\u03a3,FC) = cd-Rec(\u03a3,BL) = cd-Rec(\u03a3, lfBL) = cd-Rec(\u03a3, dBL) = cd-Rec(\u03a3,FC). We denote this set by C. (2) C \u2286 Recinit(\u03a3,BL). (3) If |\u03a3(0)| \u2265 6 and |\u03a3(2)| \u2265 2, then we have C \u2282 Recinit(\u03a3,BL). In this case, the Hasse diagram for Q with set inclusion as partial order consists of the two nodes C and Recinit(\u03a3,BL).\nWe note that since b \u2228 d = 1 and a \u2227 c = 0 in FL(2 + 2), the condition |\u03a3(0)| \u2265 6 in Lemma 19.3.4 and hence in Theorem 19.3.5 can be weakened to |\u03a3(0)| \u2265 4 (cf. the proof of Theorem 3.1.5)."
        },
        {
            "heading": "19.4 Support",
            "text": "Corollary 19.4.1. Let \u03a3 be a ranked alphabet and L be a bounded lattice. For each (\u03a3, L)-wta A the following statements hold. (1) The \u03a3-tree language supp([[A]]run) is recognizable. (2) If L is locally finite, then the \u03a3-tree language supp([[A]]init) is recognizable. Moreover, for the tree language supp([[A]]run) in (1), we can construct a \u03a3-fta which recognizes that tree language. The same holds for the tree languages supp([[A]]init) in (2).\nProof. Proof of (1) and (2): They follow from Corollary 18.2.1(3) and (2), respectively. We note that (1) also follows from Theorem 18.2.10(a) because L is zero-sum free.\nNow consider the tree language supp([[A]]run) in (1). By Corollary 19.2.1(1), we can construct a crisp deterministic (\u03a3, L)-wta B such that [[A]]run = [[B]]. Then supp([[A]]run) = T\u03a3 \\ [[B]]\u22121(0). By Theorem 10.3.1(C), we can construct a \u03a3-fta which recognizes [[B]]\u22121(0). Finally, it is easy to construct a \u03a3-fta which recognizes the complement tree language T\u03a3 \\ [[B]]\u22121(0) (cf. e.g [GS84, Thm. 2.4.2]).\nBy using Theorem 18.2.12, we can give an alternative proof for the constructability of a \u03a3-fta which recognizes supp([[A]]run) in (1). Moreover, by using Corollary 19.2.1(2) and Theorem 10.3.1(C), we can give an alternative proof for the constructability a \u03a3-fta which recognizes supp([[A]]init) in (2)."
        },
        {
            "heading": "19.5 Closure results",
            "text": "Here we instantiate the closure results of Chapter 10 to the particular case where L is a (distributive) bounded lattice (cf. Figure 10.18 for the more general cases).\n19.6. CHARACTERIZATION BY RATIONAL OPERATIONS 387\nCorollary 19.5.1. Let \u03a3 be a ranked alphabet and L be a bounded lattice. The following statements hold. (1) The sets Recrun(\u03a3, L) and Recinit(\u03a3, L) are closed under sum (cf. Theorem 10.1.1). (2) If L is distributive, then the set Rec(\u03a3, L) is closed under\n\u2022 scalar multiplications (cf. Theorem 10.2.1), \u2022 Hadamard product (cf. Theorem 10.4.1), \u2022 top-concatenations (cf. Corollary 10.5.2), \u2022 tree concatenations (cf. Corollary 10.6.2), \u2022 Kleene stars (cf. Corollary 10.7.6), and \u2022 yield-intersection (cf. Theorem 10.8.2).\n(3) The sets Recrun(\u03a3, ) and Recinit(\u03a3, ) are closed under homomorphisms between two bounded lattices (cf. Theorem 10.9.3). (4) The set Recrun( , L) is closed under \u2022 tree relabelings (cf. Theorem 10.10.1) and \u2022 linear, nondeleting, and productive tree homomorphisms (cf. Corollary 10.11.2). (5) If L is distributive, then the set Rec( , L) is closed under \u2022 inverse of linear tree homomorphisms (cf. Theorem 10.12.2), \u2022 weighted projective bimorphisms (cf. Corollary 10.13.10)."
        },
        {
            "heading": "19.6 Characterization by rational operations",
            "text": "We recall that an operation on the set of (\u03a3, L)-weighted tree languages is a rational operation if it is the sum, a tree concatenation, or a Kleene-star. Moreover, the set of rational (\u03a3, L)-weighted tree languages, denoted by Rat(\u03a3, L), is the smallest set of (\u03a3, L)-weighted tree languages which contains each polynomial (\u03a3, L)-weighted tree language and is closed under the rational operations.\nDue to the need for extra symbols at which tree concatenation can take place (cf. [TW68, Sect. 3]), we have introduced in Section 12.1 the concept of 0-extension and defined the sets of extended rational (\u03a3, L)weighted tree languages, denoted by Rat(\u03a3, L)ext, and the set of extended recognizable (\u03a3, L)-weighted tree languages, denoted by Rec(\u03a3, L)ext, which formalize these extensions.\nThen Theorem 12.1.2 implies the following Kleene theorem for distributive bounded lattices.\nCorollary 19.6.1. Let \u03a3 be a ranked alphabet and L a distributive bounded lattice. Then\nRec(\u03a3, L)ext = Rat(\u03a3, L)ext ."
        },
        {
            "heading": "19.7 Characterization by elementary operations",
            "text": "Since each run recognizable weighted tree language is a recognizable step mapping (cf. Corollary 19.2.1), we can show that the notions of representable, restricted representable, and \u00d7-restricted representable (as defined in Chapter 13) coincide. This results in Me\u0301dve\u0301de\u0301v\u2019s theorem for wta over bounded lattices.\n388 CHAPTER 19. COROLLARIES AND THEOREMS FOR WTA OVER BOUNDED LATTICES\nTheorem 19.7.1. Let \u03a3 be a ranked alphabet, L be a bounded lattice, and r : T\u03a3 \u2192 L. Then the following four statements are equivalent. (A) We can construct a (\u03a3, L)-wta A such that r = [[A]]run. (B) We can construct an e \u2208 RepEx(\u03a3, L) such that r = [[e]]. (C) We can construct an e \u2208 RepExr(\u03a3, L) such that r = [[e]]. (D) We can construct an e \u2208 RepEx\u00d7r(\u03a3, L) such that r = [[e]].\nProof. The implication (A)\u21d2(D) holds by Lemma 13.2.2. The implications (D)\u21d2(C) and (C)\u21d2(B) hold by definition.\nProof of (B)\u21d2(A): By induction on (RepEx(L),\u227a) we prove the following statement:\nFor each e \u2208 RepEx(L), we can construct a (\u03a3, L)-wta A such that [[e]] = [[A]]run.\nI.B.: For the case that e = RT\u03a3,\u03c3,b or e = NXT\u03a3,\u03b3\u0303,b, the statement follows from Corollary 13.1.3 and Theorem 10.3.1(B)\u21d2(A).\nI.S.: We distinguish four cases.\nCase (a): Let e = e1 + e2. Then the statement follows from the I.H. and Theorem 10.1.1(1). Case (b): Let e = e1 \u00d7 e2. By I.H. we can construct (\u03a3, L)-wta A1 and A2 such that [[e1]] = [[A1]] run\nand [[e2]] = [[A2]] run. By Corollary 19.2.1(1), we can construct crisp deterministic (\u03a3, L)-wta A\u20321 and A \u2032 2 such that [[A1]]run = [[A\u20321]] and [[A2]] run = [[A\u20322]]. Then the statement follows from Theorem 10.4.1(3).\nCase (c): Let e = \u03c4(e\u2032) where \u03c4 is a (\u2206,\u03a3)-tree relabeling. Then the statement follows from the I.H. and Theorem 10.10.1.\nCase (d): Let e = REST(e\u2032). By I.H. we can construct a (\u03a3, L)-wta A\u2032 such that [[A\u2032]]run = [[e\u2032]]. By Corollary 19.2.1, we can construct a crisp deterministic (\u03a3, L)-wta B such that [[B]] = [[A\u2032]]run. By Lemma 13.3.1, we can construct a (\u03a3, L)-wta A such that [[A]]run = [[REST(e\u2032)]]."
        },
        {
            "heading": "19.8 Characterization by weighted MSO-logic",
            "text": "In this situation where L is a bounded lattice, we can prove that run recognizability of a (\u03a3, L)-weighted tree language is equivalent to its definability in MSOext(\u03a3, L), and the transformations from wta to formula and vice versa are constructive (cf. Theorem 19.8.4). We recall the syntax of the formulas in MSOext(\u03a3, L) from Section 14.4. It was given by the following EBNF with nonterminal e:\ne ::= H(\u03ba) | (\u03d5\u22b2 e) | (e + e) | (e\u00d7 e) |+x e |+X e |\u00d7x e |\u00d7X e . (19.5)\nIn particular, no restriction is needed on the use of weighted conjunction, weighted first-order universal quantification, and weighted second-order universal quantification.\nFor the proof of Theorem 19.8.4, in particular, we have to prove that weighted first-order universal quantification and weighted second-order universal quantification preserve run recognizability.\nLemma 19.8.1. Let e \u2208 MSOext(\u03a3, L) with U = Free(e) and x any first-order variable. If there exists a (\u03a3U , L)-wta A with [[A]]run = [[e]], then we can construct a (\u03a3V , L)-wta B such that V = Free(\u00d7x e) and [[B]]run = [[\u00d7x e]].\nProof. Let A be a (\u03a3U , L)-wta such that [[A]]run = [[e]]. By Lemma 14.3.4, we can construct a (\u03a3U\u222a{x}, L)wta A\u2032 such that [[A\u2032]]run = [[e]]U\u222a{x}. Since U \u222a {x} = V \u222a {x}, we have that [[A \u2032]]run = [[e]]V\u222a{x}.\n19.8. CHARACTERIZATION BY WEIGHTED MSO-LOGIC 389\nSince L is a bounded lattice, [[A\u2032]]run is a recognizable step mapping. More precisely, by Corollary 19.2.3, we can construct n \u2208 N, b1, . . . , bn \u2208 L, and \u03a3V\u222a{x}-fta A1, . . . , An such that\n[[A\u2032]]run = \u2228\nj\u2208[n]\nbj \u2227 \u03c7(L(Aj)) .\nThen by Lemma 14.4.16 we can construct a (\u03a3V , L)-wta B, where V = Free(\u00d7x e), such that [[B]]run = [[\u00d7x e]].\nAs preparation for the second preservation result, we state that the consistency lemma for wta (cf. Lemma 14.3.4) also holds if we replace MSO(\u03a3, L) by MSOext(\u03a3, L).\nLemma 19.8.2. Let V be a finite set of variables, e \u2208 MSOext(\u03a3, L) with Free(e) = V , and A be a (\u03a3V , L)-wta such that [[A]]run = [[e]]. Moreover, let V be a first-order variable or a second-order variable. Then we can construct a (\u03a3V\u222a{V }, L)-wta A \u2032 such that [[A\u2032]]run = [[e]]V\u222a{V }.\nProof. The proof is the same as the one for Lemma 14.3.4 except that in Case (b)(ii) we have to use the consistency lemma for MSOext(\u03a3, L) (i.e., Lemma 14.4.1) instead of Lemma 14.2.1.\nLemma 19.8.3. Let e \u2208 MSOext(\u03a3, L) with U = Free(e) and X any second-order variable. If there exists a (\u03a3U , L)-wta A with [[A]]run = [[e]], then we can construct a crisp deterministic (\u03a3V , L)-wta B such that V = Free(\u00d7X e) and [[B]] = [[\u00d7X e]].\nProof. Let \u03b6 \u2208 T\u03a3V . By definition, we have that\n[[\u00d7X e]](\u03b6) =    \u2227 W\u2286pos(\u03b6) [[e]]V\u222a{X}(\u03b6[X 7\u2192W ]) if \u03b6 \u2208 T v \u03a3V\n0 otherwise .\nwhich is equivalent to\n[[\u00d7X e]](\u03b6) = ( \u2227\nW\u2286pos(\u03b6)\n[[e]]V\u222a{X}(\u03b6[X 7\u2192W ]) ) \u2227 \u03c7(Tv\u03a3V )(\u03b6) .\nAs auxiliary tool, we define the deterministic (\u03a3V\u222a{X},\u03a3V)-tree relabeling \u03c4 = (\u03c4k | k \u2208 N) with \u03c4k((\u03c3,W)) = (\u03c3,W \\ {X}) for each (\u03c3,W) \u2208 \u03a3V\u222a{X}. Then we have\n[[\u00d7X e]](\u03b6) = ( \u2227\n\u03be\u2208\u03c4\u22121(\u03b6)\n[[e]]V\u222a{X}(\u03be) ) \u2227 \u03c7(Tv\u03a3V )(\u03b6) .\nLet A be a (\u03a3U , L)-wta with [[A]]run = [[e]]. By Lemma 19.8.2, we can construct a (\u03a3U\u222a{X}, L)-wta A \u2032\nsuch that [[A\u2032]]run = [[e]]U\u222a{X}. Since U \u222a {X} = V \u222a {X}, we have\n[[\u00d7X e]](\u03b6) = ( \u2227\n\u03be\u2208\u03c4\u22121(\u03b6)\n[[A\u2032]]run(\u03be) ) \u2227 \u03c7(Tv\u03a3V )(\u03b6) .\nSince L is a bounded lattice, [[A\u2032]]run is a recognizable step mapping. More precisely, by Corollary 19.2.3, we can construct n \u2208 N, b1, . . . , bn \u2208 L, and \u03a3V\u222a{X}-fta A1, . . . , An such that\n[[A\u2032]]run = \u2228\ni\u2208[n]\nbi \u2227 \u03c7(L(Ai)) .\n390 CHAPTER 19. COROLLARIES AND THEOREMS FOR WTA OVER BOUNDED LATTICES\nMoreover, by Observation 2.14.1, we can assume that the family (L(Ai) | i \u2208 [n]) is a partitioning of T\u03a3V\u222a{X} . Thus\n[[\u00d7X e]](\u03b6) = ( \u2227\n\u03be\u2208\u03c4\u22121(\u03b6)\n\u2228\ni\u2208[n]\nbi \u2227 \u03c7(L(Ai))(\u03be) ) \u2227 \u03c7(Tv\u03a3V )(\u03b6) .\nSince the tree languages L(A1), . . . ,L(An) are pairwise disjoint and \u2227 is idempotent, we obtain\n[[\u00d7X e]](\u03b6) = ( \u2227\ni\u2208[n]\nmi(\u03b6) ) \u2227 \u03c7(Tv\u03a3V )(\u03b6)\nwhere, for each i \u2208 [n], the mapping mi : T\u03a3V \u2192 L is defined, for each \u03b8 \u2208 T\u03a3V , by\nmi(\u03b8) =\n{ bi if \u03c4 \u22121(\u03b8) \u2229 L(Ai) 6= \u2205\n1 otherwise .\nSince \u03c4(L(Ai)) = {\u03b8 \u2208 T\u03a3V | \u03c4 \u22121(\u03b8) \u2229 L(Ai) 6= \u2205}, the mapping mi can be written as the polynomial\nweighted tree language\nmi = ( bi \u2227 \u03c7L(\u03c4(L(Ai))) ) \u2228 ( 1 \u2227 \u03c7L(T\u03a3V \\ \u03c4(L(Ai))) ) .\nBy Corollary 10.10.2 (by instantiating \u03a3 and \u2206 by \u03a3V\u222a{X} and \u03a3V , respectively), for each i \u2208 [n], we can construct a \u03a3V -fta Bi such that L(Bi) = \u03c4(L(Ai)). Thus we have\nmi = ( bi \u2227 \u03c7L(L(Bi)) ) \u2228 ( 1 \u2227 \u03c7L(T\u03a3V \\ L(Bi)) ) .\nBy Theorem 2.13.3, we can construct a \u03a3V-fta Bi such that L(Bi) = T\u03a3V \\ L(Bi). Thus\nmi = ( bi \u2227 \u03c7L(L(Bi)) ) \u2228 ( 1 \u2227 \u03c7L(L(Bi)) )\nand hence mi is a recognizable step mapping.\nBy Corollary 10.4.2, \u2227 i\u2208[n]mi is a recognizable step mapping. Hence by Theorem 10.3.1 (B)\u21d2 (A)\nwe can construct a crisp deterministic (\u03a3V , L)-wta C such that [[C]] = \u2227 i\u2208[n]mi. Thus we obtain\n[[\u00d7X e]](\u03b6) = [[C]](\u03b6) \u2227 \u03c7(Tv\u03a3V )(\u03b6) . By Lemma 14.1.5, we can construct a \u03a3V -ftaD such that L(D) = T v \u03a3V . Then by Theorem 10.4.3(2), we\ncan construct a crisp deterministic (\u03a3V , L)-wta B such that [[B]] = [[C]]\u2227\u03c7(L(D)). Hence [[B]] = [[\u00d7X e]].\nNow we can prove B-E-T\u2019s theorem for wta over arbitrary bounded lattices.\nTheorem 19.8.4. Let \u03a3 be a ranked alphabet, L a bounded lattice, and r : T\u03a3 \u2192 L. Then the following four statements are equivalent. (A) We can construct a (\u03a3, L)-wta B such that r = [[B]]run. (B) We can construct a (\u03a3, L)-recognizable step formula e such that Free(e) = \u2205 and r = [[e]]. (C) We can construct a sentence e \u2208MSO(\u03a3, L) such that r = [[e]] (D) We can construct a sentence e \u2208MSOext(\u03a3, L) such that r = [[e]].\nProof. Proof of (A)\u21d2(B): Let B be a (\u03a3, L)-wta such that r = [[B]]run. By Corollary 19.2.3, r is a recognizable step mapping and we can construct n \u2208 N+, b1, . . . , bn \u2208 L, and \u03a3-fta A1, . . . , An such that r = \u2228 i\u2208[n] bi \u2227 \u03c7(L(Ai)). By Lemma 14.2.3, we can construct sentences \u03d51, . . . , \u03d5n in MSO(\u03a3) such that r = [[(\u03d51 \u22b2 \u3008b1\u3009) + . . .+ (\u03d5n \u22b2 \u3008bn\u3009)]]. Then we let e = (\u03d51 \u22b2 \u3008b1\u3009) + . . .+ (\u03d5n \u22b2 \u3008bn\u3009).\n19.9. ABSTRACT FAMILIES OF WEIGHTED TREE LANGUAGES 391\nProof of (B)\u21d2(C): Since each (\u03a3, L)-recognizable step formula is in MSO(\u03a3, L), this is trivial. Proof of (C)\u21d2(D): Since MSO(\u03a3, L) \u2282MSOext(\u03a3, L), this is trivial.\nProof of (D)\u21d2(A): We follow the proof of Theorem 14.3.8 and extend it appropriately. Formally, by induction on (MSOext(\u03a3, L),\u227aMSOext(\u03a3,L)), we prove the following statement.\nFor every e \u2208 MSOext(\u03a3, L) and V = Free(e), we can construct a (\u03a3V , L)-wta B such that [[B]] run = [[e]].\n(19.6)\nThe proofs for the cases that e = H(\u03ba), e = (\u03d5 \u22b2 e\u2032), e = e1 + e2, e = +x e\u2032, or e = +X e\u2032 are the same as in the proof of Theorem 14.3.8 (except that for e1 + e2 we use Lemma 19.8.2 instead of Lemma 14.3.4.\nLet e = e1 \u00d7 e2. Let V1 = Free(e1) and V2 = Free(e2). By I.H. we can construct a (\u03a3V1 , L)-wta A1 such that [[A1]] run = [[e1]]. By iterated application of Lemma 19.8.2, we can construct a (\u03a3V , L)-wta A \u2032 1 such that [[A\u20321]] run = [[e1]]V . By Theorem 16.2.7, we can construct a crisp deterministic (\u03a3V , L)-wta A\u2032\u20321 such that [[A\u2032\u20321 ]] = [[e1]]V . In the same way we can construct a crisp deterministic (\u03a3V , L)-wta A \u2032\u2032 2 such that [[A\u2032\u20322 ]] = [[e2]]V . By Theorem 10.4.1(3), we can construct a crisp deterministic (\u03a3V , L)-wta B such that [[B]] = [[A\u2032\u20321 ]]\u2297 [[A \u2032\u2032 2 ]]. Thus [[B]] = [[e1 \u00d7 e2]].\nLet e =\u00d7x e\u2032. By I.H. and Lemma 19.8.1, we can construct a (\u03a3V , L)-wta B such that [[B]]run = [[e]]. Let e =\u00d7X e\u2032. By I.H. and Lemma 19.8.3, we can construct a (\u03a3V , L)-wta B such that [[B]]run =\n[[e]].\nWe note that in [DV12, Thm. 5.3] a characterization of weighted string languages recognizable over bi-locally finite commutative strong bimonoids in terms of the unrestricted weighted MSO-logic of [DG05, DG07, DG09] was proved. When comparing the version of Theorem 19.8.4 in which \u03a3 is a string ranked alphabet with [DV12, Thm. 5.3], one has to handle the differences between MSOext(\u03a3,B) and the weighted MSO-logic of [DG05, DG07, DG09, DV12]; in [FSV12, Sec. 5] syntactic transformations for both directions are shown."
        },
        {
            "heading": "19.9 Abstract families of weighted tree languages",
            "text": "In Chapter 15 we have defined and investigated abstract families of weighted tree languages over commutative and \u03c3-complete semirings. Since each \u03c3-complete lattice is a commutative and \u03c3-complete semiring, we can immediately apply the main result of that chapter (cf. Theorem 15.4.5) to the case of \u03c3-complete lattices.\nFor this, we recall that, for each n \u2208 N, an (n, L)-weighted tree language is a (\u03a3, L)-weighted tree language for some ranked alphabet \u03a3 with maxrk(\u03a3) \u2264 n, and Reg(n, L) denotes the set of all regular (n, L)-weighted tree languages. Moreover, a family L of (n, L)-weighted tree languages is an abstract family of (n, L)-weighted tree languages if L is an (n, L)-tree cone which is closed under the rational operations, i.e., under sum, tree concatenations, and Kleene-stars.\nCorollary 19.9.1. Let L be a \u03c3-complete lattice and n \u2208 N. Then Reg(n, L) is the smallest principal abstract family of (n, L)-weighted tree languages.\n392 CHAPTER 19. COROLLARIES AND THEOREMS FOR WTA OVER BOUNDED LATTICES"
        }
    ],
    "year": 2022
}