{
    "abstractText": "Many traditional applications can be refined thanks to the development of blockchain technology. One of these services is non-repudiation, in which participants in a communication process cannot deny their involvement. Due to the vulnerabilities of the non-repudiation protocols, one of the parties involved in the communication can often avoid non-repudiation rules and obtain the expected information to the detriment of the interests of the other party, resulting in adverse effects. This paper studies the fairness guarantee quantitatively through probabilistic model checking. E-fairness is measured by modeling the protocol in probabilistic timed automata and verifying the appropriate property specified in the probabilistic computation tree logic. Furthermore, our analysis proposes insight for choosing suitable values for different parameters associated with the protocol so that a certain degree of fairness can be obtained. Therefore, the reverse question\u2014for a certain degree of fairness \u03b5, how can the protocol parameters be specified to ensure fairness\u2014is answered.",
    "authors": [
        {
            "affiliations": [],
            "name": "Xu GUO"
        }
    ],
    "id": "SP:b56f1a925e81712fc9b3ec45592d8aacb5b43809",
    "references": [
        {
            "authors": [
                "A Aldini",
                "R Gorrieri"
            ],
            "title": "Security analysis of a probabilistic non-repudiation protocol",
            "venue": "Proc 2nd Joint Int Workshop on Process Algebra and Probabilistic Methods, Performance Modeling and Verification,",
            "year": 2002
        },
        {
            "authors": [
                "DWE Allen",
                "C Berg",
                "B Markey-Towler"
            ],
            "title": "Blockchain and the evolution of institutional technologies: implications for innovation policy",
            "venue": "Res Policy,",
            "year": 2020
        },
        {
            "authors": [
                "A Am\u00e9rico",
                "MS Alvim",
                "A McIver"
            ],
            "title": "An algebraic approach for reasoning about information flow",
            "venue": "Proc 22nd Int Symp on Formal Methods,",
            "year": 2018
        },
        {
            "authors": [
                "M Baza",
                "N Lasla",
                "MMEA Mahmoud"
            ],
            "title": "B-Ride: ride sharing with privacy-preservation, trust and fair payment atop public blockchain",
            "venue": "IEEE Trans Netw Sci Eng,",
            "year": 2021
        },
        {
            "authors": [
                "J Cederquist",
                "R Corin",
                "MT Dashti"
            ],
            "title": "On the quest for impartiality: design and analysis of a fair non-repudiation protocol",
            "venue": "Proc 7th Int Conf on Information and Communications Security,",
            "year": 2005
        },
        {
            "authors": [
                "K Chatterjee",
                "V Raman"
            ],
            "title": "Assume-guarantee synthesis for digital contract signing",
            "venue": "Formal Aspect Comput,",
            "year": 2014
        },
        {
            "authors": [
                "K Christodoulou",
                "P Christodoulou",
                "Z Zinonos"
            ],
            "title": "Health information exchange with blockchain amid Covid-19-like pandemics",
            "venue": "Proc 16th Int Conf on Distributed Computing in Sensor Systems,",
            "year": 2020
        },
        {
            "authors": [
                "HY Deng",
                "RF Hu",
                "C Pray"
            ],
            "title": "Impact of government policies on private R&D investment in agricultural biotechnology: evidence from chemical and pesticide firms in China",
            "venue": "Technol Forecast Soc Change,",
            "year": 2019
        },
        {
            "authors": [
                "TTA Dinh",
                "R Liu",
                "MH Zhang"
            ],
            "title": "Untangling blockchain: a data processing view of blockchain systems",
            "venue": "IEEE Trans Know Data Eng,",
            "year": 2018
        },
        {
            "authors": [
                "M Erhan",
                "A Tarhan",
                "A Ozsoy"
            ],
            "title": "A conceptual model for blockchain-based software project information sharing",
            "venue": "Proc Joint Proc Int Workshop on Software Measurement and Int Conf on Software Process and Product Measurement,",
            "year": 2019
        },
        {
            "authors": [
                "MM Esfahani",
                "OA Mohammed"
            ],
            "title": "Secure blockchainbased energy transaction framework in smart power systems",
            "venue": "Proc 44th Annual Conf of the IEEE Industrial Electronics Society,",
            "year": 2018
        },
        {
            "authors": [
                "KN Griggs",
                "O Ossipova",
                "CP Kohlios"
            ],
            "title": "Healthcare blockchain system using smart contracts for secure automated remote patient monitoring",
            "venue": "J Med Syst,",
            "year": 2018
        },
        {
            "authors": [
                "L Hang",
                "DH Kim"
            ],
            "title": "Design and implementation of an integrated IoT blockchain platform for sensing data integrity",
            "year": 2019
        },
        {
            "authors": [
                "H Hansson",
                "B Jonsson"
            ],
            "title": "A logic for reasoning about time and reliability",
            "venue": "Formal Aspect Comput,",
            "year": 1994
        },
        {
            "authors": [
                "TA Henzinger",
                "X Nicollin",
                "J Sifakis"
            ],
            "title": "Symbolic model checking for real-time systems",
            "venue": "Inform Comput,",
            "year": 1994
        },
        {
            "authors": [
                "S Kremer",
                "O Markowitch"
            ],
            "title": "Optimistic non-repudiable information exchange",
            "venue": "Proc 21st Symp on Information Theory in the Benelux,",
            "year": 2000
        },
        {
            "authors": [
                "S Kremer",
                "O Markowitch",
                "JY Zhou"
            ],
            "title": "An intensive survey of fair non-repudiation protocols",
            "venue": "Comput Commun,",
            "year": 2002
        },
        {
            "authors": [
                "TT Li",
                "W Ren",
                "YX Xiang"
            ],
            "title": "FAPS: a fair, autonomous and privacy-preserving scheme for big data exchange based on oblivious transfer, ether cheque and smart contracts",
            "venue": "Inform Sci,",
            "year": 2021
        },
        {
            "authors": [
                "A Litchfield",
                "J Herbert"
            ],
            "title": "ReSOLV: applying cryptocurrency blockchain methods to enable global crossplatform software license validation",
            "year": 2018
        },
        {
            "authors": [
                "O Markowitch",
                "Y Roggeman"
            ],
            "title": "Probabilistic nonrepudiation without trusted third party",
            "venue": "Proc 2nd Conf on Security in Communication Networks,",
            "year": 1999
        },
        {
            "authors": [
                "L Mendiboure",
                "MA Chalouf",
                "F Krief"
            ],
            "title": "A scalable blockchain-based approach for authentication and access control in software defined vehicular networks",
            "venue": "Proc 29th Int Conf on Computer Communications and Networks,",
            "year": 2020
        },
        {
            "authors": [
                "M Mut-Puigserver",
                "MM Payeras-Capella",
                "MA Cabot-Nadal"
            ],
            "title": "Blockchain-based fair certified notifications",
            "venue": "Int Workshop on Cryptocurrencies and Blockchain Technology,",
            "year": 2018
        },
        {
            "authors": [
                "O Novo"
            ],
            "title": "Blockchain meets IoT: an architecture for scalable access management in IoT",
            "venue": "IEEE Internet Things J,",
            "year": 2018
        },
        {
            "authors": [
                "C P\u00e9rez-Sol\u00e0",
                "S Delgado-Segura",
                "G Navarro-Arribas"
            ],
            "title": "Double-spending prevention for bitcoin zeroconfirmation transactions",
            "venue": "Int J Inform Secur,",
            "year": 2019
        },
        {
            "authors": [
                "S Piramuthu"
            ],
            "title": "RFID-based non-repudiation protocols for supply chains",
            "venue": "Proc 3rd Int Conf on Future Network Systems and Security,",
            "year": 2017
        },
        {
            "authors": [
                "D Resiere",
                "H Kallel"
            ],
            "title": "Implementation of medical and scientific cooperation in the Caribbean using blockchain technology in coronavirus (Covid-19) pandemics",
            "venue": "J Med Syst,",
            "year": 2020
        },
        {
            "authors": [
                "AW Roscoe",
                "PYA Ryan"
            ],
            "title": "Auditable PAKEs: approaching fair exchange without a TTP",
            "venue": "Proc 25th Cambridge Int Workshop on Security Protocols,",
            "year": 2017
        },
        {
            "authors": [
                "KC Ruland",
                "J Sassmannshausen"
            ],
            "title": "Non-repudiation services for the MMS protocol of IEC 61850",
            "venue": "Proc 2nd Int Conf on Research in Security Standardisation,",
            "year": 2015
        },
        {
            "authors": [
                "NB Said",
                "I Cristescu"
            ],
            "title": "End-to-end information flow security for web services orchestration",
            "venue": "Sci Comput Programm,",
            "year": 2020
        },
        {
            "authors": [
                "AP Sarr",
                "PB Seye",
                "T Ngarenon"
            ],
            "title": "A practical and insider secure signcryption with non-interactive nonrepudiation",
            "venue": "Proc 3rd Int Conf on Codes, Cryptology, and Information Security,",
            "year": 2019
        },
        {
            "authors": [
                "JX Wu",
                "Y Gao",
                "ZY Zhang"
            ],
            "title": "A multi-party privacy preserving fair contract signing protocol based on blockchains",
            "venue": "J Cyber Secur,",
            "year": 2018
        },
        {
            "authors": [
                "KP Yu",
                "L Tan",
                "XL Shang"
            ],
            "title": "Efficient and privacypreserving medical research support platform against COVID-19: a blockchain-based approach",
            "venue": "IEEE Consum Electron Mag,",
            "year": 2021
        },
        {
            "authors": [
                "YW Zhao",
                "D San\u00e1n",
                "FY Zhang"
            ],
            "title": "Reasoning about information flow security of separation kernels with channel-based communication",
            "venue": "Proc 22nd Int Conf on Tools and Algorithms for the Construction and Analysis of Systems,",
            "year": 2016
        },
        {
            "authors": [
                "JY Zhou",
                "D Gollman"
            ],
            "title": "A fair non-repudiation protocol",
            "venue": "Proc IEEE Symp on Security and Privacy,",
            "year": 1996
        }
    ],
    "sections": [
        {
            "text": "Key words: Non-repudiation; Fairness analysis; Probabilistic model checking; PRISM https://doi.org/10.1631/FITEE.2100413 CLC number: TP301.2"
        },
        {
            "heading": "1 Introduction",
            "text": ""
        },
        {
            "heading": "1.1 Background",
            "text": "With the rapid growth of smart terminals, blockchain technology has been widely studied (Dinh et al., 2018). This technology not only provides an acentric infrastructure in different fields, including medicine (Griggs et al., 2018; Christodoulou et al., 2020; Resiere et al., 2020), Internet of Things (Novo, 2018; Hang and Kim, 2019), economics (Esfahani and Mohammed, 2018; Allen et al., 2020), software engineering (Litchfield and Herbert, 2018; Erhan et al., 2019; Mendiboure et al., 2020), and even Covid-19 fighting (Yu et al., 2021), but also maintains continuous and tamper-resistant data records in chronological order. Moreover, it has become a hot issue in both academia and industry (Wu et al.,\nORCID: Xu GUO, https://orcid.org/0000-0003-0803-8620 c\u00a9 Zhejiang University Press 2022\n2018; Deng et al., 2019; Feng et al., 2019). With the wide application of blockchain, fairness requirements have appeared in almost all the application scenarios, such as the issues of double payment and hard fork, which are caused by block conflicts (P\u00e9rez-Sol\u00e0 et al., 2019), and directly affect the integrity and effectiveness of E-commerce transactions.\nRepudiation is defined as the denial by one party of having been involved in the whole or part in a communication process (Fig. 1). For the originator, which is a service provider, repudiation means that it denies having sent a message. For a recipient that acts as a client, repudiation refers to its denial of having received the message. Fairness requires that two parties involved in the communication be treated equally, and that neither of the parties can obtain an advantage over the other. One party can reach a state where it can terminate the communication process to maintain fairness without relying on the actions of the other. To solve the problem, the\nprotocols that can offer non-repudiation services are called non-repudiation protocols. Non-repudiation is one of the vital security services in blockchain technology. It is applied mainly in electronic commerce and message transmission systems (Ruland and Sassmannshausen, 2015).\nThis paper studies the fairness of the nonrepudiation protocol proposed by Markowitch and Roggeman (1999). It offers non-repudiation services without the involvement of a trusted third party (TTP). The fairness property of this protocol is ensured by a given degree of fairness, tolerance \u03b5. That is, either both parties receive their expected items, or the probability that a malicious party obtains any valuable information, while the other party achieves nothing, is less than \u03b5, where \u03b5 \u2208 [0, 1]. The protocol can guarantee non-repudiation with certain probabilities, where tolerance \u03b5 is affected by different protocol parameter values. Because different configurations may produce different fairness problems, this paper uses probabilistic model checking to analyze the fairness quantitatively. Specifically, this paper studies the following questions: (1) Does parameter configuration affect the fairness? If so, what is the impact? (2) If the recipient behaves dishonestly, can the fairness be guaranteed? (3) How should the parameters be set to ensure fairness? The participants in the non-repudiation protocol are modeled as two separate units composed of the originator (O) and the recipient (R) in the setting of probabilistic model checking. They are described in the specification of PRISM, which is a probabilistic model checker."
        },
        {
            "heading": "1.2 Related works",
            "text": "The related works summarized in this study fall into four categories:\n1. Design of non-repudiation protocols\nThe ownership of a radio frequency identification (RFID) tags item changes frequently during its lifetime, but few protocols address the nonrepudiation problem. Piramuthu (2017) proposed a non-repudiation protocol for transferring ownership of tagged items. Because blockchain technology can provide an unchangeable data registration system, the services must provide fair, certified notifications that require a fair exchange of values. The data are composed of a message and the proof of non-repudiation origin. Mut-Puigserver et al. (2018) provided two solutions that allow certified notations to be sent when it is necessary to keep secret or register the contents of the notice.\n2. Security analysis of non-repudiation protocols Chatterjee and Raman (2014) studied the automatic synthesis of a fair non-repudiation protocol by applying game-theoretic controller synthesis. In addition to model checking, assume-guarantee strategy can discover the vulnerabilities of a designed protocol using counter-examples in synthesis. The purpose of Chatterjee and Raman (2014)\u2019s work was to use non-repudiation as an example to show that uncertainty methods based on information flow theory are not enough to verify the security of cryptographic protocols.\n3. Security assurance of non-repudiation protocols\nSarr et al. (2019) proposed an identification scheme based on a combination of the Rivest\u2013 Shamir\u2013Adleman (RSA) algorithm and a strongly unforgeable signature scheme. The scheme is noninteractive, non-repudiation and is shown to be inside secure under the RSA assumption and the random oracle model. Roscoe and Ryan (2017) studied how to approximate fair exchange without a TTP for password authenticated key exchange (PAKE) protocols. They considered two scenarios: in the first scenario, two parties exchanged stochastically and in the second scenario, there was an intruder that can guess the password with probability \u03b5.\n4. Fairness and privacy protection strategies in the context of non-repudiation\nDecentralization is a mainstream approach for privacy protection and fair exchange. Li et al. (2021) presented a fair big data exchange scheme, which can guarantee that buyers and sellers can complete transactions fairly and autonomously without a TTP. To enhance security and privacy, Li et al. (2021) also\napplied an m-out-of-n oblivious transfer protocol on the transactions, and applied an Ether cheque system to guarantee fairness and autonomy. Baza et al. (2021) proposed B-Ride, a decentralized ride-sharing service, based on a public blockchain. The aim of B-Ride is to ensure (1) the tradeoff between trip information sharing and personal privacy protection, (2) the accountability under anonymity, and (3) fair payment without a TTP.\nThe above studies can greatly enhance nonrepudiation protocol security, check security problems in the protocol, and balance the tradeoff between privacy protection and fair data sharing, but do not provide quantitative fairness analysis of nonrepudiation protocols. The aim of this work is to fill in this gap."
        },
        {
            "heading": "1.3 Contributions",
            "text": "The contributions of this paper can be summarized as follows:\n1. Fairness analysis is very important for blockchain technology, but there is little literature on this aspect. To fill in the gap, this paper provides a quantitative analysis of the fairness of Markowitch and Roggeman (1999)\u2019s non-repudiation protocol.\n2. Three evolutionary versions of the protocol are considered. That is, both parties\u2019 compliance with the protocol and the recipient\u2019s deception are considered. Moreover, the recipient\u2019s ability to deceive is enhanced with improved processing ability.\n3. The protocol\u2019s fairness performance under different parameter configurations is presented and relevant opinions on the protocol design are put forward according to the results of quantitative analysis."
        },
        {
            "heading": "2 Preliminaries",
            "text": ""
        },
        {
            "heading": "2.1 Related concepts",
            "text": "This subsection focuses on the background techniques to be used in formal verification of the nonrepudiation protocol that follows.\n1. Fairness Fairness is a very important factor because it has nothing to do with network size or complexity. The goal of fairness is to guarantee that benefits are distributed fairly among the participants in an activity (Zhao et al., 2016; Am\u00e9rico et al., 2018; Said and\nCristescu, 2020). Informally, fairness means that at each step of the protocol, either both parties receive their expected items, or neither of them receives any valuable information about their expected items.\n2. Distribution For a finite set S, a discrete probability distribution over S is a function f : S \u2192 {0, 1} such that \u03a3s\u2208S f(s) = 1. Dist(S) is the set of all distributions over finite subsets of S. The point distribution fm denotes the distribution which assigns probability 1 to m. The support of f denoted by supp(f) is the set supp(f) {s \u2208 S|f(s) > 0}.\n3. Evaluation V is a certain set of variables, and each element v \u2208 V has a specific domain Dom. The domain of the variables is restricted to integers, Boolean or bounded integers. A valuation of V is a function val: V \u2192 \u222av\u2208V Dom, where val(v) \u2208 Dom. The set of expressions over set V is denoted as Exprv. For an expression e \u2208 Exprv and a valuation v \u2208 V , the valuation of the expression is denoted by \u2016e\u2016v, where each occurrence of variable v is substituted by the value val(v) and the term is evaluated afterward. For a Boolean expression, \u2016ber\u2016 \u2208 {0, 1}, where \u201c0\u201d for false and \u201c1\u201d for true. Given a variable x and a Boolean expression ber, denote x |= ber if and only if \u2016ber\u2016x = 1.\n4. Clock restrictions Clock restrictions are a special kind of variables that can model real-time behaviors. Let C be a finite set of variables named clock which take values from R+ (non-negative reals). A clock valuation is referred to as a point v \u2208 RC . For a clock variable c \u2208 C, v(c) stands for the value of v assigned to c. For any v \u2208 RC and u \u2208 R+, the clock valuation defined as v(c) + u is denoted as u + v, which may represent the elapsed time. For B \u2286 C, let v[B := 0] denote the clock valuation gained from v by resetting all clocks to 0. Given a finite set of clock variables V , a clock restriction \u03c4 is defined inductively by the following syntax:\n\u03c4 :: = false|true|v \u2264 e|v = e|v \u2265 e|u+ e \u2264 v + f |\u00ac\u03c4 |\u03c4 \u2227 \u03c4,\nwhere u, v \u2208 V and e, f \u2208 N. The set of all clock restrictions over V is denoted as CR(V ). The clock valuation v satisfies the restriction CR(V ), written as v \u221d CR(V ), if and only if CR(V ) resolves to true\nafter each clock value v(c) from v takes the place of the corresponding clock c \u2208 C."
        },
        {
            "heading": "2.2 Probabilistic timed automaton (PTA)",
            "text": "Definition 1 (Probabilistic timed automaton, PTA) A PTA is defined as a tuple (L, C, inv, PR, Lab) described as follows:\n(1) L is a finite set of locations; (2) C is a finite set of clock variables; (3) inv: L \u2192 CR(C) is the invariant condition; (4) PR \u2286 L\u00d7 CR(C) \u00d7 Dist(2C \u00d7 L) is a finite set of probabilistic edge relations; (5) Lab: L \u2192 2AP is a labeling function that assigns atomic propositions to locations, where AP is a finite set of action labels.\nA state of a PTA is defined as a pair (l, c) \u2208 L\u00d7RC , where c \u221d inv(l)."
        },
        {
            "heading": "2.3 Probabilistic timed computation tree logic (PTCTL)",
            "text": "The properties of a PTA can be specified by the probabilistic timed computation tree logic (PTCTL). Following timed computation tree logic (TCTL) (Henzinger et al., 1994), PTCTL uses a set of formula clocks Z, which are separate from clocks C of the PTA. Formula clocks are assigned values by a formula clock valuation \u03b4 \u2208 RZ . Timing restrictions are expressed using such clocks and the reset operator is z.\u03c6. Similar to probabilistic computation tree logic (PCTL) (Hansson and Jonsson, 1994), PTCTL contains the probabilistic quantifier P\u223c\u03bb[\u00b7]. Definition 2 (PTCTL) The syntax of PTCTL is defined as follows: \u03c6::= true | a | \u03b6 | z.\u03c6 | \u03c6\u2227\u03c6 | \u00ac\u03c6 | P\u223cp [\u03c6 \u222a \u03c6], where a \u2208 AP is an atomic proposition, \u03b6 \u2208 CR(C \u222a Z), z \u2208 Z, \u201c\u223c\u201d \u2208 {<,\u2264, >,\u2265}, and p \u2208 [0, 1]."
        },
        {
            "heading": "3 Non-repudiation protocol",
            "text": "This section briefly describes the nonrepudiation protocol proposed by Markowitch and Roggeman (1999). As a kind of fair exchange protocol, a non-repudiation protocol guarantees that when the signature exchange over a network is complete, neither party can deny its participation in the process. If the protocol terminates successfully, it can provide each participant with evidence of commitment that cannot be denied by the other party. As\nillustrated in Fig. 1, this protocol can guarantee a fair exchange between the service provider, the originator O, the service consumer, and the recipient R. Assume that an authentication process, which is useful in resolving possible disputes, is executed before the protocol.\nThe protocol starts when R sends a request to O asking for a message. To prevent reply attacks, R chooses date D as time stamp along with the request. The message to be sent by O is divided into n fragments according to a geometric distribution with parameter p. The integer n stands for the number of rounds it takes to send the message; i.e., one fragment is transmitted in each round. In the remainder of this paper, the transmitted message fragment is called \u201cmessage.\u201d For the sake of fairness, n will never be revealed to the recipient during the protocol execution. O computes n functions f1, f2, \u00b7 \u00b7 \u00b7 , fn, which are parts of a function composition. They can help split the requested message M :\nfn(Mn) fn\u22121(Mn\u22121) \u00b7 \u00b7 \u00b7 f1(M1) = M.\nThe constitution operator \u201c \u201d does not satisfy the commutative law to ensure that R cannot obtain the requested message until the last message f1(M1) has been received. At step i, on receiving a request, O sends the encrypted message Mn\u2212i+1 to R and waits for the corresponding acknowledgement from R. To ensure fairness and prevent R from decoding the message, if O does not receive an acknowledgement within a certain period, it will terminate the protocol and declare that R is suspected of cheating. The chosen time limit AD must be greater than the time it takes for R to return an acknowledgement, but it ought to be less than the time required for R to decode the message. The messages encrypted by a participant P using a private key are denoted as EyP (M). The encryption of message M under key K is denoted as {M}K . The execution process of this protocol can be described as follows:\n(1) R selects date D as the time stamp st; (2) R \u2192 O: EyR(request, R, O, st), the origi-\nnator checks st then; (3) O \u2192 R: EyO({M1}K , O, R, st); (4) R \u2192 O: EyR(ack1); (5) 1\u2212 p: O \u2192 R : EyO({Mi}K , O, R, st); (6) R \u2192 O: EyR(acki); (7) if i<n, then goto step (4); (8) p: O \u2192 R: EyO({Mn}K , O, R, st);\n(9) R \u2192 O: EyR(ackn). The notion \u201cR \u2192 O: msg\u201d means that a message msg is sent by R and received by O. At step (4), O makes a probabilistic choice to guarantee p = \u03b5, where \u03b5 is a parameter used to maintain the fairness. O randomly sends R a piece of message with probability 1 \u2212 p, where p is a parameter of a geometric distribution. After receiving an acknowledgement message from R, O continues to send messages until the last one. At step (7), O sends the last message encrypted by K with probability p. On receiving the last acknowledgement, O terminates the protocol correctly. One can assume that each acknowledgement may contain the following content \u201cR confirms having received message Mi.\u201d This can be implemented easily because each acknowledgement may contain a hash of message Mi.\nAccording to the above description, the protocol should achieve the following informal nonrepudiation requirements:\n1. Fairness The originator\u2019s non-repudiation is pledged by the messages it sent which are signed with the private key. The recipient\u2019s non-repudiation is represented by the last acknowledgement, ackn. If the protocol can terminate after O receives ackn, both parties can obtain the expected information and the protocol is fair. If the protocol terminates because one party achieves the expected information while the other gains nothing, the protocol is unfair. If the protocol terminates after O receives acki (i = n), then neither O nor R obtains the expected items and fairness is maintained. In brief, the protocol should guarantee that during execution, each party can obtain the expected information, or the probability that a malicious party can obtain the expected items while the other gains nothing should be no more than \u03b5.\n2. Time-limited The network transmission delay can be ignored. The participants can always reach a point, within a certain period with probability 1, where they can terminate the protocol for the sake of fairness.\n3. Determinacy If both parties obey the protocol and behave correctly, they can both obtain the expected items when the protocol terminates with probability 1. Neither party involved in the protocol can achieve its own goal while preventing the other party from satisfying its goal.\n4. Tasks The implementation of a non-repudiation service includes evidence generation, signature transmission and storage, authentication, dispute resolution, and a duration for each transaction.\n5. Efficiency This refers to the TTP\u2019s degree of participation. The TTP may be non-existent, off-line, or on-line. In the on-line mode, the TTP fully participates in the execution of the protocol. In this mode, the TTP acts as a message delivery agent; all messages are passed through the TTP, thus creating a potential bottleneck, as proposed in the Zhou\u2013Gollmann protocol (Zhou and Gollman, 1996). As an optimistic approach to fair exchange, proposed by Kremer and Markowitch (2000) and Kremer et al. (2002), in offline mode, the TTP simply monitors the execution of the protocol and appears only when there is repudiation to be resolved. As an improved scheme, non-repudiation protocols without TTP have been proposed (Markowitch and Roggeman, 1999; Cederquist et al., 2005; Piramuthu, 2017).\nThere are other details about the original protocol that have no direct impact on modeling. Due to space constraints, they are omitted."
        },
        {
            "heading": "4 Modeling",
            "text": "In this section, according to the requirements of probabilistic model checking, the non-repudiation protocol described in Section 3 is modeled to verify the properties of the protocol."
        },
        {
            "heading": "4.1 Discussion",
            "text": "Both parties involved in the non-repudiation protocol exhibit probabilistic and non-deterministic behaviors that are time-related. Hence, the protocol should be modeled as PTA. To this end, we can use the following assumptions:\n(1) Encryption scheme: Because the nonrepudiation properties to be verified depend on the number and order of messages that are exchanged, the results will be extracted from the encryption schemes used by the original protocol and the message exchanging process is simply modeled between the two involved parties.\n(2) Transmission delay: Although the original protocol does not require communication channel quality of service (QoS), the transmission delay\nshould also be considered. If a packet is assumed to be delayed by a participant, it will not arrive at the other party\u2019s location. One variable is used to represent the time cost of sending a message.\n(3) TTP: The original protocol does not require a TTP. In this situation, the originator and the recipient are in an ad hoc pattern. The two involved parties should be modeled independently and have self-contained clocks.\n(4) Shared variables: The involved parties have their own clocks, but some actions should be obeyed globally. To achieve this goal, the model should provide communal variables that represent the corresponding clock restraints, which can be accessed by the involved parties.\n(5) The number of transmission rounds: The originator randomly chooses a number r, which is the number of rounds it will take to send the message. According to the original protocol, r obeys a geometric distribution of parameter p. This may lead to infinite steps, so for practical purposes, assume that the originator can set a maximum number of rounds rmax. The actual number of rounds should be min{r, rmax}.\n(6) Parametrization: The formal model encapsulates as many behaviors as possible. One of the advantages of the model checking technique is that it can simulate the behaviors of the target system under actual scenarios by building a flexible model. Hence, the model should be flexible by parametrization. The parameters required by the model are summarized in Table 1."
        },
        {
            "heading": "4.2 Honest recipient version",
            "text": "This subsection provides the model for O and an honest recipient R. R strictly follows the proto-\ncol. The originator, as shown in Fig. 2, is ready to send messages after initialization. Upon receiving a request, O begins to send a message encrypted with key K and waits for the acknowledgement sent by R. Then, at state O2, with probability 1 \u2212 p, it sends another encrypted message, sets the local clock x to zero, and reaches state O1, and with probability p, it sends the last message containing K and reaches state O3. Because the model does not describe the value that is passed, the actions are simply called \u201cmsg.\u201d At state O2, the expiration of the deadline for receiving an acknowledgement from the recipient is modeled by the action \u201cstop\u201d when the local clock x affirms a value greater than AD. The protocol terminates fairly when O receives the acknowledgement for the last message. An unfair termination of the protocol is reached if and only if O does not receive the acknowledgement within AD time units. In such a case, O executes the action \u201cstop.\u201d The constraint AD is used to represent an estimate of the maximum transmission delay of an acknowledgement. Actions such as \u201cinit\u201d in the model are treated as instant actions.\nFig. 3 shows the honest recipient model. R is a passive participant. It starts the protocol by sending a request. After receiving a message, it reaches state R2 and begins to send an acknowledgement. It resets the local clock y to zero and goes back to state R1 to receive another message. Whenever it receives a message, it returns an acknowledgement. Because R behaves honestly, it can always send an acknowledgement back within AD. The time t that an acknowledgement requires to be sent back and a new message to be transmitted via the network may hold: ad \u2264 t < AD.\nThe whole model which represents the protocol is defined as O||R, where O and R synchronize through the actions listed in the set A={req, msg, ack}. The protocol ends in a correct fair pattern\nwhen O sends out the last message and receives the corresponding acknowledgemen; that is, the system reaches the state {O3, R1}. On one hand, if both parties behave correctly, the unfair case cannot appear. On the other hand, it is possible to find a malicious recipient who has received the expected information and denied that fact."
        },
        {
            "heading": "4.3 Malicious recipient version",
            "text": "This subsection considers two versions of the protocol where the recipient behaves maliciously. One is for a simple malicious recipient (SMR) R, where the recipient tries to guess which is the last message. R sends an acknowledgement and decodes the received messages at the same time. However, the success condition is limited by whether O sends the last message; that is, the probability of successful decoding is p. The decoding process needs to be completed within DECODE time units where DECODE<AD so that O will not terminate the protocol or report R\u2019s malicious behaviors. Fig. 4 shows the model for R. The time necessary to decode a message is within the interval (0, DECODE]. Due to its limited ability, R can decode the whole message if and only if it receives the last message with probability p, i.e., as shown in Fig. 4, the transition from state R3 to state R4. State R4 represents the state at which R correctly decodes the whole message. Note that if DECODE<AD, R has enough time to decipher the message. Moreover, it makes no sense for O to terminate the protocol because it did not receive the last acknowledgement when the recipient has already obtained the whole message. If R fails to decode the last message with probability 1\u2212 p, it reaches state R5 and sends an acknowledgement to O. If O has k packages to send, the probability of unfair action is P (x = k) = p(1\u2212 p)k\u22121.\nAnother version involves a more powerfulR with a probabilistic encoder that can decode the message with probability q before O times out. For this version, R sends an acknowledgement and decodes the received message at the same time. Because R\u2019s capability is enhanced, it does not need to wait for the last message to arrive; it can successfully decode a message in DC2 with probability q. Or, after receiving the last message, it can decode the message correctly in DC1 with probability p. Fig. 5 shows the model for the more powerful malicious recipient. The time necessary for R to decode the message\nprobabilistically is DC2, which is less than AD. It takes DC1 time units for the more powerful R to decode the message successfully. For the sake of fairness, the protocol should choose a suitable AD so that AD< DC1. This can guarantee that R does not have enough time to decode the message during the execution of the protocol. To summarize, R can decode the message in DC1 with probability p; it can also decode the message in DC2 with probability q, where DC2 < DC1."
        },
        {
            "heading": "5 Fairness analysis",
            "text": "This section discusses, in detail, the fairness analysis of the non-repudiation protocol quantitatively. It provides the model of the protocol described in the PRISM language, discusses the properties described in the PCTL, and resolves the results of an experiment conducted with PRISM. The\noriginator randomly selects the number of rounds according to the geometric distribution with parameter p. This may lead to an infinite loop. As a liveness property, termination indicates that the protocol session terminates as expected. This section first verifies the termination property and then checks the fairness if the protocol sessions can terminate."
        },
        {
            "heading": "5.1 Honest recipient",
            "text": "The behaviors of the originatorO and the honest recipient R are modeled in Figs. 2 and 3, respectively. The corresponding PRISM codes for the models are as follows:\nad\ny\nAs illustrated in Fig. 2, the originator model has five states, represented by Oi (i = 0, 1, \u00b7 \u00b7 \u00b7 , 4). Similarly, for the recipient, variable Ri (i = 0, 1, 2) indicates its state. Variables x and y are local clock variables for O and R, respectively.\nThe invariant structure describes the clock invariants for each module in the PRISM model in terms of an expression. The restrictions imposed on the clock variables regulate the acceptable values, which rely on the other non-clock variable values. The clock invariants are usually used to describe each PTA location separately. The clock references must take the form of conjunctions of simple clock restrictions. That is, the simple expressions are of the form x \u223c c or x \u223c y, where x and y are clock variables, c is an integer-valued expression, and \u201c\u223c\u201d \u2208 {<,\u2264, >,\u2265,=}. In the model shown in Fig. 2, staying at location O1, the local clock x must satisfy\nthe condition x \u2264 0. For the above participants, the honest recipient is a passive one, and it executes only a simple action loop of receiving a message and sending an acknowledgement back. The originator is in a dominant position; it can decide whether to terminate the protocol or not. When the protocol ends in a fair correct way, the originator arrives at location O3. An honest recipient is in a completely passive position during the communication process. The termination of the protocol depends entirely on the originator, but the PTA model checking currently supports only Pmin=? and Pmax=? properties. The termination properties are described as follows:\nPmin=?[F o = 3], Pmax=?[F o = 3]. (1)\nWhen the originator sends the last message with probability p, the verification results of the termination probability are gathered in Table 2. The experimental results are calculated by PRISM without a rounding operation. The execution and termination are determined entirely by the originator. It can terminate the protocol when it receives the last acknowledgement. Based on the above analysis, the protocol can be terminated with probability 1 when there is no deception on the part of the recipient. For each value of p, it takes the model checker 0.05 s to calculate the maximum and minimum probabilities. According to the experimental results, if the participants act according to the protocol strictly via a non-lossy channel, the protocol can terminate with probability 1.\nAs for a lossy channel, assume that the messages transmitted by the channel may be lost with probability ploss. What impact will the channel QoS have on the protocol termination? The termination probabilities in three cases, where p takes the values of 0.1, 0.5, and 0.9 and ploss varies from 0.01 to 0.10, are shown in Fig. 6.\nThe termination probability of a lossy channel is affected by two factors: p and ploss. When the originator sends the last message with a lower probability p, the communication time will be prolonged compared with that in the case with a high probability p, because the protocol will not terminate until the originator receives the last acknowledgement. The actual situation caused by the decrease in p is that more packets are sent. When ploss is certain and more packets are sent, more packets are lost. In this way, for the same ploss, the decrease in p leads to a decrease in the termination probability. Similarly, for the same p, with an increase in ploss, the termination probability decreases. That is, the lower the value of p, the longer the communication time and the lower the termination probability.\nAs can be concluded from the previous experiments, the protocol can terminate with probability 1 in an ideal case, but the duration of the termination changes with the change of probability p. As a further step, it is necessary to consider whether the\nprotocol can terminate in a bounded period. The property that the protocol can successfully terminate within T time units can be described in PCTL specification as follows:\nPmin=?[F \u2264 T o = 3], Pmax=?[F \u2264 T o = 3].\n(2)\nThe trends of the minimum and maximum termination probabilities are plotted in Fig. 7, where p takes the values of 0.01, 0.05, and 0.10. Other experimental results about the minimum and maximum probabilities are listed in Table 3. Obviously, regardless of the maximum or minimum value, the termination probability increases with an increase in the protocol execution time. If the execution time is long enough, the difference between the maximum and minimum probabilities becomes smaller and smaller\nuntil it disappears completely. This is further confirmed by the experimental results. Moreover, the maximum and minimum termination probabilities increase with the increment of p. The same conclusion is confirmed by the results in Table 3. An efficient way to reduce execution time is to increase the value of p. If the originator splits the origin message into n pieces, the probability p that a message is the last one is p = 1/n. That is, to increase the value of p, the value of n should be reasonable.\nFor the lossy channel, as shown in Fig. 6, the termination probability is affected by p and ploss. To study the influence of these two parameters on termination probability, it is assumed that parameter p is constant and that ploss changes, and vice versa. The minimum and maximum termination probabilities in T time units are shown in Fig. 8, where ploss=0.02, 0.06, and 0.10 and p = 0.25 . The minimum termination probabilities in other circumstances are listed in Table 4. As the results show, with the increment of time, the termination probability slightly increases. If ploss = 0.10, the termination probability cannot even exceed 0.3 within 100 time units when p = 0.10. As shown in Fig. 8, the termination probability, either the minimum or the maximum, increases as ploss decreases. When ploss is lower than 0.05, the increment is more obvious. This shows that the protocol\u2019s running time can be reduced by improving QoS of the communication channel. Moreover, as the existing experimental results show, both the maximum and the minimum probabilities increase rapidly within 40 time units, and then tend to be stable. One can therefore consider that the median execution time of the protocol is 40 time units.\nThe situation where p changes while ploss is constant is also considered, and the experimental results\nare shown in Fig. 9, where ploss=0.01 and p=0.01, 0.03, 0.05, and 0.10. When ploss is invariant, the termination probability increases with the increase in p. In other words, for a certain period, improving the termination probability can be achieved by increasing the value of p. This is consistent with the previous experimental conclusion of improving the termination probability for a non-lossy channel. In summary, to improve the termination probability in a limited execution period, one can increase the value of probability p or improve QoS of the communication channel."
        },
        {
            "heading": "5.2 Simple malicious recipient (SMR)",
            "text": "In addition to the termination property, a more important issue is to discover the probability that will allow the recipient to cheat the originator in different situations, or conversely, to determine the best originator strategy to maintain fairness. This subsection begins to consider fairness analysis for\ntwo versions of the protocol, where the recipient acts maliciously. In the first version, an SMR tries to decode the message on receiving it and sends an acknowledgement within AD time units. The behavior of the SMR is shown in Fig. 4 and the PRISM codes are as follows:\nAs illustrated in Fig. 4, SMR has six states. Variable Ri (i = 0, 1, \u00b7 \u00b7 \u00b7 , 5) stands for the SMR state. Variable y serves as the SMR\u2019s local clock. At state R2, the recipient tries to decode the message on receiving it and sends an acknowledgement to the originator within AD time units. Due to the limitation of the protocol, it is possible for the recipient to decode the message successfully only when it receives the last message. That is, the probability that it can decode the message is p, where DECODE = 8 > AD = 5.\nThe first property is to verify the maximum probability that the recipient can decode the message successfully. This means that in the SMR model, as shown in Fig. 4, there exists a path, starting from state R0, by which the PTA can reach state R4 even-\ntually. The property can be described in PCTL as\nPmax=?[F r = 4]. (3)\nThe recipient can decode the message only when it receives the last message with probability p, and the experimental results prove this fact, as shown in Fig. 10. The experimental results also demonstrate that the protocol is \u03b5-fair, where \u03b5 = p. To maintain \u03b5-fairness, the originator should allocate the number of packets reasonably and keep the number of packets secret. In essence, the recipient can decode the message and gain information by guessing whether the message is the last one. As can be expected, after calculation, the minimum probability is zero. So, only the maximum probability is discussed.\nIn practical applications, the actual situations are not always optimistic for the recipient. The recipient benefits from the fact that it can decode the message within a certain period, so the property is to verify the probability that the malicious recipient can decode the message within T time units. It can be described in the form of PCTL as follows:\nPmax=?[F \u2264 T r = 4]. (4)\nFor this version, whether the recipient can successfully decode the message totally depends on whether it has received the last message. The action of the recipient is just like extracting a specific fragment from n fragments. This can be viewed as non-replacement sampling of finite samples in probability theory, which obeys hypergeometric distribution. Assume that there are n fragments to be sent; n \u2212 1 of them are normal fragments, and one is the last fragment. The probability that the last fragment is selected in the ith round is 1/n. As shown in Fig. 11, the maximum probability of decoding a\nmessage remains constant after the arrival of the first message, because each message may be the last one and nothing can be achieved by waiting for a long time.\nIn the above experiments, it takes the recipient DECODE (>AD) time units to decode the message. It seems that the probability of success totally depends on probability p. One may assume that the recipient is more powerful, which means that less time is required to decode the message. In the following experiment, DECODE is set to 4, which is less than AD. That is, the recipient has enough time to decode the message before sending an acknowledgement. Thus, fairness will be greatly damaged. It is necessary to verify the impact on the fairness of the protocol when the value of DECODE becomes smaller, where it reduces from 8 to 4. The experiment compares the maximum probabilities that the receiver can successfully decipher a message in DECODE time units when p = 0.01 and 0.10. Fig. 12 shows the experimental results.\nDECODE is reduced from 8 to 4, while AD remains at 5, which means that the recipient has more time to decode a message. That is, the probability\nthat the recipient can decode the message and obtain information increases sharply. This gives us an important insight; that is, to maintain fairness, one should fully consider the value of AD, to not only leave enough time for the recipient to send acknowledgements, but also prevent the recipient from being idle for a long time."
        },
        {
            "heading": "5.3 More powerful malicious recipient",
            "text": "This subsection considers a more powerful malicious recipient, which can invoke a method with probability q that it can decode the message within DC2 (DC2 < AD) time units. Moreover, it can decode the message correctly within DC1 time units (DC1 > AD). The behaviors of this kind of recipient are shown in Fig. 5 and the formal description in PRISM specification is as follows:\nBecause the recipient has become more powerful, the first property is to verify the maximum probability that the recipient can decode the message. This can be described in terms of PCTL as follows:\nPmax=?[F r = 5]. (5)\nFig. 13 shows the trends of the maximum probability that the recipient can decipher the message. The variation of q from 0 to 1.0 represents the fact that the decoding ability of the recipient gradually improves. The probabilities for other cases are listed in Table 5. As the experimental results show, even if the recipient can decode the message within DC2 time units, the probability is still subjected to parameter p.\nWith the incremental ability of the malicious recipient, can fairness be guaranteed? The probability that the recipient can decode the message within T time units can answer this question. To maintain consistency with the previous experiments (Fig. 13),\nthe values of p and q remain. Fig. 14 shows the maximum probability that the recipient can decode the message within T time units.\nAs shown in Fig. 14, the growth of the maximum probability is generally rapid within the interval [10, 20], while the growth tends to be steady in the interval [20, 100]. The time it takes to decipher the message probabilistically is DC2, which is far less than 20. Even after a longer period, the probability is still steady. Hence, one can draw a conclusion that if the recipient decodes a message successfully, the median time cost is 20 time units. According to the analysis of the experimental results in Fig. 13 and Table 5,\nthe probability of successful decoding increases with the increase of p and/or q. It is necessary to study the trend for the first 10 time units. The maximum probability where T \u2208[1, 10] is shown in Fig. 15. The maximum probability that the recipient can decode the message within T time units for other cases is listed in Table 6.\nBased on the above experimental results shown in Fig. 14 and Table 6, one can conclude that when T \u2208[DC2, DC1), the maximum probability is approximately equal to p \u00d7 q. To guarantee fairness, the most direct means is to reduce the probability.\nWhen the capacity of the receiver cannot be limited, the value of p can be reduced. Another way to guarantee fairness is to reduce the value of AD. If AD is far samller than DC2, it is almost impossible for the recipient to decode the message. Another important issue to be noted is that, as listed in Table 6, the maximum probability varies sharply when T changes from 7 to 10, no matter what value q takes. This fact shows that if AD is within 7, the probability that the recipient can decipher the message is reduced significantly."
        },
        {
            "heading": "5.4 Other issues",
            "text": "The parameter p used in the original protocol is the parameter of a geometric distribution. Some research, such as Aldini and Gorrieri (2002), assumed that the originator can split the transmitted message following a Bernoulli distribution with parameter p. I do not think this is appropriate, because a Bernoulli distribution is a discrete probability distribution. It describes a random event that happens only once and may randomly yield two results. While the originator in the protocol is constantly sending messages, Bernoulli distribution describes only whether the message being sent is the last one or not, but cannot describe the sending behavior continuously. Moreover, the behavior cannot be described by the n-fold Bernoulli distribution, that is, a binomial experiment, because if the originator sends the last message with probability p, it means the termination of the sending process. However, the n-fold Bernoulli experiment allows the event to continue to occur with probability 1 \u2212 p, which is obviously inconsistent with the actual behavior of the originator.\nThe behavior of the originator is exactly consistent with the behavior described by the geometric distribution; that is, the first k \u2212 1 experiments fail (sending normal messages), and the kth (the last) experiment succeeds (sending the last message)."
        },
        {
            "heading": "6 Conclusions",
            "text": "The non-repudiation protocol proposed by Markowitch and Roggeman (1999) provides a security solution for fair message exchange mechanisms. Related research focuses mainly on the design of nonrepudiation protocols, security analysis, and security guarantees. This paper focuses on a fairness analysis of this protocol. In the context of non-repudiation protocols, fairness means that during the execution of the protocol, either the participants obtain their excepted items, or the probability that one of the parties can obtain its expected items while the other gains nothing is smaller than a negligible threshold \u03b5.\nThe non-repudiation protocol is probabilistic. Therefore, this paper uses probabilistic model checking to verify the fairness properties quantitatively using the PRISM model checker. I consider three versions of this protocol. The originator is considered honest and will always abide by the protocol. In the first version, both parties obey the protocol strictly. The second version involves a simple malicious recipient that guesses whether it has received the last message and tries to decipher the message. The last version involves a more powerful recipient that can decode the message probabilistically within the deadline for sending an acknowledgement, but also deciphers the message correctly within a certain period. The three versions are modeled as PTAs and translated into PRISM specifications.\nIn the first version, both parties abide by the protocol strictly and fairness can be guaranteed. Because the original protocol specifies that the parameter p obeys a geometric distribution, this may lead to an infinite loop. Therefore, this paper proposes to limit the number of transmitted messages in a reasonable range and focuses on verification of the termination property. Termination over a period is affected mainly by two factors: one is the probability p, and the other is the QoS of the communication channel. Experimental results show that the higher the value of p, the higher the termination probability\nwithin T time units, and the better the QoS, the higher the termination probability.\nFor the malicious recipient version, when the recipient can decode the message by only guessing whether it is the last message, the probability of unfairness is determined by parameter p. We can further restrict the recipient\u2019s idle time by setting the value of AD to ensure the fairness. The more powerful recipient can both decipher the message probabilistically within DC2 with probability q and decode the message correctly in DC1. The maximum probability that the recipient can decode the message is approximately equal to p \u00d7 q during the period T \u2208[DC2, DC1). When the computing power of the recipient cannot be limited and the probability p is not changed, we can maintain fairness by setting the value of AD so that it cannot exceed 7 and is far smaller than DC2.\nWith the increase of computing power, both the originator and the recipient may infer the possible behaviors of the other party based on historical data and make corresponding decisions accordingly. Because both the originator and the recipient have the ability to think, modeling for both parties and analyzing relevant attributes are possible future work.\nTo prevent an infinite execution loop, this paper assumes that the upper bound of message transmission cannot exceed rmax. This is a safety hazard. If the maximum number of steps is known or deduced by the recipient, it knows the information when the maximum number of steps is reached during an execution of the protocol. Therefore, it can refuse to acknowledge receipt of the encrypted message and break fairness with probability 1. In the future work a better scheme will be discussed for the originator to determine the number of steps in the protocol.\nCompliance with ethics guidelines Xu GUO declares that he has no conflict of interest."
        }
    ],
    "title": "Fairness analysis of extra-gain guilty of a non-repudiation protocol",
    "year": 2022
}