{
    "abstractText": "In this paper we propose a protocol that can be used to covertly send a distress signal through a seemingly normal webserver, even if the adversary is monitoring both the network and the user\u2019s device. This allows a user to call for help even when they are in the same physical space as their adversaries. We model such a scenario by introducing a strong adversary model that captures a high degree of access to the user\u2019s device and full control over the network. Our model fits into scenarios where a user is under surveillance and wishes to inform a trusted party of the situation. To do this, our method uses existing websites to act as intermediaries between the user and a trusted backend; this enables the user to initiate the distress signal without arousing suspicion, evenwhile being actively monitored. We accomplish this by utilising the TLS handshake to convey additional information; this means that any website wishing to participate can do so with minimal effort and anyone monitoring the traffic will just see common TLS connections. In order for websites to be willing to host such a functionality the protocol must coexist gracefully with users who use normal TLS and the computational overhead must be minimal. We provide a full security analysis of the architecture and prove that the adversary cannot distinguish between a set of communicationswhich contains a distress call and a normal communication.",
    "authors": [
        {
            "affiliations": [],
            "name": "Hayyu Imanda"
        },
        {
            "affiliations": [],
            "name": "Kasper Rasmussen"
        }
    ],
    "id": "SP:457f4fdfbc3b6e4b5830c9826e5f484ff355ff0e",
    "references": [
        {
            "authors": [
                "Aidin Ameri",
                "Daryl Johnson"
            ],
            "title": "Covert Channel over Network Time Protocol",
            "venue": "Association for Computing Machinery,",
            "year": 2017
        },
        {
            "authors": [
                "Filipe Beato",
                "Emiliano De Cristofaro",
                "Kasper B. Rasmussen"
            ],
            "title": "Undetectable communication: The Online Social Networks case",
            "venue": "In 2014 Twelfth Annual International Conference on Privacy, Security and Trust. IEEE,",
            "year": 2014
        },
        {
            "authors": [
                "Filipe Beato",
                "Iulia Ion",
                "Srdjan \u010capkun",
                "Bart Preneel",
                "Marc Langheinrich"
            ],
            "title": "For Some Eyes Only: Protecting Online Information Sharing. In Proceedings of the Third ACM Conference on Data and Application Security and Privacy (San Antonio, Texas, USA) (CODASPY \u201913)",
            "venue": "Association for Computing Machinery,",
            "year": 2013
        },
        {
            "authors": [
                "Daniel J. Bernstein",
                "Mike Hamburg",
                "Anna Krasnova",
                "Tanja Lange"
            ],
            "title": "Elligator: Elliptic-Curve Points Indistinguishable from Uniform Random Strings",
            "venue": "In Proceedings of the 2013 ACM SIGSAC Conference on Computer & Communications Security (Berlin, Germany)",
            "year": 2013
        },
        {
            "authors": [
                "R. Chandramouli",
                "N. Memon"
            ],
            "title": "Analysis of LSB based image steganography techniques",
            "venue": "In Proceedings 2001 International Conference on Image Processing (Cat. No.01CH37205),",
            "year": 2001
        },
        {
            "authors": [
                "Jeremy Clark",
                "Urs Hengartner"
            ],
            "title": "Panic Passwords: Authenticating under Duress",
            "venue": "In Proceedings of the 3rd Conference on Hot Topics in Security (San Jose, CA) (HOTSEC\u201908). USENIX Association,",
            "year": 2008
        },
        {
            "authors": [
                "Mike Crittenden"
            ],
            "title": "How to Use Shorkeys. https://github.com/crittermike/ shortkeys/wiki/How-To-Use-Shortkeys",
            "year": 2019
        },
        {
            "authors": [
                "George Davida",
                "Yair Frankel",
                "Yiannis Tsiounis",
                "Moti Yung"
            ],
            "title": "Anonymity control in E-cash systems",
            "venue": "In Financial Cryptography (Lecture Notes in Computer Science),",
            "year": 1997
        },
        {
            "authors": [
                "Simon Eberz",
                "Kasper B. Rasmussen",
                "Vincent Lenders",
                "Ivan Martinovic"
            ],
            "title": "Looks Like Eve: Exposing Insider Threats Using Eye Movement Biometrics",
            "venue": "ACM Trans. Priv. Secur",
            "year": 2016
        },
        {
            "authors": [
                "Megan L. Evans",
                "Margo Lindauer",
                "Maureen E. Farrell"
            ],
            "title": "A Pandemic within a Pandemic \u2014 Intimate Partner Violence during Covid-19",
            "venue": "New England Journal of Medicine 383,",
            "year": 2020
        },
        {
            "authors": [
                "Gina Fisk",
                "Mike Fisk",
                "Christos Papadopoulos",
                "Joshua Neil"
            ],
            "title": "Eliminating Steganography in Internet Traffic with Active Wardens",
            "venue": "In Information Hiding,",
            "year": 2003
        },
        {
            "authors": [
                "Eu-Jin Goh",
                "Dan Boneh",
                "Benny Pinkas",
                "Philippe Golle"
            ],
            "title": "The Design and Implementation of Protocol-Based Hidden Key Recovery",
            "venue": "In Information",
            "year": 2003
        },
        {
            "authors": [
                "Johan H\u00f8astad",
                "Jakob Jonsson",
                "Ari Juels",
                "Moti Yung"
            ],
            "title": "Funkspiel schemes: an alternative to conventional tamper resistance",
            "venue": "In Proceedings of the 7th ACM conference on Computer and communications security - CCS",
            "year": 2000
        },
        {
            "authors": [
                "Nicholas J. Hopper",
                "John Langford",
                "Luis von Ahn"
            ],
            "title": "Provably Secure Steganography",
            "venue": "In Advances in Cryptology \u2014 CRYPTO",
            "year": 2002
        },
        {
            "authors": [
                "William Huba",
                "Bo Yuan",
                "Daryl Johnson",
                "Peter Lutz"
            ],
            "title": "A HTTP Cookie Covert Channel. In Proceedings of the 4th International Conference on Security of Information and Networks (Sydney, Australia) (SIN \u201911)",
            "venue": "Association for Computing Machinery,",
            "year": 2011
        },
        {
            "authors": [
                "Josh Karlin",
                "Daniel Ellard",
                "Alden W. Jackson",
                "Christine E. Jones",
                "Greg Lauer",
                "David P. Mankins",
                "W. Timothy Strayer"
            ],
            "title": "Decoy Routing: Toward Unblockable Internet Communication",
            "venue": "In USENIX Workshop on Free and Open Communications on the Internet (FOCI 11)",
            "year": 2011
        },
        {
            "authors": [
                "Sheharbano Khattak",
                "Tariq Elahi",
                "Laurent Simon",
                "Colleen M. Swanson",
                "Steven J. Murdoch",
                "Ian Goldberg"
            ],
            "title": "SoK: Making Sense of Censorship Resistance Systems",
            "venue": "Proceedings on Privacy Enhancing Technologies 2016,",
            "year": 2016
        },
        {
            "authors": [
                "Katharina Kohls",
                "Thorsten Holz",
                "Dorothea Kolossa",
                "Christina P\u00f6pper"
            ],
            "title": "SkypeLine: Robust Hidden Data Transmission for VoIP",
            "venue": "In Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security (Xi\u2019an, China) (ASIA CCS \u201916)",
            "year": 2016
        },
        {
            "authors": [
                "Norka B. Lucena",
                "Grzegorz Lewandowski",
                "Steve J. Chapin"
            ],
            "title": "Covert Channels in IPv6. In Privacy Enhancing Technologies, George Danezis and David Martin (Eds.)",
            "year": 2006
        },
        {
            "authors": [
                "Elisabeth Mahase"
            ],
            "title": "Covid-19: EU states report 60% rise in emergency calls about domestic violence",
            "year": 2020
        },
        {
            "authors": [
                "Cl\u00e9mentine Maurice",
                "ManuelWeber",
                "Michael Schwarz",
                "Lukas Giner",
                "Daniel Gruss",
                "Carlo Alberto Boano"
            ],
            "title": "Hello from the Other Side: SSH over Robust Cache Covert Channels in the Cloud",
            "venue": "In Proceedings of the 2017 Network and Distributed Systems Security. The Internet Society,",
            "year": 2017
        },
        {
            "authors": [
                "Alfred J. Menezes",
                "Scott A. Vanstone"
            ],
            "title": "Elliptic Curve Cryptosystems and Their Implementation",
            "venue": "J. Cryptol",
            "year": 1993
        },
        {
            "authors": [
                "Bodo M\u00f6ller"
            ],
            "title": "A Public-Key Encryption Scheme with Pseudo-random Ciphertexts",
            "venue": "ESORICS",
            "year": 2004
        },
        {
            "authors": [
                "Hilary Osborne",
                "Sam Cutler"
            ],
            "title": "Chinese border guards put secret surveillance app on tourists",
            "venue": "phones. https://www.theguardian.com/world/2019/jul/02/ chinese-border-guards-surveillance-app-tourists-phones",
            "year": 2019
        },
        {
            "authors": [
                "Hung-Jr Shiu",
                "Bor-Shing Lin",
                "Bor-Shyh Lin",
                "Po-Yang Huang",
                "Chien-Hung Huang",
                "Chin-Laung Lei"
            ],
            "title": "Data Hiding on Social Media Communications Using Text Steganography",
            "venue": "In Risks and Security of Internet and Systems,",
            "year": 2018
        },
        {
            "authors": [
                "J.H. Silverman"
            ],
            "title": "The Arithmetic of Elliptic Curves",
            "venue": "Graduate Texts in Mathematics,",
            "year": 1997
        },
        {
            "authors": [
                "Gustavus J. Simmons"
            ],
            "title": "The Prisoners\u2019 Problem and the Subliminal Channel",
            "year": 1984
        },
        {
            "authors": [
                "Emil Stefanov",
                "Mikhail Atallah"
            ],
            "title": "Duress Detection for Authentication Attacks againstMultiple Administrators",
            "venue": "Association for Computing Machinery,",
            "year": 2010
        },
        {
            "authors": [
                "Michael Carl Tschantz",
                "Sadia Afroz",
                "Anonymous",
                "Vern Paxson"
            ],
            "title": "SoK: Towards Grounding Censorship Circumvention in Empiricism",
            "venue": "In 2016 IEEE Symposium on Security and Privacy (SP). IEEE, California,",
            "year": 2016
        },
        {
            "authors": [
                "Luis von Ahn",
                "Nicholas J. Hopper"
            ],
            "title": "Public-Key Steganography. In Advances in Cryptology - EUROCRYPT 2004, Christian Cachin and Jan L",
            "year": 2004
        },
        {
            "authors": [
                "Adam Young",
                "Moti Yung"
            ],
            "title": "Kleptography from Standard Assumptions and Applications. In Security and Cryptography for Networks, Juan A",
            "year": 2010
        },
        {
            "authors": [
                "Jiangshan Yu",
                "Mark Ryan",
                "Cas Cremers"
            ],
            "title": "DECIM: Detecting Endpoint Compromise In Messaging",
            "venue": "IEEE Transactions on Information Forensics and Security 13,",
            "year": 2018
        }
    ],
    "sections": [
        {
            "heading": "1 INTRODUCTION",
            "text": "In the United Kingdom, the Ask for Angela campaign [36] allows any individual who feels unsafe an exit from the establishment they are in by asking for a fictional member named Angela, prompting a trained member of staff to ensure a safe passage and potentially call the authorities. Even more recently, major pharmacies across the UK have taken part inAsk for Ani (Action Needed Immediately) [34], where the pharmacy would provide a consultation room for people experiencing domestic abuse. These campaigns are aimed to allow survivors of domestic abuse to systematically be able to inform someone of their situation in a discreet manner, in a physical space that is common for them to visit.\nDuring the Covid-19 pandemic, there has been an increase in demand for survivors of domestic abuse services, which indicate an increase in the severity of abuse being perpetrated while survivors were not able to leave home [18]; EU Member States experienced a similar trend [30]. While some regions in the US have reported that the number of calls received by domestic violence hotlines have dropped, experts believe that this is not a reflection of a decrease in the number of cases but rather that survivors were unable to safely connect with services while they are in the same space as their abusers [16]. A solution is needed where survivors can safely reach out from their own homes, and this is a difficult task.\nIn this paper, we present an adversarymodel where the adversary has a high degree of control over a user\u2019s device and complete control over the local network. Our model allows an abstraction of real-life scenarios, where an adversary has visual access to the user\u2019s device while the user wishing to request help\u2014this can be through sharing a physical space or the adversary\u2019s ability to monitor the screen through a camera. In addition to the above, this may include travellers who have been required to enter their authentication information at a hostile nation\u2019s border [35], or an intelligence agent who has to covertly inform of their capture while being in full surveillance by their captors [21].\nIn certain situations, if communication dedicated to signalling distress is detected, it can lead to further consequences from the adversary. Hence, it is important that the system hidesthe fact that the user is signalling distress. We accomplish this using several different techniques: firstly, we rely on (existing) webservers to enrol in the scheme so they can act as intermediaries in communication between the user and the backend\u2014this goes a long way towards making the connection seem innocent even if the device is under observation; secondly, to make sure the distress signal is undetectable on the network, we embed the distress signal by utilising the random nonce in the TLS handshake as a covert channel. This ensures that a signal can be sent without the adversary\u2019s knowledge while not compromising the underlying TLS session. We formalise our security notion using a security game, and with the formal definition of security and the adversary model we are able to provide a thorough proof of the security of our protocols. We summarise our contributions as follows:\n\u2022 We introduce a local adversary Aloc, who in addition to being a Dolev-Yao adversary on the network, also has visual access to the user\u2019s device screen as well as all the user\u2019s TLS application layer data. \u2022 We create an infrastructure for distress reporting, where one central entity receives distress signals along with accompanying information, as well as webservers who voluntarily participate acting as entry points. \u2022 Within the distress infrastructure, we introduce enrolment protocols for the user and the webserver, as well as the main protocol with which the distress signal is relayed by the webserver to the central entity. \u2022 We introduce encoding and decoding functions to hide the distress and necessary information while being sent to the webserver with the presence of Aloc. We piggyback on the TLS handshake to send the output of the encoding function, and we provide a security analysis to show that Aloc will not be able to distinguish between a distribution of nonces containing a distress signal and that of normal communications. ar X iv :2\n31 0.\n03 23\n7v 1\n[ cs\n.C R\n] 5\nO ct\n2 02\n3\nThe fundamental goal of our scheme is for the user to signal distress to an online entity, where enrolment is possible beforehand. There are many non-technical facets of our scheme that are out of scope for this paper, including the resolution of the situation after the distress is received. Further, our scheme discusses the protocols that occur behind the scenes of the user initiating the distress; the human interaction with the device needs to be designed in a proper, user-friendly manner. These issues are incredibly important but are considered future work, however we highlight some possibilities in Section 9."
        },
        {
            "heading": "2 DESIGN GOALS",
            "text": "One trivial attempt to achieve the user\u2019s goal of communicating a distress signal is for the user to send an encrypted message to a trusted third party (e.g. a police website). However, the adversary, having full control of the network, is trivially aware of such attempt by the user. However, indeed for a very specific use-case, one webserver can be set up for the specific purpose of receiving a distress signal (i.e. the user communicates directly to the trusted third party)\u2014this is possible only if the adversary isn\u2019t aware of the purpose of such website.\nA second attempt may gain inspiration from existing schemes: in UK pharmacies participating in the Ask for Ani scheme, a domestic abuse survivor may enter the establishment, even with the presence of the abuser, and ask for Ani to a staff member who will give them access to a safe space and contact the relevant authorities. In network communications, this translates to the user signalling distress by sending messages that may look unsuspicious, but has been agreed upon with a trusted third party that this is a cry for help\u2014e.g., uploading a specified text on social media. Even without the adversary knowing the exact text, this scheme does not give enough guarantees; codeword or codephrase that appears to be outof-place or irrelevant to ongoing events may trigger suspicion [6].\nIn the online case, the adversary may perform statistical tests to detect when a particular communication is sent. Other methods, including hidden information on social media (for example, through hiding data on a text\u2019s white space [4, 40], or hiding messages in images [9]) can still be distinguished by the adversary. If this scheme is to be deployed with the target of reaching as many potential users that may benefit from this, we need to assume that the system we design is public, and the adversary only lacks access to several secret components, also known as Kerckhoff\u2019s principle.\nOur approach shares some similarities with Ask for Ani, namely that we depend on participation of existing establishments to be the primary receiver of the distress signal, before relaying them. In particular, we believe well-known websites to be well placed to be this intermediary: a wide enough adoption would minimise suspicion based on the recipient of communication, especially as the user can choose these participating websites.\nThe websites will have to undergo an enrolment process, and this enrolment may be open on a rolling basis. The participation from websites in the scheme is necessary, so we need to ensure that the overhead for the participating sites is as small as possible. With each enrolled website, we utilise the TLS handshake; TLS is a widely deployed system and we minimise the complexity of the scheme deployment on a large scale. In addition, we use public key encryption\nfor the user to communicate with the webserver for scalability. Our strategy is to encode this information into communication objects that are not immediately predictable in the underlying protocol, and we specifically choose the client nonce as it is a value that is chosen on the user side, as well as having a large enough size to include necessary information that can be understood and relayed by the participating websites. Its low predictability means that we can propose a way such that the adversary will not be able to determine whether or not a distress signal is sent with polynomially-bounded statistical tests. However, we note that our scheme can be adjusted to other objects with the relevant properties.\nOur method is designed for the user to signal distress against an adversary that has a high degree of control of the network in which the user operates on, as well as having visual access to the user\u2019s device screen, which may be a result of being in close physical proximity of the user. Though this would cover most scenarios we have presented, we also cover a wider, stronger set of adversaries who are able to see application layer data of the user\u2019s TLS connections\u2014for example, this can be done by setting up a TLS termination proxy."
        },
        {
            "heading": "2.1 System Model",
            "text": "The three principal players of the system are as follows, and are shown in Figure 1.\n(1) The user: the player trying to signal distress to a trusted party. The user\u2019s goal is to communicate a distress signal to the trusted party without the adversary\u2019s knowledge. (2) The webserver: a webserver who relays the user\u2019s distress signal to a distress coordination point. To take part in the scheme, the webserver has to go through an enrolment process, and user chooses which webservers to send the distress signal to. We do not, however, assume that the webserver is always honest. (3) The distress coordination point (DCP): a trusted party who receives distress signals. We assume that DCP is always honest.\nAny webserver may sign up to participate, though it is up to the user to decide the webserver to send a distress signal to if the choice is plenty (and this amount is up to the system designer, dependent on the use-case). Should there be many options, for the user, this decision can be made primarily based on two things: the\ntrustworthiness of the website, and minimising suspicion from the adversary when visiting the site.\nThe trustworthiness of the website can be judged in many ways, for example, the user might choose more popular sites over those with less reputation to lose. To minimise suspicion from the adversary, the user can choose websites that they regularly visit or a popular site they would have a legitimate reason to visit in any circumstance; again, this depends on the specific scenario: during a border check that requires the user to open their email or social media site, these sites may be chosen during enrolment.\nIn addition, we assume that the user, webserver, and DCP are all able to make a TLS connection and we assume that the user can communicate freely with the webserver at all times.\nOur system operates in three steps: (1) the server enrolment, where the webserver communicates\nwith DCP so the server is added to the server database, as well as to facilitate the exchange of necessary encryption keys. (2) the user enrolment, where the user communicates with DCP so the user is added to the user database, for the user to choose the webservers they trust, as well as the exchange of identifier and encryption keys. (3) the main distress signal protocol, which the user uses to signal distress.\nThough these steps are separate and somewhat sequential, it is important to note that new webservers and new users can enrol at any time. In addition, webservers and users who have enrolled before are able to update any enrolment details at any time."
        },
        {
            "heading": "2.2 Adversary Model",
            "text": "We consider three different adversaries located in different parts of the system, each with different capabilities and goals. Firstly, we have the network adversary Anet, an external Dolev-Yao type adversary\u2014that is, we assume that the adversary carries the message and make no further assumptions about confidentiality and integrity of the messages passed on the network. The goals ofAnet is to violate message confidentiality and message integrity (for example, to understand which users are signalling distress, or falsely trigger distress on behalf of an honest user). We also consider a malicious webserver Aweb whose goals are similar to Anet but Aweb acts as a proxy for the users messages and is expected to relay communication to the DCP.\nLastly we introduce Aloc, the local adversary. Aloc has control over all of the user\u2019s communication channels (so is a subset of Anet, but in addition, has access to the application layer content of TLS and the user\u2019s screen. We only assume that the internal state of running applications, including the user\u2019s secret keys, can be kept secret, and that Aloc is not present during the user enrolment process and will not have any access to past enrolment communication. This is a new and non-standard adversary model that captures the scenarios we described. The goal of Aloc is to detect a distress signal amongst normal communications. We make this more precise in Section 3.\nNote that it is possible forAloc to create their ownwebserver, i.e. Aloc and Aweb are the same entity. However, as the user chooses which webservers they deem trusworthy, we do not consider this\ncase. In addition, Aloc has also the capabilities of Aweb but with additional resources. Henceforth, we consider Aloc, Anet, and Aweb as three independent entities. We do not consider correlation attacks with colluding adversaries, for example by traffic or timing analysis, nor do we consider attacks on availability by Aloc or Aweb."
        },
        {
            "heading": "3 DISTRESS INDISTINGUISHABILITY",
            "text": "In this section, we introduce a security definition to capture the situation in which we illustrate howAloc can use their capabilities in order to detect a distress signal. We first start with the following.\nDefinition 3.1. For \ud835\udc51 \u2208 {true, false}, and \ud835\udc65 from a finite domain, a function \ud835\udc53\ud835\udc41 (\ud835\udc51, \ud835\udc65, \ud835\udc58) is a fixed-length reversible function if:\n(1) |\ud835\udc53\ud835\udc41 (\ud835\udc51, \ud835\udc65, \ud835\udc58) | = \ud835\udc41 (2) Except with negligible probability, there exists \ud835\udc54(\ud835\udc66, \ud835\udc58\u2032) such\nthat \ud835\udc54(\ud835\udc53 (\ud835\udc51, \ud835\udc65, \ud835\udc58), \ud835\udc58\u2032) = { \ud835\udc51, \ud835\udc65 if \ud835\udc51 = true \ud835\udc51 if \ud835\udc51 = false .\nThe definition above simply states that the scheme preserves a binary value \ud835\udc51 as well as some additional information \ud835\udc65 if \ud835\udc51 = true that is reversible by using some key (\ud835\udc58, \ud835\udc58\u2032). In addition, such function has a fixed output size \ud835\udc41 . Of course, the trivial mapping would satisfy the definition, but we also need it to satisfy some security: for our scheme to be secure, we require the function to not only preserve the distress, but hide it amongst other connections. Given that the adversary has access to TLS connections, they may have recorded a polynomial amount of client nonces in normal communication when the user isn\u2019t intending to signal distress. We formalise this in the following security game.\nDefinition 3.2. Let \ud835\udc53\ud835\udc41 be a fixed-length reversible function, \ud835\udc65\ud835\udc56 a finite string, and \ud835\udc5d\ud835\udc58 a public key for a public key encryption scheme. Consider the following experiment ExpIndDistress\ud835\udc53\ud835\udc41A (\ud835\udc5b):\nChallenger Adversary\n\ud835\udc651, . . . , \ud835\udc65\ud835\udc5b\n(\ud835\udc5d\ud835\udc58, \ud835\udc60\ud835\udc58 ) \u2190 K \ud835\udc4f \u2190\ud835\udc45 {0, 1} Construct \ud835\udc5f1, . . . , \ud835\udc5f\ud835\udc5b\n\ud835\udc5d\ud835\udc58, \ud835\udc5f1, . . . , \ud835\udc5f\ud835\udc5b,\nGuess \ud835\udc4f\u2032 \u2208 {0, 1}\n\ud835\udc4f\u2032\nThe challenger constructs \ud835\udc5f1, . . . , \ud835\udc5f\ud835\udc5b as follows:\n(1) if \ud835\udc4f = 0: \ud835\udc62\ud835\udc56 \u2190 \ud835\udc53\ud835\udc41 (false, \ud835\udc65\ud835\udc56 , \ud835\udc5d\ud835\udc58) for each \ud835\udc56 = 1, . . . , \ud835\udc5b, (2) if \ud835\udc4f = 1: \ud835\udc37 consists of \ud835\udc5b \u2212 1 numbers \ud835\udc5f\ud835\udc56 \u2190 \ud835\udc53\ud835\udc41 (false, \ud835\udc65\ud835\udc56 , \ud835\udc58)\nand for exactly one \ud835\udc57 \u2208 {1, . . . , \ud835\udc5b}, \ud835\udc5f \ud835\udc57 \u2190 \ud835\udc53\ud835\udc41 (true, \ud835\udc65 \ud835\udc57 , \ud835\udc5d\ud835\udc58) Define the advantage of A on \ud835\udc53\ud835\udc41 to be:\nAdvIndDistress,\ud835\udc53\ud835\udc41A (\ud835\udc5b) = | Pr[A outputs 1|\ud835\udc4f = 0]\u2212Pr[A outputs 1|\ud835\udc4f = 1] |.\nWe say that a fixed-length reversible function \ud835\udc53\ud835\udc41 (\ud835\udc65,\ud835\udc66) is IndDistress secure if for all probabilistic polynomial time adversaryA(\ud835\udc5b), there exists a negligible function \ud835\udf16 (\ud835\udc5b) such thatAdvIndDistress,\ud835\udc53\ud835\udc41A (\ud835\udc5b) \u2264 \ud835\udf16 (\ud835\udc5b) .\nThe experiment above describes the scenario where the adversary is able to receive a distribution of \ud835\udc5b nonces, and to guess whether or not it contains a distress call, which accurately captures our scenario as the vast majority of TLS connections will be normal communications not signalling distress. When given any amount of nonces, we want to create a scheme where the adversary will not be able to correctly guess whether or not a distress signal exists within that distribution. Intuitively, we need an encryption function to preserve and keep the distress confidential; indeed, note that any fixed-length encryption function would satisfy this, however we do not require the function to return the whole plaintext when \ud835\udc51 = false. Hence, we use encryption for part of but not all of \ud835\udc53\ud835\udc41 ; we will proceed in constructing a fixed-length reversible function that is IndDistress secure in Section 5."
        },
        {
            "heading": "4 SECURITY PROTOCOLS",
            "text": "In this section, we design the architecture where the user can covertly signal distress to DCP via the webserver. Before the distress can be sent, both the user and webserver have to separately go through an enrolment process."
        },
        {
            "heading": "4.1 Server Enrolment",
            "text": "The server enrolment aims to include the webserver in the server database. This allows DCP to store the webserver\u2019s public key, as well as to agree on a secret key between the webserver and DCP. This protocol is shown in Figure 2.\nThe webserver connects to DCP using TLS. The webserver generates a public and private key pair (\ud835\udc5d\ud835\udc58\ud835\udc35\u2032 , \ud835\udc60\ud835\udc58\ud835\udc35\u2032 ) for the encryption scheme discussed in Section 5.3, and stores it locally. In addition, the webserver chooses a Diffie-Hellman exponent \ud835\udc4f. The webserver then calculates and sends \ud835\udc54\ud835\udc4f , along with their identity \ud835\udc35, their certificate Cert\ud835\udc35 , their encryption public key \ud835\udc5d\ud835\udc58\ud835\udc35\u2032 , and a signature Sign\ud835\udc35 (\ud835\udc54\ud835\udc4f , \ud835\udc35, \ud835\udc5d\ud835\udc58\ud835\udc35\u2032 ) signed using the private key of the certificate Cert\ud835\udc35 . Note that Cert\ud835\udc35 is a certificate for the public key of the webserver, not the newly generated encryption keys.\nAfter receiving the message, DCP verifies the certificate Cert\ud835\udc35 , and uses the certificate\u2019s public key to verify Sign\ud835\udc35 ; by doing this, DCP verifies that the webserver actually holds the private key of Cert\ud835\udc35 , proving authenticity. When all the verification steps have been passed, DCP then chooses their Diffie-Hellman exponent \ud835\udc50 and computes the Diffie-Hellman key \ud835\udc58\ud835\udc35\ud835\udc36 = (\ud835\udc54\ud835\udc4f )\ud835\udc50 . DCP then stores the webserver\u2019s identity \ud835\udc35, the freshly generated public key \ud835\udc5d\ud835\udc58\ud835\udc35\u2032 , and the shared key \ud835\udc58\ud835\udc35\ud835\udc36 in the server database, before sending \ud835\udc54\ud835\udc50 to the server so the server can also compute \ud835\udc58\ud835\udc35\ud835\udc36 . Here, \ud835\udc58\ud835\udc35\ud835\udc36 is the seed for a key derivation function which can be used to derive encryption and MAC keys used later on in the protocols; we use \ud835\udc58\ud835\udc35\ud835\udc36 to describe the keys derived from this seed."
        },
        {
            "heading": "4.2 User Enrolment",
            "text": "The user enrolment process, occurring independently from the server enrolment, allows the user to be added to the user database\nand for both the user and DCP to agree on necessary shared secrets to which the main protocol rely on: the user identifier, a secret sequence number, and a shared key between the user and DCP. The user also obtains the list of chosen websites and their public keys. The protocol is shown in Figure 3.\nThe user begins a TLS connection with DCP. The user chooses a username usr\ud835\udc34 and password pwd\ud835\udc34 to register with (or to authenticate themselves if they have previously enrolled), as well as a sequence number sqn\ud835\udc34 and a Diffie Hellman exponent \ud835\udc4e. The user sends usr\ud835\udc34 , pwd\ud835\udc34 , sqn\ud835\udc34 ,\ud835\udc54\ud835\udc4e to DCP. In addition, the user sends their information info\ud835\udc34 , which is needed for DCP to react appropriately in case of distress, as well as a preference on how the user can obtain confirmation, which we discuss in Section 9.\nAfter receipt, DCP proceeds to store usr\ud835\udc34, pwd\ud835\udc34, info\ud835\udc34 in the user database and sends back the list of participating webservers from the server database. From the list, the user chooses a subset websites\ud835\udc34 , and returns their choice to the DCP. DCP then chooses a Diffie-Hellman exponent \ud835\udc50 and computes the shared key \ud835\udc58\ud835\udc34\ud835\udc36 = (\ud835\udc54\ud835\udc4e)\ud835\udc50 . In addition, DCP generates id\ud835\udc34 , a unique random string of fixed size \ud835\udc5a\ud835\udc56 which acts as the user\u2019s identifier in the system, and stores \ud835\udc58\ud835\udc34\ud835\udc36 , id\ud835\udc34, sqn\ud835\udc34 in the user database. Finally DCP sends the user identifier id\ud835\udc34 , the list of public keys of websites in websites\ud835\udc34 , as well as \ud835\udc54\ud835\udc50 to the user. This allows the user to compute \ud835\udc58\ud835\udc34\ud835\udc36 = (\ud835\udc54\ud835\udc50 )\ud835\udc4e , and stores id\ud835\udc34 , sqn\ud835\udc34 , the list of webserverswebsites\ud835\udc34 and their public keys PK\ud835\udc34 , as well as \ud835\udc58\ud835\udc34\ud835\udc36 . Similarly as above, we use \ud835\udc58\ud835\udc34\ud835\udc36 as the encryption and MAC keys derived from a key derivation function."
        },
        {
            "heading": "4.3 Distress Signal Protocol",
            "text": "After the server and user enrolments are complete, the user can now indicate distress at will, including in the presence ofAloc. To do so the user must connect to one of the webservers they chose during enrolment. In the following the user connects to webserver \ud835\udc35 with corresponding encryption key \ud835\udc5d\ud835\udc58\ud835\udc35\u2032 , and the protocol is shown in Figure 4.\nThe user first computes tag\ud835\udc34 = MAC\ud835\udc58\ud835\udc34\ud835\udc36 (id\ud835\udc34, sqn\ud835\udc34) using the key shared with DCP, which requires includes the user identifier and sequence number obtained during user enrolment. Note that when a sequence number is used in the main protocol it is incremented by one, regardless of whether the protocol is later aborted.\nThe user proceeds to create a distress nonce using Encode, a function we will describe in detail in Section 5. In short, Encode hides the distress, along with id\ud835\udc34 and tag\ud835\udc34 within an \ud835\udc41 -bit distress nonce, using \ud835\udc5d\ud835\udc58\ud835\udc35\u2032 . The user initiates a TLS handshake with the webserver and sends the distress nonce as the client nonce in Client Hello, and proceeds to completing the handshake.\nUpon receiving a new TLS connection, the webserver unravels the client nonce to check if it has a structure that indicates a distress signal. This process is done by running the Decode algorithm, described in detail in Section 5. If Decode outputs not distress then the protocol terminates; otherwise, the webserver obtains id\ud835\udc34 and tag\ud835\udc34 as the output of Decode. Termination of the distress protocol does not affect the processing of the main TLS connection, so normal connections function as expected.\nIf a distress signal is identified, the webserver now encrypts id\ud835\udc34 and tag\ud835\udc34 with \ud835\udc58\ud835\udc35\ud835\udc36 , a shared key that was generated during\nserver enrolment, to obtain \ud835\udc50\ud835\udc35\ud835\udc36 . The webserver then sends their identity \ud835\udc35, the ciphertext \ud835\udc50\ud835\udc35 , a nonce nonce\ud835\udc35 , as well asMAC\ud835\udc58\ud835\udc35\ud835\udc36 (\ud835\udc35, \ud835\udc50\ud835\udc35\ud835\udc36 , nonce\ud835\udc35), signed using the shared key \ud835\udc58\ud835\udc35\ud835\udc36 .\nUpon receipt, DCP checks that \ud835\udc35 is indeed in the server database and finds the corresponding key \ud835\udc58\ud835\udc35\ud835\udc36 so that DCP can verify the MAC. DCP then proceeds to decrypt \ud835\udc50\ud835\udc35\ud835\udc36 with \ud835\udc58\ud835\udc35\ud835\udc36 to obtain id\ud835\udc34, tag\ud835\udc34 . Now, to verify tag\ud835\udc34 , DCPwould use the sequence number sqn\ud835\udc34 agreed in user enrolment to verify tag\ud835\udc34 . To do this, for a specified \ud835\udc5b\ud835\udc5a\ud835\udc4e\ud835\udc65 and for \ud835\udc56 = 0, . . . , \ud835\udc5b\ud835\udc5a\ud835\udc4e\ud835\udc65 , DCP computes VrfyMAC(tag, \ud835\udc58, (id, sqn+ \ud835\udc56)) until VrfyMAC outputs accepts. Otherwise, the protocol aborts. Note that \ud835\udc5b\ud835\udc5a\ud835\udc4e\ud835\udc65 is a parameter that the system designer can specify to allow for malicious or accidental errors in previous distress signals not being received by DCP. If the MAC verification is successful, DCP updates sqn to sqn\u2032+1where sqn\u2032 is the accepted sequence number.\nNow, DCP needs to inform the user that their distress has been received, which they do by sending a signed sequence number \ud835\udc60\ud835\udc34\ud835\udc36 = MAC\ud835\udc58\ud835\udc34\ud835\udc36 (sqn\ud835\udc34) to the user. DCP provides instructions to thewebserver on how to send \ud835\udc60\ud835\udc34\ud835\udc36 to the user, as specified in the user enrolment as part of info\ud835\udc34; this is done by encrypting instruction with \ud835\udc58\ud835\udc35\ud835\udc36 to obtain \ud835\udc50\ud835\udc36\ud835\udc35 = Enc\ud835\udc58\ud835\udc35\ud835\udc36 (instruction). DCP then sends the signed \ud835\udc50\ud835\udc36\ud835\udc35, \ud835\udc60\ud835\udc34\ud835\udc36 , nonce\ud835\udc35, nonce\ud835\udc36 to the webserver. After this, the agreed upon distress response may be initiated, as specified in info\ud835\udc34 .\nUpon receipt, the webserver decrypts \ud835\udc50\ud835\udc36\ud835\udc35 to obtain the necessary instructions and verifies MAC using the shared key \ud835\udc58\ud835\udc35\ud835\udc36 using nonce\ud835\udc35 to check that the message is fresh. After verification is successful, the webserver waits for a https request from the user, and sends \ud835\udc60\ud835\udc34\ud835\udc36 within the page content as specified in instruction. The user can then verify DCP\u2019sMAC. The specific techniques used to embed the response in the page content can be important if the user is under observation. We discuss ways to do this in practice in Section 9."
        },
        {
            "heading": "5 ALGORITHMS",
            "text": "In order for the user to hide the distress, we encode the distress into what looks like a TLS client nonce while still satisfying the security requirements of TLS. To do so, we construct a fixed-length reversible function with a specified \ud835\udc41 = 256, the size of the TLS client nonce in TLS 1.3. In addition to hiding the distress state, we are also embedding the user\u2019s identifier as well as MAC tag. The webserver, upon receiving a nonce in the TLS handshake, will have to decode what they have received.\nNote that should \ud835\udc41 vary (e.g. if using TLS 1.2), then the bit distributions of the plaintext may be altered accordingly (see Section 5.2). In addition, should \ud835\udc41 be larger, there may be extra information included (other than distress state, identifier, and tag) such as severity of distress, and further action requested from the user at that instance."
        },
        {
            "heading": "5.1 Encoding and Decoding Distress",
            "text": "The main idea of the encoding algorithm is to encrypt a 127-bit integer \ud835\udc5f with modified Elliptic Curve El Gamal (mECEG, discussed in Section 5.3), where \ud835\udc5f contains information about a distress state. If the user is indeed in distress, \ud835\udc5f would also include their identifier, as well as a MAC tag for integrity.\nAlgorithm 1 Encoding a distress in a 256-bit nonce 1: function Encode(id, tag, \ud835\udc5d\ud835\udc58) 2: return Enc\ud835\udc5d\ud835\udc58 (1\ud835\udc5a\ud835\udc51 | |id| |tag) 3: end function\nIn addition, fix\ud835\udc5a\ud835\udc51 ,\ud835\udc5a\ud835\udc56 ,\ud835\udc5a\ud835\udc61 such that\ud835\udc5a\ud835\udc51+\ud835\udc5a\ud835\udc56+\ud835\udc5a\ud835\udc61 = 127, with each choice discussed in Section 5.2. Let Enc be the mECEG encryption algorithm, and Encode, as described in Algorithm 1 describes how the user encodes their distress and identifier into a nonce.\nThe function Encode is used only when the user wishes to signal distress. It requires three inputs: the user\u2019s ID, a MAC tag, and the public key of the webserver. The function simply concatenates a string of 1s, the user ID, and the MAC tag. This 127-bit number is then encrypted using \ud835\udc5d\ud835\udc58 , the public key of the webserver, to produce a 256-bit distress nonce.\nAlgorithm 2 describes the function Decode, and how the webserver, upon receipt of the nonce, will be able to extract whether or\nAlgorithm 2 Decoding a nonce to obtain distress value 1: function Decode(nonce, \ud835\udc60\ud835\udc58) 2: \ud835\udc5f := Dec\ud835\udc60\ud835\udc58 (nonce) 3: if MSB\ud835\udc5a\ud835\udc51 (\ud835\udc5f ) == 1\ud835\udc5a\ud835\udc51 then 4: id := MSB\ud835\udc5a\ud835\udc56 (LSB127\u2212\ud835\udc5a\ud835\udc51 (\ud835\udc5f )) 5: tag := LSB\ud835\udc5a\ud835\udc61 (\ud835\udc5f ) 6: return true, id, tag 7: else 8: return not distress 9: end if 10: end function\nnot the user signals a distress; and when they do, also the user identifier and theMAC tag, the latter used for integrity and freshness to be verified by DCP.\nWe discuss our design choice. As mentioned in Section 4.3, if the user signals distress, Encodewill return a distress nonce, which the webserver will decrypt to obtain id and tag. Indeed, the webserver will have access to id. One may be tempted to encrypt id so that\nthe webserver has no access to this, however using Enc takes a lot of space. In addition, a malicious webserver also has access to the user\u2019s IP address, so having a the user identifier doesn\u2019t add much extra information if the goal of Aweb is to violate privacy.\nThe user constructs a MAC tag before inputting it into Encode, which is used to obtain integrity for DCP. This was added to solve two problems that a scheme without tag would have: (1) the webserver can send distress signals from arbitrary users by guessing id; (2) if the user has previously sent a distress signal, then the webserver is able to replay it and send valid distresses to DCP with the correct id, without the user\u2019s knowledge. Using tag which incorporates a sequence number solves these issues.\nAnother option to obtain integrity and freshness, other than using a MAC (and sequence number), is to use a timestamp and simply constructMAC\ud835\udc58\ud835\udc34\ud835\udc36 (time), with DCP checking MAC values of [time+\ud835\udc61, time\u2212\ud835\udc61] for some buffer period \ud835\udc61 . However this introduces time synchronisation as an additional requirement.\nLastly, we did not add an integrity check between the user and the webserver embedded within the client nonce. This is simply because TLS is integrity protected; that is, during the TLS connection between the user and webserver, if Aloc modifies the client nonce, then this will be detected by the client, as the user and webserver will not be able to compute the same handshake secret so the TLS handshake cannot be completed. As we mentioned before, this is an attack on availability that we do not consider.\nWe now proceed in constructing a fixed-length reversible function which utilises Encode and Decode.\nProposition 1. Let (\ud835\udc5d\ud835\udc58, \ud835\udc60\ud835\udc58) be a key pair for a public key encryption Enc. The following function\n\ud835\udc53\ud835\udc41 (\ud835\udc51, (id, tag), \ud835\udc5d\ud835\udc58) = { Encode(id, tag, \ud835\udc5d\ud835\udc58) if \ud835\udc51 = true PRG(\ud835\udc41 ) if \ud835\udc51 = false\nwhere PRG(\ud835\udc41 ) outputs a pseudorandom string of size \ud835\udc41 , is a fixedlength reversible function.\nProof. Let \ud835\udc54\ud835\udc41 (\ud835\udc66, \ud835\udc60\ud835\udc58) = Decode(\ud835\udc66, \ud835\udc60\ud835\udc58). Given how we choose Enc in Encode to have a fixed output size (see Section 5.3), then the first criteria is satisfied.\nLet \ud835\udc51 = false. Then \ud835\udc54\ud835\udc41 (\ud835\udc53\ud835\udc41 (\ud835\udc51, (id, tag), \ud835\udc5d\ud835\udc58), \ud835\udc60\ud835\udc58) = Dec\ud835\udc60\ud835\udc58 (\ud835\udc5f ) where \ud835\udc5f is an output of PRG(\ud835\udc41 ). Then Decode(\ud835\udc5f, \ud835\udc60\ud835\udc58) will output not distress for all \ud835\udc5f \u2032 = Dec\ud835\udc60\ud835\udc58 (\ud835\udc5f ) except for \ud835\udc5f \u2032 such that MSB\ud835\udc5a\ud835\udc51 (\ud835\udc5f \u2032) = 1, and the probability of that happening is 1/2\ud835\udc5a\ud835\udc51 as \ud835\udc5f is pseudorandom. Hence, if\ud835\udc5a\ud835\udc51 is large enough, then \ud835\udc51 is preserved except with negligible probability.\nNow consider the case when \ud835\udc51 = true. We have Encode(id, tag, \ud835\udc5d\ud835\udc58) = Enc\ud835\udc5d\ud835\udc58 (\ud835\udc5f ) where \ud835\udc5f = 1\ud835\udc5a\ud835\udc51 | |id| |tag. Now, given that (\ud835\udc5d\ud835\udc58, \ud835\udc60\ud835\udc58) is a public key encryption pair, then Dec\ud835\udc60\ud835\udc58 (Enc\ud835\udc5d\ud835\udc58 (\ud835\udc5f )) = \ud835\udc5f , except for negligible probability of decryption error. Now, as MSB\ud835\udc5a\ud835\udc51 (\ud835\udc5f ) = 1\ud835\udc5a\ud835\udc51 , Decode returns MSB\ud835\udc5a\ud835\udc56 (LSB127\u2212\ud835\udc5a\ud835\udc51 (\ud835\udc5f )) = id and LSB\ud835\udc5a\ud835\udc61 (\ud835\udc5f ) = tag by construction. That is, indeed, Decode(Encode(id, tag, \ud835\udc5d\ud835\udc58), \ud835\udc60\ud835\udc58) = true, id, tag. \u25a1\nNote that the webserver, upon receipt of a TLS handshake from any user, would decrypt the client nonce as part of Decode, regardless of whether or not the user is enrolled in the scheme. Due to our choice of (Gen, Enc,Dec), given the original security properties\nof a nonce, a false positive will happen with probability 12\ud835\udc5a\ud835\udc51 . If such a false positive occurs, the webserver will also obtain some id\u2032 and tag\u2032 and forwards them to DCP. That is, other than receiving a distress signal directly from a user, the webserver also has the function of filtering out false positives.\nUpon receipt of id\u2032, tag\u2032 from a user that did not signal distress, DCP will check this with the user database. The probability that the id is valid is \ud835\udc41\ud835\udc62\ud835\udc60\ud835\udc52\ud835\udc5f2\ud835\udc5a\ud835\udc56 , where \ud835\udc41\ud835\udc62\ud835\udc60\ud835\udc52\ud835\udc5f is the total number of enrolled users. If, already with probability 12\ud835\udc5a\ud835\udc51 \u00b7 \ud835\udc41\ud835\udc62\ud835\udc60\ud835\udc52\ud835\udc5f 2\ud835\udc5a\ud835\udc56 such id\n\u2032 is valid, then the probability that a valid tag\u2032 = MAC\ud835\udc58 (id\u2032, sqn) occurs is negligible."
        },
        {
            "heading": "5.2 Bit Distribution",
            "text": "The output of Encode needs to contain three different pieces of information: a marker that lets the webserver determine whether this is a valid distress signal or a normal nonce, an identifier, and a tag that authenticates the user to the DCP. In this section we discuss the best way to allocate the limited number of available bits to these three fields. We denote the length of the three fields as\ud835\udc5a\ud835\udc51 ,\ud835\udc5a\ud835\udc56 , and \ud835\udc5a\ud835\udc61 for number of bits for distress, identifier, and tag, respectively. This is visualised in Figure 5. Note that we have a limited number of space for\ud835\udc5a\ud835\udc51 ,\ud835\udc5a\ud835\udc56 , and\ud835\udc5a\ud835\udc61 given that\ud835\udc5a\ud835\udc51 +\ud835\udc5a\ud835\udc56 +\ud835\udc5a\ud835\udc61 = 127 in order to fit in to the size requirement of client nonce.\nThe webserver always runs Decode on every TLS connections initiated. When Decode is called on a received nonce which shows distress (i.e. MSB\ud835\udc5a\ud835\udc51 (\ud835\udc5f ) = 1\ud835\udc5a\ud835\udc51 ), there are three possibilities: (1) the user with corresponding id has signalled distress, (2) a false positive from a user enrolled in the system, (3) a false positive from a user not enrolled in the system.\nThe probability of a false positive happening, from any user, is 1/2\ud835\udc5a\ud835\udc51 . Hence, we want \ud835\udc5a\ud835\udc51 to be as large as possible as this would reduce the probability of false positives. Ideally,\ud835\udc5a\ud835\udc51 \u2265 17 so that less than 1 in 100,000 TLS connections would come up as false positives. For\ud835\udc5a\ud835\udc51 = 20, this goes up exponentially to 1 in 1,000,000.\nNow, we want\ud835\udc5a\ud835\udc56 to be large enough so that all users who want to enrol are able to, and that the scheme is more resistant to resource depletion attacks. In addition, with a larger\ud835\udc5a\ud835\udc56 , a malicious webserverAweb is less likely to be able to \u2018guess\u2019 arbitrary ids, though even though they succeed in guessing a valid id, the probability that they will pass the integrity verification through MAC\ud835\udc58\ud835\udc34\ud835\udc36 (id, sqn) should be negligible\u2014hence, lastly,\ud835\udc5a\ud835\udc61 indicates the size of the tag, and the larger\ud835\udc5a\ud835\udc61 is, the better MAC security obtained.\nThough we do not specify the exact size of\ud835\udc5a\ud835\udc51 ,\ud835\udc5a\ud835\udc56 , and\ud835\udc5a\ud835\udc61 , we illustrate the case for \ud835\udc5a\ud835\udc51 = 32. That is, the probability of the\nwebserver in receiving a false positive is 1/232, which, on average, means that the webserver receives one false positive in every 4,294,967,296 TLS connections. This leaves \ud835\udc5a\ud835\udc56 + \ud835\udc5a\ud835\udc61 = 95, so if \ud835\udc5a\ud835\udc56 = 32 and \ud835\udc5a\ud835\udc61 = 63, the user identifier gives space to over 4 billion users, and a MAC tag with output size of 63-bits."
        },
        {
            "heading": "5.3 Elliptic Curve El Gamal",
            "text": "A background of elliptic curves and elliptic curve El Gamal (ECEG) is laid out in Appendix A.\nTraditionally, a ciphertext is of the form (\ud835\udc43,\ud835\udc44) where \ud835\udc43 = (\ud835\udc4b\ud835\udc43 , \ud835\udc4c\ud835\udc43 ), \ud835\udc44 = (\ud835\udc4b\ud835\udc44 , \ud835\udc4c\ud835\udc44 ). Note that for an elliptic curve \ud835\udc4c 2 = \ud835\udc4b 3 +\ud835\udc34\ud835\udc4b + \ud835\udc35 over F\ud835\udc5e , then we use the modern approach of simply sending the \ud835\udc65-coordinate of \ud835\udc43 and \ud835\udc44 , as well as two additional bits \ud835\udc4f\ud835\udc43 and \ud835\udc4f\ud835\udc44 showing which square root of \ud835\udc4b 3 +\ud835\udc34\ud835\udc4b + \ud835\udc35 are the \ud835\udc66-coordinates of \ud835\udc43 and \ud835\udc44 respectively. This is an inexpensive computation by the receiver, and allows us to save space [32]. We use this approach, which we refer to as modified El-Gamal encryption (mECEG) in throughout this paper.\nUnfortunately, the ciphertexts produced from mECEG are not indistinguishable from random. Indeed, because ciphertexts are elliptic curve points, they follow some structure that allows an adversary to come up with a strategy when trying to see if a ciphertext is an output of an mECEG encryption, instead of chosen uniformly from random. There are several attacks that an adversary can do, as discussed in [8], but the most severe one is simply checking whether \ud835\udc4b 3 +\ud835\udc34\ud835\udc4b + \ud835\udc35 is a quadratic residue in the field, which the adversary may succeed with probability 12 . We show later, that even with this extra information, the adversary will not be able to distinguish a distribution which contains a distress signal against the uniform distribution.\nWe chose mECEG instead of other encryption schemes as it satisfies the two main conditions: a ciphertext size as a function of the plaintext size, as well as its semantic security, so that TLS security is maintained. Other encryption schemes, for example IND$-CPA encryption schemes would have a better property: their ciphertexts are indistinguishable from random. However, IND$CPA schemes are not practical in this sense: the ciphertexts are too long to fit into the 256-bit space (without compromising on security), and the decryption takes 128 exponentiations, which hinders scalability as webservers will unlikely wish to have such overhead."
        },
        {
            "heading": "6 COMPUTATIONAL OVERHEAD",
            "text": "As the participation of webservers is necessary for the scheme to function, it is important that our design does not generate a large amount of overhead in computation and communication for the website.\nShould a webserver participate in our scheme, whenever a TLS connection is requested, the webserver is required to, in parallel to completing the TLS handshake, decode the client nonce received during Client Hello. Note that for the webserver, a TLS handshake already contains two expensive operations: the calculation for the early shared secret key by multiplication of elliptic curve points, and signing a hash using the certificate\u2019s public key for authentication. Our protocol adds an additional computational overhead of one elliptic curve multiplication during decryption. The additional\ncalculation of two \ud835\udc66-coordinates of the ciphertext elliptic curve points are inexpensive [32].\nAfter decryption is completed, the webserver checks whether the plaintext indicates a distress, through a bitwise AND operation, which is computationally cheap. Should the plaintext reveal a distress, the webserver proceeds to encrypt the user ID and tag and compute a MAC, with symmetric keys obtained during enrolment. After DCP verifies that the distress signal is from a valid user, then the webserver verifies a MAC and decrypts the message from DCP again symmetrically. These operations are not computationally expensive. That is, design choices we made have been to minimise this overhead to one extra elliptic curve multiplication operation, and an increase in distress received only affects overhead linearly.\nWe have previously argued that the number of false positives received by the webserver is low for \ud835\udc5a\ud835\udc51 = 32. To illustrate this, consider Google search, which is the most visited website in the world by traffic [39]. Google on average receives over 40,000 search queries per second [25], or over 3.5 billion per day. Although there is no official data on how many servers are in Google data centres (a 2016 estimate is 2.5 million servers [13]), if 100,000 servers are dedicated to Google Search and assuming that the TLS connections are distributed evenly across all servers, this means that for each server, a distress false positive happens once every 34 years. Even in the worst-case-scenario where all the connections go to a single server, on average, a distress false positive will happen every 29.83 hours."
        },
        {
            "heading": "7 SECURITY ANALYSIS",
            "text": "We assume the following:\nA1 The certificate authority issuing certificates of each protocol party is honest. A2 The signature scheme used by each protocol party is secure; that is, the probability of successfully forging a signature without access to the secret key is negligible. A3 The MAC used by each protocol party is secure. A4 The probability that an honest party picks the same nonce\ntwice is negligible."
        },
        {
            "heading": "7.1 Server and User Enrolments",
            "text": "We note down the functional and security guarantees from the server and user enrolments below.\nGuarantee 1 (Server Authenticity). The server enrolment protocol will only complete successfully, if the webserver is able to produce a valid signature corresponding to its certificate (real world identity).\nProof. If an adversary wants to claim that they are the webserver \ud835\udc35, they have to successfully send \ud835\udc65 , \ud835\udc35, Cert\ud835\udc35, \ud835\udc5d\ud835\udc58\ud835\udc35\u2032 , Sign\ud835\udc35 (\ud835\udc65, \ud835\udc35, \ud835\udc5d\ud835\udc58\ud835\udc35\u2032 ). To replay the message, they need to have previously captured Sign\ud835\udc35 (\ud835\udc65, \ud835\udc35, \ud835\udc5d\ud835\udc58\ud835\udc35\u2032 ) from another enrollment, but each enrollment is done in its own TLS session so this message is not available to the attacker. To craft the message, the attacker has to produce Sign\ud835\udc35 (\ud835\udc65, \ud835\udc35, \ud835\udc5d\ud835\udc58\ud835\udc35\u2032 ) using a private key associated with Cert\ud835\udc35 . Given our Certificate Authority is a trusted entity (A1) and the underlying signature scheme is secure (A2) this is not possible. \u25a1\nFunctionality-wise, the above guarantee means that DCP can be convinced that the identity calimed by the webserver indeed belongs to the webserver.\nGuarantee 2 (Server Shared Key). If the server enrolment protocol is completed successfully, then the webserver obtains a symmetric key that is known only to the webserver and DCP.\nProof. Firstly, DCP is authenticated during the TLS handshake, and the webserver is authenticated by Guarantee 1. Both \ud835\udc54\ud835\udc4f and \ud835\udc54\ud835\udc50 are sent within the same TLS session, so confidentiality and integrity follows. \u25a1\nGuarantee 3 (DCP Authentication). If the user enrolment protocol is completed successfully, then the user can be certain that they have been speaking to DCP.\nProof. DCP acts as the TLS server in the TLS connection, and is thus authenticated during the TLS handshake. \u25a1\nGuarantee 4 (User Shared Key and Registration). If the user enrolment protocol is completed successfully, then the user is registered and the user obtains a symmetric key and sequence number that is known only to the user and DCP.\nProof. The user has a TLS session with DCP by Guarantee 1. Both \ud835\udc54\ud835\udc4f and \ud835\udc54\ud835\udc50 are sent within the TLS session, so confidentiality and integrity of the key follows. \u25a1"
        },
        {
            "heading": "7.2 Main Protocol",
            "text": "We show the security guarantees from our main protocol, when the user signals distress. A crucial security property we want is captured in the following theorem.\nProposition 2. Let \u03a0 = (Gen, Enc,Dec) be modified Elliptic Curve El Gamal encryption scheme used by the function Encode. If \ud835\udc43\ud835\udc45\ud835\udc3a is a secure pseudorandom number generator then the following fixed-length reversible function\n\ud835\udc53\ud835\udc41 (\ud835\udc51, (id, tag), \ud835\udc5d\ud835\udc58) = { Encode(id, tag, \ud835\udc5d\ud835\udc58) if \ud835\udc51 = true PRG(\ud835\udc41 ) if \ud835\udc51 = false\nwith \ud835\udc54\ud835\udc41 (\ud835\udc5f, \ud835\udc60\ud835\udc58) = Decode(\ud835\udc5f, sk) is IndDistress secure.\nProof. The strategy of this proof is simple: statistically close distributions are polynomially indistinguishable [20]. Let \ud835\udc37\ud835\udc4f be the distribution of nonces formed when bit \ud835\udc4f is chosen, i.e. if \ud835\udc4f = 0 then \ud835\udc37\ud835\udc4f is simply the uniform distribution, and when \ud835\udc4f = 1 then there exists precisely one distress signal in \ud835\udc371. Let \ud835\udc48 be the uniform distribution (so the range of \ud835\udc370 and \ud835\udc371 are\ud835\udc48 ) and\ud835\udc49 be the distribution of elliptic curve points. The statistical distance between \ud835\udc370 = {\ud835\udc4b1, \ud835\udc4b2, . . .} and \ud835\udc371 = {\ud835\udc4c1, \ud835\udc4c2, . . .} is:\n\u0394(\ud835\udc370, \ud835\udc371) = \u2211\ufe01 \ud835\udc62 | Pr(\ud835\udc4b\ud835\udc56 = \ud835\udc62) \u2212 Pr(\ud835\udc4c\ud835\udc56 = \ud835\udc62) |\nNow, for all \ud835\udc62 \u2208 \ud835\udc48 except for one distress point \ud835\udc51 , Pr(\ud835\udc4b\ud835\udc56 = \ud835\udc62) = Pr(\ud835\udc4c\ud835\udc56 = \ud835\udc62). Also note that the number of possible outputs of El\nGamal is 2 \ud835\udc41\n4 as there exists two \ud835\udc4b -values in the ciphertexts, each lying on the curve with probability 12 . Hence,\n\u0394(\ud835\udc370, \ud835\udc371) = | Pr(\ud835\udc4b\ud835\udc56 = \ud835\udc51) \u2212 Pr(\ud835\udc4c\ud835\udc56 = \ud835\udc51) | = 1 2\ud835\udc41 \u2212 1 \ud835\udc5b \u00b7 4 2\ud835\udc41 = \ud835\udc5b \u2212 4 \ud835\udc5b \u00b7 2\ud835\udc41 ,\nwhich is negligible. \u25a1\nTo demonstrate that this is the case, a possible adversary strategy that uses elliptic curve structure is provided in Appendix B.\nGuarantee 5. If the main protocol is completed successfully, then for DCP, it is guaranteed that the message from the webserver is fresh and indeed comes from an enrolled webserver.\nProof. To break the guarantee, an adversary needs to send \ud835\udc35, \ud835\udc50\ud835\udc35, nonce\ud835\udc35,MAC\ud835\udc58\ud835\udc35\ud835\udc36 (\ud835\udc35, \ud835\udc50\ud835\udc35, nonce\ud835\udc35) for an enrolled webserver \ud835\udc35. The adversary has to send a valid MAC signed using \ud835\udc58\ud835\udc35\ud835\udc36 , a shared secret key between the webserver and DCP. This key is known only to the webserver and DCP, by Guarantee 2, and in particular the adversary doesn\u2019t have access to it. The adversary has two options in sending MAC\ud835\udc58\ud835\udc35\ud835\udc36 (\ud835\udc35, \ud835\udc50\ud835\udc35): by forgery or replay. Forgery is impossible by Assumption (A3). If the adversary replays a message, \ud835\udc50\ud835\udc35 would be used twice, but \ud835\udc50\ud835\udc35 contains the sequence number so it cannot be reused. \u25a1\nGuarantee 6. If the main protocol is completed successfully, it is guaranteed that the reply from DCP is a response to the recent communication from the webserver, and indeed comes from DCP.\nProof. Firstly, assume that the DCP has never received the request from the webserver. That means that the DCP does not have access to nonce\ud835\udc35 , and hence they will be unable to construct MAC\ud835\udc58\ud835\udc35\ud835\udc36 (..., nonce\ud835\udc35, ...) and theMAC verification by the webserver will fail.\nNow for an adversary to claim to the webserver that they are DCP, they need to send \ud835\udc5a1,\ud835\udc5a2, nonce\ud835\udc36 ,MAC\ud835\udc58\ud835\udc35\ud835\udc36 (\ud835\udc5a1,\ud835\udc5a2, nonce\ud835\udc35, nonce\ud835\udc36 ) successfully for an arbitrary\ud835\udc5a1,\ud835\udc5a2, nonce\ud835\udc36 . The adversary can do this by creating their own message or replaying a previously captured one. By Guarantee 2, only the webserver and DCP know the key \ud835\udc58\ud835\udc35\ud835\udc36 , so the adversary can only successfully forge the MAC with negligible probability by Assumption (A3). To replay the message from DCP the adversary would have to capture a previous message using the same \ud835\udc5b\ud835\udc5c\ud835\udc5b\ud835\udc50\ud835\udc52\ud835\udc35 , however by Assumption (A4) this happens only with negligible probability.\n\u25a1\nGuarantee 7. If DCP receives a valid id\ud835\udc34 and a valid tag\ud835\udc34 , then it is guaranteed that the user with corresponding id\ud835\udc34 has recently signalled distress.\nProof. By Guarantees 5 and 6 we know that the webserver and DCP are indeed speaking to one another, so an adversary cannot be of the formAnet orAloc. Hence, an adversary has to beAweb.\nFor Aweb to break this guarantee, they have to send \ud835\udc35, \ud835\udc50\ud835\udc35 , nonce\ud835\udc35 ,MAC\ud835\udc58\ud835\udc35\ud835\udc36 (\ud835\udc35, \ud835\udc50\ud835\udc35, nonce\ud835\udc35) successfully without the user ever signalling distress, or by replaying a previous distress signal sent by the user.\nWe consider the first case. For any nonce\ud835\udc34 that the adversary receives from the user, Decode(nonce\ud835\udc34, \ud835\udc60\ud835\udc58\ud835\udc35) will output\nnot distress (except with negligible probability) and in particular, the adversary does not have access to id\ud835\udc34 . Hence, the adversary will need to guess id \u2190\ud835\udc45 {0, 1}\ud835\udc5a\ud835\udc56 and sends through \ud835\udc35, \ud835\udc50\ud835\udc35, nonce\ud835\udc35,MAC\ud835\udc58\ud835\udc35\ud835\udc36 (\ud835\udc35, \ud835\udc50\ud835\udc35, nonce\ud835\udc35) with \ud835\udc50\ud835\udc35 = Enc\ud835\udc58\ud835\udc35\ud835\udc36 (id, tag\ud835\udc34). Upon verification, Aweb passes the identity verification since \ud835\udc35 is in the server database, and \ud835\udc35 has correctly signed a MAC with the shared key. However, DCP upon obtaining id from decrypting \ud835\udc50\ud835\udc35 , will only pass the verification with probability \ud835\udc41\ud835\udc62\ud835\udc60\ud835\udc52\ud835\udc5f2\ud835\udc5a\ud835\udc56 where \ud835\udc41\ud835\udc62\ud835\udc60\ud835\udc52\ud835\udc5f is the total number of users registered in the scheme. In addition, Aweb needs to forge tag\ud835\udc34 = MAC\ud835\udc58\ud835\udc34\ud835\udc36 (id, sqn\ud835\udc34), which succeeds with negligible probability according to Assumption (A4).\nWe now consider the second case, where the user has signalled distress in the past. In this case,Aweb will receive id\ud835\udc34, tag\ud835\udc34 and as above, sends this in encrypted form to DCP. Now, DCPwill receive a valid id\ud835\udc34 , butAweb has to pass theMAC verification: that is,Aweb needs to send tag\ud835\udc34 = MAC\ud835\udc58\ud835\udc34\ud835\udc36 (id\ud835\udc34, sqn\ud835\udc34) successfully. According to Guarantee 4, both\ud835\udc58\ud835\udc34\ud835\udc36 and sqn\ud835\udc34 are shared only between the user and DCP. Aweb can try to forge a MAC without the \ud835\udc58\ud835\udc34\ud835\udc36 , which is impossible except with negligible probability (Assumption (A4)), or replay a previously sent tag\ud835\udc34 . However, this requires the user to send the same sqn\ud835\udc34 more than once, which is not possible by design. \u25a1\nWe proceed to the main guarantee for the user:\nGuarantee 8. If the user signals distress and the protocol completes successfully, then the user is certain that DCP has recently received the distress.\nProof. For the adversary to convince the user that DCP has received the distress, the adversary needs to send MAC\ud835\udc58\ud835\udc34\ud835\udc36 (sqn\ud835\udc34) to the user and pass the verification. Firstly, given that the this communication happens through a TLS session, it is secure against Anet and Aloc. Hence, an adversary has to be Aweb.\nTo send a correct \ud835\udc60\ud835\udc34\ud835\udc36 = MAC\ud835\udc58\ud835\udc34\ud835\udc36 (sqn\ud835\udc34), Aweb can do this in two ways: forge the MAC or replay a previous message. By Guarantee 4 the key \ud835\udc58\ud835\udc34\ud835\udc36 is known only to the user and DCP, so any attempt at forgingMAC\ud835\udc58\ud835\udc34\ud835\udc36 (sqn\ud835\udc34) will only succeed with negligible probability according to Assumption (A3). To replay a previous message MAC\ud835\udc58\ud835\udc34\ud835\udc36 (sqn\ud835\udc34) will fail on the user\u2019s verification, as sqn will be outdated.\nWe conclude that the message MAC\ud835\udc58\ud835\udc34\ud835\udc36 (sqn\ud835\udc34) has been sent by DCP is fresh and without alteration from Aweb. DCP, being an honest party, sends this message only after receiving a valid connection from the webserver; by Guarantee 7, the user has indeed recently signalled distress. \u25a1\nNote that there are a few situations in whichAweb are able to act maliciously within our system. FirstlyAweb in receipt of a distress signal from the user, may not forward that signal to DCP; however Aweb does this, the user will not receive the correct feedback, and using Guarantee 8, the user knows that the distress signal is never received by DCP. Secondly, if the user sends a distress signal which is forwarded fromAweb to DCP, after DCP\u2019s receipt of the distress Aweb may not send the confirmation message to the user, which may lead to the user believing that the distress has never been received by DCP. These are attacks on availability and are not solvable by any protocol, and therefore out of scope. In practice, if\nthe user does not receive a confirmation from a particular website, they can simply try signalling distress to another webserver."
        },
        {
            "heading": "8 RELATEDWORK",
            "text": "This section reviews related work. We focus on three separate topics: related adversary models, work dedicated to designing a method for a distress signal to be sent, and lastly, undetectable communications.\nAdversary Models. Our adversary model is related to those discussed under endpoint compromise, which the adversary would be considered to have full access to device secrets. This is indeed the model described under insider threat [15, 17] for an adversary who has legitimate, full access to a device and wishes to exfiltrate data through a monitored network, usually a covert channel. In [47] the authors considers an adversary who has full access to the network and messaging server, and is able to periodically compromise a device but does not consider the case should the adversary is aware that the user knows, and acts on, the compromise (trivially through removing the adversary\u2019s access).\nGiven how our adversary model describes a high degree of control of the network, this might seem similar to a censorship resistance system (well reviewed in [27, 44]), where a user wishes to exchange communication with a receiver through a communication channel controlled by a censor who actively attempts to prevent this communication. Censors may have a set of distinguishers which takes in network traffic to be analysed and outputs \u2018accepted\u2019 traffic flows. This is similar to our scenario where the adversary wishes to distinguish a distress communication from a normal communication on the network, as we assume communications may take place. However, in our case, the adversary has the additional capability due to their locality to the user.\nDistress Signalling. Coercion attack, sometimes called by the term rubberhose cryptanalysis is a physical attack to bypass security, usually authentication, by physically forcing the user to reveal their secrets. A practical solution to a coercion attack is the use of a second authentication secret as part of a covert mechanism, which would alert distress during an authentication process ([10, 14, 21, 43, 48] and in commercial products [1]). Though these schemes allow the adversary to have physical and logical access to the devices, the adversary does not have access to the network and only has access to the private information if authentication is granted.\nUndetectable Communications. The initial study of undetectable communications was encapsulated in the prisoner\u2019s problem [42], which describes two prisoners trying to communicate to each other through a warden, who is able to modify the messages and allow exchange of messages only if they look innocuous.\nThe scenario of an insider threat wanting to covertly send information as well as someone circumventing censorship are usually achieved by a scheme which ensures stealth. There are numerous ways in which this can be done, through steganographic methods or covert channels [3, 23, 28, 29, 31].\nThe notion of undetectable communication specifically for the case of Online Social Networks (OSNs) was explored in [6], where\nformal definitions are introduced. In [7], the authors proposed a system to allow users to exchange data over existing web-based sharing platformwhilemaintaining confidentiality, as well as hiding from a casual observer that the exchange is taking place.\nFor steganographic or censorship resistance purposes, there are several work looking into encryption functions that have pseudorandom ciphertexts, both in the private-key setting [22] and public-key setting [45]. In [8], building on [33], the authors proposed a method to encode elliptic curve points indistinguishable from uniform random strings, which would assist elliptic curve cryptography to be suitable as a censorship circumvention tool. Unfortunately, these constructions have the downside of having extremely long ciphertexts. The constructions in [33, 46] also produces pseudorandom ciphertexts, while aiming for space efficiency. Our approach is similar to that in [19, 26], where both papers proposed methods of embedding information in the TLS client nonce. The former was proposed to embed an Escrow Agency Field (EAF) in protocol fields, with the key difference with our scheme is that encryption happens at every communication, not only during specific instances hence why their security reduces directly to semantic security of ECEG. In the latter, the client assumes a symmetric shared key with the decoy router as opposed to using public keys."
        },
        {
            "heading": "9 DISCUSSION",
            "text": "In this section we discuss a few topics with additional points we wish to clarify."
        },
        {
            "heading": "9.1 Enrolment",
            "text": "To make use of our proposed scheme, a user is required to enrol when the adversary is not present. This is important to allow the main distress signal protocol to be initiated within a single action and for the security guarantees be met. We stress that our scheme is not suitable for situations where enrolment is not possible.\nActs of abuse are often difficult to recognise, and our scheme is only appropriate to be set up in cases where the user has recognised that they are in a vulnerable position and are able to prepare should they decide to seek help. Unfortunately, in many cases domestic abuse survivors unable to leave their abuser, or return to the abuser after an initial offence [37, 38].\nWe emphasise that we do not intend to minimise the difficulty of helping domestic abuse survivors. Our proposal can fit into a set of solutions that are currently available\u2014from practical advice in managing personal devices and communications [2, 24], to the support given by organisations supporting survivors of domestic abuse, and can be a valuable building block for future work.\nThis enrolment procedure is similar to those used in practice for other related schemes, for example Path Community [11] were created for individuals to walk home safely, where one might add emergency contact numbers or guardians when they set up the application. When enrolling in this scheme, some personal information may be included so the backend can act appropriately, for example by contacting an emergency contact or forwarding the case to the relevant authority.\nIn other situations, for example journalists or activists travelling through a hostile nation, preparations can easily be made to face a situation where a distress signal may be required. In this\ncase, the employer or organisation of the individual can set up an architecture where they are the DCP. The response to a distress by the individual may include contacting the relevant embassy including the necessary personal details, including location. Our scheme does not specify the particular user information required for enrolment, nor the response from the backend, as it is incredibly context-specific and we do not wish to narrow down these many possibilities of implementation."
        },
        {
            "heading": "9.2 User Interface",
            "text": "Our scheme specifies what happens in the background when distress is initiated by the user\u2019s device, but we have not specified the user\u2019s interactions with the device when initiating the distress signal, or in the verification of response from the DCP through the webserver.\nFirstly, the enrolment phase includes an installation of the distress system on the user\u2019s device. When the adversary is present and the user wishes to initiate the signal, some action is required from the user to do so.\nThere are plenty of ways in which such action can be done stealthily, and there are plenty of existing techniques which can be implemented. For example, the user can initiate it by pressing a specific keyboard shortcut as they enter the website address (see, for example, [12]), or entering a duress password if the interface is designed in a way that doesn\u2019t reveal any information about what\u2019s being entered, or pressing a hidden icon on the browser. Note that an action has to be designed to be done before the user enters the website as the distress is sent during the TLS handshake, and not the session. There are many considerations a system designer may consider within this UI challenge, including stealth and usability, while reducing false positives through accidental inputs. At the same time, this action needs to be simple and easy to remember for the user who might be in a state of duress when sending the distress signal. This is an interesting challenge and a considerably important one, whichwe consider as futurework on the deployment of this architecture, while noting that this design is entirely contextdependent.\nIn our protocol, the user verifies the response \ud835\udc60\ud835\udc34\ud835\udc36 to confirm that DCP has indeed received the user\u2019s distress signal. The \ud835\udc60\ud835\udc34\ud835\udc36 is sent through the TLS connection from the webserver as part of the TLS session\u2014that is, within the page content. The instruction for how best to embed the confirmation in a page can be selected by the user at enrolment and communicated to the webserver by DCP when a distress signal is received. To not limit the possibilities of implementation, we have intentionally not specified how, but we give several options below.\nWith a traditional adversary model, something as simple as including \ud835\udc60\ud835\udc34\ud835\udc36 as a HTTP-header that a plugin can verify would work. However, with Aloc this may be problematic if the user is under strict surveillance, as such a header (or any other overt confirmation) would be visible to the adversary\u2014this would defeat the user\u2019s goal of stealthiness. Instead, a solution could be that the confirmation is embedded as a specific content that will be unnoticed by the adversary.\nAn ideal embedding would be one that gives the user positive confirmation that the distress signal has been received, and at the\nsame time allows for \ud835\udc60\ud835\udc34\ud835\udc36 to be extracted by a plugin (or the browser) to be verified cryptographically. Any image generated from a seed (e.g., randomart [5]), can be easily verified, but whether that would appear \u201cnormal\u201d on a website, is very context dependent. For websites that commonly include advertisements, it may be possible to display selected advertisements as confirmation, where the visual details (or indeed the text) encode the exact value of \ud835\udc60\ud835\udc34\ud835\udc36 . If a website commonly includes dynamic content like video, a response that includes moving images or sound, are options. Particularly with video, there is the opportunity to include other measurable, nonvisible parameters such as time delay and use timing-based covert channel techniques. We refer to existing research on undetectable communication [6, 7], for additional examples.\nIn short, the response sent between the webserver and the user needs to be: (1) invisible to the adversary on the TLS connection, e.g., it is important that \ud835\udc60\ud835\udc34\ud835\udc36 is not being sent on its own, but is embedded within a page content so the existence of \ud835\udc60\ud835\udc34\ud835\udc36 is obfuscated, (2) verifiable by the user\u2019s device, (3) visually verifiable by the user, and (4) unnoticeable to the adversary who has visual access of the device. These are important design choices that need to be made when the architecture is deployed, and decisions are to be made dependent on the context and situation of the user as well as the webserver\u2019s purpose and design. We note that there is no one-size fits all solution that covers all of the possible use-cases of this architecture."
        },
        {
            "heading": "10 CONCLUSION",
            "text": "We introduced a new adversary model Aloc, who not only has visual access to the user\u2019s screen, but full control over all of the user\u2019s communication channels as well as the application layer content of the TLS. This includes scenarios including a domestic abuser, a compromised journalist, or unlawful arrest and search. We introduced distress signalling as a goal for a user to perform against such adversaries. We formalised the adversary\u2019s abilities in the form of a security game, and the adversary\u2019s goal is to detect a distress signal within a set of normal communications.\nTo fulfil the user\u2019s goal, we constructed an architecture where the user can signal distress using webservers as an intermediary. To do so, the distress is embedded along with additional information as the client nonce in the TLS handshake between the user and the webserver; we specified this in our encode function, which uses the Elliptic Curve El Gamal public key encryption scheme. Upon receipt, the webserver decodes the distress and forwards the extra information to the backend so that appropriate action can be taken.\nUsing TLS as well as public key encryption allows for better scalability as well as stealth, and the protocol can coexist with normal uses of TLS. For the webserver, the decoding function only contributes to computational overhead equivalent to one exponentiation per TLS request, and a false positive happens very rarely, so there is very little overhead in terms of communication. When false positives on the webserver\u2019s side happen and forwarded to the backend, the backend will perform further integrity checks, so that actual false positives happen only with negligible probability.\nWe performed a full security analysis of our architecture, including proving distress indistinguishability of our scheme. Lastly, we\ndiscussed further practical considerations that a full scale deployment needs to address."
        },
        {
            "heading": "A BACKGROUND ON ELLIPTIC CURVES",
            "text": "The notation in this section is standard, and further details can be found on [41].\nLet F\ud835\udc5e be a finite field of size \ud835\udc5e, with \ud835\udc5e a large prime power. An elliptic curve E over F\ud835\udc5e can be written in the form E\ud835\udc34,\ud835\udc35 = \ud835\udc662 + \ud835\udc653 +\ud835\udc34\ud835\udc65 + \ud835\udc35, with \ud835\udc34, \ud835\udc35 \u2208 F\ud835\udc5e , with \ud835\udc352 \u2212 4\ud835\udc34\ud835\udc36 \u2260 0 and the point at infinity o = [0 : 1 : 0].\nWe denote E(F\ud835\udc5e) the set of F\ud835\udc5e-rational points of E, that is, for E = E\ud835\udc34,\ud835\udc35 ,\nE(F\ud835\udc5e) = {(\ud835\udc65,\ud835\udc66) |\ud835\udc662 = \ud835\udc653 +\ud835\udc34\ud835\udc65 + \ud835\udc35} \u222a {o}.\nAn important theorem concerning the number of points of an elliptic curve is the following.\nTheorem A.1 (Hasse). Let E be an elliptic curve defined over \ud835\udc5e. Then\n|#E(F\ud835\udc5e) \u2212 \ud835\udc5e \u2212 1| \u2264 2 \u221a \ud835\udc5e.\nNote that if \ud835\udc652 = \ud835\udc4e in F\ud835\udc5e , then (\u2212\ud835\udc65)2 = \ud835\udc4e. Combined with Hasse\u2019s theorem, the probability that an \ud835\udc65 \u2208 F\ud835\udc5e lies on E is in fact approximately 12 .\nA.1 Elliptic Curve El Gamal We describe the Elliptic Curve El Gamal (ECEG) public key encryption. The public parameters are:\n(1) a finite field F\ud835\udc5e and elliptic curve E : \ud835\udc662 = \ud835\udc653+\ud835\udc34\ud835\udc65 +\ud835\udc35 defined over F\ud835\udc5e .\n(2) A point \ud835\udc43 \u2208 E(F\ud835\udc5e). The receiver chooses \ud835\udc4e \u2208 F\ud835\udc5e as their secret key and publishes \ud835\udc4e\ud835\udc43 . For a sender to send a message\ud835\udc40 to the receiver, they do the following:\n(1) choose \ud835\udc58 \u2208 F\ud835\udc5e and compute \ud835\udc58 (\ud835\udc4e\ud835\udc43). (2) Compute \ud835\udc44 = \ud835\udc58\ud835\udc43 and \ud835\udc45 = \ud835\udc40 + \ud835\udc58 (\ud835\udc4e\ud835\udc43). (3) Send (\ud835\udc58\ud835\udc43, \ud835\udc45) to the receiver.\nUpon receipt, the receiver simply computer \ud835\udc40 = \ud835\udc45 \u2212 \ud835\udc4e(\ud835\udc58\ud835\udc43). Correctness is immediate. In addition, ECEG is CPA-secure under the elliptic curve decisional Diffie-Hellman assumption.\nIn its original form, ECEG has a 1:2 expansion of plaintext to ciphertext [32]. However, to save space, the sender instead of sending \ud835\udc44 = (\ud835\udc65\ud835\udc44 , \ud835\udc66\ud835\udc44 ) and \ud835\udc45 = (\ud835\udc65\ud835\udc45, \ud835\udc66\ud835\udc45) can simply send (\ud835\udc65\ud835\udc44 , \ud835\udc4f\ud835\udc44 ) and (\ud835\udc65\ud835\udc45, \ud835\udc4f\ud835\udc45), where \ud835\udc4f\ud835\udc56 are binary values denoting which square root the \ud835\udc66\ud835\udc56 is, to save space. This also eliminates an adversary\u2019s strategy of spotting distress signals by checking if, given (\ud835\udc4b\ud835\udc43 , \ud835\udc4c\ud835\udc43 ) whether \ud835\udc4c 2 \ud835\udc43 = \ud835\udc4b 3 \ud835\udc43 + \ud835\udc34\ud835\udc4b\ud835\udc43 + \ud835\udc35 and if so, then with very high probability a distress has been sent."
        },
        {
            "heading": "B DEMONSTRATING ADVERSARY ADVANTAGE",
            "text": "Consider the adversary A with the following strategy. Given a distribution of nonces \ud835\udc5f1, . . . \ud835\udc5f\ud835\udc5b :\n(1) for each \ud835\udc5f\ud835\udc56 , check if \ud835\udc5f\ud835\udc56 has the ciphertext structure. (2) If there exists a nonce that follows the ciphertext structure,\nthen flip a coin. (3) If there are no nonces that follow the ciphertext structure,\nthen output \ud835\udc4f\u2032 = 0.\nProposition 3. Let A be an adversary described above. Then AdvIndDistress,\ud835\udc53\ud835\udc41A (\ud835\udc5b) is negligible.\nProof. We consider an adversary A that uses knowledge of the elliptic curve structure to distinguish between whether or not a distribution of nonces contain a distress call. The adversary\u2019s distinguishing advantage is:\nAdvIndDistress,\ud835\udc53\ud835\udc41A = | Pr(\ud835\udc4f \u2032 = 1|\ud835\udc4f = 1) \u2212 Pr(\ud835\udc4f\u2032 = 1|\ud835\udc4f = 0) |.\nLet \ud835\udc37\ud835\udc4f be the distribution of nonces that the adversary receives; that is, when \ud835\udc4f = 1 there exists a distress signal in the distribution. Let \ud835\udc5f1, . . . , \ud835\udc5f\ud835\udc5b be the nonces that the adversary receives. Write \ud835\udc5f\ud835\udc56 = \ud835\udc4b\ud835\udc56,1 | |\ud835\udc4f\ud835\udc56,1 | |\ud835\udc4b\ud835\udc56,2 | |\ud835\udc4f\ud835\udc56,2, where\ud835\udc4b\ud835\udc56, \ud835\udc57 is 127 bits long and\ud835\udc4f\ud835\udc56, \ud835\udc57 are single bits. Now, if \ud835\udc5f\ud835\udc56 is an output of mECEG, then \ud835\udc4b\ud835\udc56, \ud835\udc57 would be on the curve E\ud835\udc34,\ud835\udc35 : \ud835\udc4c 2\ud835\udc56, \ud835\udc57 = \ud835\udc4b 3 \ud835\udc56, \ud835\udc57 +\ud835\udc34\ud835\udc4b\ud835\udc56, \ud835\udc57 + \ud835\udc35 for some \ud835\udc4c\ud835\udc56, \ud835\udc57 . That is, \ud835\udc4b 3\ud835\udc56, \ud835\udc57 +\ud835\udc34\ud835\udc4b\ud835\udc56, \ud835\udc57 + \ud835\udc35 is a quadratic residue. From Hasse\u2019s theorem, this has probability approximately 1/2.\nFor a nonce \ud835\udc5f\ud835\udc56 , let \ud835\udc52\ud835\udc50 (\ud835\udc5f\ud835\udc56 ) \u2208 {0, 1} denote whether \ud835\udc5f\ud835\udc56 has the structure of an mECEG ciphertext, that is, \ud835\udc52\ud835\udc50 (\ud835\udc5f\ud835\udc56 ) = 1 if and only if both \ud835\udc4b\ud835\udc56,1 and \ud835\udc4b\ud835\udc56,2 lie on the curve E\ud835\udc34,\ud835\udc35 .\nNow, when the adversary receives\ud835\udc371, the distribution may come from either \ud835\udc371 or \ud835\udc370, so Pr(\ud835\udc4f\u2032 = 1) = 12 . When the adversary receives \ud835\udc370, then the adversary looks into each nonce. If \ud835\udc52\ud835\udc50 (\ud835\udc5f\ud835\udc56 ) = 1, then the adversary flips a coin and if \ud835\udc52\ud835\udc50 (\ud835\udc5f\ud835\udc56 ) = 0 then the adversary outputs \ud835\udc4f = 0. Hence,\nPr(\ud835\udc4f\u2032 = 1|\ud835\udc4f = 0) = 1 2 Pr(\u2203\ud835\udc5f\ud835\udc56s.t. \ud835\udc52\ud835\udc50 (\ud835\udc5f\ud835\udc56 ) = 1) + 0 \u00b7 Pr(\u2200\ud835\udc5f\ud835\udc56s.t. \ud835\udc52\ud835\udc50 (\ud835\udc5f\ud835\udc56 ) = 0) .\nTherefore,AdvIndDistress,\ud835\udc53\ud835\udc41A = | 1 2 \u2212 1 2 Pr(\u2203\ud835\udc5f\ud835\udc56s.t. \ud835\udc52\ud835\udc50 (\ud835\udc5f\ud835\udc56 ) = 1) |. Now, let \ud835\udc34\ud835\udc56 be the event that \ud835\udc52\ud835\udc50 (\ud835\udc5f\ud835\udc56 ) = 1. Let Pr(\ud835\udc52\ud835\udc50) (\ud835\udc5b) be the probability that there exists an \ud835\udc5f\ud835\udc56 with \ud835\udc56 \u2208 {1, . . . , \ud835\udc5b} such that it has the mECEG ciphertext structure, so by the inclusion-exclusion principle we have\nPr(\ud835\udc52\ud835\udc50) (\ud835\udc5b) = Pr \ud835\udc5b\u22c3 \ud835\udc56=1 \ud835\udc34\ud835\udc56 = \ud835\udc5b\u2211\ufe01 \ud835\udc58=1 (\u22121)\ud835\udc58+1 ( \u2211\ufe01 1\u2264\ud835\udc561<...<\ud835\udc56\ud835\udc58 \u2264\ud835\udc5b Pr ( \ud835\udc34\ud835\udc561 \u2229 . . . \u2229\ud835\udc34\ud835\udc56\ud835\udc58 )) Now Pr(\ud835\udc34\ud835\udc56 ) is the event where both\ud835\udc4b\ud835\udc56,1 and\ud835\udc4b\ud835\udc56,2 lie on the curve, that is, \ud835\udc4b 3 \ud835\udc56, \ud835\udc57 +\ud835\udc34\ud835\udc4b\ud835\udc56, \ud835\udc57 + \ud835\udc35 is a square, with probability 1/2.\nFor any \ud835\udc56 , we have Pr(\ud835\udc34\ud835\udc56 ) = 2 2\ud835\udc5b\u22122\n22\ud835\udc5b . The denominator comes from the fact that given \ud835\udc5b nonces we are looking at whether both \ud835\udc4b\ud835\udc56,1 and \ud835\udc4b\ud835\udc56,2 are on E\ud835\udc34,\ud835\udc35 , and the numerator looks at all the possible combinations (as the distribution of outputs \ud835\udc43\ud835\udc45\ud835\udc3a is indistinguishable from the uniform distribution) conditioning on both \ud835\udc4b\ud835\udc56,1 and \ud835\udc4b\ud835\udc56,2 being squares.\nSimilarly, for \ud835\udc56 \u2260 \ud835\udc57 \u2260 \ud835\udc58 , we have Pr(\ud835\udc34\ud835\udc56 \u2229 \ud835\udc34 \ud835\udc57 ) = 2 2\ud835\udc5b\u22124\n22\ud835\udc5b and Pr(\ud835\udc34\ud835\udc56 \u2229 \ud835\udc34 \ud835\udc57 \u2229 \ud835\udc34\ud835\udc58 ) = 2 2\ud835\udc5b\u22126\n22\ud835\udc5b , and so forth. Hence the adversary\u2019s advantage is\nAdvIndDistress,\ud835\udc53\ud835\udc41A = 12 \u2212 12 ( \ud835\udc5b\u2211\ufe01 \ud835\udc56=1 ( \ud835\udc5b \ud835\udc56 ) (\u22121)\ud835\udc56+1 2 2\ud835\udc5b\u22122\ud835\udc56 ) 22\ud835\udc5b ) =\n12 \u2212 12 ( \ud835\udc5b\u2211\ufe01 \ud835\udc56=1 ( \ud835\udc5b \ud835\udc56 ) (\u22121)\ud835\udc56+1 1 22\ud835\udc56 ) , which is negligible (and is shown in Figure 6). \u25a1"
        }
    ],
    "title": "Ask for Alice: Online Covert Distress Signal in the Presence of a Strong Adversary",
    "year": 2023
}