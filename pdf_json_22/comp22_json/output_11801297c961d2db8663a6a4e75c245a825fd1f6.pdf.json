{
    "abstractText": "Mining high utility sequential patterns is observed to be a significant research in data mining. Several methods mine the sequential patterns while taking utility values into consideration. The patterns of this type can determine the order in which items were purchased, but not the time interval between them. The time interval among items is important for predicting the most useful real-world circumstances, including retail market basket data analysis, stock market fluctuations, DNA sequence analysis, and so on. There are a very few algorithms for mining sequential patterns those consider both the utility and time interval. However, they assume the same threshold for each item, maintaining the same unit profit. Moreover, with the rapid growth in data, the traditional algorithms cannot handle the big data and are not scalable. To handle this problem, we propose a distributed three phase MapReduce framework that considers multiple utilities and suitable for handling big data. The time constraints are pushed into the algorithm instead of pre-defined intervals. Also, the proposed upper bound minimizes the number of candidate patterns during the mining process. The approach has been tested and the experimental results show its efficiency in terms of efficiency, memory utilization, and scalability. INDEX TERMS Data mining, MapReduce framework, Multiple utility thresholds, Sequential pattern mining, Time interval patterns.",
    "authors": [
        {
            "affiliations": [],
            "name": "SUMALATHA SALETI"
        },
        {
            "affiliations": [],
            "name": "T. JAYA LAKSHMI"
        },
        {
            "affiliations": [],
            "name": "MOHD WAZIH AHMAD"
        }
    ],
    "id": "SP:8561679bc5e5b4ce2c3c2f2a3a91bedb39d09034",
    "references": [
        {
            "authors": [
                "Minos N. Garofalakis",
                "Rajeev Rastogi",
                "Kyuseok Shim"
            ],
            "title": "Spirit: Sequential pattern mining with regular expression",
            "venue": "In proceedings of the 25th International Conference on Very Large Data Bases,",
            "year": 1999
        },
        {
            "authors": [
                "Jiawei Han",
                "Jian Pei",
                "Behzad Mortazavi-Asl",
                "Qiming Chen",
                "Umeshwar Dayal",
                "Mei-Chun Hsu"
            ],
            "title": "Freespan: Frequent pattern-projected sequential pattern mining, 2000",
            "venue": "In proceedings of the Sixth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining,",
            "year": 2000
        },
        {
            "authors": [
                "Mohammed J Zaki"
            ],
            "title": "Spade: An efficient algorithm for mining frequent sequences",
            "venue": "Machine Learning,",
            "year": 2001
        },
        {
            "authors": [
                "Jian Pei",
                "Jiawei Han",
                "B. Mortazavi-Asl",
                "Jianyong Wang",
                "H. Pinto",
                "Qiming"
            ],
            "title": "This article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2022.3224217 This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/ Author et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS",
            "venue": "IEEE Transactions on Knowledge and Data Engineering,",
            "year": 2022
        },
        {
            "authors": [
                "Philippe Fournier-Viger",
                "Jerry Chun-Wei Lin",
                "Rage Uday Kiran",
                "Yun Sing Koh",
                "Rincy Thomas"
            ],
            "title": "A survey of sequential pattern mining",
            "venue": "Data Science and Pattern Recognition,",
            "year": 2017
        },
        {
            "authors": [
                "Saleti Sumalatha",
                "RBV Subramanyam"
            ],
            "title": "A novel mapreduce algorithm for distributed mining of sequential patterns using co-occurrence information",
            "venue": "Applied Intelligence,",
            "year": 2019
        },
        {
            "authors": [
                "Sumalatha Saleti",
                "P. RadhaKrishna",
                "D. JaswanthReddy"
            ],
            "title": "Mining spatiotemporal sequential patterns using mapreduce approach",
            "venue": "Soft Computing and its Engineering Applications,",
            "year": 2022
        },
        {
            "authors": [
                "Chowdhury Farhan Ahmed",
                "Syed Khairuzzaman Tanbeer",
                "Byeong- Soo Jeong"
            ],
            "title": "A novel approach for mining high-utility sequential patterns in sequence databases",
            "venue": "ETRI Journal,",
            "year": 2010
        },
        {
            "authors": [
                "Junfu Yin",
                "Zhigang Zheng",
                "Longbing Cao"
            ],
            "title": "Uspan: An efficient algorithm for mining high utility sequential patterns",
            "venue": "In Proceedings of the 18th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining,",
            "year": 2012
        },
        {
            "authors": [
                "Guo-Cheng Lan",
                "Tzung-Pei Hong",
                "Vincent S. Tseng",
                "Shyue-Liang Wang"
            ],
            "title": "Applying the maximum utility measure in high utility sequential pattern mining",
            "venue": "Expert Systems with Applications,",
            "year": 2014
        },
        {
            "authors": [
                "Oznur Kirmemis Alkan",
                "Pinar Karagoz"
            ],
            "title": "Crom and huspext: Improving efficiency of high utility sequential pattern extraction",
            "venue": "IEEE Transactions on Knowledge and Data Engineering,",
            "year": 2015
        },
        {
            "authors": [
                "Jun-Zhe Wang",
                "Jiun-Long Huang",
                "Yi-Cheng Chen"
            ],
            "title": "On efficiently mining high utility sequential patterns",
            "venue": "Knowledge Information Systems,",
            "year": 2016
        },
        {
            "authors": [
                "Jerry Chun-Wei Lin",
                "Yuanfa Li",
                "Philippe Fournier-Viger",
                "Youcef Djenouri",
                "Ji Zhang"
            ],
            "title": "Efficient chain structure for high-utility sequential pattern mining",
            "venue": "IEEE Access,",
            "year": 2020
        },
        {
            "authors": [
                "Saleti Sumalatha"
            ],
            "title": "Incremental mining of high utility sequential patterns using mapreduce paradigm",
            "venue": "Cluster Computing,",
            "year": 2022
        },
        {
            "authors": [
                "Wen-Yen Wang",
                "Anna Y.-Q. Huang"
            ],
            "title": "Mining time-interval sequential patterns with high utility from transaction databases",
            "venue": "Journal of Advanced Computational Intelligence and Intelligent Informatics,",
            "year": 2016
        },
        {
            "authors": [
                "Chun-Wei Lin",
                "Jiexiong Zhang",
                "Philippe Fournier-Viger"
            ],
            "title": "High-utility sequential pattern mining with multiple minimum utility thresholds, 2017",
            "year": 2017
        },
        {
            "authors": [
                "Wensheng Gan",
                "Jerry Chun-Wei Lin",
                "Jiexiong Zhang",
                "Philip S. Yu"
            ],
            "title": "Utility mining across multi-sequences with individualized thresholds",
            "venue": "ACM/IMS Trans. Data Sci.,",
            "year": 2020
        },
        {
            "authors": [
                "Jeffrey Dean",
                "Sanjay Ghemawat"
            ],
            "title": "Mapreduce: Simplified data processing on large clusters",
            "venue": "Communications of the ACM,",
            "year": 2008
        },
        {
            "authors": [
                "Saleti Sumalatha",
                "R.B.V. Subramanyam"
            ],
            "title": "Distributed mining of high utility time interval sequential patterns using mapreduce approach",
            "venue": "Expert Systems with Applications,",
            "year": 2020
        },
        {
            "authors": [
                "Sumalatha Saleti",
                "Jaya Lakshmi Tangirala",
                "Ragunathan Thirumalaisamy"
            ],
            "title": "Distributed mining of high utility time interval sequential patterns with multiple minimum utility thresholds",
            "venue": "Advances and Trends in Artificial Intelligence. Artificial Intelligence Practices,",
            "year": 2021
        },
        {
            "authors": [
                "Ramakrishnan Srikant",
                "Rakesh Agrawal"
            ],
            "title": "Mining sequential patterns: Generalizations and performance improvements",
            "venue": "In Proceedings of the Fifth International Conference on Extending Database Technology,",
            "year": 1996
        },
        {
            "authors": [
                "Yen-Liang Chen",
                "Mei-Ching Chiang",
                "Ming-Tat Ko"
            ],
            "title": "Discovering timeinterval sequential patterns in sequence databases",
            "venue": "Expert Systems with Applications,",
            "year": 2003
        },
        {
            "authors": [
                "Yen-Liang Chen",
                "T.C.-K. Huang"
            ],
            "title": "Discovering fuzzy time-interval sequential patterns in sequence databases",
            "venue": "IEEE Transactions on Systems, Man, and Cybernetics, Part B (Cybernetics),",
            "year": 2005
        },
        {
            "authors": [
                "Hong Yao",
                "Howard J. Hamilton"
            ],
            "title": "Mining itemset utilities from transaction databases",
            "venue": "Data & Knowledge Engineering,",
            "year": 2006
        },
        {
            "authors": [
                "Roy Setiawan",
                "Dac-Nhuong Le",
                "Regin Rajan",
                "Thirukumaran Subramani",
                "Dilip Kumar Sharma",
                "Vidya Sagar Ponnam",
                "Kailash Kumar",
                "Syed Musthafa Akbar Batcha",
                "Pankaj Dadheech",
                "Sudhakar Sengan"
            ],
            "title": "Utilizing index-based periodic high utility mining to study frequent itemsets",
            "venue": "Arabian Journal for Science and Engineering,",
            "year": 2021
        },
        {
            "authors": [
                "Rakesh Agrawal",
                "Ramakrishnan Srikant"
            ],
            "title": "Fast algorithms for mining association rules in large databases, 1994",
            "venue": "In proceedings of the 20th International Conference on Very Large Data Bases",
            "year": 1994
        },
        {
            "authors": [
                "Jiawei Han",
                "Jian Pei",
                "Yiwen Yin"
            ],
            "title": "Mining frequent patterns without candidate generation",
            "venue": "SIGMOD Rec.,",
            "year": 2000
        },
        {
            "authors": [
                "Mohammed J. Zaki",
                "Karam Gouda"
            ],
            "title": "Fast vertical mining using diffsets",
            "venue": "In Proceedings of the Ninth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining",
            "year": 2003
        },
        {
            "authors": [
                "O Jamsheela",
                "G Raju"
            ],
            "title": "Sr-mine: Adaptive transaction compression method for frequent itemsets mining",
            "venue": "Arabian Journal for Science and Engineering,",
            "year": 2021
        },
        {
            "authors": [
                "Chunyan Zhang",
                "Meng Han",
                "Rui Sun",
                "Shiyu Du",
                "Mingyao Shen"
            ],
            "title": "A survey of key technologies for high utility patterns mining",
            "venue": "IEEE Access,",
            "year": 2020
        },
        {
            "authors": [
                "Jerry Chun-Wei Lin",
                "Wensheng Gan",
                "Philippe Fournier-Viger",
                "Tzung- Pei Hong"
            ],
            "title": "Mining high-utility itemsets with multiple minimum utility thresholds",
            "venue": "In Proceedings of the Eighth International C* Conference on Computer Science&Software Engineering",
            "year": 2015
        },
        {
            "authors": [
                "Jerry Chun-Wei Lin",
                "Wensheng Gan",
                "Philippe Fournier-Viger",
                "Tzung- Pei Hong",
                "Justin Zhan"
            ],
            "title": "Efficient mining of high-utility itemsets using multiple minimum utility thresholds",
            "venue": "Knowledge-Based Systems,",
            "year": 2016
        },
        {
            "authors": [
                "Wensheng Gan",
                "Jerry Chun-Wei Lin",
                "Philippe Fournier-Viger",
                "Han- Chieh Chao"
            ],
            "title": "More efficient algorithms for mining high-utility itemsets with multiple minimum utility thresholds, 2016",
            "venue": "Proceedings, Part I, 27th International Conference on Database and Expert Systems Applications - Volume",
            "year": 2016
        },
        {
            "authors": [
                "Srikumar Krishnamoorthy"
            ],
            "title": "Efficient mining of high utility itemsets with multiple minimum utility thresholds",
            "venue": "Engineering Applications of Artificial Intelligence,",
            "year": 2018
        },
        {
            "authors": [
                "Tran Huy Duong",
                "Demetrovics Janos",
                "Vu Duc Thi",
                "Nguyen Truong Thang",
                "Tran The Anh"
            ],
            "title": "An algorithm for mining high utility sequential patterns with time interval",
            "venue": "Cybernetics and Information Technologies,",
            "year": 2019
        },
        {
            "authors": [
                "Sumalatha Saleti",
                "N. Naga Sahithya",
                "K. Rasagna",
                "K. Hemalatha",
                "B. Sai\u00c2 Charan",
                "P.V. Karthik Upendra"
            ],
            "title": "Constraint pushing multithreshold framework for\u00c2 high utility time interval sequential pattern mining",
            "venue": "Soft Computing and its Engineering Applications,",
            "year": 2022
        }
    ],
    "sections": [
        {
            "text": "INDEX TERMS Data mining, MapReduce framework, Multiple utility thresholds, Sequential pattern mining, Time interval patterns.\nI. INTRODUCTION\nSEQUENTIAL pattern mining (SPM) [1] [2] [3] [4] [5][6] [7] [8] is a significant research theme in data mining. The primary goal of SPM is to identify frequent sequences that are defined by a minimum support level that is planned by the user. In particular, a customer who purchased \"Television\" would like to return to the store and purchase \"Speakers\". Market analysts can use this information to develop novel marketing tactics such as product cross-selling and advertising activities. The standard SPM techniques employ a frequency-based framework and are regarded as uninformative because they can\u2019t mine highly profitable sequences. As a result, high utility sequential pattern mining (HUSPM) [9] has been offered as a solution to this problem, it mines high utility sequences while taking into consideration both the item\u2019s profit and quantity.\nAlthough previous HUSPM algorithms [9] [10] [11] [12] [13] [14] [15] produce very profitable sequences, they are\nunable to estimate the time gap between consumers\u2019 subsequent visits to the store. Therefore, high utility time interval sequential pattern mining (HUTISP) [16] was developed to take time periods into account. Its primary objective is to find the patterns that have the time interval between each item. Observe a store that offers groceries such as soaps, cereals, books, and ice creams. Assuming these items in a database, the goal is to determine the time interval between purchases of specific items which are being sold. As a solution, the store keeper may keep track of the quantity of consumed items by time period. For instance, consider an output sequence pattern with time intervals denoted as \u27e8x, 4, y, 6, z\u27e9. It signifies that a person who bought item x also bought item y after 4 months and returned to the store after 6 months to purchase item z. It mines extremely profitable sequences as well as the time interval between them. In spite of this, it uses the single unique threshold for each item in the input database, implying that every item has the\nVOLUME 10, 2022 1\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\nsame unit profit. This is unsatisfactory because every single item in real world situations is unique and should not be considered equally. For instance, sales of washing machine will make more profits than sales of detergent. The problem of finding sequential patterns considering multiple utility thresholds was first addressed in [17] and later extended to [18]. The authors [18] designed Lexicographic sequence tree and utility array. The tree structure represents the possible HUSPs as nodes and the extension of each node is done using I-concatenation and S-concatenation mechanisms. The former denotes the itemset extension, whereas later denotes the sequence extension. Utility array allows to find the utility values of each node in the tree. However, the authors in [17] [18] does not deal with the time intervals which generates more significant patterns.\nDue to the ever growing database sizes, many researchers of data mining revised the conventional mining algorithms and formulated the distributed algorithms to handle the big data more efficiently. The most efficient big data framework that helps in designing the distributed algorithms is MapReduce [19]. In 2008, Google developed MapReduce [19] distributed programming framework. It can handle the processing of big data by distributing the work into two parallel processes, namely, Mapper and Reducer. Mapper is a process that partitions the input data into multiple chunks and processes them in parallel. The processed output is sent to the reducer for further processing which leads to the final output. The output of the parallel program is always stored inside a distributed storage called Hadoop distributed file system (HDFS). The work flow of MapReduce framework is given in Fig. 1.\nHUTISP [16] is a centralized algorithm that is ineffective for managing large amounts of data. In light of this, DHUTISP [20] has been introduced, it is a distributed MapReduce algorithm. Recently, a MapReduce algorithm, namely, DHUTISP-MMU [21] has been proposed to handle the issue of multiple utility of items. But, it considers the predefined time interval set before generating the patterns. In consideration of this, we propose MRHUTSP-MMU in this study. It will handle the issue of setting time constraints.\nThe work plan of the current paper is to:\n1) Investigate HUTISP mining using multiple utility thresholds. 2) Propose the distributed framework that deal with the big data. 3) Provide an upper bound that maintains the downward closure property which can efficiently prune the unpromising candidates. 4) Introduce an efficient mechanism to push the time constraints within the algorithm instead of predefined time intervals. 5) Provide an empirical analysis and comparison between the distributed and non-distributed algorithms and analyze the impact of applying time constraints.\nThe significant contributions of the current paper include:\n1) Defined a novel sequential pattern that includes utility, time intervals and multiple utility thresholds. 2) Proposed MRHUTSP-MMU - a distributed algorithm based on MapReduce framework that mines high utility sequential patterns including time intervals and each item having its own threshold. 3) Introduced Downward closure property that can be tested on the patterns which includes multiple utility thresholds. 4) The correctness of MRHUTSP-MMU is proved theoretically. 5) Compared the distributed version with the nondistributed approach in terms of processing time, usage of memory, and scalability.\nThe remaining sections include the following. Section II provides a quick overview of the literature. The problem is defined in Section III. In Section IV, the proposed algorithm is described. Section V contains the experimental outcomes. Section VI discusses the conclusions."
        },
        {
            "heading": "II. LITERATURE REVIEW",
            "text": ""
        },
        {
            "heading": "A. SEQUENTIAL PATTERN MINING AND TIME INTERVAL MINING",
            "text": "Sequential pattern mining [1] [2] [3] [4] [5] [6] [7] is applied in a variety of data mining research disciplines. For mining sequential patterns, there are mainly two kinds of algorithms. They are Apriori [22] and Pattern growth approach [5]. In 1996, Agarwal and Srikant invented the GSP algorithm. Candidate generation and frequency calculation are the two processes of GSP. Zaki invented the SPADE method in [4], it is grounded on the vertical mining procedure. Han developed pattern growth approaches such as Freespan [23] and Prefixspan [5]. Garofalakis et.al., conceived and implemented the SPIRIT algorithm for sequential pattern mining using constraints in [2]. Researchers focused on time interval pattern mining after investigating the problem of mining sequential patterns. Chen et al. [23] presented novel algorithms for time interval mining, notably I-Apriori and I-Prefixspan. These techniques have been extended by Chen et al. by proposing FTI-Apriori and FTI-Prefixspan, which use fuzzy theory to partition temporal periods [24]."
        },
        {
            "heading": "B. HIGH UTILITY ITEMSET MINING WITH MULTIPLE THRESHOLDS",
            "text": "The above listed algorithms are concerned with mining of frequent sequences and time interval patterns. They consider the occurrence of each item as binary and miss the number of units purchased and the profit raised by each item. In view of this, [25] [26] introduced a new framework called high utility itemset mining (HUIM) which is an improvement over frequent itemset mining [27] [28] [29] [30]. Considering non binary transactions, utility mining [25] [26] [31] was introduced, and it became an essential research theme in the data mining industry. Initially, HUIM with multiple thresholds was introduced in [32]. The authors proposed two algorithms, one is a baseline algorithm provided as an initial"
        },
        {
            "heading": "2 VOLUME 10, 2022",
            "text": "This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\nsolution for mining HUIs using more than one threshold. The other is an improved version of the former that makes use of TID-index procedure. Using this index, utility of a candidate can be found by reading the TID-index of that candidate instead of scanning the complete database. Further, the above two algorithms are extended using estimated utility co-occurrence structure (EUCS) and a novel algorithm, namely, HUI-MMUTE [33] has been proposed. However, these are Apriori-based and follows candidate generation and level wise approach. These involve multiple database scans. In contrast to Apriori-based algorithm, the authors proposed HIMU and HIMUEUCP [34] algorithms. These make use of the compact tree structure. Also,the properties introduced in [34] assure the anti-monotonicity inorder to mine the patterns from MIU-tree. However, these algorithms order the items in a transaction with reference to the values of minimum utility threshold. It means that these algorithms are sensitive to specific ordering of items. MHUI algorithm proposed in [35], do not consider any ordering among the items and is superior to all the above mentioned high utility mining algorithms with multiple thresholds. The author proposed suffix minimum utility which is used in developing generic pruning strategies which are independent of item ordering based on minimum utility thresholds."
        },
        {
            "heading": "C. SEQUENTIAL PATTERN MINING INCLUDING UTILITY AND MULTIPLE THRESHOLDS",
            "text": "All the above mentioned algorithms are associated to HUIM with multiple utility thresholds and are unable to address the HUSP issue. A framework for HUSP mining that considers different utility threshold for each item has been introduced in [17]. From the proposed framework, the authors introduced a baseline algorithm and later it was extended by including three pruning strategies. The pruning techniques\nhelps to reduce the upper bound there by the search space is reduced. Later, the framework proposed in [17] was extended to USPT algorithm [18]. The authors made use of compressed utility array structure and this helps in the construction of Lexicographic-sequential tree. To the best of our understanding, these are the only algorithms that discuss the issue of HUSP mining using multiple utility thresholds. Yet, they are unable to mine the time intervals."
        },
        {
            "heading": "D. HIGH UTILITY SEQUENTIAL PATTERN MINING INCLUDING TIME INTERVALS AND SINGLE THRESHOLD",
            "text": "Considering the time intervals, Wang et al. [16] introduced UTMining_A algorithm that can mine high utility sequences including the time intervals. Considering the need of processing big data, a distributed approach has been proposed in [20] which uses a single threshold for all items. The authors in [36] proposed an efficient way of imposing the time constraints while generating the sequential patterns with high utility. The above-mentioned techniques in [16] [20] [36] on the other hand, treat each item as equally essential, considering a single minimal utility criterion. Recently, UIPrefixSpan-MMU [37] algorithm has been proposed which can handle multiple utility threshold problem. But, the algorithm assumes that the data fit into a single centralized system and not suitable to handle the current era of big data. As a result, in the current framework, we present a distributed approach for HUTSP mining with multiple utilities."
        },
        {
            "heading": "E. DIFFERENCE FROM EARLIER WORKS",
            "text": "The existing works in mining HUSP using multiple utility thresholds avoid the time frame amidst the items. Also, time interval HUSP mining algorithms use a single threshold for every item. Furthermore, the research in HUSP mining lacks\nVOLUME 10, 2022 3\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\na distributed algorithm using MapReduce framework that deal with utility, time interval sequences and multiple utility thresholds. To the best of our understanding, the current work is the initial study on proposing a MapReduce framework which can generate high utility sequences including time intervals along with a different threshold on each item.\nIII. PROBLEM DEFINITION To illustrate the mining process, we consider a sample quantitative sequence dataset as given in Table 1. Let X = {i1, i2, . . . , im} are the allowed items in the dataset. An itemset is dentoed as I = {i1, i2, . . . , iq}, where I \u2286 X . If | I |= q, then I is referred to as a q-itemset. An input sequence S is denoted as \u27e8(t1,1, I1), (t1,2, I2), . . . , (t1,n, In)\u27e9, where Ii denotes the itemset and t\u03b1,\u03b2 denotes the time gap between the purchase of two itemsets I\u03b2 and I\u03b1. A quantitative sequence dataset is denoted as D = {S1, S2, S3, . . . , Sn}, where every input sequence has its unique identifier called Sequence id. Each item is allotted a profit value called its external utility, E(i), and its existence in the input sequence is allotted a value called internal utility, IU(i, Ij , Sn), here i is the item in Ij . For instance, IU(a, I1, S1) = 3 and E(a) = 2 according to Table 2. Definition 1: The utility of each item i in Ij for a given sequence Sa is defined as u(i, Ij , Sa) = IU(i, Ij , Sa) \u2217 E(i). The utility of i in Sa is the maximum utility value out of multiple itemsets in Sa where i occurs. It is denoted as u(i, Sa). Let us find the utility of a in S1, i.e. u(a, S1) = max{u(a, I1, S1), u(a, I2, S1), u(a, I3, S1)} = max{3 \u2217 2, 4 \u2217 2, 4 \u2217 2} = 8. Definition 2: The utility of a pattern P = \u27e8(t1,1, I1), (t1,2, I2), . . . , (t1,n, In)\u27e9 of length n in a sequence Sa and P \u2286 Sa is denoted as u(P, Sa) and derived as follows:\nu(P, Sa) = max{ \u2211 i\u2208P u(i, Sa),\u2200P \u2208 Sa} (1)\nFor example, u(\u27e8(0, a)(1, a)\u27e9, S1) = max{3\u00d72+4\u00d72, 4\u00d7 2 + 4\u00d7 2} = max{14, 16} = 16.\nDefinition 3: Sequence utility is equal to the sum of the item utilities in a sequence Sa, and derived as follows:\nSU(Sa) = \u2211 u(i, Ij , Sa),\u2200i \u2208 Sa (2)\nFor example, SU(S1) = u(a, I1, S1) + u(a, I2, S1) + u(b, I2, S1) + u(d, I2, S1) + u(a, I3, S1) + u(f, I3, S1) + u(d, I4, S1) = 6 + 8 + 6 + 6 + 8 + 3 + 6 = 43. Definition 4: Let D denote the input data located in the Hadoop Distributed File System (HDFS). T1, T2, . . . , Tn denote the nonempty disjoint input partitions of D, where D = {T1\u222aT2\u222aT3\u222a\u00b7 \u00b7 \u00b7\u222aTn}. The input splits for the dataset shown in Table 1 are assumed to be, T1 = {S1, S2, S3} and T2 = {S4, S5}. Definition 5: Local utility of a pattern P in a partition Ti is represented as UL(P, Ti), where\nUL(P, Ti) = \u2211 u(P, Si),\u2200Si \u2208 Ti \u2229 P \u2286 Si (3)\nFor example, UL(\u27e8(0, a)(1, e)\u27e9, T2) = u(\u27e8(0, a)(1, e)\u27e9, S4)+ u(\u27e8(0, a)(1, e)\u27e9, S5) = 14 + 12 = 26. Definition 6: For an input partition Ti, its utility is U(Ti), where\nU(Ti) = \u2211 SU(Sa),\u2200Sa \u2208 Ti (4)\nFor instance, U(T1) = SU(S1) + SU(S2) + SU(S3) = 43 + 34 + 40 = 117. Definition 7: Global utility of a pattern P is represented as UG(P ) and derived as follows:\nUG(P ) = \u2211 UL(P, Ti),\u2200Ti \u2208 D. (5)\nFor example, UG(\u27e8(0, b)(1, a)\u27e9) = UL(\u27e8(0, b)(1, a)\u27e9, T1) + UL(\u27e8(0, b)(1, a)\u27e9, T2) = 14 + 22 = 36. Definition 8: The utility of a given dataset D is defined as the summation of each partition utility. To illustrate, let us find the utility of the sample dataset D, U(D) = U(T1) + U(T2) = 117 + 67 = 184. Definition 9: For a pattern P = \u27e8(t1,1, I1), (t1,2, I2), . . . , (t1,n, Im)\u27e9, the following time constraints C1, C2, C3, C4 are defined. Considering the time interval between two consecutive itemsets, C1 and C2 denote the minimum and maximum time. Similarly, considering the first and last itemsets, C3 and C4 denote the minimum and maximum time. Definition 10: Multiple Minimum Utility threshold table (MMU table) is used to construct and express utility thresholds for every item, i.e. mu(ij). Table 3 shows the MMU table for the sample dataset. mu(ij) is defined as follows [32]:\nmu(ij) = max{c\u00d7 E(ij), LMU} (6)"
        },
        {
            "heading": "4 VOLUME 10, 2022",
            "text": "This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\nLMU is the user defined least minimum utility threshold, E(ij) is the external utility of ij , and c is the constant to adjust mu of item. Definition 11: The minimum utility threshold of a pattern P is expressed as MIU(P ) = min{mu(i) | i \u2208 P}. For example, MIU(\u27e8(0, b), (1, d)\u27e9) = min{mu(b),mu(d)} = min{28, 40} = 28. Definition 12: The potential minimum utility threshold of a pattern P is denoted as PMIU(P ),\nPMIU(P ) = min{mu(ij) | ij \u2208 P \u2228 ij \u2208 ext(P ) (7)\nWhere, ext(P ) represents the possible extensions of P in the database. For instance, PMIU(\u27e8(0, b), (1, d)\u27e9) = min{{mu(b),mu(d)}\u2228{mu(c),mu(e)}} = min{{28, 50}\u2228 {50, 70}} = 28. Definition 13: A pattern P is a local high utility sequential time interval pattern only if the local utility of P is not less than MIU(P ) and holds C1, C2, C3, and C4.\nUL(P, Ti) \u2265MIU(P )\u00d7 U(Ti) (8)\nDefinition 14: A pattern P is a global high utility sequential time interval pattern only if the global utility of P is not less than MIU(P ) and holds C1, C2, C3, and C4.\nUG(P ) \u2265MIU(P )\u00d7 U(D) (9)\nDefinition 15: Problem Statement: Mining the HUTISPs considering more than one utility threshold is to extract the possible time interval sequential patterns those satisfy the utility threshold for a given input dataset. Definition 16: Sequence weighted utility (SWU) of a pattern P is defined as the sum of the sequence utility of each input sequence in which P occur. It is defined as follows:\nSWU(P ) = \u2211 SU(Si),\u2200Si \u2287 P (10)\nDefinition 17: Given a pattern P , its upper bound in a sequence Sa is denoted as,\nUB(P, Sa) = u(P, Sa) +RU(P, Sa), if RU(P, Sa) > 0, = 0, otherwise (11) where RU(P, Sa) is the remaining utility of P in Sa and it is the summation of item utilities that appear after the last item of P in Sa. For example, RU(\u27e8(0, a)(1, b)\u27e9, S1) = u(d, I2, S1) + u(a, I3, S1) + u(f, I3, S1) + u(d, I4, S1) = 6 + 8 + 3 + 6 = 23. UB(\u27e8(0, a)(1, b)\u27e9, S1) = u(\u27e8(0, a)(1, b)\u27e9, S1) + RU(\u27e8(0, a)(1, b)\u27e9, S1) = 12 + 23 = 35. Multiple occurrences of a pattern consider the maximum value as its upper bound. Definition 18: For a pattern P , its upper bound in an input partition Ti is,\nUB(P, Ti) = x\u2211 a=1 UB(P, Sa) (12)\nWhere x is the count of sequences present in Ti in which P appear. For example, UB(\u27e8(0, a)(1, b)\u27e9, T1) = UB(\u27e8(0, a)(1, b)\u27e9, S1)+UB(\u27e8(0, a)(1, b)\u27e9, S2)+UB(\u27e8(0, a)\n(1, b)\u27e9, S3) = 35 + 0 + 0 = 35. Property 1 (Downward closure property): Given a quantitative sequence dataset D, and sequences A and B, where B is a super-sequence to A, then UB(A,D) \u2265 UB(B,D). Proof 1: According to Definitions 17, and 18, the UB(A,D) =\n\u2211x a=1 UB(A,Sa) and UB(B,D) =\u2211y\na=1 UB(B,Sa), where x and y denotes the number of input sequences in which A and B occur respectively. As A is a sub-sequence to B, all the time x \u2265 y. Therefore, UB(A,D) \u2265 UB(B,D). Definition 19: Given a sequence S = \u27e8(t1,1, I1), (t1,2, I2), . . . , (t1,n, In)\u27e9, a sequence S\u2032 = \u27e8(t\u20321,1, I \u20321), (t\u20321,2, I \u20322), . . . , (t\u20321,m, I \u2032 m)\u27e9, where m \u2264 n is called its prefix iff (1) t\u20321,i = t1,i and I \u2032i = Ii for i \u2264 m\u2212 1 (2) t\u20321,m = t1,m and I \u2032m \u2286 Im. Similarly, postfix of S with respect to prefix S\u2032 is given as S\u2032\u2032 = \u27e8(t\u2032\u20321,m, I \u2032\u2032m, t\u2032\u20321,m+1, I \u2032\u2032m+1, . . . , t\u2032\u20321,n, I \u2032\u2032n)\u27e9 iff (1) t\u2032\u20321,i = t1,i and I \u2032\u2032i = Ii for i > m (2) t \u2032\u2032 1,m = t \u2032 1,m, and I \u2032\u2032 m \u2286 I \u2032m (3) t1,n = t\u2032\u20321,n and In = I \u2032\u2032 n . Definition 20: The projected database of a sequence S over the database D is expressed as D |S and it is defined as the collection of all the postfix of S in each input sequence of D.\nAlgorithm 1 First Phase Input: Time interval quantitative sequence dataset External utility table MMU-Table Output: Promising item and its global utility. function Mapper\n1: Scan the input sequence and calculate LU of each item i and SU of the sequence. 2: Emit the item i and its local utility LU along with the sequence utility SU 3: end function 4: function Reducer 5: Let item i be the key and LU, SU be the values received\nfrom the mapper. 6: Initialize GU \u2190 0, SWU \u2190 0 7: for each LU, SU pair do 8: GU \u2190 GU + LU 9: SWU \u2190 SWU + SU\n10: end for 11: if SWU \u2265MIU(item) then 12: Emit the item i and global utility GU 13: end if 14: end function"
        },
        {
            "heading": "IV. MRHUTSP-MMU",
            "text": "In this section, the proposed system is outlined by listing the details of each MapReduce phase. The major goal of the proposed algorithm is to impose time constraints and consider different utility thresholds while keeping the downward closure property. Using the MapReduce framework, the algorithm is designed in three phases. First of all, the\nVOLUME 10, 2022 5\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\nproposed algorithm finds the global utility of every item in its first phase and finds the promising items. The detailed approach for the first phase is stated in Algorithm 1. Inorder to generate all the output sequences, we invoke the second phase. In other words, Algorithm 2 generates entire output sequences that are local to each partition. We conduct the third MapReduce phase to generate the patterns which are global. This is detailed in Algorithm 4. The workflow of MRHUTSP-MMU is given in Fig. 2.\nA. FIRST PHASE OF MRHUTSP-MMU The first phase of MRHUTSP-MMU is explained in Algorithm 1. It includes a mapper and a reducer. Mapper takes time interval quantitative sequence dataset, external utility associated with every item, and MMU-Table as input. Initially, mapper scans the database and extracts the items local utility and sequence utility of each input sequence (Line 1) (refer to Definition 1 and Definition 3). The local and sequence utilities of item are emitted by the mapper (Line 2). This in turn will be the input to the reducer. For each item, reducer is responsible to calculate item\u2019s global utility and sequence weighted utility. From Definition 7, global utility of an item is the sum of its local utility (Line 8). Similarly, from Definition 16, SWU refers to sum of all the sequence utilities (Line 9). Finally, the items whose sequence weighted utility satisfies the MIU threshold will be emitted as the output (Lines 11-13). They are said to be promising items written to the distributed cache file.\nFor example, consider the sequence S1, according to\nDefinition 1, utility of a, b, d, and f are 8, 6, 6, and 3 respectively. Similarly, from Definition 3, sequence utility of a is 43. Hence, the mapper emits the \u27e8key, value\u27e9 pairs \u27e8a, (8, 43)\u27e9, \u27e8b, (6, 43)\u27e9, \u27e8d, (6, 43)\u27e9, and \u27e8f, (3, 43)\u27e9. In the same way, for every sequence, the output emitted by the mapper is given in Table 4. Now, these \u27e8key, value\u27e9 pairs reach the reducer. In our example, the values (8, 43), (4, 34), (4, 54), and (8, 13) are with respect to the key a (refer to Table 4). The values associated with the other keys are shown in Table 5. The value is a pair of local utility and sequence utility. The sum of local utilities"
        },
        {
            "heading": "6 VOLUME 10, 2022",
            "text": "This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\ni.e. 8 + 4 + 4 + 8 = 24 is the global utility of a. Similarly, sum of sequence utilities i.e. 43 + 34 + 54 + 13 = 144 is SWU of a. The global utility and sequence weighted utilities for each item are mentioned in Table 6. As described in Algorithm 1, if the SWU of an item do not satisfy its MIU, then the item cannot generate the high utility patterns. So, the reducer returns the item and its global utility after satisfying the above mentioned condition. MIU of each item is varied (refer to Table 3) in the current study and it is 45% of the database utility for item a, 28% in case of item b, and so on. As mentioned in Definition 8, database utility is 43+34+40+54+13 = 184. In the current example, every item satisfies its MIU threshold and emitted as output.\nAlgorithm 2 Second Phase Input: Time interval quantitative sequence dataset DCp - Distributed cache file with promising items MMU-Table Constraints - C1,C2,C3, and C4 Output: \u27e8LHUTISP,LU\u27e9- Output patterns from each input partition and its utility function Mapper\n1: Let the promising item read from DCp be ip. 2: Let C be the candidate pattern set. 3: Let P be the output pattern. 4: Modify the input sequence by removing the unpromising\nitems. 5: for each ip do 6: Include P \u2190 \u27e8(0, ip)\u27e9 into C. 7: if utility of P satisfies the MIU threshold then 8: Emit P and its utility 9: end if\n10: Invoke MRHUTSP -MMU(D | P,C,MMU, C1, C2, C3, C4) 11: end for 12: end function\nB. SECOND PHASE OF MRHUTSP-MMU The input for the second phase is time interval quantitative sequence dataset, promising items, MMU-Table and time constraints. We should at first make sure that all the candidate patterns may not be output patterns. Hence, we use two structures, one represents the candidate set C and the other represents the output pattern P (Lines 2-3 of Algorithm 2). Initially, the unpromising items will be pruned from\neach input sequence (Line 4). Now, an initial pattern P is created which includes time 0 and promising item ip (Line 6). If the utility of P (which is the global utility of ip) satisfies its MIU then P is emitted as output (Lines 7- 8). Inorder to extend the pattern P , we invoke the function MRHUTSP -MMU . This is a recursive function that extends the pattern P by scanning the projected database of P .\nFor example, the promising items received by the second phase mapper are a, b, c, d, e, and f . Hence, the initial patterns generated are (0, promising item). Global utility of a is 24 which is less than its MIU (i.e. 45% of the database utility). That is, (0, a) is not an output pattern. It is known that, super pattern of a non high utility pattern may be of high utility. Hence, we proceed to generate the super patterns of all the initial patterns by invoking Algorithm 3.\nAlgorithm 3 first reads the projected database of candidate pattern and generates all the possible \u27e8time, item\u27e9 pairs. In this process, only the pairs which satisfy the upperbound are considered. Also, the time interval of the pair must obey the constraints C1 and C2 (Line 1). Now, the candidate pattern is updated by including all such pairs (Line 3). If the resulting candidate pattern satisfies the constraint C4, then the function is called with the new candidate pattern as its argument (Lines 4-5). Later, if it satisfies the constraint C3, we include it in the candidate pattern set (Lines 6-8). Next, if utility of the candidate pattern satisfies the MIU threshold, then it is emitted as output along with its projected database (Lines 10- 12).\nIn the running example, considering the first partition, the \u27e8time, item\u27e9 pairs generated from the projected database of (0, a) are (1, a), (1, b), (1, d), (2, a), (2, f), (3, d), (0, b), (1, d) , (2, c). All such pairs generated from the initial patterns are given in Table 7. The constraint values are C1 = 0, C2 = 3, C3 = 1, C4 = 3. The UB(\u27e8(0, a)(1, a)\u27e9, S1) = u(\u27e8(0, a)(1, a)\u27e9)+RU(\u27e8(0, a)(1, a)\u27e9, S1) = 14+29 = 43 \u2265 PMIU(\u27e8(0, a)(1, a)\u27e9), where PMIU(\u27e8(0, a)(1, a)\u27e9) = 33. Similarly, the \u27e8time, item\u27e9 pairs from (0, a) satisfying the upper bound threshold are (1, b) and (1, d). The \u27e8time, item\u27e9 pair from (0, b) satisfying the upper bound threshold is (1, d). Similarly, the \u27e8time, item\u27e9 pairs generated from (0, c) are (0, f), (1, b), and (2, d). The \u27e8time, item\u27e9 pair generated from (0, e) is (1, e) and from (0, f) is (1, b). Now, let us consider the \u27e8time, item\u27e9 pairs from (0, b). Among them, only the pair (1, d) satisfies the upper bound threshold. UB(\u27e8(0, b)(1, d)\u27e9, T1) = UB(\u27e8(0, b)(1, d)\u27e9, S1) + UB(\u27e8(0, b)(1, d)\u27e9, S2) + UB(\u27e8(0, b)(1, d)\u27e9, S3) = 0 + 26 + 36 = 62 \u2265 PMIU(\u27e8(0, b)(1, d)\u27e9, where PMIU(\u27e8(0, b)(1, d)\u27e9 = 33. Now, the pattern \u27e8(0, b), (1, d)\u27e9 is extended with the new \u27e8time, item\u27e9 pairs, i.e. (2, c) and (1, e). But, the UB(\u27e8(0, b), (1, d), (2, c)\u27e9) = 26 < PMIU(\u27e8(0, b), (1, d), (2, c)\u27e9 and UB(\u27e8(0, b), (1, d), (1, e)\u27e9 ) = 36 \u2265 PMIU(\u27e8(0, b), (1, d), (1, e)\u27e9, where \u27e8(0, b), (1, d), (1, e)\u27e9 cannot be extended further with the \u27e8time, item\u27e9 pairs. Hence, the recursion ends here and thus generated patterns from (0, b) are \u27e8(0, b), (1, d)\u27e9 and \u27e8(0, b), (1, d), (1, e)\u27e9 with an utility of 54 and 36 respec-\nVOLUME 10, 2022 7\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\nAlgorithm 3 MRHUTSP -MMU function MRHUTSP -MMU(D | P,C,MMU,C1, C2, C3, C4)\nInitial pattern (time,item) pairs (0, a) (1, a) : 43, (1, b) : 35, (1, d) : 41, (2, a) : 23, (2, f) : 15, (3, d) : 12, (0, b) : 30, (1, d) : 12, (2, c) : 0 (0, b) (0, d) : 29, (1, a) : 23, (1, f) : 15, (2, d) : 0, (1, d) : 62, (2, c) : 0, (1, e) : 0 (0, c) (0, f) : 40, (1, b) : 39, (2, d) : 33, (2, e) : 0 (0, d) (1, a) : 23, (1, f) : 15, (2, d) : 0, (1, c) : 0, (0, e) : 0 (0, e) (1, a) : 34, (1, b) : 30, (2, d) : 12, (3, c) : 0 (0, f) (1, d) : 0, (1, b) : 37, (2, d) : 31, (2, e) : 0\ntively. The same recursive procedure is applied for the remaining initial patterns (0, a), (0, c), (0, d), (0, e), and (0, f). Note that these output patterns are local to first partition. Consider the second partition and the same procedure applies to it and the output patterns generated are \u27e8(0, a), (1, bd), (2, b), (3, e)\u27e9, \u27e8(0, a), (1, b), (2, ab), (3, e)\u27e9, \u27e8 (0, a), (1, bd), (2, ab), (3, e)\u27e9, and \u27e8(0, bd), (1, ab), (2, e)\u27e9, their local utilities are 50, 48, 54, and 50 respectively.\nAlgorithm 4 Third Phase Input: \u27e8P,D | P \u27e9 MMU-Table Output: \u27e8P,UG(P )\u27e9 function Mapper\n1: for each pattern Pi in P do 2: Find the local utility of pattern Pi 3: Emit Pi and UL(Pi) 4: end for\nend function function Reducer\n5: By adding local utility of Pi calculate the global utility UG(Pi). 6: if UG(Pi) \u2265MIU(Pi) then 7: Emit Pi and UG(Pi) 8: end if\nend function"
        },
        {
            "heading": "C. THIRD PHASE OF MRHUTSP-MMU",
            "text": "In the third phase, the output from second phase is received i.e. local output patterns and their projected database. The mapper of third phase scans the projected database of each local pattern and finds the local utility (Line 2). The reducer finds the sum of local utilities, which results in the global utility (Line 5). Finally, only the patterns that satisfy the MIU threshold are emitted as output (Lines 6-8).\nIn our running example, for each local pattern, its utility in both the partitions is calculated. For instance, the utility of \u27e8(0, b), (1, d)\u27e9 from partition 1 is 54 and from partition 2 is 0. Hence, the global utility of \u27e8(0, b), (1, d)\u27e9 is 54 which satisfies its MIU , i.e. UG(\u27e8(0, b), (1, d)\u27e9) \u2265 28% of 184. Similarly, the global utility of \u27e8(0, a), (1, bd), (2, b), (3, e)\u27e9, \u27e8(0, a), (1, b), (2, ab), (3, e)\u27e9, \u27e8(0, a), (1, bd), (2, ab), (3, e)\u27e9, and \u27e8(0, bd), (1, ab), (2, e)\u27e9 are 50, 48, 54, and 50 respectively. Among these patterns, \u27e8(0, a), (1, bd), (2, ab), (3, e)\u27e9 satisfies its MIU . Finally, the output patterns and their utilities are \u27e8(0, b), (1, d)\u27e9 : 54 and \u27e8(0, a), (1, bd), (2, ab), (3, e)\u27e9 : 54"
        },
        {
            "heading": "D. CORRECTNESS OF MRHUTSP-MMU",
            "text": "Theorem 1: Given a time interval quantitative sequence dataset, external utility of each item, time constraints and MMU-Table, MRHUTSP-MMU will generate all possible high utility time interval sequential patterns Proof 2: We prove the theorem by stating that MRHUTSPMMU will not lose any of the pattern in every phase.\n1) Prune the unpromising items in the first MapReduce"
        },
        {
            "heading": "8 VOLUME 10, 2022",
            "text": "This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\nphase: According to Algorithm 1, the mapper generates all the items and their local utility and sequence utility. Mapper will not miss any item present in the dataset. The reducer aggregates the local utilities to form the global utility of item and aggregates the sequence utility to form the sequence weighted utility. Reducer will output the items whose SWU satisfies its MIU . Thus, we do not miss any of the promising item. 2) Generate the candidate patterns whose length exceeds 2: In the second phase, each mapper generates entire local high utility sequential patterns following the time constraints. During this process, each candidate pattern is extended to its super pattern following the Property 1. Hence, the pattern is not extended if its upper bound does not satisfy the PMIU threshold. From Definition 13, whenever the local utility of a pattern is less than its MIU , then we can prune the candidate pattern. This pruning followed in the second phase will not lose any of the local candidate pattern. 3) Prune the patterns whose global utility do not satisfies its MIU : This is done in the third MapReduce phase. According to Definition 14, if the global utility of a pattern is less than its MIU , then it is not a high utility sequential pattern. Therefore, the third phase will not lose any of the output pattern. Hence, each phase in MRHUTSP-MMU will not lose any of the pattern whose utility satisfies the threshold.\nV. RESULTS We conducted several experiments on three real datasets and two synthetic datasets to assess the performance of MRHUTSP-MMU. Kosarak 1, BMSWebview2 2, MSNBC 3 are the three real datasets. Kosarak consists of 990,002 sequences and it is obtained from FIMI repository. It stores the click-stream data of an online Hungarian news portal. BMSWebView2 keeps track of an e-commerce website\u2019s click stream data. MSNBC dataset maintains the page visits of 989,818 users for a period of one day. BMSWebView2 and MSNBC are obtained from SPMF [38] data mining library. Inorder to evaluate MRHUTSP-MMU on big datasets, we generated two synthetic datasets following the procedure described in [1] and shown in Table 8. The parameters passed to the synthetic data generator are mentioned in Table 9. However, the above mentioned datasets do not include any internal/external utility information. So, we used a random number generator to provide the internal/external utilities from 1 to 10. The time information is included in the dataset based on the occurrence order of the itemset in a transaction. We employed a Hadoop cluster including one node as a master and eight as data nodes. Each node has a 2.5 GHz Intel Xeon CPU with 16 GB RAM and Hadoop 2.9.1 installed. Java is used to implement all of the algorithms.\n1http : //fimi.ua.ac.be/data/. 2https://www.philippe-fournier-viger.com/spmf/datasets/BMS2.txt. 3https://www.philippe-fournier-viger.com/spmf/datasets/MSNBC.txt."
        },
        {
            "heading": "A. RUN TIME COMPARISON WITH RESPECT TO CONSTRAINTS AND LEAST MINIMUM UTILITY",
            "text": "The constraints used in the performance assessment are C1 = 0, C2 = 2, C3 = 0, and C4 = 4 on the real datasets and C1 = 0, C2 = 5, C3 = 0, and C4 = 15 on the synthetic datasets. MRHUTSP-MMU is compared with UIPrefixSpan-MMU in terms of run time and the findings are shown in Fig. 3. Both the algorithms are executed with and without constraints. As a result, it is found that, the algorithms perform better with time constraints. Because the time constraints induce a smaller number of candidates to be generated, which lowers the search space and increases the performance. Furthermore, for lower values of LMU, the run time will increase. This is because of huge candidates for lower LMU values. Additionally, more effort is spent during candidate evaluation. It is also observed that MRHUTSPMMU is more efficient than UIPrefixSpan-MMU on all the five datasets. This is because of the MapReduce Algorithm employed in MRHUTSP-MMU which distributed the execution process among multiple nodes in the Hadoop cluster.\nOn Kosarak dataset, MRHUTSP-MMU with constraints is about 2.4, 2.8, and 5.4 times faster than MRHUTSPMMU without constraints, UIPrefixSPan-MMU with constraints, and UIPrefixSPan-MMU without constraints. On BMSWebView2 dataset, MRHUTSP-MMU with constraints is about 1.4, 3.1, and 5.3 times faster than MRHUTSPMMU without constraints, UIPrefixSPan-MMU with constraints, and UIPrefixSPan-MMU without constraints. On MSNBC dataset, MRHUTSP-MMU with constraints is about 1.5, 2.7, and 4.5 times faster than MRHUTSPMMU without constraints, UIPrefixSPan-MMU with constraints, and UIPrefixSPan-MMU without constraints On Synthetic Dataset1, MRHUTSP-MMU with constraints is about 1.9, 3.7, and 7.3 times faster than MRHUTSP-MMU without constraints, UIPrefixSPan-MMU with constraints, and UIPrefixSPan-MMU without constraints. On Synthetic Dataset2, MRHUTSP-MMU with constraints is about 2.1, 4.2, and 7.6 times faster than MRHUTSP-MMU without constraints, UIPrefixSPan-MMU with constraints, and UIPrefixSPan-MMU without constraints.\nUIPrefixSpan-MMU requires more time because it needs to read the database for three times, and the time for scanning the database is directly proportional to the database size. Whereas, MRHUTSP-MMU scans the database only for\nVOLUME 10, 2022 9\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\ntwo times. Also, the parallel execution of multiple map and reduce functions leads to reduced processing time. Hence, the distributed version MRHUTSP-MMU is more efficient than the original UIPrefixSPan-MMU.\nB. MEMORY CONSUMPTION OF THE ALGORITHMS\nThe memory consumed by MRHUTSP-MMU is lesser than the other three approaches. The test reports of both the algorithms with and without constraints has been presented in Fig. 4. It is observed that both of them consume lesser memory when constraints have been applied. This is due to the fewer candidate sequences generated by applying the\nconstraints. It is also noticed that the memory requirement tends to decrease with an increase in the threshold. This is mainly due to the generation of more number of patterns for lower values of threshold. On Kosarak dataset, the memory consumption of MRHUTSP-MMU with constraints is nearly 1.5, 2.8, and 4.2 times less than MRHUTSP-MMU without constraints, UIPrefixSpan-MMU with constraints and UIPrefixSpan-MMU without constraints. On BMSWebView2 dataset, the memory consumption of MRHUTSPMMU with constraints is nearly 1.2, 2.3, and 2.7 times less than MRHUTSP-MMU without constraints, UIPrefixSpanMMU with constraints and UIPrefixSpan-MMU without"
        },
        {
            "heading": "10 VOLUME 10, 2022",
            "text": "This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\nconstraints. On MSNBC dataset, the memory consumption of MRHUTSP-MMU with constraints is nearly 1.6, 2.2, and 2.7 times less than MRHUTSP-MMU without constraints, UIPrefixSpan-MMU with constraints and UIPrefixSpanMMU without constraints.On Synthetic Dataset1, the memory consumption of MRHUTSP-MMU with constraints is nearly 1.7, 3.1, and 3.6 times less than MRHUTSP-MMU without constraints, UIPrefixSpan-MMU with constraints and UIPrefixSpan-MMU without constraints. On Synthetic Dataset2, the memory consumption of MRHUTSP-MMU with constraints is nearly 2.3, 3.3, and 3.9 times less than MRHUTSP-MMU without constraints, UIPrefixSpan-\nMMU with constraints and UIPrefixSpan-MMU without constraints."
        },
        {
            "heading": "C. SCALABILITY TEST",
            "text": "To test the scalability of MRHUTSP-MMU algorithm, we carried out two experiments - scalability with respect to dataset capacity, scalability with respect to node count in the cluster. The results of former experiment are given in Fig. 5. The number of sequences used in the experiment on the Kosarak dataset ranged from 1 lakh to the entire dataset (990,002 sequences). The size has been changed from 2 lakhs to full dataset size. For BMSWebView2 dataset, sequence\nVOLUME 10, 2022 11\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\ncount ranged from 10,000 to the full dataset size (77,512). The dataset size has been increased by 20 thousand every time. For MSNBC dataset, the sequence count ranged from 2 lakhs to the full dataset size (989,818). The size is increased by 2 lakhs every time. The size of Synthetic Dataset1 is varied from 2 lakhs to 1 million. The size is increased by 2 lakhs for every experiment. The number of sequences considered for Synthetic Dataset2 is from 2 millions to 10 millions. The size is increased by 2 millions each time. The least minimum utility used in the above experiment is 0.6, 1.7, and 0.6 for Kosarak, BMSWebview2, and MSNBC datasets, and it is 0.5 for Synthetic Dataset1 and Synthetic Dataset2.\nIt is visible that the performance gradually decrease with the rise in dataset size. It is also noticed that the MRHUTSPMMU scales well when executed on Synthetic Dataset1 and Synthetic Dataset2 compared to real datasets. This shows that MRHUTSP-MMU is more scalable than UIPrefixSPanMMU especially on large datasets. The reasons are two fold. Firstly, MRHUTSP-MMU scans the dataset only for two times, whereas UIPrefixSpan-MMU scans the dataset for three times. Secondly, the distributed nature of the proposed algorithm parallelize the processing of sequences thereby reducing the execution time.\nFigure 6 demonstrates the scalability of MRHUTSP-MMU"
        },
        {
            "heading": "12 VOLUME 10, 2022",
            "text": "This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\nregarding the updation of node count. For this experiment, the run time of MRHUTSP-MMU is noted with and without constraints. The algorithms are executed using 2, 4, 6, and 8 nodes. The centralized approaches are not used as they exhibited more running time especially for the synthetic datasets using 2 nodes. It is noticed that, the reduction in run time is more when we scaled from 2 to 4 nodes compared to 4 to 6 and 6 to 8 nodes.\nD. UPPER BOUND EVALUATION\nTwo upper bounds UB and SWU are evaluated and the results are shown in Fig. 7. UB is a tighter than SWU and\nthis is evident from Definition 16 and Definition 18. A tighter upper bound always results in less number of promising sequences there by the candidates for evaluation are reduced. This effects the algorithm\u2019s run time. MRHUTSP-MMU using UB as the upper bound executes faster compared to SWU as the upper bound. Especially, for lower thresholds, the UB approach outperforms the SWU ."
        },
        {
            "heading": "VI. CONCLUSION",
            "text": "Conventional algorithms for finding sequential patterns with high utility excludes the time factor and consider that all items in a transaction have the same utility. The prime contribution of the current paper is to study the problem of multiple\nVOLUME 10, 2022 13\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\nutilities with respect to time interval mining of sequences and propose a distributed solution that deals with the big data. Taking into consideration, we contributed MRHUTSP-MMU for finding the sequential patterns which include separate utility for each item and generates the time between each itemset of the pattern. The experimental work was carried out to know the efficiency of the algorithm with respect to time constraints. Also, MRHUTSP-MMU outperforms the non-distributed algorithms in terms of run time, memory, and scalability. As an extension to the current work, MRHUTSPMMU can be more investigated to introduce most efficient pruning strategies."
        },
        {
            "heading": "14 VOLUME 10, 2022",
            "text": "This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\nChen, U. Dayal, and Mei-Chun Hsu. Mining sequential patterns by pattern-growth: the prefixspan approach. IEEE Transactions on Knowledge and Data Engineering, 16(11):1424\u20131440, 2004. [6] Philippe Fournier-Viger, Jerry Chun-Wei Lin, Rage Uday Kiran, Yun Sing Koh, and Rincy Thomas. A survey of sequential pattern mining. Data Science and Pattern Recognition, 1(1):54\u201377, 2017. [7] Saleti Sumalatha and RBV Subramanyam. A novel mapreduce algorithm for distributed mining of sequential patterns using co-occurrence information. Applied Intelligence, 49:150\u2013171, 2019. [8] Sumalatha Saleti, P. RadhaKrishna, and D. JaswanthReddy. Mining spatiotemporal sequential patterns using mapreduce approach. In Kanubhai K. Patel, Gayatri Doctor, Atul Patel, and Pawan Lingras, editors, Soft Computing and its Engineering Applications, pages 153\u2013166, Cham, 2022. Springer International Publishing. [9] Chowdhury Farhan Ahmed, Syed Khairuzzaman Tanbeer, and ByeongSoo Jeong. A novel approach for mining high-utility sequential patterns in sequence databases. ETRI Journal, 32(5):676\u2013686, 2010. [10] Junfu Yin, Zhigang Zheng, and Longbing Cao. Uspan: An efficient algorithm for mining high utility sequential patterns, 2012. In Proceedings of the 18th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 660\u2013668. [11] Guo-Cheng Lan, Tzung-Pei Hong, Vincent S. Tseng, and Shyue-Liang Wang. Applying the maximum utility measure in high utility sequential pattern mining. Expert Systems with Applications, 41(11):5071\u20135081, 2014. [12] Oznur Kirmemis Alkan and Pinar Karagoz. Crom and huspext: Improving efficiency of high utility sequential pattern extraction. IEEE Transactions on Knowledge and Data Engineering, 27(10):2645\u20132657, 2015. [13] Jun-Zhe Wang, Jiun-Long Huang, and Yi-Cheng Chen. On efficiently mining high utility sequential patterns. Knowledge Information Systems, pages 597\u2013627, 2016. [14] Jerry Chun-Wei Lin, Yuanfa Li, Philippe Fournier-Viger, Youcef Djenouri, and Ji Zhang. Efficient chain structure for high-utility sequential pattern mining. IEEE Access, 8:40714\u201340722, 2020. [15] Saleti Sumalatha. Incremental mining of high utility sequential patterns using mapreduce paradigm. Cluster Computing, 25:805\u2013825, 2022. [16] Wen-Yen Wang and Anna Y.-Q. Huang. Mining time-interval sequential patterns with high utility from transaction databases. Journal of Advanced Computational Intelligence and Intelligent Informatics, 20(6):1018\u20131026, 2016. [17] Chun-Wei Lin, Jiexiong Zhang, and Philippe Fournier-Viger. High-utility sequential pattern mining with multiple minimum utility thresholds, 2017. [18] Wensheng Gan, Jerry Chun-Wei Lin, Jiexiong Zhang, and Philip S. Yu. Utility mining across multi-sequences with individualized thresholds. ACM/IMS Trans. Data Sci., 1(2), may 2020. [19] Jeffrey Dean and Sanjay Ghemawat. Mapreduce: Simplified data processing on large clusters. Communications of the ACM, 51(1):107\u2013113, 2008. [20] Saleti Sumalatha and R.B.V. Subramanyam. Distributed mining of high utility time interval sequential patterns using mapreduce approach. Expert Systems with Applications, 141:112967, 2020. [21] Sumalatha Saleti, Jaya Lakshmi Tangirala, and Ragunathan Thirumalaisamy. Distributed mining of high utility time interval sequential patterns with multiple minimum utility thresholds. In Hamido Fujita, Ali Selamat, Jerry Chun-Wei Lin, and Moonis Ali, editors, Advances and Trends in Artificial Intelligence. Artificial Intelligence Practices, pages 86\u201397, Cham, 2021. Springer International Publishing. [22] Ramakrishnan Srikant and Rakesh Agrawal. Mining sequential patterns: Generalizations and performance improvements. In Proceedings of the Fifth International Conference on Extending Database Technology, 1057:3\u201317, 1996. [23] Yen-Liang Chen, Mei-Ching Chiang, and Ming-Tat Ko. Discovering timeinterval sequential patterns in sequence databases. Expert Systems with Applications, 25(3):343\u2013354, 2003. [24] Yen-Liang Chen and T.C.-K. Huang. Discovering fuzzy time-interval sequential patterns in sequence databases. IEEE Transactions on Systems, Man, and Cybernetics, Part B (Cybernetics), 35(5):959\u2013972, 2005. [25] Hong Yao and Howard J. Hamilton. Mining itemset utilities from transaction databases. Data & Knowledge Engineering, 59(3):603\u2013626, 2006. Including: ER 2003. [26] Roy Setiawan, Dac-Nhuong Le, Regin Rajan, Thirukumaran Subramani, Dilip Kumar Sharma, Vidya Sagar Ponnam, Kailash Kumar, Syed Musthafa Akbar Batcha, Pankaj Dadheech, and Sudhakar Sengan. Utilizing index-based periodic high utility mining to study frequent itemsets. Arabian Journal for Science and Engineering, 2021.\n[27] Rakesh Agrawal and Ramakrishnan Srikant. Fast algorithms for mining association rules in large databases, 1994. In proceedings of the 20th International Conference on Very Large Data Bases. [28] Jiawei Han, Jian Pei, and Yiwen Yin. Mining frequent patterns without candidate generation. SIGMOD Rec., 29(2):1\u201312, may 2000. [29] Mohammed J. Zaki and Karam Gouda. Fast vertical mining using diffsets, 2003. In Proceedings of the Ninth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. [30] O Jamsheela and G Raju. Sr-mine: Adaptive transaction compression method for frequent itemsets mining. Arabian Journal for Science and Engineering, 2021. [31] Chunyan Zhang, Meng Han, Rui Sun, Shiyu Du, and Mingyao Shen. A survey of key technologies for high utility patterns mining. IEEE Access, 8:55798\u201355814, 2020. [32] Jerry Chun-Wei Lin, Wensheng Gan, Philippe Fournier-Viger, and TzungPei Hong. Mining high-utility itemsets with multiple minimum utility thresholds, 2015. In Proceedings of the Eighth International C* Conference on Computer Science&Software Engineering. [33] Jerry Chun-Wei Lin, Wensheng Gan, Philippe Fournier-Viger, TzungPei Hong, and Justin Zhan. Efficient mining of high-utility itemsets using multiple minimum utility thresholds. Knowledge-Based Systems, 113:100\u2013115, 2016. [34] Wensheng Gan, Jerry Chun-Wei Lin, Philippe Fournier-Viger, and HanChieh Chao. More efficient algorithms for mining high-utility itemsets with multiple minimum utility thresholds, 2016. Proceedings, Part I, 27th International Conference on Database and Expert Systems Applications - Volume 9827. [35] Srikumar Krishnamoorthy. Efficient mining of high utility itemsets with multiple minimum utility thresholds. Engineering Applications of Artificial Intelligence, 69:112\u2013126, 2018. [36] Tran Huy Duong, Demetrovics Janos, Vu Duc Thi, Nguyen Truong Thang, and Tran The Anh. An algorithm for mining high utility sequential patterns with time interval. Cybernetics and Information Technologies, 19(4):3\u201316, 2019. [37] Sumalatha Saleti, N. Naga Sahithya, K. Rasagna, K. Hemalatha, B. Sai\u00c2 Charan, and P. V. Karthik Upendra. Constraint pushing multithreshold framework for\u00c2 high utility time interval sequential pattern mining. In Kanubhai K. Patel, Gayatri Doctor, Atul Patel, and Pawan Lingras, editors, Soft Computing and its Engineering Applications, pages 264\u2013273, Cham, 2022. Springer International Publishing. [38] Fournier-Viger P, Lin C.W, Gomariz A, Gueniche T, Soltani A, Deng Z, and Lam H.T. The spmf open-source data mining library version 2, 2016. In proceedings of 19th European Conference on Principles of Data Mining and Knowledge Discovery (PKDD 2016) Part III, Springer LNCS 9853, pp. 36-40.\nS. SUMALATHA is working as an Assistant Professor in the Department of Computer Science and Engineering, SRM University, Amaravathi, AP, India. She received her Ph.D. Degree from National Institute of Technology, Warangal, India in 2020. Her research interests include Big data, Data mining, and pattern discovery.\nVOLUME 10, 2022 15\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nAuthor et al.: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS\nT. JAYA LAKSHMI is working as an Assistant Professor in the Department of Computer Science and Engineering, SRM University, Amaravathi, AP, India. She received her Ph.D. Degree for her work on \"Link Prediction in Heterogeneous Social Networks\" from the School of Computer and Information Sciences, University of Hyderabad, India in 2019. She is reviewer of reputed international journals. She has a overall teaching experience of 22 years. Her research interests include\nGraph mining, Recommender systems, Natural Language Processing and Security analytics.\nMOHD WAZIH AHMAD is working as Assistant Professor in the Department of Computer Science and Engineering, Adama Science and Technology University, Adama, Ethiopia. His current research projects are based on Machine Learning, Internet of Things, Information Retrieval and Soft Computing applications in Agriculture, Health and other areas. He has supervised more than twenty post graduate thesis and working as the leader of Intelligent Systems SIG at ASTU Campus."
        },
        {
            "heading": "16 VOLUME 10, 2022",
            "text": "This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/"
        }
    ],
    "title": "Mining High Utility Time Interval Sequences using MapReduce Approach: Multiple Utility Framework",
    "year": 2022
}