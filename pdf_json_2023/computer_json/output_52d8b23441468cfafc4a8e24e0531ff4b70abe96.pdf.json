{
    "abstractText": "The analytic technique for proving completeness gives a very operational perspective: build a countermodel to the unproved formula from a failed proof attempt in your calculus. We have to be careful, however, that the proof attempt did not fail because our strategy in finding it was flawed. Overcoming this concern requires designing a prover. We design and formalize in Isabelle/HOL a sequent calculus prover for firstorder logic with functions. We formalize soundness and completeness theorems using an existing framework and extract executable code to Haskell. The crucial idea is to move complexity from the prover itself to a stream of instructions that it follows. The result serves as a minimal example of the analytic technique, a naive prover for first-order logic, and a case study in formal verification.",
    "authors": [
        {
            "affiliations": [],
            "name": "Asta Halkj\u00e6r"
        },
        {
            "affiliations": [],
            "name": "J\u00f8rgen Villadsen(B"
        }
    ],
    "id": "SP:40a3adafd8ee14fdbdc9fb3037f77b8e9de03850",
    "references": [
        {
            "authors": [
                "M. Ben-Ari"
            ],
            "title": "Mathematical Logic for Computer Science",
            "venue": "Springer, Cham",
            "year": 2012
        },
        {
            "authors": [
                "J.C. Blanchette"
            ],
            "title": "Formalizing the metatheory of logical calculi and automatic provers in Isabelle/HOL (invited talk)",
            "venue": "Mahboubi, A., Myreen, M.O. (eds.) Proceedings of the 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, CPP 2019, pp. 1\u201313. ACM",
            "year": 2019
        },
        {
            "authors": [
                "J.C. Blanchette",
                "A. Popescu",
                "D. Traytel"
            ],
            "title": "Abstract completeness",
            "venue": "Archive of Formal Proofs",
            "year": 2014
        },
        {
            "authors": [
                "J.C. Blanchette",
                "A. Popescu",
                "D. Traytel"
            ],
            "title": "Unified classical logic completeness",
            "venue": "Demri, S., Kapur, D., Weidenbach, C. (eds.) IJCAR 2014. LNCS (LNAI), vol. 8562, pp. 46\u201360. Springer, Cham",
            "year": 2014
        },
        {
            "authors": [
                "J.C. Blanchette",
                "A. Popescu",
                "D. Traytel"
            ],
            "title": "Soundness and completeness proofs by coinductive methods",
            "venue": "J. Autom. Reason. 58(1), 149\u2013179",
            "year": 2016
        },
        {
            "authors": [
                "N. de Bruijn"
            ],
            "title": "Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser theorem",
            "venue": "Nederpelt, R., Geuvers, J., de Vrijer, R. (eds.) Selected Papers on Automath, Studies in Logic and the Foundations of Mathematics, vol. 133, pp. 375\u2013388. Elsevier",
            "year": 1994
        },
        {
            "authors": [
                "A.H. From"
            ],
            "title": "Synthetic completeness for a terminating Seligman-style tableau system",
            "venue": "de\u2019Liguoro, U., Berardi, S., Altenkirch, T. (eds.) 26th International Conference on Types for Proofs and Programs, TYPES 2020, University of Turin, Italy, 2\u20135 March 2020. LIPIcs, vol. 188, pp. 5:1\u20135:17. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik",
            "year": 2020
        },
        {
            "authors": [
                "A.H. From"
            ],
            "title": "Formalized soundness and completeness of epistemic logic",
            "venue": "Silva, A., Wassermann, R., de Queiroz, R.J.G.B. (eds.) WoLLIC 2021. LNCS, vol. 13038, pp. 1\u201315. Springer, Cham",
            "year": 2021
        },
        {
            "authors": [
                "A.H. From"
            ],
            "title": "A succinct formalization of the completeness of first-order logic",
            "venue": "Basold, H., Cockx, J., Ghilezan, S. (eds.) 27th International Conference on Types for Proofs and Programs, TYPES 2021, Leiden, The Netherlands, 14\u201318 June 2021 (Virtual Conference). LIPIcs, vol. 239, pp. 8:1\u20138:24. Schloss Dagstuhl - LeibnizZentrum f\u00fcr Informatik",
            "year": 2021
        },
        {
            "authors": [
                "A.H. From",
                "F.K. Jacobsen"
            ],
            "title": "Verifying a sequent calculus prover for first-order logic with functions in Isabelle/HOL",
            "venue": "Andronick, J., de Moura, L. (eds.) 13th International Conference on Interactive Theorem Proving, ITP 2022, Haifa, Israel, 7\u201310 August 2022. LIPIcs, vol. 237, pp. 13:1\u201313:22. Schloss Dagstuhl - LeibnizZentrum f\u00fcr Informatik",
            "year": 2022
        },
        {
            "authors": [
                "A.H. From"
            ],
            "title": "A Naive prover for first-order logic",
            "venue": "Archive of Formal Proofs",
            "year": 2022
        },
        {
            "authors": [
                "A.H. From",
                "F.K. Jacobsen"
            ],
            "title": "A sequent calculus prover for first-order logic with functions",
            "venue": "Archive of Formal Proofs",
            "year": 2022
        },
        {
            "authors": [
                "A.H. From",
                "A.B. Jensen",
                "A. Schlichtkrull",
                "J. Villadsen"
            ],
            "title": "Teaching a formalized logical calculus",
            "venue": "Electron. Proc. Theor. Comput. Sci. 313, 73\u201392",
            "year": 2020
        },
        {
            "authors": [
                "K. G\u00f6del"
            ],
            "title": "Die Vollst\u00e4ndigkeit der Axiome des logischen Funktionenkalk\u00fcls",
            "venue": "Monatshefte f\u00fcr Mathematik und Physik 37(1), 349\u2013360",
            "year": 1930
        },
        {
            "authors": [
                "L. Henkin"
            ],
            "title": "The discovery of my completeness proofs",
            "venue": "Bull. Symb. Log. 2(2), 127\u2013 158",
            "year": 1996
        },
        {
            "authors": [
                "A.B. Jensen",
                "J.B. Larsen",
                "A. Schlichtkrull",
                "J. Villadsen"
            ],
            "title": "Programming and verifying a declarative first-order prover in Isabelle/HOL",
            "venue": "AI Commun. Eur. J. Artif. Intell. 31(3), 281\u2013299",
            "year": 2018
        },
        {
            "authors": [
                "S.C. Kleene"
            ],
            "title": "Mathematical Logic",
            "venue": "Courier Corporation",
            "year": 2002
        },
        {
            "authors": [
                "J. Michaelis",
                "T. Nipkow"
            ],
            "title": "Formalized proof systems for propositional logic",
            "venue": "Abel, A., Forsberg, F.N., Kaposi, A. (eds.) 23rd International Conference on Types for Proofs and Programs (TYPES 2017). Leibniz International Proceedings in Informatics (LIPIcs), vol. 104, pp. 5:1\u20135:16. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany",
            "year": 2018
        },
        {
            "authors": [
                "T. Nipkow",
                "G. Klein"
            ],
            "title": "Concrete Semantics - With Isabelle/HOL",
            "venue": "Springer, Cham",
            "year": 2014
        },
        {
            "authors": [
                "D. Pastre"
            ],
            "title": "Muscadet 2.3: a knowledge-based theorem prover based on natural deduction",
            "venue": "IJCAR 2001. LNCS,",
            "year": 2001
        },
        {
            "authors": [
                "F.J. Pelletier"
            ],
            "title": "Automated natural deduction in THINKER",
            "venue": "Stud. Logica. 60(1), 3\u201343",
            "year": 1998
        },
        {
            "authors": [
                "T. Ridge",
                "J. Margetson"
            ],
            "title": "A mechanically verified, sound and complete theorem prover for first order logic",
            "venue": "Hurd, J., Melham, T. (eds.) TPHOLs 2005. LNCS, vol. 3603, pp. 294\u2013309. Springer, Heidelberg",
            "year": 2005
        },
        {
            "authors": [
                "A. Schlichtkrull",
                "J.C. Blanchette",
                "D. Traytel"
            ],
            "title": "A verified prover based on ordered resolution",
            "venue": "Proceedings of the 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, CPP 2019, pp. 152\u2013165. Association for Computing Machinery, New York",
            "year": 2019
        },
        {
            "authors": [
                "S. Schulz",
                "A. Pease"
            ],
            "title": "Teaching automated theorem proving by example: PyRes",
            "venue": "IJCAR 2020. LNCS (LNAI),",
            "year": 2020
        },
        {
            "authors": [
                "J. Villadsen",
                "A. Schlichtkrull",
                "A.H. From"
            ],
            "title": "A verified simple prover for first-order logic",
            "venue": "Konev, B., Urban, J., R\u00fcmmer, P. (eds.) Proceedings of the 6th Workshop on Practical Aspects of Automated Reasoning. CEUR Workshop Proceedings, vol. 2162, pp. 88\u2013104. CEUR-WS.org",
            "year": 2018
        }
    ],
    "sections": [
        {
            "text": "Keywords: First-Order Logic \u00b7 Prover \u00b7 Completeness \u00b7 Isabelle/HOL"
        },
        {
            "heading": "1 Introduction",
            "text": "We present a sound and complete (naive) prover for classical first-order logic with functions. There are several ways to prove that a proof system for firstorder logic is complete. Go\u0308del\u2019s approach [14], later refined by Henkin [15] is now known as the synthetic way. This technique abstractly builds maximal consistent (and saturated) sets of formulas as a bridge between the proof system and the semantics. This is a useful technique and has been used in formalizations of the completeness of axiomatic systems for first-order logic [9] and epistemic logic [8], a tableau system for hybrid logic [7] and more. Unfortunately, as pointed out by Blanchette et al. [5] in the context of formalization in Isabelle/HOL, there is no useful connection between this technique and the execution of an actual prover.\nThe technique by Beth and Hintikka [17] offers a more operational perspective. Here, we consider unsuccessful proof attempts in the given calculus and build countermodels from these. Such a countermodel refutes the validity of the formula that we tried to prove. To build such a countermodel, however, we must ensure that the proof attempt was sufficiently sophisticated and, essentially, that it would have found a proof if one existed. In proving this property of the proof strategy, we are effectively designing a prover based on the calculus. This means that, in practice, we can extract a prover from our completeness proof. c\u00a9 The Author(s) 2023 R. Ramanayake and J. Urban (Eds.): TABLEAUX 2023, LNAI 14278, pp. 468\u2013480, 2023. https://doi.org/10.1007/978-3-031-43513-3_25\nBlanchette et al. [5] have made this very concrete by developing a framework in Isabelle/HOL for analytic completeness proofs. Their paper includes a firstorder logic example, but their entry in the Archive of Formal Proofs [3] only includes a propositional example. In this paper, we describe a naive prover based on the framework, designed to be as simple as possible. This augments the framework with a concrete first-order logic example showcasing the analytic technique. Moreover it serves as an introduction to automated reasoning by making explicit the requirements for completeness of a prover for first-order logic. It also serves as a small case study for formal verification in a proof assistant.\nThen the question remains of how to design this proof strategy. We want it to be sufficiently intricate to be both sound and complete, but we also want it to be simple enough that we can reasonably demonstrate these properties (in a proof assistant). We might follow something like Ben-Ari\u2019s tableau algorithm [1] (essentially sequent calculus), but we discover that it is surprisingly complex. There are nodes with labels, branches with markings, and concerns about which kinds of formulas to process first, later or even together. Instead, we will design a prover with minimal structure that tries to apply sequent calculus proof rules over and over, in the belief that we will eventually apply the right ones.\nThe problem changes from working out which rule to apply in a given situation, to designing a stream of instructions that will cover whatever we encounter and embedding enough structure into these instructions to keep the prover itself elementary. This perspective shift greatly simplifies the prover: the rules are indexed by formulas and specify exactly what the prover should do in each case. Moreover, the nodes in the proof tree are simply sequents, no additional state is needed. The rules apply straightforwardly to these sequents to form the next nodes of the tree. This simplifies the completeness proof and makes it a nonissue to handle first-order logic with functions, which can otherwise require extra consideration.\nThe formalization of the (naive) prover is available in the Archive of Formal Proofs [11]. It consists of less than 900 lines of Isabelle/HOL listings, the majority of which are proofs that are not included when exporting Haskell code for the prover. A short, manually written Main.hs file augments the exported code with a command line interface and pretty-printed output. The Isabelle theory Export.thy includes instructions on how to export and compile the Haskell code (which closely resembles the programs listed here). The code in this paper is exported to LATEX by Isabelle from the formalization, but differs slightly in names and layout for presentation reasons. Likewise, to focus on essentials, we often omit the technical commands needed in the formalization."
        },
        {
            "heading": "2 Related Work",
            "text": "Blanchette [2] gives an overview of a number of verification efforts including the metatheory of SAT and SMT solvers, the resolution and superposition calculi, and a series of proof systems for propositional logic [18]. The aim is to develop a methodology for formalizing modern research in automated reasoning and\nthe present work points in this direction with a minimal example of a formally verified prover for classical first-order logic based on the sequent calculus.\nThe prover is based on the abstract completeness framework by Blanchette, Popescu and Traytel [4,5]. Their formalization contains a simple example prover for propositional logic, while their paper contains the ideas for a (naive) prover for first-order logic. Our prover realizes these ideas by formalizing them in Isabelle/HOL. Instead of a prover, Blanchette et al. [5] used the framework to formalize soundness and completeness of a calculus for first-order logic with equality in negation normal form. From and Jacobsen [10,12] used the framework to formalize a much less naive prover for first-order logic based on the SeCaV proof system [13]. Instead of indexed rules, they employ \u201cmulti-rules\u201d that apply to every applicable formula in a sequent at once and they store more than just the sequent at each node in the proof tree. Their prover performs better, but the formalization does not enjoy the simplicity of the naive prover, with close to 3000 lines of Isabelle/HOL against 900 lines.\nThe indexed rules of the naive prover automatically yield readable proofs. In the same vein, THINKER by Pelletier [21] is a natural deduction proof system and attached automated theorem prover, designed for \u201cdirect proofs\u201d, as opposed to proofs based on reduction to a resolution system. MUSCADET by Pastre [20] is another automated theorem prover based on natural deduction. Neither of these has been formally verified. Schulz and Pease [24] focused on readable code rather than proofs. They have developed a saturation-based theorem prover in Python for first-order logic to teach automated theorem proving by example. They have not formally verified soundness and completeness, but our projects are similar.\nIn the world of formalization, Schlichtkrull et al. [23] formalized an ordered resolution prover for clausal first-order logic in Isabelle/HOL. Jensen et al. [16] formalized the soundness, but not the completeness, of a prover for first-order logic with equality in Isabelle/HOL. Villadsen et al. [25] verified a simple prover for first-order logic in Isabelle/HOL aiming for students to understand both the prover and the formalization. That work simplified a formalization by Ridge and Margetson [22]. Neither of the last two provers support functions."
        },
        {
            "heading": "3 Isabelle/HOL Overview",
            "text": "We give a quick overview of the Isabelle/HOL features used in the present paper. Nipkow and Klein [19, Part 1] give a more complete introduction.\nThe datatype command defines a new inductive type from a series of constructors, where each can be given custom syntax. The natural numbers are built from the nullary constructor 0 and unary Suc. The constructors True and False belong to the built-in type bool. The usual connectives and quantifiers from first-order logic (\u2212\u2192, \u2200 , etc.) are available for bool, as well as if-then-else expressions. The parametric \u2032a list is the type of lists with elements of type \u2032a. The type variable \u2032a stands in the place of another type. Lists are built from [], the empty list, and #, an infix constructor that adjoins an element to an\nexisting list. The notation [a, b, c] is shorthand for these primitive operations. The function set turns a list into a set of its elements, map applies a given function to every element of a list, @ appends two lists, concat flattens a list of lists and upt j k creates the list [j, j + 1, . . . , k \u2212 1]. We use [\u2208] for list membership and [\u00f7] to remove all occurrences of a given element from a list. The two types \u2032a set and \u2032a fset form sets and finite sets respectively. The usual operations are available on sets. On finite sets they are typically prefixed by f as in fimage. Two additional types are important: sum types with the two unary constructors Inl and Inr, and option types constructed by the unary Some or nullary None. Constructors can be examined using case expressions.\nThe codatatype command defines a new coinductive type from a series of constructors. The canonical example is the type \u2032a stream of \u201clists with no base case\u201d, i.e. infinite sequences. The functions shd and stl return the head and tail of a stream, respectively, while flat transforms a stream of lists into a stream of all the elements in the constituent lists, sset returns a set of its elements, smap applies a function to every element, !! returns the element at a given index and sdrop-while removes a prefix of a stream that satisfies a given predicate. The stream nats contains all natural numbers.\nThe type A \u21d2 B denotes a function from A to B. Type signatures are specified after \u201c::\u201d. Types can be shortened using type synonyms. The term UNIV stands for the set of all values of a given type. In this paper, both = and \u2261 are used to form new definitions. Function application resembles functional programming languages: f(x, y) is written as f x y and partial application is allowed. Anonymous functions are built using \u03bb-expressions, e.g. \u03bbn. n + n for f(n) = n + n.\nA locale in Isabelle/HOL fixes a number of terms, then assumes a number of properties about those terms. The meta-logical implication =\u21d2 separates premises from conclusions in each assumption. The keyword and acts as a separator. A locale for a group, for instance, fixes a set and a binary operation and assumes the group axioms."
        },
        {
            "heading": "4 First-Order Logic in Isabelle/HOL",
            "text": "Figure 1 contains a formalization of the syntax of first-order logic as a datatype in Isabelle/HOL. The syntax is deeply embedded as an object in the meta-logic so we can manipulate it. We use de Bruijn indices [6] to represent binding: each variable n is bound by the quantifier that is n quantifiers away, moving outwards.\nA term t, type tm, is then either a variable #n for some de Bruijn index n (a natural number) or a function application \u2020f [. . .] for some natural number f representing the function name and list of argument terms. [. . .]. A formula p, type fm, is the constant for falsity, \u22a5, a predicate \u2021P [. . .] for some natural number P representing the predicate name and list of argument terms [. . .], an implication p1 \u2212\u2192 p2 between two formulas p1, p2 or a universally quantified formula \u2200p.\nFigure 2 contains a formalization of the semantics in Isabelle/HOL. A model consists of three denotations: one each for variables (E ), function symbols (F ) and predicate symbols (G). Terms evaluate to a member of the domain, here represented as a type variable, while formulas evaluate to truth values in the higher-order logic. We can use the connectives and quantifiers of Isabelle/HOL to interpret the first-order logic syntax. For the universal quantifier, we modify the environment such that we evaluate the quantified variable 0 as every element of the domain.\nFigure 3 lists the rules for instantiating a quantifier with a term without capturing any free variables in the process. The operation lift-tm increments every variable in the term t by one. The operation sub-tm s t applies the substitution s to every variable in term t. The operation sub-fm s p applies the substitution s to the formula p, taking account of binders. In the case for \u2200p, the substitution is augmented using o9 to preserve the bound variable #0 in p and to lift the variables in the output of the substitution s to point past the binder. We write the instantiation of a quantified formula \u2200p with a concrete term t as \u3008t\u3009p. The notation \u3008t\u3009 represents the simultaneous substitution that maps variable 0 to t and every other variable n + 1 to n to account for the removed binder. Figure 4 lists the operations for generating a variable fresh to a list of formulas, i.e. one that does not appear in any formula in the list.\nThe calculus works on two-sided sequents, of type sequent, which are represented as pairs of lists of formulas (cf. Fig. 5). We can think of the left-hand side as assumptions and the right-hand side as conclusions. Moreover, the left-hand side is conjunctive, so we can assume all of the formulas there to be true, while the right-hand side is disjunctive, so we only need to prove one.\nSequent calculus has the benefit of the subformula property : to prove a formula we only need to look at its subformulas. Contrast this with axiomatic systems using modus ponens (from p \u2212\u2192 q and p infer q), where we need to guess a suitable \u201clemma\u201d formula. However, a sequent calculus may still leave too much freedom for comfort. In particular, we want to remove the need for structural rules, since these are too applicable.\nFigure 6 lists the underlying rules of the prover in a somewhat idiosyncratic manner. The reason will become apparent later. Each rule has a name to the left of the horizontal line. Below the horizontal line is the conclusion and above are the premises, if any. Any side conditions are given to the right of the line. Note that each rule is indexed by the exact (sub)formulas it works on: the rule Axiom 0 [] is distinct from the rule Axiom 1 [] etc. This rigidity means that we do not need any structural rules. It also means that there is no pattern matching in any of the rules and that the three primary operations are membership checking ([\u2208]), removal of concrete formulas ([\u00f7]) and adding new formulas to a list (#).\nThe Idle rule appears for technical reasons (there should always be an enabled rule). The Axiom rule is indexed by a predicate symbol P and argument list ts and checks whether such a predicate appears on both sides of the sequent: if so, the rule applies and there are no child sequents. The FlsL rule checks if \u22a5 occurs among the assumptions, in which case the sequent is proved. The FlsR rule, when it applies, drops all occurrences of \u22a5 from the conclusions, since we\ncan never prove any of them. The ImpL and ImpR rules decompose implications on either side of the sequent in the standard way. The UniL rule is indexed by a term t and a formula p. If \u2200p occurs on the left, then the rule instantiates it with t, adding \u3008t\u3009p to the left-hand side of the child sequent. The UniR rule is only indexed by a formula p. When \u2200p occurs on the right, it is instantiated with a fresh variable and removed.\nIn order to obtain a prover based on the rules of the sequent calculus we use the abstract completeness framework for Isabelle/HOL developed by Blanchette, Popescu and Traytel [3,5]. This framework formalizes the mechanics of sequent calculus and semantic tableaux provers in an abstract way that we can instantiate with concrete rules. There are two possible perspectives on the framework: (i) the proof perspective, where we use the framework to obtain theorems about proof trees built from our rules and (ii) the code generation perspective, where we use the framework to generate an executable prover. In this paper, both perspectives come into play but the two perspectives can be used on their own.\nThe framework needs: a stream of rules, a function describing their effect, a proof that some rule is always enabled and a guarantee that rules are persistent. We formalize the calculus in Isabelle/HOL as a datatype of rules, rule, with constructors Idle, Axiom, FlsL, FlsR, ImpL, ImpR, UniL and UniR, and an effect function, eff, that encodes the relationship between premises and conclusions in the manner expected by the framework."
        },
        {
            "heading": "5 Soundness and Completeness",
            "text": "Soundness requires that we do not prove a sequent without having proper reasons to do so. It is a local property of our calculus that we can easily check. Completeness, on the other hand, requires that we have sufficient rules available to prove every valid formula. Thus, proving completeness requires a more involved strategy.\nLemma 1 (Local soundness). If all premises of a rule are valid, then its conclusion is valid. In Isabelle, if eff r (A, B) = Some ss and \u2200A B . (A, B) |\u2208| ss \u2212\u2192 (\u2200 (E :: - \u21d2 \u2032a). sc (E , F , G) (A, B)), then sc (E , F , G) (A, B). Proof. By induction on the call structure of eff. The induction hypothesis then applies to the sequents produced by eff. All cases except UniR are trivial. For UniR, by the induction hypothesis, the premise holds under all variable denotations: no matter the assignment to the fresh variable. This justifies forming the universal quantifier and since the fresh variable does not appear elsewhere in the sequent, the semantics there are unaffected.\nTheorem 1 (Prover soundness). If a proof tree (attempt) is well formed and finite, then the root sequent is valid. In Isabelle, if tfinite t and wf t, then sc (E , F , G) (fst (root t)).\nProof. By induction on the finite proof tree using Lemma 1.\nFor completeness we must now show that, for every valid sequent, the prover finds a proof. We do so contrapositively: if the prover does not find a proof, we produce a countermodel to the sequent. To do so, we characterize saturated escape paths syntactically using Hintikka sets and show that such sets induce countermodels. Figure 7 characterizes Hintikka sets in our setting. There are two perspectives on these: one, that they characterize saturated escape paths and two, that they characterize the semantics of the countermodel.\nTo understand the first perspective, read the set A as consisting of all formulas that appear as assumptions on the saturated escape path (on the left-hand side of sequents) and the set B as consisting of all formulas that appear as conclusions (on the right-hand side of sequents). The Isabelle/HOL functions treeA and treeB collect these sets, respectively.\nLemma 2 (Hintikka sets characterize saturated escape paths). Let A and B be sets of assumption and conclusion formulas on a saturated escape path. Then they fulfill all Hintikka requirements. In Isabelle, if epath steps and Saturated steps, then Hintikka (treeA steps) (treeB steps).\nProof. We check each condition separately. Basic states that a predicate cannot appear as both assumption and conclusion on the epath. Otherwise the Axiom rule would have terminated the (infinite) epath.\nFlsA states that \u22a5 does not appear among the assumptions. Similar to the above, the FlsL rule would have terminated the epath if so.\nImpA and ImpB break down implications in accordance with the ImpL and ImpR rules. For a given p, q, if p \u2212\u2192 q appears in A (respectively B), then at some point in the proof tree attempt, the rule ImpL p q (respectively ImpR p q) becomes enabled. Since the epath is saturated, any enabled rule is eventually taken and the effect matches the thesis.\nUniA states that any universally quantified formula \u2200p on the left is instantiated with all possible terms. Fix an arbitrary term t. Since \u2200p occurs as an assumption, the specific rule UniL p t is eventually enabled, taken, and has the desired effect.\nUniB is similar, except the witnessing term is the fresh variable.\nRemark 1. We see the usefulness of indexed rules in the above proof. If we simply had an ImpR rule, rather than an ImpR p q rule for each formula p and q, we would have to further argue that this rule eventually applies to exactly the implication p \u2212\u2192 q we need it to. Perhaps we need to argue first that p \u2212\u2192 q eventually reaches the front of the sequent or similar delicate reasoning. This is where fairness concerns would show up. We have sidestepped the issue by using very specific rules.\nConsider now the second perspective. The countermodel in Fig. 7 uses the term universe (also called Herbrand universe) where every variable and function symbol evaluates to itself. Thus, the universal quantifier, which ranges over a given domain, ranges over terms. Now, read the sets A and B as formulas we wish to satisfy and falsify, respectively.\nLemma 3 (A Hintikka set induces a countermodel). Let A and B be sets of formulas fulfilling the Hintikka requirements. Then M A satisfies formulas in A and falsifies formulas in B. In Isabelle, if Hintikka A B then (p \u2208 A \u2212\u2192 M A p) \u2227 (p \u2208 B \u2212\u2192 \u00ac M A p). Proof. By well founded induction on the size of the formula, such that the induction hypothesis applies to subformulas and instances of universally quantified formulas.\nFor \u22a5 \u2208 A, this contradicts FlsA so the thesis holds vacuously. For \u22a5 \u2208 B, the thesis holds trivially since \u22a5 is falsified by every model.\nFor \u2020P ts \u2208 A, the thesis holds by the definition of M. For \u2020P ts \u2208 B, we cannot have \u2020P ts \u2208 A due to Basic and so the thesis holds by the definition of M.\nFor p \u2212\u2192 q \u2208 A and p \u2212\u2192 q \u2208 B the theses hold by the induction hypotheses at p and q and the conditions ImpA and ImpB, respectively.\nFor \u2200p \u2208 A and \u2200p \u2208 B the theses hold by the induction hypotheses at \u3008t\u3009p for all t and by the conditions UniA and UniB, respectively.\nAny saturated escape path induces a countermodel, contradicting validity.\nTheorem 2 (Prover completeness). For any valid sequent, the prover terminates.\nProof. If the prover does not find a proof, then by the framework, the proof attempt contains a saturated escape path. By Lemma 2, this epath fulfills the Hintikka requirements. By Lemma 3, we can build a model that satisfies every assumption formula and falsifies every conclusion formula. This model contradicts the validity of the sequent.\nWe join the soundness and completeness theorems in a corollary on formulas.\nCorollary 1. The prover terminates if, and only if, the given formula is valid. In Isabelle, fix p :: fm and let t \u2261 prover ([], [p]), then tfinite t \u2227 wf t \u2190\u2192 (\u2200 (E :: - \u21d2 tm) F G . [[E , F , G ]] p)."
        }
    ],
    "title": "A Naive Prover for First-Order Logic: A Minimal Example of Analytic Completeness",
    "year": 2023
}