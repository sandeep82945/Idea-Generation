{
    "abstractText": "We identify and demonstrate a weakness of Petri Nets (PN) in specifying composite behavior of reactive systems. Specifically, we show how, when specifying multiple requirements in one PN model, modelers are obliged to specify mechanisms for combining these requirements. This yields, in many cases, over-specification and incorrect models. We demonstrate how some execution paths are missed, and some are generated unintentionally. To support this claim, we analyze PN models from the literature, identify the combination mechanisms, and demonstrate their effect on the correctness of the model. To address this problem, we propose to model the system behavior using behavioral programming (BP), a software development and modeling paradigm designed for seamless integration of independent requirements. Specifically, we demonstrate how the semantics of BP, which define how to interweave scenarios into a single model, allow for avoiding the over-specification. Additionally, while BP maintains the same mathematical properties as PN, it provides means for changing the model dynamically, thus increasing the agility of the specification. We compare BP and PN in quantitative and qualitative measures by analyzing the models, their generated execution paths, and the specification process. Finally, while BP is supported by tools that allow for applying formal methods and reasoning techniques to the model, it lacks the legacy of PN tools and algorithms. To address this issue, we propose semantics and a tool for translating BP models to PN and vice versa.",
    "authors": [
        {
            "affiliations": [],
            "name": "Achiya Elyasaf"
        },
        {
            "affiliations": [],
            "name": "Gera Weiss"
        }
    ],
    "id": "SP:d4f847d3e2e245ed568e5dd663ae60cb799c55f5",
    "references": [
        {
            "authors": [
                "H.K. Pae"
            ],
            "title": "From linguistic relativity to script relativity",
            "venue": "Script Effects as the Hidden Drive of the Mind, Cognition, and Culture, Berlin, Germany: Springer, 2020, pp. 37\u201358.",
            "year": 2020
        },
        {
            "authors": [
                "G. Deutscher"
            ],
            "title": "Through the Language Glass: Why the World Looks Different in Other Languages",
            "year": 2010
        },
        {
            "authors": [
                "K.E. Iverson"
            ],
            "title": "Notation as a tool of thought",
            "venue": "Commun. ACM, vol. 23, no. 8, pp. 444\u2013465, Aug. 1980.",
            "year": 1980
        },
        {
            "authors": [
                "Y. Matsumoto"
            ],
            "title": "The power and philosophy of ruby (or, how to create babel-17)",
            "venue": "Aug. 2003. [Online]. Available: https://web. archive.org/web/20040404075831/http://www.rubyist.net/ ~matz/slides/oscon2003/index.html",
            "year": 2003
        },
        {
            "authors": [
                "J.A. Moyne"
            ],
            "title": "Relevance of computer science to linguistics and vice versa",
            "venue": "Int. J. Comput. Informat. Sci., vol. 4, no. 3, pp. 265\u2013279, 1975.",
            "year": 1975
        },
        {
            "authors": [
                "J. Chen"
            ],
            "title": "Linguistic relativity and programming languages",
            "venue": "2018, arXiv: 1808.03916.",
            "year": 2018
        },
        {
            "authors": [
                "D. Harel",
                "A. Marron",
                "G. Weiss"
            ],
            "title": "Behavioral programming",
            "venue": "Commun. ACM, vol. 55, no. 7, pp. 90\u2013100, 2012.",
            "year": 2012
        },
        {
            "authors": [
                "A. Elyasaf"
            ],
            "title": "Context-oriented behavioral programming",
            "venue": "Informat. Softw. Technol., vol. 133, May 2021, Art. no. 106504. [Online]. Available: http://www.sciencedirect.com/science/article/pii/ S095058492030094X",
            "year": 2021
        },
        {
            "authors": [
                "A. Marron",
                "G. Weiss",
                "G. Wiener"
            ],
            "title": "A decentralized approach for programming interactive applications with javascript and blockly",
            "venue": "Proc. 2nd Ed. Program. Syst., Lang. Appl. Based Actors, Agents, Decentralized Control Abstractions, 2012, pp. 59\u201370.",
            "year": 2012
        },
        {
            "authors": [
                "A. Elyasaf",
                "A. Marron",
                "A. Sturm",
                "G. Weiss"
            ],
            "title": "A context-based behavioral language for IoT",
            "venue": "Proc. MODELS Workshops, 2018, pp. 485\u2013494.",
            "year": 2018
        },
        {
            "authors": [
                "G. Alexandron",
                "M. Armoni",
                "M. Gordon",
                "D. Harel"
            ],
            "title": "Scenariobased programming, usability-oriented perception",
            "venue": "ACM Trans. Comput. Educ., vol. 14, no. 3, pp. 1\u201323, 2014.",
            "year": 2014
        },
        {
            "authors": [
                "D. Harel",
                "M. Gordon-Kiwkowitz"
            ],
            "title": "On teaching visual formalisms",
            "venue": "IEEE Softw., vol. 26, no. 3, pp. 87\u201395, May/Jun. 2009.",
            "year": 2009
        },
        {
            "authors": [
                "M. Bar-Sinai",
                "A. Elyasaf",
                "A. Sadon",
                "G. Weiss"
            ],
            "title": "A scenario based on-board software and testing environment for satellites",
            "venue": "Proc. 59th Isr. Annu. Conf. Aerosp. Sci., 2019, pp. 1407\u20131419.",
            "year": 2019
        },
        {
            "authors": [
                "A. Elyasaf",
                "A. Sadon",
                "G. Weiss",
                "T. Yaacov"
            ],
            "title": "Using behavioural programming with solver, context, and deep reinforcement learning for playing a simplified robocup-type game",
            "venue": "Proc. IEEE/ ACM 22nd Int. Conf. Model Driven Eng. Lang. Syst. Companion, 2019, pp. 243\u2013251.",
            "year": 2019
        },
        {
            "authors": [
                "G. Katz",
                "A. Marron",
                "A. Sadon",
                "G. Weiss"
            ],
            "title": "On-the-fly construction of composite events in scenario-based modeling using constraint solvers",
            "venue": "2019, arXiv:1909.00408.",
            "year": 2019
        },
        {
            "authors": [
                "M. Bar-Sinai",
                "G. Weiss",
                "R. Shmuel"
            ],
            "title": "BPJS: An extensible, open infrastructure for behavioral programming research",
            "venue": "Proc. 21st IEEE/ACM Int. Conf. Model Driven Eng. Lang. Syst. Companion, 2018, pp. 59\u201360.",
            "year": 2018
        },
        {
            "authors": [
                "D. Harel",
                "R. Lampert",
                "A. Marron",
                "G. Weiss"
            ],
            "title": "Model-checking behavioral programs",
            "venue": "Proc. 9th ACM Int. Conf. Embedded Softw., 2011, pp. 279\u2013288.",
            "year": 2011
        },
        {
            "authors": [
                "D. Harel",
                "A. Kantor",
                "G. Katz"
            ],
            "title": "Relaxing synchronization constraints in behavioral programs",
            "venue": "Proc. Int. Conf. Log. Program. Artif. Intell. Reasoning, 2013, pp. 355\u2013372.",
            "year": 2013
        },
        {
            "authors": [
                "D. Harel",
                "H. Kugler",
                "R. Marelly",
                "A. Pnueli"
            ],
            "title": "Smart play-out of behavioral requirements",
            "venue": "Proc. Int. Conf. Formal Methods Comput.-Aided Des., 2002, pp. 378\u2013398.",
            "year": 2002
        },
        {
            "authors": [
                "H. Kugler",
                "C. Plock",
                "A. Roberts"
            ],
            "title": "Synthesizing biological theories",
            "venue": "Proc. Int. Conf. Comput. AidedVerification, 2011, pp. 579\u2013584.",
            "year": 2011
        },
        {
            "authors": [
                "S. Maoz",
                "Y. Sa\u2019ar"
            ],
            "title": "Counter play-out: Executing unrealizable scenario-based specifications",
            "venue": "Proc. IEEE 35th Int. Conf. Softw. Eng., 2013, pp. 242\u2013251.",
            "year": 2013
        },
        {
            "authors": [
                "D. Harel",
                "A. Marron",
                "G. Weiss"
            ],
            "title": "Programming coordinated behavior in java",
            "venue": "Proc. Eur. Conf. Object-Oriented Program., 2010, pp. 250\u2013274.",
            "year": 2010
        },
        {
            "authors": [
                "D. Harel",
                "R. Marelly"
            ],
            "title": "Come, let\u2019s Play: Scenario-Based Programming",
            "venue": "Using LSCs and the Play-Engine,",
            "year": 2003
        },
        {
            "authors": [
                "N.G. Leveson",
                "J.L. Stolzy"
            ],
            "title": "Safety analysis using petri nets",
            "venue": "IEEE Trans. Softw. Eng., vol. 13, no. 3, pp. 386\u2013397, Mar. 1987.",
            "year": 1987
        },
        {
            "authors": [
                "B. Liu",
                "M. Ghazel",
                "A. Toguy eni"
            ],
            "title": "OF-PENDA: A software tool for fault diagnosis of discrete event systems modeled by labeled petri nets",
            "venue": "inProc. Int.WorkshopADECS@Petri Nets, 2014, pp. 20\u201335.",
            "year": 2014
        },
        {
            "authors": [
                "M. Ghazel",
                "B. Liu"
            ],
            "title": "A customizable railway benchmark to deal with fault diagnosis issues in des",
            "venue": "Proc. IEEE 13th Int. Workshop Discrete Event Syst., 2016, pp. 177\u2013182.",
            "year": 2016
        },
        {
            "authors": [
                "A. Mazzeo",
                "N. Mazzocca",
                "S. Russo",
                "V. Vittorini"
            ],
            "title": "A systematic approach to the petri net based specification of concurrent systems",
            "venue": "Safety-Critical Real-Time Systems. Berlin, Germany: Springer, 1997, pp. 3\u201320.",
            "year": 1997
        },
        {
            "authors": [
                "Y.-K. Tsay",
                "Y.-F. Chen",
                "M.-H. Tsai",
                "K.-N. Wu",
                "W.-C. Chan"
            ],
            "title": "Goal: A graphical tool for manipulating b\u20ac uchi automata and temporal formulae",
            "venue": "Proc. Int. Conf. Tools Algorithms Construction Anal. Syst., 2007, pp. 466\u2013471.",
            "year": 2007
        },
        {
            "authors": [
                "A. Boussif"
            ],
            "title": "Contributions to model-based diagnosis of discreteevent systems",
            "venue": "Ph.D. dissertation, Universit e de Lille1-Sciences et Technologies, Villeneuve-d\u2019Ascq, France, 2016.",
            "year": 2016
        },
        {
            "authors": [
                "A. Boussif",
                "B. Liu",
                "M. Ghazel"
            ],
            "title": "An experimental comparison of three diagnosis techniques for discrete event systems",
            "venue": "Proc. 28th Int. Workshop Princ. Diagnosis, 2017, Art. no. 8.",
            "year": 2017
        },
        {
            "authors": [
                "G. Liu",
                "C. Jiang",
                "M. Zhou"
            ],
            "title": "Time-soundness of time petri nets modelling time-critical systems",
            "venue": "ACM Trans. Cyber-Phys. Syst., vol. 2, no. 2, pp. 1\u201327, 2018.",
            "year": 2018
        },
        {
            "authors": [
                "F. Pommereau"
            ],
            "title": "Snakes: A flexible high-level petri nets library (tool paper)",
            "venue": "Proc. Int. Conf. Appl. Theory Petri Nets Concurrency, 2015, pp. 254\u2013265.",
            "year": 2015
        },
        {
            "authors": [
                "I. Poliakov",
                "V. Khomenko",
                "A. Yakovlev"
            ],
            "title": "Workcraft\u2013A framework for interpreted graph models",
            "venue": "Proc. Int. Conf. Appl. Theory Petri Nets, 2009, pp. 333\u2013342.",
            "year": 2009
        },
        {
            "authors": [
                "D. Sokolov",
                "V. Khomenko",
                "A. Mokhov"
            ],
            "title": "Workcraft: Ten years later",
            "venue": "This Asynchronous World. Essays Dedicated Alex Yakovlev Occasion 60th Birthday, 2016, pp. 269\u2013293. [Online]. Available: http://homepages.cs.ncl.ac.uk/victor.khomenko/papers/Alex- Festschrift.pdf",
            "year": 2016
        },
        {
            "authors": [
                "T. Yaacov"
            ],
            "title": "Extending behavioral programming towards improved software engineering practices",
            "venue": "PhD dissertation, Ben- Gurion University of the Negev, Beer-Sheva, Israel, 2021.",
            "year": 2021
        },
        {
            "authors": [
                "R. Davidrajuh"
            ],
            "title": "Verifying solutions to the dining philosophers problem with activity-oriented petri nets",
            "venue": "Proc. IEEE 4th Int. Conf. Artif. Intell. Appl. Eng. Technol., 2014, pp. 163\u2013168.",
            "year": 2014
        },
        {
            "authors": [
                "A. Giua",
                "M. Silva"
            ],
            "title": "Modeling, analysis and control of discrete event systems: A petri net perspective",
            "venue": "IFAC-PapersOnLine, vol. 50, no. 1, pp. 1772\u20131783, 2017.",
            "year": 2017
        },
        {
            "authors": [
                "P. Soboci nski"
            ],
            "title": "Representations of petri net interactions",
            "venue": "Proc. Int. Conf. Concurrency Theory, 2010, pp. 554\u2013568.",
            "year": 2010
        },
        {
            "authors": [
                "R. Bruni",
                "H. Melgratti",
                "U. Montanari",
                "P. Sobocinski"
            ],
            "title": "Connector algebras for C/E and P/T nets\u2019 interactions",
            "venue": "Log. Methods Comput. Sci., vol. 9, no. 3, pp. 1\u201365, Sep. 2013.",
            "year": 2013
        },
        {
            "authors": [
                "R. Devillers"
            ],
            "title": "Articulations and products of transition systems and their applications to petri net synthesis",
            "venue": "Fundamenta Informaticae, vol. 183, pp. 1\u201331, 2021.",
            "year": 2021
        },
        {
            "authors": [
                "P. Baldan",
                "A. Corradini",
                "H. Ehrig",
                "R. Heckel"
            ],
            "title": "Compositional modeling of reactive systems using open nets",
            "venue": "Proc. Int. Conf. Concurrency Theory, 2001, pp. 502\u2013518.",
            "year": 2001
        },
        {
            "authors": [
                "E. Kindler",
                "L. Petrucci"
            ],
            "title": "Towards a standard for modular petri nets: A formalisation",
            "venue": "Proc. Int. Conf. Appl. Theory Petri Nets, 2009, pp. 43\u201362. 2316 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 49, NO. 4, APRIL 2023",
            "year": 2009
        },
        {
            "authors": [
                "R. Eshuis",
                "J. Dehnert"
            ],
            "title": "Reactive petri nets for workflow modeling",
            "venue": "Proc. Int. Conf. Appl. Theory Petri Nets, 2003, pp. 296\u2013315.",
            "year": 2003
        },
        {
            "authors": [
                "D. Harel",
                "A. Marron",
                "G. Wiener",
                "G. Weiss"
            ],
            "title": "Behavioral programming, decentralized control, and multiple time scales",
            "venue": "Proc. Compilation Co-Located Workshops DSM, TMC, AGERE, AOOPES, NEAT, VMIL, 2011, pp. 171\u2013182.",
            "year": 2011
        },
        {
            "authors": [
                "C.M. Kirsch",
                "A. Sokolova"
            ],
            "title": "The logical execution time paradigm",
            "venue": "Advances in Real-Time Systems, Berlin, Germany: Springer, 2012, pp. 103\u2013120.",
            "year": 2012
        }
    ],
    "sections": [
        {
            "text": "Specifically, we show how, when specifying multiple requirements in one PN model, modelers are obliged to specify mechanisms for combining these requirements. This yields, in many cases, over-specification and incorrect models. We demonstrate how some execution paths are missed, and some are generated unintentionally. To support this claim, we analyze PN models from the literature, identify the combination mechanisms, and demonstrate their effect on the correctness of the model. To address this problem, we propose to model the system behavior using behavioral programming (BP), a software development and modeling paradigm designed for seamless integration of independent requirements. Specifically, we demonstrate how the semantics of BP, which define how to interweave scenarios into a single model, allow for avoiding the over-specification. Additionally, while BP maintains the same mathematical properties as PN, it provides means for changing the model dynamically, thus increasing the agility of the specification. We compare BP and PN in quantitative and qualitative measures by analyzing the models, their generated execution paths, and the specification process. Finally, while BP is supported by tools that allow for applying formal methods and reasoning techniques to the model, it lacks the legacy of PN tools and algorithms. To address this issue, we propose semantics and a tool for translating BP models to PN and vice versa.\nIndex Terms\u2014Petri nets, behavioral programming, linguistic relativity\n\u00c7"
        },
        {
            "heading": "1 INTRODUCTION",
            "text": "THE linguistic relativity hypothesis says that the languageswe speak influence our worldview or cognition. While early linguistics believed that language determines thought, it is now commonly accepted that language influences only certain cognitive processes in non-trivial ways [1]. Deutscher [2] for example, says, \u201cwhen your language routinely obliges you to specify certain types of information, it forces you to be attentive to certain details in the world and to certain aspects of experience that speakers of other languages may not be required to think about all the time.\u201d\nThe linguistic-relativity hypothesis has been a guiding principle for computer languages, from early to modern ones, that were designed to direct programmers to change and adapt their thinking to the way machines \u201cthink\u201d. There are many examples: Iverson argued that notations aid in thinking about computer algorithms [3], Matz says that he was inspired by this hypothesis when creating the Ruby language [4], and many more [5], [6]. While linguistics\nresearchers have moved to \u201csofter\u201d versions of the theorem, in software engineering, to the best of our knowledge, computer-language researchers are still guided by the early version of the theorem,with one exempt, as discussed below.\nIn this work, we follow Deutcher and demonstrate how the Petri net (PN) language routinely obliges users to specify things that they do not wish to specify, resulting in unexpected complications and even incorrect specifications. Specifically, we show how the attempt to specify multiple requirements in one PN model forces users to specify also mechanisms for combining these requirements, resulting in over-specification and possibly incorrect models, as some execution paths are missed and some are generated unintentionally.\nPetri net (PN) is a modeling language with formal semantics that allow for both executing the model and analyzing it. The formal semantics differentiate PN from other process and behavioral modeling languages, such as activity and sequence diagrams. The ability to synthesize the model into working software and analyze it makes it commonly used for modeling and programming discrete event systems (DES) \u2013 dynamic systems with discrete, potentially infinite, state space. A comprehensive introduction to PN can be found in [7].\nIn Section 9 we survey behavior-composition approaches for PN that have been proposed over the years. Nevertheless, these approaches require modelers to consider all the mutual dependencies directly. As we demonstrate in this paper, this may not be feasible in some cases.\nTo support our claim on PN,we beginwith an analysis of a knownDES benchmark, called level crossing, and demonstrate the inaccuracy of several PN models for this benchmark. To address this problem, we propose a different modeling and\nAchiya Elyasaf is with the Software and Information Systems Engineering Department, Ben-Gurion University of the Negev, 84105 Beersheba, Israel. E-mail: achiya@bgu.ac.il. Tom Yaacov and Gera Weiss are with the Computer Science Department, Ben-Gurion University of the Negev, 26732 Beersheba, Israel. E-mail: tomya@post.bgu.ac.il, geraw@cs.bgu.ac.il.\nManuscript received 6 January 2022; revised 12 July 2022; accepted 17 October 2022. Date of publication 25 October 2022; date of current version 18 April 2023. This work was supported in part by the Israeli Science Foundation under Grant #2714/19 and in part by the Israeli Smart Transportation Research Center (ISTRC). (Corresponding author: Achiya Elyasaf.) Recommended for acceptance by P. Spoletini. Digital Object Identifier no. 10.1109/TSE.2022.3216683\nThis work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/\nprogramming paradigm, called behavioral programming (BP), that allows for a direct specification, execution, and verification of requirements. Like PN, BP is supported by tools for applying formal methods and reasoning techniques to the model. Nevertheless, to keep the legacy of PN tools and algorithms, we propose tools for translating BPmodels to PN and vice versa. As we will show, our approach has the following advantages:\nIt supports a modular specification approach where each module isolates a specific aspect of the system behavior. It allows modelers to specify the behavior only, exempting them from specifying mechanisms of combining the behaviors. It allows for applying formal methods and reasoning techniques for analyzing and verifying different properties of the system behavior, such as reachability, liveness, boundedness, etc. These algorithms can be executed in a compositional way, thus handling large-scale programs. We present transnational semantics from the BP model to the PN and vice versa. This translation supports current PN-based practices and algorithms. Furthermore, to avoid the necessity of verifying properties of both the BP model and the PN model, we propose an algorithm and a tool for comparing the two models and testing their equivalency. Thus, our approach allows PNmodelers to verify the requirements\u2019 correctness and the alignment between the requirements and their implementation.\nPN has many extensions and variations. In this paper, we compare BP to the basic PN formalism and arguably the most familiar one. Nevertheless, we discuss some of these extensions in Section 9.\nThe rest of the paper continues as follows. Section 2 gives a short primer on behavioral programming, followed by a general description of the level-crossing benchmark in Section 3. We model the benchmark requirements with BP in Section 4 and with PN in Section 5. In Section 6, we provide an algorithm for comparing the two models and use it for demonstrating how the mechanism specification in PN results in incorrect behavior. In Section 7, we provide translational semantics between the two models. In Section 8, we complete our analysis with more PN models and quantitative comparison between BP and PN. We conclude the paper with a survey of related work (Section 9) and a short discussion (Section 10)."
        },
        {
            "heading": "2 A SHORT PRIMER ON BEHAVIORAL PROGRAMMING",
            "text": "The behavioral programming paradigm focuses on constructing reactive systems incrementally from their expected behaviors [8], [9]. When creating a system using BP, developers specify a set of scenarios that may, must, or must not happen. Each scenario is a simple sequential thread of execution and is thus called a b-thread. B-threads are typically aligned with system requirements, such as \u201ctrain may not enter when barriers are up\u201d. The set of bthreads in a model is called a behavioral program (b-\nprogram). During runtime, an application-agnostic execution engine interweaves all b-threads participating in a b-program, yielding a complex behavior consistent with all said b-threads. As we will show, this execution engine exempts the modelers from specifying how the requirements interact.\nBP is interesting from the linguistic-relativity perspective. Instead of directing its users to a particular way of thinking, the main design goal of the paradigm is precisely the opposite. It aims to enable modelers to specify reactive systems\u2019 behavior in a natural and intuitive manner that is aligned with how they perceive the system requirements. To address this goal, several extensions to the paradigm have been proposed to improve this alignment and remove the necessity of specifying mechanisms [9], [10], [11]. Also, user studies measured the naturalness and intuitiveness of the paradigm, compared to other paradigms [12], [13].\nPrevious demonstrations of BP include a showcase of a fully functional nano-satellite [14], robotic controllers [15], [16], a reactive IoT building [11], a development tool with an integrated model-checking tool [17], and more. Research results on BP cover, among others, model-checking [18], compositional verification [19], runtime look-ahead [20], synthesis [21] interactive analysis of unrealizable specification [22].\nHarel, Marron, and Weiss [23] proposed a simple protocol for b-thread synchronization, as follows. The protocol consists of each b-thread submitting a statement before selecting each event that the b-program produces. The statement declares which events the b-thread requests, which events it waits for (but does not requests), and which events it blocks (forbids from happening). After submitting the statement, the b-thread pauses. When all b-threads have submitted their statements, we say that the b-program has reached a synchronization point. Then, a central event arbiter selects a single event that was requested and was not blocked. Given this event, the arbiter resumes all b-threads that requested or waited for that event. The rest of the bthreads remain paused, and their current statements are used in the next synchronization point.\nTo make these concepts more concrete, we now turn to a tutorial example of a simple b-program. The example presented in this section is an adaptation of one of the first demonstration programs presented in [23] (the hot/cold example). For convenience and succinctness of the specification, the b-programs in this paper are written using BPjs \u2014 an environment for running behavioral programs written in JavaScript [17]. While the b-programs specification may be considered programming rather than modeling, the same program can be specified using diagrammatic implementations of the BP paradigm, including live-sequence charts [24] and Blockly [10]. Moreover, b-programs can be translated to PN models and vice versa, as described in Section 7.\nThe example: Consider a system with the following requirements:\n1) When the system loads, do \u2018A\u2019 three times. 2) When the system loads, do \u2018B\u2019 three times. Listing 1 shows a b-program (a set of b-threads) that fulfills these requirements. It consists of two b-threads, added\nat the program start-up. One b-thread, namely Do-A, is responsible for fulfilling requirement #1, and the second bthread, namely Do-B, fulfills requirement #2.\nListing 1. A b-program that do \u2018A\u2019 and \u2018B\u2019 three times each. The order between \u2018A\u2019 and \u2018B\u2019 events is arbitrary\nThe program\u2019s structure is aligned with the system requirements. It has a single b-thread for each requirement, and it does not dictate the order in which actions are performed (e.g., the following runs are possible: AABBAB, or ABABAB, etc.). This is in contrast to, say, a single-threaded JavaScript program that must dictate exactly when each action should be performed. Thus, traditional programming paradigms are prone to over-specification, while behavioral programming avoids it.\nWhile a specific order of actions was not originally required, this behavior may represent a problem in some cases. Consider, for example, an additional requirement that the user detected after running the initial version of the system:\n3) Two actions of the same type cannot be executed consecutively.\nWhile we may add a condition before requesting \u2018A\u2019 and \u2018B\u2019, the BP paradigm encourages us to add a new b-thread for each new requirement. Thus we add a b-thread, called Interleave, presented in Listing 2.\nListing 2. A b-thread that ensures that two actions of the same type cannot be executed consecutively, by blocking and additional request of \u2018A\u2019 until the \u2018B\u2019 is performed, and vice-versa\nThe Interleave b-thread ensures that there are no repetitions. It does so by forcing an interleaved execution of the performed actions \u2014 \u2018A\u2019 is blocked until \u2018B\u2019 is executed, and then \u2018B\u2019 is blocked until \u2018A\u2019 is executed. This is done by using the waitFor and block idioms. Note that this b-thread can be added and removed without affecting other b-threads. This is an example of a purely\nadditive change, where the system behavior is altered to match a new requirement without affecting the existing behaviors.\nRecall the discussion in the introduction regarding Deutcher\u2019s concept of languages that oblige people to specify things that they do not wish to specify. A critical reader may suspect that BP obliges users to specify unnecessary information for guiding the execution protocol. To answer this, we note that the BP protocol for composing behaviors is implicitly defined and is not part of the model. This protocol is aligned with an implicit protocol that already exists in requirement documents. Each requirement specifies a single aspect of the behavior, and it does not concern itself with other behaviors, though it is clear that the requirements are related to each other. Thus, the implicit protocol of BP does not force the modeler to specify unnecessary information, only use assumptions that already exist in the requirements."
        },
        {
            "heading": "3 THE LEVEL-CROSSING BENCHMARK",
            "text": "We now turn to describe the level-crossing benchmark that we will use throughout the following sections.\nThe level-crossing (LC) domain was first presented in 1987 by [25] and modeled with Petri nets (PN). It was later used in various research areas of PN modeling and software safety analysis [26], [27], [28]. Although some of these works modified the original model to pertain features to the relevant study, they all followed the same general behavior of [25].\nLevenson and Stolzy [25] defined the model as a controller for a gate at a railway crossing \u2014 an intersection between a railway line and a road at the same level. The railway line has a sensor that signals the controller whenever the train is approaching, entering, or leaving the crossing zone. Based on the signals, the barriers are raised and lowered, ensuring the safety of the trains, i.e., that a train cannot be in the crossing zone while the barriers are up.\nWhile the system behavior is not explicitly specified as a set of requirements, we have extracted the following requirements as we understand them, and we will later refine them:\n1) The railway sensor system dictates the exact event order: train approaching, entering, and then leaving. Also, there is no overlapping between successive train passages. 2) The barriers are lowered when a train is approaching and then raised as soon as possible. 3) A train may not enter while barriers are up. 4) The barriers may not be raised while a train is in the\nintersection zone. The intersection zone is the area between the approaching sensor and the leaving sensor. At system initialization, there is no train at the intersection zone, and the barriers are raised.\nWe note that these requirements specify the behavior that the controller should enforce, though they do not specify the implementation details. As we will show, our BP implementation will follow this distinction and keep the\nalignment between the requirements and the model. However, the PN model will add a mechanism for combining the behaviors that will cause incorrect behavior."
        },
        {
            "heading": "4 MODELING THE REQUIREMENTS WITH BP",
            "text": "To emphasize the agility of BP models, we begin with a specification that handles only one railway, and we will later extend this model to support multiple railways and faults.\nFollowing the principles of BP described in Section 2, each b-thread in Listing 3 is aligned to a single requirement of the system.\nListing 3. A BP program that specifies the requirements for a single railway. Each b-thread is aligned with a single requirement. An application-agnostic execution engine interweaves these b-threads at runtime, yielding a complex behavior that is consistent with each b-thread, liberating the designer from explicitly specifying the joint model\nThe first requirement, describing the order of the sensor\u2019s events, is specified in the first b-thread. It continuously requests to \u201capproach\u201d, \u201center\u201d, and \u201cleave\u201d, dictating this specific order. We note that a new cycle can start only if the previous train has left the intersection zone, which is aligned with the requirement of no overlapping between successive train passages.\nThe second b-thread specifies the second requirement of the barriers behavior. It waits for a train to approach and then requests to lower the barriers. When the barriers are down, it requests to raise them as soon as possible. We note that the two barriers events, Lower and Raise,\ncan only happen consecutively, aligned with the system behavior description.\nRequirement 3 is specified by the third b-thread, which blocks the train from entering while the barriers are up. The first synchronization point blocks the train from entering before lowering the barriers. The second synchronization point ensures that if the barriers are raised between the approaching and the entering events, then the behavior returns to its initial state.\nFinally, the last b-thread specifies Requirement 4, blocking the raising of the barriers while there is a train in the intersection zone.\nThis model demonstrates some merits of the BP modeling approach. The system was modeled in an incremental and modular manner, where each module is aligned with a single requirement and is unaware of other b-threads. We claim that the resulting modules are readable and comprehensible to all stakeholders."
        },
        {
            "heading": "5 MODELING THE SYSTEM WITH PN",
            "text": "In this section and in Section 6, we present three PN models for the LC domain. We begin with the original model from 1987 of Levenson and Stolzy [25] and continue with the two models of Ghazel and Liu [27] from 2016. Aswe demonstrate below, all of these models are incorrect, as some execution paths aremissed and some are generated unintentionally.\nThe original model of [25] is composed of three types of subsystems: railway traffic, barriers, and a barriers\u2019 controller. To comply with the specified behavior of the entire system, the modelers specified a mechanism to combine these subsystems. As we discuss below, this mechanism changes the behavior of the model, causing unpredictable side effects.\nThe railway-traffic subsystem (depicted in Fig. 1) specifies the dynamics of the railway using three places and three transitions, corresponding to the sensor\u2019s events: approaching, entering, and leaving. The index of these events denotes the railway index, though for now,we have only one.\nThe barriers subsystem (depicted in Fig. 2) has two states \u2014 up and down (marked by p7 and p8 respectively). The barriers passively respond to the commands issued by its controller that we now describe.\nThe barriers\u2019 controller subsystem (depicted in Fig. 3) provides an interface between the railway traffic and the barriers subsystems. A closing request is fired when a train approaches, and when a train leaves, an opening request is fired. Note that this subsystem contains two interlocks, p2 and p3, which together make sure that closing request and opening request fire alternatively. In practice, this means that the barriers may be closed if and only if they are open.\nFinally, to address Requirement 3 and forbid the train entrance while the barriers are up, the unified model that integrates the three subsystems (depicted in Fig. 4) includes an additional interlocking state, p9, and its arcs \u2014 lower ! p9 and p9 ! entering.\nWe note that the controller events closing request and opening request are not mentioned in the requirements. The reason is that Levenson and Stolzy [25] designed the PN model as a controller where these events act as part of the implementation of the controller. We argue, as we show below, that it is better to model the requirements separately of the implementation. We mark these implementation events as helper events, since they are not required for specifying the system behavior, only for the specific implementation perspective. We show below that the helper events and the interlocking mechanism lead to undesired system behaviors."
        },
        {
            "heading": "6 COMPARING THE BP AND PN",
            "text": "In this section, we compare the BP and the PN models to verify our model\u2019s correctness and explicate the differences between the models."
        },
        {
            "heading": "6.1 Models Equivalency",
            "text": "We begin with a definition of equivalence. Generally, two models are equivalent if they yield the same set of runs, i.e., the same sequences of events. However, there is a complication in our case since the PN model requires helper events that are not part of the BP model. For example, the two traces in Table 1 are equivalent in system behavior, though they have different events.\nAs the example shows and noted before, these events are used to synchronize the barriers and the railway events. They are not required to compare the resulted behavior of the two models. Thus, our equivalency definition ignores these events. For completeness, we allow helper events on either side of the comparison.\nDefinition 1. ModelsM1 andM2 over the event sets E1 and E2, respectively, are equivalent if and only if\nfpE1\\E2\u00f0t\u00de : t 2 L\u00f0M1\u00deg \u00bc fpE1\\E2\u00f0t\u00de : t 2 L\u00f0M2\u00deg where L\u00f0Mi\u00de is a set of sequences of events, called traces, that model Mi generates, and pE1\\E2\u00f0t\u00de is an operator that removes from a trace t all the events that are not in E1 \\ E2:\npE1\\E2\u00f0t\u00de \u00bc t\u00bd0 pE1\\E2\u00f0t\u00bd1:: \u00de if t\u00bd0 2 E1 \\ E2; pE1\\E2\u00f0t\u00bd1:: \u00de otherwise;\nTo allow traces with finite length, we also define that pE\u00f0\"\u00de \u00bc \" for any E. The sequences in the sets L\u00f0Mi\u00de can have a finite or infinite length.\nUsing this definition, we denote MBP and MPN as the BP model and the PN model (respectively). Since the trains may infinitely approach, enter, and leave the crossing zone, we use B\u20acuchi automata to represent the languages L\u00f0MBP \u00de and L\u00f0MPN\u00de. A B\u20acuchi automaton consists of a set of states and a transition function, where some states are defined as accepting and some as initial (starting). The automaton accepts input if and only if there is a run over this input that begins at an initial state, and at least one of the infinitely often occurring states is an accepting state.\nWe generate the automata using a depth-first search that traverse the state space of each model, where transitions correspond to events and all states are accepting (depicted in Fig. 5). Thus, the accepting words of these automata represent the set of possible traces that each model may generate.\nTo understand the significance of the difference between the two models, we analyze them using GOAL [29] \u2014 a graphical tool for manipulating B\u20acuchi automata and temporal formulas. Our findings show that the resulting language for the BP model is contained in the resulting PN model \u2014 LMBP LMPN , meaning that some runs are only possible in the PN model. One example for a word (or a trace) that is accepted only by the PN model is:\nApproaching \u00f0Lower Entering Leaving Approaching Raise\u00dev\nIn this case, there are two trains on the same railway, where the second train approaches the intersection zone after the first train leaves while the barriers are down. According to this trace, even though a train is already approaching the barriers, the latter may be raised only to be lowered again immediately after. As we describe in Section 6.3, [27] added the keep down event to avoid this behavior, though it did not completely prevent it and caused other problems to the model. Thus, these redundant barriers actions are not aligned with the system requirements and do not stand to reason. We believe that such behavior is derived from their specific mechanism implementation. While the BP paradigm allows for a direct specification of the requirements as separate modules and their automatic composition, the PN modeling\napproach obliges the modeler to explicitly specify how the different modules interact."
        },
        {
            "heading": "6.2 Adjusting Our Model",
            "text": "To allow a simple comparison of the models, we now adjust our model to meet this behavior. We start with a redefinition of Requirement 2:\n\u201cThe barriers should be lowered after a train approaches. If the barriers were already lowered, then they should be raised, and immediately lowered again before the train enters the intersection zone\u201d.\nGranted, this is a strange and tangled requirement, though it describes the observed behavior.\nThis adjustment requires the modification of the second b-thread. The original b-thread and its modified version are presented in Listing 4. Once a train leaves, the controller requests to raise the barriers while waiting for another\nTABLE 1 Comparing Traces of BP and PN\nBP Approaching, Lower, Entering, Leaving, Raise\nPN Approaching, ClosingRequest, Lower, Entering, Leaving, OpeningRequest, Raise\nThe two traces are equivalent in terms of system behavior, though they have different events.\nListing 4. Adapting the second b-thread to the change in the requirement. (a) The original b-thread (b)The modified b-thread\napproaching event, whichever comes first. If the event is approaching, it requests to raise the barriers. Otherwise, it waits for a train to pass again. In addition to this change, the fourth b-thread should be removed, to allow the raise of the barriers after the train approaches.\nGiven these modifications, the BP and the PN models are now equivalent."
        },
        {
            "heading": "6.3 Expanding to Multi-Track",
            "text": "Ghazel and Liu [27] observed this redundant behavior and tried to address it. In addition, they extended the model to support multiple railways. Many have used this extension as a benchmark for this domain [30], [31], [32], and we use it to continue our comparison. Fig. 6 presents the extended PN model of [27] and our extended BP model.\nExtending the BP model required only multiplying the bthreads by the number of tracks. Railway-specific events (i.e., Approaching, Entering, and Leaving) were assigned with an index while the barriers events remained the same. Since the behavior of each b-thread is valid for both the single version of the system and the multi-track version, we needed no further adaptations to the extended model.\nThe extended PN model of [27] significantly changed the model and its semantics. To support multi-track, they multiplied the railway traffic subsystem and changed the other two subsystems as follows: two additional arcs were added (p6 ! closing request and raise ! p6), tokens were added, and some arc weights were changed.\nTo address the redundant raise-lower behavior, the model adds a helper event, called keep down, and its related arcs. These additions allow to keep down the barriers if a train approaches right after another one leaves. Alas, not\nonly that their solution did not solve it in all cases, but it created other problems, as we present in Section 8.1.\nApplying the comparison algorithm of Section 5 reveals that the extended PN model is, again, not aligned with the requirements and is no longer equivalent to our model. In Section 8, we further analyze the differences between these models."
        },
        {
            "heading": "6.4 Adding Faults",
            "text": "In real life, discrete-event systems may have faults. For example, the entering sensor on a railway may be faulted and miss a train entering. Detecting and diagnosing such faults at real-time is of paramount importance in DES modeling and has become an active research area in recent years. The research activity in this area is driven by the needs of many different error-prone domains. When modeling, faults are often added to the basic model that describes the standard system behavior. This may lead to inconsistent system behavior that is misaligned with prior requirements. In Section 8.1, we give multiple examples for such inconsistencies. Here, we demonstrate how our suggested method can assist modelers in verifying and analyzing the impact of faults on the initial requirements.\nIn the PNmodel detailed in [27], two classes of faults were added for diagnosis purposes (denoted with red transitions in Fig. 7). The first one simulates a train-sensing defect and indicates that the train enters the level-crossing zone without triggering the entering sensor. Thus, the train may enter before the barriers are lowered. The second failure indicates a defect of the barriers that result in a premature raising.\nA detailed look at their model, reveals that the arcs to and from p9 are not required for modeling the fault\ntransitions. In fact, they were added as part of a mechanism for satisfying the original requirements given the new fault transitions. As we show in Section 8.1, these arcs fix one behavior and break others, blocking many legit traces that can no longer happen. This example, together with the multi-track extension, demonstrate the drawback of PN for modeling behaviors \u2014 adding new behaviors after the model is ready often requires modifying the mechanism and performing non-trivial adjustments to the model. It obliges modelers to think of all the side effects of these adjustments, something that may not be practical for complex behavior of large-scale systems.\nThe BP version of the fault transitions is presented in Listing 5. The first class of faults, simulating an unobservable train entering, is modeled using n b-threads, one for each railway. Each b-thread waits for a train to approach and then requests a signed entering event, representing the fault. The second b-thread models the second fault class of a premature barriers\u2019 raise. The b-thread waits for the barriers to be lowered. It then requests to raise the barriers using a signed event that represents this fault. We note that the fault events in our BP model are similar to the original nonfaulted events for both entering and raising respectively and are differentiated by adding a \u201cflag\u201d to the event data. This setting allows existing b-threads to effect (by blocking) or be affected by (requesting and waiting for) the added fault events without modifying them.\nListing 5. Faults b-threads for the level-crossing benchmark"
        },
        {
            "heading": "6.5 A Conclusion for the Level-Crossing Domain",
            "text": "The addition of multiple tracks and fault transitions demonstrate the dynamical and incremental development style of BP. The described b-program is modular because new requirements can be flexibly added as new b-threads. Since modeling often begins without faults, we believe that the ability to implement them without modifying (or even accessing) the existing model is a significant advantage. Furthermore, it maintains the alignment of the model with requirements. System requirements, both old and new, can be represented directly using a BP model.\nAt this point, a critical reader may ask whether the BP model is indeed error-free or has some unknown problems. We used the verification tool of BPjs to assert some properties of the model, such as that it has no deadlocks or\nlivelocks. To validate that the model is indeed aligned with the requirements, we sampled the generated traces of the model and checked that they are aligned with the way we perceive the requirements.\nTo conclude the different versions of the LC benchmark, we present in Section 8.1 a quantitative comparison between the PN and the BP models for the LC benchmark. This comparison emphasis the effect of the problems in the PNmodel on the resulted behavior. To the best of our knowledge there are no other references in the literature to these problems in the LC benchmark."
        },
        {
            "heading": "7 TRANSLATIONAL SEMANTICS FROM PN TO BP",
            "text": "BP has tools for executing and analyzing the models (e.g., using formal methods). In addition, there are tools for converting BP models into other formats, such as Z3, GOAL, SPIN, Graphviz, and more. Nevertheless, PN has longstanding successful tools that may be more suitable for different use cases. Thus, we propose an approach for PN modelers to use BP to bridge the gap between system specification and PN implementation. System requirements can be specified directly using BP and implemented using PN. Hence an equivalence between the two models, in such a case, can indicate an alignment between requirements and implementation. This approach \u201ceases\u201d the transition for PN modelers and maintains the current advantages of PN. Although the automaton required for the comparison can be computed directly from PN, we now show a viable alternative that is more useful in practice \u2014 a direct translation\nfrom PN to BP. Tools based on these semantics can provide a uniform modeling environment where all modeling artifacts are translated to a common language.\nTaking advantage of BP\u2019s modularity and flexibility, we can implement the dynamics of each place of the PNmodel as a separate b-thread. Each b-thread maintains the number of tokens in the place using a variable. Based on the number of tokens, it waits-for or blocks a set of events that represents the transitions to/from the place. A translation example for p2 is presented in Listing 6. If it has no tokens, it forbids the event \u201cClosing Request\u201d from taking place while waiting for an \u201cOpening Request\u201d event, which increases its tokens. If it has some tokens, it waits for both events and increases or decreases its tokens accordingly. The suggested translation is general and can be applied to all places of a PN model. The complete b-program combines all places b-threads and an auxiliary b-thread that requests all possible events at each round (as depicted in Listing 7). This program yields a behavior consistentwith the entire PNdynamics.\nBased on these semantics, we translated to BP all the PN models in this paper. To verify the correctness of each translation, we generated the automaton of the PN model using SNAKES [33], a Python library for Petri nets. Next, we generated the automaton for the translated (to BP) model. Finally, we verified that themodels are equivalence, using themethod described in Section 6.1. The paper\u2019s repository (github.com/ bThink-BGU/Papers-2022-BP-PN) contains the source code for all models (PN, translated-PN-to-BP, and BP) and their automata. In Section 8.1, we empirically evaluate the differences between the BP and the PN/translatedmodels.\nListing 6. p2 translated b-thread\nListing 7. The \u201cauxiliary\u201d translated b-thread\nAlthough a translation from BP to PN is not necessary for the context of this paper, it can be easily done. An automaton representing the behavior of the model, such as the one depicted in Fig. 5, can be automatically generated (elaborated in Section 6.1). This automaton can be viewed as a\nspecial case of a simple PN with a single token passing from states (or places)."
        },
        {
            "heading": "8 RESULTS",
            "text": "The example of the level-crossing benchmark allowed us to demonstrate our claims on PN. The purpose of this section is to further establish our claims in two ways: 1) quantifying the differences between PN and BP, and; 2) demonstrating our claims on other PN models to support our hypothesis that the problem is rooted in the language constructs.\nAll the code examples in this paper and the data we used for comparing the models can be viewed at github.com/ bThink-BGU/Papers-2022-BP-PN."
        },
        {
            "heading": "8.1 Empirical Results for the Level-Crossing Benchmark",
            "text": "To quantify the differences between the two approaches, we computed the state space (i.e., reachability graph) of the PN and the BP programs, with and without failures. We ran each program with a varying number of railways. To evaluate the effect of the helper events on the state space, we removed all transitions s\ne! t, where e is a helper event, and rewired all incoming transitions of s into t. We denote the resulting state space as PN*.\nThe results are summarized in Table 2. For comparison, we use the BP model without the Requirement 2, since it better aligns with the requirements. We implemented the PN model of [27] using the translational semantics presented in Section 7. Notably, for any n with faults, the number of states and transitions of the PN model matches the reported numbers of [27], thus validating our implementation (they did not provide statistics for other implementations). To make the differences between the models accessible to the reader, in Table 3, we present the state and transition reduction between the different models. For all models, the average reduction in states is similar to the average reduction in transitions. From PN to PN*, the model is reduced by almost 50%; from PN* to BP, the model is reduced by almost 70%, and finally; from PN to BP, the model is reduced by approximately 80%. This dramatic reduction allows for applying reasoning techniques and formal methods on larger models compared to PN. Furthermore, the composable structure of BP programs allows for\napplying compositional verification and compositional formal method techniques [19].\nIn Table 4, we evaluate the equivalency of the models to compare thepossible traces of eachmodel (as described in Section 6.1). Unsurprisingly, the number of paths is exponentially bound to the size of the state space. Therefore, we generated only traces of a maximal length of sixteen and only for a limited number of railways due tomemory limitations. This comparison shed much light on the differences between the models, aswe now elaborate.\nIn Section 6, we showed that for a single track without fault transitions, the resulting language of the BP model is contained in the resulting language of the PN model (i.e., LMBP LMPN ), meaning that some traces are only possible in the PN model. As Table 4 shows, this phenomenon is relevant for multiple tracks as well. To recall, the PN model allows for a redundant raise and lower actions of the barriers after the train approaches.\nThe inclusion of fault transition to themodels increased the models\u2019 differences. In addition to traces unique to the PN model, the introduction of fault transitions resulted in unique runs to the BPmodel. One example for a trace that is accepted by the BP model only is: \u00f0Approaching FaultEntering Leaving\u00dev. In this case, a train enters the crossing zone before the barriers are lowered and then leaves. A train should be able to leave the crossing zone regardless of the barriers state. To understand why this trace is not possible in the PNmodel with faults, we recall the mechanism (described in Section 6.4 for complying with the original requirements, which adds arcs to and from p9. This mechanism caused an unexpected side effect. Another trace that is accepted only by the BP model is: \u00f0Approaching Lower Entering Leaving Approaching FaultRaise Entering \u00dev. Here, the barriers were raised, although the system was unaware of this event. Then a train entered the crossing zone.While such behavior is reasonable and may happen, this trace cannot happen in the PNmodel, revealing another side effect of themechanism."
        },
        {
            "heading": "8.2 Additional Petri-Net Models",
            "text": "We now turn to demonstrate our claims on two other domains to support our hypothesis that the problem is rooted in the language constructs."
        },
        {
            "heading": "8.2.1 The Dining Philosophers",
            "text": "The famous dining philosophers problem has been modeled using PN in many papers and was also modeled in BP [18]. In Listing 8, we present the BP implementation for this problem and the PN model in Fig. 8. We took the PN model from a tutorial for Workcraft \u2014 a framework for interpreted graph models, supporting modeling, verification, and synthesizing such models [34], [35], [36]. Both of the implementations define the two basic behaviors of the system, one for philosophers and one for the forks.\nListing 8. A behavioral program of the dining philosopher, taken from [18]\nBoth implementations may cause the same two problems \u2014 a deadlock and starvation. These problems can be defined as two additional liveness requirements: 1) A picked-up forked will eventually be put down, and; 2) a hungry philosopher will eventually eat. While both PN and BP have tools for detecting liveness problems, BP allows developers to directly specify the liveness requirements, as presented in Listing 9. A hot synchronization point specifies that whenever the b-thread arrives at this point, it will\nTABLE 3 The State-Space Reduction Between the Models, in Terms of Number of States and Transitions\nPN! PN* PN*! BP PN! BP n with faults S T S T S T"
        },
        {
            "heading": "1 0.40 0.38 0.17 0.25 0.50 0.54",
            "text": ""
        },
        {
            "heading": "1 \u2713 0.35 0.40 0.00 0.00 0.35 0.40",
            "text": ""
        },
        {
            "heading": "2 0.55 0.53 0.65 0.70 0.84 0.86",
            "text": ""
        },
        {
            "heading": "2 \u2713 0.40 0.43 0.54 0.56 0.73 0.75",
            "text": ""
        },
        {
            "heading": "3 0.65 0.65 0.79 0.81 0.93 0.93",
            "text": ""
        },
        {
            "heading": "3 \u2713 0.47 0.51 0.75 0.76 0.87 0.88",
            "text": ""
        },
        {
            "heading": "4 0.65 0.65 0.89 0.89 0.96 0.96",
            "text": ""
        },
        {
            "heading": "4 \u2713 0.23 0.29 0.90 0.90 0.92 0.93",
            "text": ""
        },
        {
            "heading": "5 0.49 0.50 0.95 0.95 0.98 0.98",
            "text": "5 \u2713 0.25 0.32 0.94 0.94 0.95 0.96 average 0.44 0.47 0.66 0.68 0.80 0.82 median 0.44 0.47 0.77 0.79 0.90 0.91\neventually proceed (i.e., one of the requested or waited-for events will be selected).\nListing 9. Liveness requirements for the dining philosophers. A hot synchronization point specifies that whenever the b-thread arrives to this point, it will eventually proceed\nBP offers several approaches for automatically enforcing a correct execution in terms of liveness, including synthesis, runtime look-ahead, and reinforcement learning [37]. Another option to enforce the execution correctness is explicitly implementing known solutions, like resource ordering and a central arbitrator. Resource ordering in BP can be achieved using priorities. Here, the priority of the philosophers\u2019 requests is inversely proportional to their index. We demonstrate the use of priorities in the following example (see Listing 11). The central arbitrator\nsolution is presented in Listing 10, where philosophers must get a hold on a central semaphore to eat (i.e., take and put the forks). The literature also offers PN solutions [38], which we do not present for brevity. Nevertheless, like our previous examples, they require the mechanism specification for interweaving all of the requirements together.\nListing 10. An arbitrator solution to the deadlock requirement"
        },
        {
            "heading": "8.2.2 Tic-Tac-Toe",
            "text": "The last domain we present is the game Tic-Tac-Toe. The game is of particular interest to us as it was developed using BP in one of the earliest papers of the paradigm [23]. The requirements of the game are well known, and the BP implementation of the game was published long before this paper. Thus, this domain stands as a touchstone for our hypothesis.\nWe take the PN model from [39], which was used to create a domain-specific language (DSL) for the game. As depicted in Fig. 9, this PN model only specifies two requirements of the game: 1) a cell can be marked only once, and; 2) turns \u2014 X and O play in turns where X starts. The mechanism for integrating these requirements is specified without the use of helper events and is fairly understandable. Nevertheless, there are two additional requirements: 3) The first player to get three marks in a line is the winner, ending the game, and; 4) if no player has won and all nine squares are marked, then the game is over with a tie. Although according to this model, the game ends upon the marking of the last cell, there is no tie declaration (i.e., transition). This is where the model gets complicated. Since [39] did not create a complete model of the game, we took this mission upon ourselves. In Fig. 10, we added an interlock mechanism for handling the case that X wins by placing Xs in the first row. The \u201cgame token\u201d is added to ensure that the game will stop once the token is gone (i.e., the game ends). The place \u201crow0 X counter\u201d waits for three \u201cX\u201d tokens to arrive and then fires them to the \u201crow0 X win\u201d transition, together with the \u201cgame token\u201d. Since the transition has no outgoing edges, it acts as a sink that terminates the game. In total, we added 23 edges, two places, one transition, and one token. Since the new model was extremely noisy and hard to understand, we decreased the opacity of the original specification. Handling the other seven lines will require additional 35 edges, seven transitions, and seven places. Adding a tie event with a lower priority than a winning event requires an additional interlocking mechanism.\nListing 11 presents a BP implementation of the game, taken from [23]. Each b-thread represents a single aspect of the game and is unaware of other aspects. For example, the last b-thread repeatedly asks for placing X and O at any of the nine cells. It is unaware of other rules, like turns, which are enforced by the second b-thread. Cell and line b-threads are duplicated for each cell/line. There is one exception to the separation of concerns between the b-threads \u2014 the 90 and 100 numbers in the winning b-threads. These numbers represent the priority of the event. If a game has both nine moves and the last mark wins the game for the X player, then the \u2018XWin\u2019 event overcomes the \u2018Tie\u2019 event. Notably, the Tie requirement refers to the winning requirement, thus technically, the separation of concerns is violated in the requirements, and the alignment is kept. Nevertheless, there are several\nsolutions to this issue (e.g., using context [9]), though they are out of the scope of this paper.\nListing 11. A behavioral program for the game of TicTac-Toe, taken from [23]. Lines 1-20 specify the same behavior as the PN model of Fig. 9, and the b-thread in line 29, with l=\u201cfirst row\u201d, specifies the same behavior as the PN model of Fig. 10\nNotably, the b-threads in lines 1-20 specify the same behavior as the PN model in Fig. 9. Similarly, the b-thread in line 29, with l=\u201cfirst row\u201d, specifies the same behavior as the PN model in Fig. 10. This comparison emphasizes the conciseness of the BP model compared to the PN model."
        },
        {
            "heading": "9 RELATED WORK",
            "text": "Giua and Silva [40] pointed out that while the use of PNs with state specifications is a very mature area, their use in the design of systems from general behavioral specifications has not been equally successful. The latter issue can in some cases lead to incorrect specifications, faulty\nFig. 9. The PN model of [39] for the game of Tic-Tac-Toe. The model implements only two requirements out of four.\nimplementations, and inconsistent system behavior. Finding a more general approach to system modeling is still an open problem driving several developments in the PN field.\nThe ability to structurally define the entire system behavior as a function of the behavior of its subsystems is a key factor in designing systems from a general behavior description. Hence there has been much research concentrating on PNs compositionality and sub-PNs interactions representation. Several works introduced a compositional extension of PNs using process algebras [41], [42], [43]. They provide an approach for a high-level description of interactions, communications, and synchronizations between PNs. In another work, Baldan et al. [44] represented PNs interactions by introducing open PN, a generalization of the ordinary model. In open PN, some places, designated as open, reflect interaction with other nets. Concretely, an open place can function as an input or an output (or both), meaning that external PNs can put or remove tokens from it. Kindler and Petrucci [45] proposed a similar approach that adds an interface for each module, called channel, that specifies the input and the output of the module. All approaches require the definition of an interface between the different components, thus improving their abstraction (as with interfaces of object-oriented programming). Nevertheless, the modelers are still required to consider the mutual dependencies for specifying these interfaces. We argue that the BP approach addresses compositionality more naturally, with the ability to compose behaviors without direct consideration of mutual dependencies.\nAn important part of generalizing PN modeling is the ability to represent an interface of the system with the environment. Plain PNs are not adequate to model systems that can interact with their environment or, in another view, are only partially specified. The above-mentioned open PN [44] can also model external interaction, where some nets in the whole model represent the system\u2019s environment. In another related work, reactive PN [46] addresses this issue by defining reactive semantics to PN, specifically, splitting the set of transitions into internal and external and\nmodifying its firing rules. These semantics state that if an external transition is enabled, it may fire, while in contrast, internal transition, when enabled, must fire. Such behavior is desired in systems that are specified to react as a consequence of external events. We view the ability to accurately model real-time scenarios in reactive systems to be of great importance. BP approaches an external environment interaction in its semantics [47] and implementations [17] using the mechanism of super-steps that capture the priority of external events over external ones that reflect the notion of logical execution time [48]."
        },
        {
            "heading": "10 DISCUSSION",
            "text": "There is a qualitative difference between BP models and PN models: BP focuses on breaking systems into requirements, and PN focuses on specifying the components of a system and how they interact. While both approaches have many merits, we argued in this paper that BP is better for specifying system behavior when it is a composition of requirements. To support our claim, we methodologically demonstrated over three problems how PN obliges modelers to specify a mechanism for combining the different behaviors. This results in over-specification, incorrect models, or complicated models that are not directly aligned with the requirements. In view of the long-standing success of Petri nets, we propose, as future work, to get the best of the two by integrating BP semantics (i.e., wait, request, and block) with Petri nets, as previously done with statecharts [49].\nThe problem of a language that obliges users to say things they do not wish to say does not solely belong to Petri nets. Other programming and modeling languages, compilers, and sometimes even IDEs \u2014 share it. We believe that this problem may be rooted in the relationship between programming languages and the early, \u201chard\u201d version of the linguistic relativity hypothesis. For years, programming languages have directed users to adapt their thinking. Behavioral programming is different in that its primary design goal is to allow its users to specify the system behavior in a natural and intuitive manner that is aligned with how they perceive the system requirements. We are not saying that BP does not share this problem; however, the BP community is devoted to refining and extending the paradigm to eliminate these problems. For example, a recent extension to the paradigm [9] has pointed out that the absence of context idioms in BP obliges users to define mechanisms for specifying context-dependent requirements. These mechanisms either break the alignment to the requirements or break the correctness of the model. To allow users a more natural specification of their context-dependent requirements, the extension of [9] adds context idioms as first-class citizens of the language.\nIn practice, software projects rarely start with welldefined requirements. Reasonably, it may be related to the challenge of maintaining the requirement documents, the design documents, and the traceability between the requirements and the code. Generally speaking, requirements are how people describe their system. Thus, a shift left of modeling/programming languages towards a more natural specification/programming of the requirements may lead\nFig. 10. Our extended version of the PN model of [39]. The model includes a mechanism for terminating the game when X wins by taking the first row.\nto an evolutionary step in the field. There are other possible solutions and approaches to this problem. We believe that the software engineering community will benefit from adopting modern linguistics approaches and searching for these solutions."
        },
        {
            "heading": "ACKNOWLEDGMENTS",
            "text": "The authors would like to thank Assaf Marron for a thorough review of the draft of this paper."
        }
    ],
    "title": "What Petri Nets Oblige us to Say Comparing Approaches for Behavior Composition",
    "year": 2023
}