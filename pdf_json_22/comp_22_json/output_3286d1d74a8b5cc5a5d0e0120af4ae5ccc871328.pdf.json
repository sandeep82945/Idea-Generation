{
    "abstractText": "P-time event graphs are discrete event systems suitable for modeling processes in which tasks must be executed in predefined time windows. Their dynamics can be represented by systems of linear dynamical inequalities in the max-plus algebra and its dual, the min-plus algebra, referred to as max-plus linear-dual inequalities (LDIs). We define a new class of models called switched LDIs (SLDIs), which allow to switch between different modes of operations, each corresponding to an LDI, according to an infinite sequence of modes called schedule. In this paper, we focus on the analysis of SLDIs when the schedule is fixed and periodic. We show that SLDIs can model single-robot multi-product processing networks, in which every product has different processing requirements and corresponds to a specific mode of operation. Based on the analysis of SLDIs, we propose an algorithm to compute minimum and maximum cycle times for these processes that improves the time complexity of other existing approaches.",
    "authors": [
        {
            "affiliations": [],
            "name": "Jan Komenda"
        },
        {
            "affiliations": [],
            "name": "J\u00f6rg Raisch"
        }
    ],
    "id": "SP:32f7ecff95c04a63fdb2da2961ac76d6d561bfcc",
    "references": [
        {
            "authors": [
                "F. Baccelli",
                "G. Cohen",
                "G.J. Olsder",
                "J.P. Quadrat"
            ],
            "title": "Synchronization and linearity: an algebra for discrete event systems",
            "year": 1992
        },
        {
            "authors": [
                "T. Becha",
                "R. Kara",
                "S.C. Dutilleul",
                "J.J. Loiseau"
            ],
            "title": "Modelling, analysis and control of electroplating line modelled by P-time event graphs",
            "venue": "IFAC Proceedings Volumes,",
            "year": 2013
        },
        {
            "authors": [
                "S. Calvez",
                "P. Aygalinc",
                "W. Khansa"
            ],
            "title": "P-time Petri nets for manufacturing systems with staying time constraints",
            "venue": "IFAC Proceedings Volumes,",
            "year": 1997
        },
        {
            "authors": [
                "L. Hardouin",
                "B. Cottenceau",
                "Y. Shang",
                "J. Raisch"
            ],
            "title": "Control and state estimation for max-plus linear systems",
            "venue": "Foundations and Trends\u00ae in Systems and Control,",
            "year": 2018
        },
        {
            "authors": [
                "R.A. Horn",
                "C.R. Johnson"
            ],
            "title": "Topics in matrix analysis",
            "year": 1991
        },
        {
            "authors": [
                "V. Kats",
                "L. Lei",
                "E. Levner"
            ],
            "title": "Minimizing the cycle time of multiple-product processing networks with a fixed operation sequence, setups, and time-window constraints",
            "venue": "European Journal of Operational Research,",
            "year": 2008
        },
        {
            "authors": [
                "J.H. Kim",
                "T.E. Lee",
                "H.Y. Lee",
                "D.B. Park"
            ],
            "title": "Scheduling analysis of time-constrained dual-armed cluster tools",
            "venue": "IEEE Transactions on Semiconductor Manufacturing,",
            "year": 2003
        },
        {
            "authors": [
                "J. Komenda",
                "A. Lai",
                "J.G. Soto",
                "S. Lahaye",
                "J. Boimond"
            ],
            "title": "Modeling of safe time Petri nets by interval weighted automata. IFAC-PapersOnLine",
            "year": 2020
        },
        {
            "authors": [
                "P. \u0160pa\u010dek",
                "J. Komenda"
            ],
            "title": "Analysis of cycle time in interval P-time event graphs in dioid algebras",
            "venue": "IFACPapersOnLine,",
            "year": 2017
        },
        {
            "authors": [
                "T.J. Van Den Boom",
                "B. De Schutter"
            ],
            "title": "MPC of implicit switching max-plus-linear discrete event systems - timing aspects",
            "venue": "In 8th IFAC International Workshop on Discrete Event Systems (WODES),",
            "year": 2006
        },
        {
            "authors": [
                "D. Zorzenon",
                "J. Komenda",
                "J. Raisch"
            ],
            "title": "Bounded consistency of P-time event graphs",
            "venue": "In 2020 59th IEEE Conference on Decision and Control (CDC),",
            "year": 2020
        },
        {
            "authors": [
                "D. Zorzenon",
                "J. Komenda",
                "J. Raisch"
            ],
            "title": "The non-positive circuit weight problem in parametric graphs: a solution based on dioid theory",
            "year": 2022
        },
        {
            "authors": [
                "D. Zorzenon",
                "J. Komenda",
                "J. Raisch"
            ],
            "title": "Periodic trajectories in P-time event graphs and the nonpositive circuit weight problem",
            "venue": "IEEE Control Systems Letters,",
            "year": 2022
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n20 4.\n01 15\n6v 1\n[ ee\nss .S\nY ]\n3 A\npr 2\nKeywords: Petri nets, P-time event graphs, scheduling, switched systems"
        },
        {
            "heading": "1. INTRODUCTION",
            "text": "P-time event graphs (P-TEGs) are event graphs in which tokens are forced to sojourn in places in predefined time windows. They have been applied to solve scheduling problems for several processing networks, including electroplating lines and cluster tools, cf. Becha et al. [2013], Kim et al. [2003]. A common feature of these processing networks is that operations need to be executed in specified time intervals in order to obtain the desired quality of the final product, and P-TEGs are the ideal tools for modeling such constraints.\nIn this paper, we introduce a new class of systems called switched max-plus linear-dual inequalities (SLDIs). They extend the modeling power of P-TEGs by allowing to switch among different modes of operations, each consisting in a system of inequalities describing the dynamics of a P-TEG. We first highlight the equivalence between bounded consistency, an important property extended to SLDIs from P-TEGs, and the existence of periodic trajectories. SLDIs are then applied to model single-robot multiproduct processing networks, namely, processing networks in which the type of products to be processed can change\n1 This work was funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation), Projektnummer RA 516/14- 1. Partially supported by the GACR grant 19-06175J, by MSMT INTER-EXCELLENCE project LTAUSA19098, by RVO 67985840, and by Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany\u2019s Excellence Strategy \u2013 EXC 2002/1 \u201cScience of Intelligence\u201d \u2013 project number 390523135.\nover time, each type requires to visit different processing stations, and products are transported by a single robot (see Kats et al. [2008] for a formal definition). In this case, each mode is associated with a certain product type.\nWhen the sequence of modes is fixed and periodic with period |v| \u2208 N, the minimum and maximum cycle times of such systems can be computed in strongly polynomial time O(|v|4n4) (in the worst case) using an algorithm presented in Kats et al. [2008], where n corresponds to the total number of processing stations in the network. We provide other two algorithms based on SLDIs that solve instances of the same problem. The first one is derived from an existing procedure that computes the cycle times of P-TEGs, and achieves time complexity O(|v|4n4). The second one, of time complexity O(|v|n3+n4), improves the first one by using tools from automata theory to exploit the sparsity of a certain matrix in the max-plus algebra. Tests are performed on an example of single-robot multiproduct processing network to show the advantages of the proposed methods.\nNotation\nThe set of positive, respectively non-negative, integers is denoted by N, respectively N0. The set of non-negative real numbers is denoted by R\u22650. Moreover, Rmax := R\u222a{\u2212\u221e}, Rmin := R \u222a {\u221e}, and R := Rmax \u222a {\u221e} = Rmin \u222a {\u2212\u221e}. If A \u2208 R n\u00d7n , we will use notation A\u266f to indicate \u2212A\u22ba."
        },
        {
            "heading": "2. PRELIMINARIES",
            "text": "In the following subsections, some preliminary notions on idempotent semirings, precedence graphs, and multiprecedence graphs are recalled. For a more detailed discussion on the first two topics, we refer to Baccelli et al. [1992] and Hardouin et al. [2018]; multi-precedence graphs have been introduced in Zorzenon et al. [2022a]."
        },
        {
            "heading": "2.1 Formal languages and the max-plus algebra",
            "text": "A diod (or idempotent semiring) (D,\u2295,\u2297) is a set D endowed with two operations: \u2295 (addition), and \u2297 (multiplication). Operation \u2295 and \u2297 are associative and have a neutral element indicated, respectively, by \u03b5 and e; \u2295 is commutative and idempotent (a \u2295 a = a), \u2297 distributes over\u2295, and \u03b5 is absorbing for\u2297 (\u2200a \u2208 D, a\u2297\u03b5 = \u03b5\u2297a = \u03b5). For the sake of brevity, we will often omit symbol \u2297. The order relation is induced by \u2295 by: a b \u21d4 a \u2295 b = a. A dioid is complete if it is closed for infinite sums and \u2297 distributes over infinite sums. In complete dioids, \u22a4 = \u2295\nx\u2208D x denotes the greatest element ofD, the Kleene star of an element a \u2208 D is defined by a\u2217 = \u2295\nk\u2208N0 ak,\nwhere a0 = e, ak+1 = ak \u2297 a, and the dual addition (or greatest lower bound) \u229e is defined by a\u229e b = \u2295\nDab x,\nwhere Dab = {x \u2208 D | x a and x b}.\nAn example of a dioid that will be used in this paper is the algebra of formal languages. Let \u03a3 = {a1, . . . , al} be a finite alphabet of symbols a1, . . . , al. Then, \u03a3\n\u2217, respectively, \u03a3\u03c9, indicate the set of all finite, respectively, infinite, sequences of symbols from \u03a3, called strings. Given two strings s, t \u2208 \u03a3\u2217, their concatenation forms a new string st \u2208 \u03a3\u2217; given a string s \u2208 \u03a3\u2217 and a number k \u2208 N0, sk \u2208 \u03a3\u2217 and s\u03c9 \u2208 \u03a3\u03c9 denote, respectively, the string obtained by concatenating s k, respectively, infinitely many times, with s0 = e, where e denotes the empty string. The length of a string s is indicated by |s| (with |e| = 0), and |s|ai is the number of occurrences of letter ai in s. Moreover, si indicates the i\nth symbol of s, with s0 = e. The prefix set of string s \u2208 \u03a3\n\u2217 \u222a \u03a3\u03c9 is defined by Pre(s) = {t1 \u2208 \u03a3\u2217 | t1t2 = s for some t2 \u2208 \u03a3\u2217 \u222a \u03a3\u03c9} and sk] indicates the string formed by the first k symbols of s: sk] = s1s2 . . . sk, with s0] = e. We denote by 2 \u03a3\u2217 the set of subsets of \u03a3\u2217. Then, a (formal) language L is an element of 2\u03a3 \u2217\n, i.e., L \u2286 \u03a3\u2217. The union of two languages L1,L2 \u2208 2\u03a3 \u2217\nis indicated by L1 \u222a L2, and L1 \u00b7 L2 = L1L2 = {vw | v \u2208 L1, w \u2208 L2} indicates the language obtained by concatenating all strings of L1 with those of L2. Given a string s \u2208 \u03a3\u2217, we will often indicate by the same symbol the single-string language s := {s} \u2208 2\u03a3 \u2217\n. It is easy to show that (2\u03a3 \u2217\n,\u222a, \u00b7) forms a complete dioid, in which e = {e}, \u03b5 = \u2205, \u22a4 = \u03a3\u2217, \u229e coincides with \u2229, and coincides with \u2286.\nBefore giving a second example of dioid \u2013 the max-plus algebra \u2013 we recall some other definitions and propositions. Given A,B \u2208 Dm\u00d7n, C \u2208 Dn\u00d7p, operations \u2295 and \u2297 are extended to matrices as (A\u2295 B)ij = Aij \u2295Bij , and (A\u2297 C)ij = \u2295n k=1(Aik \u2297Ckj). Furthermore, the multiplication between a scalar \u03bb \u2208 D and a matrix A \u2208 Dm\u00d7n is defined by (\u03bb\u2297A)ij = \u03bb\u2297Aij . If (D,\u2295,\u2297) is a complete dioid, then (Dn\u00d7n,\u2295,\u2297) is a complete dioid, too, with\nneutral elements for \u2295, \u2297, and \u229e, respectively, given by the matrices E , E\u2297, and T , where for all i, j, Eij = \u03b5, E\u2297ij = e if i = j, E\u2297ij = \u03b5 else, and Tij = \u22a4. A binary operation \u22a0 is called dual product if it is associative, distributes over \u229e, e is its neutral element, and \u22a4 is absorbing for \u22a0. Moreover, if \u22a0 is a dual product for (D,\u2295,\u2297), then its extension to matrices, given by, \u2200A \u2208 Dm\u00d7n, C \u2208 Dn\u00d7p, \u03bb \u2208 D, (A\u22a0C)ij = \u229e n k=1(Aik \u22a0Ckj), (\u03bb\u22a0A)ij = \u03bb\u22a0Aij , is a dual product for (Dn\u00d7n,\u2295,\u2297).\nConsider a complete idempotent semifield (D,\u2295,\u2297), i.e., a complete dioid in which every element a \u2208 D \\ {\u03b5,\u22a4} admits a multiplicative inverse a\u22121, i.e., a\u2297 a\u22121 = a\u22121 \u2297 a = e. Then, operation \u22a0 defined as a\u22a0 b = a \u2297 b if a, b \u2208 D \\ {\u22a4}, a\u22a0 b = \u22a4 if a = \u22a4 or b = \u22a4 is a dual product for (D,\u2295,\u2297) (see Zorzenon et al. [2022b]).\nThe tensor (or Kronecker) product \u2297t between two matrices A \u2208 Dm\u00d7n, B \u2208 Dp\u00d7q is defined as the matrix\nA\u2297t B =\n\n  A11 \u2297B \u00b7 \u00b7 \u00b7 A1n \u2297B ...\n... Am1 \u2297B \u00b7 \u00b7 \u00b7 Amn \u2297B\n\n  \u2208 Dmp\u00d7nq.\nWe recall the following properties of \u2297t, the first of which holds in commutative dioids, i.e., dioids in which \u2297 is commutative.\nProposition 1. (Horn and Johnson [1991]). Let (D,\u2295,\u2297) be a commutative diod, A \u2208 Dm\u00d7n, B \u2208 Dp\u00d7q, C \u2208 Dn\u00d7k, D \u2208 Dq\u00d7r . Then (A\u2297tB)\u2297(C\u2297tD) = (A\u2297C)\u2297t (B\u2297D).\nProposition 2. Let (D,\u2295,\u2297) be a dioid, A \u2208 Dm\u00d7m, B \u2208 Dp\u00d7p. Then, tr(A \u2297t B) = tr(A) \u2297 tr(B), where tr(M) =\n\u2295q i=1 Mii indicates the trace of matrix M \u2208\nDq\u00d7q.\nProof.\ntr(A\u2297t B) = m \u2295\nk=1\ntr(Akk \u2297B) = m \u2295\nk=1\nAkk \u2297 tr(B)\n=\n(\nm \u2295\nk=1\nAkk\n)\n\u2297 tr(B) = tr(A)\u2297 tr(B).\nThe max-plus algebra is the complete and commutative idempotent semifield (R,\u2295,\u2297), i.e., the set of extended real numbers endowed with the standard maximum operation \u2295, and the standard addition \u2297. In the max-plus algebra, \u03b5 = \u2212\u221e, e = 0, \u22a4 = \u221e, \u229e is the standard minimum operation, coincides with \u2264. The dual product \u22a0 is such that a\u22a0 b = a\u2297b if a, b 6= \u221e, and a\u22a0 b = \u221e if a = \u221e or b = \u221e. The extension of the max-plus algebra to square matrices (R n\u00d7n\n,\u2295,\u2297) is a complete dioid; in the rest of the paper, symbol will be reserved to compare matrices with elements from R, i.e., \u2200A,B \u2208 R m\u00d7n\n, A B \u21d4 Aij \u2264 Bij \u2200i, j. The product between a scalar \u03bb \u2208 R and a matrix A \u2208 R n\u00d7n\n, \u03bb\u2297A = \u03bb\u22a0A, will simply be indicated by \u03bbA. Note that, with the notation above, (R,\u229e,\u22a0) forms a dual dioid called the min-plus algebra."
        },
        {
            "heading": "2.2 Precedence graphs and multi-precedence graphs",
            "text": "A directed graph is a pair (N,E) where N is a finite set of nodes and E \u2286 N\u00d7N is the set of arcs. A weighted directed graph is a triplet (N,E,w), where (N,E) is a directed\ngraph, and w : E \u2192 R is a function that associates a weight w((i, j)) to each arc (i, j) \u2208 E of graph (N,E).\nThe precedence graph associated with a matrix A \u2208 Rn\u00d7nmax is the weighted directed graph G(A) = (N,E,w), where N = {1, . . . , n}, and E and w are defined in the following (non-standard) way: there is an arc (i, j) \u2208 E from node i to node j if and only if Aij 6= \u2212\u221e, and w is such that w((i, j)) = Aij . We adopt this non-standard convention of associating Aij to the weight of arc (i, j) instead of (j, i), as this will simplify the interpretation of the label of a path in multi-precedence graphs. When elements of A are functions of some real parameters, A = A(\u03bb1, . . . , \u03bbp), \u03bb1, . . . , \u03bbp \u2208 R, we say that G(A) is a parametric precedence graph. A sequence of r + 1 nodes \u03c1 = (i1, i2, . . . , ir+1), r \u2265 1, such that (ij , ij+1) \u2208 E for all j \u2208 {1, . . . , r} is a path of length r; a path \u03c1 such that i1 = ir+1 is called a circuit. The weight of a path is the sum (in conventional algebra) of the weights of the arcs composing it. Elements of the max-plus power of a matrix A have a clear meaning with respect to precedence graph G(A); indeed, (Ar)ij corresponds to the maximum weight of all paths in G(A) of length r from node i to node j. The maximum circuit mean of a precedence graph G(A) with n nodes can be computed in the max-plus algebra as mcm(A) = \u2295n\nk=1 tr(A k) 1 k , where a 1 k is the kth max-plus\nroot of a \u2208 Rmax and corresponds to a k in standard algebra. We recall that a precedence graph G(A) does not contain circuits with positive weight if and only if tr(A\u2217) = 0; otherwise, if there is at least one circuit with positive weight in G(A), then tr(A\u2217) = \u221e.\nIn this paper, we will make use of another class of graphs, called multi-precedence graphs, which will allow us to analyze parametric precedence graphs using tools from formal languages and automata theory. The reader familiar with max-plus automata will notice their similarity to multiprecedence graphs. The multi-precedence graph associated with matrices A1, . . . , Al \u2208 Rn\u00d7nmax is the weighted multi-directed graph G(A1, . . . , Al) = (N,\u03a3, \u00b5, E), where N = {1, . . . , n} is the set of nodes, \u03a3 = {a1, . . . , al} is the alphabet of symbols a1, . . . , al, \u00b5 : \u03a3 \u2192 Rn\u00d7nmax is the morphism defined by \u00b5(ai) = Ai for all i \u2208 {1, . . . , l}, and E \u2286 N \u00d7 \u03a3 \u00d7 N is the set of labeled arcs, defined such that there is an arc (i, z, j) \u2208 E from node i to node j labeled z with weight (\u00b5(z))ij if and only if (\u00b5(z))ij 6= \u2212\u221e. A path in a multi-precedence graph G(A1, . . . , Al) is a sequence of alternating nodes and labels of the form \u03c3 = (i1, z1, i2, z2, . . . , zr, ir+1), r \u2265 1, such that (ij , zj , ij+1) \u2208 E for all j = 1, . . . , r; we will say that path \u03c3 is labeled s = z1z2 . . . zr.\nIt is convenient to extend morphism \u00b5 to \u00b5 : 2\u03a3 \u2217 \u2192 R n\u00d7n\nas follows: for all z \u2208 \u03a3, L1,L2 \u2286 \u03a3\u2217, \u00b5({e}) = E\u2297, \u00b5({z}) = \u00b5(z), \u00b5(L1 \u222a L2) = \u00b5(L1) \u2295 \u00b5(L2), and \u00b5(L1L2) = \u00b5(L1) \u2297 \u00b5(L2). In this way, given a language L \u2286 \u03a3\u2217, \u00b5(L)ij = \u2295\ns\u2208L \u00b5(s)ij corresponds to the supremum, for all strings s \u2208 L, of the weights of all paths labeled s in G(A1, . . . , Al) from node i to node j; in particular, tr(\u00b5(L)\u2217) = 0 if and only if no circuits with positive weight exist in G(A1, . . . , Al) among those with label s \u2208 L. Moreover, the following properties hold: for all L1,L2,L \u2286 \u03a3\u2217, L1 \u2286 L2 \u21d2 \u00b5(L1) \u00b5(L2), and \u00b5(L\u2217) = \u00b5(L)\u2217. We will indicate by \u0393, respectively, \u0393M , the set\nAlgorithm 1: Solve NCP(P, I, C)\nInput: P, I, C \u2208 Rn\u00d7nmax Output: \u039bNCP(\u03bbP \u2295 \u03bb\n\u22121I \u2295 C) 1 if G(C) /\u2208 \u0393 then return \u2205 2 P \u2190 C\u2217PC\u2217, I \u2190 C\u2217IC\u2217, S \u2190 E\u2297 3 for k = 1 to \u230a n\n2\n\u230b\ndo\n4 S \u2190 PS2I \u2295 IS2P \u2295 E\u2297 5 if G(S) /\u2208 \u0393 then return \u2205 6 return [mcm(IS\u2217), (mcm(PS\u2217))\u22121] \u2229 R\nof all precedence graphs, respectively, multi-precedence graphs, that do not contain circuits with positive weight. The following proposition allows us to study the sign of circuit weights in some precedence graphs using multiprecedence graphs.\nProposition 3. (Zorzenon et al. [2022a]). Let A1, . . . , Al \u2208 Rn\u00d7nmax . There exists a circuit with positive weight visiting node i \u2208 {1, . . . , n} in multi-precedence graph G(A1, . . . , Al) if and only if there exists a circuit with positive weight visiting node i in precedence graph G(A1\u2295 . . .\u2295Al).\nGiven a parametric precedence graph G(A), where A = A(\u03bb1, . . . , \u03bbl), the non-positive circuit weight problem (NCP) consists in characterizing the set \u039bNCP(A) = {(\u03bb1, . . . , \u03bbl) \u2208 Rl | G(A) \u2208 \u0393} of all values of parameter (\u03bb1, . . . , \u03bbl) for which G(A) does not contain circuits with positive weight. When matrix A has the form A(\u03bb) = \u03bbP\u2295 \u03bb\u22121I \u2295 C for arbitrary matrices P, I, C \u2208 Rn\u00d7nmax (called proportional, inverse, and constant matrix, respectively), then \u039bNCP(\u03bbP\u2295\u03bb\u22121I\u2295C) = [\u03bbmin, \u03bbmax]\u2229R is an interval; moreover, its extremes can be found either in weakly polynomial time using linear programming solvers such as the interior-point method, or in strongly polynomial time O(n4) using Algorithm 1, see Zorzenon et al. [2022a]."
        },
        {
            "heading": "3. P-TIME EVENT GRAPHS",
            "text": "Definition 4. (From Calvez et al. [1997]). An unweighted P-time Petri net (P-TPN) is a 5-tuple (P , T , E,m, \u03b9), where (P \u222a T , E) is a directed graph in which the set of nodes is partitioned into the set of places, P , and the set of transitions, T , the set of arcs E is such that E \u2286 (P \u00d7 T ) \u222a (T \u00d7 P), m : P \u2192 N0 is a map such that m(p) represents the number of tokens initially residing in place p \u2208 P (also called initial marking of p), and \u03b9 : P \u2192 {[\u03c4\u2212, \u03c4+] | \u03c4\u2212 \u2208 R\u22650, \u03c4+ \u2208 R\u22650 \u222a {\u221e}, \u03c4\u2212 \u2264 \u03c4+} is a map that associates to every place p \u2208 P a time interval \u03b9(p) = [\u03c4\u2212p , \u03c4 + p ].\nThe dynamics of a P-TPN net is briefly described as follows. A transition t is enabled when either it has no upstream place or each upstream place p of t contains at least one token which has resided in p for a time between \u03c4\u2212p and \u03c4 + p (extremes included). When transition t is enabled, it may fire; its firing causes one token to be removed instantaneously from each of the upstream places of t, and one token to be added, again instantaneously, to each of the downstream places of t. If a token sojourns more than \u03c4+p time instants in a place p, then said token is dead, as it is forced to remain in p forever.\nA P-time event graph (P-TEG) is a P-TPN in which every place has exactly one upstream and one downstream\ntransition. Without loss of generality (see S\u030cpac\u030cek and Komenda [2017]), we will suppose that the initial marking m(p) is less than or equal to 1 for each place p \u2208 P of a P-TEG. This allows to rephrase the dynamics of a P-TEG with |T | = n transitions as a max-plus lineardual inequality system (LDI), i.e., a system of dynamical (\u2295,\u2297)- and (\u229e,\u22a0)-linear inequalities of the form\n\u2200k \u2208 N0,\n{\nA0 \u2297 x(k) x(k) B0 \u22a0x(k) A1 \u2297 x(k) x(k + 1) B1 \u22a0x(k) , (1)\nwhere x : N0 \u2192 Rn is called dater function, A0, A1 \u2208 R\nn\u00d7n max , B 0, B1 \u2208 Rn\u00d7nmin are called characteristic matrices of the P-TEG, and are defined as follows. If there exists a place p with initial marking \u00b5 \u2208 {0, 1}, upstream transition tj and downstream transition ti, then A \u00b5 ij = \u03c4 \u2212 p and B\u00b5ij = \u03c4 + p ; otherwise, A \u00b5 ij = \u2212\u221e and B \u00b5 ij = \u221e. By convention, element xi(k) of the dater function represents the time at which transition ti fires for the (k + 1)\nst time. Since the (k + 2)nd firing of any transition cannot occur before the (k + 1)st, we require the dater to be a nondecreasing function, i.e., \u2200i \u2208 {1, . . . , n}, xi(k+1) \u2265 xi(k).\nIf a non-decreasing dater trajectory {x(k)}k\u2208N0 satisfying (1) exists, then the trajectory is said to be consistent for the P-TEG, as it does not cause the death of any token, and the P-TEG is said to be consistent. A trajectory {x(k)}k\u2208N0 is 1-periodic with period \u03bb \u2208 R\u22650, if it has the form {\u03bbkx(0)}k\u2208N0 , in the max-plus algebra sense; in standard algebra, this corresponds to a dater trajectory such that, for all i \u2208 {1, . . . , n}, xi(k) = k\u03bb + xi(0). Moreover, we indicate by \u039bP-TEG(A\n0, A1, B0, B1) \u2286 R the set of \u03bb \u2265 0 for which there exists a 1-periodic trajectory of period \u03bb that is consistent for the P-TEG characterized by matrices A0, A1, B0, B1; such periods are called cycle times. We say that a trajectory {x(k)}k\u2208N0 is delay-bounded if there exists a positive real number M such that, for all i, j \u2208 {1, . . . , n} and for all k \u2208 N0, xi(k) \u2212 xj(k) < M ; a P-TEG admitting a consistent delay-bounded trajectory of the dater function is said to be boundedly consistent. To our knowledge, no algorithm that checks whether a P-TEG is consistent has been found until now; on the other hand, there exists an algorithm that checks bounded consistency of P-TEGs in time O(n4), which comes directly from the following result.\nTheorem 5. (Zorzenon et al. [2020, 2022b]). A P-TEG is boundedly consistent if and only if it admits a consistent 1-periodic trajectory, i.e., if and only if set \u039bP-TEG(A\n0, A1, B0, B1) is non-empty. Moreover, \u039bP-TEG(A 0, A1, B0, B1) coincides with\n\u039bNCP(\u03bbB 1\u266f \u2295 \u03bb\u22121A1 \u2295 (A0 \u2295B0\u266f)) \u2229 [0,\u221e[.\nExample 6. Consider the P-TEG represented in Figure 1, in which time windows are parametrized with respect to label z; in Table 1, values of time windows are given for z \u2208 {a, b, c}. The matrices characterizing the P-TEG\nlabeled z are:\nA0z =\n[\n\u2212\u221e \u2212\u221e 0 \u2212\u221e\n]\n, A1z =\n[\n\u03b1z \u2212\u221e \u2212\u221e \u03b2z\n]\n,\nB0z =\n[\n\u221e \u221e \u221e \u221e\n]\n, B1z =\n[\n\u03b1z \u221e \u221e \u03b2z\n]\n.\nSince lower and upper bounds for the sojourn times of the two places with an initial token coincide, once dater xz(0) is chosen (such that the first inequality in (1) is satisfied for k = 0, i.e., xz,2(0) \u2265 xz,1(0)), the only trajectory {xz(k)}k\u2208N0 that is a candidate to be consistent for the P-TEG labeled z is deterministically given by\n\u2200k \u2208 N0, xz(k + 1) =\n[\n\u03b1z + xz,1(k) \u03b2z + xz,2(k)\n]\n.\nHowever, it is easy to see that, for any valid choice of the initial dater, candidate trajectory {xa(k)}k\u2208N0 is not consistent (as for a sufficiently large k, xa,2(k) < xa,1(k)), and {xb(k)}k\u2208N0 , despite being consistent, is not delaybounded and results in the infinite accumulation of tokens in the place between t1 and t2 for k \u2192 \u221e. On the other hand, {xc(k)}k\u2208N0 is consistent and delay-bounded (in fact, it is 1-periodic with period 1); thus we can conclude that the P-TEG labeled a is not consistent, the one labeled b is consistent but not boundedly consistent, and the one labeled c is boundedly consistent. Of course, we would have reached the same conclusions regarding delay-boundedness by using Theorem 5. In particular, applying Algorithm 1, we get\n\u039bP-TEG(A 0 a , A 1 a , B 0 a , B 1 a ) = \u039bP-TEG(A 0 b, A 1 b, B 0 b , B 1 b) = \u2205,\n\u039bP-TEG(A 0 c , A 1 c , B 0 c , B 1 c ) = [1, 1] = {1}."
        },
        {
            "heading": "4. SWITCHED MAX-PLUS LINEAR-DUAL INEQUALITIES",
            "text": ""
        },
        {
            "heading": "4.1 General description",
            "text": "We start by defining a switched LDI (SLDI) as the natural extension of the dynamical inequalities of P-TEGs, in which the mode of operation can switch. Each mode is associated with a set of n events that have to satisfy certain time window constraints. An SLDI is a 5-tuple S = (\u03a3, A0, A1, B0, B1), where \u03a3 = {a1, . . . , am} is a finite alphabet whose symbols are called modes, and A0, A1 : \u03a3 \u2192 Rn\u00d7nmax , B\n0, B1 : \u03a3 \u2192 Rn\u00d7nmin are functions that associate a matrix to each mode of \u03a3; for sake of simplicity, given a mode z \u2208 \u03a3, we will write A0z , A 1 z , B 0 z , B 1 z in place of A0(z), A1(z), B0(z), B1(z), respectively. A schedule w \u2208 \u03a3\u03c9 is an infinite concatenation of modes.\nThe dynamics of an SLDI S under schedule w \u2208 \u03a3\u03c9 is expressed by the following system of inequalities: for all k \u2208 N0, {\nA0wk+1 \u2297 x(wk]) x(wk]) B 0 wk+1 \u22a0 x(wk]) A1wk+1 \u2297 x(wk]) x(wk+1]) B 1 wk+1 \u22a0 x(wk]) , (2) where function x : Pre(w) \u2192 Rn is called dater of S associated with schedule w. Term xi(wk]) represents the\ntime of the occurrence of event i associated with mode wk+1.\nWhen schedule w is fixed, we can extend the definition of some properties of P-TEGs to SLDIs in a natural way. For instance, if there exists a trajectory of the dater {x(wk])}k\u2208N0 that satisfies (2) for all k \u2208 N0, then the trajectory is consistent for the SLDI under schedule w, and we say that the SLDI is consistent under schedule w. The definitions of delay-bounded trajectory and bounded consistency are generalized to SLDIs under schedule w in a similar way.\nThe interpretation of bounded consistency of an SLDI under a fixed schedule w is analogous to the one of P-TEGs (see Zorzenon et al. [2020]). When a process consisting of several tasks (each represented by an event) is modeled by an SLDI that is not boundedly consistent under a schedule w, then the execution of every possible sequence of tasks following w will either lead to the violation of some time window constraints (if the SLDI is not consistent under w), or to the infinite accumulation of delay between the execution of some tasks (if the only consistent trajectories are not delay-bounded)."
        },
        {
            "heading": "4.2 Analysis of fixed periodic schedules",
            "text": "In this subsection, we analyze bounded consistency and cycle times of an SLDI when schedule w is periodic, i.e., when it can be written as w = v\u03c9, where v \u2208 \u03a3\u2217 is a finite subschedule. Similarly to P-TEGs, it is natural to assume the following non-decreasingness condition for the dater of an SLDI: for all k \u2208 N0, h \u2208 {0, . . . , |v| \u2212 1}, x(vk+1v1v2 . . . vh) x(vkv1v2 . . . vh). The meaning is that events occurring during the (k+2)nd repetition of mode vh, at the hth position in subschedule v, cannot occur earlier than those taking place during the (k + 1)st one.\nWe define v-periodic trajectories of period \u03bb \u2208 R\u22650 for SLDIs under schedule w = v\u03c9 as those dater trajectories that, for all k \u2208 N0, h \u2208 {0, . . . , |v| \u2212 1}, satisfy x(vk+1v1 . . . vh) = \u03bbx(v kv1 . . . vh); \u039b v SLDI(S) denotes the set of all periods \u03bb, called cycle times, for which there exists a consistent v-periodic trajectory. Their relationship with 1-periodic trajectories in P-TEGs is made clear by the following example.\nExample 7. Let us analyze the SLDI S, with \u03a3 = {a, b, c}, and A0z , A 1 z , B 0 z , B 1 z defined as in Example 6; now label z \u2208 \u03a3 is to be interpreted as a mode. Thus, for each event k, the dynamics of the SLDI may switch among those specified by the P-TEGs labeled a, b, and c. We consider periodic schedules (ac)\u03c9 and (ab)\u03c9; observe that for w = v\u03c9, with v \u2208 {ac, ab} (i.e., v1 = a and v2 = c or v2 = b) the SLDI following w can be written as: for all k \u2208 N0,\n\n \n  \nA0v1 \u2297 x(v k) x(vk) B0v1 \u22a0 x(v k) A1v1 \u2297 x(v k) x(vkv1) B 1 v1 \u22a0 x(vk)\nA0v2 \u2297 x(v kv1) x(v kv1) B 0 v2 \u22a0 x(vkv1) A1v2 \u2297 x(v kv1) x(v k+1) B1v2 \u22a0 x(v kv1)\n. (3)\nBy defining x\u0303(k) = [x\u22ba(vk), x\u22ba(vkv1)] \u22ba, the above set of inequalities can be rewritten as an LDI: for all k \u2208 N0, {\nA0v \u2297 x\u0303(k) x\u0303(k) B 0 v \u22a0 x\u0303(k) A1v \u2297 x\u0303(k) x\u0303(k + 1) B 1 v \u22a0 x\u0303(k) , (4a) (4b)\nwhere\nA0v =\n[\nA0v1 E A1v1 A 0 v2\n]\n, A1v =\n[\nE A1v2 E E\n]\n,\nB0v =\n[\nB0v1 T B1v1 B 0 v2\n]\n, B1v =\n[\nT B1v2 T T\n]\n.\nTo see the equivalence of (3) and (4), observe that the second block of (4a) reads A1v1 \u2297 x(v k)\u2295A0v2 \u2297 x(v kv1) x(vkv1) B1v1 \u22a0x(v k)\u229eB0v2 \u22a0x(v\nkv1). From this transformation, we can easily conclude that S is boundedly consistent under v\u03c9 if and only if the LDI with characteristic matrices A0v, A 1 v, B 0 v , B 1 v is boundedly consistent, and that all consistent v-periodic trajectories of S coincide with consistent 1-periodic trajectories of the LDI; hence,\n\u039bac SLDI (S) = \u039bP-TEG(A 0 ac, A 1 ac, B 0 ac, B 1 ac) = \u2205,\n\u039bab SLDI (S) = \u039bP-TEG(A 0 ab, A 1 ab, B 0 ab, B 1 ab) = [3, 3].\nIt is worth noting that, although P-TEGs labeled a and b are not boundedly consistent, the SLDI under schedule (ab)\u03c9 is. Thus, in general it is not possible to infer bounded consistency of an SLDI under a fixed schedule w solely based on the analysis of each mode appearing in w.\nBy generalizing the procedure shown in Example 7, we can derive the following proposition through some simple algebraic manipulations (to set up an equivalent LDI) and applying Theorem 5.\nProposition 8. An SLDI S is boundedly consistent under schedule w = v\u03c9 if and only if it admits a v-periodic trajectory. Moreover, set \u039bv\nSLDI (S) coincides with \u039bNCP(\u03bbPv\u2295\n\u03bb\u22121Iv \u2295 Cv), where\nPv = Y|v|,1 \u2297 t Pv|v| , Iv = Y1,|v| \u2297 t Iv|v| ,\nCv =\n|v|\u22121 \u2295\nr=1\n(Yr,r+1 \u2297 t Pvr \u2295 Yr+1,r \u2297 t Ivr \u2295 Yr,r \u2297 t Cvr )\n\u2295Y|v|,|v| \u2297 t Cv|v| ,\nwhere, for all i, j \u2208 {1, . . . , |v|}, Yi,j \u2208 R |v|\u00d7|v| max , with (Yi,j)hk = 0 if h = i and k = j, (Yi,j)hk = \u2212\u221e else, for all r \u2208 {1, . . . , |v|}, Pvr = B 1\u266f vr , Ivr = A 1 vr , and Cvr = A 0 vr \u2295 B0\u266fvr .\nFor instance, when |v| = 5, matrix \u03bbPv \u2295 \u03bb\u22121Iv \u2295 Cv has the form\n\n   \nCv1 Pv1 E E \u03bb \u22121Iv5 Iv1 Cv2 Pv2 E E E Iv2 Cv3 Pv3 E E E Iv3 Cv3 Pv4\n\u03bbPv5 E E Iv4 Cv5\n\n    , (5)\nwhich can be rewritten, using the tensor product, as Y1,1\u2297 tCv1 \u2295Y1,2\u2297 tPv1 \u2295\u03bb \u22121Y1,5\u2297 t Iv5 \u2295Y2,1\u2297 t Iv1 \u2295 . . .\nProposition 8 directly provides an algorithm to compute the minimum and maximum cycle times of an SLDI under a fixed periodic schedule. Indeed, these values come from solving the NCP for parametric precedence graph G(\u03bbPv\u2295 \u03bb\u22121Iv \u2295 Cv). However, this approach results in a slow (although strongly polynomial time) algorithm when the length of subschedule v is large; indeed, its time complexity is O((|v|n)4) = O(|v|4n4), as the considered precedence graph has |v|n nodes. In the next subsection, we show how to exploit the sparsity of \u03bbPv \u2295\u03bb\u22121Iv \u2295Cv, illustrated for |v| = 5 in (5), to develop an algorithm of linear complexity in the subschedule length."
        },
        {
            "heading": "4.3 Improved algorithm",
            "text": "Let us start by defining the multi-precedence graph Gv associated with parametric precedence graph G(\u03bbPv \u2295 \u03bb\u22121Iv \u2295 Cv): Gv = G(Y1,1 \u2297t Cv1 , Y1,2 \u2297 t Pv1 , Y1,|v| \u2297 t \u03bb\u22121Iv|v| , Y2,1 \u2297 t Iv1 , . . .) = (N, \u03a3\u0304, \u00b5, E) is such that N = {1, . . . , |v|n}, \u03a3\u0304 = {p1, . . . , p|v|, i1, . . . , i|v|, c1, . . . , c|v|}, for all r \u2208 {1, . . . , |v| \u2212 1}, \u00b5(pr) = Yr,r+1 \u2297t Pvr , \u00b5(ir) = Yr+1,r\u2297t Ivr , \u00b5(cr) = Yr,r\u2297 tCvr , \u00b5(p|v|) = \u03bbY|v|,1\u2297 tPv|v| , \u00b5(i|v|) = \u03bb \u22121Y1,|v| \u2297 t Iv|v| , \u00b5(c|v|) = Y|v|,|v| \u2297 t Cv|v| . The multi-precedence graph Gv is schematized by the lumpednode representation of Figure 2 in the case |v| = 5. In this representation, j\u0304 indicates the set of nodes {(j \u2212 1)n + 1, . . . , jn} of Gv, and an arc from i\u0304 to j\u0304 with label z indicates that, in Gv, every arc from a node in i\u0304 to a node in j\u0304 is labeled z.\nLet L1 be the (regular) language containing the labels of all circuits inGv from any node in 1\u0304 = {1, . . . , n}. With the visual aid of the lumped-node representation, we can use automata-theory techniques to determine an expression for L1: reinterpret the lumped-node representation of Gv as a deterministic finite automaton with states j\u0304 for all j \u2208 {1, . . . , |v|}; then, L1 is the language recognized by the automaton when 1\u0304 is both initial and final state. Once we get L1, values of \u03bb such that tr(\u00b5(L1)) = 0 will correspond to those for which there are no circuits in Gv, visiting at least one node from 1\u0304, with positive weight; we will see later how to derive from this observation a low-complexity algorithm that finds all \u03bb\u2019s such that Gv \u2208 \u0393M \u2013 clearly, due to Proposition 3 these values correspond to the cycle times that we are looking for. Language L1 can be written as follows: L1 = (P|v| \u222a I|v| \u222a C P |v| \u222a C I |v| \u222a c1) \u2217, where\n- P|v| = c \u2217 1Lc \u2217 1 is such that L \u2286 \u03a3\u0304 \u2217 contains all strings s \u2208 L1 with s1 = p1, s|s| = p|v|, |s|p1 = |s|p|v| = 1; - I|v| = c \u2217 1Lc \u2217 1 is such that L \u2286 \u03a3\u0304\n\u2217 contains all strings s \u2208 L1 with s1 = i|v|, s|s| = i1, |s|i1 = |s|i|v| = 1;\n- CP|v| = c \u2217 1Lc \u2217 1 is such that L \u2286 \u03a3\u0304 \u2217 contains all strings\ns \u2208 L1 with s1 = p1, s|s| = i1, |s|p|v| = |s|i|v| = 0, and |s|p1 = |s|i1 = 1;\n- CI|v| = c \u2217 1Lc \u2217 1 is such that L \u2286 \u03a3\u0304 \u2217 contains all strings\ns \u2208 L1 with s1 = i|v|, s|s| = p|v|, |s|p1 = |s|i1 = 0, and |s|p|v| = |s|i|v| = 1.\nTo get an expression for L1, it is convenient to first define some auxiliary languages: for all r \u2208 {1, . . . , |v|}, Pr =\nc\u2217rprc \u2217 r+1, Ir = c \u2217 r+1irc \u2217 r with c|v|+1 := c1. Then, P1 = P|v|, I1 = I1, CP1 = C I 1 = {e}, and for all r \u2208 {1, . . . , |v| \u2212 1},\nPr+1 = P|v|\u2212rC P r Pr, Ir+1 = Ir+1C I rIr, C P r+1 = (P|v|\u2212rC P r I|v|\u2212r) \u2217, CIr+1 = (Ir+1C I rPr+1) \u2217.\nFor instance, in the case |v| = 5, we get\nP5 = P1(P2(P3(P4I4) \u2217I3) \u2217I2) \u2217\nP2(P3(P4I4) \u2217I3) \u2217P3(P4I4) \u2217P4P5,\nI5 = I5(I4(I3(I2P2) \u2217P3) \u2217P4) \u2217\nI4(I3(I2P2) \u2217P3) \u2217I3(I2P2) \u2217I2I1,\nC P 5 = P1(P2(P3(P4I4) \u2217I3) \u2217I2) \u2217I1, C\nI 5 = I5(I4(I3(I2P2) \u2217P3) \u2217P4) \u2217P5.\nObserve that, for all A,B,C \u2208 Rn\u00d7nmax and i, j \u2208 {1, . . . , |v|}, the following properties hold: from Y 2i,i = Yi,i, Proposition 1, and the fact that in the max-plus algebra the tensor product distributes over infinite sums,\n(Yi,i \u2297 t A)\u2217 =\n\u221e \u2295\nk=0\n(Yi,i \u2297 t A)k =\n\u221e \u2295\nk=0\nY ki,i \u2297 t Ak\n= Yi,i \u2297 t\n\u221e \u2295\nk=0\nAk = Yi,i \u2297 t A\u2217;\nmoreover, since Yi,j \u2297 Yj,j \u2297 Yj,i = Yi,i,\n((Yi,j \u2297 t A)(Yj,j \u2297 t B)(Yj,i \u2297 t C))\u2217 = Yi,i \u2297 t (ABC)\u2217.\nHence, for some matrices LP , LI , LCP , LCI \u2208 R n\u00d7n\n, \u00b5(P|v|) = Y1,1 \u2297 t \u03bbLP , \u00b5(I|v|) = Y1,1 \u2297 t \u03bb\u22121LI , \u00b5(C P |v|) = Y1,1 \u2297t LCP , \u00b5(CI|v|) = Y1,1 \u2297 t LCI , and\n\u00b5(L1) = Y1,1 \u2297 t (\u03bbLP \u2295 \u03bb \u22121LI \u2295 LCP \u2295 LCI \u2295 Cv1) \u2217.\nFinally, from Proposition 2 and tr(Y1,1) = 0, we get tr(\u00b5(L1)) = tr((\u03bbLP \u2295 \u03bb\u22121LI \u2295 LCP \u2295 LCI \u2295 Cv1)\n\u2217) = 0 if and only if G(\u03bbLP \u2295 \u03bb\u22121LI \u2295 LCP \u2295 LCI \u2295 Cv1) \u2208 \u0393. Observe that we obtained an NCP that can be solved in O(n4) using Algorithm 1.\nTo find all \u03bb\u2019s for which Gv \u2208 \u0393M , we still need to verify that there are no circuits with positive weight among those visiting only nodes that are not in 1\u0304 (if this is not true, then \u039bvSLDI(S) = \u2205). This can be done by checking that, for all r \u2208 {1, . . . , |v|}, G(\u00b5(cr)) \u2208 \u0393, and G(\u00b5(CPr )) \u2208 \u0393 (or, equivalently, G(\u00b5(CIr)) \u2208 \u0393). Indeed, a circuit \u03c3 starting from a node in r\u0304 that does not visit any node in 1\u0304 either does not visit any node in other sets j\u0304 6= r\u0304, in which case the label s of \u03c3 belongs to c\u2217r , or it does. In the second case, take the smallest j for which \u03c3 visits nodes in j\u0304, say j\u2032. If j\u2032 = r, then s \u2208 CPr ; otherwise, there exists a circuit \u03c3\u2032 with label s\u2032 that visits the same nodes of \u03c3 using the same arcs, but starting from a node in j\u0304\u2032. Thus, the weights of \u03c3 and \u03c3\u2032 coincide, and s\u2032 \u2208 CPj\u2032 . This proves that G(\u00b5(cr)) \u2208 \u0393 and G(\u00b5(CPr )) \u2208 \u0393 \u2200r \u2208 {1, . . . , |v|} is a necessary and sufficient condition for the non-positiveness of the weight of all circuits in Gv not visiting nodes in 1\u0304. Note that, similarly to \u00b5(L1), \u00b5(cr) and \u00b5(CPr ) can be written as the tensor product between Yr,r and an n\u00d7 n matrix, and we can exploit this fact to decrease the complexity for checking the non-positiveness of the circuits of their associated precedence graphs.\nThe discussed procedure to compute the minimum and maximum cycle times of an SLDI S under schedule v\u03c9 is summarized in Algorithm 2. Note that the time complexity to run lines 1\u201311 isO(|v|n3), as the three for-loops perform\nAlgorithm 2: Compute \u039bv SLDI (S) Input: Pz, Iz, Cz \u2208 R n\u00d7n max for all z \u2208 \u03a3, v \u2208 \u03a3 \u2217 Output: \u039bv SLDI\n(S) 1 for r = 1 to |v| do 2 if G(Cvr ) /\u2208 \u0393 then return \u2205 3 v|v|+1 \u2190 v1 4 for r = 1 to |v| do 5 Pr \u2190 C\u2217vrPvrC \u2217 vr+1 , Ir \u2190 C\u2217vr+1IvrC \u2217 vr 6 LCP \u2190 E\u2297, LCI \u2190 E\u2297, LP \u2190 Pv|v| , LI \u2190 Iv1 7 for r = 2 to |v| do 8 if G(P|v|\u2212r+1LCP I|v|\u2212r+1) /\u2208 \u0393 or G(IrLCIPr) /\u2208 \u0393 then 9 return \u2205\n10 LP \u2190 P|v|\u2212r+1LCPLP , LI \u2190 IrLCILI 11 LCP \u2190 (P|v|\u2212r+1LCP I|v|\u2212r+1) \u2217, LCI \u2190 (IrLCIPr) \u2217 12 return Solve NCP(LP , LI , LCP \u2295 LCI \u2295 Cv1 )\noperations of complexity O(n3), namely, multiplying n\u00d7n matrices, computing their star, and checking whether the associated precedence graphs contain circuits with positive weight. Line 12 requiresO(n4) operations; thus, the overall time complexity of Algorithm 2 is O(|v|n3 + n4), which is linear in the length of subschedule v, and its space complexity is O(|v|n2)."
        },
        {
            "heading": "5. PRACTICALLY-MOTIVATED EXAMPLE",
            "text": "The example we present is a multi-product processing network taken from Kats et al. [2008]. Examples of such networks are electroplating lines and cluster tools. Consider a manufacturing system consisting of 5 processing stations S1, . . . , S5 and a robot of capacity one. The system can treat two types of parts, part a, which requires to be processed in S1, S3, and S5 in this order, and part b, which must follow route S2, S1, S4, S5. The task of the robot is to transport parts of type a and b from an input storage S0 to their first processing stations, between the processing stations (in the right order), and finally from the last processing station to an output storage S6. The time the robot takes to travel from Si to Sj is \u03c4ij when it is not carrying any part, and \u03c4 zij when it is carrying part z \u2208 {a, b}. Moreover, the processing time for part z in station Si must be within the interval \u03b9 z i = [L z i, R z i ] \u2282 R\u22650.\nWe suppose that initially station S3 is processing a part of type a, and S2, S4 are processing parts of type b. We denote by Si z \u2212\u2192 Sj robot operation \u201cunload a part of type z from Si, transport it to and load it into Sj\u201d and by \u2192 Sj operation \u201ctravel from the current location to Sj and wait if necessary\u201d. A schedule for this process is an infinite sequence of modes w \u2208 {a, b}\u03c9, where mode a represents the sequence of operations \u2192 S3 a \u2212\u2192 S5 \u2192 S0 a \u2212\u2192 S1 \u2192 S5 a \u2212\u2192 S6 \u2192 S1 a \u2212\u2192 S3 and mode b represents \u2192 S4 b \u2212\u2192 S5 \u2192 S2 b \u2212\u2192 S1 \u2192 S5 b \u2212\u2192 S6 \u2192 S0 b \u2212\u2192 S2 \u2192 S1 b \u2212\u2192 S4. Initially, the robot is positioned at S3 if w1 = a or at S4 if w1 = b. We consider the following parameters for the processing network: \u03c4ij = |i\u2212j|, \u03c4 a ij = \u03c4ij+1, \u03c4 b ij = \u03c4ij+2, \u03b9a1 = [10, 15], \u03b9 a 3 = [40, 140], \u03b9 a 5 = [20, 30], \u03b9 b 2 = [50, 150], \u03b9b1 = [10, 20], \u03b9 b 4 = [30, 150], \u03b9 b 5 = [20, 30].\nLet us first model the processing network when only part a, respectively, b is considered. In this way, we obtain two P-TEGs, P-TEGa and P-TEGb (shown in Figure 3),\neach of which represents the behavior of the system when processing only parts of one type. Using Algorithm 1, we can find that the cycle times of the network when processing only parts of type a, b are all values in [73,\u221e[, and [72, 192], respectively. Now, from the obtained PTEGs, we can model the processing network in the case where both part-types are considered as an SLDI S = ({a, b}, A0, A1, B0, B1). To do so, we must define matrices A0z , A 1 z , B 0 z , B 1 z \u2208 R n\u00d7n max for z \u2208 {a, b} appropriately: we start by adding in P-TEGa (respectively, P-TEGb) the missing transitions from P-TEGb (respectively, P-TEGa) \u2013 the obtained P-TEGs have both n = 12 transitions (in general, n = 2 + 2 \u00d7 number of processing stations). For each new transition ti of P-TEGz, we define (A 1 z )ii = (B1z )ii = 0; this is done to store in auxiliary variables xi(wk]z) = xi(wk]) the last entrance and exit times of parts in stations that are not used in mode z. Moreover, to model the transportation of the robot from S3 to S4 (respectively, from S4 to S3) after each switching of mode from a to b (respectively, from b to a), we set (A1a)4out,3in = \u03c434 (respectively, (A1b)3out,4in = \u03c443). The other elements of A0z , A 1 z , B 0 z , B 1 z are taken from the characteristic matrices of P-TEGz, for z \u2208 {a, b}. The modeling effort required to define S is repaid by the possibility to use Algorithm 2 for computing the minimum and maximum cycle times corresponding to a schedule w = v\u03c9 . For instance, we get \u039babSLDI(S) = [77, 192]. This means that, using schedule (ab)\u03c9, we can obtain one final product of each type every at least 77 and at most 192 time units.\nTo appreciate the advantage of using Algorithm 2, in Figure 4 we show the computational time to get \u039bvSLDI(S) with increasing subschedule length |v|, using different methods: Algorithm 2, the algorithm derived from Proposition 8 directly, the algorithm developed in Kats et al. [2008], and a linear programming solver. The first three algorithms were implemented onMatlab R2019a, for solving the linear programs we used CPLEX\u2019s dual simplex method; the tests were executed on a PC with an Intel i7 processor at 2.20Ghz. From the results, we can see that the most timeconsuming approach is the one using Proposition 8 directly, while Algorithm 2 achieves the fastest computation. This shows how critical the exploitation of the sparsity of matrix \u03bbPv \u2295 \u03bb\u22121Iv \u2295 Cv is for decreasing computation time."
        },
        {
            "heading": "6. FINAL REMARKS",
            "text": "We have shown that SLDIs can model plants such as multiproduct processing networks, and provided an inexpensive method to compute minimum and maximum cycle times when they follow a fixed and periodic schedule. We remark that the complexity reduction achieved by exploiting the sparsity of matrix \u03bbPv \u2295 \u03bb\u22121Iv \u2295 Cv through techniques from automata theory could be generalized to solve NCPs on matrices with different distributions of non-\u03b5 elements; practical applications in a variety of scheduling problems are expected. Regarding SLDIs, plenty of problems of theoretical and practical relevance remain open, such as the complexity of verifying the existence of a schedule w under which the SLDI is boundedly consistent. Finally, we argue that, as implicit switching max-plus linear systems generalize the dynamics of max-plus automata (cf. Van Den Boom and De Schutter [2006]), SLDIs generalize the\ndynamics of interval weighted automata. This would imply that SLDIs can be used to represent and solve scheduling problems for systems modeled by safe P-time Petri nets (cf. Komenda et al. [2020])."
        }
    ],
    "year": 2022
}