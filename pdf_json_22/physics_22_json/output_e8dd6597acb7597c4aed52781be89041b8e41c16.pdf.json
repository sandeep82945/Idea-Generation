{
    "abstractText": "Quantum computers are often cited as superior to classical computers[1], and some actors have even claimed to have demonstrated their supremacy over their classical predecessors[2], in the sense of exhibiting a computational problem to which the quantum machine produces a correct answer more efficiently than any classical machine can. Proving the existence of such an advantage would imply the existence of quantum algorithms which solve problems we believe to be intractable on modern classical machines. However, a single demonstration cannot prove the existence of such an advantage, as it could be the case that we are merely (and unknowingly) demonstrating the inadequacy of our own classical algorithms, when there does exist a more ingenious classical solution that reduces the performance gap. The proof of an advantage would require at least showing that BQP , the class of problems which can be computed efficiently by a quantum computer, is not contained in P , the class of problems which can be computed efficiently by a classical computer, implying the existence of problems within BQP which cannot be done efficiently on a classical computer. Here, I provide a stronger proof, exhibiting a family of decision problems which are trivially contained in BQP , but which also cannot even lie within NP , the parent class of P . This has significant implications for any scientist who wishes to solve a computationally demanding problem using existing hardware: it demonstrates that uncountably many problems are exponential faster on quantum machines than on classical ones. However, I must forecast that in this paper, I will work over a complete computational basis, which is to say, I permit the use of any possible one or two qubit gate in our circuits. This will require a bit of exposition to make our basis usable in a complexity-theoretic context.",
    "authors": [
        {
            "affiliations": [],
            "name": "Jonah Librande"
        }
    ],
    "id": "SP:21c58d13131283bb6be516e2f1d9bfac38141e4c",
    "references": [
        {
            "authors": [
                "A. Harrow",
                "A. Montanaro"
            ],
            "title": "Quantum computational supremacy",
            "venue": "Nature 549,",
            "year": 2017
        },
        {
            "authors": [
                "F Arute"
            ],
            "title": "Quantum supremacy using a programmable superconducting processor",
            "venue": "Nature 574,",
            "year": 2019
        },
        {
            "authors": [
                "J.M. Chappell",
                "M.A. Lohe",
                "L. von Smekal",
                "A. Iqbal",
                "D. Abbott"
            ],
            "title": "A Precise Error Bound for Quantum Phase Estimation",
            "venue": "PLoS ONE",
            "year": 2011
        },
        {
            "authors": [
                "S. Arora",
                "B. Barak"
            ],
            "title": "Computational Complexity: A Modern Approach",
            "year": 2009
        },
        {
            "authors": [
                "M.A. Nielsen",
                "Chuang",
                "I.L. Quantum Computation",
                "Quantum Information"
            ],
            "title": "10th Anniversary Edition 10th",
            "venue": "isbn: 1107002176",
            "year": 2011
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n20 9.\n10 39\n8v 1\n[ cs\n.C C\n] 1\n9 Se\np 20\n22\nBQP is not in NP\nJonah Librande1\n1University of Washington, Seattle, Washington 98195-1560, USA\nSeptember 22, 2022"
        },
        {
            "heading": "1 Introduction",
            "text": "Quantum computers are often cited as superior to classical computers[1], and some actors have even claimed to have demonstrated their supremacy over their classical predecessors[2], in the sense of exhibiting a computational problem to which the quantum machine produces a correct answer more efficiently than any classical machine can. Proving the existence of such an advantage would imply the existence of quantum algorithms which solve problems we believe to be intractable on modern classical machines. However, a single demonstration cannot prove the existence of such an advantage, as it could be the case that we are merely (and unknowingly) demonstrating the inadequacy of our own classical algorithms, when there does exist a more ingenious classical solution that reduces the performance gap. The proof of an advantage would require at least showing that BQP , the class of problems which can be computed efficiently by a quantum computer, is not contained in P , the class of problems which can be computed efficiently by a classical computer, implying the existence of problems within BQP which cannot be done efficiently on a classical computer. Here, I provide a stronger proof, exhibiting a family of decision problems which are trivially contained in BQP , but which also cannot even lie within NP , the parent class of P . This has significant implications for any scientist who wishes to solve a computationally demanding problem using existing hardware: it demonstrates that uncountably many problems are exponential faster on quantum machines than on classical ones.\nHowever, I must forecast that in this paper, I will work over a complete computational basis, which is to say, I permit the use of any possible one or two qubit gate in our circuits. This will require a bit of exposition to make our basis usable in a complexity-theoretic context."
        },
        {
            "heading": "2 Working with a complete basis",
            "text": "We describe some details of working over our basis. We need in particular to know how to interpret the \"construction\" of circuits in BQP if the basis is so large, as the standard definitions generally assume that circuits in BQP have descriptions which are generated by a Turing machine which operates over a finite alphabet of symbols. This section is a summary of material developed in another paper, which is to be submitted."
        },
        {
            "heading": "2.1 U-strings defined",
            "text": "To specify an element of our uncountable basis, I use the notion of a U-string. These are constructed by starting with the set A, which I define to be the union of the familiar alphanumeric alphabet of classical computation with the set of all possible 1 and 2 qubit gates. We consider each element of A to be a character, and then define a U-string to be any finite tuple over A. This will allow us to generate reasonable-sized descriptions of arbitrary circuits over our basis."
        },
        {
            "heading": "2.2 The canonical encoding of a circuit",
            "text": "For what follows, we would like a standard way of encoding a circuit as a U-string. For convenience, I will always assume that circuits come endowed with an ordering of their qubits; consequently, a reordering of the qubits in a circuit will generally produce a circuit considered to be distinct from the original circuit.\nTo produce our encoding, we can start by dividing the circuit into \"layers,\" or groups of gates which may act simultaneously, in the sense that all gates in a layer (1) act after all preceding layers, (2) act before all following layers, and (3) all the gates in the layer commute with one another and share no arguments pairwise except for perhaps a qubit which is used only as a control qubit, by gates in that layer. For any gate in our basis, it is also in our alphabet A and we can refer to it by the corresponding character g P A. It acts on at most two qubits, of indices i and j, where i is the index of the first argument g takes, and j the index of the second. We encode this singular gate as gri, js.\nTo encode a layer of gates, we concatenate the encodings of all gates in the layer, starting with the gate having the smallest index argument. If two gates both have the same smallest index argument, then this shared qubit must be used as a control by both, or else the two gates cannot be in the same layer. Each then acts on one more qubit aside from the control qubit (and only one more, since the basis consists of one and two qubit gates only), and we first encode the gate whose second argument is of a smaller index in this case.\nTo encode the entire circuit, we simply concatenate the encodings of the layers, in their order of action, so that the first gate we see in the encoding, reading from left to right, will be the first gate (read: gate having the smallest index among the qubits it acts upon) of the first layer to act on the register. We concatenate to the front of this concatenation of layers, the integer number of qubits in the circuit.\nAs an example of this encoding, consider the circuit on two qubits which has a Hadamard gate H on the first qubit, and a controlled not gate c\u03c3x after that, with the first qubit acting as the control. The canonical encoding of this gate would be\n2Hr0sc\u03c3xr0, 1s,\nwith the regular convention that an enumeration of a register starts at 0. It is useful here to define our terminology for the phase gates: we define\nP p\u03b8q \u201c\n\u00ab\n1 0 0 ei\u03b8\nff\n,\nand refer to the controlled variant of this gate by cP p\u03b8q. We refer to both as phase gates."
        },
        {
            "heading": "3 The problem family AQCE\u02da",
            "text": "We define a family of decision problems, each indexed by any finite number of gates from our basis. We shall call this family of problems AQCE\u02da, for \"aliased quantum circuit evaluation.\" An example member of this family would be AQCEp\u03c3x, Hq, where \u03c3x is the quantum-NOT gate and H is the Hadamard gate. We note that this class will be distinct from the problem class AQCEpH,\u03c3xq; the order of the parameters matters! We use AQCE\u02da to refer to the family of all such problems, for all valid parameters, but do not consider AQCE\u02da as a decision problem class in its own right. We shall delay the definition of the actual decision problem until the end of this section, as we must first describe the problem instances.\nEvery problem instance in this family is made from a quantum circuit satisfying a certain promise we shall soon specify, and to each such quantum circuit, we can locate a problem in the AQCE\u02da family. We let U \u201c pu1, u2, . . . , umq be some set of basis gates, and consider the class AQCEpUq. The instances of this class will be strings s P AQCEpUq (note that these are regular alphanumeric strings, not U-strings!) satisfying two sorts of requirements, several of form and one of substance.\nThe requirements in terms of form are somewhat lengthy to describe, but not difficult to understand: we require that the first characters of s be a number n in decimal. After that, the rest of the string shall\nbe composed of a regular series of substrings. Each substring will begin with an open parenthesis, \"(\", and conclude with a close square bracket, \"]\". These characters will occur nowhere within substrings, and in fact, delineate the start and end of substrings. Each substring will be of one of the following forms, with k as an integer in the range 1 to m inclusive (with m being the number of gates in U as given above), r an integer in the range 1 to n\u00b4 1 inclusive, and i, j integers in the range 0 to n\u00b4 1 inclusive:\n1. pkqrjs;\n2. pkqri, js;\n3. p\u02darqrjs; and\n4. pc \u02da rqri, js.\nWe shall refer to a substring as of the type 1, 2, 3, or 4, referring to the numbered entries above. A given instance string s may have any number of these substrings within it.\nWe may interpret any string s P AQCEpUq \u201c AQCEpu1, u2, . . . , umq as describing a quantum circuit. This is done by using the definition of the class as a dictionary to replace the substrings pkq by gate characters from the U-string alphabet, in the following way:\n(a) Whenever we see a substring of type 1 or 2, replace the characters \"pkq\" by the U-string character uk. Well-formed instances will always be such that whenever the substring is of type 1, the gate uk is a one-qubit gate, and whenever it is of type 2, the gate is a two-qubit gate.\n(b) Whenever we see a substring of type 3, replace the symbol p\u02darq by the gate P p\u03c0{2rq.\n(c) Whenever we see a substring of type 4, similarly, we replace the symbol pc \u02da rq by the gate cP p\u03c0{2rq.\nObserve that this will give exactly a canonical encoding of a circuit, assuming the input string was of the form described above. We shall call this process (of determining a quantum circuit from a string s P AQCEpUq) de-aliasing. We observe that it depends critically on the problem class to which it belongs; this will become relevant later.\nThe requirement of substance on the string s is really a requirement on the circuit it encodes, when we de-alias it using the parent class AQCEpUq: call this circuit CU,s. We can initialize every qubit in the input register of CU,s to the state |0y; assuming we do so, we may ask what the probability is of measuring |1y from the first qubit of the output register. Call this probability p. Our requirement of substance is that either p \u011b 2{3 or p \u010f 1{3.\nAny string which satisfies these two requirements for some class AQCEpUq (which is to say, it satisfies the structure requirements and decodes into the proper sort of circuit when using the list of gates U which come with the class AQCEpUq) is then a member of AQCEpUq.\nSo, we have that s P AQCEpUq corresponds to a unique circuit. The question germane to AQCEpUq is then this: when the circuit described by s is run with its register initialized to the all-zero tensor state, is the probability that a measurement of the first qubit of the output will be |1y greater than 2/3, or is it less than 1/3? Recall that we are promised one of these will hold.\nOf course, these instance strings are reasonable descriptions of quantum circuits, by any metric I can imagine. These strings are all perfectly exact: to each s P AQCEpUq corresponds a unique quantum circuit, which can be deduced in a very straightforward way. I struggle to think of a definition of a \"description of a quantum circuit\" which can exclude ACQE\u02da instances while still allowing anything a regular Turing machine may be able to produce for finite precision, for the output of a Turing machine, over some finite alphabet, is merely a set of characters, and if we are to agree that the string cX means \"controlled-NOT\" even though \"cX\" is clearly a pair of Latin characters and not a unitary having a certain matrix representation, or a piece of hardware, then I see no reason why we cannot agree in context that p5q refers to the quantum gate P p\u03c02q. The string p5q is as much an actual quantum gate as the string cX is.\nI will then consider the string s P AQCEpUq for some U to constitute a valid description of a quantum circuit, and so the problems AQCE\u02da are contained in BQP . Their membership in the classical hierarchy is to be determined."
        },
        {
            "heading": "3.1 Two example AQCE\u02da instances",
            "text": "For clarity, I would like to show two AQCE\u02da instances, and the canonical encodings they represent. We consider the string s \u201c 2p1qr0sp2qr0, 1s, which is not an AQCE\u02da instance on its own; to be considered an instance, we must know the specific class to which it belongs. It becomes an instance when endowed with class membership, such as, say, s P AQCEpH, c\u03c3xq, where H is the Hadamard gate, and c\u03c3x is the controlled NOT gate. We need the parameters of the class to de-alias the instance, and we can determine this s considered as a member of AQCEpH, c\u03c3xq represents the circuit 2Hr0sc\u03c3xr0, 1s, as the reader can verify by using the de-aliasing procedure given above.\nThe parameters of the class to which our string belongs determines the instance circuit entirely, as can be seen with the distinct decision problem given by s P AQCEpH, cHq, where cH is the controlled Hadamard gate; this problem has an instance circuit 2Hr0scHr0, 1s. I wish to stress that this shows the string s does not in general determine a unique circuit, and this same string will, depending on the AQCE\u02da class to which it is considered as a member of, refer to a multiplicity of different circuits."
        },
        {
            "heading": "4 The proof of noncontainment",
            "text": "We at last are in a position to prove the main result. Theorem. BQP \u0106 NP .\nProof. Suppose for contradiction that BQP \u0102 NP . Then, since every AQCE\u02da problem is contained in BQP , they will also also lie in NP . This means that for every member class AQCEpUq of the family AQCE\u02da, there will exist a nondeterministic Turing machine MU which decides every x P AQCEpUq.\nWe then let H \u201c t1{2j : j P Z`u, and pick x, y P p0, 2\u03c0qzH such that x \u2030 y. Since these two reals are distinct, their binary expansions must differ at some finite index, and for concreteness, we say they first differ at the k-th bit of their expansions.\nThese two reals define distinct phase gates P pxq and P pyq, and these phase gates both share the eigenstate |1y, though they each associate a different eigenvalue to it \u2013 we have P pxq|1y \u201c eix|1y and P pyq|1y \u201c eiy|1y. Now, we would like to build phase estimation circuits to estimate the phase of each of these |1y eigenvalues, to which we will then append a few auxiliary gates; call the circuit we wish to construct for P pxq by Cx, and the circuit for P pyq by Cy. We note here that the preparation of the eigenvalue of the phase gates is trivial \u2013 assuming every qubit of the register starts in the state |0y, we need only place a single NOT gate on the qubit which we wish to put in the eigenstate. In this way, we can absorb the preparation of the eigenstate into the circuit.\nAs noted in the appendices, we can enlarge a phase estimation circuit by an extra, finite number of qubits to increase the probability of receiving an accurate measurement to any finite level we desire[3]. In particular, we need only append some finite number r of qubits to one of the phase estimation circuits to obtain an accurate estimate of the first k bits of the phase with probability at least 2/3, say, 0.8. We will then choose the register size of both circuits to be the same number, such that both circuits will have probability at least 0.8 of measuring an accurate estimate of the first k bits of the phases.\nThe phases being estimated are in fact the reals x and y, and since these values first differ at the k-th bit, then the stipulation on measurement probabilities implies that, without loss of generality, the k-th qubit of the output in the circuit for P pxq will be measured to be in the state |0y with probability at least 0.8, while the same qubit of the output in the circuit for P pyq will be measured to be in the state |1y with probability at least 0.8.\nTo conclude these two circuits, we append at the end a qubit swap operation, between the k-th qubit and the first qubit in the register. This can be accomplished by a trio of controlled-NOT gates, which we shall refer to as cX gates, to distinguish them from regular NOT (X) gates. This means that the first qubit in the register of the output of Cx will, with probability at least 0.8, be measured to be in the state |0y, while the same qubit for Cy will be measured to be in the state |1y with probability at least 0.8. These probabilities will be of importance shortly.\nNow, we consider encoding these two circuits as problem instances in the family AQCE\u02da. We observe that, aside from W gates, each circuit is comprised of just four gates: the Hadamard gate H , the NOT gate X (used to realize the eigenstate |1y), the corresponding controlled phase gate cP pxq or cP pyq (depending on the circuit in question), and the controlled-NOT gate cX (for the qubit swap). In addition, we may consider the canonical U-string encodings of both circuits; call the encodings for Cx and Cy by ux and uy, respectively. These encodings will be the same length, and in fact, they will not match at their j-th characters if and only if the character is a controlled phase gate, a fact which follows from the procedure to create the phase estimation circuit, since we fixed both circuits to estimate the phase to the same precision (which is to say, we fixed them both to have the same register size) and since both gates of interest share the same eigenstate of interest; the procedure is agnostic to the action of any particular gate, only requiring that we have access to the controlled variant of the gate, and that the eigenstate of interest is somehow prepared in the lower register. Of course, for our procedure, we can easily prepare the eigenstate of interest \u2013 it is just |1y, for both circuits, which is easily prepared.\nThe similarity of these encodings means that there is a string s such that when considered as a problem instance s P AQCEpH,X, cP pxq, cXq, the circuit in instance s is the circuit Cx, and while considered as an instance s P AQCEpH,X, cP pyq, cXq, the circuit in the instance is Cy . This because the circuit we construct from such an instance is decided both by the form of the instance string, and the dictionary of gates which defines the problem class. The string is the same for both problems, and the dictionaries only differ in the third gate, which is also the only point at which the circuits Cx and Cy differ. Thus, de-aliasing the instances will give these two circuits, from the same string, using different dictionaries.\nSince we assume BQP \u0102 NP , there exists a nondeterministic Turing machine Mx which decides every instance of AQCEpH,X, cP pxq, cXq, meaning that when fed an instance p P AQCEpH,X, cP pxq, cXq, Mp will accept p if, after being run on a register initialized to the all-|0y tensor state, a measurement of the first qubit of the output of the circuit represented by p will return |1y with probability at least 2/3, and reject it if the probability is less than 1/3. Similarly, there exists an analogous nondeterministic Turing machine My for AQCEpH,X, cP pyq, cXq with identical acceptance criteria.\nI claim that the machines Mx and My must be distinct. To see this, we note that Mx must reject s P AQCEpH,X, cP pxq, cXq, as the circuit this instance corresponds to (Cx) has an output whose first qubit will not be measured in the state |1y with probability at least 0.8. However, My must accept s P AQCEpH,X, cP pyq, cXq, as the circuit this instance corresponds to (Cy) will have an output whose first qubit will be measured to be in the state |1y with probability at least 0.8. Of course, the instance string itself s is the same in both cases, and a single Turing machine (even if nondeterministic!) cannot both reject and accept the same string, so the two Turing machines must be distinct.\nThe values x, y P p0, 2\u03c0qzH were arbitrary, so that for any distinct a, b P p0, 2\u03c0qzH , the nondeterministic Turing machinesMa andMb deciding the problem classesAQCEpH,X, cP paq, cXq andAQCEpH,X, cP pbq, cXq must be distinct. However, since H is countable, the set p0, 2\u03c0qzH is uncountable, and we thus require an uncountable number of nondeterministic Turing machines to decide the classes AQCEpH,X, cP paq, cXq for each a P p0, 2\u03c0qzH \u2013 but this is impossible, as the set of all nondeterministic Turing machines is countable! Thus, we have a contradiction, and our original assumption that BQP \u0102 NP must fail to hold."
        },
        {
            "heading": "5 Acknowledgement",
            "text": "I would like to thank Kenneth Roche for his help in preparing this manuscript.\nAppendices\nCollected here are bit of information that may be useful to the reader, but which has no easy place ot be inserted into the body of the main article.\nAppendix A: BQP defined\nThere are multiple definitions of BQP floating around. Here are a representative pair as concerns regular quantum computation over a finite basis:\n1. (Listing gates via Turing machine[4].) A boolean function f : t0, 1u\u02da \u00d1 t0, 1u is in BQP if there is some polynomial p such that for every x P t0, 1un, there exists a quantum circuit Cfpxq such that:\n(a) Cfpxq has no more than n ` ppnq qubits in its register;\n(b) There are no more than ppnq elementary gates in Cfpxq, and there exists some polynomial-time Turing machine that when fed 1n, outputs the elementary gates to be applied.\n(c) A measurement of the first qubit of Cfpxq will be equal to fpxq with probability at least 2/3.\n2. (Families of descriptions of quantum circuits[5].) A boolean function f is in BQP if there is a classical algorithm computing a function of the form x \u00de\u00d1 Zpxq in polynomial time, where Zpxq is a description of a quantum circuit which computes fpxq on empty input.\nBoth of these definitions require that we obtain a descriptive listing of gates from some Turing machine in polynomial time. However, as Turing machines by definition only have access to a finite alphabet, they cannot describe an arbitrary element of the uncountable basis we are using, and thus it appears that we are vastly restricting the power of quantum computation by using this Turing machine-based conception of BQP . This tension is at least bandaged, if not resolved, in the AQCE\u02da problem classes, which allow the exact description of arbitrary circuits using the alphabet of classical computation."
        },
        {
            "heading": "Appendix B: The quantum phase estimation routine",
            "text": "We gather here a few facts about the quantum phase estimation routine which are relevant in the main text; most of the general information can be found in [6]. The routine involves two registers, which I shall call the \"main\" register and \"phase\" register; the main register will be initialized to the state |0ybn, where n is determined by the desired accuracy of the estimation to be obtained, while the phase register will be prepared in a state determined by the gate which we want to estimate.\nIn general, for some gate U and a eigenstate |\u03c8y of U prepared in the phase register, we will have U |\u03c8y \u201c ei\u03b8|\u03c8y for \u03b8 P r0, 2\u03c0s. The quantum phase routine, in its conventional form, allows us to construct an estimate for \u03b8, given some number of copies of a controlled version of some gate realizing U , which we call cU .\nThe circuit can be constructed, aside from the prepared state |\u03c8y and the copies of cU , using only two sorts of gates:\n1. Hadamard gates, and\n2. The set of gates cW pkq for k ranging from 1 to n \u00b4 1, where n is the number of qubits in the main register.\nTogether with the controlled gates cU , this comprises all that is needed to run the circuit. Once the circuit is constructed and run, some subset of the main register is measured. The estimate for the phase is obtained by interpreting the value measured as being the value 2k\u03b8, where k is the number of qubits we are measuring.\nThere are two pertinent facts about the phase estimation routine I wish to draw attention to: first, if we wish our measurement of the main register to give an accurate estimate in the first k qubits with probability at least 1 \u00b4 \u01eb for any \u01eb \u0105 0, then this can be done by adding a finite, \u01eb-dependent number of qubits to the main register [3]. Second, the phase estimation circuit on n qubits will have a main register which is practically independent of the controlled unitary cU that we wish to estimate the phase of: if two unitaries U and V have the same eigenstate, then creating a phase estimation circuit with n qubits (in the main register) for the unitary U , and then replacing every gate cU by the gate cV , with the same control and acted upon qubits, will exactly turn the circuit into a phase estimation circuit on n qubits (in the main register) for V ."
        },
        {
            "heading": "Appendix C: From circuits to AQCE\u02da",
            "text": "Let g be a mapping which takes as a domain all quantum circuits C which are such that, when run on a register initialized to the state |0ybnthe probability of measuring the first qubit of the output to be in the state |1y is either greater than 2/3 or less than 1/3. Fed such an input, the function g outputs a pair ps, AQCEpUqq, where s is just some regular classical string over the finite alphabet of classical computing, and AQCEpUq is a member of the family AQCE\u02da for some list of gates U . This output tells us that the string s is to be understood as an instance of the problem class AQCEpUq.\nFor any circuit C on n qubits, the action of g proceeds in steps. First, it will canonically encode C as a U-string. Then, we consider the set of all basis gates that occur in C; this set is necessarily finite, and the canonical encoding of C gives these gates a natural enumeration. Of these gates, we consider all gates which are not of the form\ncP\n\u02c6\n\u03c0\n2k\n\u02d9\n\u201c\n\u00bb\n\u2014 \u2014 \u2014 \u2013\n1 0 0 0\n0 1 0 0\n0 0 1 0 0 0 0 e i \u03c0 2k\nfi\nffi ffi ffi fl\nor\nP\n\u02c6\n\u03c0\n2k\n\u02d9\n\u201c\n\u00ab\n1 0 0 e i \u03c0 2k\nff\nfor integer k P r1, n \u00b4 1s; gates of these two forms will be referred to, in shorthand, as W gates. They carry an integer index which refers to the power of 2 in the denominator of the phase index; as an example, the former of the two preceding gates will be referred to as cW pkq while the latter will be just W pkq. The remaining, non-W gates in C can then be enumerated, since the circuit is finite: let h1 be the first unique basis gate that appears in the encoding of C which is not of the above form, and then let h2 be the second, and so on, until we have a set thju of all such basis gates appearing in C. Our g will then perform an \"aliasing\" step, where it replaces every character from the gate set B with a character from the alphabet of classical computation, before outputting the resultant, aliased, fully classical string into the class AQCEph1, h2, . . .q \u201c AQCEpthjuq; the second element of our output pair will be the class AQCEpthjuq.\nThe aliasing step is a simple replacement routine. Consider a gate character u in the encoding of C. Either u is a W gate or not. If it is not a W gate, then u is among the enumerated gates described above, and we may suppose it to be gate hi. Then, g will replace u by the symbols piq, where i will be given in, say, decimal, using the characters of classical computation.\nIf instead u is a W gate, then it is either of the form cW pkq or it is of the form W pkq. If it is of the form cW pkq, then g will replace u by the characters pc \u02da kq, where c is just the regular alphabet character c (or, equivalently, some sensible encoding thereof), \u02da is the star character, and k is represented in decimal. If instead u is of the form W pkq, we encode more simply as p\u02dakq.\nThus, for all gates in the uncountable set B, g will replace them by a finite number of characters from the alphabet of classical computing. The resultant, fully classical string is then, as mentioned above, mapped into AQCEpthjuq as a realized instance. Every problem in any of the AQCE\n\u02da can easily be seen to be obtainable in this way as the image under g of some quantum circuit."
        }
    ],
    "year": 2022
}