{
    "abstractText": "Although RNA secondary structure prediction is a textbook application of dynamic programming (DP) and routine task in RNA structure analysis, it remains challenging whenever pseudoknots come into play. Since the prediction of pseudoknotted structures by minimizing (realistically modelled) energy is NP-hard, specialized algorithms have been proposed for restricted conformation classes that capture the most frequently observed configurations. To achieve good performance, these methods rely on specific and carefully hand-crafted DP schemes. In contrast, we generalize and fully automatize the design of DP pseudoknot prediction algorithms. For this purpose, we formalize the problem of designing DP algorithms for an (infinite) class of conformations, modeled by (a finite number of ) fatgraphs, and automatically build DP schemes minimizing their algorithmic complexity. We propose an algorithm for the problem, based on the tree-decomposition of a well-chosen representative structure, which we simplify and reinterpret as a DP scheme. The algorithm is fixed-parameter tractable for the treewidth tw of the fatgraph, and its output represents a O(n) algorithm (and even possibly O(n) in simple energy models) for predicting the MFE folding of an RNA of length n. We demonstrate, for the most common pseudoknot classes, that our automatically generated algorithms achieve the same complexities as reported in the literature for hand-crafted schemes. Our framework supports general energy models, partition function computations, recursive substructures and partial folding, and could pave the way for algebraic dynamic programming beyond the context-free case.",
    "authors": [
        {
            "affiliations": [],
            "name": "Bertrand Marchand"
        },
        {
            "affiliations": [],
            "name": "Sebastian Will"
        },
        {
            "affiliations": [],
            "name": "Sarah J. Berkemer"
        },
        {
            "affiliations": [],
            "name": "Yann Ponty"
        },
        {
            "affiliations": [],
            "name": "Laurent Bulteau"
        }
    ],
    "id": "SP:25b927f6c9571826e71cf2ad46d3d6ac67d1e30e",
    "references": [
        {
            "authors": [
                "M. Zuker"
            ],
            "title": "Mfold web server for nucleic acid folding and hybridization prediction",
            "venue": "Nucleic Acids Res",
            "year": 2003
        },
        {
            "authors": [
                "Reuter JS",
                "Mathews DH"
            ],
            "title": "RNAstructure: software for rna secondary structure prediction and analysis",
            "venue": "BMC Bioinform",
            "year": 2010
        },
        {
            "authors": [
                "CB Do",
                "DA Woods",
                "S. Batzoglou"
            ],
            "title": "CONTRAfold: RNA secondary structure prediction without physics-based models",
            "year": 2006
        },
        {
            "authors": [
                "S Zakov",
                "Y Goldberg",
                "M Elhadad",
                "M. Ziv-Ukelson"
            ],
            "title": "Rich parameterization improves RNA structure prediction",
            "venue": "J Comput Biol",
            "year": 2011
        },
        {
            "authors": [
                "K Sato",
                "M Akiyama",
                "Y. Sakakibara"
            ],
            "title": "RNA secondary structure prediction using deep learning with thermodynamic integration",
            "venue": "Nature Commun",
            "year": 2021
        },
        {
            "authors": [
                "E Ten Dam",
                "K Pleij",
                "D. Draper"
            ],
            "title": "Structural and functional aspects of RNA pseudoknots. Biochemistry",
            "year": 1992
        },
        {
            "authors": [
                "T. Akutsu"
            ],
            "title": "Dynamic programming algorithms for RNA secondary structure prediction with pseudoknots",
            "venue": "Discrete Appl Mathemat",
            "year": 2000
        },
        {
            "authors": [
                "Cao S",
                "Chen S-J"
            ],
            "title": "Predicting RNA pseudoknot folding thermodynamics",
            "venue": "Nucleic Acids Res",
            "year": 2006
        },
        {
            "authors": [
                "Rivas E",
                "Eddy SR"
            ],
            "title": "A dynamic programming algorithm for RNA structure prediction including pseudoknots",
            "venue": "J Mol Biol",
            "year": 1999
        },
        {
            "authors": [
                "Dirks RM",
                "Pierce NA"
            ],
            "title": "A partition function algorithm for nucleic acid secondary structure including pseudoknots",
            "venue": "J Comput Chem",
            "year": 2003
        },
        {
            "authors": [
                "CM Reidys",
                "FW Huang",
                "JE Andersen",
                "RC Penner",
                "PF Stadler",
                "ME. Nebel"
            ],
            "title": "Topology and prediction of RNA",
            "venue": "pseudoknots. Bioinformatics",
            "year": 2011
        },
        {
            "authors": [
                "H Jabbari",
                "I Wark",
                "C Montemagno",
                "S. Will"
            ],
            "title": "Knotty: efficient and accurate prediction of complex RNA pseudoknot structures",
            "year": 2018
        },
        {
            "authors": [
                "J Ren",
                "B Rastegari",
                "A Condon",
                "HH. Hoos"
            ],
            "title": "HotKnots: heuristic prediction of RNA secondary structures including pseudoknots",
            "year": 2005
        },
        {
            "authors": [
                "K Sato",
                "Y Kato",
                "M Hamada",
                "T Akutsu",
                "K. Asai"
            ],
            "title": "IPknot: fast and accurate prediction of RNA secondary structures with pseudoknots using integer programming",
            "year": 2011
        },
        {
            "authors": [
                "H Jabbari",
                "A. Condon"
            ],
            "title": "A fast and robust iterative algorithm for prediction of RNA pseudoknotted secondary structures",
            "venue": "BMC Bioinform",
            "year": 2014
        },
        {
            "authors": [
                "Reidys CM",
                "Wang RR"
            ],
            "title": "Shapes of RNA pseudoknot structures",
            "venue": "J Comput Biol",
            "year": 2010
        },
        {
            "authors": [
                "M M\u00f6hl",
                "S Will",
                "R. Backofen"
            ],
            "title": "Lifting prediction to alignment of RNA pseudoknots",
            "venue": "J Comput Biol",
            "year": 2010
        },
        {
            "authors": [
                "C Alkan",
                "E Karako\u00e7",
                "JH Nadeau",
                "SC Sahinalp",
                "K. Zhang"
            ],
            "title": "RNA-RNA interaction prediction and antisense RNA target search",
            "venue": "J Comput Biol",
            "year": 2006
        },
        {
            "authors": [
                "ME Fornace",
                "NJ Porubsky",
                "NA. Pierce"
            ],
            "title": "A unified dynamic programming framework for the analysis of interacting nucleic acid strands: enhanced models, scalability, and speed",
            "venue": "ACS Synt Biol",
            "year": 2020
        },
        {
            "authors": [
                "Bodlaender HL",
                "Koster AM"
            ],
            "title": "Combinatorial optimization on graphs of bounded treewidth",
            "venue": "Comp J. 2008;51(3):255\u201369",
            "year": 2008
        },
        {
            "authors": [
                "P Rinaudo",
                "Y Ponty",
                "D Barth",
                "Denise"
            ],
            "title": "A Tree decomposition and parameterized algorithms for RNA structure-sequence alignment including tertiary interactions and pseudoknots",
            "venue": "In: International Workshop on Algorithms in Bioinformatics,",
            "year": 2012
        },
        {
            "authors": [
                "Bodlaender HL"
            ],
            "title": "A linear-time algorithm for finding tree-decompositions of small treewidth",
            "venue": "SIAM J Comput",
            "year": 1996
        },
        {
            "authors": [
                "F Huang",
                "C Reidys",
                "R. Rezazadegan"
            ],
            "title": "Fatgraph models of RNA structure",
            "venue": "Comput Mathemat Biophy",
            "year": 2017
        },
        {
            "authors": [
                "M Loebl",
                "I. Moffatt"
            ],
            "title": "The chromatic polynomial of fatgraphs and its categorification",
            "venue": "Adv Mathemat",
            "year": 2008
        },
        {
            "authors": [
                "RC Penner",
                "M Knudsen",
                "C Wiuf",
                "JE. Andersen"
            ],
            "title": "Fatgraph models of proteins",
            "venue": "Commun Pure Appl Mathemat",
            "year": 2010
        },
        {
            "authors": [
                "R Giegerich",
                "B Vo\u00df",
                "M. Rehmsmeier"
            ],
            "title": "Abstract shapes of rna",
            "venue": "Nucleic Acids Res",
            "year": 2004
        },
        {
            "authors": [
                "S Arnborg",
                "DG Corneil",
                "A. Proskurowski"
            ],
            "title": "Complexity of finding embeddings in ak-tree",
            "venue": "SIAM J Algeb Discrete Meth",
            "year": 1987
        },
        {
            "authors": [
                "Bodlaender HL",
                "Koster AM"
            ],
            "title": "Treewidth computations i. upper bounds",
            "venue": "Inform Comput",
            "year": 2010
        },
        {
            "authors": [
                "H. Tamaki"
            ],
            "title": "Positive-instance driven dynamic programming for treewidth",
            "venue": "J Comb Optim",
            "year": 2019
        },
        {
            "authors": [
                "V Gogate",
                "R. Dechter"
            ],
            "title": "A complete anytime algorithm for treewidth",
            "venue": "arXiv. 2012. https:// doi. org/ 10",
            "year": 2012
        },
        {
            "authors": [
                "H-T Yao",
                "J Waldisp\u00fchl",
                "Y Ponty",
                "S. Will"
            ],
            "title": "Taming Disruptive Base Pairs to Reconcile Positive and Negative Structural Design of RNA",
            "venue": "RECOMB 2021-25th International Conference on Research in Computational Molecular Biology",
            "year": 2021
        },
        {
            "authors": [
                "C Scornavacca",
                "M. Weller"
            ],
            "title": "Treewidth-based algorithms for the small parsimony problem on networks",
            "venue": "Algorit Mole Biol",
            "year": 2021
        },
        {
            "authors": [
                "L. Lov\u00e1sz"
            ],
            "title": "Graph minor theory",
            "venue": "Bull Am Mathemat Soc",
            "year": 2006
        },
        {
            "authors": [
                "Bodlaender HL",
                "Koster AM"
            ],
            "title": "Safe separators for treewidth",
            "venue": "Discrete Mathemat",
            "year": 2006
        },
        {
            "authors": [
                "V Bouchitt\u00e9",
                "I. Todinca"
            ],
            "title": "Treewidth and minimum fill-in: grouping the minimal separators",
            "venue": "SIAM J Comput",
            "year": 2001
        },
        {
            "authors": [
                "Nussinov R",
                "Jacobson AB"
            ],
            "title": "Fast algorithm for predicting the secondary structure of single-stranded rna",
            "venue": "Proc Nat Acad Sci",
            "year": 1980
        },
        {
            "authors": [
                "RB Lyngs\u00f8",
                "M Zuker",
                "CN. Pedersen"
            ],
            "title": "Fast evaluation of internal loops in RNA secondary structure prediction. Bioinformatics. 1999;15(6):440\u20135",
            "venue": "https:// doi. org/",
            "year": 1999
        },
        {
            "authors": [
                "McCaskill JS"
            ],
            "title": "The equilibrium partition function and base pair binding probabilities for rna secondary structure. Biopolymers",
            "venue": "https:// doi",
            "year": 1990
        },
        {
            "authors": [
                "Ding Y",
                "Lawrence CE"
            ],
            "title": "A statistical sampling algorithm for RNA secondary structure prediction",
            "venue": "Nucleic Acids Res",
            "year": 2003
        },
        {
            "authors": [
                "Y Ponty",
                "C. Saule"
            ],
            "title": "A combinatorial framework for designing (pseudoknotted) RNA algorithms",
            "year": 2011
        },
        {
            "authors": [
                "F M\u00f6lder",
                "KP Jablonski",
                "B Letcher",
                "MB Hall",
                "CH Tomkins-Tinch",
                "V Sochat",
                "J Forster",
                "S Lee",
                "SO Twardziok",
                "A Kanitz"
            ],
            "title": "Sustainable data analysis with snakemake. F1000Research",
            "venue": "https:// doi. org/",
            "year": 2021
        },
        {
            "authors": [
                "Riechert M",
                "Stadler PF"
            ],
            "title": "Algebraic dynamic programming for multiple context-free grammars",
            "venue": "Theoret Comp Sci. 2016;639:91\u2013109. https:// doi. org/ 10",
            "year": 2016
        },
        {
            "authors": [
                "H-L Chen",
                "A Condon",
                "H. Jabbari"
            ],
            "title": "An O (n5) algorithm for MFE prediction of kissing hairpins and 4-chains in nucleic acids",
            "venue": "J Comput Biol",
            "year": 2009
        },
        {
            "authors": [
                "M Quadrini",
                "L Tesei",
                "E. Merelli"
            ],
            "title": "An algebraic language for RNA pseudoknots comparison",
            "venue": "BMC Bioinform",
            "year": 2019
        },
        {
            "authors": [
                "SJ Berkemer",
                "C Siederdissen",
                "PF. Stadler"
            ],
            "title": "Algebraic dynamic programming on trees",
            "year": 2017
        },
        {
            "authors": [
                "RM Dirks",
                "JS Bois",
                "JM Schaeffer",
                "E Winfree",
                "NA. Pierce"
            ],
            "title": "Thermodynamic analysis of interacting nucleic acid strands",
            "venue": "SIAM Rev",
            "year": 2007
        }
    ],
    "sections": [
        {
            "text": "\u00a9 The Author(s) 2023. Open Access This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article\u2019s Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article\u2019s Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit http:// creat iveco mmons. org/ licen ses/ by/4. 0/. The Creative Commons Public Domain Dedication waiver http:// creat iveco mmons. org/ publi cdoma in/ zero/1. 0/ applies to the data made available in this article, unless otherwise stated in a credit line to the data.\nKeywords Pseudoknots, RNA folding, Tree Decomposition, Treewidth"
        },
        {
            "heading": "Introduction",
            "text": "The function of non-coding RNAs is, to a large extent, determined by their structure. Structure prediction algorithms therefore play a crucial role in biomedical and pharmaceutical applications. The basis to determine more complex 3D structures of RNA molecules is set by first accurately predicting their 2D or secondary structures. There exist various RNA folding algorithms that predict an optimal secondary structure as minimum free energy structure of the given RNA sequence in suitable thermodynamic models. In the most frequently used methods, this optimization is performed efficiently by a dynamic programming (DP) algorithm, e.g.\u00a0mfold [1], RNAfold [2], RNAstructure [3]. A recent alternative to predictions based on experimentally determined energy parameters are machine learning approaches that train models on known secondary structures, e.g., CONTRAfold [4], ContextFold [5], MXfold2 [6].\nHowever, the most frequently used algorithms (including all of the above ones) optimize solely over pseudoknot-free structures [7], which do not contain crossing base pairs. Although pseudoknots (PK) appear in many RNA secondary structures, they have been omitted by initial prediction algorithms due to their computational complexity [8], and the difficulty to score individual *Correspondence: Yann Ponty yann.ponty@lix.polytechnique.fr 1 LIX (UMR 7161), Ecole Polytechnique, Institut Polytechnique de Paris, Palaiseau, France 2 LIGM, CNRS, University Gustave Eiffel, F77454 Marne-la-Vall\u00e9e, France 3 Earth-Life Science Institute, Tokyo Institute of Technology 2\u201312-1-I7E318, Ookayama, Tokyo 152\u20138550, Japan\nconformations [9]. Nevertheless, many algorithms have been proposed to predict at least certain pseudoknots. These methods are either based on exact DP algorithms such as pknots-RE [10], NUPACK [11], gfold [12], Knotty [13] or they use heuristics that don\u2019t guarantee exact solutions, e.g., HotKnots [14], IPknot [6, 15], Hfold [16].\nOwing to the hardness of PK prediction, efficient exact DP algorithms are necessarily restricted to certain categories of pseudoknotted structures. The underlying DP schemes are designed manually, guided by design to either i) support structures that are frequently observed in experimentally resolved structures (declarative categories); or ii) support the largest possible set of conformations, while remaining within a certain complexity (complexity-driven). For most categories, essentially declarative ones, there exists one or several helix arrangements, either observed in experimentallydetermined structures or implicitly characterized by graph-theoretical properties (3-non-crossing [17], topologically bounded [12]) that need to be captured. A detailed overview of pseudoknot categories is given in [18]. Similar situations occur for RNA-RNA interactions [19], possibly including several RNA molecules. Interestingly, when more than two RNA strands are considered, existing algorithms restrict the joint conformation to crossing-free interactions [20], further motivating an, ideally-automated, design of algorithms beyond the case of pseudoknot-free secondary structures.\nThe paradigm of tree decompositions (TD) represents an appealing candidate for automating such a design task. TDs organize the vertices of a graph into a tree-like structure that represents all vertices and edges, augmented with a notion of consistency. A TD can then be re-interpreted as DP schemes for a wealth of graphs problems involving local constraints (coloring, independent sets, covers...) [21] and complex pattern matching problems in Bioinformatics [22]. The complexities of such exact algorithms are typically exponential on a parameter called the treewidth, which can be minimized to obtain an optimal TD in time only exponential on the min treewidth itself [23]. However, TD-based approaches typically start from a single input graph, whereas folding prediction requires DP schemes that generalize to collections of structures of unbounded cardinalities. This led us to the following question, at the foundation of this work:\nCan tree decompositions be used to infer structure prediction algorithms that work for entire classes of conformations?\nIn this work, we answer positively to that question. We consider popular classes of pseudoknotted structures, described as fatgraphs [12, 24\u201326], an abstraction of\nRNA conformations related to RNA shapes [27] or shadows [12, 17]. We formalize the principles underlying the design of DP folding algorithms including pseudoknots and, at the same time, give a formulation of the computational problem corresponding to the design of DP algorithms. We show how to leverage tree-decompositions, computed on a minimal expansion of the input fatgraph, to automatically derive DP schemes that use as little indices as possible. Our methodology leads to a generalization of algorithms underlying LiCoRNA [22] and gfold [12] and represents a parameterized algorithm based on the treewidth (tw) of the underlying fatgraph. For example, our method automatically derives optimally efficient recursions of a gfold-like prediction algorithm covering the four pseudoknot types of 1-structures (cf Table\u00a01) Moreover, it enables highly complex implementations, like a prediction algorithm for 2-structures. Notably, this was never implemented for gfold, since it requires the generation of recursions for 3472 fatgraphs\u2014virtually impossible to conduct \u201cby hand\u201d.\nIn Sect. \"Definitions and main result\", we state our problem and define its input structure abstraction, the fatgraph. Then, we describe helix expansions of the fatgraph and their tree decompositions (Sect. \"Minimal representative expansion of a fatgraph\"). By minimal helix expansions and a derivation of the tree decomposition to its canonical form, we automatically derive a DP scheme for the folding of pseudoknotted structures (Sect. \"Interpreting the tree decomposition of a fatgraph expansion as a DP algorithm\"). The following result is the main result of our papering a number of indices equal to the treewidth. Figure\u00a0 1 outlines the fundamental algorithm. Section \"Extensions\"\u00a0 discusses extensions to combine multiple fatgraphs, include recursive substructure, and cover realistic energy models. Section\u00a0 \"Automated (re-) design of algorithms for specificpseudoknot classes\" discusses the application of our methods to the design of concrete pseudoknot folding algorithms. We demonstrate the re-design of gfold for 1-structures, as well as the novel design of 2-structure prediction and interesting novel algorithms between 1- and 2-structures (e.g.\u00a0 predicting 5-chains in O(n7))."
        },
        {
            "heading": "Definitions and\u00a0main result",
            "text": "We define an RNA sequence S as a word of length n over the nucleotides A,\u00a0 C,\u00a0 G and U; moreover an RNA secondary structure (potentially, with pseudoknots) \u03c9 of S as a set of base pairs (i,\u00a0 j) between sequence positions i and j (in 1,\u00a0...,\u00a0n), such that there is at most one base pair incident to each position. A diagram is a graph of nodes 1,...,n (the positions), connecting consecutive positions by directed edges (i, i + 1) and moreover connecting positions by arcs, visualizing the arc-annotation of the\nsequence. Typically this is represented drawing the backbone linearly and the arcs on top. RNA secondary structures are naturally interpreted as diagrams.\nOne of our central concerns is the crossing configuration of arcs in a diagram. We define two arcs (i,\u00a0 j) and (i\u2032, j\u2032) in a diagram as crossing iff i < i\u2032 < j < j\u2032 or i\u2032 < i < j\u2032 < j . Naturally, this leads to the notion of a conflict graph consisting of all the arcs of a diagram and connecting crossing arcs by a conflict edge. Given a potentially conflicted set of base pairs, the associated\nRNA structure graph is the diagram consisting of one vertex per nucleotide, backbone links, and one arc per base pair.\nA\u00a0 fatgraph [12, 24\u201326] is an abstraction of a family of pseudoknotted RNA structures displaying a specific conflict structure. It is typically represented as a band diagram (see Figs.\u00a0 1 and\u00a0 2), in which each band may represent a helix of arbitrary size, including bulges. An arc-annotation is said to be an expansion of a fatgraph if collapsing nested arcs and contracting isolated bases\nyields the band diagram of a fatgraph. Given a finite number of fatgraphs, we say a structure is a recursive expansion of these fatgraphs if decomposing the structure into conflict-connected components, collapsing nested arcs and contracting isolated bases only yields members of the given fatgraph set. For the purpose of this presentation (where we do not explicitly study structure topology), we moreover identify fatgraphs with their diagrams.\nTo make the connection to gfold [12] explicit, recursive expansions of fatgraphs are equivalently understood in terms of the shadows of a structure. The shadow of an RNA structure (or equivalently, its diagram) is defined in [12] as the diagram obtained by, firstly, removing all unpaired bases and non-crossing structures and, secondly, contracting all stacks (i.e. pairs of arcs between directly consecutive positions) to single arcs. Then, the class of recursive expansions of a set of input fatgraphs \u0174 is the class of structures, where the shadows of their conflict-connected components are in \u0174.\nIn this paper, we consider a class of RNA folding problems in which the search space is restricted to recursive expansions of a user-specified finite set of fatgraphs. For the sake of simplicity, we first describe minimizing energy in a simple free-energy model E , where the energy of a sequence/structure is obtained by summing the contributions of individual base pairs; moreover, we present the method initially without recursive insertions. Only later, in Sect. \"Extensions\", we extend to the full problem in realistic energy models.\nDefinition 1 (Fatgraph MFE folding problem) Input: Collection of fatgraphs \u03b31, . . . , \u03b3p , sequence S Output: Minimum Free Energy (MFE) arc-annotation for S according to a free-energy model E , restricting the search to recursive expansions of the input fatgraphs.\nSpecifically, we solve the problem of automatic design of such pseudoknot prediction algorithms based on an input set of fatgraphs.\nDefinition 2 (Fatgraph algorithm design problem) Input: Collection of fatgraphs \u03b31, . . . , \u03b3p Output: A Dynamic-Programming algorithm that, given any sequence S, solves the Fatgraph MFE folding problem over \u03b31, . . . , \u03b3p and S.\nDefining the treewidth of a fatgraph as the treewidth of its minimal expansion (see Sect. \"Helices of length 5 are sufficient to obtain generalizable tree decompositions\"), our main result, stated in Algorithm\u00a0 1, is the existence of an effective algorithm for the Fatgraph MFE-folding problem, parameterized by the maximum treewidth tw of the input fatgraphs.\nUsing parameterized algorithmics terminology [28], it consists of an FPT (Fixed-Parameter Tractable) preprocessing of the input fatgraphs, yielding an XP (Slicewise-Polynomial) dynamic-programming algorithm accepting any input sequence and solving the Fatgraph MFE folding problem (see Fig.\u00a01). In a nutshell, an algorithm is FPT in a parameter k is its run-time is of the form O(f (k) \u00b7 nc) , for c a constant and f a computable (typically super-exponential) function. On the other hand, it is XP if its run-time is of the form f (k) \u00b7 ng(k) for two computable functions f,\u00a0 g. Both yield polynomial algorithms for a fixed value of k. More details about the parameterized complexity classes XP and FPT can be found in [28].\nInput : Finite number of fatgraphs \u03b31, . . . , \u03b3p, sequence S, base-pair based energy model E Output: Best-scoring arc-annotation for S, in the class specified by the fatgraphs\n1 foreach fatgraph \u03b3i do 2 Compute minimal expansion Gi of fatgraph \u03b3i;\n\u2212\u2192 Linear time; see Section ''Helices of length 5 are sufficient to obtain generalizable tree decompositions''\n3 Find min. width tree decomposition T for Gi; \u2212\u2192 FPT in tw using exact tree dec. algorithm 4 Transform T into a canonical form tree dec T \u2032; \u2212\u2192 Polynomial time; see Section ''Canonical form of fatgraph tree decompositions'' 5 Compute skeleton of T \u2032;\n\u2212\u2192 Linear time; see Section ''Canonical form of fatgraph tree decompositions''\n6 Derive corresponding DP scheme; \u2212\u2192 Linear time; see Section ''Automatic\nderivation of dynamic programming equations in a base pair-based energy model''\n7 end 8 Run all DP schemes to find MFE arc-annotation of S;\n\u2212\u2192 XP in tw O(ntw+1); See Section ''Extensions''\nAlgorithm\u00a0 1: Pseudocode for\u00a0 the\u00a0 recursive fatgraph folding problem.\nThe following result is the main result of our paper. A refined version is Theorem\u00a0 4 in Sect. \"Complexity analysis\".\nTheorem\u00a0 1 (Main result) Algorithm\u00a0 1 solves the fatgraph folding problem in O(ntw+1) , where tw is the maximum treewidth of the input fatgraphs.\nAs detailed with Theorem\u00a04, the complexity can also be O(ntw) in certain cases, depending on the choice of energy model and the fatgraphs under consideration.\nSince the number of indices used by the DP equation is minimized, the resulting complexities could be seen as optimal within a family of simple DP algorithms. However, a characterization of such a non-trivial family of algorithms would be beyond the scope of this work, and\nwe leave formal proofs of optimality to future work, as briefly discussed in Sect \u201cConclusions and discussion\u201d."
        },
        {
            "heading": "Minimal representative expansion of\u00a0a\u00a0fatgraph",
            "text": "Our approach builds on the concept of tree decomposition, which we want to leverage to derive decomposition strategies within dynamic programming (DP) schemes. A key challenge is in the fact that tree decompositions are computed for concrete graphs, whereas our objective is to find an algorithm whose search space includes all possible recursive expansions of an input fatgraph.\nFortunately, we find that expanding every helix of a fatgraph to length 5 (i.e. 5 nested base pairs) yields a graph which is representative of the fatgraph. Namely, its optimal tree decomposition, having treewidth tw, trivially generalizes into a tree decomposition for any further expansion, retaining treewidth tw. This tree decomposition can finally be reinterpreted into a DP scheme that exactly solves the MFE folding problem in O(ntw+1) complexity (and sometimes even O(ntw) for simple energy models)."
        },
        {
            "heading": "Treewidth and\u00a0tree decompositions",
            "text": "Definition 3 A tree decomposition T = (T , {Xi}i\u2208V (T )) of a graph G = (V ,E) is a tree of subsets of vertices of G, called bags, verifying the following conditions:\n\u2022 \u2200u \u2208 V \u2203i \u2208 V (T ) such that u \u2208 Xi . (representing vertices) \u2022 \u2200(u, v) \u2208 E \u2203i \u2208 V (T ) such that {u, v} \u2282 Xi.(representing edges) \u2022 Tu = {i \u2208 V (T ) | u \u2208 Xi} must be connected. (vertex subtree property)\nThe width of a tree decomposition is the size of its biggest bag minus one, i.e. maxi\u2208V (T ) |Xi| \u2212 1 . The treewidth of a graph G is then the minimum possible width of a tree decomposition of G. Intuitively, the lower the treewidth, the closer G is to being a tree. Treewidth is NP-hard to compute [29], but fixed-parameter tractable (FPT): there is a O(f (w) \u00b7 n) algorithm [23] deciding whether tw(G) \u2264 w given G. More details regarding the fixed-parameter tractability and theoretical aspects of treewidth can be found in [28]. Many polynomial heuristics are also known to yield reasonable results [30], and optimized exact solvers have been developed [31, 32]. Notoriously, a wide variety of hard computational problems can be solved efficiently when restricted to graphs of bounded treewidth [21, 28], including in bioinfomatics [22, 33, 34]. Such is the case of pseudoknotted structure-sequence alignment, using the algorithm presented in [22]. The method presented in this paper can actually be seen as a generalization of this algorithm, allowing to\nperform \u201cpseudoknotted motif-sequence alignment\u201d, with a motif describing a family of structures.\nWe will rely in the remainder of this section on some well known-properties for treewidth, which we recall here. First, taking any minor of G [35], i.e. performing any sequence or edge contractions, edge deletions and vertex deletions on G can only lower the treewidth. Second, degree-2 vertices can be contracted into their neighbors without changing the treewidth, as quickly stated below. This implies in particular that any bulge in a helix of an RNA structure graph is inconsequential with respect to treewidth.\nProposition 1 If u is a degree-2 vertex of G with neighbors {v,w} , and Gv\u2190u is the graph obtained by contracting u into v in G then tw(G) = tw(Gv\u2190u)\nProof To start with, Gv\u2190u is a minor of G, therefore tw(Gv\u2190u) \u2264 tw(G) . Then, given an optimal tree decomposition T for Gv\u2190u , since (v,\u00a0w) is an edge of this graph, there has to be a bag X containing both vertices. If tw(Gv\u2190u) = 1 , then X = {v,w} and can be split into two bags {v,u} and {u,w} to obtain a tree decomposition for G. If tw(Gv\u2190u) \u2265 2 , then we can simply connect a new bag {u, v,w} and connect it to X to obtain again a valid tree decomposition for G of the same width. Therefore tw(G) \u2264 tw(Gv\u2190u) and we have the equality.\nThen, we import from [36] an inequality valid for any separator of G. A separator is a subset S of vertices of G such that G \\ S is composed of at least 2 conected components. This set of connected components obtained by removing S in G is denoted CG(S) . We then have:\nProposition 2 If S is a separator of G, then\nwith G[C \u222a clique(S)] the subgraph of G induced by C \u222a S augmented by edges making S a clique. In case of equality, we say that S is safe.\nProof Consider, for each C \u2208 CG(S) , a tree decomposition TC of G[C \u222a clique(S)] . Since these graphs contain S as a clique, each TC must have a bag XC containing S entirely. Consider now the following tree decomposition for G: make a bag out of S, and connect XC for each C to it. The resulting tree decomposition is valid for G, and its width is the left-hand-side of the inequality.\nConversely, given two adjacent bags X and Y in a tree decomposition T , unless all vertices on the \u201cX-side\u201d of the tree decomposition are also present in the Y-side (or the opposite), X \u2229 Y is a separator of G. Formally, given\ntw(G) \u2264 max C\u2208CG(S) tw(G[C \u222a clique(S)])\n(X,\u00a0Y) an edge of a tree decomposition T , the X-side of T is the connected component of T containing X obtained when removing (X,\u00a0Y).\nTo write down the proofs of the following section in a smoother fashion, we restrict (w.l.o.g) tree decompositions to be such that any intersection of two adjacent bags is a minimal separator of the graph. The existence of optimal decompositions with these property is easily seen when defining tree decompositions in terms of triangulations and chordal graphs [31, 37]. In this framework, the treewidth of a graph G is the minimum possible maximum clique size in a chordal completion of G. The bags of the decomposition are the maximal cliques of the chordal completion (\u201cclique-tree\u201d), and intersections of adjacent bags are minimal separators. For completeness, we formulate this result in the following proposition:\nProposition 3 Given a graph G, there always exists an optimal tree decomposition such that, for any two adjacent bags X and Y:\n1. X \u2229 Y is a minimal separator of G. 2. |X \u2229 Y | \u2264 tw(G)\nProof Denoting \u03c9(H) the maximum clique size of a graph H, we have [37]:\nThe tree decomposition corresponding to a particular chordal completion H of G is the \u201cclique-tree\u201d of H. Bag intersections are then minimal separators of G (item 1), and no two bags contain exactly the same vertices (hence item 2). We refer the reader to [37] for full definitions and justifications.\nHelices of\u00a0length 5 are sufficient to\u00a0obtain generalizable tree decompositions Given an RNA graph (with one vertex per nucleotide and one edge per base pair and backbone link, see Fig.\u00a03a, we call perfect helix a set of directly nested base pairs, resulting in the subgraph depicted on Fig.\u00a0 3b. We call the number of nested base pairs its length, and denote it with l. With a slight abuse of language, we call such a subgraph a helix, even for general graphs.\nThroughout the remainder of the article, helices will be often proven to be replaceable, as a subgraph, by one of two small graphs on 4 vertices. These two graphs are\ntw(G) = min H chordal completion of G \u03c9(H)\nthe clique on 4 vertices and a 4-cycle augmented with one (and only one) of the possible two chords. To simplify the exposition, we simply denote them by \u22a0 and .\nOne situation where \u22a0 will appear is when we prove that, sometimes, the 4 extremities can be connected into a clique without loss of generality. The graph we obtain, an helix closed by a clique, has treewidth 4, which will be an important threshold in our structural results below. We state this fact in the following lemma. Let us denote by H\u2217l the graph corresponding to a helix of length l, with the extremities connected as a clique.\nLemma 1 For l = 2 , tw(H\u2217l ) = 3 , while for l \u2265 3 , tw(H\u2217l ) = 4.\nProof For l = 2 , H\u2217l is simply the clique on 4 vertices, and which has a width of 3. For l \u2265 3 , a clique on 5 vertices can be obtained as a minor by contracting the internal part of the helix to one vertex, which ends up being connected to all 4 extremities, which already form a clique. Therefore, tw(H\u2217l ) \u2265 4 . To obtain the equality, we recursively build a tree decomposition of width \u2264 4 , starting with l = 2 which we already described. Given a tree decomposition of width \u2264 4 for H\u2217l , there has to be a bag X containing all 4 extremities {u1, v1,ul , vl} (see Fig.\u00a03b). We introduce two new bags: X \u2032 = {u1, v1,ul , vl , vl+1} introducing a new vertex vl+1 , and X \u2032\u2032 = {u1, v1,ul , vl+1,ul+1} introducing ul+1 . We connect X \u2032 to X and X \u2032\u2032 to X \u2032 . By doing so, we respect the subtree connectivity property for all involved vertices, and build a tree decomposition capable of representing H\u2217l+1 .\nOur main structural result is to show that the treewidth of a graph G does not increase when extending a helix past a length of 5. Its proof relies on the following inequality, involving the graphs G\u22a0 and G , obtained from G by replacing a helix H with either \u22a0 or , (see Fig.\u00a03c).\nLemma 2 Given a graph G and a helix H of length l \u2265 3 in G, we have:\nProof To start with, by noticing that the 4 extremities of the helix form a separator S between the inside and the outside of it, we get by Proposition\u00a0 2 that tw(G) \u2264 max(H \u222a clique(S),G\u22a0) . The graph H \u222a clique(S) does not depend on G, and consists of a helix with the 4 extremities forming a clique. With l \u2265 2 , it turns out that this graph has treewidth 4, per Lemma\u00a01, hence the inequality.\ntw(G\u22a0)\u2212 1 \u2264 tw(G ) \u2264 tw(G) \u2264 max(4, tw(G\u22a0))\nNext, we notice that G is a minor of G when l \u2265 3 . This can be seen by contracting the helix according to the pattern outlined on Fig.\u00a0 3d by the green areas (each green area is contracted to the extremity it contains). Therefore, tw(G ) \u2264 tw(G). Finally, let us note that G\u22a0 and G only differ by 1 edge, and removing a single edge from a graph can only decrease its treewidth by at most 1. Indeed, suppose that tw(G ) < tw(G\u22a0)\u2212 1 , and consider an optimal tree decomposition T for G . Let us denote by u and v the two extremities of the helix not connected in G . If the subtrees of bags containing respectively u and v do not intersect, then one can just add v to all bags of the tree decomposition, to represent the edge (u,\u00a0v) while increasing the width by \u2264 1 . Therefore tw(G\u22a0)\u2212 1 \u2264 tw(G ) and the inequality is complete.\nThrough the introduction of G\u22a0 and G as the two possible graphs to which G is equivalent in terms of treewidth, Lemma\u00a02 already contains the essence of our main structural result, Theorem\u00a02. It will be the basis for generalizing tree decompositions of minimal expansions of a fatgraph to arbitrary helix lengths.\nTheorem\u00a0 2 If H is a helix in G of length l \u2265 5 , then extending the helix to have length l + 1 does not increase the treewidth.\nProof Let us distinguish two cases depending on the treewidth of G. For both of them, we consider an optimal tree decomposition T of G and show how to modify it into a valid tree decomposition for the extended version of G: If tw(G) \u2264 3 then there has to be a pair i,\u00a0j ( i \u2264 j ) of indices \u2208 [1, l] such that |i \u2212 j| > 1 and no bag contains both an element from{ui, vi} and {uj , vj} . I.e. the occurences of {ui, vi} and {uj , vj} in the tree decomposition are completely separated by some edge (X,\u00a0 Y) of the tree decomposition. Indeed, if \u2200i, j \u2208 [1, l] there is some edge between {ui, vi} and {uj , vj} represented, then contracting uk , vk together \u2200k would yield a clique on 5 vertices, which is forbidden if tw(G) \u2264 3.\nGiven such a pair i,\u00a0j of indices, let us denote S = X \u2229 Y the separator associated to that edge. By Proposition\u00a03, S can be assumed to be inclusion minimal, and therefore to contain exactly 2 vertices uk and vk \u2032 such that |k \u2212 k \u2032| \u2264 1\nand i \u2264 k , k \u2032 \u2264 j . Such a separator is depicted on Fig.\u00a03c, as well as on Fig.\u00a07. On this latter Figure, we also depict the re-writing we perform: we introduce two new vertices x and y to the X-side of the separator, as well as intermediary bags between Y and X that will gradually transform uk , v \u2032 k into x and y. To be specific, we introduce S as a bag between X and Y, and connect it to X through the series of bags S \u222a {x} , S \u222a {x, y} \\ {uk} , S \u222a {x, y}\\{uk , v\u2032k} in the case (w.l.o.g) that k \u2264 k \u2032 . In addition, all occurences of uk in X and beyond in the subtree rooted at X and directed away from S are replaced with x and those of v\u2032k with y. Since |S| \u2264 tw(G) , such a re-writing does not increase the treewidth, while representing all necessary edges for an extension of the helix by one level.\nIf tw(G) \u2265 4 , then we first look for a pair i,\u00a0 j verifying (as above) that some edge (X,\u00a0Y) of the tree decomposition completely separates {ui, vi} from {uj , vj} , although this time with no garantee of finding one. If we do find one, we apply the same transformation as above.\nIn the case where no such pair i,\u00a0j exists, we argue that the four extremities of the helix form a safe separator of G. i.e. tw(G) = max(4, tw(G\u22a0)) . An optimal tree decomposition for G can then be obtained from a tree decomposition G\u22a0 , and a tree decomposition of an helix closed by a clique, connected through a bag in which the separator forms a clique. The helix can then simply be extended by changing the part of the tree decomposition representing the helix.\nBy Lemma\u00a02, we have tw(G) \u2264 max(4, tw(G\u22a0)) . Since tw(G) \u2265 4 , it reduces to tw(G) \u2264 tw(G\u22a0) . We now use the fact that edges connecting {ui, vi} and {uj , vj} for all i,\u00a0j are represented in the tree decomposition to show that G\u22a0 is a minor of G, and therefore tw(G) = tw(G\u22a0)\nIf there is an edge connecting ui to vj or vi to uj for |j \u2212 i| > 1 represented in the tree decomposition, then we obtain G\u22a0 through the contraction scheme represented on Fig.\u00a0 3. If \u2200i, j the edge connecting {ui, vi} and {uj , vj} is (ui,uj) or (vi, vj) , then w.l.o.g we are in one of the two situations colored in orange on Fig.\u00a03. By contracting the orange parts into the extremity they contain, we get G\u22a0 as a minor of G.\nSince bulges in a helix only consist of vertices of degree exactly 2, combining Proposition\u00a0 1 with Theorem\u00a0 2 implies that the treewidth of any expansion of a given fatgraph is always smaller than or equal to the treewidth of a minimal expansion where all bands are helices of length exactly 5. As for gaps, arguments similar to the proof of\nTheorem\u00a02 can show that going from a gap of length 0 to an arbitrary length does not increase the treewidth of a fatgraph expansion. Overall, we formally define the minimal expansion of a fatgraph as:\nDefinition 4 (Minimal representative expansion of a fatgraph) Given a fatgraph \u03b3 , its minimal representative expansion consists of:\n\u2022 A perfect helix of length 5 for each band. \u2022 No gap between the extremities of two helices\nSuch a minimal representative expansion is illustrated in Fig.\u00a08a. For visual clarity, gaps have been kept between consecutive helices, but one can see that the corresponding extremities have the same labels. Given a fatgraph, this RNA structure graph contains all necessary information for formulating DP equations decomposing all RNA structures compatible with the fatgraph.\nInterestingly, the two graphs G\u22a0 and G that emerge in the proofs as the two graphs G could be equivalent in terms of treewidth, as well as the separators they are associated to (see Fig.\u00a03c) are reminiscent of two typical decomposition strategies used into dynamic programming for RNA folding. They suggest, for each helix in a graph, two possible \u201ccanonical representations\u201d in terms of tree decomposition, which will be elaborated on in the next section.\nInterpreting the\u00a0tree decomposition of\u00a0a\u00a0fatgraph expansion as\u00a0a\u00a0DP algorithm Starting with a tree decomposition for a minimal representative expansion of a given fatgraph, we first describe in this section how to represent it in a canonical form, with each helix represented either in one of two different ways, respectively related to G and G\u22a0 . The resulting tree decomposition can be further compressed into a skeleton, where bags within individual helices are compressed into a single bag.\nThis tree can then be interpreted as a dynamic programming scheme, in which helices are generated by specializing dynamic programming subroutines. In a sense, the tree decomposition yields automatically a decomposition strategy usable for dynamic programming, of the kind that was hand-crafted in previous approaches [11, 12].\nCanonical form of\u00a0fatgraph tree decompositions Let us recall this additional definition for the sake of presentation: Given an edge e = (X ,Y ) of a tree decomposition T , we call the X \u2212 side of T the connected component of T \\ e containing X.\nDefinition 5 A tree decomposition of an expansion G of a fatgraph is in canonical form if, for each helix H of length l, either:\n\u2022 Clique case: H is represented by a root bag that contains its 4 extremities, connected to a sub-treedecomposition Tl recursively defined as\n\u2022 Diagonal case: Helix H is represented by a linear series of bags starting with X1 = S\u2217 \u222a {u1, v1} , finishing with X2l+2 = S\u2217 \u222a {ul , vl} , and such that for 1 < k < l + 1 :\nT\u22a00 = \u2205\nT\u22a0l = {u1, v1,ul , vl}\n\u2192 {u1, v1,ul , vl\u22121, vl}\n\u2192 {u1, v1,ul\u22121,ul , vl\u22121} \u2192 T \u22a0 l\u22121\nand\nThe definition above is illustrated by Fig.\u00a04. A canonical tree decomposition for a minimum expansion of a fatgraph is also presented on Fig.\u00a0 5. It was obtained through the processing routine that we describe in Algorithm\u00a0 2, applicable to any (optimal or not) tree decomposition. It can therefore use a sub-optimal tree decomposition obtained from a polynomial heuristic [21] instead of an exponential solver, if the latter is too time-consuming (although [31] is empirically quite efficient on RNA structure graphs) (Fig 6).\nAlgorithm\u00a02 essentially follows the dichotomy of the proof of Theorem\u00a02. We state its correctness, run-time and proof below.\nX2k = S \u2217 \u222a {u2k\u22121, v2k\u22121,u2k}\nX2k+1 = S \u2217 \u222a {v2k\u22121,u2k , v2k}.\nInput : Tree decomposition T for the minimal expansion G of a fatgraph \u03b3.\nOutput: A tree decomposition of G in canonical form 1 if width(T ) \u2264 3 then \u2212\u2192 \u2018\u2018Diagonal case\u2019\u2019 only 2 foreach helix H in fatgraph \u03b3 do\n\u2212\u2192 \u2203i, j s.t. ui, vi completely separated from uj , vj in T\n3 Find an edge (X,Y ) of T and i, j such that 0 \u2264 i, j \u2264 4, |i\u2212 j| > 1 and X \u2229 Y separates ui, vi on the X-side from uj , vj on the Y-side; 4 \u2200i \u2208 [0 . . . 4], replace ui with u1 and vi with v1 in all bags of the X-side of T ; 5 \u2200j \u2208 [0 . . . 4], replace uj with u4 and vj with v4 in all bags of the Y -side of T ; 6 Insert between X and Y the \u201cdiagonal\u201d canonical representation for H, with constant part S = (X \u2229 Y ) \\ {uk, vk}i\u2264k\u2264j 7 end 8 else 9 foreach helix H in \u03b3 do\n10 if \u2203 i, j and (X,Y ) edge of T s.t X \u2229 Y separates ui, vi on the X-side from uj , vj on the Y -side then \u2212\u2192 \u2018\u2018Diagonal case\u2019\u2019 11 \u2200i \u2208 [0 . . . 4], replace ui with u1 and vi with v1 in all bags of the X-side of T ; 12 \u2200j \u2208 [0 . . . 4], replace uj with u4 and vj with v4 in all bags of the Y -side of T ; 13 Insert between X and Y the \u201cdiagonal\u201d\ncanonical representation for H, with constant part S = (X \u2229 Y ) \\ {uk, vk}i\u2264k\u2264j\n14 else \u2212\u2192 \u2018\u2018Clique case\u2019\u2019 15 \u2200i, j there is always an edge connecting ui, vi to uj , vj represented T \u2192 use these edges to get a tree decomposition for G ; 16 Attach a tree decomposition for an helix closed by a clique to the bag containing the clique on the 4 extremities of H 17 end 18 end 19 end\nAlgorithm\u00a0 2: Algorithm for\u00a0 re-writing a\u00a0 tree decomposition into\u00a0a\u00a0canonical one in\u00a0which every helix of\u00a0 the\u00a0 input graph is\u00a0 represented in\u00a0 a\u00a0 canonical way. A\u00a0representation of\u00a0an\u00a0helix as\u00a0a\u00a0subgraph in\u00a0a\u00a0minimal representative expansion, along\u00a0 with\u00a0 the notations (ui, vj ...) used in\u00a0this pseudo-code can be found on\u00a0Figure\u00a06. With a\u00a0 slight abuse of\u00a0 notation, we re-use these variables for\u00a0each helix.\nTheorem\u00a0 3 Given G the structure graph of a minimal expansion of a fatgraph \u03b3 , and T a tree decomposition of"
        },
        {
            "heading": "G, Algorithm\u00a02 outputs a canonical tree decomposition for",
            "text": "G, having same width as T, in time O(NH \u00b7 n3) , where NH is the number of helices in \u03b3.\nProof Concerning the run-time, enumerating all pairs 1 \u2264 i < j \u2264 l) is quadratic in the length of the helix under consideration, which is O(n) in a general graph, while testing a given edge for separation of ui, vi and uj , vj takes O(n) (through breadth-first search) for each of the O(n) edges of the tree decomposition.\nAs for its correctness: it essentially follows the dichotomy of Theorem\u00a02. If width(T ) \u2264 3 , then there has to be a pair of indices i,\u00a0 j such that {ui, vi} is separated from {uj , vj} by an edge (X,\u00a0Y) of the tree decomposition. If it is not the case, contracting (uk , vk) \u2200k yields a K5-minor, which is not possible with a width of 3. We therefore get a separator as depicted in blue on Fig.\u00a07, which forms the \u201cconstant part\u201d of the diagonal-case helix representation. The replacement of vertex occurences on both sides of the separator does not increase the width, while representing all edges of the graph.\nIf width(T ) \u2265 4 , if a separator as above is found (but this time, no guarantee to find one), then we apply the same transformation. Otherwise, we use the extra edges represented in the tree decomposition to modify it into a tree decomposition of G\u22a0 , as in the proof of Theorem\u00a02. There is then necessarily a bag containing all four extremities of the helix, to which a tree decomposition representing the inside of the helix can be attached.\nNote that in a canonical tree decomposition, all vertices and edges internal to a helix of a graph are represented in the canonical sub-tree-decomposition associated to it. All bags outside of these canonical blocks only consist of extremities of helices, or other vertices outside of helices. Ignoring these internal parts, to focus on a more compact \u201cskeleton\u201d of canonical tree decompositions will be the first\nstep towards automatically deriving dynamic programming equations.\nDefinition 6 The skeleton of a canonical tree decomposition for a graph G, is defined as follows:\n\u2022 All sub-tree-decompositions representing a helix in the \u201cclique\u201d case are replaced with a unique bag containing all extremities of the helix \u2022 All sub-tree-decompositions representing a helix in the \u201cdiagonal\u201d case are contracted to contain their first and last bags only, denoted as S \u222a {u1, v1} and S \u222a {ul , vl} in Definition\u00a05.\nFigure\u00a08b gives an example of such a skeleton.\nAutomatic derivation of\u00a0dynamic programming equations in\u00a0a\u00a0base pair\u2011based energy model Given the skeleton of a representative minimal expansion of a fatgraph \u03b3 , we describe here how to formulate DP equations for the corresponding folding problem. We initially restrict our exposition to a base-pair based model, further named BP model, akin to the one optimized by the seminal Nussinov algorithm [38], where the free-energy of a structure S is given by:\nGi,j being the contribution of a base-pair (i,\u00a0 j) to the free-energy (or negative log-odd to produce max-likelihood structures).\nEBP(S) = \u2211\n(i,j)\u2208S\n\ufffdGi,j ,\nEssentially, we introduce helix DP tables for each helix, and transitional tables for non-helix bags. The variables indexing these tables are called anchors. These integer variables each represent a separation point between consecutive (half-)helices. Taken together, a full set of anchors (a, b, c, . . .) partitions the sequence into a set of disjoint intervals [a, b[, [b, c[. . . , each associated with one half-helix, i.e.\u00a0one of the subsequences that form a helix. Helix tables will account for the freeenergy contributions of concrete base-pairs, while transitional tables will instantiate anchors in a way that remains consistent with previous assignments.\nIndeed, owing to the definition of a valid tree decomposition, a skeleton is guaranteed to:\n1. Feature each anchor in some bag; 2. Represent each pair of consecutive anchors in at least\none bag;\n3. Propagate anchor values, such that the anchor values within helix tables remain consistent. This implies that non-helix bags can simply propagate previouslyassigned anchors, possibly assigning values to novel anchors (if any and constrained to remain consistent with the sequential order) to explore all possible partitions of the input RNA sequence.\nHelix tables will predict concrete sets of base pairs and account for their associated free-energy. In order to both prevent the double pairing of certain sequence positions, and to avoid ambiguity, we require (and enforce in the DP rules) that an anchor x, separating the consecutive halves of two helices H and H \u2032 , implies the pairing of position x to the other half of H \u2032 , and the pairing of some position x\u2032 < x as part of H. In other words, a helix H delimited by anchors i, i\u2032, j\u2032, and j must pair position i to some position x \u2208]j\u2032, j[ , and j\u2032 to some position y \u2208]i, i\u2032[ , implicitly leaving both regions ]y, i\u2032[ and ]x,\u00a0j[ unpaired."
        },
        {
            "heading": "Helix table\u00a01: \u201cClique\u201d cases",
            "text": "In the skeleton, each bag representing a helix in the \u201cclique\u201d case is associated to the following tables, where i, i\u2032 + 1, j\u2032 , and j + 1 represent the values of the anchors delimiting the helix. The increments on i\u2032 and j are here to ensure the presence of gap of length \u2265 1 between two base pairs belonging to different helices. (see also Fig.\u00a08c for an example of how anchor values are passed to C\u22a0 with a decrement of \u22121 for the same reason).\nA first table C \u2032 \u22a0 holds the minimal free-energy of a helix delimited by i, i\u2032, j\u2032, and j, such that position i is paired to some x \u2208]j\u2032, j[ and j\u2032 to some position y \u2208]i, i\u2032[ . The idea is here to iteratively move the anchor from j to j \u2212 1 , implicitly leaving position j unpaired, until a base pair (i,\u00a0j) is formed. Once a base pair is created, we transition to another table C\u22a0 which optimizes over helices like C \u2032\u22a0 , but additionally allows position i to be left unpaired.\nThose two tables can be filled owing to the following recurrences:\nand\nwhere Gi,j denote the free-energy contribution of the base pair (i,\u00a0j) in the input RNA sequence."
        },
        {
            "heading": "Helix tables\u00a02: \u201cDiagonal\u201d cases",
            "text": "In the skeleton bags representing the diagonal cases, we need to associate a different table to each helix. Indeed, each \u201cdiagonal\u201d case associates, to a helix H, a set S of indices, dubbed the constant anchors, whose values remain unchanged during the construction of H.\nWe focus on the case where (i,\u00a0 j) represents the value of the outermost anchor pair (i.e. [i,\u00a0 j] represents the full span of H), leaving to the reader the symmetric case starting from the innermost pair. Note that, in the skeleton, we kept two bags for a \u201cdiagonal case\u201d helix. Yet they are associated to a single table, since the helix is created by incrementing two indices only, such that the initial pair of extremities \u201cbecomes\u201d the other pair. We need this second bag to know how to map index values to the children tables {Mk}k . This value mapping at the end of a diagonal case is illustrated on Fig.\u00a09.\nC \u2032 \u22a0 [i, i\u2032, j\u2032, j] = min\n\n   \n   \nC \u2032 \u22a0 [i, i\u2032, j\u2032, j \u2212 1] {if j\u2032 < j} C\u22a0[i + 1, i \u2032, j\u2032, j \u2212 1] +\ufffdGi,j\n{if (i < i\u2032) \u2227 (j\u2032 < j)} \ufffdGi,j {if j = j \u2032} +\u221e {if no case applies}\nC\u22a0[i, i \u2032, j\u2032, j] = min\n\n     \n     \nC \u2032 \u22a0 [i, i\u2032, j\u2032, j \u2212 1] {if j\u2032 < j} C\u22a0[i + 1, i \u2032, j\u2032, j] {if i < i\u2032} C\u22a0[i + 1, i \u2032, j\u2032, j \u2212 1] +\ufffdGi,j\n{if (i < i\u2032) \u2227 (j\u2032 < j)} \ufffdGi,j {if j = j\n\u2032} +\u221e {if no case applies}\nNamely, let the cell DH [i, j | S] (resp. D\u2032H [i, j | S] ) represent the minimum-free energy achieved by the set of helices in the subtree of H, when H is anchored at (i,\u00a0 j) without commitment to form base pairs for neither i nor j (resp. where i is committed to form a pair with some position x \u2264 j\u2032 ). We have:\nand\nwhere Ak denotes the anchors values needed for the k-th child of the diagonal bag."
        },
        {
            "heading": "Transitional tables: Non\u2011helix bags",
            "text": "The general case consists of passing the values of relevant variables onward to the diagonal and clique tables, possibly assigning/propagating anchors that appear in the bag for the first time, i.e. anchors that are not found in the parent bag. Let IP be the anchors of the parent bag of M in the tree decomposition, we have:\nwhere Ik denotes the anchor values from I needed for the k-th child of the bag, and S represents the constant anchors of the k-th child, assumed to be a diagonal."
        },
        {
            "heading": "Complexity analysis",
            "text": "Let w\u22a0 , w and w\u2032 be the maximum width of a clique, diagonal and transitional bag (i.e. its size minus one; or 0 if no bag exist for a given type) in a canonical tree decomposition T of a fatgraph \u03b3 . Note that w\u22a0 is always 4, but we keep this notation for consistency. In the following theorem, \u03b3 is a fatgraph with |\u03b3 | helices and T is a canonical tree decomposition for \u03b3 . The DP scheme obtained from T as described in the previous section is called the DP scheme inferred from T .\nD\u2032H [i, j | S] = min\n\n \n \nD\u2032H [i, j \u2212 1 | S] {if j \u2212 1 > i \u2227 \u2200s \u2208 S, j \u2212 1 \ufffd= s}\nDH [i + 1, j \u2212 1 | S] +\ufffdGi,j {if \u2200s \u2208 S, (i + 1 \ufffd= s) \u2227 (j \u2212 1 \ufffd= s)}\nDH [i, j | S] = min\n\n         \n         \nDH [i + 1, j | S] {if i + 1 < j \u2227 \u2200s \u2208 S, i + 1 \ufffd= s} D\u2032H [i, j \u2212 1 | S] {if j \u2212 1 > i \u2227 \u2200s \u2208 S, j \u2212 1 \ufffd= s}\nDH [i + 1, j \u2212 1 | S] +\ufffdGi,j {if \u2200s \u2208 S, (i + 1 \ufffd= s) \u2227 (j \u2212 1 \ufffd= s)} \ufffd\nk Mk [Ik ] {with Ik := \ufffd {i, j + 1} \u222a S \ufffd \u2229 Ak}\nM[IP] = min Values for\nanch. in I \\ IP\n#child. \ufffd\nk=1\n\n     \n     \nMk [Ik ] {if k-th child trans.} C \u2032 \u22a0 [i, i\u2032 \u2212 1, j\u2032, j \u2212 1] {if clique at (i, i\u2032, j\u2032, j)} D\u2032Hk [i, j \u2212 1 | Sk ]\n{if diagonal at (i, j\u2032)}\nTheorem\u00a04 In the base-pair energy model, the DP scheme inferred from T yields an algorithm for the Fatgraph MFE Folding problem with O(|\u03b3 | \u00b7 nmax(w\u22a0,w ,w\u2032+1)) time and O(|\u03b3 | \u00b7 nmax(w\u22a0,w ,w \u2032)) space complexity.\nTable 1 While the space complexity of the generated DP schemes is always bounded by O(ntw) (Lemma 3), the run-time complexity of filling-up the DP tables C and C\u22a0 depends on the choice of energy model. As for the table corresponding to a transitional bag X with indices I, the cost of filling it is O(ntw+1) irrespectively of the energy model\nEnergy model Diagonal tables Clique tables Transitional tables C [i, j|S] C\u22a0[i, i \u2032 , j\u2032, j] MX [IX ]\nBP-based model O ( n |S|+2 )\nO ( n 4 )\nO ( n |I| )\nBP+stacking O ( n |S|+2 )\nO ( n 4 )\n|\nFull Turner O ( n |S|+3 )\nO ( n 5 )\n|\nProof The complexity of the DP scheme inferred from T (presented in the previous section for a base-pair based model) depends on the complexities of filling each of the tables corresponding to helices.\nC\u22a0[i, i \u2032, j\u2032, j] and C \u2032 \u22a0 [i, i\u2032, j\u2032, j] take O(n4) to fill, using either a memoization procedure or a bottom-up iteration of all possible values for i, i\u2032, j\u2032, j . It is equal to the space complexity thanks to the finite number of cases in their recursive equations.\nA similar analysis holds for C [i, j | S] and C \u2032 [i, j | S] , except that the number of indices is |S| + 2 . Since the maximum size of a bag in a diagonal-case representation is |S| + 3 , we indeed have w = |S| + 2.\nFor transitional bags, the situation is slightly different. The indices of the table are the intersection with the parent bag in the tree decomposition, whose number is bounded by w\u2032 . The space complexity of the corresponding DP table is therefore O(ntw\u2032) . But there is also a minimization over all possible values for the variables not present in the parent bag, incurring a linear factor for each of them. Overall, for a transitional B of maximum size w\u2032 + 1 , the complexity of filling the matrix is O(w\u2032 + 1) ( O(n|B\\P|) for each of the O(n|B\u2229P|) ) entries.\nAs for the number of tables, it is at most twice the number of bags in T , which is linear in the number of helices in \u03b3 . The overall time complexity is therefore given the DP table of most expensive filling cost, O(|\u03b3 | \u00b7 nmax(w\u22a0,w ,w\n\u2032+1)) . The same holds for the space complexity, yielding O(|\u03b3 | \u00b7 nmax(w\u22a0,w ,w\u2032)) .\nSince tree decompositions are typically chosen to minimize their width tw := max(w\u22a0,w ,w\u2032) , then the precise resulting complexity may depend on the choice of an optimal tree decomposition. Indeed, it could be that tw = w\u2032 , yielding a O(ntw+1) algorithm or, conversely, w\u2032 < tw \u2212 1 would imply a complexity of O(ntw) . In other words, in the base pair model, the algorithm induced by the choice of an arbitrary tree decomposition T may be suboptimal by a linear factor. Figure\u00a011 shows an example with two tree decompositions of the same width, but with different w\u2032 values. They yield different complexities ( O(n4) vs. O(n5)).\nFortunately, it is possible to work around this issue, and obtain a O(ntw) DP algorithm anytime a suitable canonical fatgraph decomposition exists. To find such a decomposition, we explore the space of all possible canonical tree decompositions, through an enumeration of all possible representations for each helix. This is formalized in the theorem below (note that this is purely meant as a feasibility result, we do not expect this approach to be optimal in terms of complexity; however, we conjecture that this subproblem is FPT for the treewdidth of \u03b3 ). We use the same notations as above by calling w\u2032(T ) the\nmaximum width of a transitional bag of a canonical tree decomposition."
        },
        {
            "heading": "Theorem\u00a05 Let G be a minimal expansion of a fatgraph",
            "text": "\u03b3 with nH helices. If there exists an optimal canonical tree decomposition T of G such that w\u2032(T ) \u2264 tw(G)\u2212 1 , then such a T can be found in 2O ( |\u03b3 |2 ) \u00b7 f (tw) time.\nProof The space of all possible canonical tree decomposition can be iterated over by deciding, for each helix, whether it is in the \u201cclique\u201d or \u201cdiagonal\u201d case. If it is in the diagonal case, one must in addition decide what is the \u201cconstant part\u201d of the representation of the helix. Any set S such that {u1, v1,u5, v5} \u222a S separates the graph into at least 3 connected components, one being the inside of the helix, is an eligible candidate.\nThis process corresponds to deciding, for each helix, what separator cuts out the inside of the helix from the rest of the graph. When such a decision is made, a canonical tree decomposition can be obtained by computing canonical tree decompositions for the connected components associate to the separator, and connecting them together (in the spirit of Proposition\u00a02). When there are no helices left, an optimal tree decomposition of the graph is computed in time f(tw). It yields the transitional bags in between helix representations.\nGiven that S is only composed of helix extremities, it is chosen among \u2264 |\u03b3 | vertices. We consider therefore an upper bound of 2|\u03b3 | for the number of possible choices of S in the diagonal case, and an upper bound of |\u03b3 | for the number of connected components associated to a separator, the overall time of exploring all canonical tree decompositions is bounded by O((|\u03b3 | \u00b7 2|\u03b3 |)|\u03b3 | \u00b7 f (tw)) \u2286 2O ( |\u03b3 |2 )\n\u00b7 f (tw). If an optimal canonical tree decomposition T such that w\u2032(T ) \u2264 tw(G)\u2212 1 exists, then it corresponds to a particular assignation of separators to each helix as outlined above, and it will be one of the tree decompositions explored by the iteration."
        },
        {
            "heading": "Automated C code generation",
            "text": "Figure\u00a0 8 shows an example of output to our pipeline, with automatically generated LaTeX equations for the dynamic programming scheme inferred from the tree decomposition. Figure\u00a0 10 gives other examples of such automatically generated equations. But our implementation, available freely at https:// gitlab. inria. fr/ bmarc han/ auto- dp, is also capable of automatically generating C code implementing these equations. The automatically generated *.c files corresponding to all of the examples of Fig.\u00a0 10 are available as Supplementary Material. In the current state, they are only meant as a prototype\ndemonstration. Developments towards generation of fully functional code, including the extensions presented in the next Section, will be the subject of future work."
        },
        {
            "heading": "Extensions",
            "text": "The DP scheme, as stated above, only supports conformations that consist of a single pseudoknot configuration, indicated by a fatgraph. Moreover, it forces the first position of the sequence to always form a base pair. Finally, it considers an energy model that is fairly unrealistic in comparison with the current state of the art. In this section, we briefly describe how to extend this fundamental construction in several directions. This enables us to solve the stated algorithm design problem (Def.\u00a02) and consequently the associated folding problem in complex energy models, and discuss the consequences on the complexity.\nIntegration with\u00a0classic DP algorithms for\u00a0MFE structure prediction Firstly, let us note that alternative fatgraphs can easily be considered, without significant overhead, by adding a disjunctive rule at the top level of the DP scheme, such as\nwhere root\u03b3i is the top level case of the DP scheme for fatgraph \u03b3i.The associated conformation space then consists of the union of all pseudoknotted structures compatible with one of the fatgraphs."
        },
        {
            "heading": "Enriching classic schemes with\u00a0fatgraphs",
            "text": "Fatgraphs usually represent a structural module rather than a complete RNA conformation. The classic DP scheme for 2D structure energy-minimization can thus be supplemented by additional constructs, enabling the consideration of pseudoknots. Towards that goal, one needs to access MFEPK(i, j) , the MFE achieved over a region [i,\u00a0j] by a conformation compatible with one of the input fatgraphs. In other words, one needs to be able to prescribe the span of the fatgraph occurrence, i.e. the values (i,\u00a0j) of its extremal anchors (a, a\u2032) within the dynamic programming.\nTo ensure this possibility, one simply needs to connect the first and last positions within the minimal fatgraph completion G = (V ,E) , i.e. resulting in a graph G\u2032 := (V ,E \u222a {(a, a\u2032)}) . Since each arc of the input graph is represented in a valid tree decomposition, we know that any tree decomposition for G\u2032 features a bag B including both a and a\u2032 , possibly in conjunction with additional anchors S := {k1, k2, . . .} . Moreover, since a tree decomposition is unordered, it can be rerooted to start with B, and preceded by a root node restricted to\nMFEPK := p\nmin i=1 root\u03b3i [\u2205]\nanchors (a,\u00a0 b), without adverse consequences complexity-wise. This yields the following entry point for the DP of a fatgraph \u03b3:\nwhich can be used within a classic, pseudoknot-oblivious, DP scheme for MFE structure prediction. Complexitywise, it can be shown that the additional base pair can at most increase by 1 the treewidth (and frequently leaves it unchanged)."
        },
        {
            "heading": "Recursive substructures",
            "text": "Recursive substructures consist of secondary structures/occurrences of fatgraphs that are inserted, both in between and within helices, usually through recursive calls to the (augmented) 2D folding scheme.\nTo allow arbitrary sub-structures to be inserted in the gaps between consecutive helices, one can again modify the minimal helix expansion to distinguish the anchors a,\u00a0b associated with consecutive helices (instead of merging them into a single anchor in our initial exposition). By connecting a and b, one ensures their simultaneous presence in a tagged bag B, whose DP recurrence is then augmented to include an energy contribution MFESS(a+ 1, b\u2212 1).\nTo enable the insertion of substructures within a helix requires modifications to the helix clique/diagonal rules that are very similar to the ones enabling support for the Turner energy model. Assuming the presence of a base pair (i,\u00a0j), an insertion can indeed be performed by delimiting a region [i,\u00a0k] (resp. [k,\u00a0j]) of arbitrary length, leading to an overall MFE of MFESS(i, k)+ \u03b4 , where \u03b4 is the freeenergy contributed by the rest of the helix (e.g. to include additional terms associated with multiloops).\nMore realistic energy models For the sake of simplicity, we illustrated in Sect. \"Automatic derivation of dynamic programming equations in a base pair-based energy model\" the generation of a dynamic programming algorithm within a fairly simple base-pair based energy model. However, the procedure can be adapted to capture more complex energy models found in the literature. This includes stacking base pairs models defined as:\nwith Gi,i+1,j\u22121,j the energy of base pair (i + 1, j \u2212 1) stacking onto (i,\u00a0 j), or even the nearest-neighbor freeenergy model, also called Turner model.\nMFE\u03b3 (i, j) := min i<k1<k2<...<j MB[i, k1, k2, . . . , j]\nEStacking (S) = \u2211\n{(i, j), (i + 1, j \u2212 1)} \u2282 S\n\ufffdGi,i+1,j\u22121,j\nIn the Turner model, any pseudoknot-free structure S is decomposed into loops, each rooted at a base pair (i, j) \u2208 S \u222a {(\u22121, n+ 1)} , and delimited by a set of base pairs L(i, j) = {(i\u2032, j\u2032)} \u2208 S such that [i\u2032, j\u2032] \u2282 [i, j] and \u2203(i\u2032\u2032, j\u2032\u2032) \u2208 S such that [i\u2032, j\u2032] \u2282 [i\u2032\u2032, j\u2032\u2032] \u2282 [i, j] . A loop L(i,\u00a0j) is then assigned a free-energy contribution \ufffdGL(i,j) that depends on the nucleotide content of base pairs, and unpaired regions between adjacent base pairs. The overall free energy of a structure in the Turner model is then defined as\nRather than including independent values for all contents and size of loops, the Turner model usually uses affine linear models for multiloops ( |L(i, j)| \u2265 2 ), and interior loops ( |L(i, j)| = 1 ), the latter based on loop length and asymmetry.\nBoth of those models can be captured by a modified version of the dynamic programming algorithm presented in Sect.\u00a0 \"Automatic derivation of dynamic programmingequations in a base pair-based energy model\". In the stacking model, it suffices to duplicate the cliques (resp. diagonal) matrices to keep track of (i,\u00a0 j) being directly enclosed ( \u22a5 ) or not ( \u22a5 ) within a base pair (i + 1, j \u2212 1) . This results in a replacement (C\u22a0,C \u2032\u22a0) with (C\u22a0,\u22a5,C \u2032 \u22a0,\u22a5,C\u22a0,\ufffd\u22a5,C \u2032 \u22a0,\ufffd\u22a5) (resp. (DH ,D \u2032 H ) into (DH ,\u22a5, D \u2032 H ,\u22a5,DH ,\ufffd\u22a5,D \u2032 H ,\ufffd\u22a5) ), and the inclusion of suitable energy contributions for the \u22a5 cases, the only ones likely to form stacking pairs. The time complexity remains identical, up to a constant, to that of the BP energy model.\nA consideration of the full Turner model is more involved, but can be achieved in O(n3) through an enumeration of all possible loops, as shown by Lyngsoe et\u00a0al [39], by exploiting the linear interpolation of loops beyond a certain length threshold. Adapting the recurrence to consider all possible helix expansions of cliques and diagonals will result in a O(n) time overhead for all cliques and diagonals, leading to an increased time complexity in O(|\u03b3 | \u00b7 nmax(w\u22a0+1,w +1,w\u2032+1)) , or equivalently O(|\u03b3 | \u00b7 ntw+1) . A summary of the complexity of filling the different kinds of DP table (transitional, clique and diagonal) depending on the choice of energy is given on Table\u00a0 1. In any case, the space complexity is always O(|\u03b3 | \u00b7 ntw) , as stated below.\nLemma 3 The space complexity of the generated DP schedule is O(|\u03b3 | \u00b7 ntw) , regardless of the energy model.\nProof The set of indices of a table is the intersection of the corresponding bag with its parent bag. Both bags have size at most tw + 1 , and they are distinct, so their intersection has size at most tw. Each index runs in the\nETurner(S) = \u2211\n(i,j)\u2208S\u222a{\u22121,n+1}\n\ufffdGL(i,j).\nrange [0,\u00a0n], so the size of each table is at most ntw . The number of tables is bounded by the number of bags in the tree decomposition of \u03b3 , which is itself in O(|\u03b3 |) ."
        },
        {
            "heading": "Partition functions and\u00a0ensemble applications",
            "text": "For ensemble applications of our DP schemes, such as computing the partition function [40] and statistical sampling of the Boltzmann ensemble [41], it is imperative for the DP scheme above to be complete and unambiguous [42]. Fortunately, both properties are already guaranteed by our DP schemes. Indeed, intuitively: the completeness is ensured by the exhaustive investigation of all possible anchor positions, i.e. all possible partitions; the unambiguity is guaranteed by the invariant that assigning a position x to a given anchor (within a transitional or diagonal bag), leads x to be paired within the (half-)helix immediately to its right. Choosing different values for x thus induces different innermost/outermost base pairs for the associated helix, leading to disjoint sets of structures.\nFrom these two properties, we conclude that the partition function for a fatgraph (or several, possibly recursively and/or within a \u00b1 realistic energy model) can be obtained through the simple change of algebra pioneered by McCaskill [40] in the pseudoknot-free case. Namely, replace the (min,+,\ufffdG) terms into ( \u2211\n,\u00d7, e\u03b2\ufffdG) , with \u03b2 = RT being the Boltzmann constant multiplied by some absolute temperature."
        },
        {
            "heading": "Automated (re\u2011)design of\u00a0algorithms for\u00a0specific pseudoknot classes",
            "text": "Our pipeline for automated generation of DP folding equations given a fatgraph has been implemented using Python and Snakemake [43]. The implementation is freely available at: https:// gitlab. inria. fr/ bmarc han/ auto- dp.\nSince the algorithms in [12] have been described in terms of a finite number of fatgraphs (called irreducible shadows in the paper), one can directly apply our method to obtain an efficient algorithm that covers the same class as gfold, namely 1-structures that are recursive expansions of the four fatgraphs of genus 1 corresponding to simple PK \u2019H\u2019 ([)], kissing hairpin \u2019K\u2019 ([)(]), threeknot \u2019L\u2019 ({[)}] and \u2019M\u2019 ([{)(]}) (here, represented in dot-bracket notation, i.e. corresponding opening and closing brackets correspond to arcs). The maximum complexity of O(n6) of the four fatgraphs (see Table\u00a0 2) implies that the automatically derived algorithm covers the class of 1-structures in O(n6) time\u2014the same complexity as hand-crafted gfold. Note that [12] used declarative methods in their algorithm design only to the point of generating grammar rules, which without\nfurther optimization yield O(n18) (after applying algebraic dynamic programming; ADP [44]). In contrast, our method obtains the optimal complexity in fully automatic fashion. Beyond this re-design of gfold, remarkably our method is equally prepared to automatically design a DP algorithm with optimized efficiency for 2-structures, which are based on all genus 2 fatgraphs. This is remarkable, since the implementation of a practical algorithm has been considered infeasible [12] due to the large number of genus 2 shadows (namely, there are 3472 shadows/ fatgraphs), whose grammar rules would have to be optimized by hand. In contrast, due to full automation, our method directly handles even the large number of fatgraphs of genus 2 and yields an efficient, complexity optimized, DP scheme.\nRecall that we cover all other pseudoknot classes that are recursive expansions of a finite number of fatgraphs (in the same way as we cover the design of prediction algorithms for 1- and 2-structures). In this way, among the previously existing DP algorithms, we cover the class of Dirks &Pierce (D &P) [11], simply by specifying the H-type as single input fatgraph. Consequently, we automatically re-design the D &P algorithm in the same complexity of O(n5) . Even more interestingly, we can design algorithms covering specific (sets of ) crossing configurations. This results in an infinite class of efficient algorithms that have not been designed before. Again the complexity of such algorithms is dominated by the most complex fatgraph; where results for interesting ones are given in Table\u00a02. Most remarkably, we design an algorithm optimizing over recursive expansions of kissing hairpins in O(n4) , whereas CCJ [13, 45], which was specifically designed to cover kissing hairpins, requires O(n5).\nA special case, which further showcases the flexibility, is the extension of existing classes by specific crossing configurations. For example, extending D &P by kissing hairpin covers a much larger class while staying in the same complexity. Extending 1-structures by 5-chain yields a new algorithm with a complexity below of 2-structures (namely only O(n7) instead of O(n8) [12]). The complexity of 5-chain is remarkably low, when considering that previously described algorithms covering this configuration take O(n8) (e.g. gfold\u2019s generalization to 2-structures and a hypothetical blow-up of the Rivas and Eddy algorithm [10] to 6-dimensional instead of 4-dimensional DP matrix elements\u2014both of which have never been implemented)."
        },
        {
            "heading": "Conclusions and\u00a0discussion",
            "text": "In this work, we provided an algorithm that takes a family of fatgraphs, i.e. pseudoknotted structures, and returns DP equations that efficiently predict arc annotations\nminimizing the free energy. The DP equations are automatically generated based on an expansion of the fatgraph, designed to capture helices of arbitrary length. The DP tables in the equations use a number of indices smaller than or equal to the treewidth of the minimal expansion. This very general framework recovers the complexity of prior, hand-crafted algorithms, and lays the foundation for a purely declarative approach to RNA folding with pseudoknots.\nIn addition to the extensions described in Sect. \"Extensions\", this work suggests perspectives that will be explored in future work. Indeed, the choice of an optimal decomposition/DP scheme for the input fatgraph can be seen as the automated design of an optimal table strategy in the context of algebraic dynamic programming [44, 46, 47]. This would enable extensions to multiple context free grammars or tree grammars when describing the problem in the ADP framework.\nOur automated design of pseudoknot folding algorithms could naturally be extended to RNA\u2013RNA interactions, since the joint conformation of two interacting RNA sequences can be seen as a pseudoknot when concatenating the two structures [48]. More ambitiously, categories of pseudoknots inducing an infinite family of fatgraphs, e.g. as covered by the seminal Rivas & Eddy algorithm [10], could be captured by allowing the introduction of recursive gapped structures in prescribed parts of the fatgraph. This could be addressed by adding cliques to the minimal completion graph which would ensure the availability of the relevant anchors in some bags of the tree decomposition, allowing to score such non-contiguous, recursive substructures.\nAnother avenue for future research includes a proof of optimality, in term of polynomial complexity, for the produced DP algorithms. Of course, it would be far too ambitious (and erroneous) to expect our DP schemes to be optimal within general computational models. However, it may be possible to prove optimality within a formally-defined subset of DP schemes, e.g. by contradiction since the existence of a better algorithm would imply the existence of a tree decomposition having smaller width. More precisely, given a fatgraph \u03b3 , one could imagine that a DP scheme (with DP tables indexed by anchor variables as is typically the case) capable of exploring all recursive expansions of \u03b3 would in particular induce a decomposition of the minimal representative expansion of \u03b3 , from the parsing of this structure by the DP grammar. If this decomposition can be reinterpreted as a tree decomposition, then the treewidth of the minimal expansion would become a lower bound on the number of indices to use in such a DP scheme."
        },
        {
            "heading": "Appendix",
            "text": "See Figs.\u00a010, 11\nAuthor contributions BM should be considered the leading author in this study. All authors contributed to all aspects of the research, and were involved in writing and proofreading the manuscript.\nFunding This project has received funding from the European Union\u2019s Horizon 2020 research and innovation programme under the Marie Sk\u0142odowska-Curie grant\nagreement No 101,029,676, and from the French-Austrian PaRNAssus project (ANR-19-CE45\u20130023; I 4520-N) supported by the ANR/FWF agencies.\nAvailability of data and materials A prototype implementation of our algorithm is available at https:// gitlab. inria. fr/ bmarc han/ auto- dp"
        },
        {
            "heading": "Declarations",
            "text": "Competing interests The authors declare that they have no competing interests.\nReceived: 1 April 2023 Accepted: 10 June 2023\nReferences 1. Zuker M. Mfold web server for nucleic acid folding and hybridization\nprediction. Nucleic Acids Res. 2003;31(13):3406\u201315. 2. Lorenz R, H\u00f6ner Bernhart S, Zu Siederdissen C, Tafer H, Flamm C, Stadler P,\nHofacker I. ViennaRNA Package 2.0. Algorithms Mol Biol. 2011. https:// doi. org/ 10. 1186/ 1748- 7188-6- 26.\n3. Reuter JS, Mathews DH. RNAstructure: software for rna secondary structure prediction and analysis. BMC Bioinform. 2010;11(1):1\u20139. 4. Do CB, Woods DA, Batzoglou S. CONTRAfold: RNA secondary structure prediction without physics-based models. Bioinformatics. 2006;22(14):90\u20138. 5. Zakov S, Goldberg Y, Elhadad M, Ziv-Ukelson M. Rich parameterization improves RNA structure prediction. J Comput Biol. 2011;18(11):1525\u201342. 6. Sato K, Akiyama M, Sakakibara Y. RNA secondary structure prediction using deep learning with thermodynamic integration. Nature Commun. 2021;12(1):1\u20139. 7. Ten Dam E, Pleij K, Draper D. Structural and functional aspects of RNA pseudoknots. Biochemistry. 1992;31(47):11665\u201376. 8. Akutsu T. Dynamic programming algorithms for RNA secondary structure prediction with pseudoknots. Discrete Appl Mathemat. 2000;104(1\u20133):45\u201362. 9. Cao S, Chen S-J. Predicting RNA pseudoknot folding thermodynamics. Nucleic Acids Res. 2006;34(9):2634\u201352. https:// doi. org/ 10. 1093/ nar/ gkl346. 10. Rivas E, Eddy SR. A dynamic programming algorithm for RNA structure prediction including pseudoknots. J Mol Biol. 1999;285(5):2053\u201368. 11. Dirks RM, Pierce NA. A partition function algorithm for nucleic acid secondary structure including pseudoknots. J Comput Chem. 2003;24(13):1664\u201377. 12. Reidys CM, Huang FW, Andersen JE, Penner RC, Stadler PF, Nebel ME. Topology and prediction of RNA pseudoknots. Bioinformatics. 2011;27(8):1076\u201385. 13. Jabbari H, Wark I, Montemagno C, Will S. Knotty: efficient and accurate prediction of complex RNA pseudoknot structures. Bioinformatics. 2018;34(22):3849\u201356. 14. Ren J, Rastegari B, Condon A, Hoos HH. HotKnots: heuristic prediction of RNA secondary structures including pseudoknots. RNA. 2005;11(10):1494\u2013504. 15. Sato K, Kato Y, Hamada M, Akutsu T, Asai K. IPknot: fast and accurate prediction of RNA secondary structures with pseudoknots using integer programming. Bioinformatics. 2011;27(13):85\u201393. 16. Jabbari H, Condon A. A fast and robust iterative algorithm for prediction of RNA pseudoknotted secondary structures. BMC Bioinform. 2014;15(1):1\u201317. 17. Reidys CM, Wang RR. Shapes of RNA pseudoknot structures. J Comput Biol. 2010;17(11):1575\u201390. 18. M\u00f6hl M, Will S, Backofen R. Lifting prediction to alignment of RNA pseudoknots. J Comput Biol. 2010;17(3):429\u201342. 19. Alkan C, Karako\u00e7 E, Nadeau JH, Sahinalp SC, Zhang K. RNA-RNA interaction prediction and antisense RNA target search. J Comput Biol. 2006;13(2):267\u201382. https:// doi. org/ 10. 1089/ cmb. 2006. 13. 267. 20. Fornace ME, Porubsky NJ, Pierce NA. A unified dynamic programming framework for the analysis of interacting nucleic acid\nstrands: enhanced models, scalability, and speed. ACS Synt Biol. 2020;9(10):2665\u201378. https:// doi. org/ 10. 1021/ acssy nbio. 9b005 23.\n21. Bodlaender HL, Koster AM. Combinatorial optimization on graphs of bounded treewidth. Comp J. 2008;51(3):255\u201369. 22. Rinaudo P, Ponty Y, Barth D, Denise A Tree decomposition and parameterized algorithms for RNA structure-sequence alignment including tertiary interactions and pseudoknots. In: International Workshop on Algorithms in Bioinformatics, 149\u2013164 (2012). Springer 23. Bodlaender HL. A linear-time algorithm for finding tree-decompositions of small treewidth. SIAM J Comput. 1996;25(6):1305\u201317. 24. Huang F, Reidys C, Rezazadegan R. Fatgraph models of RNA structure. Comput Mathemat Biophy. 2017;5(1):1\u201320. 25. Loebl M, Moffatt I. The chromatic polynomial of fatgraphs and its categorification. Adv Mathemat. 2008;217(4):1558\u201387. 26. Penner RC, Knudsen M, Wiuf C, Andersen JE. Fatgraph models of proteins. Commun Pure Appl Mathemat. 2010;63(10):1249\u201397. 27. Giegerich R, Vo\u00df B, Rehmsmeier M. Abstract shapes of rna. Nucleic Acids Res. 2004;32(16):4843\u201351. 28. Cygan M, Fomin FV, Kowalik \u0141, Lokshtanov D, Marx D, Pilipczuk M, Pilipczuk M, Saurabh S. Parameterized Algorithms. Cham: Springer; 2015. 29. Arnborg S, Corneil DG, Proskurowski A. Complexity of finding embeddings in ak-tree. SIAM J Algeb Discrete Meth. 1987;8(2):277\u201384. 30. Bodlaender HL, Koster AM. Treewidth computations i. upper bounds. Inform Comput. 2010;208(3):259\u201375. 31. Tamaki H. Positive-instance driven dynamic programming for treewidth. J Comb Optim. 2019;37(4):1283\u2013311. 32. Gogate V, Dechter R. A complete anytime algorithm for treewidth. arXiv. 2012. https:// doi. org/ 10. 48550/ arXiv. 1207. 4109. 33. Yao H-T, Waldisp\u00fchl J, Ponty Y, Will S. 2021. Taming Disruptive Base Pairs to Reconcile Positive and Negative Structural Design of RNA. In: RECOMB 2021-25th International Conference on Research in Computational Molecular Biology. 34. Scornavacca C, Weller M. Treewidth-based algorithms for the small parsimony problem on networks. Algorit Mole Biol. 2021. https:// doi. org/ 10. 1186/ s13015- 022- 00216-w. 35. Lov\u00e1sz L. Graph minor theory. Bull Am Mathemat Soc. 2006;43(1):75\u201386. 36. Bodlaender HL, Koster AM. Safe separators for treewidth. Discrete Math-\nemat. 2006;306(3):337\u201350. 37. Bouchitt\u00e9 V, Todinca I. Treewidth and minimum fill-in: grouping the\nminimal separators. SIAM J Comput. 2001;31(1):212\u201332. 38. Nussinov R, Jacobson AB. Fast algorithm for predicting the secondary\nstructure of single-stranded rna. Proc Nat Acad Sci. 1980;77(11):6309\u201313. 39. Lyngs\u00f8 RB, Zuker M, Pedersen CN. Fast evaluation of internal loops in RNA\nsecondary structure prediction. Bioinformatics. 1999;15(6):440\u20135. https:// doi. org/ 10. 1093/ bioin forma tics/ 15.6. 440.\n40. McCaskill JS. The equilibrium partition function and base pair binding probabilities for rna secondary structure. Biopolymers. 1990;29(6\u2013 7):1105\u201319. https:// doi. org/ 10. 1002/ bip. 36029 0621. 41. Ding Y, Lawrence CE. A statistical sampling algorithm for RNA secondary structure prediction. Nucleic Acids Res. 2003;31(24):7280\u2013301. https:// doi. org/ 10. 1093/ nar/ gkg938. 42. Ponty Y, Saule C. A combinatorial framework for designing (pseudoknotted) RNA algorithms. In: Przytycka TM, Sagot M-F, editors. Algorit Bioinform. Berlin, Heidelberg: Springer; 2011. p. 250\u201369. 43. M\u00f6lder F, Jablonski KP, Letcher B, Hall MB, Tomkins-Tinch CH, Sochat V, Forster J, Lee S, Twardziok SO, Kanitz A, et al. Sustainable data analysis with snakemake. F1000Research. 2021. https:// doi. org/ 10. 12688/ f1000 resea rch. 29032.2. 44. Riechert M, Stadler PF. Algebraic dynamic programming for multiple context-free grammars. Theoret Comp Sci. 2016;639:91\u2013109. https:// doi. org/ 10. 1016/j. tcs. 2016. 05. 032. 45. Chen H-L, Condon A, Jabbari H. An O (n5) algorithm for MFE prediction of kissing hairpins and 4-chains in nucleic acids. J Comput Biol. 2009;16(6):803\u201315.\n\u2022 fast, convenient online submission\n\u2022 thorough peer review by experienced researchers in your field\n\u2022 rapid publication on acceptance\n\u2022 support for research data, including large and complex data types\n\u2022 gold Open Access which fosters wider collaboration and increased citations\nmaximum visibility for your research: over 100M website views per year \u2022\nAt BMC, research is always in progress.\nLearn more biomedcentral.com/submissions\nReady to submit your research ? Choose BMC and benefit from:\n46. Quadrini M, Tesei L, Merelli E. An algebraic language for RNA pseudoknots comparison. BMC Bioinform. 2019;20(4):1\u201318. 47. Berkemer SJ, Siederdissen C, Stadler PF. Algebraic dynamic programming on trees. Algorithms. 2017;10(4):135. 48. Dirks RM, Bois JS, Schaeffer JM, Winfree E, Pierce NA. Thermodynamic analysis of interacting nucleic acid strands. SIAM Rev. 2007;49(1):65\u201388."
        },
        {
            "heading": "Publisher\u2019s Note",
            "text": "Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations."
        }
    ],
    "title": "Automated design of dynamic programming schemes for RNA folding with pseudoknots",
    "year": 2023
}