{
    "abstractText": "This paper presents a tree-to-tree transduction method for text rewriting. Our model is based on synchronous tree substitution grammar, a formalism that allows local distortion of the tree topology and can thus naturally capture structural mismatches. We describe an algorithm for decoding in this framework and show how the model can be trained discriminatively within a large margin framework. Experimental results on sentence compression bring significant improvements over a state-of-the-art model.",
    "authors": [
        {
            "affiliations": [],
            "name": "Trevor Cohn"
        },
        {
            "affiliations": [],
            "name": "Mirella Lapata"
        }
    ],
    "id": "SP:db64cdfafed833e2df598cc9346015f66fc05a7e",
    "references": [
        {
            "authors": [
                "R. Barzilay",
                "K. McKeown."
            ],
            "title": "Extracting paraphrases from a parallel corpus",
            "venue": "Proceedings of ACL/EACL, 50\u201357, Toulouse, France.",
            "year": 2001
        },
        {
            "authors": [
                "D. Bikel."
            ],
            "title": "Design of a multi-lingual, parallelprocessing statistical parsing engine",
            "venue": "Proceedings of HLT, 24\u201327, San Diego, CA.",
            "year": 2002
        },
        {
            "authors": [
                "J. Carroll",
                "G. Minnen",
                "D. Pearce",
                "Y. Canning",
                "S. Devlin",
                "J. Tait."
            ],
            "title": "Simplifying text for language impaired readers",
            "venue": "Proceedings of EACL, 269\u2013270, Bergen, Norway.",
            "year": 1999
        },
        {
            "authors": [
                "D. Chiang."
            ],
            "title": "A hierarchical phrase-based model for statistical machine translation",
            "venue": "Proceedings of the 43rd ACL, 263\u2013270, Ann Arbor, MI.",
            "year": 2005
        },
        {
            "authors": [
                "J. Clarke",
                "M. Lapata."
            ],
            "title": "Constraint-based sentence compression: An integer programming approach",
            "venue": "Proceedings of COLING/ACL Main Conference Poster Sessions, 144\u2013151, Sydney, Australia.",
            "year": 2006
        },
        {
            "authors": [
                "J. Clarke",
                "M. Lapata."
            ],
            "title": "Models for sentence compression: A comparison across domains, training requirements and evaluation measures",
            "venue": "Proceedings of COLING/ACL, 377\u2013384, Sydney, Australia.",
            "year": 2006
        },
        {
            "authors": [
                "J. Clarke",
                "M. Lapata."
            ],
            "title": "Modelling compression with discourse constraints",
            "venue": "Proceedings of EMNLPCoNLL, Prague, Czech Republic.",
            "year": 2007
        },
        {
            "authors": [
                "J. Eisner."
            ],
            "title": "Learning non-isomorphic tree mappings for machine translation",
            "venue": "Proceedings of the ACL Interactive Poster/Demonstration Sessions, 205\u2013208, Sapporo, Japan.",
            "year": 2003
        },
        {
            "authors": [
                "M. Galley",
                "K. McKeown."
            ],
            "title": "Lexicalized Markov grammars for sentence compression",
            "venue": "Proceedings of NAACL/HLT, 180\u2013187, Rochester, NY.",
            "year": 2007
        },
        {
            "authors": [
                "J. Grael",
                "K. Knight."
            ],
            "title": "Training tree transducers",
            "venue": "Proceedings of NAACL/HLT, 105\u2013112, Boston, MA.",
            "year": 2004
        },
        {
            "authors": [
                "C. Hori",
                "S. Furui."
            ],
            "title": "Speech summarization: an approach through word extraction and a method for evaluation",
            "venue": "IEICE Transactions on Information and Systems, E87-D(1):15\u201325.",
            "year": 2004
        },
        {
            "authors": [
                "H. Jing."
            ],
            "title": "Sentence reduction for automatic text summarization",
            "venue": "Proceedings of ANLP, 310\u2013315, Seattle, WA.",
            "year": 2000
        },
        {
            "authors": [
                "T. Joachims."
            ],
            "title": "A support vector method for multivariate performance measures",
            "venue": "Proceedings of ICML, 377\u2013384, Bonn, Germany.",
            "year": 2005
        },
        {
            "authors": [
                "K. Knight",
                "D. Marcu."
            ],
            "title": "Summarization beyond sentence extraction: a probabilistic approach to sentence compression",
            "venue": "Artificial Intelligence, 139(1):91\u2013107.",
            "year": 2002
        },
        {
            "authors": [
                "P. Koehn",
                "F.J. Och",
                "D. Marcu."
            ],
            "title": "Statistical phrasebased translation",
            "venue": "Proceedings of HLT/NAACL, 48\u2013 54, Edmonton, Canada.",
            "year": 2003
        },
        {
            "authors": [
                "D. Lin",
                "P. Pantel."
            ],
            "title": "Discovery of inference rules for question answering",
            "venue": "Natural Language Engineering, 7(4):342\u2013360.",
            "year": 2001
        },
        {
            "authors": [
                "R. McDonald."
            ],
            "title": "Discriminative sentence compression with soft syntactic constraints",
            "venue": "Proceedings of EACL, 297\u2013304, Trento, Italy.",
            "year": 2006
        },
        {
            "authors": [
                "I.D. Melamed."
            ],
            "title": "Statistical machine translation by parsing",
            "venue": "Proceedings of ACL, 653\u2013660, Barcelona, Spain.",
            "year": 2004
        },
        {
            "authors": [
                "F.J. Och",
                "H. Ney."
            ],
            "title": "The alignment template approach to statistical machine translation",
            "venue": "Computational Linguistics, 30(4):417\u2013449.",
            "year": 2004
        },
        {
            "authors": [
                "F.J. Och",
                "C. Tillmann",
                "H. Ney."
            ],
            "title": "Improved alignment models for statistical machine translation",
            "venue": "Proceedings of EMNLP/VLC, 20\u201328, College Park, MD.",
            "year": 1999
        },
        {
            "authors": [
                "B. Pang",
                "K. Knight",
                "D. Marcu."
            ],
            "title": "Syntax-based alignment of multiple translations: Extracting paraphrases and generating new sentences",
            "venue": "Proceedings of NAACL, 181\u2013188, Edmonton, Canada.",
            "year": 2003
        },
        {
            "authors": [
                "K. Papineni",
                "S. Roukos",
                "T. Ward",
                "W.-J. Zhu."
            ],
            "title": "BLEU: a method for automatic evaluation of machine translation",
            "venue": "Proceedings of ACL, 311\u2013318, Philadelphia, PA.",
            "year": 2002
        },
        {
            "authors": [
                "C. Quirk",
                "C. Brockett",
                "W. Dolan."
            ],
            "title": "Monolingual machine translation for paraphrase generation",
            "venue": "Proceedings of EMNLP, 142\u2013149, Barcelona, Spain.",
            "year": 2004
        },
        {
            "authors": [
                "S. Riezler",
                "T.H. King",
                "R. Crouch",
                "A. Zaenen."
            ],
            "title": "Statistical sentence condensation using ambiguity packing and stochastic disambiguation methods for lexicalfunctional grammar",
            "venue": "Proceedings of HLT/NAACL, 118\u2013125, Edmonton, Canada.",
            "year": 2003
        },
        {
            "authors": [
                "Y. Shinyama",
                "S. Sekine",
                "K. Sudo",
                "R. Grishman."
            ],
            "title": "Automatic paraphrase acquisition from news articles",
            "venue": "Proceedings of HLT, 40\u201346, San Diego, CA.",
            "year": 2002
        },
        {
            "authors": [
                "I. Tsochantaridis",
                "T. Joachims",
                "T. Hofmann",
                "Y. Altun."
            ],
            "title": "Large margin methods for structured and interdependent output variables",
            "venue": "Journal of Machine Learning Research, 6:1453\u20131484.",
            "year": 2005
        },
        {
            "authors": [
                "J. Turner",
                "E. Charniak."
            ],
            "title": "Supervised and unsupervised learning for sentence compression",
            "venue": "Proceedings of ACL, 290\u2013297, Ann Arbor, MI.",
            "year": 2005
        },
        {
            "authors": [
                "L.S. Zettlemoyer",
                "M. Collins."
            ],
            "title": "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars",
            "venue": "Proceedings of UAI, 825\u2013830, Edinburgh, UK.",
            "year": 2005
        }
    ],
    "sections": [
        {
            "text": "Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pp. 73\u201382, Prague, June 2007. c\u00a92007 Association for Computational Linguistics"
        },
        {
            "heading": "1 Introduction",
            "text": "Recent years have witnessed increasing interest in text-to-text generation methods for many natural language processing applications ranging from text summarisation to question answering and machine translation. At the heart of these methods lies the ability to perform rewriting operations according to a set of prespecified constraints. For example, text simplification identifies which phrases or sentences in a document will pose reading difficulty for a given user and substitutes them with simpler alternatives (Carroll et al., 1999). Sentence compression produces a summary of a single sentence that retains the most important information while remaining grammatical (Jing, 2000).\nIdeally, we would like a text-to-text rewriting system that is not application specific. Given a parallel corpus of training examples, we should be able to learn rewrite rules and how to combine them in order to generate new text. A great deal of previous work has focused on the rule induction problem (Barzilay\nand McKeown, 2001; Pang et al., 2003; Lin and Pantel, 2001; Shinyama et al., 2002), whereas relatively little emphasis has been placed on the actual generation task (Quirk et al., 2004). A notable exception is sentence compression for which end-to-end rewriting systems are commonly developed (Knight and Marcu, 2002; Turner and Charniak, 2005; Galley and McKeown, 2007; Riezler et al., 2003; McDonald, 2006). The appeal of this task lies in its simplified formulation as a single rewrite operation, namely word deletion (Knight and Marcu, 2002).\nSolutions to the compression task have been cast mostly in a supervised learning setting (but see Clarke and Lapata (2006a), Hori and Furui (2004), and Turner and Charniak (2005) for unsupervised methods). Rewrite rules are learnt from a parsed parallel corpus and subsequently used to find the best compression from the set of all possible compressions for a given sentence. A common assumption is that the tree structures representing long sentences and their compressions are isomorphic. Consequently, the models are not generally applicable to other text rewriting problems since they cannot readily handle structural mismatches and more complex rewriting operations such as substitutions or insertions. A related issue is that the tree structure of the compressed sentences is often poor; most algorithms delete words or constituents without paying too much attention to the structure of the compressed sentence. However, without an explicit generation mechanism that allows tree transformations, there is no guarantee that the compressions will have well-formed syntactic structures. And it will not be easy to process them for subsequent generation or analysis tasks.\nIn this paper we present a text-to-text rewriting\n73\nmodel that scales to non-isomorphic cases and can thus naturally account for structural and lexical divergences. Our approach is inspired by synchronous tree substitution grammar (STSG, Eisner (2003)) a formalism that allows local distortion of the tree topology. We show how such a grammar can be induced from a parallel corpus and propose a large margin model for the rewriting task which can be viewed as a weighted tree-to-tree transducer. Our learning framework makes use of the algorithm put forward by Tsochantaridis et al. (2005) which efficiently learns a prediction function to minimise a given loss function. Experiments on sentence compression show significant improvements over the state-of-the-art. Beyond sentence compression and related text-to-text generation problems (e.g., paraphrasing), our model is generally applicable to tasks involving structural mapping. Examples include machine translation (Eisner, 2003) or semantic parsing (Zettlemoyer and Collins, 2005)."
        },
        {
            "heading": "2 Related Work",
            "text": "Knight and Marcu (2002) proposed a noisy-channel formulation of sentence compression based on synchronous context-free grammar (SCFG). The latter is a generalisation of the context-free grammar (CFG) formalism to simultaneously produce strings in two languages. In the case of sentence compression, the grammar rules have two right hand sides, one corresponding to the source (long) sentence and the other to its target compression. The synchronous derivations are learnt from a parallel corpus and their probabilities are estimated generatively.\nGiven a long sentence, l, the aim is to find the corresponding compressed sentence, s, which maximises P(s)P(l|s) (here P(s) is the source model and P(l|s) the channel model.) Modifications of this model are reported in Turner and Charniak (2005) and Galley and McKeown (2007) with improved results. The channel model is limited to tree deletion and does not allow any type of tree re-organisation.\nNon-isomorphic tree structures are common when translating between languages. It is therefore not surprising that most previous work on tree rewriting falls within the realm of machine translation. Proposals include Eisner\u2019s (2003) synchronous tree substitution grammar (STSG), Melamed\u2019s (2004)\nmultitext grammar, and Graehl and Knight\u2019s (2004) tree-to-tree transducers. Despite differences in formalism, all these approaches model the translation process using tree-based probabilistic transduction rules. The grammar induction process requires EM training which can be computationally expensive especially if all synchronous rules are considered.\nOur work formulates sentence compression in the framework of STSG (Eisner, 2003). We propose a novel grammar induction algorithm that does not require EM training and is coupled with a separate large margin training process (Tsochantaridis et al., 2005) for weighting each rule. McDonald (2006) also presents a sentence compression model that uses a discriminative large margin algorithm. However, we differ in two important respects. First, our generation algorithm is more powerful, performing complex tree transformations, whereas McDonald only considers simple word deletion. Being treebased, the generation algorithm is better able to preserve the grammaticality of the compressed output. Second, our model can be tuned to a wider range of loss functions (e.g.,tree-based measures)."
        },
        {
            "heading": "3 Problem Formulation",
            "text": "We formulate sentence compression as an instance of the general problem of learning a mapping from input patterns x \u2208 X to discrete structured objects y \u2208 Y . Our training sample consists of a parallel corpus of input (uncompressed) and output (compressed) pairs (x1,y1) . . .(xn,yn) \u2208 X \u00d7 Y and our task is to predict a target labelled tree y from a source labelled tree x. As we describe below, y is not precisely a target tree, but instead derivations which generate both the source and the target tree. We model the dependency between x and y as a weighted STSG. Grammar rules are of the form \u3008X ,Y \u3009 \u2192 \u3008\u03b3,\u03b1,\u03b2\u3009 where \u03b3 and \u03b1 are elementary trees composed of a mixture of terminal and nonterminals rooted with non-terminals X and Y respectively, and \u03b2 is a set of variable correspondences between pairs of frontier non-terminals in \u03b3 and \u03b1. A grammar rule specifies that we can substitute the trees \u03b3 and \u03b1 for corresponding X and Y nodes in the source and target trees respectively. For example, the rule:\n\u3008NP, NP\u3009 \u2192 \u3008[DT 1 ADJP NN 2 ]NP, [DT 1 NN 2 ]NP\u3009\nallows adjective phrases to be dropped from the source tree within an NP. The indices x are used to specify the variable correspondences, \u03b2.\nEach grammar rule has a score from which the overall score of a compression y for sentence x can be derived. These scores are learnt discriminatively using the large margin technique proposed by Tsochantaridis et al. (2005). The synchronous rules are combined using a chart-based parsing algorithm (Eisner, 2003) to generate the derivation (i.e., compressed tree) with the highest score.\nWe begin by describing our STSG generation algorithm in Section 3.1. We next explain how a synchronous grammar is induced from a parallel corpus of original sentences and their compressions (Section 3.2) and give the details of our learning framework (Section 3.3)."
        },
        {
            "heading": "3.1 Generation",
            "text": "Generation aims to find the best target tree for a given source tree using the transformations specified by the synchronous grammar. (We discuss how we obtain this grammar in the following section.)\ny\u2217 =max y\u2208Y score(x,y;w) (1)\nwhere y ranges over all target derivations (and therefore trees), w is a parameter vector and score(\u00b7) is an objective function measuring the quality of the derivation. In common with many parsing methods, we encounter a problem with spurious ambiguity: i.e., there may be many derivations (sequences of rule applications) which produce the same target tree. Ideally we would sum up the scores over all these derivations, however for the sake of tractability we instead take the maximum score. This allows us to pose the maximisation problem over derivations rather than target trees.\nThe generation algorithm uses a dynamic program defined over the constituents in the source tree as shown in Figure 1 (see also Eisner (2003)). The algorithm makes the assumption that the scoring function decomposes with the derivation, such that a partial score can be evaluated at each step, i.e., score(x,y;w) = \u2211r\u2208y score(r;w) where r are the rules used in the derivation. This method builds a chart of the best scoring partial derivation for each source subtree headed by a given target nonterminal. The inductive step is applied recursively\nbottom-up, and involves applying a grammar rule to a node in the source tree. Rules with substitution variables in their frontier are scored with reference to the chart for the matching nodes and target nonterminal categories. Once the process is complete, we can read the best score from the chart cell for the root node, and the best derivation can be constructed by traversing back-pointers also stored in the chart. This is illustrated in Figure 2 where the rule \u3008V P,V P\u3009\u2192 \u3008[[isAUX ADJP 1 ]V P CC V P]V P, [isAUX NP 1 ]V P\u3009 is applied to the top V P node. The score of the resulting tree would reference the chart to calculate the score for the best target tree at the ADJP node with syntactic category NP."
        },
        {
            "heading": "3.2 Grammar Induction",
            "text": "Our induction algorithm automatically finds grammar rules from a word-aligned parsed parallel corpus. The rules are pairs of elementary trees (i.e., tree fragments) whose leaf nodes are linked by the word alignments. These leaves can be either terminal or non-terminal symbols. Initially, the algorithm ex-\ntracts tree pairs from word aligned text by choosing aligned constituents in the source and the target. These pairs are then generalised using subtrees which are also extracted, resulting in synchronous rules with variable nodes. The set of aligned tree pairs are extracted using the alignment template method (Och and Ney, 2004), constrained to syntactic constituent pairs:\nC = {(nS,nT ), (\u2203(s, t) \u2208 A \u2227 s \u2208 Y (nS)\u2227 t \u2208 Y (nT ))\u2227 (@(s, t) \u2208 A \u2227 (s \u2208 Y (nS)Y t \u2208 Y (nT )))}\nwhere nS and nT are source and target tree nodes (subtrees), A = {(s, t)} is the set of word alignments (pairs of word-indices), Y (\u00b7) returns the yield span for a subtree and Y is the exclusive-or operator.\nThe next step is to generalise the candidate pairs by replacing subtrees with variable nodes. We could fully trust the word alignments and adopt a strategy in which the rules are generalised as much as possible and thus include little lexicalisation. Figure 3 shows a simple sentence pair and the resulting synchronous rules according to this generalisation strategy. Alternatively, we could extract every possible rule by including unlexicalised rules, lexicalised rules and their combination. The downside here is that the total number of possible rules is factorial in the size of the candidate set. We address this problem by limiting the number of variables and the recursion depth, and by filtering out singleton rules.\nThere is no guarantee that the induced rules will generalise well to a testing set. For example, the testing data may have a rule which was not seen in the training set (e.g., a new terminal or non terminal). In this case no rule can be applied and subsequently generation fails. For this reason we allow the model to duplicate any CFG production from the source tree, and uses a feature to flag that this rule was unseen in training. These SCFG rules are then merged with the induced rules and fed into the feature detection module (see Section 3.3 for details)."
        },
        {
            "heading": "3.3 The Large Margin Model",
            "text": "We now describe how the parameters of our STSG generation system are fit to a supervised training set. For a given source tree, the space of sister target trees implied by the synchronous grammar is often very large, and the majority of these trees are un-\ngrammatical or are poor compressions. The training procedure learns weights such that the model can discriminate between these trees and predict a good target tree. For this we develop a discriminative training process which learns a weighted tree-to-tree transducer. Our model is based on Tsochantaridis et al.\u2019s (2005) framework for learning Support Vector Machines (SVMs) with structured output spaces, using the SVMstruct implementation.1 We briefly summarise the approach below; for a more detailed description we refer the interested reader to Tsochantaridis et al. (2005).\nTraditionally SVMs learn a linear classifier that separates two or more classes with the largest possible margin. Analogously, structured SVMs attempt to separate the correct structure from all other\n1http://svmlight.joachims.org/svm struct.html\nstructures with a large margin. Given an input instance x, we search for the optimum output y under the assumption that x and y can be adequately described using a combined feature vector representation \u03a8(x,y). Recall that x are the source trees and y are synchronous derivations which generate both x and a target tree.\nf (x;w) = argmax y\u2208Y \u3008w,\u03a8(x,y)\u3009 (2)\nThe goal of the training procedure is to find a parameter vector w such that it satisfies the condition:\n\u2200i,\u2200y \u2208 Y \\yi : \u3008w,\u03a8(xi,yi)\u2212\u03a8(xi,y)\u3009 \u2265 0 (3)\nwhere xi,yi are the ith training source tree and target derivation. To obtain a unique solution \u2014 there will be several parameter vectors w satisfying (3) if the training instances are linearly separable \u2014 Tsochantaridis et al. (2005) select the w that maximises the minimum distance between yi and the closest runner-up structure.\nThe framework also incorporates a loss function. This property is particularly appealing in the context of sentence compression and generally text-to-text generation. For example, a compression that differs from the gold standard with respect to one or two words should be treated differently from a compression that bears no resemblance to it. Another important factor is the length of the compression. Compressions whose length is similar to the gold standard should be be preferable to longer or shorter output. A loss function \u2206(yi,y) quantifies the accuracy of prediction y with respect to the true output value yi. We give details of the loss functions we employed for the compression task below.\nWe are now ready to state the learning objective for the structured SVM. We use the soft-margin formulation which allows errors in the training set, via the slack variables \u03bei:\nmin w,\u03be 1 2 ||w||2 + C n\nn\n\u2211 i=1 \u03bei, \u03bei \u2265 0 (4)\n\u2200i,\u2200y \u2208 Y \\yi : \u3008w,\u03b4\u03a8(y)\u3009 \u2265 1\u2212 \u03bei\n\u2206(yi,y)\nSlack variables \u03bei are introduced here for each training example xi, C is a constant that controls the trade-off between training error minimisation and\nmargin maximisation, and \u03b4\u03a8(y) is a shorthand for \u03a8(xi,yi)\u2212\u03a8(xi,y) (see (3)). Note that slack variables are rescaled with the inverse loss incurred in each of the linear constraints.2\nThe optimisation problem in (4) is approximated using a polynomial time cutting plane algorithm (Tsochantaridis et al., 2005). This optimisation crucially relies on finding the constraint incurring the maximum cost. The cost function for slack rescaling can be formulated as:\nH(y) = (1\u2212\u3008\u03b4\u03a8i(y),w\u3009)\u2206(yi,y) (5)\nIn order to adapt this framework to our generation problem, we must provide the feature mapping \u03a8(x,y), a loss function \u2206(yi,y), and a maximiser y\u0302 = argmaxy\u2208Y H(y) (see (5)). The following sections describe how these are instantiated in the sentence compression task.\nFeature Mapping We devised a general feature set suitable for compression and paraphrasing. Our feature space is defined over source trees (x) and target derivations (y). All features apply to a single grammar rule; a feature vector for a derivation is expressed as the sum of the feature vectors for each rule in this derivation.\nWe make use of syntactic, lexical, and compression specific features. Our simplest syntactic feature is the identity of a synchronous rule. Specifically, we record its source tree, its target tree and their combination. We also include rule frequencies \u03c6(target|source), \u03c6(source|target) and \u03c6(source, target). Another feature records the frequencies of the CFG productions used in the target side of a rule. This allows the model to learn the weights of a CFG generation grammar, as a proxy for a language model. Using scores from a pre-trained CFG grammar or an n-gram language model might be preferable when the training sample is small, however we leave this as future work. Our last syntactic feature keeps track of the source root and the target root non-terminals. Our lexical features contain the list of tokens in the source yield, target yield, and both. We also use words as features.\n2Alternatively, the loss function can be used to rescale the margin. This approach is less desirable as it is not scale invariant (Tsochantaridis et al., 2005). We also found empirically that slack-rescaling slightly outperforms margin rescaling on our compression task.\nFinally, we have implemented a set of compression-specific features. These include a feature that detects if the yield of the target side of a synchronous rule is a subset of the yield of its source. We also take note of the edit operations (i.e., removal, insertion) required to transform the source side into the target. Edit operations are recorded separately for trees and their yields. In order to encourage compression, we also count the number of words on the target, the number of rules used in the derivation and the number of dropped variables.\nLoss Functions The large margin configuration sketched above is quite modular and in theory a wide range of loss functions could be specified. Examples include edit-distance, precision, F-score, BLEU and tree-based measures. In practice, the loss function should be compatible with our maximisation algorithm which requires the objective function to decompose along the same lines as the tree derivation.3\nGiven this restriction, we define a loss based on position-independent unigram precision (Prec) which penalises errors in the yield independently for each word. Although fairly intuitive, this loss is far from ideal. First, it maximally rewards repeatedly predicting the same word if the latter is in the reference target tree. Secondly, it may bias towards overly short output which drops core information \u2014 one-word compressions will tend to have higher precision than longer output. To counteract this, we introduce two brevity penalty measures (BP) inspired by BLEU (Papineni et al., 2002) which we incorporate into the loss function, using a product, loss = 1\u2212Prec \u00b7BP:\nBP1 = exp(1\u2212max(1, r c )) (6) BP2 = exp(1\u2212max(c r , r c ))\nwhere r is the reference length and c is the candidate length.\nBP1 is asymmetric, it has value one when c \u2265 r and decays to zero when c < r. Note that precision should decay when c > r as extra output will often not match the reference. BP2 is two-sided: it has\n3Optimising non-decompositional loss functions complicates the objective function, which then cannot be solved efficiently using a dynamic program.\nvalue one when c = r and decays towards zero for c < r and c > r. In both cases, brevity is assessed against the gold standard target (not the source) to allow the system to learn the correct degree of compression from the training data.\nMaximisation Algorithm Our algorithm finds the maximising derivation for H(y) in (5). This derivation will have a high loss and a high score under the model, and therefore represents the most-violated constraint which is then added to the SVM\u2019s working set of constraints (see (4)).\nThe standard generation method from Section 3.1 cannot be used without modification to find the best scoring derivation since it does not account for the loss function or the gold standard derivation. Instead, we stratify the generation chart with the number of true and false positive tokens predicted, as described in Joachims (2005). These contingency values allow us to compute the precision and brevity penalty (see (6)) for each complete derivation. This is then combined with the derivation score and the gold standard derivation score to give H(y).\nThe gold standard derivation features, \u03a8(xi,yi), must be calculated from a derivation linking the source tree to the gold target tree. As there may be many such derivations, we find a unique derivation using the smallest rules possible (for maximum generality). This is done using a dynamic program, similar to the inside-outside algorithm used in parsing. Other strategies are also possible, however we leave this to future work. Finally, we can find the global maximum H(y) by maximising over all the root chart entries."
        },
        {
            "heading": "4 Evaluation Set-up",
            "text": "In this section we present our experimental set-up for assessing the performance of the max margin model described above. We give details of the corpora used, briefly introduce McDonald\u2019s (2006) sentence compression model used for comparison with our approach, and explain how system output was evaluated.\nCorpora We evaluated our system on two different corpora. The first is the compression corpus of Knight and Marcu (2002) derived automatically from the document-abstract pairs of the Ziff-\nDavis corpus. Previous compression work has almost exclusively used this corpus. Our experiments follow Knight and Marcu\u2019s partition of training, test, and development sets (1,002/36/12 instances). We also present results on Clarke and Lapata\u2019s (2006a) Broadcast News corpus.4 This corpus was created manually (annotators were asked to produce compressions for 50 Broadcast news stories) and poses more of a challenge than Ziff-Davis. Being a speech corpus, it often contains incomplete and ungrammatical utterances and speech artefacts such as disfluencies, false starts and hesitations. Furthermore, spoken utterances have varying lengths, some are very wordy whereas others cannot be reduced any further. Thus a hypothetical compression system trained on this domain should be able to leave some sentences uncompressed. Again we used Clarke and Lapata\u2019s training, test, and development set split (882/410/78 instances).\nComparison with State-of-the-art We evaluated our approach against McDonald\u2019s (2006) discriminative model. This model is a good basis for comparison for several reasons. First, it achieves competitive performance with Knight and Marcu\u2019s (2002) decision tree and noisy channel models. Second, it also uses large margin learning. Sentence compression is formulated as a string-to-substring mapping problem with a deletion-based Hamming loss. Recall that our formulation involves a tree-to-tree mapping. Third, it uses a feature space complementary to ours. For example features are defined between adjacent words, and syntactic evidence is incorporated indirectly into the model. In contrast our model relies on synchronous rules to generate valid compressions and does not explicitly incorporate adjacency features. We used an implementation of McDonald (2006) for comparison of results (Clarke and Lapata, 2007).\nEvaluation Measures In line with previous work we assessed our model\u2019s output by eliciting human judgements. Participants were presented with an original sentence and its compression and asked to rate the latter on a five point scale based on the information retained and its grammaticality. We conducted two separate elicitation studies, one for the\n4The corpus can be downloaded from http://homepages. inf.ed.ac.uk/s0460084/data/.\nZiff-Davis and one for the Broadcast news dataset. In both cases our materials consisted of 96 sourcetarget sentences. These included gold standard compressions and the output of our system and McDonald\u2019s (2006). We were able to obtain ratings on the entire Ziff-Davis test set as it has only 32 instances; this was not possible for Broadcast news as the test section consists of 410 instances. Consequently, we randomly selected 32 source-target sentences to match the size of the Ziff-Davis test set.5 We collected ratings from 60 unpaid volunteers, all self reported native English speakers. Both studies were conducted over the Internet. Examples of our experimental items are given in Table 1.\nWe also report results using F1 computed over grammatical relations (Riezler et al., 2003). We chose F1 (as opposed to accuracy or edit distancebased measures) as Clarke and Lapata (2006b) show that it correlates reliably with human judgements."
        },
        {
            "heading": "5 Experiments",
            "text": "The framework presented in Section 3 is quite flexible. Depending on the grammar induction strategy, choice of features, loss function and maximisation algorithm, different classes of models can be derived. Before presenting our results in detail we discuss the specific model employed in our experiments and explain how its parameters were instantiated.\nIn order to build a compression model we need\n5A Latin square design ensured that subjects did not see two different compressions of the same sentence.\na parallel corpus of syntax trees. We obtained syntactic analyses for source and target sentences with Bikel\u2019s (2002) parser. Our corpora were automatically aligned with Giza++ (Och et al., 1999) in both directions between source and target and symmetrised using the intersection heuristic (Koehn et al., 2003). Each word in the lexicon was also aligned with itself. This was necessary in order to inform Giza++ about word identity. Unparseable sentences and those longer than 50 tokens were removed from the data set.\nWe induced a synchronous tree substitution grammar from the Ziff-Davis and Broadcast news corpora using the method described in Section 3.2. We extracted all maximally general synchronous rules. These were complemented with more specific rules from conjoining pairs of general rules. The specific rules were pruned to remove singletons and those rules with more than 3 variables. Grammar rules were represented by the features described in Section 3.3.\nAn important parameter for our compression task is the appropriate choice of loss function. Ideally, we would like a loss function that encourages compression without overly aggressive information loss. Figure 4 plots compression rate against grammatical relations F1 using each of the loss functions presented in Section 3.3 on the Ziff-Davis development set.6 As can be seen with unigram precision alone (Prec)\n6We obtained a similar plot for the Broadcast News corpus but omit it due to lack of space.\nthe system produces overly short output, whereas the one-sided brevity penalty (BP1) achieves the opposite effect. The two-sided brevity penalty (BP2) seems to strike the right balance: it encourages compression while achieving good F-scores. This suggests that important information is retained in spite of significant compression. We also varied the regularisation parameter C (see (4)) over a range of values on the development set and found that setting it to 0.01 yields overall good performance across corpora and loss functions.\nWe now present our results on the test set. These were obtained with a model that uses slack rescaling and a precision-based loss function with a twosided brevity penalty (C = 0.01). Table 2 shows the average compression rates (CompR) for McDonald (2006) and our model (STSG) as well as their performance according to grammatical relations F1. The row \u2018Gold standard\u2019 displays human-produced compression rates. Notice that our model obtains compression rates similar to the gold standard, whereas McDonald tends to compress less on Ziff-Davis and more on Broadcast news. As far as F1 is concerned, we see that STSG outperforms McDonald on both corpora. The difference in F1 is statistically significant on Broadcast news but not on Ziff-Davis (which consists solely of 32 sentences).\nTable 3 presents the results of our elicitation study. We carried out an Analysis of Variance (ANOVA) to examine the effect of system type (McDonald06, STSG, Gold standard) on the compression ratings. The ANOVA revealed a reliable effect on both corpora. We used post-hoc Tukey tests to\nexamine whether the mean ratings for each system differed significantly. The Tukey tests showed that STSG is perceived as significantly better than McDonald06. There is no significant difference between STSG and the gold standard compressions on the Broadcast news; both systems are significantly worse than the gold standard on Ziff-Davis.\nThese results are encouraging, indicating that our highly expressive framework is a good model for sentence compression. Under several experimental conditions we obtain better performance than previous work. Importantly, the model described here is not compression-specific, it could be easily adapted to other tasks, corpora or languages (for which syntactic analysis tools are available). Being supervised, our model learns to fit the compression rate of the training data. In this sense, it is somewhat inflexible as it cannot easily adapt to a specific rate given by a user or imposed by an application (e.g., when displaying text on small screens). Compression rate can be indirectly manipulated by adopting loss functions that encourage or discourage compression (see Figure 4), but admittedly in other frameworks (e.g., Clarke and Lapata (2006a)) the length of the compression can be influenced more naturally.\nIn our formulation of the compression problem, a derivation is characterised by a single inventory of features. This entails that the feature space cannot in principle distinguish between derivations that use the same rules, applied in a different order. Although, this situation does not arise often in our dataset, we believe that it can be ameliorated by intersecting a language model with our generation algorithm (Chiang, 2005)."
        },
        {
            "heading": "6 Conclusions and Future Work",
            "text": "In this paper we have presented a novel method for sentence compression cast in the framework of structured learning. We develop a system that generates compressions using a synchronous tree substitution grammar whose weights are discriminatively trained within a large margin model. We also describe an appropriate algorithm than can be used in both training (i.e., learning the model weights) and decoding (i.e., finding the most plausible compression under the model). The proposed formulation allows us to capture rewriting operations that go beyond word deletion and can be easily tuned to specific loss functions directly related to the problem at hand. We empirically evaluate our approach against a state-of-the art model (McDonald, 2006) and show performance gains on two compression corpora.\nFuture research will follow three directions. First, we will extend the framework to incorporate position dependent loss functions. Examples include the Hamming distance or more sophisticated functions that take the tree structure of the source and target sentences into account. Such functions can be supported by augmenting our generation algorithm with a beam search. Secondly, the present paper used a relatively simple feature set. Our intention was to examine our model\u2019s performance without extensive feature engineering. Nevertheless, improvements should be possible by incorporating features defined over n-grams and dependencies (McDonald, 2006). Finally, the experiments presented in this work use a grammar acquired from the training corpus. However, there is nothing inherent in our formalisation that restricts us to this particular grammar. We therefore plan to investigate the potential of our method with unsupervised or semi-supervised grammar induction techniques for additional rewriting tasks including paraphrase generation and machine translation.\nAcknowledgements The authors acknowledge the support of EPSRC (grants GR/T04540/01 and GR/T04557/01).\nWe are grateful to James Clarke for sharing his implementation\nof McDonald (2006) with us. Special thanks to Philip Blunsom\nfor insightful comments and suggestions."
        }
    ],
    "title": "Large Margin Synchronous Generation and its Application to Sentence Compression",
    "year": 2007
}