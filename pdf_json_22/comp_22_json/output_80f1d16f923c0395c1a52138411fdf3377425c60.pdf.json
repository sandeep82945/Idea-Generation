{
    "abstractText": "We study principles and models for reasoning inductively about properties of distributed systems, based on programmed atomic handlers equipped with contracts. We present the Why3-do library, leveraging a state of the art software verifier for reasoning about distributed systems based on our models. A number of examples involving invariants containing existential and nested quantifiers (including Dijsktra\u2019s selfstabilizing systems) illustrate how the library promotes contract-based modular development, abstraction barriers, and automated proofs.",
    "authors": [
        {
            "affiliations": [],
            "name": "Cl\u00e1udio Belo Louren\u00e7o"
        },
        {
            "affiliations": [],
            "name": "Jorge Sousa Pinto"
        }
    ],
    "id": "SP:f2891b59d672c5b441166ca63ab1b248ac433b78",
    "references": [
        {
            "authors": [
                "M. Abadi",
                "L. Lamport"
            ],
            "title": "The existence of refinement mappings",
            "venue": "Theoretical Computer Science 82(2), 253\u2013284",
            "year": 1991
        },
        {
            "authors": [
                "K. Altisen",
                "P. Corbineau",
                "S. Devismes"
            ],
            "title": "A framework for certified selfstabilization",
            "venue": "Albert, E., Lanese, I. (eds.) Formal Techniques for Distributed Objects, Components, and Systems. pp. 36\u201351. Springer International Publishing, Cham",
            "year": 2016
        },
        {
            "authors": [
                "C. Baier",
                "J.P. Katoen"
            ],
            "title": "Principles of Model Checking",
            "venue": "The MIT Press",
            "year": 2008
        },
        {
            "authors": [
                "C. Barrett",
                "C.L. Conway",
                "M. Deters",
                "L. Hadarean",
                "D. Jovanovi\u0107",
                "T. King",
                "A. Reynolds",
                "C. Tinelli"
            ],
            "title": "CVC4",
            "venue": "Gopalakrishnan, G., Qadeer, S. (eds.) Computer Aided Verification. pp. 171\u2013177. Springer Berlin Heidelberg, Berlin, Heidelberg",
            "year": 2011
        },
        {
            "authors": [
                "S. Brookes",
                "P.W. O\u2019Hearn"
            ],
            "title": "Concurrent separation logic",
            "venue": "ACM SIGLOG News 3(3), 47\u201365",
            "year": 2016
        },
        {
            "authors": [
                "E. Chang",
                "R. Roberts"
            ],
            "title": "An improved algorithm for decentralized extrema-finding in circular configurations of processes",
            "venue": "Commun. ACM 22(5), 281\u2013283",
            "year": 1979
        },
        {
            "authors": [
                "K. Chaudhuri",
                "D. Doligez",
                "L. Lamport",
                "S. Merz"
            ],
            "title": "Verifying safety properties with the TLA + proof system",
            "venue": "Giesl, J., H\u00e4hnle, R. (eds.) Automated Reasoning. pp. 142\u2013148. Springer Berlin Heidelberg, Berlin, Heidelberg",
            "year": 2010
        },
        {
            "authors": [
                "J. Chen",
                "F. Abujarad",
                "S. Kulkarni"
            ],
            "title": "Towards scalable model checking of selfstabilizing programs",
            "venue": "Journal of Parallel and Distributed Computing 73(4), 400\u2013 410",
            "year": 2013
        },
        {
            "authors": [
                "E.M. Clarke",
                "O. Grumberg",
                "D. Peled"
            ],
            "title": "Model checking",
            "venue": "MIT Press",
            "year": 2001
        },
        {
            "authors": [
                "S. Conchon",
                "A. Coquereau",
                "M. Iguernlala",
                "A. Mebsout"
            ],
            "title": "Alt-Ergo 2.2. In: SMT Workshop: International Workshop on Satisfiability Modulo Theories",
            "year": 2018
        },
        {
            "authors": [
                "D. Cousineau",
                "D. Doligez",
                "L. Lamport",
                "S. Merz",
                "D. Ricketts",
                "H. Vanzetto"
            ],
            "title": "TLA + proofs",
            "venue": "Giannakopoulou, D., M\u00e9ry, D. (eds.) FM 2012: Formal Methods. pp. 147\u2013154. Springer Berlin Heidelberg, Berlin, Heidelberg",
            "year": 2012
        },
        {
            "authors": [
                "P. Cuoq",
                "F. Kirchner",
                "N. Kosmatov",
                "V. Prevosto",
                "J. Signoles",
                "B. Yakobowski"
            ],
            "title": "Frama-C - A software analysis perspective",
            "venue": "Eleftherakis, G., Hinchey, M., Holcombe, M. (eds.) Software Engineering and Formal Methods - 10th International Conference, SEFM 2012, Thessaloniki, Greece, October 1-5, 2012. Proceedings. Lecture Notes in Computer Science, vol. 7504, pp. 233\u2013247. Springer",
            "year": 2012
        },
        {
            "authors": [
                "A. Desai",
                "A. Phanishayee",
                "S. Qadeer",
                "S.A. Seshia"
            ],
            "title": "Compositional programming and testing of dynamic distributed systems",
            "venue": "Proc. ACM Program. Lang. 2(OOPSLA)",
            "year": 2018
        },
        {
            "authors": [
                "E.W. Dijkstra"
            ],
            "title": "Self-stabilizing systems in spite of distributed control",
            "venue": "Commun. ACM 17(11), 643\u2013644",
            "year": 1974
        },
        {
            "authors": [
                "E.W. Dijkstra",
                "C.S. Scholten"
            ],
            "title": "Predicate calculus and program semantics",
            "venue": "Springer-Verlag New York, Inc., New York, NY, USA",
            "year": 1990
        },
        {
            "authors": [
                "J. Filli\u00e2tre"
            ],
            "title": "One logic to use them all",
            "venue": "Bonacina, M.P. (ed.) Automated Deduction - CADE-24 - 24th International Conference on Automated Deduction, Lake Placid, NY, USA, June 9-14, 2013. Proceedings. Lecture Notes in Computer Why3-do: The Way of Harmonious Distributed System Proofs 139 Science, vol. 7898, pp. 1\u201320. Springer",
            "year": 2013
        },
        {
            "authors": [
                "J.C. Filli\u00e2tre",
                "A. Paskevich"
            ],
            "title": "Why3 \u2014 where programs meet provers",
            "venue": "Felleisen, M., Gardner, P. (eds.) Proceedings of the 22nd European Symposium on Programming. Lecture Notes in Computer Science, vol. 7792, pp. 125\u2013128. Springer",
            "year": 2013
        },
        {
            "authors": [
                "P. Fonseca",
                "K. Zhang",
                "X. Wang",
                "A. Krishnamurthy"
            ],
            "title": "An empirical study on the correctness of formally verified distributed systems",
            "venue": "Proceedings of the Twelfth European Conference on Computer Systems. p. 328\u2013343. EuroSys\u201917, Association for Computing Machinery, New York, NY, USA",
            "year": 2017
        },
        {
            "authors": [
                "C. Hawblitzel",
                "J. Howell",
                "M. Kapritsos",
                "J.R. Lorch",
                "B. Parno",
                "M.L. Roberts",
                "S. Setty",
                "B. Zill"
            ],
            "title": "Ironfleet: Proving practical distributed systems correct",
            "venue": "Proceedings of the 25th Symposium on Operating Systems Principles. p. 1\u201317. SOSP\u201915, Association for Computing Machinery, New York, NY, USA",
            "year": 2015
        },
        {
            "authors": [
                "C.A.R. Hoare"
            ],
            "title": "An Axiomatic Basis For Computer Programming",
            "venue": "Communications of the ACM 12, 576\u2013580",
            "year": 1969
        },
        {
            "authors": [
                "G. Huet",
                "G. Kahn",
                "C. Paulin-Mohring"
            ],
            "title": "The Coq proof assistant : A tutorial",
            "venue": "Version 6.1. Tech. rep., INRIA",
            "year": 1997
        },
        {
            "authors": [
                "F. Kalim",
                "K. Palmskog",
                "J. Mehar",
                "A. Murali",
                "I. Gupta",
                "P. Madhusudan"
            ],
            "title": "Kaizen: Building a performant blockchain system verified for consensus and integrity",
            "venue": "2019 Formal Methods in Computer Aided Design (FMCAD). pp. 96\u2013104",
            "year": 2019
        },
        {
            "authors": [
                "M. Krogh-Jespersen",
                "A. Timany",
                "M.E. Ohlenbusch",
                "S.O. Gregersen",
                "L. Birkedal"
            ],
            "title": "Aneris: A mechanised logic for modular reasoning about distributed systems",
            "venue": "M\u00fcller, P. (ed.) Programming Languages and Systems. pp. 336\u2013365. Springer International Publishing, Cham",
            "year": 2020
        },
        {
            "authors": [
                "L. Lamport"
            ],
            "title": "The temporal logic of actions",
            "venue": "Digital Equipment Corporation",
            "year": 1994
        },
        {
            "authors": [
                "R. Leino"
            ],
            "title": "Dafny: An automatic program verifier for functional correctness",
            "venue": "16th International Conference, LPAR-16, Dakar, Senegal. pp. 348\u2013370. Springer Berlin Heidelberg",
            "year": 2010
        },
        {
            "authors": [
                "B. Lepers",
                "R. Gouicem",
                "D. Carver",
                "J.P. Lozi",
                "N. Palix",
                "M.V. Aponte",
                "W. Zwaenepoel",
                "J. Sopena",
                "J. Lawall",
                "G. Muller"
            ],
            "title": "Provable multicore schedulers with ipanema: Application to work conservation",
            "venue": "Proceedings of the Fifteenth European Conference on Computer Systems. EuroSys\u201920, Association for Computing Machinery, New York, NY, USA",
            "year": 2020
        },
        {
            "authors": [
                "C.B. Louren\u00e7o",
                "J.S. Pinto"
            ],
            "title": "Why3-do: The way of harmonious distributed system proofs",
            "venue": "ESOP 2022 Artifact",
            "year": 2022
        },
        {
            "authors": [
                "H. Ma",
                "A. Goel",
                "J.B. Jeannin",
                "M. Kapritsos",
                "B. Kasikci",
                "K.A. Sakallah"
            ],
            "title": "I4: Incremental inference of inductive invariants for verification of distributed protocols",
            "venue": "Proceedings of the 27th ACM Symposium on Operating Systems Principles. p. 370\u2013384. SOSP \u201919, Association for Computing Machinery, New York, NY, USA",
            "year": 2019
        },
        {
            "authors": [
                "S. Merz"
            ],
            "title": "On the verification of a self-stabilizing algorithm",
            "venue": "Tech. rep., University of Munich",
            "year": 1998
        },
        {
            "authors": [
                "L. de Moura",
                "N. Bj\u00f8rner"
            ],
            "title": "Z3: An Efficient SMT Solver, Lecture Notes in Computer Science, vol",
            "venue": "4963/2008, pp. 337\u2013340. Springer Berlin",
            "year": 2008
        },
        {
            "authors": [
                "C. Newcombe"
            ],
            "title": "Why amazon chose TLA+",
            "venue": "Ait Ameur, Y., Schewe, K.D. (eds.) Abstract State Machines, Alloy, B, TLA, VDM, and Z. pp. 25\u201339. Springer Berlin Heidelberg, Berlin, Heidelberg",
            "year": 2014
        },
        {
            "authors": [
                "O. Padon",
                "G. Losa",
                "M. Sagiv",
                "S. Shoham"
            ],
            "title": "Paxos made EPR: Decidable reasoning about distributed protocols",
            "venue": "Proc. ACM Program. Lang. 1(OOPSLA)",
            "year": 2017
        },
        {
            "authors": [
                "O. Padon",
                "K.L. McMillan",
                "A. Panda",
                "M. Sagiv",
                "S. Shoham"
            ],
            "title": "Ivy: Safety verification by interactive generalization",
            "venue": "Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation. p. 614\u2013630. PLDI \u201916, Association for Computing Machinery, New York, NY, USA",
            "year": 2016
        },
        {
            "authors": [
                "S. Qadeer",
                "N. Shankar"
            ],
            "title": "Verifying a self-stabilizing mutual exclusion algorithm",
            "venue": "Proceedings of the IFIP TC2/WG2.2,2.3 International Conference on Programming Concepts and Methods. pp. 424\u2013443. PROCOMET \u201998, Chapman & Hall, Ltd.",
            "year": 1998
        },
        {
            "authors": [
                "A. Riazanov",
                "A. Voronkov"
            ],
            "title": "The design and implementation of VAMPIRE",
            "venue": "AI Commun. 15(2-3), 91\u2013110",
            "year": 2002
        },
        {
            "authors": [
                "B. Rognier"
            ],
            "title": "Verify a smart contract with archetype",
            "venue": "https://medium.com/ coinmonks/verify-a-smart-contract-with-archetype-6e0ea548e2da",
            "year": 2019
        },
        {
            "authors": [
                "M. Schneider"
            ],
            "title": "Self-stabilization",
            "venue": "ACM Comput. Surv. 25(1), 45\u201367",
            "year": 1993
        },
        {
            "authors": [
                "I. Sergey",
                "J.R. Wilcox",
                "Z. Tatlock"
            ],
            "title": "Programming and proving with distributed protocols",
            "venue": "Proc. ACM Program. Lang. 2(POPL)",
            "year": 2017
        },
        {
            "authors": [
                "P. Tolmach",
                "Y. Li",
                "S.W. Lin",
                "Y. Liu",
                "Z. Li"
            ],
            "title": "A survey of smart contract formal specification and verification",
            "venue": "ArXiv abs/2008.02712",
            "year": 2020
        },
        {
            "authors": [
                "T. Tsuchiya",
                "S. ichi Nagano",
                "R.B. Paidi",
                "T. Kikuno"
            ],
            "title": "Symbolic model checking for self-stabilizing algorithms",
            "venue": "IEEE Trans. Parallel Distrib. Syst. 12(1), 81\u201395",
            "year": 2001
        },
        {
            "authors": [
                "J.R. Wilcox",
                "D. Woos",
                "P. Panchekha",
                "Z. Tatlock",
                "X. Wang",
                "M.D. Ernst",
                "T. Anderson"
            ],
            "title": "Verdi: A framework for implementing and formally verifying distributed systems",
            "venue": "Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation. p. 357\u2013368. PLDI \u201915, Association for Computing Machinery, New York, NY, USA",
            "year": 2015
        },
        {
            "authors": [
                "Y. Yu",
                "P. Manolios",
                "L. Lamport"
            ],
            "title": "Model checking TLA+ specifications",
            "venue": "Pierre, L., Kropf, T. (eds.) Correct Hardware Design and Verification Methods. pp. 54\u201366. Springer Berlin Heidelberg, Berlin, Heidelberg",
            "year": 1999
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "The formal verification of properties of distributed algorithms and protocols is an important and notoriously difficult activity. The dominant approaches are: (i) Automatic exploration of the state space, known as model checking [10,4], a technique that can be used for both safety and liveness properties, expressed using variants of temporal logic. Its application to distributed systems is a consolidated area that has held many significant results. However, the state explosion phenomenon means that in practice only systems of modest size can be verified. (ii) Deductive reasoning based on the use of inductive invariants. A number of tools [26,18,13] now exist for the verification of single-threaded systems based on first-order logic (FOL), loop invariants, and contracts, with solid theoretical foundations [21,16]. Reasoning about distributed systems using inductive invariants was, until recently, mostly a pen-and-paper activity, but tools like Verdi [42], IronFleet [20], and Ivy [34] have made significant advances to this state of things (see Section 7 for details). Relying on external provers (and in the case of IronFleet, on the Dafny verifier to check the sequential code), these tools support verification of asynchronous message-passing systems based on atomic handlers, reusable network/fault models, and different abstract specification mechanisms.\nBased on the same principles, we propose in this paper a conceptual contractbased framework for reasoning about distributed systems, as well as the Why3-do library for the Why3 verifier [18]. Distinctive aspects of our approach include the following:\n\u2013 It allows for reasoning about distributed systems using a standard program verification tool (rather than a dedicated tool or a proof assistant), and methods and techniques that are standard for sequential software.\nc\u00a9 The Author(s) 2022 I. Sergey (Ed.): ESOP 2022, LNCS 13240, pp. 114\u2013142, 2022. https://doi.org/10.1007/978-3-030-99336-8_5\n\u2013 Systems and protocols are described algorithmically by means of programmed handlers equipped with contracts that guarantee the inductiveness of invariants. Thus Why3-do brings modular development using the popular programming by contract methodology to the scope of distributed systems. \u2013 Why3-do offers other system models in addition to message-passing. We illustrate this in this paper by describing a locally shared memory model. \u2013 It takes advantage of Why3\u2019s state of the art proof management (including replayability, bisection of hypotheses, and inconsistency detection); ability to interact with all major proof tools (automated and interactive); and internal transformations that allow for a combination of interactive and automated development, avoiding the use of proof assistants for inductive proofs.\nContributions of the Paper. We contribute to the state of the art of distributed system verification, and in general to software verification with Why3: (i) We introduce (Section 3) principles for modular verification of distributed systems based on clonable models, capturing in a uniform way different system semantics. Each model declares a set of handlers equipped with contracts. (ii) We present (sections 4, 5, 6) a Why3 library with different system models and fault semantics. A concrete system is defined by cloning a model and defining its handlers and invariants. Handler implementations are required to respect the contracts declared in the model, which in particular ensures inductiveness of the invariants. Although Dafny contracts can also be used in IronFleet, the novelty in Why3-do is the presence of dedicated contracts in the library models, that are used to automatically generate verification conditions when cloning. (iii) We introduce (Section 5) a model-independent specification mechanism based on system traces, to act as abstraction barrier between specification (observable properties) and implementation. Traces are a common specification mechanism; the novelty here is the support for modular development through the use of model-independent clonable specification modules ; different implementations can be given for a specification, using different system models. (iv) We present (Section 6) a locally-shared memory model illustrating how our approach is applied uniformly beyond message-passing models. As far as we are aware Verdi, IronFleet and Ivy work with message-passing systems only. (v) We formalize and verify one of Dijsktra\u2019s self-stabilizing systems [15] and verify its closure (safety) and convergence (liveness) properties using Why3-do. This verification is of independent interest: our proof of convergence, using a measure function, takes advantage of SMT solvers and significantly improves on previous, much more laborious efforts using proof assistants (Section 6). (vi) We propose two techniques for reasoning with inductive invariants containing existential and nested quantifiers: stepwise bounded validation (Section 6), and the use of dual definitions containing both code and logic (sections 4 and 6). Together with Why3\u2019s ability to interact with multiple solvers with different strengths, dual definitions allow for more robust and natural specifications, as well as for easier automated proofs, without the need for tricks like quantifier hiding [20]. Both techniques are explained by means of examples.\nmodule MapList use int.Int, list.List, list.Mem, list.Length, list.NthNoOpt\nval function f (x:int) : int requires {x >= 0} ensures {result >= 0}\npredicate nonNeg (l:list int) = forall x :int. mem x l -> x >= 0\nlet rec map_list (l:list int) : list int requires { nonNeg l } ensures { nonNeg result /\\ forall j. 0<=j<length l -> nth j result = f(nth j l) } variant { l } = match l with | Nil -> Nil | Cons h t -> Cons (f h) (map_list t) end end (* module MapList *)\nmodule MapFib use int.Int, list.List, list.Mem, list.Length, list.NthNoOpt, ref.Ref\ninductive fibpred int int = | zero : fibpred 0 0 | one : fibpred 1 1 | oth : forall n r1 r2 :int. n>=2 -> fibpred (n-1) r1 /\\ fibpred (n-2) r2 -> fibpred n (r1+r2)\nlet function calcfib (m:int) : int requires { m >= 0 } ensures { result >= 0 /\\ forall r. fibpred m r <-> r=result } = let n = ref 0 in let x = ref 0 in let y = ref 1 in while !n < m do\ninvariant { 0 <= !n <= m /\\ !x >= 0 /\\ !y >= 0 } invariant { forall r. (fibpred !n r <-> r = !x) /\\ (fibpred (!n+1) r <-> r = !y) } variant { m - !n } let tmp = !x in x := !y; y := !y+tmp; n := !n+1;\ndone; !x\nclone MapList with val f = calcfib\nlemma mapFib_lm: forall l:list int.nonNeg l-> let fibl = map_list l in nonNeg fibl /\\ forall j.0<=j<length l-> nth j fibl = calcfib (nth j l) end (* module MapFib *) Listing 2.1. Why3 example\nAll the models and example modules mentioned in the paper are available for experimentation in the Why3-do artifact [28]."
        },
        {
            "heading": "2 The Why3 Languages in a Nutshell",
            "text": "The example in Listing 2.1 illustrates the use of Why3\u2019s logic and programming languages, as well as the module cloning mechanism. The MapList module first imports a number of theories for mathematical integers and lists from the standard library. Why3 includes a wide range of theories, usable across provers. A program function f is then declared with the val keyword, including a simple contract: a precondition requiring its argument to be nonnegative, and a postcondition stating that the result is also nonnegative. In the rest of the module this contract will be assumed to hold for f. Next, a logic predicate nonNeg\nis defined. It uses a universal quantifier to state that every element of its argument list is nonnegative. Finally, the map_list program function is defined. The definition includes both the function\u2019s recursive definition and a contract, in particular a postcondition that uses a universal quantifier to state the mapping property (result refers to the return value). From this module, Why3 will generate verification conditions (VCs) ensuring that the definition is consistent with its contract, assuming the definition of f keeps to its own contract. This interplay between contracts plays a fundamental role in deductive verification.\nThis little example allows us to elaborate on another aspect of Why3. nonNeg is also a function (returning a truth value), but it lives in a different namespace from map_list, which is a WhyML program function. nonNeg belongs to Why3\u2019s logic language [17], and its definition contains a quantifier, which cannot be used in programs. However, pure program functions, which do not modify the global state, may also be used in the logic, if their declaration includes the function keyword. This is the case of f, used in both the code and the contract of map_list. We will refer to program functions that can be used in the logic as \u201clet functions\u201d. map_list is also pure, but is not declared as a let function.\nWhy3 encodes both the code and contracts of let functions, so one may choose to write certain logic functions algorithmically or logically, or both. For instance nonNeg could be defined alternatively as follows (the postcondition is optional):\nlet rec predicate nonNeg (l:list int) ensures { result <-> forall x :int. mem x l -> x >= 0 } = match l with | Nil -> true | Cons h t -> h>=0 && nonNeg t end\nIf the postcondition is present, the logic encoding of the predicate will contain redundancy (no inconsistency can be created since the definition must respect the contract). Writing such \u201cdual definitions\u201d of logic functions may be a good idea for a number of reasons, namely the possibility of including preconditions, and termination checks based on user-provided variants. Moreover, dual definitions increase the robustness of specifications and may facilitate automated proofs of results involving quantifiers. Not every logic function can be defined as a let function: since the latter must remain executable, they may not contain for instance occurrences of logic equality or quantifiers. In these cases let ghost functions can be used. These are pure logic definitions that are not meant to be executed, but are still written as programs.\nA second module, MapFib, defines a program function calcfib that computes Fibonacci numbers using a loop. The recursive definition of the Fibonacci sequence (used in the function and loop invariant of calcfib) cannot be written as a logic function, since it is not total. It could be defined as a let function with a precondition restricting its domain, but we use instead an inductive predicate fibpred: the formula fibpred n f means that f is the nth. Fibonacci number. Inductive predicates, familiar to readers acquainted with proof assistants, are defined by means of a set of inference rules. They are used in our models to define non-deterministic transition relations on distributed system configurations.\nWhy3 will generate and successfully discharge VCs ensuring the correctness of calcfib with respect to its contract. Now, since calcfib is in accordance with\nthe contract of f in MapList, this module can be cloned instantiating the latter function with the former. This imports into the current module a copy of every element of MapList, with calcfib substituted for f, and generates refinement VCs, to ensure that calcfib\u2019s contract is stronger than f\u2019s. Finally, the lemma mapFib_lm states that indeed map_list maps the function calcfib as expected."
        },
        {
            "heading": "3 Distributed Systems and Models",
            "text": "A distributed system consists of a set N of nodes, each of which can at any moment be in a state taken from a set \u03a3, together with additional elements, such as a communication network or a shared memory. We will call the global state of such a system a world and denote by W the set of all worlds. In general, worlds will include the local state of every node in the system, captured as a mapping lS : N \u2192 \u03a3. Different models will specialize this basic setting to define different notions of distributed system (and consequently also of world), including for instance different communication and fault models (we will always write N, \u03a3, or W in the context of a specific system model, left implicit).\nModels are handler-based : systems are described by writing code executed by nodes in response to certain events, such as receiving a message from the network or an input from the local environment, or simply being enabled by a guard predicate that becomes true. Handlers are assumed to execute atomically. Each model defines a transition semantics describing how worlds evolve step by step, allowing for all possible schedules (both locally and globally). Each model contains a set of rules inferring judgments of the form w w\u2032, meaning that the system\u2019s global state w evolves to w\u2032. The general form of the rules states the following: if the world w\u2032 results from w when a handler is executed by one of the system\u2019s nodes, then w w\u2032.\nLet w0 correspond to the initial state of the system, and \u2217 denote the reflexive-transitive closure of . A world w is said to be reachable if w0 \u2217 w. Let \u03a6 be some property of worlds; we will write w |= \u03a6 to signify that \u03a6 is satisfied by the world w . A system is said to be correct with respect to \u03a6 if w |= \u03a6 holds for every reachable world w. A typical correctness proof involves finding an inductive invariant : a property I such that (i) w0 |= I, and (ii) for every pair w, w\u2032 of worlds, if w |= I and w w\u2032, then w\u2032 |= I. If w |= I implies w |= \u03a6, this is sufficient to guarantee correctness.\nContract-based Models. We introduce the use of handler contracts for designing and verifying distributed systems. Let us consider a model with worlds of the form \u3008lS, . . .\u3009, with . . . standing for other components of worlds in addition to the state function. The signature and contract of a handling function will be of the following general form, where I is a candidate invariant predicate, and other arguments and return values (. . .) may be present:\nhandle(n : N, lS : N\u2192 \u03a3, . . .) : (\u03c3 : \u03a3, . . .) requires I\u3008lS, . . .\u3009 ensures I\u3008lS[n 7\u2192 \u03c3], . . .\u3009\nThe function returns the new state \u03c3 of the node n that executes the handler in a world with state function lS. This general form will be adapted with modifications in different models. For instance, handling functions may have access only to the local state and not to the entire state function lS, or they may return, in addition to a new state, a list of messages to be sent by n. Transition rules have the following general form, updating the state of the node that executes the handler, and reflecting in the world other effects of the execution.\nhandle(n, lS, . . .) = (\u03c3, . . .)\n\u3008lS, . . .\u3009 \u3008lS[n 7\u2192 \u03c3], . . .\u3009\nThe handler\u2019s contract, consisting of precondition I\u3008lS, . . .\u3009 and postcondition I\u3008lS[n 7\u2192 \u03c3], . . .\u3009, ensures that if the handler is executed in a world satisfying the invariant I, then the world resulting from this transition still satisfies I.\nIt is common for handlers to have access only to the state \u03c3 of the node n where they are being executed. In this case it is not possible to include I\u3008lS, . . .\u3009 as a precondition in the contract, since lS is not passed as a parameter. Preservation of the invariant can be written instead as a conditional postcondition, stating that for every world satisfying I in which \u03c3 is the state of node n and this node executes the handler, then the resulting world still satisfies I:\nhandle(n : N, \u03c3 : \u03a3, . . .) : (\u03c3\u2032 : \u03a3, . . .) ensures \u2200lS:N\u2192\u03a3 . \u03c3 = lSn \u2192 I\u3008lS, . . .\u3009 \u2192 I\u3008lS[n 7\u2192 \u03c3\u2032], . . .\u3009\nThe Why3-do Library. Listing 3.1 illustrates how contract-based models are written as Why3 modules. The World module declares basic types and functions, and defines the world structured type. The Steps module includes val declarations for (i) the initial world, (ii) an inductive invariant predicate, and (iii) a set of handling functions (illustrated here by handle_1). Contracts enforce that the inductive invariant is satisfied by the initial world, and preserved by handlers. Each handler\u2019s contract makes use of a step_1 auxiliary function, that is also used in the definition of the transition semantics through the step inductive predicate. The module ends with the definition of reachable world, and a lemma stating that the invariant holds in all reachable worlds (this is proved inductively for each model, using proof transformations and SMT solvers).\nThat is all that is required to define a system model, which may now be cloned to produce concrete distributed systems. Listing 3.2 illustrates how simple this is. We write a System module that defines, first of all, types for nodes, states, messages, and other relevant elements, and if appropriate, well-formedness predicates for different entities. The World module from the desired Why3-do library model can then be cloned, after which the following are defined: (i) the initial world, (ii) a candidate inductive invariant predicate, and (iii) handler functions specifying the behavior of the system\u2019s nodes/processes. The Steps module from the same model is now cloned, instantiating these elements. Why3 will produce a set of VCs, generated from the contracts contained in the cloned module, ensuring that the invariant is inductive. Properties of interest can at last be stated and proved (which may involve writing additional definitions and lemmas).\nmodule World (* file model.mlw *) type node type state type world = (map node state, ...) function localState (w:world) : map node state = (* projection functions for worlds *)\nlet (lS, ...) = w in lS end (* module World *)\nmodule Steps (* file model.mlw *) ... val function initState (node) : state (* init functions for world components *) constant initWorld : world = (initState, ...)\nval ghost predicate indpred (w:world) ensures { w=initWorld -> result } (* initial world must satisfy invariant *)\n(* specifying the new world that results from w when n executes a handler yielding results r *) function step_1 (w:world) (n:node) (r:(state, ...)) : world =\nlet (st, ...) = r in let newLocalState = set (localState w) n st in\n(newLocalState, ...)\n(* handlers\u2019 arguments include a node h and its state; results include a new state for h *) val function handle_1 (h:node) (sig:state) ... : (state, ...)\nensures { forall w :world. indpred w -> sig = localState w h -> ... -> indpred (step_1 w h result) }\ninductive step world world = | step_1 : forall w :world, n :node. step w (step_1 w n (handle_1 n (localState w n) ...)) | ...\ninductive step_TR world world = | base : forall w :world. step_TR w w | step : forall w w\u2019 w\u2019\u2019 :world. step_TR w w\u2019 -> step w\u2019 w\u2019\u2019 -> step_TR w w\u2019\u2019\npredicate reachable (w:world) = step_TR initWorld w\n(* inductive invariant holds in all reachable worlds *) lemma indpred_reachable : forall w :world. reachable w -> indpred w end (* module Steps *)\nListing 3.1. Basic structure of a Why3-do model"
        },
        {
            "heading": "4 The Basic Message-Passing Model",
            "text": "In this model nodes communicate by exchanging packets : triples of the form (d, s,m), carrying a message m \u2208 Msg from node s \u2208 N to node d \u2208 N, with Msg a given set of messages. Worlds are pairs \u3008lS , nt\u3009 where lS : N \u2192 \u03a3 is a function assigning a state to each node and nt : Msg\u2217 is a network, abstracted as a list of packets. In a system based on this asynchronous model, nodes execute a message handler whenever they receive a message, and may in turn send messages to other nodes. The handleM function implements this local messagehandling behavior. Its parameters include the node h handling the message, the node that sent the message, the state of the handling node, and the message itself. It returns a new state for h and a list of packets to be sent to the network.\nmodule System (* file system.mlw *) type node = int type state = int clone model.World with type node, type state\nlet function initState (n:node) : state = ...\nlet ghost predicate indpred (w:world) = ...\nlet function handle_1 (h:node) (lS:map node state) : state = ...\nclone model.Steps with type node, type state, val initState, val indpred, val handle_1\ngoal systemProperty : forall w :world. reachable w -> ...\nend (* module System *) Listing 3.2. Basic structure of a Why3-do system module\nIts signature and contract are (with I a candidate invariant):\nhandleM(h : N, s : N,m : Msg, \u03c3 : \u03a3) : (\u03c3\u2032 : \u03a3, nt\u2032 : Msg\u2217) ensures \u2200lS:N\u2192\u03a3,nt:Msg\u2217 . \u03c3 = lSh\u2192 (h, s,m) \u2208 nt \u2192 I\u3008lS, nt\u3009 \u2192 I\u3008lS[h 7\u2192 \u03c3\u2032], nt\u2032 + nt\u2212 {(h, s,m)}\u3009)\nThe semantics of the model are given by the following transition rule:\nhandleM(h, s,m, lS(h)) = (\u03c3, nt\u2032) (h, s,m) \u2208 nt \u3008lS , nt\u3009 \u3008lS[h 7\u2192 \u03c3] , nt\u2032 + nt\u2212 {(h, s,m)}\u3009 (message)\nWe use notation +, \u2212, and \u2208 for list concatenation, difference, and membership. Any packet that is in transit in the network may be selected by the rule to be delivered and handled by the receiving node. The rule removes the packet from the network, updates the state of the handling node, and sends new packets as prescribed by the handler. The semantics takes into account all possible orders of message delivery, since any message may be extracted from the packet pool. The semantics is otherwise idealized, but the library contains additional models in which messages may be dropped or duplicated by the network (an example verification of a system assuming message duplication is given in Section 5).\nThe contract of handleM ensures that executions of (message) preserve the invariant I. Let okI(handleM) signify that the implementation of the handler adheres to its contract, instantiated with the candidate invariant I. If I holds in the initial world then it is indeed inductive and holds in all reachable worlds:\nLemma 1. Let w0, w \u2208 W and I be a predicate such that okI(handleM). If w0 |= I and w0 \u2217 w then w |= I.\nA simplified version of the corresponding Why3-do model is shown in Listing 4.1. The World module defines the tuple types packet and world and auxiliary functions. Steps declares the following elements to be instantiated when cloning: the ok_Msg well-formedness predicate; initState and initMsgs,\nmodule World type node type state type msg type packet = (node, node, msg) function dest (p:packet) : node = let (d,_,_)=p in d function src (p:packet) : node = let (_,s,_)=p in s function payload (p:packet) : msg = let (_,_,m)=p in m type world = (map node state, list packet) function localState (w:world) : map node state = let (lS,_)=w in lS function inFlightMsgs (w:world) : list packet = let (_,ifM)=w in ifM end (* module World *)\nmodule Steps ... predicate ok_Msg (node) (node) (msg)\nval function initState (node) : state val constant initMsgs : list packet constant initWorld : world = (initState, initMsgs)\nval ghost predicate indpred (w:world) ensures { w=initWorld -> result } ensures { result -> forall p: packet. mem p (inFlightMsgs w) ->\nok_Msg (dest p) (src p) (payload p) }\nfunction step_message (w:world) (p:packet) (r:(state, list packet)) : world = let (st, ms) = r in let localState = set (localState w) (dest p) st in\nlet inFlightMsgs = ms ++ (remove p (inFlightMsgs w)) in (localState, inFlightMsgs)\nval function handleMsg (h:node) (s:node) (m:msg) (sig:state) : (state, list packet) requires { ok_Msg h s m } ensures { forall w :world. indpred w -> mem (h, s, m) (inFlightMsgs w) ->\nsig = localState w h -> indpred (step_message w (h, s, m) result) }\ninductive step world world = | step_msg : forall w :world, p :packet. mem p (inFlightMsgs w) ->\nstep w (step_message w p (handleMsg (dest p) (src p) (payload p) (localState w (dest p))))\ninductive step_TR world world = ... predicate reachable (w:world) = step_TR initWorld w\nlemma indpred_reachable : forall w :world. reachable w -> indpred w end (* module Steps *)\nListing 4.1. Message-passing model: modelMP\nused to construct initWorld; the inductive invariant indpred; and finally the handleMsg handler. The contract of indpred ensures that it is satisfied by the initial world, and that all messages in the network are well-formed. Wellformedness conditions are singled out from the invariant because the handler function may need to assume basic facts about messages. The module ends with lemma indpred_reachable, corresponding to Lemma 1 (the okI(handleM) and w0 |= I premises are enforced by the contracts of indpred and handleMsg). It is proved using a Why3 transformation for predicate induction, and SMT solvers.\nExample: Leader Election on a Ring. Leader Election is a coordination problem, where a set of processes or nodes collectively designate one of them to act as leader. One of the simplest solutions to this problem on a unidirectional ring network is the maximum-finding distributed algorithm devised by Chang and\nRoberts [7]. Let each node have a distinct identifier of some type equipped with a total order relation. Informally the algorithm can be described as follows: (i) messages are node identifiers; each node starts by sending its id to the next node in the ring. (ii) Each node then enters a message-handling loop. If a received message has a higher value than the receiver\u2019s id, the message is forwarded to the next node. Otherwise, it is discarded. (iii) If a node receives back a message with its own id, it claims to be the leader. The fundamental property to be proved of this system is that at most one node claims to be leader. The system has been used as example in [34] and later in [29]. The Ivy description of the system is based on the decidable EPR fragment of FOL (See Section 7), whereas our formalization below uses unrestricted quantification.\nThe Why3-do encoding of this algorithm is given in Listing 4.2, based on the modelMP library model. The first step is to define types for nodes, identifiers, states, and messages. Identifiers are uniquely associated to nodes by means of the id function and the uniqueIds axiom. The constant n_nodes is the number of nodes in the ring. A minimum of 3 nodes is assumed, with no upper bound. The constant maxId_global corresponds to the (unique) node having the highestvalue id in the ring. Node states are records having a single field leader of Boolean type, which indicates when a node claims to be leader. The ok_Msg predicate describes the notion of well-formed message in the ring topology.\nThe types for nodes and identifiers could be left undefined, with a set of axioms for the next function and the maxId_global constant. But in our experience, using library types, as well as defined constants, predicates, and functions when adequate, is advantageous from the point of view of provability, and also reduces the danger of introducing inconsistencies. For instance the maxId_global constant is defined algorithmically using a recursive let function maxId_fn with a \u201cdual definition\u201d (it is equipped with a contract describing precisely what it does). We could instead simply write an axiom concerning maxId_global, but using the dual definition let function, containing code, not only increases the degree of assurance in what is being specified, but also makes it easier to reason about, since Why3 will generate a more easily provable set of VCs.\nCloning the module modelMP.World introduces new composed types and auxiliary definitions. The system description then proceeds to give the initial conditions of the system, by means of a state function initState, and a constant initMsgs for the list of messages that are sent upon booting, also defined by means of a recursive let function. The handler definition then follows. The next element in the module is the invariant indpred, defined as a let predicate (since logic elements like quantifiers and equality are required, it is defined as a let ghost predicate using an auxiliary predicate inv, see Section 2). It states that every inflight message is well-formed; it contains the id of some node in the ring, with value not less than the sender\u2019s id, and it is not the id of any node i such that maxId_global is located between i and the message\u2019s destination node (an auxiliary predicate between is used to express this). Moreover if the message contains its destination\u2019s id then that id is the highest in the network. Finally, any node that is claiming to be the leader has the highest id in the ring.\ntype node = int val constant n_nodes : int axiom n_nodes_ax : 3 <= n_nodes let function next (x:node) : node = mod (x+1) n_nodes\ntype id = int val function id (node) : id axiom uniqueIds : forall i j :node. id i = id j <-> i=j\nlet rec function maxId_fn (n:int) : node requires { 1 <= n <= n_nodes } ensures { 0 <= result < n} ensures { forall k :node. 0<=k<n -> k<>result -> id k < id result} variant { n } = if n=1 then 0 else let m = maxId_fn (n-1) in if id (n-1) > id m then n-1 else m\nconstant maxId_global : id = maxId_fn n_nodes\ntype state = { leader : bool }\ntype msg = id predicate ok_Msg (dest:node) (src:node) (m:msg) =\n0 <= dest < n_nodes /\\ 0 <= src < n_nodes /\\ dest = next src\nclone modelMP.World with type node = node, type state = state, type msg = msg\nlet function initState (i:node) : state = { leader = false }\nlet rec function initMsgs_fn (n:node) : list packet requires { 0<=n<=n_nodes } ensures { forall s d :node, m :msg. mem (d, s, m) result ->\nm = id s /\\ d = next s /\\ n<=s<n_nodes /\\ (forall i :node. between i maxId_global d -> m <> id i) /\\ (m = id d -> d = maxId_global) }\nvariant { n_nodes-n } = if (0<=n<n_nodes) then Cons (next n, n, id n) (initMsgs_fn (n+1))\nelse Nil\nlet constant initMsgs : list packet = initMsgs_fn 0\nlet function handleMsg (h:node) (src:node) (m:msg) (s:state) : (state, list packet) = if m = (id h) then ({ leader = true }, Nil)\nelse if m > id h then (s, Cons (next h, h, m) Nil) else (s, Nil)\npredicate between (lo:node) (i:node) (hi:node) = (lo < i < hi) \\/ (hi < lo < i) \\/ (i < hi < lo)\nlemma btw_next_lm : forall i j k :node. 0 <= i < n_nodes -> 0 <= j < n_nodes -> 0 <= k < n_nodes -> i <> k ->\nbetween (next i) j k -> between i j k\npredicate inv (lS:map node state) (iFM:list packet) = (forall s d :node, m :msg. mem (d, s, m) iFM ->\n(ok_Msg d s m /\\ m >= id s /\\ (exists i :node. 0 <= i < n_nodes /\\ m = id i) /\\ (forall i :node. between i maxId_global d -> m <> id i) /\\ (m = id d -> d = maxId_global) )) /\\\n(forall i:node. 0<=i<n_nodes -> (lS i).leader = true -> i = maxId_global)\nlet ghost predicate indpred (w:world) = inv (localState w) (inFlightMsgs w)\nclone modelMP.Steps with type node, type state, type msg, predicate ok_Msg, val initState, val initMsgs, val indpred, val handleMsg\ngoal uniqueLeader : forall w :world, i j:node.\nreachable w -> 0<=i<n_nodes -> 0<=j<n_nodes -> (localState w i).leader = true -> (localState w j).leader = true -> i = j\nListing 4.2. Leader election on a ring (Chang-Roberts)\nThe module then clones the Steps module from modelMP instantiating the necessary elements, and formulates the uniqueLeader proof goal. The verification results depend on the provers that are available. In our setup we were able to prove automatically all VCs using the Alt-Ergo [11], CVC4 [5], and Vampire [36] SMT solvers after (i) providing lemma btw_next_lm, proved automatically by Alt-Ergo; and (ii) including in the postcondition of function initMsgs_fn the relevant facts relating in-transit messages and maxId_global, as required by the invariant. Observe that this postcondition is proved automatically by the program verification engine following the recursive definition of the function."
        },
        {
            "heading": "5 Trace Specifications",
            "text": "In the previous section we have considered a specification property expressed at the implementation level, with access to internal node states. Other internal elements of worlds, including messages, could be mentioned in such implementationlevel properties. It is however very useful to introduce an abstraction barrier between specifications and implementation details. This can be achieved by logging certain observable events onto a trace of the system, and then writing specifications as properties of the trace. Models in our setting can be equipped with traces, allowing for protocols and systems to be specified in this way.\nWe will illustrate this by equipping the message-passing model of Section 4 with traces. Each system using this model defines an Out type of outputs, and the model defines external events as Evt = N \u00d7Out, outputs paired with the node that originated them (other models may use additional notions of external event, such as inputs received by nodes from their local environments). A trace is a sequence of external events; the function rec : N\u2192 Out\u2217 \u2192 Evt\u2217 produces a trace from a sequence of outputs, pairing them with the source node. Given a predicate \u03bd on traces and \u03c4 \u2208 Evt\u2217, we will write \u03c4 |= \u03bd when \u03c4 satisfies \u03bd.\nA commit specification (\u00b5p, \u00b5f ) consists of a predicate \u00b5p(\u03a3,\u03a3) and a function \u00b5f (\u03a3,\u03a3) : Out\n\u2217, expressing respectively when outputs should be produced, and what those outputs should be. The signature of the message handler is similar to that in the model of Section 4, with a trace as additional output. Its contract states that it complies with a given commit specification.\nhandleM(h :N, s :N,m :Msg, \u03c3 :\u03a3) : (\u03c3\u2032 :\u03a3, nt\u2032 :Msg\u2217, l :Out\u2217) ensures \u2200lS:N\u2192\u03a3,nt:Msg\u2217 . \u03c3 = lSh\u2192 (h, s,m) \u2208 nt\nI\u3008lS, nt\u3009 \u2192 I\u3008lS[h 7\u2192 \u03c3\u2032], nt\u2032 + nt\u2212 {(h, s,m)}\u3009) ensures (\u00b5p(\u03c3, \u03c3 \u2032)\u2192 l = \u00b5f (\u03c3, \u03c3\u2032)) \u2227 (\u00ac\u00b5p(\u03c3, \u03c3\u2032)\u2192 l = \u03b5)\nWe will write okI,\u00b5p,\u00b5f (handleM) to signify that the implementation of handleM adheres to its contract, with invariant I and commit specification (\u00b5p, \u00b5f ).\nWorlds are tuples \u3008lS, nt, \u03c4\u3009 with lS : N \u2192 \u03a3, nt : Msg\u2217, and \u03c4 : Evt\u2217. The semantics will now be given by the relation \u2286 W \u00d7N \u00d7W, with w n w\u2032 meaning that world w transitions to w\u2032 with node n executing a handler. The following transition rule commits outputs to the trace:\nhandleM(h, s,m, lS(h)) = (\u03c3, nt\u2032, l) (h, s,m) \u2208 nt \u3008lS , nt , \u03c4\u3009 h\u3008lS[h 7\u2192 \u03c3] , nt\u2032 + nt\u2212 {(h, s,m)} , rech(l) + \u03c4\u3009 (message)\nA specification is a triple (\u00b5p, \u00b5f , \u03bd) consisting of a commit specification and a predicate \u03bd(Evt\u2217) expressing some notion of trace consistency. Correctness implies that the commit specification is respected and traces are consistent.\nDefinition 1. A system with initial world w0 \u2208 W is said to be correct with respect to a specification (\u00b5p, \u00b5f , \u03bd) if\n1. for all w = \u3008lS, nt, \u03c4\u3009 \u2208 W, w\u2032 = \u3008lS\u2032, nt\u2032, \u03c4 \u2032\u3009 \u2208 W and n \u2208 N such that w0 \u2217 w n w\u2032, if \u00b5p(lS(n), lS \u2032(n)) then \u03c4 \u2032 = recn(\u00b5f (lS(n), lS \u2032(n))) + \u03c4 ,\notherwise \u03c4 \u2032 = \u03c4 2. \u03c4 |= \u03bd for every world w = \u3008lS, nt, \u03c4\u3009 \u2208W such that w0 \u2217 w\nLemma 2. Let (\u00b5p, \u00b5f , \u03bd) be a specification, and I a predicate such that okI,\u00b5p,\u00b5f (handleM), w0 |= I, and for every world w = \u3008lS , nt , \u03c4\u3009, w |= I implies \u03c4 |= \u03bd. Then the system is correct with respect to (\u00b5p, \u00b5f , \u03bd).\nAs usual the lemma is proved mechanically in the Why3-do module for this model. Every Why3-do model extended with traces contains a similar lemma.\nA simplified version of the modelMPTrace model is shown in Listing 5.1 (... indicate elements that are preserved from the modelMP module). The world type extends the tuple of modelMP with a trace of type list externalEvent. The functions/predicates commitp, commitf, and consistent, corresponding respectively to \u00b5p, \u00b5f , and \u03bd, are to be instantiated when cloning the model. The indpred inductive predicate gains a new postcondition ensuring that it enforces consistency of the system\u2019s trace (following the conditions of Lemma 2). The step inductive predicate is modified to include as an additional parameter the node involved in each transition. The commit_step and consistent_reachable lemmas (mechanically proved, using the contracts of indpred and handleMsg) together correspond to Lemma 2 above.\nExample: Distributed Lock. This example will show how Why3-do models can be extended in a flexible way. Its verification was first carried out in [20] and later also in [34] and [29]. We adapt it here to make use of trace specifications, which will allow us to demonstrate their effectiveness as an abstraction barrier. In addition to traces, the example also illustrates the use of guarded actions in models (through the use of enabling predicates), as well as the use of a nonidealized network model, in which in-transit messages can be duplicated. Two implementations will be given: one that is in accordance with the trace spec if the idealized model is used, and a second implementation that tolerates duplicating messages. The specification of the distributed lock system is the following:\n1. the state of each node must include information on whether it is holding a lock (a Boolean), together with the lock\u2019s current epoch (an integer); 2. whenever a node acquires a lock it outputs its current epoch;\nmodule World ... type externalEvent ... type world = (map node state, list packet, list externalEvent) ... function trace (w:world) : list externalEvent = let (_,_,t)=w in t end (* module World *)\nmodule Steps ... type output type externalEvent val function record_outputs (n:node) (outs:list output) : list externalEvent predicate commitp (state) (state) function commitf (state) (state) : list output predicate consistent (t:list externalEvent)\nval ghost predicate indpred (w:world) ensures { ... /\\ result -> consistent (trace w) }\nfunction step_message (w:world) (p:packet) (r:(state, list packet, list output)) : world = let (st, ms, outs) = r in let localState = set (localState w) (dest p) st in\nlet inFlightMsgs = ms ++ (remove p (inFlightMsgs w)) in let trace = (record_outputs (dest p) outs) ++ (trace w) in\n(localState, inFlightMsgs, trace)\nval function handleMsg (h:node)(s:node)(m:msg)(sig:state) : (state, list packet, list output) requires { ... } ensures { ... /\\ let (s\u2019,_,lo) = result in (commitp s s\u2019 ->\nlo = commitf s s\u2019) /\\ (not (commitp s s\u2019) -> lo = Nil) }\ninductive step world node world = | step_msg : forall w :world, p :packet.\nmem p (inFlightMsgs w) -> step w (dest p) (step_message w p (handleMsg (dest p) (src p) (payload p) (localState w (dest p))))\n... lemma commit_step :\nforall w w\u2019 :world, n :node. reachable w -> step w n w\u2019 -> (commitp (localState w n) (localState w\u2019 n) ->\ntrace w\u2019 = (record_outputs n (commitf (localState w n) (localState w\u2019 n))) ++ trace w) /\\ (not (commitp (localState w n) (localState w\u2019 n)) -> trace w\u2019 = trace w)\nlemma consistent_reachable : forall w :world. reachable w -> consistent (trace w) end (* module Steps *) Listing 5.1. Message-passing model: modelMPTrace\n3. in every reachable world an output n is stored in position n of the trace.\nThe system\u2019s trace stores the sequence of outputs sent by different nodes. Together, these requirements mean that a node acquiring the lock at epoch n writes to position n of the trace, which implies (since traces are only modified by appending at the head) that no two nodes acquire the lock in the same epoch.\nSpecifications are written as Why3-do modules defining the output and externalEvent types, together with projection and the record_outputs functions. Most importantly, they define the commitp and consistent predicates, as well as the commitf function. However, the specification is abstract and does not impose the use of any specific system model. It requires the presence of certain types, but does not specify how the types are implemented. The requirement that states should contain specific information is included by declaring functions\nmodule Spec\n(* to be instantiated when cloning this module *) type node type state function getEpochS (s:state) : int predicate getHeldS (s:state)\ntype output = | Locked int function getEpochO (o:output) : int =\nmatch o with | Locked e -> e end type externalEvent = (node, output) function node (e:externalEvent) : node = let (n,_) = e in n function outp (e:externalEvent) : output = let (_,o) = e in o let rec function record_outputs (n:node) (outs:list output) : list externalEvent\nensures { forall i :int. 0<=i<length outs -> nth i result = (n, nth i outs) } = ... predicate commitp (s:state) (s\u2019:state) = not (getHeldS s) /\\ getHeldS s\u2019 function commitf (_:state) (s\u2019:state) : list output = Cons (Locked (getEpochS s\u2019)) Nil predicate consistent (t:list externalEvent) =\nmatch t with | Nil -> true | Cons (_,o) tt -> getEpochO o = length t /\\ consistent tt end\nend (* module Spec *) Listing 5.2. Specification module for distributed lock\nand/or predicates on states. Implementation modules will define these types and functions and clone the specification module, instantiating them.\nThis specification of the distributed lock is written as the Why3-do module of Listing 5.2. It assumes the use of a system model defining types node, state, output, and externalEvent. The above requirements are formalized as follows:\n1. the functions getEpochS and getHeldS express required state information; 2. the output type has a single constructor carrying an integer; externalEvents\nare outputs paired with nodes; the commitp predicate states that outputs are produced when the state of a node changes from not holding to holding a lock, and the commitf function returns a list with the node\u2019s current epoch; 3. the consistent predicate uses the list length function to require that the output stored in each position n of the trace contains epoch n.\nWe will consider two message-passing implementations for this specification based on a ring topology, shown in listings 5.3 and 5.4. Node states are records with two fields: a Boolean held indicating whether the node holds the lock, and its current epoch. After the appropriate type definitions, both implementation modules clone the same Spec module, and then the World module from the appropriate model. The idealized model modelMPEnabledTrace is used in the implementation of Listing 5.3, whereas Listing 5.4 uses modelMPEnabledTraceDupl in which messages can be duplicated. Both are extensions of modelMPTrace (Listing 5.1) with an enabling predicate. Enabling predicates allow for nodes to execute guarded actions: when cloning the model, the enabled predicate (with a node and its state as parameters) and the handleEnbld function are instantiated; the semantics states that the handler may be executed whenever the predicate\ntype node = int val constant n_nodes : int axiom n_nodes_ax : 2 <= n_nodes let function next (x:node) : node = mod (x+1) n_nodes\ntype state = { held : bool; epoch : int } function getEpochS (s:state) : int = epoch s predicate getHeldS (s:state) = held s\ntype msg = int predicate ok_Msg (dest:node) (src:node) (_:msg) =\n0<=dest<n_nodes /\\ 0<=src<n_nodes /\\ dest = next src\nclone specLDT.Spec with type node, type state, function getEpochS, predicate getHeldS\nclone modelMPEnabledTrace.World with type node, type state, type msg, type output, type externalEvent\nlet function initState (n:node) : state = let h = if n=0 then true else false in\nlet e = if n=0 then 1 else 0 in { held = h; epoch = e }\nlet constant initMsgs : list packet = Nil let constant initTrace : list externalEvent = Cons (0,Locked(1)) Nil\nlet function handleMsg (_:node)(_:node) (m:msg) (s:state) :(state, list packet, list output) = if (not (held s) ) then ({ held = True; epoch = m }, Nil, Cons (Locked m) Nil)\nelse (s, Nil, Nil)\nlet ghost predicate enabled (s:state) (i:node) = 0<=i<n_nodes && held s\nlet function handleEnbld (h:node) (s:state) : (state, list packet, list output) = let e = epoch s in ({ held = False; epoch = e }, Cons (next h, h, e+1) Nil, Nil)\nlet rec ghost predicate zeroHeld (lS:map node state) (n:int) = ... let rec ghost predicate oneHeld (lS:map node state) (n:int) = ... let rec ghost predicate oneMsg (lp:list packet) = length lp = 1 let rec ghost predicate noMsgs (lp:list packet) = length lp = 0\nlet rec ghost predicate ok_trace (t:list externalEvent) ensures { result -> consistent t } = match t with | Nil -> true | Cons (_,o) Nil -> getEpochO o = 1 | Cons (_,o1) os ->\nmatch os with | Nil -> true | Cons (_,o2) _ -> getEpochO o1=(getEpochO o2)+1 && ok_trace os end\nend\npredicate inv (lS:map node state) (iFM:list packet) (tr:list externalEvent) = (forall p: packet. mem p iFM -> ok_Msg(dest p)(src p)(payload p)) /\\ ((oneMsg iFM /\\ zeroHeld lS n_nodes)\n\\/ (noMsgs iFM /\\ oneHeld lS n_nodes)) /\\ (forall n :node. 0<=n<n_nodes -> held (lS n) ->\nn = node (hd tr) /\\ epoch (lS n) = getEpochO(outp (hd tr))) /\\ (forall p: packet. mem p iFM ->\nsrc p = node (hd tr) /\\ payload p=getEpochO(outp (hd tr))+1) /\\ length tr > 0 /\\ ok_trace tr\nlet ghost predicate indpred (w:world) = inv (localState w) (inFlightMsgs w) (trace w)\nclone modelMPEnabledTrace.Steps with ... Listing 5.3. Distributed lock with idealized model\n... let function handleMsg (_:node) (_:node) (m:msg) (s:state)\n: (s\u2019:state, lp:list packet, lo:list output) = let nop = (s, Nil, Nil) in\nif (held s) || m <= epoch s then nop else ({ held = True; epoch = m }, Nil, Cons (Locked m) Nil)\n... (* helper definitions for invariant predicate *) let rec ghost predicate zeroHeld (lS:map node state)(n:int) ... let rec ghost predicate atMostOneHeld (lS:map node state)(n:int)... let rec ghost predicate isFresh (p: packet) (lS:map node state)... let rec ghost predicate allStale (lS:) (lp:list packet)... let rec ghost predicate atMostOneFresh (lS:...)(lp:...)... let rec ghost predicate ok_trace (t:list externalEvent)...\npredicate inv (lS:map node state) (iFM:list packet) (tr:list externalEvent) = (forall p: packet. mem p iFM -> ok_Msg (dest p)(src p)(payload p)) /\\ atMostOneFresh lS iFM /\\ atMostOneHeld lS n_nodes /\\ (zeroHeld lS n_nodes \\/ allStale lS iFM) /\\ (forall n :node. 0<=n<n_nodes -> held (lS n) ->\nn = node (hd tr) /\\ epoch (lS n) = getEpochO(outp (hd tr))) /\\ (forall p: packet. mem p iFM -> isFresh p lS ->\nsrc p = node (hd tr) /\\ payload p = getEpochO(outp (hd tr))+1) /\\ length tr > 0 /\\ ok_trace tr\n... Listing 5.4. Distributed lock with duplicating messages model\nis true. In the present example, enabled is defined as true when a node holds a lock, in which case it is free to release it. The lock is released when handleEnbld executes, sending a message to the next node in the ring. The message includes the value of the sender\u2019s current epoch, incremented by one.\nThe system is initialized with node 0 holding the lock (and this fact is registered in the system trace). The handling functions then follow. The enabling predicate and the corresponding handler are the same in both implementations; it is in the message handlers that they differ. With the idealized model nodes can trust that messages are never stale, so they react by blindly acquiring the lock. With the duplicating model the receiving node first checks whether the epoch in the received message is higher than its present epoch (in which case it cannot be a stale copy of a previous message). The inductive invariants are also different for both implementations, but both include a property expressed with the ok_trace predicate, stating that events in the trace contain incremental epochs, starting from 1. This implies consistency of the trace (as defined in the specification), and is easier to check for inductiveness.\nLet us consider in detail the system of Listing 5.4. A message is fresh if the current epoch of its destination node is lower than the message. Transfer messages are always sent from the highest epoch node (holding the lock) and thus, at the time of sending, the destination has a lower epoch, which will be updated when the message is received and the lock acquired. Other copies of the message are stale because their destinations\u2019 epochs have since increased. The system\u2019s invariant is given as the conjunction of the following properties, using the zeroHeld, atMostOneHeld, allStale, and atMostOneFresh predicates: (i)\nin-transit messages are well-formed; (ii) there is at most one in-transit fresh message, and at most one node holding a lock; if a node holds a lock then all in-transit messages are stale; (iii) If node n holds the lock then the last Locked x was written in the trace by n, and x is the current epoch of n; (iv) if there exists a fresh in-transit message, then it was sent by the last node that output Locked x, and it carries the value x+ 1; (v) the trace obeys the ok_trace predicate.\nThe VCs generated for the modules of listings 5.3 and 5.4, proved automatically, establish the correctness of each system with respect to the specification of Listing 5.2: events are being logged in the specified way, and traces are consistent."
        },
        {
            "heading": "6 Locally Shared Memory Model",
            "text": "Dijkstra described certain distributed systems (including the self-stabilizing systems described below) using a guarded processes model, in which nodes/processes do not exchange messages, but instead have direct read access to each other\u2019s states. Although particular systems will only require read access to a limited set of states (typically its immediate neighbors\u2019), our model allows read access universally. This is not a shared-memory model in all generality, but it may be implemented over shared memory, with a single-writer multiple-reader data structure for each node\u2019s state (and readers\u2013writer locks for atomicity).\nWe formalize this in our setting as a model where worlds are simply of the form \u3008lS\u3009 with lS : N \u2192 \u03a3 a state-assigning function. A system based on this model is programmed by defining an enabling predicate on nodes and a handling function describing the behavior that can be executed whenever a node is enabled. Formally we will consider that the enabling predicate has signature ep(n : N, lS : N\u2192 \u03a3), taking as parameters a node and a global state assigning function, and the handling function has the following signature and contract:\nhandleE(h : N, lS : N\u2192 \u03a3) : (\u03c3 : \u03a3) requires ep(h, lS) \u2227 I\u3008lS\u3009 ensures I\u3008lS[h 7\u2192 \u03c3]}\u3009\nThe enabling predicate and the handler code have read access to every node\u2019s state, but the handler may only modify the state of the node where it is running. This semantics is given by the following rule:\nhandleE(h, lS) = \u03c3 ep(h, lS)\n\u3008lS\u3009 h \u3008lS[h 7\u2192 \u03c3]\u3009 (enabled)\nwhere h means that node h runs the handler. The contract of handleE ensures that executions of the (enabled) transition rule preserve the property I (the contract ensures this if the node is enabled, and the semantics only allow for transitions satisfying this requirement). We will write okI(ep, handleE) when the implementation of the handling function handleE adheres to its contract, with invariant I and enabling predicate ep. Listing 6.1 shows a simplified version of the Why3-do modelReadallEnabled module, including the following Lemma, proved using an induction transformation and SMT solvers.\nmodule World\ntype node, type state, type world = map node state end\nmodule Steps val predicate validNd (n:node) val function initState (node) : state constant initWorld : world = initState\nval ghost predicate indpred (w:world) ensures { w=initWorld -> result } val ghost predicate enabled (map node state) (i:node) requires { validNd i }\nfunction step_enbld (w:world) (n:node) (st:state) : world = set w n st\nval function handleEnbld (h:node) (lS:map node state) : state requires { validNd h /\\ enabled lS h /\\ indpred lS } ensures { indpred (step_enbld lS h result) }\ninductive step world node world = | step_enbld : forall w :world, n :node. validNd n -> enabled w n ->\nstep w n (step_enbld w n (handleEnbld n w))\nlemma indpred_step : forall w w\u2019 :world, n :node. step w n w\u2019 -> indpred w -> indpred w\u2019 lemma step_preserves_states : forall w w\u2019 :world, n i :node. step w n w\u2019 -> i<>n -> w i = w\u2019 i\n(* keeps track of number of transition steps *) inductive step_TR world world int = | base : forall w :world. step_TR w w 0 | step : forall w w\u2019 w\u2019\u2019 :world, n :node, steps :int.\nstep_TR w w\u2019 steps -> step w\u2019 n w\u2019\u2019 -> step_TR w w\u2019\u2019 (steps+1)\nlemma noNeg_step_TR : forall w w\u2019 :world, steps :int. step_TR w w\u2019 steps -> steps >= 0 lemma indpred_manySteps :\nforall w w\u2019 :world, steps :int . step_TR w w\u2019 steps -> indpred w -> indpred w\u2019\npredicate reachable (w:world) = exists steps :int. step_TR initWorld w steps lemma indpred_reachable : forall w :world. reachable w -> indpred w\nend Listing 6.1. Locally shared memory model: modelReadallEnabled\nLemma 3. Let w0, w \u2208W, with ep and I predicates such that okI(ep, handleE), w0 |= I, and w0 \u2217 w. Then w |= I.\nExample: Stabilizing Mutual Exclusion. Self-stabilizing systems [15,38] are designed to tolerate failures resulting from \u201chorrible errors\u201d (such as data corruption), by including a recovery mechanism. Given some notion of legal configuration, a system is said to be self-stabilizing if (i) starting from an illegal configuration, all executions eventually converge to a legal configuration (a liveness property), and (ii) legal configurations are closed under normal execution steps, i.e. no illegal configuration is reachable if no corruption of data occurs (a safety property). One of Dijkstra\u2019s examples of such a system in his seminal paper [15] was a directed ring of processes sharing a resource, with mutual exclusion enforced by means of a circulating token. Legal configurations are those in\nmodule SelfStab_Ring_Closure\ntype node = int val constant n_nodes : int axiom n_nodes_bounds : 2 < n_nodes let predicate validNd (n:node) = 0 <= n < n_nodes type state = int val constant k_states : int axiom k_states_lower_bound : n_nodes < k_states let function incre (x:state) : state = mod (x+1) k_states\nclone modelReadallEnabled.World with type node, type state\nlet function initState (n:node) : state = if n=n_nodes-1 then 1 else 0\npredicate has_token (lS:map node state) (i:node) = (i = 0 /\\ lS i = lS (n_nodes-1)) \\/ (i > 0 /\\ i < n_nodes /\\ lS i <> lS (i-1)) let ghost predicate enabled (lS:map node state) (i:node) = has_token lS i\nlet function handleEnbld (h:node) (lS:map node state) : state = if h = 0 then incre (lS (n_nodes-1)) else lS (h-1)\nlet rec ghost predicate atLeastOneToken (lS:map node state) (n:int) requires { validNd n } ensures { result <-> exists k :int. 0<=k<n /\\ has_token lS k } variant { n } = n > 0 && (has_token lS (n-1) || atLeastOneToken lS (n-1))\npredicate atMostOneToken (lS:map node state) (n:int) = validNd n -> forall i j :int. 0<=i<n -> 0<=j<n -> has_token lS i -> has_token lS j -> i=j\nlemma first_last : forall n: int, lS :map node state. n >= 0 -> (forall j :int. 0<j<=n -> lS j = lS (j-1)) -> lS 0 = lS n lemma atLeastOneTokenLm : forall w :world. atLeastOneToken w n_nodes\npredicate inv (lS:map node state) = (forall n :int. validNd n -> 0 <= lS n < k_states) /\\ atMostOneToken lS n_nodes let ghost predicate indpred (w:world) = inv w\nclone modelReadallEnabled.Steps with type node, type state, val validNd, val initState, val indpred, val enabled, val handleEnbld\npredicate oneToken (w:world) = atMostOneToken w n_nodes /\\ atLeastOneToken w n_nodes goal oneToken : forall w :world. reachable w -> oneToken w\nend Listing 6.2. Self-stabilizing mutual exclusion on a ring \u2013 Closure\nwhich exactly one process carries a token. In case of failure the system converges back into a single-token configuration. Dijkstra\u2019s proposal for self-stabilizing mutual exclusion was the following: processes have integer numbers in {0, . . .K\u22121} as states, with K greater than the size of the ring. Each process observes the state of its predecessor in the ring; the process with index 0 holds a token when its state is the same as that of its predecessor (the last process in the ring); other processes hold a token when their state is different from their predecessor\u2019s. When holding a token, each process may modify its state by copying its predecessor\u2019s state; node 0 additionally increments (modulo K) this state.\nListing 6.2 shows the Why3-do formalization of this system, based on the locally shared memory model. Nodes and states are both integers; n_nodes and k_states are the size of the ring and the number of different states. The en-\nabling predicate is defined as true for a node exactly when it is carrying a token, as specified by the has_token predicate. The handler defined by handleEnbld copies states as previously described. Mutual exclusion is expressed using predicates atLeastOneToken and atMostOneToken that apply to the first n nodes.\nThe module of Listing 6.2 verifies the closure property. The invariant expresses that node states are within bounds, and there is no more than one token in the ring. One possible (legal) initial configuration of the system is described by the initState let function. These definitions are instantiated when cloning modelReadallEnabled. The module ends with the oneToken goal, stating that there exists exactly one token in all reachable configurations.\nStepwise Bounded Validation. In the verification of closure we use the following technique: we introduce an axiom bounding the size of the system, passed to the solvers to make automated proofs easier (soundness of the verification may be compromised at this point). We then introduce parts of the invariant step by step, and check them in this bounded system in order to gain insight as to their validity. Once we feel confident about the elected invariant, we remove the bounding axiom to achieve soundness of the verification, possibly stating additional lemmas or strengthening the invariant. For the present system:\n1. We started with the following invariant. Inductiveness is proved automatically, but the oneToken goal cannot be proved from it (as expected): forall i :int. validNd i -> 0 <= lS i < k_states.\n2. Next, we included atMostOnetoken lS n_nodes in the invariant; preservation was proved automatically, but oneToken could still not be proved. We then added a bounding axiom n_nodes <= 10, which allowed the goal to be proved.\n3. We strengthened the invariant with atLeastOnetoken lS n_nodes and removed the bounding axiom. The oneToken goal was proved trivially; however, the VC pertaining to the preservation of the invariant could not be proved.\n4. Preservation could be proved by reintroducing a bound on n_nodes (with a bound of 1000, all VCs could be proved within 30 seconds in our setup).\nThese bounded proof results indicate that, in all likelihood, (i) the property atLeastOnetoken lS n_nodes is preserved by system transitions, and thus inductive, but (ii) it is not necessary to include it in the inductive invariant to prove oneToken: in our development the oneToken goal could be proved for a number of processes up to 10 without including the former property in the invariant. The reason for this is that in fact the atLeastOnetoken lS n_nodes property is satisfied by definition in all configurations: in order for a token to be present, either any two adjacent processes have different states, or the first and last processes have the same state. If all processes have the same state, then the second case holds. Including the property in the invariant still requires a bound (to prove preservation), but this can now have a much higher value (1000 rather than 10).\nAn unbounded proof is obtained by including in the module the first_last lemma (proved by induction on n). This allows for the goal to be proved automatically without atLeastOnetoken lS n_nodes in the invariant, and with no upper bound on n_nodes. We remark that the dual definition (recursive +\ncontract) of the atLeastOneToken let function was crucial for proving the goal automatically (this was not possible with a logic definition).\nThe convergence property is more challenging; its Why3-do formalization can be found in the artifact [28]. We have also verified Dijkstra\u2019s version of this system with a bidirectional array topology. Bounded exploration again allowed us to validate parts of the invariant; attaining an unbounded verification required strengthening the invariant, rather than a lemma."
        },
        {
            "heading": "7 Related Work",
            "text": "Deductive verification methods are typically based on first-order logic reasoning and focus on safety properties, with correctness proofs requiring users to manually provide appropriate invariants and to discharge (either automatically or interactively) proof obligations generated in the process. Invariants may apply to loops, recursive functions, or non-deterministic transition relations, and allow for correctness proofs by induction on the length of executions. In the last few years a number of frameworks and tools have been proposed for reasoning about asynchronous message-passing systems using inductive invariants, based on atomic handler models and different specification mechanisms. We will now briefly survey these and compare them with Why3-do in terms of design choices.\nVerdi [42] introduced the use of models based on worlds and atomic handlers, with models capturing different fault semantics. Why3-do\u2019s semantic framework is inspired by Verdi; we enrich handlers with interface specifications in the form of contracts, allowing for the use of methods that are standard in deductive verification of single-thread software. Verdi is a Coq development, and reasoning is carried out within the Coq proof assistant [22]. The implementation of our\nframework as a Why3 library allows for the use of automated tools (all the proofs in this paper use SMT solvers and a few Why3 transformations).\nWhereas Verdi handlers are defined in a purely functional style, in Why3do they are written in WhyML, combining functional and imperative features. Verdi supports system transformations that allow for verified systems to be obtained from systems verified with simpler models (additional mechanisms may be automatically introduced to compensate for the presence of faults). Transformations are verified once and for all, so the resulting systems do not need to be verified. An important difference is that Verdi targets exclusively messagepassing systems, whereas Why3-do covers different system models. Verdi supports traces, but specifications may not be written in a completely abstract, model-independent way. In Why3-do this is achieved through the use of clonable specification modules defining commit specifications and trace consistency.\nThe IronFleet [20] platform is built on top of a deductive verification tool, Dafny [26], which uses the Z3 [31] SMT solver for proofs. Like Verdi, it supports only message-passing systems. A major difference with respect to Why3-do and Verdi is that, instead of a specification mechanism based on traces, IronFleet separates development in a specification level (where worlds are viewed abstractly) and a concrete protocol level, both described in FOL as state machines. A refinement function [1] maps protocol worlds to the specification level, and a refinement proof shows that protocol steps are compatible with the abstract behavior (in Why3-do this is achieved by trace consistency proofs). There is a third, implementation level, where event handlers are programmed using mutable data structures and machine types, for performance and realism. IronFleet extends Dafny with a UDP specification to support networking, which allows non-atomic handlers to be developed assuming low-level interleaving. In order to establish refinement proofs between low-level implementations and protocols, reductionbased reasoning is supported. IronFleet also includes an embedding of TLA that makes possible reasoning about liveness properties. It is overall an ambitious tool that has been used by its authors to verify practical systems.\nUp to a point Why3-do implementations cover both the protocol and implementation levels, since WhyML accommodates both functional programs and stateful code with mutable structures and machine types. Why3 supports code extraction from verified WhyML programs, and it should not be difficult to obtain a distributed implementation from a verified Why3-do system, using one of the available OCaml libraries. Our framework allows for diverse system models, with different implementation infrastructure requirements. In general each node must run a scheduler that will, for instance, receive incoming local inputs and messages from the network, check enabling predicates, and run the appropriate handlers, reflecting locally and globally the effects prescribed by the semantics.\nThe Ivy tool [34] differs from Why3-do and the previous frameworks in several important ways. It uses a dedicated modeling/programming language called RML, and a logic language restricted to the effectively propositional (EPR) class of formulas, whose satisfiability is decidable (Ivy also uses Z3). Specifications may refer to any part of the model (no specification/protocol distinct layers or\nobservation traces are used). The use of EPR imposes severe restrictions: RML does not allow arithmetic operations, so for instance a ring topology cannot be modeled using integer modulo arithmetic. A verification methodology based on the use of EPR, and details on how it has been used to verify variants of the PAXOS protocol, are extensively described in [33] (the method proposed for reducing quantifier alternation is of general interest, even when unrestricted FOL is used). Leveraging the decidability of the logic, Ivy focuses on assisting the user in writing the protocol and its specification, and in discovering adequate inductive invariants. A few initial steps of execution are first considered, which may allow for bugs to be found in the protocol and/or target properties; Ivy then assists the user in finding an inductive invariant by performing interactive strengthening and generalization steps, and representing states visually.\nA more general, comprehensive framework for reasoning about distributed systems has been constructed around the TLA+ specification language, based on the Temporal Logic of Actions [25]. TLA+ is without any doubt a widely successful toolset, and its adoption in practice is well documented [32]. The toolset comprises the specification language itself; the PlusCal algorithmic language; the TLC model checker [43]; the TLAPS proof system [8]; and a development environment. Correctness proofs are based on the notion of refinement mapping [1]. If one writes a TLA+ specification and a PlusCal implementation, and then translates the latter to TLA+, its correctness can be stated as a refinement problem, whose VC is itself written as a TLA+ formula. The TLAPS proof system is an ongoing effort but can already be used to prove many such refinements. TLAPS proofs [12] are constructed using both proof assistants and SMT solvers.\nTable 7.1 summarizes the distinctive aspects of the discussed tools. Additionally, the I4 technique has been proposed [29] based on the automatic synthesis (by model checking) of inductive invariants for small instances of protocols, followed by their generalization. Invariants are checked with Ivy, and if necessary the process is repeated, considering a bigger instance or a pruned invariant. Kaizen [23] is a verified blockchain system that has been developed using an approach similar to IronFleet. Implementations of distributed systems that have been formally verified using different tools have been empirically scrutinized in [19].\nProgram logics for distributed systems have also been the subject of recent work, typically based on or inspired by concurrent separation logics [6], and mechanized in the Coq proof assistant. Notable examples include Disel [39], which focuses on modularity and compositionality, and Aneris [24], which includes support for node-level concurrency in addition to inter-node reasoning. ModP [14] is an actor-based compositional programming framework that offers assume-guarantee reasoning principles to support compositional system testing.\nThe self-stabilizing ring system has been verified interactively using the PVS [35] and Isabelle [30] proof assistants, and also by symbolic model checking [41,9]. A general framework for building certified proofs of self-stabilizing algorithms (using Coq) is described in [3]."
        },
        {
            "heading": "8 Conclusion",
            "text": "In this paper we have proposed principles for contract-based verification of distributed systems, based on a library promoting modular development. The approach enables the use of state of the art sequential software verifiers for reasoning about distributed systems, supports model-independent trace specifications, and is uniform across system models, beyond the message-passing setting.\nTo implement these principles we have chosen the Why3 verification platform. We have shown how specific features of Why3, such as the ability to interface with different solvers and the use of dual definitions, contribute to successful automated proofs. For instance, we were able to prove the inductiveness of an invariant for the leader election protocol containing a quantifier \u2018alternation\u2019 (a sequence of the form \u2200\u2203 [33], outside the decidable EPR logic). In particular, the Alt-Ergo and Vampire solvers were able to prove these VCs, whereas Z3 and CVC4 failed (with a generous timeout value). On the other hand, the dual definition of the atLeastOneToken predicate in the self-stabilization systems, when the invariant included this predicate containing an existential quantifier, allowed Z3 or CVC4 (not the other solvers) to prove inductiveness. In neither case was it necessary to employ invariant quantifier hiding, as in [20].\nUnbounded domains (nodes, messages, etc.) are typical of distributed systems. Considering bounded systems, in combination with dual definitions, allowed us to explore the inductiveness of invariant properties before tackling the unbounded case (by strengthening invariants or writing lemmas). This should not be mistaken with the use of bounded verification in Ivy, which considers the first few system steps in order to debug models, or in I4, which produces finite quantifier-free instances of problems, amenable to model checking.\nThe limitations of the framework are that, in the spirit of verification of sequential programs with Why3, Why3-do targets the verification of distributed systems at the algorithmic level, and is not intended for reasoning about executable implementations (but see the discussion on implementation extraction in Section 7). Also, no support for reasoning with non-atomic handlers is included.\nWhy3 is a stable tool, actively developed by a solid team, with a growing user community and very low risk of obsolescence. It is being successfully used for formal verification in contexts as diverse as safety-critical programming [2], multicore schedulers [27], or blockchain smart contracts [37,40]. Why3-do brings Why3\u2019s strengths in terms of usability and proof engineering to the mechanical verification of distributed systems, making it available to a wider community.\nAcknowledgments. The development of Why3-do was initiated during a visit of the second author to the Toccata team at Inria Saclay-\u0302Ile-de-France/LRI Univ Paris-Saclay/CNRS and greatly benefited from the team\u2019s hospitality and Why3 expertise. This work is financed by the ERDF \u2013 European Regional Development Fund through the North Portugal Regional Operational Programme - NORTE 2020 Programme and by National Funds through the Portuguese funding agency, FCT - Fundac\u0327a\u0303o para a Cie\u0302ncia e a Tecnologia within project NORTE-01-0145FEDER-028550 - PTDC/EEI-COM/28550/2017."
        }
    ],
    "title": "Why3-do: The Way of Harmonious Distributed System Proofs",
    "year": 2022
}