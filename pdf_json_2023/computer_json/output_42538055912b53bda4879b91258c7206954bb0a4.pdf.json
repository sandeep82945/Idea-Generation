{
    "abstractText": "The directed acyclic word graph (DAWG) of a string y of length n is the smallest (partial) DFA which recognizes all suffixes of y with only O(n) nodes and edges. In this paper, we show how to construct the DAWG for the input string y from the suffix tree for y, in O(n) time for integer alphabets of polynomial size in n. In so doing, we first describe a folklore algorithm which, given the suffix tree for y, constructs the DAWG for the reversed string \u0177 in O(n) time. Then, we present our algorithm that builds the DAWG for y in O(n) time for integer alphabets, from the suffix tree for y. We also show that a straightforward modification to our DAWG construction algorithm leads to the first O(n)-time algorithm for constructing the affix tree of a given string y over an integer alphabet. Affix trees are a text indexing structure supporting bidirectional pattern searches. We then discuss how our constructions can lead to linear-time algorithms for building other text indexing structures, such as linear-size suffix tries and symmetric CDAWGs in linear time in the case of integer alphabets. As a further application to our O(n)-time DAWG construction algorithm, we show that the set MAW(y) of all minimal absent words (MAWs) of y can be computed in optimal, inputand output-sensitive O(n+ |MAW(y)|) time and O(n) working space for integer alphabets.",
    "authors": [
        {
            "affiliations": [],
            "name": "Yuta Fujishigea"
        },
        {
            "affiliations": [],
            "name": "Yuki Tsujimaruc"
        },
        {
            "affiliations": [],
            "name": "Shunsuke Inenagaa"
        },
        {
            "affiliations": [],
            "name": "Hideo Bannaid"
        },
        {
            "affiliations": [],
            "name": "Masayuki Takedaa"
        }
    ],
    "id": "SP:f3e4e4c4bd750b757a2c241b52f033245d660a45",
    "references": [
        {
            "authors": [
                "P. Weiner"
            ],
            "title": "Linear pattern matching algorithms",
            "venue": "in: 14th Annual Symposium on Switching and Automata Theory",
            "year": 1973
        },
        {
            "authors": [
                "U. Manber",
                "E.W. Myers"
            ],
            "title": "Suffix arrays: A new method for on-line string searches",
            "venue": "SIAM J. Comput. 22 (5) ",
            "year": 1993
        },
        {
            "authors": [
                "K. Sadakane"
            ],
            "title": "New text indexing functionalities of the compressed suffix arrays",
            "venue": "J. Algorithms 48 (2) ",
            "year": 1016
        },
        {
            "authors": [
                "R. Grossi",
                "J.S. Vitter"
            ],
            "title": "Compressed suffix arrays and suffix trees with applications to text indexing and string matching",
            "venue": "SIAM J. Comput. 35 (2) ",
            "year": 2005
        },
        {
            "authors": [
                "K. Sadakane"
            ],
            "title": "Compressed suffix trees with full functionality",
            "venue": "Theory Comput. Syst. 41 (4) ",
            "year": 2007
        },
        {
            "authors": [
                "A. Blumer",
                "J. Blumer",
                "D. Haussler",
                "A. Ehrenfeucht",
                "M.T. Chen",
                "J.I. Seiferas"
            ],
            "title": "The smallest automaton recognizing the subwords of a text",
            "venue": "Theoretical Computer Science 40 ",
            "year": 1985
        },
        {
            "authors": [
                "M. Crochemore"
            ],
            "title": "Transducers and repetitions",
            "venue": "Theor. Comput. Sci. 45 (1) ",
            "year": 1986
        },
        {
            "authors": [
                "A. Blumer",
                "J. Blumer",
                "D. Haussler",
                "R.M. McConnell",
                "A. Ehrenfeucht"
            ],
            "title": "Complete inverted files for efficient text retrieval and analysis",
            "venue": "Journal of the ACM 34 (3) ",
            "year": 1987
        },
        {
            "authors": [
                "J. Stoye"
            ],
            "title": "Affix trees",
            "venue": "Tech. Rep. Report 2000-04, Universit\u00e4t Bielefeld ",
            "year": 2000
        },
        {
            "authors": [
                "M.G. Maa\u00df"
            ],
            "title": "Linear bidirectional on-line construction of affix trees",
            "venue": "Algorithmica 37 (1) ",
            "year": 2003
        },
        {
            "authors": [
                "E.M. McCreight"
            ],
            "title": "A space-economical suffix tree construction algorithm",
            "venue": "Journal of the ACM 23 (2) ",
            "year": 1976
        },
        {
            "authors": [
                "M. Farach-Colton",
                "P. Ferragina",
                "S. Muthukrishnan"
            ],
            "title": "On the sorting-complexity of suffix tree construction",
            "venue": "Journal of the ACM 47 (6) ",
            "year": 2000
        },
        {
            "authors": [
                "K. Narisawa",
                "S. Inenaga",
                "H. Bannai",
                "M. Takeda"
            ],
            "title": "Efficient computation of substring equivalence classes with suffix arrays",
            "venue": "in: Proc. CPM 2007",
            "year": 2007
        },
        {
            "authors": [
                "M. Crochemore",
                "C. Epifanio",
                "R. Grossi",
                "F. Mignosi"
            ],
            "title": "Linear-size suffix tries",
            "venue": "Theoretical Computer Science 638 ",
            "year": 2016
        },
        {
            "authors": [
                "M.T. Chen",
                "J. Seiferas"
            ],
            "title": "Efficient and elegant subword-tree construction",
            "venue": "Combinatorial Algorithms on Words ",
            "year": 1985
        },
        {
            "authors": [
                "M. Crochemore",
                "F. Mignosi",
                "A. Restivo",
                "S. Salemi"
            ],
            "title": "Text compression using antidictionaries",
            "venue": "in: ICALP 1999",
            "year": 1999
        },
        {
            "authors": [
                "T. Ota",
                "H. Morita"
            ],
            "title": "On a universal antidictionary coding for stationary ergodic sources with finite alphabet",
            "venue": "in: ISITA 2014",
            "year": 2014
        },
        {
            "authors": [
                "G. Hampikian",
                "T.L. Andersen"
            ],
            "title": "Absent sequences: Nullomers and primes",
            "venue": "in: PSB 2007",
            "year": 2007
        },
        {
            "authors": [
                "J. Herold",
                "S. Kurtz",
                "R. Giegerich"
            ],
            "title": "Efficient computation of absent words in genomic sequences",
            "venue": "BMC Bioinformatics 9 ",
            "year": 2008
        },
        {
            "authors": [
                "Z. Wu",
                "T. Jiang",
                "W. Su"
            ],
            "title": "Efficient computation of shortest absent words in a genomic sequence",
            "venue": "Inf. Process. Lett. 110 (14-15) ",
            "year": 2010
        },
        {
            "authors": [
                "R.M. Silva",
                "D. Pratas",
                "L. Castro",
                "A.J. Pinho",
                "P.J.S.G. Ferreira"
            ],
            "title": "Three minimal sequences found in ebola virus genomes and absent from human DNA",
            "venue": "Bioinformatics 31 (15) ",
            "year": 2015
        },
        {
            "authors": [
                "P. Charalampopoulos",
                "M. Crochemore",
                "G. Fici",
                "R. Mercas",
                "S.P. Pissis"
            ],
            "title": "Alignmentfree sequence comparison using absent words",
            "venue": "Inf. Comput. 262 ",
            "year": 2018
        },
        {
            "authors": [
                "Y. Almirantis",
                "P. Charalampopoulos",
                "J. Gao",
                "C.S. Iliopoulos",
                "M. Mohamed",
                "S.P. Pissis",
                "D. Polychronopoulos"
            ],
            "title": "On avoided words",
            "venue": "absent words, and their application to biological sequence analysis, Algorithms for Molecular Biology 12 (1) ",
            "year": 2017
        },
        {
            "authors": [
                "A. H\u00e9liou",
                "S.P. Pissis",
                "S.J. Puglisi"
            ],
            "title": "emMAW: computing minimal absent words in external memory",
            "venue": "Bioinformatics 33 (17) ",
            "year": 2017
        },
        {
            "authors": [
                "M. Crochemore",
                "F. Mignosi",
                "A. Restivo"
            ],
            "title": "Automata and forbidden words",
            "venue": "Information Processing Letters 67 (3) ",
            "year": 1998
        },
        {
            "authors": [
                "F. Mignosi",
                "A. Restivo",
                "M. Sciortino"
            ],
            "title": "Words and forbidden factors",
            "venue": "Theor. Comput. Sci. 273 (1-2) ",
            "year": 2002
        },
        {
            "authors": [
                "C. Barton",
                "A. H\u00e9liou",
                "L. Mouchard",
                "S.P. Pissis"
            ],
            "title": "Linear-time computation of minimal absent words using suffix array",
            "venue": "BMC Bioinformatics 15 ",
            "year": 2014
        },
        {
            "authors": [
                "C. Barton",
                "A. H\u00e9liou",
                "L. Mouchard",
                "S.P. Pissis"
            ],
            "title": "Parallelising the computation of minimal absent words",
            "venue": "in: PPAM 2015",
            "year": 2015
        },
        {
            "authors": [
                "D. Belazzougui",
                "F. Cunial",
                "J. K\u00e4rkk\u00e4inen",
                "V. M\u00e4kinen"
            ],
            "title": "Versatile succinct representations of the bidirectional Burrows-Wheeler transform",
            "venue": "in: Proc. ESA 2013",
            "year": 2013
        },
        {
            "authors": [
                "D. Belazzougui",
                "F. Cunial"
            ],
            "title": "Fully-functional bidirectional Burrows-Wheeler indexes and infinite-order de Bruijn graphs",
            "venue": "in: CPM 2019",
            "year": 2019
        },
        {
            "authors": [
                "P. Charalampopoulos",
                "M. Crochemore",
                "S.P. Pissis"
            ],
            "title": "On extended special factors of a word",
            "venue": "in: SPIRE 2018",
            "year": 2018
        },
        {
            "authors": [
                "G. Fici",
                "P. Gawrychowski"
            ],
            "title": "Minimal absent words in rooted and unrooted trees",
            "venue": "in: SPIRE 2019, Vol. 11811 of Lecture Notes in Computer Science",
            "year": 2019
        },
        {
            "authors": [
                "S. Inenaga"
            ],
            "title": "Suffix trees",
            "venue": "DAWGs and CDAWGs for forward and backward tries, in: LATIN 2020, Vol. 12118 of Lecture Notes in Computer Science",
            "year": 2020
        },
        {
            "authors": [
                "S. Inenaga"
            ],
            "title": "Towards a complete perspective on labeled tree indexing: New size bounds",
            "venue": "efficient constructions, and beyond, J. Inf. Process. 29 ",
            "year": 2021
        },
        {
            "authors": [
                "T. Akagi",
                "K. Okabe",
                "T. Mieno",
                "Y. Nakashima",
                "S. Inenaga"
            ],
            "title": "Minimal absent words on run-length encoded strings",
            "venue": "in: CPM 2022, Vol. 223 of LIPIcs",
            "year": 2022
        },
        {
            "authors": [
                "Y. Fujishige",
                "Y. Tsujimaru",
                "S. Inenaga",
                "H. Bannai",
                "M. Takeda"
            ],
            "title": "Computing DAWGs and minimal absent words in linear time for integer alphabets",
            "venue": "in: MFCS 2016",
            "year": 2016
        },
        {
            "authors": [
                "S. Inenaga",
                "H. Hoshino",
                "A. Shinohara",
                "M. Takeda",
                "S. Arikawa",
                "G. Mauri",
                "G. Pavesi"
            ],
            "title": "Online construction of compact directed acyclic word graphs",
            "venue": "Discrete Applied Mathematics 146 (2) ",
            "year": 2005
        },
        {
            "authors": [
                "J. Fischer",
                "P. Gawrychowski"
            ],
            "title": "Alphabet-dependent string searching with wexponential search trees",
            "venue": "CoRR abs/1302.3347 ",
            "year": 2013
        },
        {
            "authors": [
                "D. Breslauer",
                "R. Hariharan"
            ],
            "title": "Optimal parallel construction of minimal suffix and factor automata",
            "venue": "Parallel Processing Letters 6 (1) ",
            "year": 1996
        },
        {
            "authors": [
                "D. Hendrian",
                "T. Takagi",
                "S. Inenaga"
            ],
            "title": "Online algorithms for constructing linear-size suffix trie",
            "venue": "in: CPM 2019",
            "year": 2019
        },
        {
            "authors": [
                "D. Hendrian",
                "T. Takagi",
                "S. Inenaga",
                "K. Goto",
                "M. Funakoshi"
            ],
            "title": "Linear time online algorithms for constructing linear-size suffix trie",
            "venue": "CoRR abs/2301.04295 ",
            "year": 2023
        }
    ],
    "sections": [
        {
            "text": "The directed acyclic word graph (DAWG) of a string y of length n is the smallest (partial) DFA which recognizes all suffixes of y with only O(n) nodes and edges. In this paper, we show how to construct the DAWG for the input string y from the suffix tree for y, in O(n) time for integer alphabets of polynomial size in n. In so doing, we first describe a folklore algorithm which, given the suffix tree for y, constructs the DAWG for the reversed string y\u0302 in O(n) time. Then, we present our algorithm that builds the DAWG for y in O(n) time for integer alphabets, from the suffix tree for y. We also show that a straightforward modification to our DAWG construction algorithm leads to the first O(n)-time algorithm for constructing the affix tree of a given string y over an integer alphabet. Affix trees are a text indexing structure supporting bidirectional pattern searches. We then discuss how our constructions can lead to linear-time algorithms for building other text indexing structures, such as linear-size suffix tries and symmetric CDAWGs in linear time in the case of integer alphabets. As a further application to our O(n)-time DAWG construction algorithm, we show that the set MAW(y) of all minimal absent words (MAWs) of y can be computed in optimal, input- and output-sensitive O(n+ |MAW(y)|) time and O(n) working space for integer alphabets.\nKeywords: string algorithms, DAWGs, suffix trees, affix trees, CDAWGs, minimal absent words"
        },
        {
            "heading": "1. Introduction",
            "text": ""
        },
        {
            "heading": "1.1. Constructing DAWGs for integer alphabets",
            "text": "Text indexes are fundamental data structures that allow for efficient processing of string data, and have been extensively studied. Although there are several alternative data structures which can be used as an index, such as suffix trees [1] and suffix arrays [2] (and their compressed versions [3, 4, 5]), in this paper, we focus on directed acyclic word graphs (DAWGs) [6], which are a fundamental data structure for string processing. Intuitively, the DAWG of string y, denoted DAWG(y), is an edge-labeled DAG obtained by merging isomorphic subtrees of the trie representing all suffixes of string y, called the suffix trie of y. Hence, DAWG(y) can be seen as an automaton recognizing all suffixes of y. Let n be the length of the input string y.\nEmail addresses: inenaga.shunsuke.380@m.kyushu-u.ac.jp (Shunsuke Inenaga), hdbn.dsc@tmd.ac.jp (Hideo Bannai)\nPreprint submitted to Elsevier July 6, 2023\nar X\niv :2\n30 7.\n01 42\n8v 1\n[ cs\n.D S]\n4 J\nul 2\nDespite the fact that the number of nodes and edges of the suffix trie is \u2126(n2) in the worst case, Blumer et al. [6] proved that, surprisingly, DAWG(y) has at most 2n\u2212 1 nodes and 3n\u2212 4 edges for n > 2. Crochemore [7] showed that DAWG(y) is the smallest (partial) automaton recognizing all suffixes of y, namely, the sub-tree merging operation which transforms the suffix trie to DAWG(y) indeed minimizes the automaton.\nSince DAWG(y) is a DAG, more than one string can be represented by the same node in general. It is known that every string represented by the same node of DAWG(y) has the same set of ending positions in the string y. Due to this property, if z is the longest string represented by a node v of DAWG(y), then any other string represented by the node v is a proper suffix of z. Hence, the suffix link of each non-root node of DAWG(y) is well-defined; if ax is the shortest string represented by node v where a is a single character and x is a string, then the suffix link of ax points to the node of DAWG(y) that represents string x.\nOne of the most intriguing properties of DAWGs is that the suffix links of DAWG(y) for any string y forms the suffix tree [1] of the reversed string of y. Hence, DAWG(y) augmented with suffix links can be seen as a bidirectional text indexing data structure. This line of research was followed by other types of bidirectional text indexing data structures such as symmetric compact DAWGs (SCDAWGs) [8] and affix trees [9, 10]."
        },
        {
            "heading": "1.1.1. Our Contributions to Text Indexing Constructions",
            "text": "Time complexities for constructing text indexing data structures depend on the underlying alphabet. See Table 1. For a given string y of length n over an ordered alphabet of size \u03c3, the suffix tree [11], the suffix array [2], the DAWG, and the compact DAWGs (CDAWGs) [8] of y can all be constructed in O(n log \u03c3) time. Here, we recall that the CDAWG of a string y is a path-compressed version of the DAWG for y, or equivalently, the CDAWG of y is a DAG obtained by merging isomorphic subtrees of the suffix tree of y. The aforementioned bounds immediately lead to O(n)-time construction algorithms for constant-size alphabets.\nIn this paper, we are particularly interested in input strings of length n over an integer alphabet of polynomial size in n. Farach-Colton et al. [12] proposed the first O(n)-time suffix tree construction algorithm for integer alphabets. Since the out-edges of every node of the suffix tree constructed by McCreight\u2019s [11] and Farach-Colton et al.\u2019s algorithms are lexicographically sorted, and since sorting is an obvious lower-bound for constructing edge-sorted suffix trees, the above-mentioned suffix-tree construction algorithms are optimal for ordered and integer alphabets, respectively. Since the suffix array of y can be easily obtained in O(n) time from the edge-sorted suffix tree of y, suffix arrays can also be constructed in optimal time. In addition, since the edge-sorted suffix tree of y can easily be constructed in O(n) time from\nthe edge-sorted CDAWG of y, and since the edge-sorted CDAWG of y can be constructed in O(n) time from the edge-sorted DAWG of y [8], sorting is also a lower-bound for constructing edge-sorted DAWGs and edge-sorted CDAWGs. Using the technique of Narisawa et al. [13], edge-sorted CDAWGs can be constructed in optimal O(n) time for integer alphabets. On the other hand, the only known algorithm to construct DAWGs was Blumer et al.\u2019s O(n log \u03c3)-time online algorithm [6] for ordered alphabets of size \u03c3, which results in O(n log n)-time DAWG construction for integer alphabets. In this paper, we show that the gap between the upper and lower bounds for DAWG construction can be closed, by introducing how to construct edge-sorted DAWGs in O(n) time for integer alphabets, in two alternative ways.\nIt is known that the suffix tree can be augmented with Weiner links, which are a generalization of the reversed suffix links. The DAG consisting of the nodes of the suffix tree for a string y and its Weiner links coincides with the DAWG of the reversed string y\u0302 [6, 15]. In this paper, we first describe an O(n)-time folklore algorithm which computes the sorted Weiner links for integer alphabets, given that the suffix tree of the string is already computed. This immediately gives us an O(n)-time algorithm for constructing the edge-sorted DAWG for the reversed string y\u0302 over an integer alphabet.\nIt was still left open whether one could efficiently construct the DAWG for a string y from the suffix tree for y, in the case of integer alphabets. We close this question by proposing an O(n)-time algorithm that builds the edge-sorted DAWG for the input (forward) string y. Our algorithm builds DAWG(y) for a given string y by transforming the suffix tree of y to DAWG(y). In other words, our algorithm simulates the minimization of the suffix trie of y to DAWG(y) using only O(n) time and space. Our algorithm also computes the suffix links of the DAWG, and can thus be applied to various kinds of string processing problems. This also means that we can construct the suffix tree for the reversed string y\u0302, as a byproduct.\nA simple modification to our O(n)-time DAWG construction algorithm also leads us to the first O(n)-time algorithm to construct edge-sorted affix trees for integer alphabets. We remark that the previous best known affix-tree construction algorithm of Maa\u00df [10] requires O(n log n) time for integer alphabets.\nIn addition, we show that our construction algorithms for DAWGs and affix trees lead to linear-time constructions of other indexing structures such as symmetric CDAWGs [8] and linear-size suffix tries [14] in the case of integer alphabets."
        },
        {
            "heading": "1.2. Computing Minimal Absent Words for Integer Alphabets",
            "text": "As yet another application of our O(n)-time DAWG construction algorithm, we present an optimal time algorithm to compute minimal absent words for a given string. There are a number of applications to minimal absent words, including data compression [16, 17] and molecular biology [18, 19, 20, 21, 22, 23, 24]. Hence, it is important to develop efficient algorithms for computing minimal absent words from a given string.\nLet MAW(y) be the set of minimal absent words of a string y. Crochemore et al. [25] proposed an algorithm to compute MAW(y) in \u0398(n\u03c3) time and O(n) working space. Their algorithm first constructs DAWG(y) with suffix links in O(n log \u03c3) time and computes MAW(y) in \u0398(n\u03c3) time using DAWG(y) and its suffix links. Since |MAW(y)| = O(n\u03c3) [26], the output size |MAW(y)| is hidden in the running time of their algorithm.\nLater, Barton et al. proposed an alternative algorithm that computes MAW(y) using the suffix array, in \u0398(n\u03c3) time and space [27]. The algorithm presented in [28] can be seen as a parallel version of this Barton et al.\u2019s algorithm using suffix arrays. While all of these\nalgorithms achieve O(n) running time in the case of constant-size alphabets (\u03c3 \u2208 O(1)), it can require O(n2) time when \u03c3 \u2208 \u2126(n).\nMignosi et al. [26] gave a tight bound on |MAW(y)| such that \u03c3 \u2264 |MAW(y)| \u2264 (\u03c3y \u2212 1)(|y| \u2212 1) + \u03c3, where \u03c3 is the size of the underlying alphabet and \u03c3y is the number of distinct characters occurring in y. However, |MAW(y)| can be o(n\u03c3) for many strings. Thus, it is important to develop an algorithm whose running time is output-sensitive, namely, linear in the output size |MAW(y)|.\nIn this paper, we show that MAW(y) can be computed in optimal O(n+ |MAW(y)|) time given that the edge-sorted DAWG of y is already computed. In more detail, given the edgesorted DAWG for y, which can be computed in O(n) time as above, our algorithm computes MAW(y) in O(n + |MAW(y)|) optimal time. We remark that our algorithm for computing MAW(y) itself works within this time for general ordered alphabets.\nOur algorithm is a modification of Crochemore et al.\u2019s algorithm [25] for finding MAW(y). We emphasize that for non-constant-size alphabets Crochemore et al.\u2019s algorithm takes superlinear time in terms of the input string length independently of the output size |MAW(y)|, and thus our result greatly improves the efficiency for integer alphabets."
        },
        {
            "heading": "1.2.1. Other efficient algorithms for computing MAWs",
            "text": "Belazzougui et al. [29] showed that using a representation of the bidirectional BWT of the input string y of length n, MAW(y) can be computed in O(n+ |MAW(y)|) time. Although the construction time for the representation of the bidirectional BWT was not given in [29], it was later shown by Belazzougui and Cunial [30] that the bidirectional BWT of a given string y over an integer alphabet can be incrementally constructed in O(n) time.\nIndependently of our work, Charalampopoulos et al. [31] proposed an O(n)-space data structure which, given a positive integer l, computes the set MAWl(y) of all minimal absent words of length l in O(1 + |MAWl(y)|) query time. This data structure can be constructed in O(n) time and space. By querying this data structure for all possible l = 1, . . . , n+ 1, one can compute MAW(y) = \u22c3n+1 l=1 MAWl(y) in O(n+ |MAW(y)|) total time.\nFici and Gawrychowski [32] showed an optimal O(N + |MAW(T )|)-time algorithm for computing all MAWs for a rooted tree T of size N in the case of integer alphabets. It is known that the DAWG of a tree of size N can have \u2126(N2) edges while its number of nodes is still O(N) [33, 34]. Instead of explicitly building the DAWG for T , the algorithm of Fici and Gawrychowski [32] simulates DAWG transitions by cleverly using lowest common ancestor queries on the suffix tree of the reversed input tree T\u0302 . In this view, their method can be seen as a tree input version of our linear-time algorithm for computing MAWs.\nRecently, Akagi et al. [35] proposed a space-efficient representation of all MAWs for the input string y which is based on the run length encoding (RLE ). Their data structure takes O(m) space and can output all MAWs in O(|MAW(y)|) time, where m is the RLE size of y.\nNew Materials\nA preliminary version of this paper appeared in [36]. Below is a list of the new materials in this full version:\n\u2022 A clear description of the folklore linear-time construction of DAWG(y\u0302) for the reversed input string y\u0302 from the suffix tree for the input string y (Section 3);\n\u2022 The observation that our linear-time affix tree construction algorithm can also build DAWG(y\u0302) for the reversed input string y\u0302 (Section 6.1);\n\u2022 The first linear-time construction of symmetric CDAWGs in the case of integer alphabets (Section 6.2);\n\u2022 The first linear-time construction of linear-size suffix tries in the case of integer alphabets (Section 6.3)."
        },
        {
            "heading": "2. Preliminaries",
            "text": ""
        },
        {
            "heading": "2.1. Strings",
            "text": "Let \u03a3 denote the alphabet. An element of \u03a3\u2217 is called a string. Let \u03b5 denote the empty string, and let \u03a3+ = \u03a3\u2217 \\{\u03b5}. For any string y, we denote its length by |y|. For any 1 \u2264 i \u2264 |y|, we use y[i] to denote the ith character of y. For any string y, let y\u0302 denote the reversed string of y. If y = uvw with u, v, w \u2208 \u03a3\u2217, then u, v, and w are said to be a prefix, substring, and suffix of y, respectively. For any 1 \u2264 i \u2264 j \u2264 |y|, y[i..j] denotes the substring of y which begins at position i and ends at position j. For convenience, let y[i..j] = \u03b5 if i > j. Let Substr(y) and Suffix(y) denote the set of all substrings and that of all suffixes of y, respectively.\nThroughout this paper, we will use y to denote the input string. For any string x \u2208 \u03a3\u2217, we define the sets of beginning and ending positions of occurrences of x in y, respectively, by\nBegPos(x) = {i | i \u2208 [1, |y| \u2212 |x|+ 1], y[i..i+ |x| \u2212 1] = x}, EndPos(x) = {i | i \u2208 [|x|, |y|], y[i\u2212 |x|+ 1..i] = x}.\nFor any strings u, v, we write u \u2261L v (resp. u \u2261R v) when BegPos(u) = BegPos(v) (resp. EndPos(u) = EndPos(v)). For any string x \u2208 \u03a3\u2217, the equivalence classes with respect to \u2261L and \u2261R to which x belong, are respectively denoted by [x]L and [x]R. Also, \u2212\u2192x and \u2190\u2212x respectively denote the longest elements of [x]L and [x]R.\nFor any set S of strings where no two strings are of the same length, let long(S) = argmax{|x| | x \u2208 S} and short(S) = argmin{|x| | x \u2208 S}.\nIn this paper, we assume that the input string y of length n is over the integer alphabet [1, nc] for some constant c, and that the last character of y is a unique character denoted by $ that does not occur elsewhere in y. Our model of computation is a standard word RAM of machine word size log2 n. Space complexities will be evaluated by the number of words (not bits)."
        },
        {
            "heading": "2.2. Suffix trees and DAWGs",
            "text": "Suffix trees [1] and directed acyclic word graphs (DAWGs) [6] are fundamental text data structures. Both of these data structures are based on suffix tries. The suffix trie for string y, denoted STrie(y), is a trie representing Substr(y), formally defined as follows.\nDefinition 1. STrie(y) for string y is an edge-labeled rooted tree (VT,ET) such that\nVT = {x | x \u2208 Substr(y)} ET = {(x, b, xb) | x, xb \u2208 VT, b \u2208 \u03a3}.\nThe second element b of each edge (x, b, xb) is the label of the edge. We also define the set LT of labeled \u201creversed\u201d edges called the suffix links of STrie(y) by\nLT = {(ax, a, x) | x, ax \u2208 Substr(y), a \u2208 \u03a3}.\nAs can be seen in the above definition, each node v of STrie(y) can be identified with the substring of y that is represented by v. Assuming that string y terminates with a unique character that appears nowhere else in y, for each non-empty suffix y[i..|y|] \u2208 Suffix(y) there is a unique leaf \u2113i in STrie(y) such that the suffix y[i..|y|] is spelled out by the path from the root to \u2113i.\nIt is well known that STrie(y) may require \u2126(n2) space. One idea to reduce its space to O(n) is to contract each path consisting only of non-branching edges into a single edge labeled with a non-empty string. This leads to the suffix tree STree(y) of string y. Following conventions from [8, 37], STree(y) is defined as follows.\nDefinition 2. STree(y) for string y is an edge-labeled rooted tree (VS,ES) such that\nVS = {\u2212\u2192x | x \u2208 Substr(y)} ES = {(x, \u03b2, x\u03b2) | x, x\u03b2 \u2208 VS, \u03b2 \u2208 \u03a3+, b = \u03b2[1], \u2212\u2192 xb = x\u03b2}.\nThe second element \u03b2 of each edge (x, \u03b2, x\u03b2) is the label of the edge. We also define the set LS of labeled \u201creversed\u201d edges called the suffix links of STree(y) by\nLS = {(ax, a, x) | x, ax \u2208 VS, a \u2208 \u03a3},\nand denote the tree (VS, LS) of the suffix links by SLT(y).\nObserve that each internal node of STree(y) is a branching internal node in STrie(y). Note that for any x \u2208 Substr(y) the leaves in the subtree rooted at \u2212\u2192x correspond to BegPos(x). By representing each edge label \u03b2 with a pair of integers (i, j) such that y[i..j] = \u03b2, STree(y) can be represented with O(n) space.\nAn alternative way to reduce the size of STrie(y) to O(n) is to regard STrie(y) as a partial DFA which recognizes Suffix(y), and to minimize it. This leads to the directed acyclic word graph DAWG(y) of string y. Following conventions from [8, 37], DAWG(y) is defined as follows.\nDefinition 3. DAWG(y) of string y is an edge-labeled DAG (VD,ED) such that\nVD = {[x]R | x \u2208 Substr(y)} ED = {([x]R, b, [xb]R) | x, xb \u2208 Substr(y), b \u2208 \u03a3}.\nWe also define the set LD of labeled \u201creversed\u201d edges called the suffix links of DAWG(y) by\nLD = {([ax]R, a, [x]R) | x, ax \u2208 Substr(y), a \u2208 \u03a3, [ax]R \u0338= [x]R}.\nSee Figure 1 for examples of STrie(y), STree(y), DAWG(y), and CDAWG(y).\nTheorem 1 ([6]). For any string y of length n > 2, the number of nodes in DAWG(y) is at most 2n\u2212 1 and the number of edges in DAWG(y) is at most 3n\u2212 4.\nMinimization of STrie(y) to DAWG(y) can be done by merging isomorphic subtrees of STrie(y) which are rooted at nodes connected by a chain of suffix links of STrie(y). Since the substrings represented by these merged nodes end at the same positions in y, each node of DAWG(y) forms an equivalence class [x]R. We will make an extensive use of this property in our O(n)-time construction algorithm for DAWG(y) over an integer alphabet."
        },
        {
            "heading": "2.3. Minimal Absent Words",
            "text": "A string x is said to be an absent word of another string y if x /\u2208 Substr(y). An absent word x of y is said to be a minimal absent word (MAW ) of y if Substr(x) \\ {x} \u2282 Substr(y). The set of all MAWs of y is denoted by MAW(y). For example, if \u03a3 = {a, b, c} and y = abaab, then MAW(y) = {aaa, aaba, bab, bb, c}.\nLemma 1 ([26]). For any string y \u2208 \u03a3\u2217, \u03c3 \u2264 |MAW(y)| \u2264 (\u03c3y\u2212 1)(|y|\u2212 1)+\u03c3, where \u03c3 = |\u03a3| and \u03c3y is the number of distinct characters occurring in y. These bounds are tight.\nThe next lemma follows from the definition of MAWs.\nLemma 2. Let y be any string. For any characters a, b \u2208 \u03a3 and string x \u2208 \u03a3\u2217, axb \u2208 MAW(y) iff axb /\u2208 Substr(y), ax \u2208 Substr(y), and xb \u2208 Substr(y).\nBy Lemma 2, we can encode each MAW axb of y in O(1) space by (i, j, b), where ax = y[i..j].\n3. Folklore Algorithm to Construct DAWG(y\u0302) from STree(y) in O(n) Time for Integer Alphabet\nFor the suffix tree STree(y) = (VS,ES), we define the set WL of edges called Weiner links of STree(y) by\nWL = {(x, a, ax\u03b2) | a \u2208 \u03a3, \u03b2 \u2208 \u03a3\u2217, x \u2208 VS,\u2212\u2192ax = ax\u03b2 \u2208 VS}.\nThe following lemma on the relation between Weiner links and DAWG is well known.\nLemma 3 ([6, 15]). For the suffix tree STree(y) = (VS,ES) of a string y, (V,E) is the DAWG of y\u0302, where V = {[x]L | x \u2208 VS} and E = {([x]L, a, [ax\u03b2]L) | (x, a, ax\u03b2) \u2208 WL}, and L = {([xb\u03b2]L, b, [x]L) | b \u2208 \u03a3, x, \u03b2 \u2208 \u03a3\u2217, (x, b\u03b2, xb\u03b2) \u2208 ES} are the suffix links of the DAWG (V,E) of y\u0302.\nEach Weiner-link (x, a, ax\u03b2) \u2208 WL is called explicit if \u03b2 = \u03b5 (namely, ax \u2208 VS or equivalently \u2212\u2192ax = ax), and it is called implicit otherwise. By definition, the explicit Weiner links are identical to the reversed suffix links. Figure 2 shows a concrete example of suffix links and Weiner links.\nBy the above argument, what is left is to compute the implicit Weiner links. In this section, we describe a folklore algorithm for computing the Weiner links in linear time, from a given suffix tree STree(y) augmented with the suffix links.\nLet p1(x) be p(x) and pi(x) be the parent of pi\u22121(x) for i > 1 in the suffix tree STree(y). Then the following properties hold.\nObservation 1 ([38]). For each implicit Weiner link (x, a, ax\u03b2) \u2208 WL of STree(y) with \u03b2 \u2208 \u03a3+, there exists the explicit Weiner link (x\u03b2, a, ax\u03b2). For each explicit Weiner link (w, a, aw), if k is the smallest integer such that p(aw) = apk(w) (i.e. k is the smallest integer such that (pk(w), a, p(aw)) is an explicit Weiner link), then (pi(w), a, aw) is an implicit Weiner link for each 1 \u2264 i < k. See Figure 3 and Figure 4.\nFrom Observation 1, every implicit Weiner link of STree(y) is of the form (pi(w), a, aw) described above for some explicit Weiner link (w, a, aw). Thus we can obtain all implicit Weiner links in linear time by computing (pi(w), a, aw) for all explicit Weiner links (w, a, aw) which are the reversed edges of LS of STree(y). This computation takes O(n) total time.\nTheorem 2. Given STree(y) and its suffix links LS of string y of length n over an integer alphabet, the Weiner links WL of STree(y) can be computed in O(n) time.\nWe can obtain DAWG(y\u0302) from STree(y) by Lemma 3 and Theorem 2. We remark however that the edges of DAWG(y\u0302) might not be sorted, since the Weiner links WL of STree(y) might not be sorted. Still, we can easily sort all the edges of DAWG(y\u0302) in O(n) total time after they are constructed: First, extract all edges of DAWG(y\u0302) by a standard traversal on DAWG(y\u0302),\nwhich takes O(n) time. Next, radix sort them by their labels, which takes O(n) time because we assumed an integer alphabet of polynomial size in n. Finally, re-insert the edges to their respective nodes in the sorted order.\nTheorem 3. Given STree(y) and its suffix links LS of string y of length n over an integer alphabet, the edge-sorted DAWG(y\u0302) of the reversed string y\u0302 with suffix links can be constructed in O(n) time and space.\nIn some applications such as bidirectional pattern searches, it is preferable that the incoming suffix links at each node of DAWG(y\u0302) are also sorted in lexicographical order, but the algorithm described above does not sort the suffix links. However, one can sort the suffix links in O(n) time by the same technique applied to the edges of DAWG(y\u0302).\nRemark. It is noteworthy that the parallel DAWG construction algorithm proposed by Breslauer and Hariharan [39] can be seen as a parallel version of the above folklore algorithm.\n4. Constructing DAWG(y) from STree(y) in O(n) Time for Integer Alphabet\nIn this section, we present an optimal O(n)-time algorithm to construct DAWG(y) with suffix links LD for a given string y of length n over an integer alphabet. Our algorithm constructs DAWG(y) with suffix links LD from STree(y) with suffix links LS. The following result is known.\nTheorem 4 ([12]). Given a string y of length n over an integer alphabet, edge-sorted STree(y) with suffix links LS can be computed in O(n) time.\nLet L and R be, respectively, the sets of longest elements of all equivalence classes on y w.r.t. \u2261L and \u2261R, namely, L = {\u2212\u2192x | x \u2208 Substr(y)} and R = {\u2190\u2212x | x \u2208 Substr(y)}. Let\nSTree\u2032(y) = (V\u2032S,E \u2032 S) be the edge-labeled rooted tree obtained by adding extra nodes for strings in R to STree(y), namely,\nV\u2032S = {x | x \u2208 L \u222aR}, E\u2032S = {(x, \u03b2, x\u03b2) | x, x\u03b2 \u2208 V\u2032S, \u03b2 \u2208 \u03a3+, 1 \u2264 \u2200i < |\u03b2|, x \u00b7 \u03b2[1..i] /\u2208 V\u2032S}.\nNotice that the size of STree\u2032(y) is O(n), since |L \u222a R| \u2264 |VS|+ |VD| = O(n), where VS and VD are respectively the sets of nodes of STree(y) and DAWG(y).\nA node x \u2208 V\u2032S of STree\u2032(y) is called black iff x \u2208 R. See Figure 5 for an example of STree\u2032(y).\nLemma 4. For any x \u2208 Substr(y), if x is represented by a black node in STree\u2032(y), then every prefix of x is also represented by a black node in STree\u2032(y).\nProof. Since x is a black node, x =\u2190\u2212x . Assume on the contrary that there is a proper prefix z of x such that z is not represented by a black node. Let zu = x with u \u2208 \u03a3+. Since z \u2261R \u2190\u2212z , we have x = zu \u2261R \u2190\u2212z u. On the other hand, since z is not black, we have |\u2190\u2212z | > |z|. However, this contradicts that x is the longest member \u2190\u2212x of [x]R. Thus, every prefix of x is also represented by a black node.\nLemma 5. For any string y, let BT(y) be the trie consisting only of the black nodes of STree\u2032(y). Then, every leaf \u2113 of BT(y) is a node of the original suffix tree STree(y).\nProof. Assume on the contrary that some leaf \u2113 of BT(y) corresponds to an internal node of STree\u2032(y) that has exactly one child. Since any substring in L is represented by a node of the original suffix tree STree(y), we have \u2113 \u2208 R. Since \u2113 = \u2190\u2212 \u2113 , \u2113 is the longest substring of y which has ending positions EndPos(\u2113) in y. This implies one of the following situations: (1) occurrences of \u2113 in y are immediately preceded by at least two distinct characters a =\u0338 b, (2) \u2113 occurs as a prefix of y and all the other occurrences of \u2113 in y are immediately preceded by a unique character a, or (3) \u2113 occurs exactly once in y as its prefix. Let u be the only child of \u2113 in STree\u2032(y), and let \u2113z = u, where z \u2208 \u03a3+. By the definition of \u2113, u is not black. On the other hand, in any of the situations (1)-(3), u = \u2113z is the longest substring of y which has ending positions EndPos(u) in y. Hence we have u =\u2190\u2212u and u must be black, a contradiction. Thus, every leaf \u2113 of BT(y) is a node of the original suffix tree STree(y).\nLemma 6 ([13]). For any node x \u2208 VS of the original suffix tree STree(y), its corresponding node in STree\u2032(y) is black iff (1) x is a leaf of the suffix link tree SLT(y), or (2) x is an internal node of SLT(y) and for any character a \u2208 \u03a3 such that ax \u2208 VS, |BegPos(ax)| =\u0338 |BegPos(x)|.\nUsing Lemma 5 and Lemma 6, we can compute all leaves of BT(y) in O(n) time by a standard traversal on the suffix link tree SLT(y). Then, we can compute all internal black nodes of BT(y) in O(n) time using Lemma 4. Now, by Theorem 4, the next lemma holds:\nLemma 7. Given a string y of length n over an integer alphabet, edge-sorted STree\u2032(y) can be constructed in O(n) time.\nWe construct DAWG(y) with suffix links LD from STree \u2032(y), as follows. First, we construct a DAG D, which is initially equivalent to the trie BT(y) consisting only of the black nodes of STree\u2032(y). Our algorithm adds edges and suffix links to D, so that the DAG D will finally become DAWG(y). In so doing, we traverse STree\u2032(y) in post order. For each black node\nx of STree\u2032(y) visited in the post-order traversal, which is either an internal node or a leaf of the original suffix tree STree(y), we perform the following: Let p(x) be the parent of x in the original suffix tree STree(y). It follows from Lemma 4 that every prefix x\u2032 of x with |p(x)| \u2264 |x\u2032| \u2264 |x| is represented by a black node. For each black node x\u2032 in the path from p(x) to x in the DAG D, we compute the in-coming edges to x\u2032 and the suffix link of x\u2032.\nLet s0, . . . , sm be the sequence of nodes connected by a chain of suffix links starting from s0 = x, such that |BegPos(si)| = |BegPos(s0)| for all 0 \u2264 i \u2264 m \u2212 1 and |BegPos(sm)| > |BegPos(s0)| (see the left diagram of Figure 6). In other words, sm is the first black node after s0 in the chain of suffix links (this is true by Lemma 6). Since |si| = |si\u22121| \u2212 1 for every 1 \u2264 i \u2264 m\u2212 1, EndPos(si) = EndPos(s0). Thus, s0, . . . , sm\u22121 form a single equivalence class w.r.t. \u2261R and are represented by the same node as x = s0 in the DAWG.\nFor any 0 \u2264 i \u2264 m\u2212 1, let d(si) = |si|\u2212 |p(si)|. Observe that the sequence d(s0), . . . , d(sm) is monotonically non-increasing by the property of suffix trees. We partition the sequence s0, . . . , sm of nodes into blocks so that the parents of all nodes in the same block belong to the same equivalence class w.r.t. \u2261R. Let r be the number of such blocks, and for each 0 \u2264 k \u2264 r\u22121, let Bk = sik , . . . , sik+1\u22121 be the kth such block. We can easily compute all these blocks by comparing |p(si\u22121)| and |p(si)| for each pair si\u22121 and si of consecutive elements in the sequence s1, . . . , sm of nodes. Note that for each block Bk, p(sik) is the only black node among the parents p(sik), . . . , p(sik+1\u22121) of the nodes in Bk, since it is the longest one in its equivalence class [p(sik)]R. Also, every node in the same block has the same value for function d. Thus, for each block Bk, we add a new edge (p(sik), bk, qk) to the DAG D, where qk is the (black) ancestor of x such that |qk| = |x| \u2212 d(sik) + 1, and bk is the first character of the label of the edge from p(sik) to sik in STree\n\u2032(y). Notice that this new edge added to D corresponds to the edges between the nodes in the block Bk and their parents in STree\n\u2032(y). We also add a suffix link (p(qk), a, p(sik)) to D, where a = sik\u22121[1]. See also the right diagram of Figure 6.\nFor each 2 \u2264 k \u2264 r \u2212 1, let Pk be the path from qk\u22121 to gk, where gk = p(p(qk)) for\n2 \u2264 k \u2264 r \u2212 2 and gr\u22121 = x = s0. Each Pk is a sub-path of the path from p(s0) to s0, and every node in Pk has not been given their suffix link yet. For each node v in Pk, we add the suffix link from v to the ancestor u of sik such that |sik | \u2212 |u| = |s0| \u2212 |v|. See also the right diagram of Figure 6.\nRepeating the above procedure for all black nodes of STree\u2032(y) that are either internal nodes or leaves of the original suffix tree STree(y) in post order, the DAG D finally becomes DAWG(y) with suffix links LD. We remark however that the edges of DAWG(y) might not be sorted, since the edges that exist in STree\u2032(y) were firstly inserted to the DAG D. Still, we can easily sort all the edges and suffix links of DAWG(y) in O(n) total time after they are constructed by the same technique as in Section 3.\nTheorem 5. Given a string y of length n over an integer alphabet, we can compute edge-sorted DAWG(y) with suffix links LD in O(n) time and space.\nProof. The correctness can easily be seen if one recalls that minimizing STrie(y) based on its suffix links produces DAWG(y). The proposed algorithm simulates this minimization using only the subset of the nodes of STrie(y) that exist in STree\u2032(y). The out-edges of each node of DAWG(y) are sorted in lexicographical order as previously described.\nWe analyze the time complexity of our algorithm. We can compute STree\u2032(y) in O(n) time by Lemma 7. The initial trie for D can easily be computed in O(n) time from STree\u2032(y). Let x be any node visited in the post-order traversal on STree\u2032(y) that is either an internal node or a leaf of the original suffix tree STree(y). The cost of adding the new in-coming edges to the black nodes in the path from p(x) to x = s0 is linear in the number of nodes in the sequence s0, . . . , sm connected by the chain of suffix links starting from s0 = x. Since s0 and sm are the only black nodes in the sequence, it follows from Lemma 6 that the chain of suffix links from s0 to sm is a non-branching path of the suffix link tree SLT(y). This implies that the suffix links in this chain are used only for node x during the post-order traversal of STree\u2032(y). Since the number of edges in SLT(y) is O(n), the amortized cost of adding each edge to D is constant. Also, the total cost to sort all edges is O(n), as was previously explained. Now let us consider the cost of adding the suffix links from the nodes in each sub-path Pk. For each node v in Pk, the destination node v can be found in constant time by simply climbing up the path from sik in the chain of suffix links. Overall, the total time cost to transform the trie for D to DAWG(y) is O(n).\nThe working space is clearly O(n).\nExample 1. Figure 7 shows snapshots of the DAWG construction for string y = aabcabcab$ by our algorithm. Step 0: (Left): STree\u2032(y) with suffix links LS and (Right): the initial trie for D. We traverse STree\u2032(y) in post order. Step 1: We arrived at black leaf node x1 = aabcabcab$ (indicated by a star). We determine the in-coming edges and suffix links for the black nodes in the path from p(x1) = a and x1 (indicated by thick black lines). To the right is the resulting DAG D for this step. Step 2: We arrived at black branching node x2 = abcab (indicated by a star). We determine the in-coming edges and suffix links for the black nodes in the path from p(x2) = ab and x2 (indicated by thick black lines). To the right is the resulting DAG D for this step. Step 3: We arrived at black branching node x3 = ab (indicated by a star). We determine the in-coming edges and suffix links for the black nodes in the path from p(x3) = a and x3 (indicated by thick black lines). To the right is the resulting DAG D for this step. Step 4: We arrived at black branching node x4 = a (indicated by a star). We determine the in-coming edges and suffix links for the black nodes in the path from p(x4) = \u03b5 and x4\n(indicated by thick black lines). To the right is the resulting DAG D for this step. Since all branching and leaf black nodes have been processed, the final DAG D is DAWG(y) with suffix links.\n5. Constructing Affix Trees in O(n) Time for Integer Alphabet\nLet y be the input string of length n over an integer alphabet. Recall the sets L = {\u2212\u2192x | x \u2208 Substr(y)} and R = {\u2190\u2212x | x \u2208 Substr(y)} introduced in Section 4. For any set S \u2286 \u03a3\u2217 \u00d7 \u03a3\u2217 of ordered pairs of strings, let S[1] = {x1 | (x1, x2) \u2208 S for some x2 \u2208 \u03a3\u2217} and S[2] = {x2 | (x1, x2) \u2208 S for some x1 \u2208 \u03a3\u2217}.\nThe affix tree [9] of string y, denoted ATree(y), is a bidirectional text indexing structure defined as follows:\nDefinition 4. ATree(y) for string y is an edge-labeled DAG (VA,EA) = (VA,E F A \u222a EBA ) which has two disjoint sets EFA ,E B A of edges such that\nVA = {(x, x\u0302) | x \u2208 L \u222aR}, EFA = {((x, x\u0302), \u03b2, (x\u03b2, \u03b2\u0302x\u0302)) | x, x\u03b2 \u2208 VA[1], \u03b2 \u2208 \u03a3+, 1 \u2264 \u2200i < |\u03b2|, x \u00b7 \u03b2[1..i] /\u2208 VA[1]}, EBA = {((x, x\u0302), \u03b1\u0302, (\u03b1x, x\u0302\u03b1\u0302)) | x\u0302, x\u0302\u03b1\u0302 \u2208 VA[2],\n\u03b1 \u2208 \u03a3+, 1 \u2264 \u2200i < |\u03b1|, x\u0302 \u00b7 \u03b1\u0302[1..i] /\u2208 VA[2]}.\nEFA is the set of forward edges labeled by substrings of y, while E B A is the set of backward edges labeled by substrings of y\u0302.\nTheorem 6. Given a string y of length n over an integer alphabet of polynomial size in n, we can compute edge-sorted ATree(y) in O(n) time and space.\nProof. Clearly, there is a one-to-one correspondence between each node (x, x\u0302) \u2208 VA of ATree(y) = (VA,E F A \u222a EBA ) and each node x \u2208 V\u2032S of STree\u2032(y) = (V\u2032S,E\u2032S) of Section 4 (see also Figure 5 and Figure 8). Moreover, there is a one-to-one correspondence between each forward edge (x, \u03b2, x\u03b2) \u2208 EFA of ATree(y) and each edge (x, \u03b2, x\u03b2) \u2208 E\u2032S of STree\u2032(y). Hence, what remains is to construct the backward edges in EBA for ATree(y). A straightforward modification to our DAWG construction algorithm of Section 4 can construct the backward edges of ATree(y); instead of working on the DAG D, we directly add the suffix links to the black nodes of STree\u2032(y) whose suffix links are not defined yet (namely, those that are neither branching nodes nor leaves of the suffix link tree SLT(y)). Since the suffix links are reversed edges, by reversing them we obtain the backward edges of ATree(y). The labels of the backward edges can be easily computed in O(n) time by storing in each node the length of the string it represents. Finally, we can sort the forward and backward edges in lexicographical order in overall O(n) time, using the same idea as in Section 4."
        },
        {
            "heading": "6. Constructions of other text indexing structures",
            "text": "In this section, we present how our algorithms for building DAWGs and affix trees can be applied to constructing other text indexing data structures in linear time."
        },
        {
            "heading": "6.1. DAWG for the reversed string",
            "text": "Here we show that the algorithm that computes affix trees from Section 5 can also be regarded as a linear-time algorithm which computes the Weiner links for the forward and reversed strings simultaneously. This will be a key to our efficient construction of other text indexing structures, which will be shown later in this section.\nFor the sake of simplicity, we here use a slightly different version of Weiner links than WL in Section 3, which are called modified Weiner links and are defined as follows:\nmWL = {(x, a, ax) | a \u2208 \u03a3, x \u2208 VS, ax \u2208 Substr(y)}.\nThe difference from the normal Weiner links is that the destination nodes of the modified Weiner links ax can be implicit (i.e. non-branching) nodes in the suffix tree (see the right diagram of Figure 9). Hence, it is clear that there is a one-to-one correspondence between WL and mWL, and it is easy to convert mWL to WL and vice versa.\nAs in the case with (normal) Weiner links WL, we call each modified Weiner link (x, a, ax) \u2208 mWL explicit if ax \u2208 VS, and implicit otherwise. For each implicit modified Weiner link (x, a, ax), we consider an auxiliary nodes ax. We note that such auxiliary nodes ax are exactly the type-2 nodes of linear-size suffix tries [14].\nThe following theorem holds for the modified Weiner links.\nTheorem 7. For any edge ((x, x\u0302), \u03b1\u0302, (\u03b1x, x\u0302\u03b1\u0302)) \u2208 EBA of ATree(y), x \u2208 L\u2227\u03b1x /\u2208 L iff (x, a, ax) is an implicit modified Weiner link of STree(y) where a = \u03b1[|\u03b1|] (see Figure 9).\nProof. (\u21d0) Since (x, a, ax) is an implicit modified Weiner link of STree(y), x is in L and wax is not in L for any string w \u2208 \u03a3\u2217. Thus x \u2208 L \u2227 \u03b1x /\u2208 L. (\u21d2) By the definition of EBA , for any i (1 \u2264 i < |\u03b1|), we have x\u0302 \u00b7 \u03b1\u0302[1..i] /\u2208 VA[2]. Thus \u03b1[|\u03b1|]x /\u2208 L. Obliviously ax \u2208 Substr(y), and thus (x, a, ax) is an implicit modified Weiner link of STree(y).\nBy Theorem 7, when constructing the affix tree ATree(y) of the input string y, the set of modified Weiner links mWL of STree(y) is also computed. Because affix trees are symmetric data structures for the string and its reversal, the modified Weiner links of the suffix tree STree(y\u0302) for the reversed string y\u0302 are also computed at the same time."
        },
        {
            "heading": "6.2. Symmetric CDAWGs",
            "text": "The Compact DAWG [8] (CDAWG) of string y, denoted CDAWG(y) is an edge-labeled DAG that can be obtained by merging isomorphic subtrees of STree(y), or equivalently by performing path-compressions to DAWG(y). Each internal node of CDAWG(y) corresponds to a maximal repeat of the string y, where a substring x of y is called a maximal repeat of y if x occurs in y more than once, and prepending or appending a character to x decreases the number of its occurrences in y. By the nature of maximal repeats, CDAWG(y) for string y and CDAWG(y\u0302) can share the same set of nodes. The resulting data structure is yet another bidirectional text indexing structure, called symmetric CDAWG for y. Blumer et al. [8] showed the following:\nTheorem 8 ([8]). Given STree(y) and DAWG(y\u0302) for string y which share the same nodes, one can build the symmetric CDAWG for string y in linear time.\nThe algorithm by Blumer et al. in the above theorem does not use character comparisons. Thus, by applying this method after building DAWG(y\u0302) over STree(y) using our technique from Section 6.1, we obtain the following corollary:\nCorollary 1. Given a string y of length n over an integer alphabet of polynomial size in n, we can compute edge-sorted symmetric CDAWG for y in O(n) time and space."
        },
        {
            "heading": "6.3. Linear-size suffix tries",
            "text": "When reversed and unlabeled, the modified Weiner links are the suffix links of the so-called type-2 nodes of the linear-size suffix tries [14]. Let LSTrie(y) denote the linear-size suffix trie of string y. Intuitively, LSTrie(y) is an edge-labeled rooted tree obtained from STree(y) as follows:\n(1) For each reversed and unlabeled modified Weiner link (ax, x), insert a non-branching explicit node ax if ax is not a branching node of STree(y). Such non-branching nodes are called type-2 nodes.\n(2) Retain the first character in each edge label, and remove all the following characters along the edge.\nIt is known that one can restore the whole edge label efficiently on LSTrie(y), without explicitly storing the input string y [14, 40, 41]. Now the following corollary is immediate from Theorem 6 and Theorem 7:\nCorollary 2. Given a string y of length n over an integer alphabet of polynomial size in n, we can compute edge-sorted LSTrie(y) in O(n) time and space.\n7. Computing Minimal Absent Words in O(n + |MAW(y)|) Time\nAs an application to our O(n)-time DAWG construction algorithm of Section 4, in this section we show an optimal time algorithm to compute the set of all minimal absent words of a given string over an integer alphabet.\nFinding minimal absent words of length 1 for a given string y (i.e., the characters not occurring in y) is easy to do in O(n+ \u03c3) time and O(1) working space for an integer alphabet, where \u03c3 is the alphabet size. In what follows, we concentrate on finding minimal absent words of y of length at least 2.\nCrochemore et al. [25] proposed a \u0398(\u03c3n)-time algorithm to compute MAW(y) for a given string y of length n. The following two lemmas, which show tight connections between DAWG(y) and MAW(y), are implicitly used in their algorithm but under a somewhat different formulation. Since our O(n+ |MAW(y)|)-time solution is built on the lemmas, we give a proof for completeness.\nLemma 8. Let a, b \u2208 \u03a3 and x \u2208 \u03a3\u2217. If axb \u2208 MAW(y), then x =\u2190\u2212x , namely, x is the longest string represented by node [x]R \u2208 VD of DAWG(y). Proof. Assume on the contrary that x \u0338=\u2190\u2212x . Since x is not the longest string of [x]R, there exists a character c \u2208 \u03a3 such that cx \u2208 Substr(y) and [x]R = [cx]R. Since axb \u2208 MAW(y), it follows from Lemma 2 that xb \u2208 Substr(y). Since [x]R = [cx]R, c always immediately precedes x in y. Thus we have cxb \u2208 Substr(y).\nSince axb \u2208 MAW(y), c \u0338= a. On the other hand, it follows from Lemma 2 that ax \u2208 Substr(y). However, this contradicts that c always immediately precedes x in y and c \u0338= a. Consequently, if axb \u2208 MAW(y), then x =\u2190\u2212x .\nFor any node v \u2208 VD of DAWG(y) and character b \u2208 \u03a3, we write \u03b4D(v, b) = u if (v, b, u) \u2208 ED for some u \u2208 VD, and write \u03b4D(v, b) = nil otherwise. For any suffix link (u, a, v) \u2208 LD of\nAlgorithm 1: \u0398(n\u03c3)-time algorithm (MF-TRIE) by Crochemore et al. [25]\nInput: String y of length n Output: All minimal absent words for y\n1 MAW\u2190 \u2205; 2 Construct DAWG(y) augmented with suffix links LD; 3 for each non-source node u of DAWG(y) do 4 for each character b \u2208 \u03a3 do 5 if \u03b4D(u, b) = nil and \u03b4D(slD(u), b) \u0338= nil then 6 MAW\u2190 MAW\u222a{axb}; // (u, a, slD(u))\u2208LD, x= long(slD(u))\n7 Output MAW;\nDAWG(y), we write slD(u) = v. Note that there is exactly one suffix link coming out from each node u \u2208 VD of DAWG(y), so the character a is unique for each node u. Lemma 9. Let a, b \u2208 \u03a3 and x \u2208 \u03a3\u2217. Then, axb \u2208 MAW(y) iff x = \u2190\u2212x , \u03b4D([x]R, b) = [xb]R, slD([ax]R) = [x]R, and \u03b4D([ax]R, b) = nil . Proof. (\u21d2) From Lemma 8, x = \u2190\u2212x . From Lemma 2, axb \u0338\u2208 Substr(y). However, ax, xb \u2208 Substr(y), and thus we have \u03b4D([ax]R, b) = nil , \u03b4D([x]R, b) = [xb]R, and slD([ax]R) = [x]R, where the last suffix link exists since x =\u2190\u2212x .\n(\u21d0) Since \u03b4D([x]R, b) = [xb]R and slD([ax]R) = [x]R, we have that xb, ax \u2208 Substr(y). Since ax \u2208 Substr(y) and \u03b4D([ax]R, b) = nil , we have that axb \u0338\u2208 Substr(y) Thus from Lemma 2, axb \u2208 MAW(y).\nFrom Lemma 9 all MAWs of y can be computed by traversing all the states of DAWG(y) and comparing all out-going edges between nodes connected by suffix links. See also Figure 10 for illustration.\nA pseudo-code of the algorithm MF-TRIE by Crochemore et al. [25], which is based on this idea, is shown in Algorithm 1. Since all characters in the alphabet \u03a3 are tested at each node, the total time complexity becomes \u0398(n\u03c3). The working space is O(n), since only the DAWG and its suffix links are needed.\nNext we show that with a simple modification in the for loops of the algorithm and with a careful examination of the total cost, the set MAW(y) of all MAWs of the input string y can be computed in O(n+ |MAW(y)|) time and O(n) working space. Basically, the only change is to move the \u201c\u03b4D(slD(u), b) \u0338= nil\u201d condition in Line 5 to the for loop of Line 4. Namely, when we focus on node u of DAWG(y), we test only the characters which label the out-edges from node slD(u). A pseudo-code of the modified version is shown in Algorithm 2.\nTheorem 9. Given a string y of length n over an integer alphabet, we compute MAW(y) in optimal O(n+ |MAW(y)|) time with O(n) working space.\nProof. First, we show the correctness of our algorithm. For any node u of DAWG(y), EndPos(slD(u)) \u2283 EndPos(u) holds since every string in slD(u) is a suffix of the strings in u. Thus, if there is an out-edge of u labeled c, then there is an out-edge of slD(u) labeled c. Hence, the task is to find every character b such that there is an out-edge of slD(u) labeled b but there is no out-edge of u labeled b. The for loop of Line 4 of Algorithm 2 tests all such characters and only those. Hence, Algorithm 2 computes MAW(y) correctly.\nAlgorithm 2: Proposed O(n+ |MAW(y)|)-time algorithm Input: String y of length n Output: All minimal absent words for y 1 MAW\u2190 \u2205; 2 Construct edge-sorted DAWG(y) augmented with suffix links LD; 3 for each non-source node u of DAWG(y) do 4 for each character b such that \u03b4D(slD(u), b) \u0338= nil do 5 if \u03b4D(u, b) = nil then 6 MAW\u2190 MAW\u222a{axb}; // (u, a, slD(u))\u2208LD, x= long(slD(u))\n7 Output MAW;\nSecond, we analyze the efficiency of our algorithm. As was mentioned above, minimal absent words of length 1 for y can be found in O(n+ \u03c3) time and O(1) working space. By Lemma 1, \u03c3 \u2264 |MAW(y)| and hence the \u03c3-term is dominated by the output size |MAW(y)|. Now we consider the cost of finding minimal absent words of length at least 2 by Algorithm 2. Let b be any character such that there is an out-edge e of slD(u) labeled b. There are two cases: (1) If there is no out-edge of u labeled b, then we output an MAW, so we can charge the cost to check e to an output. (2) If there is an out-edge e\u2032 of u labeled b, then the trick is that we can charge the cost to check e to e\u2032. Since each node u has exactly one suffix link going out from it, each out-edge of u is charged only once in Case (2). Since the out-edges of every node u and those of slD(u) are both sorted, we can compute their difference for every node u in DAWG(y), in overall O(n) time. Edge-sorted DAWG(y) with suffix links can be constructed in O(n) time for an integer alphabet as in Section 4. Overall, Algorithm 2 runs in O(n+ |MAW(y)|) time. The space requirement is clearly O(n)."
        },
        {
            "heading": "8. Conclusions",
            "text": "In this paper, we proposed O(n)-time algorithms for constructing DAWG(y) and ATree(y) of a given string y of length n, over an integer alphabet of size polynomial in n. These algorithms transform the suffix tree of y to DAWG(y) and ATree(y). We also showed how to build the symmetric CDAWG and linear-size suffix trie for the input string over an integer alphabet.\nAs a further application of DAWG(y), we presented an optimal O(n + |MAW(y)|)-time algorithm to compute the set MAW(y) of all minimal absent words of y when the edge-sorted DAWG for y is already computed."
        },
        {
            "heading": "Acknowledgements",
            "text": "This work was supported by JSPS KAKENHI Grant Numbers JP18J10967 (YF), JP17H01697, JP26280003, JP22H03551 (SI), JP16H02783, JP20H04141 (HB), JP25240003, JP18H04098 (MT)."
        }
    ],
    "title": "Linear-time Computation of DAWGs, Symmetric Indexing Structures, and MAWs for Integer Alphabets",
    "year": 2023
}