{
    "abstractText": "A t-spanner of a graph is a subgraph that t-approximates pairwise distances. The greedy algorithm is one of the simplest and most well-studied algorithms for constructing a sparse spanner: it computes a t-spanner with n edges by repeatedly choosing any edge which does not close a cycle of chosen edges with t+ 1 or fewer edges. We demonstrate that the greedy algorithm computes a t-spanner with t \u00b7 log n \u00b7 n edges even when a matching of such edges are added in parallel. In particular, it suffices to repeatedly add any matching where each individual edge does not close a cycle with t + 1 or fewer edges but where adding the entire matching might. Our analysis makes use of and illustrates the power of new advances in length-constrained expander decompositions. ar X iv :2 30 4. 08 89 2v 4 [ cs .D S] 2 A ug 2 02 3",
    "authors": [
        {
            "affiliations": [],
            "name": "Bernhard Haeupler"
        },
        {
            "affiliations": [],
            "name": "D Ellis Hershkowitz"
        },
        {
            "affiliations": [],
            "name": "Zihan Tan"
        }
    ],
    "id": "SP:37c2faafdfcd1e7eb61de93a4f2b9901a5a679ad",
    "references": [
        {
            "authors": [
                "Baruch Awerbuch",
                "Alan Baratz",
                "David Peleg"
            ],
            "title": "Cost-sensitive analysis of communication protocols",
            "venue": "In ACM Symposium on Principles of Distributed Computing (PODC),",
            "year": 1990
        },
        {
            "authors": [
                "Reyan Ahmed",
                "Greg Bodwin",
                "Faryad Darabi Sahneh",
                "Keaton Hamm",
                "Mohammad Javad Latifi Jebelli",
                "Stephen Kobourov",
                "Richard Spence"
            ],
            "title": "Graph spanners: A tutorial review",
            "venue": "Computer Science Review,",
            "year": 2020
        },
        {
            "authors": [
                "Ingo Alth\u00f6fer",
                "Gautam Das",
                "David Dobkin",
                "Deborah Joseph",
                "Jos\u00e9 Soares"
            ],
            "title": "On sparse spanners of weighted graphs",
            "venue": "Discrete & Computational Geometry,",
            "year": 1993
        },
        {
            "authors": [
                "Baruch Awerbuch"
            ],
            "title": "Communication-time trade-offs in network synchronization",
            "venue": "In ACM Symposium on Principles of Distributed Computing (PODC),",
            "year": 1985
        },
        {
            "authors": [
                "Baruch Awerbuch"
            ],
            "title": "Efficient broadcast and light-weighted spanners",
            "year": 1992
        },
        {
            "authors": [
                "Greg Bodwin",
                "Michael Dinitz",
                "Merav Parter",
                "Virginia Vassilevska Williams"
            ],
            "title": "Optimal vertex fault tolerant spanners (for fixed stretch)",
            "venue": "In Annual ACM-SIAM Symposium on Discrete Algorithms (SODA),",
            "year": 2018
        },
        {
            "authors": [
                "Greg Bodwin",
                "Michael Dinitz",
                "Caleb Robelle"
            ],
            "title": "Partially optimal edge fault-tolerant spanners",
            "venue": "In Annual ACM-SIAM Symposium on Discrete Algorithms (SODA),",
            "year": 2022
        },
        {
            "authors": [
                "Greg Bodwin",
                "Gary Hoppenworth",
                "Ohad Trabelsi"
            ],
            "title": "Bridge girth: A unifying notion in network design",
            "venue": "arXiv preprint arXiv:2212.11944,",
            "year": 2022
        },
        {
            "authors": [
                "Boris Bukh",
                "Zilin Jiang"
            ],
            "title": "A bound on the number of edges in graphs without an even cycle",
            "venue": "Combinatorics, Probability and Computing,",
            "year": 2017
        },
        {
            "authors": [
                "Rebecca Braynard",
                "Dejan Kostic",
                "Adolfo Rodriguez",
                "Jeffrey Chase",
                "Amin Vahdat"
            ],
            "title": "Opus: an overlay peer utility service",
            "venue": "IEEE Open Architectures and Network Programming Proceedings. OPENARCH 2002 (Cat. No. 02EX571),",
            "year": 2002
        },
        {
            "authors": [
                "Yehuda Ben-Shimol",
                "Amit Dvir",
                "Michael Segal"
            ],
            "title": "Splast: a novel approach for multicasting in mobile wireless ad hoc networks",
            "venue": "IEEE 15th International Symposium on Personal, Indoor and Mobile Radio Communications (IEEE Cat. No. 04TH8754),",
            "year": 2004
        },
        {
            "authors": [
                "Jason Cong",
                "Andrew B Kahng",
                "Gabriel Robins",
                "Majid Sarrafzadeh",
                "CK Wong"
            ],
            "title": "Performance-driven global routing for cell based ics",
            "venue": "In ICCD,",
            "year": 1991
        },
        {
            "authors": [
                "Jason Cong",
                "Andrew B Kahng",
                "Gabriel Robins",
                "Majid Sarrafzadeh",
                "CK Wong"
            ],
            "title": "Provably good algorithms for performance-driven global routing",
            "venue": "Proc. of 5th ISCAS,",
            "year": 1992
        },
        {
            "authors": [
                "Boliong Chen",
                "Makoto Matsumoto",
                "Jianfang Wang",
                "Zhongfu Zhang",
                "Jianxun Zhang"
            ],
            "title": "A short proof of nash-williams\u2019 theorem for the arboricity of a graph",
            "venue": "Graphs and Combinatorics,",
            "year": 1994
        },
        {
            "authors": [
                "Edith Cohen"
            ],
            "title": "Fast algorithms for constructing t-spanners and paths with stretch t",
            "venue": "SIAM Journal on Computing,",
            "year": 1998
        },
        {
            "authors": [
                "Michael Elkin"
            ],
            "title": "Computing almost shortest paths",
            "venue": "ACM Transactions on Algorithms (TALG),",
            "year": 2005
        },
        {
            "authors": [
                "Paul Erd\u00f6s"
            ],
            "title": "On some extremal problems in graph theory",
            "venue": "Israel Journal of Mathematics,",
            "year": 1965
        },
        {
            "authors": [
                "Michael Elkin",
                "Jian Zhang"
            ],
            "title": "Efficient algorithms for constructing (1+, \u03b5, \u03b2)spanners in the distributed and streaming models",
            "venue": "In ACM Symposium on Principles of Distributed Computing (PODC),",
            "year": 2004
        },
        {
            "authors": [
                "Joan Feigenbaum",
                "Sampath Kannan",
                "Andrew McGregor",
                "Siddharth Suri",
                "Jian Zhang"
            ],
            "title": "Graph distances in the streaming model: the value of space",
            "venue": "In Annual ACM-SIAM Symposium on Discrete Algorithms (SODA),",
            "year": 2005
        },
        {
            "authors": [
                "Arnold Filtser",
                "Shay Solomon"
            ],
            "title": "The greedy spanner is existentially optimal",
            "venue": "In ACM Symposium on Principles of Distributed Computing (PODC),",
            "year": 2016
        },
        {
            "authors": [
                "Manuel Fern\u00e1ndez V",
                "David PWoodruff",
                "Taisuke Yasuda"
            ],
            "title": "Graph spanners in the message-passing model",
            "venue": "In Innovations in Theoretical Computer Science Conference (ITCS). Schloss Dagstuhl-Leibniz-Zentrum fu\u0308r Informatik,",
            "year": 2020
        },
        {
            "authors": [
                "Bernhard Haeupler",
                "D Ellis Hershkowitz",
                "Zihan Tan"
            ],
            "title": "Length-constrained expander decompositions: Deeper theory, simpler algorithms",
            "year": 2023
        },
        {
            "authors": [
                "Bernhard Haeupler",
                "Harald R\u00e4cke",
                "Mohsen Ghaffari"
            ],
            "title": "Hop-constrained expander decompositions, oblivious routing, and distributed universal optimality",
            "venue": "In Annual ACM Symposium on Theory of Computing (STOC),",
            "year": 2022
        },
        {
            "authors": [
                "Bernhard Haeupler",
                "David Wajc",
                "Goran Zuzic"
            ],
            "title": "Network coding gaps for completion times of multiple unicasts",
            "venue": "In Symposium on Foundations of Computer Science (FOCS),",
            "year": 2020
        },
        {
            "authors": [
                "Dejan Kostic",
                "Amin Vahdat"
            ],
            "title": "Latency versus cost optimizations in hierarchical overlay",
            "year": 2001
        },
        {
            "authors": [
                "C St JA Nash-Williams"
            ],
            "title": "Edge-disjoint spanning trees of finite graphs",
            "venue": "Journal of the London Mathematical Society,",
            "year": 1961
        },
        {
            "authors": [
                "C St JA Nash-Williams"
            ],
            "title": "Decomposition of finite graphs into forests",
            "venue": "Journal of the London Mathematical Society,",
            "year": 1964
        },
        {
            "authors": [
                "David Peleg"
            ],
            "title": "Distributed computing: a locality-sensitive approach",
            "year": 2000
        },
        {
            "authors": [
                "David Peleg"
            ],
            "title": "Proximity-preserving labeling schemes",
            "venue": "Journal of Graph Theory,",
            "year": 2000
        },
        {
            "authors": [
                "David Peleg",
                "Jeffrey D Ullman"
            ],
            "title": "An optimal synchronizer for the hypercube",
            "venue": "In ACM Symposium on Principles of Distributed Computing (PODC),",
            "year": 1987
        },
        {
            "authors": [
                "Liam Roditty",
                "Mikkel Thorup",
                "Uri Zwick"
            ],
            "title": "Deterministic constructions of approximate distance oracles and spanners",
            "venue": "In International Colloquium on Automata, Languages and Programming (ICALP),",
            "year": 2005
        },
        {
            "authors": [
                "Liam Roditty",
                "Uri Zwick"
            ],
            "title": "On dynamic shortest paths problems",
            "venue": "In Annual European Symposium on Algorithms (ESA),",
            "year": 2004
        },
        {
            "authors": [
                "F Sibel Salman",
                "Joseph Cheriyan",
                "Ramamoorthi Ravi",
                "Sairam Subramanian"
            ],
            "title": "Approximating the single-sink link-installation problem in network design",
            "venue": "SIAM Journal on Optimization,",
            "year": 2001
        },
        {
            "authors": [
                "Hanan Shpungin",
                "Michael Segal"
            ],
            "title": "Near-optimal multicriteria spanner constructions in wireless ad hoc networks",
            "venue": "IEEE/ACM Transactions on Networking,",
            "year": 1976
        },
        {
            "authors": [
                "Mikkel Thorup",
                "Uri Zwick"
            ],
            "title": "Compact routing schemes",
            "venue": "In ACM Symposium on Parallelism in Algorithms and Architectures (SPAA),",
            "year": 2001
        },
        {
            "authors": [
                "Mikkel Thorup",
                "Uri Zwick"
            ],
            "title": "Approximate distance oracles",
            "venue": "Journal of the ACM (JACM),",
            "year": 2005
        },
        {
            "authors": [
                "Pascal Von Rickenbach",
                "Rogert Wattenhofer"
            ],
            "title": "Gathering correlated data in sensor networks",
            "venue": "In Proceedings of the 2004 joint workshop on Foundations of mobile computing,",
            "year": 2004
        },
        {
            "authors": [
                "J\u00fcrgen Vogel",
                "J\u00f6rg Widmer",
                "Dirk Farin",
                "Martin Mauve",
                "Wolfgang Effelsberg"
            ],
            "title": "Priority-based distribution trees for application-level multicast",
            "venue": "In Proceedings of the 2nd workshop on Network and system support for games,",
            "year": 2003
        },
        {
            "authors": [
                "Bang Ye Wu",
                "Kun-Mao Chao",
                "Chuan Yi Tang"
            ],
            "title": "Light graphs with small routing cost",
            "venue": "Networks: An International Journal,",
            "year": 2002
        }
    ],
    "sections": [
        {
            "text": "We demonstrate that the greedy algorithm computes a t-spanner with t3 \u00b7 log3 n \u00b7 n1+O(1/t) edges even when a matching of such edges are added in parallel. In particular, it suffices to repeatedly add any matching where each individual edge does not close a cycle with t + 1 or fewer edges but where adding the entire matching might. Our analysis makes use of and illustrates the power of new advances in length-constrained expander decompositions.\nar X\niv :2\n30 4.\n08 89\n2v 4\n[ cs\n.D S]\n2 A\nug 2\n02 3"
        },
        {
            "heading": "1 Introduction",
            "text": "A spanner of a graph is a sparse subgraph that approximately preserves pairwise distances. Definition 1 (t-Spanner). Given graph G = (V,E) and t \u2265 1, a t-spanner is a subgraph H = (V,E\u2032) of G such that for every u, v \u2208 V we have\ndH(u, v) \u2264 t \u00b7 dG(u, v).\n(See Section 2 for standard notation and definitions). Since their formalization by [PS89], spanners have become indispensable in graph sparsfication and graph algorithms. For example, they have found applications in distributed broadcast [ABP90, Awe92], network synchronization [Awe85, PU87, ABP90, Awe92, Pel00a], overlay, sensor and wireless networks [BKR+02, VWF+03, KV02, VRW04, BSDS04, SS10], VLSI circuit design [CKR+91, CKR+92, SCRS01], routing [WCT02, TZ01], distance oracles [TZ05, Pel00b, RTZ05] and approximate shortest paths [Coh98, RZ04, Elk05, EZ04, FKM+05]. Generally speaking, these works make use of sparse spanners; namely, spanners with a small number of edges.\nOne of the simplest and most well-studied ways of computing a sparse t-spanner H is the greedy algorithm. The greedy algorithm is based on what we will call unspanned edges.\nDefinition 2 (Unspanned Edge). Given graph G = (V,E) and subgraph H \u2286 G, say that edge {u, v} \u2208 E is t-unspanned with respect to H \u2286 G if dH(u, v) > t. In other words, {u, v} is t-unspanned with respect to H if it does not close a (t + 1)-cycle in H. To compute a t-spanner H, the greedy algorithm simply repeatedly adds t-unspanned edges to H until none exist; see Algorithm 1.\nAlgorithm 1 Sequential Greedy Algorithm for t-Spanners\nInput: Graph G = (V,E) and t \u2265 1 Output: A t-spanner H of G Initialize H \u2190 \u2205 while \u2203e \u2208 E that is t-unspanned with respect to H do:\nH \u2190 H \u222a {e} return H\nIt is easy to see that the resulting H is indeed a t-spanner of G since, by construction, every edge in G has a length at most t path in H between its endpoints. Additionally, a classic analysis shows the result is sparse, containing at most most n1+O(1/t) edges [ADD+93, ABS+20]: by construction the graph output has girth at least t (i.e. contains no cycles of length t or less) and classic so-called Moore bounds state that a graph with girth at least t contains at most n1+O(1/t) edges. Assuming the \u201cErdo\u030bs Girth Conjecture\u201d [Erd65], this sparsity is asymptotically-optimal. Furthermore, the greedy spanner is existentially-optimal in that its output is as sparse as possible for any given graph family [FS16].\nHowever, one downside of the greedy algorithm is its apparent sequentialness: whether an edge is t-unspanned with respect to H is dependent on what edges have previously been added to H. Furthermore, the sparsity analysis of the output spanner is also quite delicate in that it relies on the output spanner having girth at most t and has little to say if the girth is much smaller than t.\nIn summary, the (sequential) greedy algorithm is one of the most well-studied algorithms for constructing a sparse t-spanner but seems inherently sequential and has a delicate sparsity analysis."
        },
        {
            "heading": "1.1 Our Results",
            "text": "In this work, we show that the classic sequential greedy algorithm, in fact, admits significant opportunities for parallelism while (approximately) retaining its sparsity guarantees. In particular, we show that even when many unspanned edges are added at once the resulting graph is still sparse. To formalize this, we generalize the above notion of an unspanned edge to a set of edges as follows.\nDefinition 3 (Unspanned Edge Set). Given graph G = (V,E) and subgraph H \u2286 G, edges E\u0302 \u2286 E are t-unspanned if each e \u2208 E\u0302 is t-unspanned with respect to H.\nThen, the parallel greedy algorithm computes a t-spannerH by simply repeatedly adding matchings of t-unspanned edges to H; see Algorithm 2 and Figure 1.\nAlgorithm 2 Parallel Greedy Algorithm for t-Spanners\nInput: Graph G = (V,E) and t \u2265 1 Output: A t-spanner H of G Initialize H \u2190 \u2205 while \u2203e \u2208 E that is t-unspanned do:\nLet M \u2286 E be any matching in G that is t-unspanned with respect to H H \u2190 H \u222aM\nreturn H\nOur main result is a proof of the sparsity of the output of the parallel greedy algorithm.\nTheorem 1. Parallel greedy (Algorithm 2) outputs a t-spanner with t3 \u00b7 log3 n \u00b7 n1+O(1/t) edges.\nEven stronger, we show that parallel greedy\u2019s output has arboricity at most t3 \u00b7 log3 n \u00b7 nO(1/t). For constant t, this recovers the usual n1+O(1/t) bound. While we state our results for unweighted graphs, the above can be made to work for edge-weighted graphs by a standard bucketing trick of weights at a cost of O(log n) in the sparsity.\nAnalysis Overview. The above result seems somewhat surprising in light of the usual analysis of the (sequential) greedy algorithm. As mentioned above, the output of the (sequential) greedy\nalgorithm has low sparsity on account of its large girth. However, a cycle on 4 nodes demonstrates that the parallel greedy algorithm can output a spanner with girth as small as 4, regardless of the value of t\u2014see Figure 2. As such, an entirely different approach to analyzing the sparsity of the output spanner is required.\nInstead of a girth-based argument, we make use of an analysis based on length-constrained expander decompositions, as recently introduced by [HRG22]. Roughly our analysis is as follows. A length-constrained expander decomposition allows us to assume that (up to the deletion of a small number of edges), given a matching in a graph with large minimum degree, one can find many t-length paths between the matching endpoints such that no edge is used by too many paths. On the other hand, a graph with large arboricity has a subgraph with large minimum degree and so if the output of our algorithm has large arboricity then we can find said non-overlapping paths for the last matching chosen by our algorithm. Since these paths do not overlap too much, one of them must not use any edges in the matching itself, contradicting the t-unspannedness of the edges we choose. Thus, our analysis provides an alternative approach to analyzing the sparsity of spanners output by greedy algorithms that does not rely on delicate girth-based arguments.\nApplications and Additional Related Work. While we make use of the above analysis to bound the sparsity of the parallel greedy algorithm, we believe that graphs produced by the parallel greedy algorithm\u2014which we call t-pg graphs\u2014are a fundamental extremal object which will find applications beyond this work. Indeed, while our approach makes use of (the existence of) lengthconstrained expander decompositions, it is also conversely useful for (algorithms for computing) length-constrained expander decompositions. Specifically, another work [HHT23] makes use of the sparsity of t-pg graphs to argue that the union of a sequence of sparse (length-constrained) cuts is itself a sparse (length-constrained) cut. This structural fact, in turn, was used by [HHT23] to give improved algorithms for computing length-constrained expander decompositions.\nLikewise, several works [BDPW18, BJ17, FVWY+20, BDR22, BHT22] prove lower bounds by considering graphs that are produced by adding batches of edges (not necessarily a matching) where no edge can complete a short cycle. For instance, this approach has been used to prove lower bounds on fault tolerant spanners [BDPW18] and the communication complexity of computing spanners [FVWY+20].\nIn summary, we show that the classic greedy algorithm admits significant opportunities for\nparallelism while retaining its sparsity guarantees. In the process of showing this, we introduce a new robust way of analyzing the density of a particular graph class which we expect to find applications beyond spanners. The remainder of this work is dedicated to showing Theorem 1."
        },
        {
            "heading": "2 Notation and Conventions",
            "text": "We review the notation and conventions we make use of throughout this work.\nGraphs. Let G = (V,E) be a graph and edge-length function lG. If unspecified then lG assigns every edge value 1. We let dG denote the shortest path metric according to lG in G. We let n := |V | and m := |E| be the number of vertices and edges. The girth of a graph is the minimum number of edges in a cycle. A matching M \u2286 E is a collection of pairwise disjoint edges. Given edges C we let G\u2212C := (V,E \\C) and G+C := (V,E \u222aC). We say a subgraph is non-empty if it contains at least one edge. We let EG(U,W ) := {{u, v} \u2208 E : u \u2208 U, v \u2208 W} and let degG(v) give the degree of v in G. For U \u2286 V , the induced subgraph G[U ] on U is (V,E(U)) where E(U) is all edges in E with both endpoints in U . We drop G subscript when it is clear from context.\nArboricity. A forest cover of graph G is a collection of edge-disjoint subgraphs F1, F2, . . . , Fk of G all of which are forests and whose union is G. k is the size of the forest cover and G is said to have arboricity \u03b1 if its minimum size forest cover has size \u03b1.\nFlows. A (multicommodity) flow F in G is a function that assigns to each simple path P in G a flow value F (P ) \u2265 0. We say P is a flow-path of F if F (P ) > 0. The congestion of F on an edge e is defined to be conF (e) = \u2211 P :e\u2208P F (P ). The congestion of F is maxe\u2208E(G) conF (e). The length (a.k.a. dilation) of F is the maximum length of any of its flow-paths.\nDemands. A demand D : V \u00d7V \u2192 R\u22650 assigns a non-negative value D(v, w) \u2265 0 to each ordered pair of vertices in V . The load of demand D is defined as\nload(D) := max v\n( max (\u2211 u D(u, v), \u2211 u D(v, u) )) .\nA demand D is unit if we have load(D) \u2264 deg(v) for every v \u2208 V . The size of a demand is written as |D| and is defined as \u2211 v,w D(v, w). A demand D is called h-length constrained (or simply h-length) in G if it assigns positive values only to pairs that are within distance at most h in G. Given a flow F , the demand routed by F is denoted by DF where, for each u, v \u2208 V , DF (u, v) = \u2211 P is a path from u to v F (P ) is the value of the flow from u to v.\nRouting Demands and Matchings with Flows. We say that a demand D is routable in G with congestion \u03b7 and dilation h iff there exists a flow F in G with congestion \u03b7 and dilation h where DF = D. We say that a matching M \u2286 E is \u03b4-routable with congestion \u03b7 and dilation h if the demand DM (u, v) = \u03b4 iff {u, v} \u2208M and 0 otherwise is routable with congestion \u03b7 and dilation h; here we imagine that each e \u2208M has a canonical u and v so that load(DM ) \u2264 \u03b4."
        },
        {
            "heading": "3 High Degree Subgraphs with Routable Matchings",
            "text": "Towards bounding the arboricity of the output of our parallel greedy algorithm, in this section we show that any graph of high minimum degree has a non-empty subgraph of essentially the same minimum degree where any matching can be routed with low dilation and congestion. Specifically, we show the following where \u03983 is a fixed universal constant hidden in Theorem 3; later stated.\nLemma 1. There exist universal constants \u03982, \u03983 such that for every t \u2265 2 if we let\n\u03d5 := 1/(2t \u00b7 n\u03983/t \u00b7 log n) and \u03b4 := 4\u03982 \u00b7 t log n/\u03d52\nthen every n-vertex graph H of minimum degree \u03b4, has a non-empty subgraph H \u2032 \u2286 H, such that\n1. Minimum Degree: H \u2032 has minimum degree at least \u03b4\u2032 := \u03d52t \u00b7 \u03b4 ; and\n2. Routings: Any matching M \u2286 H \u2032 is \u03b4\u2032-routable in H \u2032 with dilation t and congestion \u03b4\u2032/2.\nObserve that \u03b4\u2032-routing a matching with dilation 1 and congestion \u03b4\u2032 is trivial; notably the above improves this to congestion o(\u03b4\u2032). The rest of this section proves Lemma 1 with length-constrained expander decompositions."
        },
        {
            "heading": "3.1 Preliminary: Length-Constrained Expander Decompositions",
            "text": "Our proof of Lemma 1 makes use of length-constrained expander decompositions and so we begin by providing background on length-constrained expander decompositions, mostly from [HRG22]. In short, a length-constrained expander decomposition is a small number of edge length increases so that every length-constrained unit demand in the resulting graph can be routed with low congestion and dilation."
        },
        {
            "heading": "3.1.1 Length-Constrained Cuts (a.k.a. Moving Cuts)",
            "text": "We begin by giving formal definitions of length-constrained cuts which will allow us to define length-constrained expanders and length-constrained expander decompositions.\nThe following is the length-constrained analogue of a cut.\nDefinition 4 (Length-Constrained Cut (a.k.a. Moving Cut) [HWZ20]). An h-length cut (a.k.a. h-length moving cut) of graph G = (V,E) is a function C : E 7\u2192 {0, 1h , 2 h , . . . , 1}. The size of C is |C| := \u2211\neC(e). Any length-constrained cut with support in {0, 1} is called pure.\nThe following is the result of applying a length-constrained cut in a graph.\nDefinition 5 (G\u2212 C). For graph G = (V,E) with edge length function lG and length-constrained cut C, we let G\u2212C be G with the edge-length function which assigns e \u2208 E value lG(e) + h \u00b7C(e). If C is a pure cut then G\u2212 C is G with all edges in the support of C deleted.\nThe following gives the length-constrained analogue of separating a demand.\nDefinition 6 (h-Length Separated Demand). For any demand D and any h-length cut C, we define the amount of h-length separated demand as\nseph(C,D) = \u2211\nu,v:dG\u2212C(u,v)>h\nD(u, v).\nUsing demand separation, we can define cut sparsity in the length-constrained setting.\nDefinition 7 (h-Length Sparsity of a Cut C for Demand D). For any demand D and any h-length cut C with seph(C,D) > 0, the h-length sparsity of C with respect to D is\nsparsh(C,D) = |C|\nseph(C,D) .\nLikewise, we can define the overall sparsity of a length-constrained cut as follows.\nDefinition 8 ((h, s)-Length Sparsity of a Cut). The (h, s)-length sparsity of hs-length cut C is:\nspars(h,s)(C) = min h-length unit demand D sparss\u00b7h(C,D)."
        },
        {
            "heading": "3.1.2 Length-Constrained Expanders",
            "text": "We now move on to formally defining length-constrained expanders. Informally, they are graphs with no sparse length-constrained cuts.\nDefinition 9 ((h, s)-Length \u03d5-Expanders). A graph G is an (h, s)-length \u03d5-expander if every hslength cut has (h, s)-length sparsity at least \u03d5.\nWe now summarize the crucial properties of length-constrained expanders, namely the fact that they admit low congestion and dilation routings (see Lemma 3.16 of [HRG22]).\nTheorem 2 (Routing Characterization of Length-Constrained Expanders, [HRG22]). Given graph G, for any h \u2265 1, \u03d5 < 1, and s \u2265 1, there exists a universal constant \u03982:\n\u2022 Length-Constrained Expanders Have Good Routings: If G is an (h, s)-length \u03d5expander, then every h-length unit demand can be routed in G with congestion at most \u03982 \u00b7 log n/\u03d5 and dilation at most s \u00b7 h.\n\u2022 Not Length-Constrained Expanders Have an Unroutable Demand: If G is not an (h, s)-length \u03d5-expander, then some h-length unit demand cannot be routed in G with congestion at most 1/2\u03d5 and dilation at most s2 \u00b7 h."
        },
        {
            "heading": "3.1.3 Length-Constrained Expander Decompositions",
            "text": "Having defined length-constrained expanders, we can now define length-constrained expander decompositions. Informally, these are length-constrained cuts whose application renders the graph a length-constrained expander.\nMore specifically, we will make use of a strengthened version of length-constrained expander decompositions called \u201clinked\u201d length-constrained expander decompositions. Informally, this is a length-constrained expander decomposition which renders G length-constrained expanding even after adding many self-loops. This is a strengthened version because adding self-loops only makes it harder for a graph to be a length-constrained expander.\nThe following definition gives the self-loops we will add for a length-constrained expander decomposition C.\nDefinition 10 (Self-Loop Set L\u2113C). Let C be an h-length cut of a graph G = (V,E) and let \u2113 be a positive integer divisible by h. For any vertex v, define C(v) = \u2211 e\u220bv C(e). The self-loop set L \u2113 C consists of C(v) \u00b7 \u2113 self-loops at v. We let G+ L\u2113C := (V,E \u222a L\u2113C). Using the above self-loops, we can now define linked length-constrained expander decompositions.\nDefinition 11 (Linked Length-Constrained Expander Decomposition). Let G be a graph. An \u2113-linked (h, s)-length \u03d5-expander decomposition with cut slack \u03ba is an hs-length cut C such that |C| \u2264 \u03ba \u00b7 \u03d5m and G+ L\u2113C \u2212 C is an (h, s)-length \u03d5-expander.\nPrior work of [HRG22] demonstrated that for each \u03d5, a length-constrained expander decomposition always exist with length slack s = \u2126(n), cut slack \u03ba = O(log n) and linkedness \u2113 \u2265 \u2126(1/\u03d5\u00b7log n)."
        },
        {
            "heading": "3.2 Existence of Length-Constrained Expander Decompositions",
            "text": "In this work we will use the existence of pure length-constrained expanders which trade-off between s and \u03ba. Namely, we show the following theorem; our proof essentially follows that of [HRG22] but accounts for the pureness of our decompositions (paying an extra h in \u03ba) and uses a more general form of the \u201cexponential demand\u201d.\nTheorem 3 (Length-Constrained Expander Decompositions). There exists a constant \u03983 such that given graph G = (V,E) with edge lengths, h \u2265 1, s \u2265 100, \u03d5 \u2265 0 and any \u2113 \u2264 1/(100\u03d5 log n), there exists a pure \u2113-linked (h, s)-length \u03d5-expander decomposition with cut slack hs \u00b7 n\u03983/s \u00b7 log n. Proof. We denote by d(\u00b7, \u00b7) the shortest-path distance between edges in G. That is, for a pair e, e\u2032 \u2208 E(G), d(e, e\u2032) is the smallest total length of any path starting with e and ending with e\u2032.\nWe now define a demand D on G as follows. For a pair e, e\u2032 of edges in G, we set w(e, e\u2032) = n\u2212d(e,e \u2032)/(sh/2) if d(e, e\u2032) \u2264 sh/2, otherwise we set w(e, e\u2032) = 0. Denote w(e) = \u2211\ne\u2032 w(e, e \u2032), and define D(e, e\u2032) = w(e, e\u2032)/w(e), so for each e, \u2211\ne\u2032 D(e, e \u2032) = 1. Intuitively, we can think of D\nas a demand that sends, for each pair e, e\u2032, D(e, e\u2032) units of flow from e to e\u2032. Formally, we define the demand on vertices as follows. For every pair v, v\u2032 of vertices in G, we send D(v, v\u2032) =\u2211\ne\u223cv,e\u2032\u223cv\u2032 D(e, e \u2032) units of flow from v to v\u2032. As \u2211 e\u2032 D(e, e\n\u2032) = 1 holds for all e, we get that the demand D we defined on pairs of vertices is unit. We prove the following two claims.\nClaim 1. For every pair e, e\u2032 with d(e, e\u2032) \u2264 h, \u2211\ne\u2032\u2032 min {D(e, e\u2032\u2032), D(e\u2032, e\u2032\u2032)} \u2265 n\u22124/s.\nProof. Observe that, for every e\u2032\u2032,\nw(e\u2032, e\u2032\u2032) = n \u2212 d(e \u2032,e\u2032\u2032) (sh/2) \u2265 n\u2212 d(e,e\u2032)+d(e,e\u2032\u2032) (sh/2) \u2265 n\u2212 h (sh/2) \u00b7 n\u2212 d(e,e\u2032\u2032) (sh/2) = n\u22122/s \u00b7 w(e, e\u2032\u2032),\nand as a corollary, w(e\u2032) = \u2211 e\u2032\u2032 w(e\u2032, e\u2032\u2032) = \u2211 e\u2032\u2032 n \u2212 d(e \u2032,e\u2032\u2032) (sh/2) \u2265 \u2211 e\u2032\u2032 n\u22122/s \u00b7 w(e, e\u2032\u2032) = n\u22122/s \u00b7 w(e).\nTherefore, \u2211 e\u2032\u2032 min { D(e, e\u2032\u2032), D(e\u2032, e\u2032\u2032) } \u2265 \u2211 e\u2032\u2032 min { w(e, e\u2032\u2032) w(e) , w(e\u2032, e\u2032\u2032) w(e\u2032) }\n\u2265 \u2211 e\u2032\u2032 n\u22122/s \u00b7 w(e, e\u2032\u2032) n2/s \u00b7 w(e) \u2265 n\u22124/s.\nClaim 2. Let C be any moving cut with spars(h,s)(C) \u2264 \u03d5. Then sparsh,s/2(C,D) \u2264 2\u03d5n4/s.\nProof. Let D\u2217 be a unit h-hop demand with spars(h,s)(C,D \u2217) \u2264 \u03d5. As D\u2217 is a unit demand, we first distributed the demand on each vertex to its incident edges, such that each edge sends and receives at most 1 unit of flow. Consider the resulting demand D\u2217\u2217 on edges. Note that, by concatenating a demand of D\u2217\u2217(e, e\u2032) \u00b7min {D(e, e\u2032\u2032), D(e\u2032, e\u2032\u2032)} from e to every e\u2032\u2032 and a demand from e\u2032\u2032 to e\u2032 with the same amount, where we essentially applied the demandD twice (where the second time we use it in the opposite direction), we obtain a demand that sends at leastD\u2217\u2217(e, e\u2032)\u00b7n\u22124/s units of flow from eto e\u2032, for every pair e, e\u2032. If e and e\u2032 are at distance at least sh in G\u2212C then either the pair e, e\u2032\u2032 or the pair e\u2032\u2032, e must be at distance at least sh/2. Therefore, sephs/2(C,D) \u2265 (n\u22124/s/2) \u00b7sephs(C,D\u2217), and so spars(h,s/2)(C,D) \u2264 2n\u22124/s \u00b7 spars(h,s)(C,D\u2217) \u2264 2\u03d5n4/s.\nWe now provide the proof of Theorem 3 by a simple algorithm. While there exists a moving cut C in G that is (h, s)-hop \u03d5-sparse, we let C\u0304 be the pure cut corresponding to C (that is, C\u0304 contains all edges with non-zero values in C, so |C\u0304| \u2264 hs \u00b7 |C|), update G \u2190 G \u2212 C\u0304 + L\u2113\nC\u0304 and continue. It\nis easy to verify that our algorithm ends with G being an \u2113-linked (h, s)-hop \u03d5-expander. It suffices to count the total number of deleted edges, for which we define a potential function as follows. For each edge (including self-loop) in G, we define its potential to be ln(w(e)) \u00b74hsn4/s. For every unit of moving cut that we applied to G, we define its potential to be 1/\u03d5. Initially, the total potential is at most |E(G)|\u00b7log |E(G)|\u00b74hs\u00b7n4/s (each edge has potential at most log |E(G)|\u00b74hs\u00b7n4/s) and there is no moving cut applied. We will show that, after each iteration (where a cut is applied to G and corresponding self-loops are added), the potential never increases. Note that this implies that the total number of deleted edges is at most \u03d5 \u00b7 |E(G)| \u00b7 log |E(G)| \u00b7 4hs \u00b7 n4/s, completing the proof of Theorem 3 (as |E(G)| \u2264 n2).\nAccording to the algorithm, in an iteration where a sparse cut C is found, we apply C\u0304 to G and add self-loops, which increases the potential by at most\n|C| \u00b7 hs/\u03d5+ |C| \u00b7 hs \u00b7 \u2113 log n \u2264 2 \u00b7 |C| \u00b7 hs/\u03d5,\nas \u2113 \u2264 1/(100\u03d5 log n). On the other hand, the potential decrease is at least\n4n4/s \u00b7 hs \u00b7 \u2211\ne\u2208E(G)\nln(w(e))\u2212 ln(w\u2032(e)) \u2265 4n4/s \u00b7 hs \u00b7 \u2211\ne\u2208E(G)\nw(e)\u2212 w\u2032(e) w(e) ,\nwhere w\u2032(e) represents the weight of e in the updated graph G. From Claim 2, we know that the (h, s/2)-hop sparsity of C for D is at most 2\u03d5n4/s. This means that sepsh/2(C,D) \u2265 |C|/(2\u03d5n4/s). On the other hand, by definition of D, the right-hand-side of the above inequality is at least the amount of demand that is sh/2-separated by C (as those demand will have weight w\u2032(e, e\u2032) = 0 according to our definition), and so is at least |C|/(2\u03d5n4/s). Altogether, we get that the potential decrease is at least\n4n4/s \u00b7 hs \u00b7 |C|/(2\u03d5n4/s) \u2265 2 \u00b7 |C| \u00b7 hs/\u03d5,\nwhich is an upper bound of the potential increase. This completes the proof that the potential never increases."
        },
        {
            "heading": "3.3 High Degree Routable Matching Subgraphs (Lemma 1 Proof)",
            "text": "We conclude this section with our proof of Lemma 1.\nLemma 1. There exist universal constants \u03982, \u03983 such that for every t \u2265 2 if we let\n\u03d5 := 1/(2t \u00b7 n\u03983/t \u00b7 log n) and \u03b4 := 4\u03982 \u00b7 t log n/\u03d52\nthen every n-vertex graph H of minimum degree \u03b4, has a non-empty subgraph H \u2032 \u2286 H, such that\n1. Minimum Degree: H \u2032 has minimum degree at least \u03b4\u2032 := \u03d52t \u00b7 \u03b4 ; and\n2. Routings: Any matching M \u2286 H \u2032 is \u03b4\u2032-routable in H \u2032 with dilation t and congestion \u03b4\u2032/2.\nProof. The basic idea of the proof is as follows. We first take a linked length-constrained expander decomposition. Then, the result of applying this length-constrained expander decomposition must have high minimum degree because if any vertex v has its degree drop too low we can find a sparse length-constrained cut (namely the singleton cut separating that v). Likewise, matchings are routable with low dilation and congestion because the result of applying our length-constrained expander decomposition is a length-constrained expander.\nWe begin by more formally describing our length-constrained expander decomposition. Specifically, we apply Theorem 3 to graph H with parameters h = 1, s = t and \u2113 = 1/(100\u03d5 log n). We let C be the resulting pure cut which is a 1/(100\u03d5 log n)-linked (h, s)-length \u03d5-expander decomposition for H with cut slack t \u00b7 n\u03983/t \u00b7 log n.\nWe first define H \u2032. Observe that by our choice of \u03d5 we have\n|C| \u2264 t \u00b7 n\u03983/t \u00b7 log n \u00b7 \u03d5 \u00b7 |E(H)|\n\u2264 |E(H)| 2\nand therefore H \u2212 C contains at least one edge. We let H \u2032 be an arbitrary connected component of H \u2212 C with at least one edge. It remains to show that H \u2032 satisfies the properties required in Lemma 1.\nWe first show that the minimum degree in H \u2032 is at least \u03b4\u2032. Assume for the sake of contradiction that there is a vertex v in H \u2032 such that degH\u2032(v) < \u03b4\n\u2032. Since H \u2032 is a connected graph with at least two vertices, v has at least one neighbor in H \u2032; let u be an arbitrary such neighbor. By our choice of \u03d5 and l, we have that\nl = 1/(100\u03d5 log n) = t \u00b7 n\u03983/t/50 = \u03c9(1) \u2265 2 (1)\nand\n\u03b4\u2032 = \u03d5 2t \u00b7 \u03b4 = 1 4t2 \u00b7 n\u03983/t \u00b7 log n \u00b7 \u03b4 \u2264 \u03b4 2 . (2)\nThus, from the definition of the set L\u2113C and our choice of \u03b4 \u2032 and \u03d5 and applying Equations 1 and 2, the number of self loops at v in H \u2212 C + L\u2113C is at least\n(\u03b4 \u2212 \u03b4\u2032) \u00b7 l \u2265 \u03b4.\nLikewise, the degree of u in H \u2212C +L\u2113C is at least \u03b4 since in H it has degree at least \u03b4, and if the cut C assigns non-zero values to d of its incident edges, then d\u2113 > d self-loops will be added to u.\nNext, consider the demand D0 which gives value \u03b4 to (u, v) and 0 to all other pairs of vertices. Since both u and v have degree at least \u03b4 in H \u2212C +L\u2113C , it follows that D0 is unit in H \u2212C +L\u2113C . Likewise, since u and v are adjacent in H \u2032, D0 is a 1-length demand in H \u2212 C + L\u2113C .\nLet C0 be the length-constrained cut that assigns value t to all edges in EH\u2032({v} , V (H \u2032) \\ {v}) and value 0 to all other edges. Since v has degree at most \u03b4\u2032 in H \u2032 we have\n|C0| \u2264 t \u00b7 \u03b4\u2032. (3)\nHowever, C0 t-separatesD0 inH\u2212C+L\u2113C and sinceD0 is a unit 1-length demand andH\u2212C+L\u2113C is a (1, t)-length \u03d5-expander it follows that\n|C0| \u2265 \u03d5 \u00b7 |D0| = \u03d5 \u00b7 \u03b4. (4)\nCombining Equations 3 and 4 we get\n\u03d5 \u00b7 \u03b4 \u2264 t \u00b7 \u03b4\u2032\nwhich contradicts the definition of \u03b4\u2032 as \u03d52t \u00b7 \u03b4. It remains to show that any matching in H \u2032 is \u03b4\u2032-routable with dilation t and congestion at most \u03b4\u2032/2. Consider matching M \u2286 H \u2032 and let DM be the demand which assigns (u, v) value \u03b4\u2032 for each {u, v} \u2208M (for a canonical ordering of the vertices). DM is 1-length by construction and unit in H \u2032 since every vertex in H \u2032 has degree at least \u03b4\u2032. Furthermore, H \u2032 is a (1, t)-length \u03d5-expander since H \u2212 C + L\u2113C is and so DM can be routed with dilation t and congestion\n\u03982 \u00b7 log n/\u03d5 \u2264 \u03b4\u2032/2\nin H \u2032."
        },
        {
            "heading": "4 Bounding the Arboricity of Parallel Greedy Graphs",
            "text": "Having shown how to route in high minimum degree graphs in the previous section, in this section we bound the arboricity of any graph constructed in the manner of the parallel greedy algorithm. We abstract out such graphs with the notion of a parallel greedy graph.\nDefinition 12 (t-pg Graphs). Let V be a set of vertices. We say that a sequence of edge sets (E1, . . . , Ek) on V is t-pg for some integer t \u2265 2, iff for each i \u2208 [k],\n\u2022 Ei is a matching on V ; and \u2022 dGi\u22121(u, v) > t for each (u, v) \u2208 Ei where Gi\u22121 the graph on V with edges \u22c3 1\u2264j\u2264i\u22121Ej.\nWe say that a graph G = (V,E) is t-pg iff its edge set E is the union of some t-pg sequence on V .\nThe following summarizes our bound on the arboricity of t-pg graphs.\nTheorem 4. Every t-pg graph on n vertices has arboricity t3 \u00b7 log3 n \u00b7 nO(1/t).\nThe remainder of this section is dedicated to a proof of Theorem 4. In particular, we will observe that if our parallel greedy graph has high arboricity then it has a high minimum degree subgraph and this subgraph admits low congestion and dilation routings (by Lemma 1). We will then use these routings to contradict the parallel greediness of the input graph."
        },
        {
            "heading": "4.1 Preliminary: Minimum-Degree Subgraphs from Arboricity",
            "text": "We begin by noting a known fact about high minimum degree subgraphs of high arboricity graphs.\nLemma 2. Let G = (V,E) be a graph with arboricity \u03b1. Then, G has a non-empty induced subgraph with minimum degree at least \u03b1/2.\nThe rest of this section is dedicated to showing this folklore fact using some standard arguments. To show Lemma 2, we will make use of a famous result of Nash-Williams characterizing graph arboricity in terms of graph density as well as two simple helper lemmas.\nTheorem 5 ([NW61, NW64, CMW+94]). Graph G = (V,E) has arboricity at most \u03b1 iff for every U \u2286 V we have\n|E(U)| \u2264 \u03b1 \u00b7 (|U | \u2212 1).\nLikewise we make use of the following two simple helper lemmas.\nLemma 3. Let G = (V,E) be a connected graph with arboricity \u03b1. Then |E|+ 1 \u2265 |V | \u2212 1 + \u03b1.\nProof. Let F1, F2, . . . , F\u03b1 be the minimum size forest decomposition of G. We may assume that F1 is a spanning tree of G since if it is not we can always move edges from Fi for i \u2265 2 to F1 to make it a spanning tree. Furthermore, we may assume that each Fi contains at least one edge (otherwise we would have violated the definition of arboricity). It follows that F1 contains |V | \u2212 1 unique edges and Fi for i \u2265 2 contains at least one unique edge, giving the inequality.\nLemma 4. Let G = (V,E) be a graph with average degree \u03c1 := \u2211\nu degG(u) |V | . Then there is a\nnon-empty U \u2286 V such that G[U ] has minimum degree at least \u03c1/2.\nProof. Our proof is by the following construction: initialize U to V ; while there exists a vertex u \u2208 U such that degG[U ](u) < \u03c1/2 remove u from U . By construction the minimum degree of G[U ] is at least \u03c1/2.\nTo see that U is non-empty, let\n\u03c1U :=\n\u2211 u\u2208U degG[U ](u)\n|U |\nbe the average degree of U . It suffices to show that our construction always satisfies \u03c1U > 0 since if U is empty at the end of our construction then at some point the numerator of \u03c1U would be 0 and the denominator would be 1 (namely, when |U | = 1). This follows since initially \u03c1U has value \u03c1 and each time we remove a vertex from u we decrease the numerator of \u03c1U by strictly less than \u03c1 and the denominator by 1.\nUsing the above theorem of Nash-Williams and our two helper lemmas, we conclude with a proof of Lemma 2.\nLemma 2. Let G = (V,E) be a graph with arboricity \u03b1. Then, G has a non-empty induced subgraph with minimum degree at least \u03b1/2.\nProof. By Theorem 5 there is a non-empty U \u2286 V such that\n|E(U)| \u2265 (\u03b1\u2212 1) \u00b7 (|U | \u2212 1) + 1 (5)\nsince other we could decrease \u03b1 by 1 and still satisfy the inequality in Theorem 5, contradicting Theorem 5. We can assume without loss of generality that U is connected. Applying Lemma 3 and the fact that G[U ] has arboricity at least \u03b1 we have\n|E(U)|+ 1 \u2265 |U | \u2212 1 + \u03b1 (6)\nThus, combining Equations 5 and 6 we have\n2|E(U)| \u2265 \u03b1 \u00b7 |U |\nIt follows that the average degree of a vertex in G[U ] is\u2211 u\u2208U degG[U ](u)\n|U | = 2|E(U)| |U | \u2265 \u03b1.\nand so by Lemma 4 we know that G[U ] and therefore G contains a subgraph of minimum degree at least \u03b1/2."
        },
        {
            "heading": "4.2 Arboricity of Parallel Greedy Graphs (Theorem 4 Proof)",
            "text": "In this section, we provide the proof of Theorem 4. We make use of Lemma 1 and Lemma 2 from previous sections. We also make use of the following simple helper lemma.\nLemma 5. Every subgraph of a t-pg graph is also a t-pg graph.\nProof. Let G be a t-pg graph and let H be a subgraph of G. Let (E1, . . . , Ek) be the t-pg sequence that generates G. For each i \u2208 [k], let E\u2032i be the subset of Ei that contains all edges lying in H. Clearly, E\u2032i is a matching inH, and if we denote byHi\u22121 the graph induced by edges in \u22c3 1\u2264j\u2264i\u22121E \u2032 j , then for every edge (u, v) \u2208 E\u2032i we have\ndHi\u22121(u, v) > t.\nThis follows because otherwise we have\ndGi\u22121(u, v) \u2264 dHi\u22121(u, v) \u2264 t\nand since Hi\u22121 is a subgraph of Gi\u22121 and (u, v) is also an edge in Ei, this leads to a contradiction to the assumption that (E1, . . . , Ek) is a t-pg sequence.\nWe conclude with our proof of Theorem 4, illustrated in Figure 3.\nTheorem 4. Every t-pg graph on n vertices has arboricity t3 \u00b7 log3 n \u00b7 nO(1/t).\nProof. Throughout this proof we use the following parameters:\n\u03d5 = 1/(2 \u00b7 t \u00b7 n\u03983/t \u00b7 log n) and \u03b4 = 4\u03982 \u00b7 t log n/\u03d52 = t3 \u00b7 log3 n \u00b7 nO(1/t)\nwhere \u03983 is the constant stated in Theorem 3 and \u03982 is the constant stated in Theorem 2. Let G be any t-pg graph. Assume for contradiction that G has arboricity greater than 2\u03b4. It follows by Lemma 2 that G has a non-empty (induced) subgraph H of minimum degree at least \u03b4. We now use Lemma 1 to complete the proof. We apply Lemma 1 to H, \u03d5 and t. Let H \u2032 be the subgraph we obtain, so H \u2032 is a subgraph of H and a subgraph of G, and therefore also a t-pg graph (by Lemma 5). Let (E\u20321, . . . , E \u2032 k) be a t-pg sequence that generates H\n\u2032. Denote M = E\u2032k as the last set in this sequence.\nFrom Lemma 1, there exists a flow F that sends \u03b4\u2032 = \u03d52t \u00b7 \u03b4 units of flow from u to v in H \u2032 for each edge {u, v} \u2208 M with congestion \u03b4\u2032/2 and dilation t. Thus, the total amount of flow sent by F from sources to sinks is |M | \u00b7 \u03b4\u2032. On the other hand, each edge in H \u2032 carries at most \u03b4\u2032/2 units of flow and so all edges of M carry at most |M | \u00b7 (\u03b4\u2032/2) < |M | \u00b7 \u03b4\u2032 units of flow.\nThus, some flow must be sent along a path that does not contain edges of M . Let {u, v} be the endpoints of such a path. As the flow only uses paths of length at most t, this implies that dH\u2032\\M (u, v) \u2264 t, and it follows that dH\u2032\\M (u, v) \u2264 t, a contradiction to the fact that H \u2032 is a t-pg graph."
        },
        {
            "heading": "5 Sparse Spanner from Parallel Greedy (Theorem 1 Proof)",
            "text": "We conclude with our proof that the parallel greedy algorithm produces a sparse t-spanner.\nTheorem 1. Parallel greedy (Algorithm 2) outputs a t-spanner with t3 \u00b7 log3 n \u00b7 n1+O(1/t) edges.\nProof. The argument that the output graph H is a t-spanner is identical to the usual analysis of the greedy algorithm; in particular, if G has no t-unspanned edges with respect to H then H is a t-spanner. This follows since in such an H, every edge {u, v} \u2208 G is either in H or dH(u, v) \u2264 t.\nThus, for two arbitrary vertices u and v with shortest path P = (u = v0, v1, v2, . . . , vk = v) in G we have dH(vi\u22121, vi) \u2264 t for each i \u2208 [k] and so\ndH(u, v) \u2264 \u2211 i\u2208[k] dH(vi\u22121, vi) \u2264 t \u00b7 |P | = t \u00b7 dG(u, v).\nLikewise, by construction the output of the parallel greedy algorithm is a t-pg graph. Thus, by Theorem 4 it has arboricity at most t3 \u00b7 log3 n \u00b7 nO(1/t) and so contains at most t3 \u00b7 log3 n \u00b7 n1+O(1/t) edges."
        },
        {
            "heading": "6 Conclusion and Future Directions",
            "text": "In this work we showed that the classic greedy algorithm for constructing t-spanners produces sparse t-spanners even when many edges from a matching are added in parallel. Using a simple application of length-constrained expander decompositions, we demonstrated that this process results in a graph with at most t3 \u00b7 log3 n \u00b7 n1+O(1/t) edges.\nThe most obvious future direction is to tightly characterize the density of the spanners produced by this algorithm. In contrast, to the classic sequential greedy algorithm, simple examples (e.g. the n-dimensional hypercube) demonstrate that the t-spanners produced by the parallel greedy algorithm contain at least \u2126(n \u00b7 log n)-many edges. As such, an exciting future direction is to determine whether or not this simple lower bounds can be matched on the upper bounds side. Furthermore, our work is a simple application of length-constrained expander decompositions. Work in algorithms work has only recently begun to fully develop applications of these decompositions and so we leave further applications as an exciting future direction. Likewise, we believe t-pg are a fundamental graph class and leave further applications of their sparsity as a future direction."
        },
        {
            "heading": "Acknowledgements",
            "text": "We would like to thank Greg Bodwin for helpful comments and references. Haeupler and Hershkowitz supported in part by NSF grants CCF-1527110, CCF-1618280, CCF1814603, CCF-1910588, NSF CAREER award CCF1750808, a Sloan Research Fellowship, funding from the European Research Council (ERC) under the European Union\u2019s Horizon 2020 research and innovation program (ERC grant agreement 949272) and the Swiss National Foundation (project grant 200021 184735). Hershkowitz also funded by the SNSF, Swiss National Science Foundation grant 200021 184622. Tan supported by a grant to DIMACS from the Simons Foundation (820931)."
        }
    ],
    "title": "Parallel Greedy Spanners",
    "year": 2023
}