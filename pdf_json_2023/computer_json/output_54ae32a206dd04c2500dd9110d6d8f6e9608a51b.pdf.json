{
    "abstractText": "Algorithmicists are well-aware that fast dynamic programming algorithms are very often the correct choice when computing on compositional (or even recursive) graphs. Here we initiate the study of how to generalize this folklore intuition to mathematical structures writ large. We achieve this horizontal generality by adopting a categorial perspective which allows us to show that: (1) structured decompositions (a recent, abstract generalization of many graph decompositions) define Grothendieck topologies on categories of data (adhesive categories) and that (2) any computational problem which can be represented as a sheaf with respect to these topologies can be decided in linear time on classes of inputs which admit decompositions of bounded width and whose decomposition shapes have bounded feedback vertex number. This immediately leads to algorithms on objects of any C-set category; these include \u2013 to name but a few examples \u2013 structures such as: symmetric graphs, directed graphs, directed multigraphs, hypergraphs, directed hypergraphs, databases, simplicial complexes, circular port graphs and halfedge graphs. Thus we initiate the bridging of tools from sheaf theory, structural graph theory and parameterized complexity theory; we believe this to be a very fruitful approach for a general, algebraic theory of dynamic programming algorithms. Finally we pair our theoretical results with concrete implementations of our main algorithmic contribution in the AlgebraicJulia ecosystem.",
    "authors": [
        {
            "affiliations": [],
            "name": "ERNST ALTHAUS"
        }
    ],
    "id": "SP:c881cedf7cc4695ecb766653d582d030b8cc7316",
    "references": [
        {
            "authors": [
                "S Abramsky",
                "N. Shah"
            ],
            "title": "Relating structure and power: Comonadic semantics for computational resources",
            "venue": "Journal of Logic and Computation,",
            "year": 2021
        },
        {
            "authors": [
                "R. Diestel"
            ],
            "title": "Graph Decompositions: a study in infinite graph theory",
            "year": 1990
        },
        {
            "authors": [
                "Robertson N",
                "Seymour PD"
            ],
            "title": "Graph minors. II. Algorithmic aspects of tree-width",
            "venue": "Journal of Algorithms,",
            "year": 1986
        },
        {
            "authors": [
                "Robertson N",
                "Seymour PD"
            ],
            "title": "Graph minors X. Obstructions to tree-decomposition",
            "venue": "Journal of Combinatorial Theory, Series B,",
            "year": 1991
        },
        {
            "authors": [
                "U Bertel\u00e8",
                "F. Brioschi"
            ],
            "title": "Nonserial dynamic programming",
            "venue": "doi:https://doi.org/ 10.1016/s0076-5392(08)x6010-2",
            "year": 1972
        },
        {
            "authors": [
                "R. Halin"
            ],
            "title": "S-functions for graphs",
            "venue": "Journal of Geometry,",
            "year": 1976
        },
        {
            "authors": [
                "S. i Oum"
            ],
            "title": "Graphs of Bounded Rank-width",
            "venue": "Ph.D. thesis, Princeton University,",
            "year": 2005
        },
        {
            "authors": [
                "J Geelen",
                "O j Kwon",
                "R McCarty",
                "P. Wollan"
            ],
            "title": "The Grid Theorem for vertex-minors",
            "venue": "Journal of Combinatorial Theory, Series B,",
            "year": 2020
        },
        {
            "authors": [
                "P. Wollan"
            ],
            "title": "The structure of graphs not admitting a fixed immersion",
            "venue": "Journal of Combinatorial Theory, Series B,",
            "year": 2015
        },
        {
            "authors": [
                "T Johnson",
                "N Robertson",
                "PD Seymour",
                "R. Thomas"
            ],
            "title": "Directed tree-width",
            "venue": "Journal of combinatorial theory. Series B,",
            "year": 2001
        },
        {
            "authors": [
                "D Berwanger",
                "A Dawar",
                "P Hunter",
                "S Kreutzer",
                "J. Obdr\u017e\u00e1lek"
            ],
            "title": "The DAG-width of directed graphs",
            "venue": "Journal of Combinatorial Theory, Series B,",
            "year": 2012
        },
        {
            "authors": [
                "P Hunter",
                "S. Kreutzer"
            ],
            "title": "Digraph Measures: Kelly Decompositions\u201a Games\u201a and Orderings",
            "venue": "Theoretical Computer Science (TCS),",
            "year": 2008
        },
        {
            "authors": [
                "Safari MA"
            ],
            "title": "D-width: A more natural measure for directed tree width",
            "venue": "In: International Symposium on Mathematical Foundations of Computer Science. Springer,",
            "year": 2005
        },
        {
            "authors": [
                "Kreutzer S",
                "Kwon Oj"
            ],
            "title": "Digraphs of Bounded Width",
            "venue": "Classes of Directed Graphs,",
            "year": 2018
        },
        {
            "authors": [
                "BM Bumpus",
                "K Meeks",
                "W. Pettersson"
            ],
            "title": "Directed branch-width: A directed analogue of tree-width",
            "venue": "arXiv preprint arXiv:2009.08903,",
            "year": 2020
        },
        {
            "authors": [
                "V Dujmovi\u0107",
                "P Morin",
                "DR. Wood"
            ],
            "title": "Layered separators in minor-closed graph classes with applications",
            "venue": "Journal of Combinatorial Theory, Series B,",
            "year": 2017
        },
        {
            "authors": [
                "F. Shahrokhi"
            ],
            "title": "New representation results for planar graphs",
            "venue": "arXiv preprint arXiv:1502.06175,",
            "year": 2015
        },
        {
            "authors": [
                "BMP Jansen",
                "JJH de Kroon",
                "M. W\u0142odarczyk"
            ],
            "title": "Vertex Deletion Parameterized by Elimination Distance and Even Less",
            "venue": "Proceedings of the 53rd Annual ACM SIGACT Symposium on Theory of Computing,",
            "year": 2021
        },
        {
            "authors": [
                "M. Grohe"
            ],
            "title": "Descriptive Complexity, Canonisation, and Definable Graph Structure Theory, Cambridge University Press, Cambridge, 2017, x + 544 pp. The Bulletin of Symbolic Logic, 2017",
            "year": 2017
        },
        {
            "authors": [
                "B Courcelle",
                "J. Engelfriet"
            ],
            "title": "Graph structure and monadic second-order logic: a language-theoretic approach, volume 138",
            "year": 2012
        },
        {
            "authors": [
                "J Flum",
                "M. Grohe"
            ],
            "title": "Parameterized Complexity Theory",
            "venue": "Texts Theoret. Comput. Sci. EATCS Ser,",
            "year": 2006
        },
        {
            "authors": [
                "Downey RG",
                "Fellows MR"
            ],
            "title": "Fundamentals of parameterized complexity, volume",
            "venue": "URL https://doi.org/10.1007/978-1-4471-5559-1",
            "year": 2013
        },
        {
            "authors": [
                "J. Leray"
            ],
            "title": "Lanneau dhomologie dune reprsentation",
            "venue": "CR Acad. Sci. Paris,",
            "year": 1946
        },
        {
            "authors": [
                "Gray JW"
            ],
            "title": "Fragments of the history of sheaf theory. In: Applications of Sheaves: Proceedings of the Research Symposium on Applications of Sheaf Theory to Logic, Algebra, and Analysis, Durham, July 9\u201321",
            "venue": "URL https://doi.org/10.1007/BFb0061812",
            "year": 1977
        },
        {
            "authors": [
                "D. Rosiak"
            ],
            "title": "Sheaf Theory through Examples",
            "venue": "ISBN 9780262370424",
            "year": 2022
        },
        {
            "authors": [
                "S MacLane",
                "I. Moerdijk"
            ],
            "title": "Sheaves in geometry and logic: A first introduction to topos theory",
            "venue": "Springer Science & Business Media,",
            "year": 2012
        },
        {
            "authors": [
                "Oum Si",
                "Seymour PD"
            ],
            "title": "Approximating clique-width and branch-width",
            "venue": "Journal of Combinatorial Theory, Series B,",
            "year": 2006
        },
        {
            "authors": [
                "S Libkind",
                "A Baas",
                "E Patterson",
                "J. Fairbanks"
            ],
            "title": "Operadic modeling of dynamical systems: mathematics and computation",
            "venue": "arXiv preprint arXiv:2105.12282,",
            "year": 2021
        },
        {
            "authors": [
                "BM Bumpus",
                "ZA Kocsis",
                "JE. Master"
            ],
            "title": "Structured Decompositions: Structural and Algorithmic Compositionality",
            "venue": "arXiv preprint arXiv:2207.06091,",
            "year": 2022
        },
        {
            "authors": [
                "E Patterson",
                "O Lynch",
                "J. Fairbanks"
            ],
            "title": "Categorical data structures for technical computing",
            "venue": "arXiv preprint arXiv:2106.04703,",
            "year": 2021
        },
        {
            "authors": [
                "S Lack",
                "P. Sobocinski"
            ],
            "title": "Adhesive Categories. In: Walukiewicz I (ed.), Foundations of Software Science and Computation Structures",
            "venue": "ISBN 978-3-540-24727-2,",
            "year": 2004
        },
        {
            "authors": [
                "Bodlaender HL",
                "Fomin FV"
            ],
            "title": "Tree decompositions with small cost. In: Algorithm Theory\u2014SWAT",
            "venue": "Scandinavian Workshop on Algorithm Theory Turku, Finland, July",
            "year": 2002
        },
        {
            "authors": [
                "E. Riehl"
            ],
            "title": "Category theory in context",
            "venue": "Courier Dover Publications,",
            "year": 2017
        }
    ],
    "sections": [
        {
            "text": "Thus we initiate the bridging of tools from sheaf theory, structural graph theory and parameterized complexity theory; we believe this to be a very fruitful approach for a general, algebraic theory of dynamic programming algorithms. Finally we pair our theoretical results with concrete implementations of our main algorithmic contribution in the AlgebraicJulia ecosystem.\nKeywords: Parameterized Complexity, Dynamic Programming, Sheaf Theory, Category Theory"
        },
        {
            "heading": "1. Introduction",
            "text": "As pointed out by Abramsky and Shah [1], there are two main \u201corganizing principles in the foundation of computation\u201d: these are structure and power. The first is concerned with compositionality and semantics while the second focuses on expressiveness and computational complexity.\nSo far these two areas have remained largely disjoint. This is due in part to mathematical and linguistic differences, but also to perceived differences in the research focus. However, we maintain that many of these differences are only superficial ones and that compositionality has always been a major focus of the \u201cpower\u201d community. Indeed, although this has not yet formalized as such (until now), dynamic programming and graph decompositions are clear witnesses of the importance of compositionality in the field. Thus the main characters of the present story are:\n(SC) the Structural compositionality arising in graph theory in the form of graph decompositions and graph width measures (whereby one decomposes graphs into smaller and simpler constituent parts [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]),\n(AC) the Algorithmic compositionality embodied by the intricate dynamic programming routines found in parameterized complexity theory [22, 23, 24, 25, 26],\n(RC) and the Representational compositionality1 arising in algebraic topology and virtually throughout the rest of mathematics in the form of sheaves [28, 29, 30] (whereby one systematically\n1We choose the term \u201crepresentational\u201d as a nod to Leray\u2019s [27] 1946 understanding of what sheaf theory should be: \u201cNous nous proposons d\u2019indiquer sommairement comment les m\u00e9thodes par lesquelles nous avons etudi\u00e9 la topologie d\u2019un espace\nassigns data to \u2018spaces\u2019 in such a way that one can easily keep track of how local data interacts with global data).\nThe study of graph decompositions and their associated \u2018width measures\u2019 has been an extremely active area of research which has generated a myriad of subtly different methods of decomposition [6, 7, 4, 23, 22, 2, 31, 12, 13, 14, 15, 16, 18, 19, 20, 21, 11, 17, 32]. From a computationally minded perspective, these notions are crucial for dynamic programming since they can be seen as data structures for graphs with compositional structure [22, 23, 25, 26].\nSheaves on the other hand supply the canonical mathematical structure for attaching data to spaces (or something \u201cspace-like\u201d), where this further consists of restriction maps encoding some sort of local constraints or relationships between the data, and where the sheaf structure prescribes how compatible local data can be combined to supply global structure. As such, the sheaf structure lets us reason about situations where we are interested in tracking how compatible local data can be stitched together into a global data assignment. While sheaves were already becoming an established instrument of general application by the 1950s, first playing decisive roles in algebraic topology, complex analysis in several variables, and algebraic geometry, their power as a framework for handling all sorts of local-to-global problems has made them useful in a variety of areas and applications, including sensor networks, target tracking, dynamical systems (see the textbook by Rosiak [29] for many more examples and references).\nOur contribution is to show how to use tools from both sheaf theory and category theory to bridge the chasm separating the \u201cstructure\u201d and \u201cpower\u201d communities. Indeed our main algorithmic result (Theorem 1.1) is a meta-theorem obtained by amalgamating these three perspectives. Roughly it states that any decision problem which can be formulated as a sheaf can be solved in linear time on classes of inputs which can built compositionally out of constituent pieces which have bounded internal complexity. In more concrete terms, this result yields linear (FPT-time) algorithms for problems such as H-coloring (and generalizations thereof) on a remarkably large class of mathematical structures; a few examples of these are: 1. databases, 2. simple graphs, 3. directed graphs, 4. directed multigraphs, 5. hypergraphs, 6. directed hypergraphs (i.e. Petri nets), 7. simplicial complexes, 8. circular port graphs [33] and 9. half-edge graphs.\nTo be able to establish (or even state) our main algorithmic result, one must first overcome two highly nontrivial hurdles. The first is that one needs to make sense of what it means for mathematical objects (which need not be graphs) to display compositional structure. The second is that, in order to encode computational problems as sheaves, one must first equip the input objects with a notion of a topology which moreover is expressive enough to encode the compositional structure of the input instances.\nWe overcome the first issue by abandoning the narrow notion of graph decompositions in favor of its broader, object-agnostic counterpart, namely structured decompositions. These are a recent category-theoretic generalization of graph decompositions to objects of arbitrary categories [34].\npeuvent \u00eatre adapt\u00e9es \u00e0 l\u2019\u00e9tude de la topologie d\u2019une repr\u00e9sentation\u201d (in English: \u201cWe propose to indicate briefly how the methods by which we have studied the topology of a space can be adapted to the study of the topology of a representation\u201d). As Gray [28] points out, this is \u201cthe first place in which the word \u2018faisceau\u2019 is used with anything like its current mathematical meaning\u201d.\nThis shift from a graph-theoretic perspective to a category-theoretic one also allows us to overcome the second hurdle by thinking of decompositions as covers of objects in a category. More precisely we prove that structured decompositions equip categories of data (i.e. adhesive categories) with Grothendieck topologies. This is our main structural result (Corollary 3.8). It empowers us with with the ability to think of sheaves with respect to the decomposition topology as a formalization of the vague notion of \u2018computational problems whose compositional structure is compatible with that of their inputs\u2019."
        },
        {
            "heading": "1.1. Roadmap",
            "text": "Throughout the paper we will built up all the necessary category theoretic formulations to make the following illustration a precise and formal commutative diagram (this will be Diagram 6).\nData Sol. Spaces Answer Space\nData w/ Decomps.\nDecomps. of Data Decomps. of Sol. Spaces Decomps. of Sol. Spaces Decomps. of Answers\ncollect\nGlobalSolSpace\nLocalSolSpace\ncomm.\nis Empty?\nAlgorithm is Empty (locally) ?\n\u2227comm.\n(1) This diagram, whose arrows will be functors relating appropriate categories, relates structure and power by succinctly encoding all three forms of compositionality we identified earlier. The categories on the bottom row correspond to Structural Compositionality. The colored paths correspond to different algorithms:\n1. the top path (in blue) corresponds to a brute-force algorithm,\n2. the \u201cmiddle path\u201d crossing upwards (red then pink then blue) corresponds to a compositional algorithm, but a slow one and\n3. the bottom path (in red) corresponds to a fast (FPT-time) dynamic programming algorithm.\nThe commutativity of the squares (and of the diagram of the whole) represents correctness of the algorithm since it implies that it is equivalent (in terms of its returned solution) to the brute force approach; this is Algorithmic Compositionality. The ingredient upon which all of our reasoning hinges is the assumption that the arrow labeled \u201cGlobalSolSpace\u201d is a sheaf. This is Representational Compositionality and it implies the commutativity of the whole diagram.\nAlgorithmic Compositionality on its own is interesting, but it is only useful when it is paired with running time guarantees. To that end, precise statements about the running time of subroutines of the algorithm can already be gleaned from Diagram 1. Indeed note that the arrow labeled \u201cLocalSolSpace\u201d (resp. \u201cis empty (locally)?\u201d) corresponds to computing local solution spaces (resp. answering the decision problem locally) in order to turn decompositions of data into decompositions of solution spaces (resp. Booleans). These arrows correspond to local computations done a linear2 number of\n2(linear in the number of component pieces of the decomposition)\ntimes and thus one can intuit that the running time will be dominated by the arrow suggestively named \u201cAlgorithm\u201d. Most of our technical work will be devoted to proving the existence of this functor (Theorem 4.1) and in showing that it is efficiently computable (Theorem 1.1). This functor is not only a sensible choice, but it is also in some sense the canonical one: it is exactly what one comes to expect using standard category theoretic machinery3. All of these arguments will hinge on Representational Compositionality: they require \u2018GlobalSolSpace\u2019 to be a sheaf.\nGiven this context, we can now offer an informal statement of our main algorithmic contribution (Theorem 1.1). It states that, given any problem encoded as a sheaf with respect to the topology given by the decompositions of data, there is an algorithm which solves its associated decision problem in time that grows\n1. linearly in the number of constituent parts of the decompositions and\n2. boundedly (often exponentially) in terms of the internal complexity of the constituent parts.\nFormally the theorem and the computational task it achieves read as follows. (Sections 2 and Section 3 are devoted to building up all of the necessary resources to make sense of this statement.)\nC\u2212SHEAFDECISION Input: a sheaf F : C\u2192 FinSetop on the site (C,Dcmp) where C is a small adhesively cocomplete category, an object c \u2208 C and a C-valued structured decomposition d for c. Task: letting 2 be the two-object category \u22a5\u2192 \u22a4 and letting dec : FinSet\u2192 2 be the functor taking a set to \u22a5 if it is empty and to \u22a4 otherwise, compute decopF c.\nTheorem 1.1. Let G be a finite, irreflexive, directed graph without antiparallel edges and at most one edge for each pair of vertices. Let D be a small adhesively cocomplete category, let F : Dop\u2192 FinSet be a presheaf and let C be one of {D, Dmono}. If F is a sheaf on the site ( C,Dcmp |C ) and if we are given an algorithm AF which computes F on any object c in time \u03b1(c), then there is an algorithm which, given any C-valued structured decomposition d : \u222b G\u2192 C of an object c \u2208 C and a feedback vertex set S of G, computes decF c in time\nO(max x\u2208V G\n\u03b1(dx)+\u03ba|S|\u03ba2)|EG|\nwhere \u03ba = maxx\u2208V G |F dx|.\nTheorem 1.1 enjoys three main strengths:\n1. it allows us to recover some algorithmic results on graphs (for instance dynamic programming algorithms, for H-COLORING and for H-REFLCOLORING4) and\n3The functor arises via the monad given by the colim \u22a3 const adjunction of diagrams 4Here, given a fixed graph H, one is asked to determine whether a given graph G admits a reflexive homomorphism onto H (where a reflexive homomorphism is a vertex map f : V G\u2192V H such that, for all vertex pairs (x,y) in G, if f (x) f (y) \u2208 EH, then xy \u2208 EG.\n2. it allows us to generalize both decompositions and dynamic programming thereupon to other kinds of structures (not just graphs) and\n3. it is easily implementable.\nWe shall now briefly expand on the last two of these points. Notice that, since Theorem 1.1 applies to any adhesive category, we automatically obtain algorithms on a host of other structures encoded as any category of C-sets [35, 36]. This is a remarkably large class of structures of which the following are but a few examples: 1. databases, 2. simple graphs, 3. directed graphs, 4. directed multigraphs, 5. hypergraphs, 6. directed hypergraphs, 7. simplicial complexes, 8. circular port graphs [33] and 9. half-edge graphs.\nWe note that categorical perspective allows us to pair \u2013 virtually effortlessly \u2013 our meta-theoretic results (specifically the special case relating to tree-shaped decompositions) with a practical, runnable implementation [37] in the AlgebraicJulia Ecosystem [38].\nFinally, from a high-level view, our approach affords us another insight (already noted by Bodlaender and Fomin [39]): it is not the width of the decompositions of the inputs that matters; instead it is the width of the decompositions of the solutions spaces that is key to the algorithmic bounds.\nOutline Our results rely on the following ingredients: 1. encoding computational problems as functors 2. describing structural compositionality via diagrams (and in particular a special class thereof suited for algorithmic manipulation called structured decompositions), 3. proving that these give rise to Grothendieck topologies and finally 4. proving our main algorithmic result. In Section 2 we explain how to view computational problems as functors. In Section 3.1 we provide background on structured decompositions and we prove that they yield Grothendieck topologies (Corollary 3.8). We establish our algorithmic meta theorem (Theorem 1.1) in Section 4 and we provide a discussion of our practical implementation [37] of these results in AlgebraicJulia in Section 4.3. Finally we provide a discussion of our contributions and of opportunities for future work in Section 7.\nAcknowledgements: The authors would like to thank Evan Patterson for thought-provoking discussions which influenced the development of this paper and for providing key insights that improved the implementation of structured decompositions in AlgebraicJulia [38]."
        },
        {
            "heading": "1.2. Notation",
            "text": "Throughout the paper we shall assume familiarity with typical category theoretic notation as that found in Riehl\u2019s textbook [40]. We use standard notation from sheaf theory and for any notion not explicitly defined here or in Appendix A, we refer the reader to Rosiak\u2019s textbook [29]. Finally, for background on graph theory we follow Diestel\u2019s notation [3] while we use standard terminology and notions from parameterized complexity theory as found for example in the textbook by Cygan et al. [25]."
        },
        {
            "heading": "2. Computational Problems as Functors",
            "text": "Computational problems are assignments of data \u2013 thought of as solution spaces \u2013 to some class of input objects. We think of them as functors F : C\u2192 Sol taking objects of some category C to objects of some appropriately chosen category Sol of solution spaces. Typically, since solution spaces are prohibitively large, rather than computing the entire solution space, one instead settles for more approximate representations of the problem in the form of decision or optimization or enumeration problems etc.. For instance one can formulate an F -decision problem as a composite of the form\nC F\u2212\u2192 Sol dec\u2212\u2212\u2192 2\nwhere dec is a functor into 2 (the walking arrow category) mapping solutions spaces to either \u22a5 or \u22a4 depending on whether they witness yes- or no-instances to F .\nSome examples familiar to graph theorists are GAPHCOLORINGn, VERTEXCOVERk and Odd Cycle Transversal (denoted OTCk) which can easily be encoded as contravariant functors into the category FinSet of finite sets, as we shall now describe.\nGRAPHCOLORINGn is the easiest problem to define; it is simply the representable functor SimpFinGr(\u2212,Kn) : SimpFinGrop\u2192 FinSet taking each graph G to the set of all homomorphisms from G to the n-vertex irreflexive complete graph. One turns this into decision problems by taking dec : FinSet\u2192 2 to be functor which takes any set to \u22a5 if and only if it is empty.\nFor VERTEXCOVERk and OTCk we will instead work with the subcategory\nSimpFinGrmono \u21aa\u2192 SimpFinGr\nof finite simple graphs and monomorphisms (subgraphs) between them. Notice that, if H \u2032 is a subgraph of a graph G\u2032 \u2013 witnessed by the injection g : H \u2032 \u21aa\u2192G\u2032 \u2013 which satisfies some subgraph-closed property P of interest and if f : G \u21aa\u2192 G\u2032 is any monomorphism, then the pullback of g along f will yield a subgraph of G which also satisfies property P (since P is subgraph-closed). In particular this shows that, for any such subgraph-closed property P (including, for concreteness, our two examples of being either a vertex cover or an odd cycle transversal of size at most k) the following is a contravariant \u2018functor by pullback\u2019 into the category of posets\nFP : SimpFinGrmono\u2192 Pos.\nLetting U being the forgetful functor taking posets to their underlying sets, then we can state the corresponding decision problems (including, in particular VERTEXCOVERk and OCTk) as the following composite\nSimpFinGropmono FP\u2212\u2192 Pos U\u2212\u2192 FinSet dec\u2212\u2212\u2192 2."
        },
        {
            "heading": "3. Compositional Data & Grothendieck Topologies",
            "text": "Parameterized complexity [25] is a two-dimensional framework for complexity theory whose main insight is that one should not analyze running times only in terms of the total input size, but also in\nterms of other parameters of the inputs (such as measures of compositional structure [25]). Here we represent compositional structure via diagrams: we think of an object c \u2208 C obtained as the colimit of a diagram d : J\u2192 C as being decomposed by d into smaller constituent pieces. This section is split into two parts. In Section 3.1 we will show that diagrams yield Grothendieck topologies on adhesive categories. Then in Section 3.2 we focus on a special class of diagrams (suited for algorithmic manipulation) called structured decompositions [34]. Roughly they consist of a collection of objects in a category and a collection of spans which relate these objects (just like the edges in a graph relate its vertices)."
        },
        {
            "heading": "3.1. Diagrams as Grothendieck Topologies",
            "text": "In this section we will need adhesive categories. We think of these as categories of data \u201cin which pushouts of monomorphisms exist and \u00abbehave more or less as they do in the category of sets\u00bb, or equivalently in any topos.\u201d [41] Adhesive categories encompass many mathematical structures raging from topological spaces (or indeed any topos) to familiar combinatorial structures such as: 1. databases, 2. simple graphs, 3. directed graphs, 4. directed multigraphs, 5. hypergraphs, 6. directed hypergraphs (i.e. Petri nets), 7. simplicial complexes, 8. circular port graphs [33] and 9. half-edge graphs.\nDefinition 3.1. (Adhesive category [36]) A category C is said to be adhesive if\n1. C has pushouts along monomorphisms;\n2. C has pullbacks;\n3. pushouts along monomorphisms are van Kampen.\nIn turn, a pushout square of the form\nC\nA B\nD\ng n\nf m\nis said to be van Kampen if, for any commutative cube as in the following diagram which has the\nabove square as its bottom face,\nC\u2032\nA\u2032 B\u2032\nD\u2032 C\nA B\nD\ng n\nf m\na\nd\nc\nb\ng\u2032 n\u2032\nf \u2032m\u2032\nthe following holds: if the back faces are pullbacks, then the front faces are pullbacks if and only if the top face is a pushout.\nWe will concern ourselves with diagrams whose morphisms are monic; we call these submonic diagrams.\nDefinition 3.2. A submonic diagram in C of shape J is a diagram d : J \u2192 C which preserves monomorphisms and whose domain is a finite category with all arrows monic. We say that a category C is adhesively cocomplete if (1) it is adhesive and (2) every submonic diagram in C has a colimit.\nThe following result ([34, Lemma 5.10] restated here for convenience) states that we can associate \u2013 in a functorial way \u2013 to each object c of an adhesively cocomplete category C the set of submonic diagrams whose colimit is c.\nLemma 3.3. ([34]) Let C be a small adhesively cocomplete category. For any arrow f : x\u2192 y in C and any diagram dy : J\u2192 C whose colimit is y we can obtain a diagram dx : J\u2192 C whose colimit is x by point-wise pullbacks of f and the arrows of the colimit cocone \u039b over dy.\nX = colimdx y = colimdy\ndxJ dyJ\n\u039b\nf\n\u231f\nNote that we cannot do without requiring the diagrams to be monic in Lemma 3.3 since, although adhesive categories have all pushouts of monic spans, they need not have pushouts of arbitrary spans (see Definition 3.1).\nAs we shall now see, adhesively cocomplete categories have just enough structure for us to define a Grothendieck topologies where covers are given by colimits of monic subcategories 5. We will use this result to prove (Corollary 3.8) that structured decompositions yield the desired Grothendieck topologies.\nTheorem 3.4. If C is a small adhesively cocomplete category, then, denoting by \u039bd the colimit cocone of any diagram d, the following is a functor by pullback.\nsubMon : Cop\u2192 Set subMon : c 7\u2192 {\u039bd | d a submonic diagram and colimd = c}\u22c3\n{{ f} | f : a \u223c=\u2212\u2192 c an iso }.\nFurthermore we have that:\n\u2022 for any such C the pair (C, subMon) is a site and\n\u2022 denoting by Cmono the subcategory of C having the same objects of C, but only the monomorphisms of C, we have that the following pair is a site(\nCmono, subMon |Cmono ) .\nProof: The fact that subMon is a contravariant functor by pullback follows from the observation that pullbacks preserve isomorphisms together with Lemma 3.3.\nNow notice that it suffices to show that subMon defines a Grothendieck pre-topology (Definition A.1) since it is known that every Grothendieck pre-topology determines a genuine Grothendieck topology [29]. We do this only for the first case (the second case is proved analogously) and to that end we proceed by direct verification of the axioms (consult Definition A.1 in Appendix A). First of all note that Axiom ( PT1) holds trivially by the definition of subMon. It is also immediate that Axiom ( PT2) holds since we have just shown in the first part of this theorem that subMon is a contravariant \u201cfunctor by pullback\u201d. Axiom ( PT3) is also easily established as follows:\n\u2022 since a diagram of diagrams is a diagram, we have that a colimit of colimits is a colimit and thus the resulting colimit cocone is in the cover; and\n\u2022 if we are given any singleton cover consisting of an isomorphism { f : b \u223c=\u2212\u2192 c}, then there are two\ncases: 1. we are given another such cover f \u2032 : a \u223c=\u2212\u2192 b then the composite f f \u2032 is an isomorphism into c and thus is in the coverage and 2. if the cover on b is a colimit cocone \u039bd of submonic diagram d, then the composition of the components of the cocone (which are monomorphism) with isomorphism f determines a diagram of subobjects of c and this diagram will have c as its colimit, as desired.\n5For the reader concerned with size issues, observe that: (1) given categories C and D, the functor category [C,D] is small whenever C and D also are; and (2) since we are concerned with diagrams whose domains have finitely many objects and morphisms, one has that the collection of diagrams which yield a given object as a colimit is indeed a set.\n\u2293\u2294\nRecall from Section 1 that some computational problems (e.g. VERTEXCOVERk and OCTk) are stated on the category SimpFinGrmono of finite simple graphs and the monomorphisms between them. Indeed note that, if we were to attempt to state these notions on the category SimpFinGr, then we would lose the ability to control the cardinalities of the vertex covers (resp. odd cycle transversals, etc.) since, although the pullback of a vertex cover along an epimorphism is still a vertex cover (resp. odd cycle transversals, etc.), the size of the resulting vertex cover obtained by pullback may increase arbitrarily. Thus, if we want to think of computational problems (the specific ones mentioned above, but also more generally) as sheaves, it is particularly helpful to be able to use structured decompositions as Grothendieck topologies on \u2018categories of monos\u2019 (i.e. Cmono for some adhesive C) which will fail to have pushouts in general.\nTangential Remark Note that similar ideas to those of Theorem 3.4 and Corollary 3.8 can be used to define sheaves on \u2018synthetic spaces\u2019 (i.e. mixed-dimensional manifolds encoded as structured decompositions of manifolds). Here the idea is that one would like to define sheaves on topological spaces obtained by gluing manifolds of varying dimensions together while simultaneously remembering that the resulting object should be treated as a \u2018synthetic mixed-dimensional manifold\u2019 (i.e. structured decompositions of manifolds). The fact that one can use structured decompositions as topologies implies that one can speak of sheaves which are aware of the fact that the composite topological space needs to be regarded as a mixed-dimensional manifold. This is beyond the scope of the present paper, but it is a fascinating direction for further work."
        },
        {
            "heading": "3.2. Structured Decompositions",
            "text": "For our algorithmic purposes, it will be convenient to use structured decompositions, rather than arbitrary diagrams, to define Grothendieck topologies. This is for two reasons: (1) structured decompositions are a class of particularly nice diagrams which are easier to manipulate algorithmically when the purpose is to construct colimits via recursive algorithms and (2) although it is true that, given its colimit cone, one can always turn a diagram into a diagram of spans (as we argue in Corollary 3.8), this operation is computationally expensive (especially when, as we will address later, one is dealing with decompositions of prohibitively large objects such as solutions spaces).\nBackground on Structured Decompositions Structured decompositions [34] are category-theoretic generalizations of many combinatorial invariants \u2013 including, for example, tree-width [6, 7, 4], layered tree-width [19, 20], co-tree-width [42], H -tree-width [21] and graph decomposition width [18] \u2013 which have played a central role in graph theory and parameterized complexity.\nIntuitively structured decompositions should be though of as generalized graphs: whereas a graph is a relation on the elements of a set, a structured decomposition is a generalized relation (a collection of spans) on a collection of objects of a category. For instance consult Figure 1 for a drawing of a graph-valued structured decomposition of shape K3 (the complete graph on three vertices).\nFormally, for any category C, one defines C-valued structured decompositions as certain kinds of diagrams in C as in the following definition. For the purposes of this paper, we will only need the\nspecial case of structured decompositions given by diagrams whose arrows are all monic; however, for completeness, we note that the theory of structured decompositions does not rely on such a restriction. Thus, to ease legibility and since we will only work with monic structured decompositions in the present document, we will drop the adjective \u2018monic\u2019 and instead speak of structured decompositions (or simply \u2018decompositions\u2019).\nDefinition 3.5. (Monic Structured Decomposition) Given any finite graph G viewed as a functor G : GrSch\u2192 Set where GrSch is the two object category generated by\nE V s\nt one can construct a category \u222b\nG with an object for each vertex of G and an object from each edge of G and a span joining each edge of G to each of its source and target vertices. This construction is an instance of the more general notion of Grothendieck construction. Now, fixing a base category K we define a K-valued structured decomposition of shape G (see Figure 1) as a diagram of the form\nd : \u222b G\u2192 K\nwhose arrows are all monic in K. Given any vertex v in G, we call the object dv in K the bag of d indexed by v. Given any edge e = xy of G, we call de the adhesion indexed by e and we call the span dx\u2190 de\u2192 dy the adhesion-span indexed by e.\nDefinition 3.6. (Morphisms of Structured Decompositions) A morphism of K-valued structured decompositions from d1 to d2 is a pair\n(F,\u03b7) : (\u222b G1 d1\u2212\u2192 K ) \u2192 (\u222b G2 d2\u2212\u2192 K )\nas in the following diagram where F is a functor F : \u222b G1 \u2192 \u222b\nG2 and \u03b7 is a natural transformation \u03b7 : d1\u21d2 d2F as in the following diagram.\u222b\nG1 \u222b G2\nK\nd1 d2\nF\n\u03b7\nThe point of such abstraction is that one can now speak in a unified way about decompositions of many different kinds of objects. Indeed this is precisely our approach in this paper: we relate the compositional structure of the inputs of a computational problem to a corresponding compositional structure of the solutions spaces of the problem. To do so, we leverage the fact that the construction of the category of structured decompositions [34, Prop. 3.3] is functorial [34, Corol. 3.4]. In particular there is a functor"
        },
        {
            "heading": "Dm : Cat\u2192 Cat",
            "text": "taking any category C to the category DmC of C-valued structured decompositions6; this is summarized in Definition 3.7 below.\nDefinition 3.7. (The category of Structured Decompositions) Category of Decompositions. Fixing a category K, K-valued structured decompositions (of any shape) and the morphisms between them (as in Definition 3.5) form a category Dm(K) called the category of K-valued structured decompositions. Furthermore, this construction is functorial: there is a functor Dm : Cat\u2192 Cat which takes any category K to the category Dm(K) and every functor \u03a6 : K\u2192 K\u2032 to the functor Dm(\u03a6) : Dm(K)\u2192Dm(K\u2032) defined on objects as\nDm(\u03a6) : (\u222b G d\u2212\u2192 K ) 7\u2192 ( Dm(\u03a6)d : \u222b G d\u2212\u2192 K \u03a6\u2212\u2192 K\u2032 ) and on arrows as \u222b\nG1 \u222b G2 \u222b G1 \u222b G2\nK K\u2032 .\nDm\u03a6 d1 Dm(\u03a6)d2\nF\nd1 d2\nF\nDm(\u03a6) \u03a6\u03b7\u03b7\n6In order to maintain notational consistency with the prequel [34] and in order to remind the reader that we are only working throughout with monic structured decompositions, we will keep the subscript m in the notation of the category DmC.\nThe fact that Dm is a functor means that every functor F : C\u2192 Sol which encodes some computational problem lifts to a functor\nDmF : DmC\u2192DmSol\ntaking structured decompositions of the inputs to a computational problem (i.e. decompositions valued in C) to those valued in the solution spaces of the problem (i.e. decompositions valued in Sol) by evaluating F on the bags and adhesions of the objects of DmC. We will make use of this fact in Section 4 to easily encode local computations on the bags and adhesions of decompositions and for the implementations of our results (see Section 4.3).\nStructured Decompositions as Grothendieck Topologies We are finally ready to show that structured decompositions yield Grothendieck topologies on adhesive categories. We will proceed in much the same way as we did for arbitrary submonic diagrams. Indeed observe [34, Corol. 5.11] that, for any small adhesively cocomplete category C, one can define (again by point-wise pullbacks as in Theorem 3.4) a subfunctor Dcmp of the functor subMon (defined in Theorem 3.4) as follows (where we once again denote by \u039bd the set of arrows in the colimit cocone over d).\nDcmp : Cop\u2192 Set (2) Dcmp : c 7\u2192 {\u039bd | colimd = c and d \u2208DmC} \u22c3 {{ f} | f : a \u223c=\u2212\u2192 c an iso }.\nCorollary 3.8. The pairs (C,Dcmp) and ( Cmono, Dcmp |Cmono ) are sites where C is any small adhesively cocomplete category and Dcmp is the functor of Equation (2).\nProof: Every C-valued structured decomposition induces a diagram in C. Conversely, since C is adhesive, we have that colimit cocones of monic subcategories will consist of monic arrows. Thus, by taking pairwise pullbacks of the colimit arrows, one can recover a structured decomposition with the same colimit (because C is adhesive) and having all adhesions monic. \u2293\u2294\nIn the general case, there are going to be many distinct Grothendieck topologies that we could attach to a particular category, yielding different sites. In building a particular site, we have in mind the sheaves that will be defined with respect to it. It would be nice if we could use some relationship between sites to induce a relationship between the associated sheaves, and reduce our work by lifting the computation of sheaves with respect to one Grothendieck topology from the sheaves on another (appropriately related) Grothendieck topology. As it turns out, the collection of Grothendieck topologies on a category C are partially ordered (by inclusion), and established results show us how to exploit this to push sheaves on one topology to sheaves on others.\nWe might first define maps between arbitrary coverings as follows.\nDefinition 3.9. A morphism of coverings from V = {Vj \u2192 V} j\u2208J to U = {Ui\u2192U}i\u2208I is an arrow V \u2192U together with a pair (\u03c3, f ) comprised of\n\u2022 a function \u03c3 : J\u2192 I on the index sets, and\n\u2022 a collection of morphisms f = { f j : Vj\u2192U\u03c3( j)} j\u2208J with\nVj U\u03c3( j)\nV U\ncommuting for all j \u2208 J.\nWith this notion of morphisms, we could define a category of the coverings on C. However, we will mostly be concerned with a particular case of such morphisms of coverings, namely where V =U and V \u2192U is just the identity map. In this case, we say that V is a refinement of U.\nDefinition 3.10. Let C be a category and U = {Ui\u2192U}i\u2208I be a family of arrows. Then a refinement V = {Vj\u2192U} j\u2208J is a family of arrows such that for each index j \u2208 J there exists some i \u2208 I such that Vj\u2192U factors through Ui\u2192U .\nIn sieve terms, we can simplify the above to say that, given U = {Ui\u2192U} and V = {Vj \u2192U}, V is a refinement of U if and only if the sieve generated by V is contained in (a sub-sieve of) the sieve generated by U.\nMoreover, observe that any covering is a refinement of itself, and a refinement of a refinement is a refinement. As such, refinement gives us an ordering on the coverings of an object U . We can use this to define the following relation for Grothendieck topologies.\nDefinition 3.11. Let C be a category and J,J\u2032 two Grothendieck topologies on C. We say that J is subordinate to J\u2032, denoted J \u2a7d J\u2032, provided every covering in J has a refinement that is a covering in J\u2032.\nIf J \u2a7d J\u2032 and J\u2032 \u2a7d J, then J and J\u2032 are equivalent.\nThis really says not just that any covering in J is a covering in J\u2032\u2014which makes us say that the topology J\u2032 is finer than J\u2014but that for any covering in J, there exists a refinement among the coverings in J\u2032.\nIn sieve terms, J \u2a7d J\u2032 just says that for any object U and any sieve S considered a covering sieve by J, there exists a sieve S\u2032 that is considered a covering sieve by J\u2032, where all arrows of S are also in S\u2032. In particular, two topologies will be equivalent if and only if they have the same sieves.\nNow we come to the point of these definitions. Using the main sheaf definition\u2014i.e., a functor F is a sheaf with respect to a topology J if and only if for any sieve S belonging to J the induced map7\nF(U)\u2243 Hom(yU ,F)\u2192 Hom(S,F)\nis a bijection\u2014together with the previous definition (expressed in terms of sieves), we get the following result.\n7Here we write yU to denote the Yoneda embedding at U .\nProposition 3.12. Let J,J\u2032 be two Grothendieck topologies on a category C. If J is subordinate to J\u2032, i.e., J \u2a7d J\u2032, then every presheaf that satisfies the sheaf condition for J\u2032 also satisfies it for J.\nIn other words: if J is subordinate to J\u2032, then we know that any sheaf for J\u2032 will automatically be a sheaf for J.\nProof: We could show the result by deploying the notion of morphisms of sites (see Mac Lane and Moerdijk [30]) f : (C,J)\u2192 (D,K), as a certain \u201ccover-preserving\" morphism, where this is got by setting D= C and K = J\u2032, and using the identity functor C\u2192 C, taking any object to itself and any J-covering to itself as well. Precomposition with f gives a functor between the category of presheaves (going the other way), and we then use the pushforward (or direct image) functor f\u2217 : Sh(C,J\u2032)\u2192 Sh(C,J), where this is the restriction of the precomposition with f down to sheaves, to push a sheaf with respect to J\u2032 to a sheaf f\u2217F on J. Details can be found in the literature. \u2293\u2294\nAs a particular case, two equivalent topologies have the same sheaves. The main take-away here is, of course, that if we can show that a particular presheaf is in fact a sheaf with respect to a topology J\u2032, and if J is another topology which we can establish is subordinate to J\u2032, then we will get for free a sheaf with respect to J (and with respect to any other subordinate topology, for that matter). Moreover, in particular, if there is a finest cover, verifying the sheaf axiom there will guarantee it for all covers.\nLet\u2019s now connect these established results to the Grothendieck topologies that we defined in Theorem 3.4 and Corollary 3.8, namely subMon and Dcmp, where the latter is a subfunctor of the former. We can focus on showing how subMon relates to another Grothendieck topology of interest.\nProposition 3.13. Fix any adhesively cocomplete category C. The topology given by subMon on Cmono is subordinate to the subobject topology.\nProof: The subobject topology just takes for coverings of an object c (equivalence classes of) monomorphisms whose union is c. Need to show that any covering in the monic diagram topology can be refined by a covering in the subobject topology. This follows immediately from the definition of subMon in Corollary 3.8. \u2293\u2294\nThis, combined with Proposition 3.12, yields the following result which can be particularly convenient when proving that a given presheaf is indeed a sheaf with respect to the decomposition topology.\nProposition 3.14. Fix any adhesively cocomplete category C and any presheaf F : Cop\u2192 Set. If F is a sheaf on (C)mono with respect to the subobject topology, then it will automatically give us a sheaf on the site ( Cmono, Dcmp |Cmono ) ."
        },
        {
            "heading": "4. Deciding Sheaves",
            "text": "Adopting an algorithmically-minded perspective, the whole point of Thm 3.4 and Corollary 3.8 is to speak about computational problems which can be solved via compositional algorithms. To see this,\nsuppose we are given a sheaf F : Cop\u2192 FinSet with respect to the site (C,Dcmp). We think of this sheaf as representing a computational problem: it specifies which solutions spaces are associated to which inputs. We\u2019ve already seen a concrete example of such a construction in Section 1; namely the coloring functor\nSimpFinGr(\u2212,Kn) : SimpFinGrop\u2192 FinSet\nwhich takes each graph to the set of all n-colorings of that graph. In this paper we focus on decision problems and specifically on the sheaf decision problem (defined in Section 1) which we recall below for ease of reference.\nC\u2212SHEAFDECISION Input: a sheaf F : C\u2192 FinSetop on the site (C,Dcmp) where C is a small adhesively cocomplete category, an object c \u2208 C and a C-valued structured decomposition d for c. Task: letting 2 be the two-object category \u22a5\u2192 \u22a4 and letting dec : FinSet\u2192 2 be the functor taking a set to \u22a5 if it is empty and to \u22a4 otherwise, compute decopF c.\nIn this section we will show that the sheaf decision problem lies in FPT under the dual parameterization of the width of the given structured decomposition and the feedback vertex number8 of the shape of the decomposition. Notice that, when the decomposition is tree-shaped, we recover parameterizations by our abstract analogue of tree-width (which, note, can be instantiated in any adhesive category, not just that of graphs).\nTo that end, notice that, if C has colimits, then, since sheaves on this site send colimits of decompositions to limits of sets [29], the following diagram will always commute (see Bumpus, Kocsis & Master [34] for a reference).\nC FinSetop 2op\nDmC DmFinSet op\ncolim colim\nF\nDm F\ncomm.\ndecop\n(3)\nFor concreteness, let us unpack what this means. The blue path corresponds to first gluing the constituent parts of the decomposition together (i.e. forgetting the compositional structure) and then solving the problem on the entire output. On the other hand the red path corresponds to a compositional solution: one first evaluates F on the constituent parts of the decomposition and then joins9 these solutions together to find a solution on the whole. Thus, since this diagram commutes for any sheaf F , we have just observed that there is a compositional algorithm for SHEAFDECISION.\nUnfortunately the approach we just described is still very inefficient since for any input c and no matter which path we take in the diagram, we always end-up computing all of F (c) which is very large in general (for example, the images of the coloring sheaf which we described above have cardinalities\n8A feedback vertex set in a graph G is a vertex subset S \u2286V (G) of G whose removal from G yields an acyclic graph. The feedback vertex number of a graph G is the minimum size of a feedback vertex set in G. 9Note that the colimit functor colim : DmFinSetop\u2192 FinSetop \u2013 which is in red in Diagram 3 \u2013 is a limit of sets; we invite the reader to keep this in mind throughout.\nthat grow exponentially in the size of the input graphs). One might hope to overcome this difficulty by lifting dec to a functor from FinSetop-valued structured decompositions to 2op-valued structured decompositions as is shown in the following diagram.\nC FinSetop 2op\nDmC DmFinSet op Dm 2op\ncolim colim\nF\nDm F\ncomm.\ndecop\nDm decop\ncolim=\u2227\nHowever, this too is to no avail: the right-hand square of the above diagram does not commute in general. To see why, consider the 2-coloring sheaf SimpFinGr(\u2212,K2) and let d be the structured decomposition P3\u2190K2\u2192P4 which decomposes a 5-cycle into two paths on 2 and 3 edges respectively (see Figure 2). The image of d under Dm decop \u25e6Dm F is \u22a4\u2190\u22a4\u2192\u22a4 (since the graphs P3, K2 and P4 are all 2-colorable) and the colimit of this diagram in 2op (i.e. a limit in 2; i.e. a conjunction) is \u22a4. However, 5-cycles are not 2-colorable.\nAlthough this counterexample might seem discouraging, we will see that the approach we just sketched is very close to the correct idea. Indeed in the rest of this section we will show (Theorem 4.1) that there is an endofunctor\nA : DmFinSetop\u2192DmFinSetop\nwhich makes the following diagram commute.\nC FinSetop 2op\nDmC DmFinSet op DmFinSet op Dm 2op colim colim\nF\nDm F\ncomm.\ndecop\nA Dm decop \u2227comm. (by Thm. 4.1) (4)\nMoreover we will show that this functor A can be computed efficiently (this is Theorem 1.1, which we mentioned in the introduction).\nWhen C fails to have colimits. Before we move on to defining the object and morphism maps of A (which \u2013 as we shall prove in Theorem 4.1 \u2013 assemble into a functor), we will briefly note how the entire discussion mentioned above can be applied even to sheaves defined on the site ( Cmono,Dcmp |Cmono ) . Recall from Sections 2 and 3 that there are many situations in which we would like to speak of computational problems defined on the category Cmono having the same objects of C, but only those morphisms in C which are monos. In this case, since Cmono will fail to have colimits in general, we trivially cannot deduce the commutativity of the \u2018square of compositional algorithms\u2019 (Diagram 3) since one no longer has the colimit functor (namely colim which is marked in blue in Diagram 3). However, note that in either case \u2013 i.e. taking any K \u2208 {C,Cmono} \u2013 if F is a sheaf with respect to the site (K,Dcmp), then we always have that, for any covering\n(\u03ba \u2208 K, d \u2208 Dcmp\u03ba)\nwe always have that (decop \u25e6F )(\u03ba) = (decop \u25e6 const\u25e6Dm F )(d). (5)\nTo state this diagrammatically, we can invoke the Grothendieck construction10. For convenience we spell-out the definition of the category \u222b Dcmp; it is defined as having\n\u2022 objects given by pairs (c,d) with c \u2208 C and d \u2208 Dcmp(c)\n\u2022 arrows from (c,d) to (c\u2032,d\u2032) are given by morphisms in C of the form f0 : c\u2192 c\u2032 such that Dcmp( f )(d\u2032) = d.\nNotice that this allows us to restate Equation (5) as the commutativity of the following diagram.\nC FinSetop 2op\n\u222b Dcmp\nDmC DmFinSet op\ncolim\nF\nDm F\ncomm.\ndecop\nfst\nsnd\n10Recall that the Grothendieck construction produces from any functor F : A\u2192 B a category denoted \u222b\nF . For details on the construction and its properties, we refer the reader to Riehl\u2019s textbook [40]\nwhere fst and snd are the evident projection functors, whose object maps are respectively fst : (c,d) 7\u2192 c and snd : (c,d) 7\u2192 d. The point of all of this machinery is that it allows us to restate our algorithmic goal (namely Diagram (4) \u2013 whose commutativity we shall prove in Theorem 4.1) in the following manner when our category C of inputs does not have colimits. (Notice that the following diagram is the formal version of Diagram 1 which we used to sketch our \u2018roadmap\u2019 in Section 1.)\nC FinSetop 2op\n\u222b Dcmp\nDmC DmFinSet op DmFinSet op Dm 2op\ncolim\nF\nDm F\ncomm.\ndecop\nA Dm decop\n\u2227\nfst\nsnd\ncomm. (by Thm. 4.1) (6)\nAll that remains to be done is to establish that the functor A in Diagram 6. As we shall see, we will define this functor by making use of the monad T defined as follows. Recall that, for any category K with pullbacks and colimits, there is the following adjunction [34] (which is a special case of the analogous adjunction in categories of diagrams)\nDmK K\ncolim\n\u22a5 const\nwhere the functor const takes objects of K to trivial decompositions (having a single bag) and the functor colim takes decompositions to their colimits. Now, taking K = FinSetop, we shall denote by T the monad\nT : DmFinSetop\u2192DmFinSetop (7) T : d 7\u2192 (const\u25e6colim)(d)\ngiven by this adjunction. In the proof of the following theorem we will make use of this monad to finally establish the existence of the desired functor A .\nTheorem 4.1. There is a functor A : DmFinSetop\u2192DmFinSetop such that:\n(A1) there is a natural isomorphism\nFinSetop\nDmFinSet op DmFinSet op A\ncolim colim \u223c=\n(A2) there are natural transformations \u03b11 and \u03b12 which factor the unit of \u03b7 of the monad T \u2013 see Functor (7) \u2013 as in the following diagram\nidDm FinSetop T\nA\n\u03b7\n\u03b11 \u03b1 2\n(A3) and the following diagram (which is Diagram (6), restated) commutes\nC FinSetop 2op\n\u222b Dcmp\nDmC DmFinSet op DmFinSet op Dm 2op\ncolim\nF\nDm F\ncomm.\ndecop\nA Dm decop\n\u2227\nfst\nsnd\ncomm. (by Thm. 4.1)\nOne should think of the functor A of Theorem 4.1 as a pre-processing routine by which one filters-out those local solutions which cannot be extended to global solutions. Furthermore, notice that there is a sense in which A is canonical since it arises from the monad T . Indeed as we shall see, although most of the proof is focused on the derivation of A , none of the steps in this derivation are ad-hoc: they are the \u2018obvious steps\u2019 which are completely determined by the properties of the monad T . We find this to be a great benefit of our categorical approach."
        },
        {
            "heading": "4.1. Proof of Theorem 4.1",
            "text": "The proof is structured as follows: we shall begin by making use of the monad T to define the functor A : DmFinSetop\u2192 DmFinSetop; then we will point out how various facts accumulated through the derivation of A easily imply the points (A1), (A2) and (A3) listed in the statement of the theorem."
        },
        {
            "heading": "4.1.1. Gathering Intuition",
            "text": "Notice that, if we momentarily disregard any consideration of efficiency of computation, then it is easy to find a candidate for the desired functor A . To see this, consider what happens when we pass a FinSetop-valued structured decomposition d through the monad T . We will have that T d consists of a structured decomposition of shape K1 (the one-vertex complete graph) whose bag consists of the solution space we seek to evaluate (namely the colimit of d in FinSetop). Thus we will clearly have that Diagram (4) commutes if we replace A by T .\nAlthough T is not efficiently computable (since, as we mentioned earlier, the set colimd might be very large) we will see that the unit \u03b7 of the monad T given by the adjunction const \u22a2 colim is the crucial ingredient needed to specify (up to isomorphism) the desired functor A (shown to be efficiently computable later in this section.) Thus, towards defining A , we will first spell-out the definition of \u03b7.\nNotice that \u03b7 yields a morphism of structured decompositions\n\u03b7d : d\u2192 T d\nwhich by definition consists of a pair (\u03b70d ,\u03b7 1 d) where \u03b7 0 d :\n\u222b G\u2192 \u222b K1 is a functor and \u03b71d : d\u21d2 T (d)\u03b70d\nis a natural transformation as in the following diagram.\n\u222b G\n\u222b K1\nFinSetop\nT dd\n\u03b70d\n\u03b71d (8)\nNow notice that the diagram above views d and T d as FinSetop-valued structured decompositions. Instead, in the interest of convenience and legibility, we will \"slide the op\" in Diagram (9) so as to think of \u03b7d as a morphism of FinSet-valued structured co-decompositions (i.e. contravariant structured decompositions); in other words we will rewrite Diagram (9) as follows.\n( \u222b G)op ( \u222b K1)op\nFinSet\nT dd\n(\u03b70d) op\n\u03bbd (9)\nFor clarity, we will take a moment to spell out what this change of perspective entails. First of all observe that FinSet-valued co-decompositions associate to each edge of G a cospan of sets whose legs are epimorphisms (since they are monomorphisms in FinSetop). The natural transformation \u03bbd is simply the transformation \u03b71d when its components are viewed not as morphisms in FinSet\nop, but as morphisms of FinSet (we choose to denote it \u03bbd simply to avoid notational confusion). The components of \u03bbd are functions (projections) from the single bag of T d to each one the bags of d as shown below.\n\u03bbdx : T d\u2192 dx. (10)\nIn particular these are given by the limit cone11 sitting above d with apex T d."
        },
        {
            "heading": "4.1.2. Defining the object map of A.",
            "text": "With these observations in mind, we can now define the object map A0 : ((\u222b G)op d\u2212\u2192 FinSet ) 7\u2192 ((\u222b G )op A0d\u2212\u2212\u2192 FinSet) (11) 11Once again we remind the reader that taking the colimit in FinSetop of a FinSetop-valued decomposition d : \u222b\nG\u2192 FinSetop will yield the same result as first viewing d as a FinSet-valued co-decomposition d : ( \u222b G)op\u2192 FinSet and evaluating its limit in FinSet.\nof the functor A which we are seeking to establish. It maps d to the decomposition obtained by restricting all of the bags and adhesions of d to the images of the legs of the limit cone with apex T d (we encourage the reader to consult Figure 3 for a visual aid). Spelling this out formally, the map A0 takes a structured co-decomposition d : ( \u222b G)op\u2192 FinSet to the structured co-decomposition\nA0d : ( \u222b G)op\u2192 FinSet which has the same shape as d and which is defined as follows:\nA0d : (x \u2208 \u222b G) 7\u2192 Im\u03bbdx (12)\nA0d : (e fx,e\u2190\u2212\u2212 x \u2208Mor (\u222b G )op ) 7\u2192 ( Im\u03bbde fx,e|Im\u03bbdx\u2190\u2212\u2212\u2212\u2212 Im\u03bbdx ) ."
        },
        {
            "heading": "4.1.3. Preliminaries of the definition of the morphism map of A.",
            "text": "Now, towards defining the morphism map A1, observe that, by the definition of A0 via the unit \u03b7 of T , we have that \u03b7 factors as\nd A0d T d \u03b12Ad=(\u03b7 0 d ,a 2 d)\n\u03b7d=(\u03b70d ,\u03bb d)\n\u03b11d=(iddom(d),a 1 d)\n(13)\nwhere, for any x \u2208 \u222b\nG, the maps a1d and a 2 Ad shown below\n( \u222b G)op ( \u222b G)op ( \u222b K1)op\nFinSet\nd\n\u03b70d\nAd T d\nid\na2a1\nare respectively defined by restriction and corestriction12 of \u03bbd . Spelling this out, these maps are defined as the following morphisms in FinSet\na1d(x) := Adx dx\na2Ad(x) := T dK1 Adx\niddx|Im\u03bbdx\n\u03bbdx |Im\u03bb d x\n(14)"
        },
        {
            "heading": "4.1.4. Defining the morphism map of A.",
            "text": "Given any morphism q = (q0,q1) of FinSet-valued structured co-decompositions as in the following diagram\n( \u222b G)op ( \u222b H)op\nFinSet\nq0\nd d\u2032q1 (15)\nwe have, by Diagram (13) and the functoriality of the monad T and the naturality of its unit, that the following diagram commutes.\nd A0d T d\nd\u2032 A0d\u2032 T d\u2032\n\u03b12Ad\n\u03b7d=(\u03b70d ,\u03bb d)\n\u03b11d\nq T q\n\u03b11d\u2032 \u03b1 2 Ad\u2032\n\u03b7d\u2032\n(16)\nRecall that each of the morphisms in the above diagram are themselves morphisms in a category of diagrams consisting of a functor and a natural transformation where the natural transformation points \u201cbackwards\u201d (for example as in Diagram (15)). For instance recall that the morphism \u03b7d : d \u2192 T d (drawn in Diagram (9)) corresponds to the limit cone over d.\nWe are seeking to prove the existence of a morphism A0 d \u2192 A0 d\u2032 which commutes with Diagram (16). This will follow from the commutativity of Diagram (16). However, it deserves to be unpacked as follows.\nConsider Diagram (16). The morphism T q represents a function from the limit of d\u2032 to the limit of d. The morphisms \u03b7d and \u03b7d\u2032 represent the limit cones sitting above d and d\u2032 respectively. The 12Dually to the notation used for restrictions, for any function f : A\u2192 B, we denote the corestriction of f to its image as f |Im f .\nmorphism q (defined in Diagram (15)) corresponds to assigning to each object x \u2208 domd a morphism\nq1x : (q 0x \u2208 domd\u2032)\u2192 (x \u2208 domd).\nThe commutativity of Diagram (16) amounts to stating the following: for each x \u2208 domd and each component q1x of q1, the range of q 1 x is completely contained in the images of the leg \u03bbdx : T d\u2192 dx of the limit cone \u03bbd at x. But then, this means that, by restricting q1x to the image of \u03bbd \u2032 x, we obtain the\ndesired morphism shown below (where recall \u03b11d\u2032 := (id( \u222b G)op ,a 1 d\u2032).\n( \u222b G)op ( \u222b G)op\nFinSet\nA0d\u2032 A0d\nid\na1d\u2032\u25e6q 1\nIn summary, this derivation allowed us to define the desired morphism A q : A0d\u2192 A0d\u2032 given by\nA1 : ( (q0,q1) : d\u2192 d\u2032 ) 7\u2192 ( (q0,a1d\u2032 \u25e6q1) ) . (17)"
        },
        {
            "heading": "4.1.5. Completing the proof",
            "text": "The functoriality of A is immediate: it clearly preserves identities and, since T is a functor, one can see that A preserves composition by inspection of Diagram (16). On the other hand Point (A1) can be seen to follow by the definition of A0 and the properties of limits in FinSet (namely that, if X1 \u03c01\u2190\u2212 X1\u00d7S X2 \u03c02\u2212\u2192 X2 is the pullback of a span X1 f1\u2212\u2192 S f2\u2190\u2212 X2, then X1\u00d7S X2 will also be isomorphic to the pullback object of the span Im\u03c01 f1|Im\u03c01\u2212\u2212\u2212\u2212\u2192 S\nf2|Im\u03c01\u2190\u2212\u2212\u2212\u2212 Im\u03c02). Since the naturality of \u03b11 and \u03b12 is evident, Point (A2) just amounts to the commutativity of Diagram (13). Finally, to show Point (A3), observe that, by the definition of the object map A0 and since the only set with a morphism to the empty set is the empty set, we have that \u2227\u25e6Dm decop \u25e6A = decop \u25e6 colim ."
        },
        {
            "heading": "4.2. An Algorithm for Computing A",
            "text": "Recall that one should think of the functor A of Theorem 4.1 as a pre-processing routine which filtersout those local solutions which cannot be extended to global solutions. This intuition suggests the following local filtering algorithm according to which one filters pairs of bags locally by taking pullbacks along adhesions and then retaining only those local solutions which are in the image of the projection maps of the pullbacks.\nRecursive applications of Algorithm 1 allow us to obtain the following algorithm for sheaf decision on tree-shaped structured decompositions.\nLemma 4.2. There is an algorithm (namely Algorithm 2) which correctly computes Ad on any input FinSet-valued structured co-decomposition d : ( \u222b G)op \u2192 FinSet in time O(\u03ba2)|EG| where \u03ba = maxx\u2208V G |dx| whenever G is a finite, irreflexive, directed tree.\nAlgorithm 1 Filtering Input: a FinSet-valued structured co-decomposition d : ( \u222b G)op\u2192 FinSet and an edge e = xy in G.\n\u2013 compute the pullback dx \u03c0x\u2190\u2212 dx\u00d7de dy \u03c0y\u2212\u2192 dy of the cospan dx fx\u2212\u2192 dex,y fy\u2190\u2212 dy associated to each edge e = xy in G \u2013 let de be the decomposition obtained by replacing the cospan associated to e in d by the the cospan\nIm\u03c0x fx|Im\u03c0x\u2212\u2212\u2212\u2212\u2192 dex,y fy|Im\u03c0y\u2190\u2212\u2212\u2212\u2212 Im\u03c0y,\nreturn de.\nProof: Fixing any enumeration e1, . . . ,em of the edges of G, we will show that that following recursive procedure (Algorithm 2) satisfies the requirements of the lemma when called on inputs (d,(e1, . . . ,em)). Notice that in Algorithm 1 we always have an injection Im\u03c0x \u21aa\u2192 dx. By this fact and since Algorithm 2\nAlgorithm 2 Recursive filtering Input: a FinSetop-valued structured decomposition d : ( \u222b G)op\u2192 FinSet and a list \u2113 of edges of G.\nif \u2113 is empty then return d else \u2013 split \u2113 into its head-edge e and its tail \u2113\u2032\n\u2013 let de be the output of Algorithm 1 on inputs (d,e) \u2013 recursively call Algorithm 2 on inputs (de, \u2113\u2032).\nend if\namounts to computing |EG| pullbacks in FinSet and hence the running time bound is evident. Now suppose the input decomposition is tree-shaped (i.e. suppose that G is a tree); we will proceed by induction to show that the output of Algorithm 1 is isomorphic to Ad. If G\u223c= K1 (the one-vertex complete graph), then the algorithm terminates immediately (since G has no edges) and returns d. This establishes the base-case of the induction since Ad \u223c= d whenever G \u223c= K1. Now suppose |EG| > 0 and let e = x1x2 be the last edge of the tree G over which Algorithm 2 iterates upon. The removal of e splits G into two sub-trees T1 \u21aa\u2192 G and T2 \u21aa\u2192 G containing the nodes x1 and x2 respectively. In turn these two trees induce two sub-decompositions \u03b9i : di \u21aa\u2192 d of d; these are given by the following composite functors:\nd1 : ( \u222b T1)op \u21aa\u2192 ( \u222b G)op\u2192 FinSet and d2 : ( \u222b T2)op \u21aa\u2192 ( \u222b G)op\u2192 FinSet .\nBy the induction hypothesis we have that, for each i \u2208 {1,2}, running Algorithm 1 on di yields an object \u03b4i isomorphic to Adi : ( \u222b Ti)op \u2192 FinSet. Thus, by Point (A2) of Theorem 4.1, the span of\nstructured decompositions d1 \u03b91 \u21aa\u2212\u2192 d \u03b92\u2190\u2212\u21a9 d2 yields the following commutative diagram.\nT d1 Ad1 d1\nT d Ad d\nT d2 Ad1 d2\n\u03b11d1\u03b1 2 Ad1\n\u03b11d2\u03b1 2 Ad2\n\u03b7d1\n\u03b7d2\n\u03b91\n\u03b91\n\u03b11d\u03b1 2 Ad\n\u03b7d\nA\u03b91\nA\u03b92\nT\u03b91\nT\u03b92\n(18)\nNow consider the cospan dx1 ex1\u2212\u2192 de ex1\u2190\u2212 dx2. Passing it through the functor const to obtain morphisms\nconstex1 : constd \u2032\u2192 di\nsuch that the following commutes.\nT d1 Ad1 d1\nT d Ad d constde\nT d2 Ad1 d2\n\u03b11d1\u03b1 2 Ad1\n\u03b11d2\u03b1 2 Ad2\n\u03b7d1\n\u03b7d2\n\u03b91\n\u03b91\n\u03b11d\u03b1 2 Ad\n\u03b7d\nA\u03b91\nA\u03b92\nT\u03b91\nT\u03b92\nconstex2\nconstex2\nThese observations imply that the following is a pullback diagram in FinSet.\nT d1(K1) = limd1\nT d(K1) = limd de\nT d2(K1) = limd2\n\u03c11\n\u03c12\n(19)\nWe can factor this diagram further as follows (where \u03bbi is the leg of the cone with apex limdi).\nT d1(K1) = limd1\nAd1x1\nT d(K1) = limd de\nAd2x2\nT d2(K1) = limd2\n\u03c11\n\u03c12\n\u03bb1\n\u03bb2\nFrom which we observe that all that remains to be shown is that the unique pullback arrow u shown in the following diagram\nT d1(K1) = limd1\nAd1x1\nT d(K1) = limd Ad1x1\u00d7de Ad2x2 de\nAd2x2\nT d2(K1) = limd2\n\u03c11\n\u03c12\n\u03bb1\n\u03bb2\n\u03c01\n\u03c02\nu\nis a surjection. To see why this suffices, notice that, if u is surjective, then the entire claim will follow since we would have\n\u03bbi\u03c1i = \u03c0iu =\u21d2 Im\u03bbi\u03c1i = Im\u03c0iu = Im\u03c0i|Imu = Im\u03c0i.\nBut then this concludes the proof since the surjectivity of u is immediate once we recall that Adixi was defined as Im\u03bbi and that limd = limd1\u00d7de limd2 (as established in Diagram 19). \u2293\u2294\nNotice that Lemma 4.2 does not na\u00efvely lift to decompositions of arbitrary shapes. For instance\nconsider the following example of a cyclic decomposition of a 5-cycle graph with vertices {x1, . . . ,x5}. x1 x2\nx1x2\nx5x1 x2x3\nx4x5 x3x4\nx5 x4 x3\nPassing this decomposition through the two-coloring sheaf SimpFinGr(\u2212,K2) (i.e. applying the functor DmSimpFinGr(\u2212,K2)) we obtain a structured co-decomposition \u03b4 valued in FinSet and whose bags are all two element sets corresponding to the two proper colorings of any edge. Now notice that, since odd cycles are not two-colorable at least one of the bags of A\u03b4 will be empty. In contrast, it is easy to verify that the output of Algorithm 1 on \u03b4 is isomorphic to \u03b4 itself.\nAlthough these observations might seem to preclude us from obtaining algorithmic results on decompositions that are not tree-shaped, if we are willing to accept slower running times (which are still FPT-time, but under a double parameterization rather than the single parameterization of Lemma 4.2), then we can efficiently solve the sheaf decision problem on decompositions of other shapes as well. This is Theorem 1.1 which we are finally ready to prove. For clarity, we wish to point out that the following result is exactly the same as Lemma 4.2 when we are given a decomposition whose shape is a tree: trees trivially have feedback vertex number zero.\nTheorem 4.3. (Theorem 1.1 restated) Let G be a finite, irreflexive, directed graph without antiparallel edges and at most one edge for each pair of vertices. Let D be a small adhesively cocomplete category, let F : Dop\u2192 FinSet be a presheaf and let C be one of {D, Dmono}. If F is a sheaf on the site ( C,Dcmp |C ) and if we are given an algorithm AF which computes F on any object c in time \u03b1(c), then there is an algorithm which, given any C-valued structured decomposition d : \u222b G\u2192 C of an object c \u2208 C and a feedback vertex set S of G, computes decF c in time\nO(max x\u2208V G\n\u03b1(dx)+\u03ba|S|\u03ba2)|EG|\nwhere \u03ba = maxx\u2208V G |F dx|.\nProof: [Proof of Theorem 1.1] Recall that, by Point (A3) of Theorem 4.1 the following diagram commutes.\nC FinSetop 2op\n\u222b Dcmp\nDmC DmFinSet op DmFinSet op Dm 2op\ncolim\nF\nDm F\ncomm.\ndecop\nA Dm decop\n\u2227\nfst\nsnd\ncomm. (by Thm. 4.1)\nOur proof will will rely on this fact together with the following claim.\nClaim 4.4. Consider the image of d under DmF and view it as a FinSet-valued structured co-decomposition DmF d : ( \u222b G)op\u2192 FinSet, fix any vertex x \u2208 V G and any enumeration \u2113 = (e1, . . . ,en) of the edges incident with x. Let \u03b3s be the output of Algorithm 2 when applied to the input (DmF d, \u2113) and, letting G\u2032 \u21aa\u2192 G be the subgraph of G obtained by removing all edges incident with x, define \u03b4s to be the decomposition \u03b4s : ( \u222b G\u2032)op \u21aa\u2192 ( \u222b G)op\n\u03b3s\u2212\u2192 FinSet . If DmF d(x) is a singleton, then \u2227\u25e6decop \u25e6A \u25e6DmF )(d) = (\u2227\u25e6decop \u25e6A)(\u03b4s).\nProof: [Proof of Claim 4.4] If the bag DmF dx has precisely one section, let\u2019s call it \u03be, then every matching family for F on d must involve \u03be. Notice that we trivially have that limDmF d = lim\u03b3s since the local pullbacks performed by Algorithm 1 (and hence Algorithm 2 cannot change the overall limit) and hence we have\n(\u2227\u25e6decop \u25e6A \u25e6DmF )(d) = (\u2227\u25e6decop \u25e6A)(\u03b3s).\nBut now notice that, since DmF dx is a singleton, any collection of sections (\u03b6 \u2208 \u03b4s(z))z\u2208V G\u2032 must give rise to a matching family for d since, by the construction of \u03b4s, we have that each such section \u03b6 in the family must agree with \u03be. But then, as desired, we have proven that\n(\u2227\u25e6decop \u25e6A \u25e6DmF )(d) = (\u2227\u25e6decop \u25e6A)(\u03b4s).\n\u2293\u2294\nIn light of this result, notice that, if F ds is a singleton for each s \u2208 S (where recall that S is a feedback vertex set in G), then, by repeatedly applying Claim 4.4 until the output decomposition is a forest and then applying the algorithm of Lemma 4.2, we can correctly solve the sheaf decision problem in time O(maxx\u2208V G \u03b1(dx)+\u03ba2)|EG| (since this entire procedure amounts to one call to algorithm AF in order to compute DmF d and O(|EG|)-calls to the edge-filtering algorithm \u2013 i.e. Algorithm 1).\nNow, at an intuitive level, if there exists s \u2208 S such that F ds is not a singleton, then we can simply repeat the above procedure once for each section in F ds. Stating this more formally, define for each \u03c3 \u2208\u220fs\u2208S F ds the FinSet-valued structured co-decomposition \u03c9\u03c3 : ( \u222b G)op\u2192 FinSet by replacing all bags of the form DmF ds in DmF d with the bag \u03c9\u03c3s := {\u03c3s} (where \u03c3s is the section at index s in the tuple \u03c3). Then, since F is a sheaf, it follows that\ndecop F c = \u2228\n\u03c3\u2208\u220fs\u2208S F ds (\u2227\u25e6Dm decop \u25e6A)(\u03c9\u03c3).\nThis will have the desired running time since it corresponds to first computing DmF d (which we can do in time O(maxx\u2208V G \u03b1(dx)) using algorithm AF ) and then running Algorithm 2 (whose correctness and running time are established by Claim 4.4 and Lemma 4.2) at most (|\u220fs\u2208S F ds| \u2208 O(k|S|))-many times. \u2293\u2294\nThe reader might notice that we have so far avoided mentioning notions of width of the input decompositions and that indeed these considerations do not appear in the statements of the algorithms\nof Lemma 4.2 or Theorem 1.1. This is for good reason: one should observe that it is not the width of the decompositions of the inputs that matters; instead it is the width of the decompositions of the solutions spaces that is key to the algorithmic bounds. In categories (such as that of graphs, say) where objects come equipped with natural notions of \u2018size\u2019, then one might expect that it would be convenient to state the running time of the algorithm in terms of the maximum bag size in the input decomposition. However, we maintain (in accordance with observations previously made by Bodlaender and Fomin [39]) that quantifying the running time of the algorithm in terms of the width of the decompositions of the inputs is misleading. To see why, consider the very simple, but concrete case of algorithms for coloring on tree decompositions. In this situation, it is perfectly fine to admit very large bags in our decomposition so long as the following two conditions are met: 1. the local solution spaces (which are sets) associated to these bags are small and 2. these solution spaces can be determined in a bounded amount of time. A trivial, but illuminating example of this phenomenon is the case in which we allow large bags (of unbounded size) in our decomposition as long as they consist of complete graphs: for such graphs we have only one proper coloring up to isomorphism and this can be determined in linear time."
        },
        {
            "heading": "4.3. Implementation",
            "text": "Compared to the traditional, combinatorial definition of graph decompositions [6, 7, 4], our category theoretic formulation of structured decompositions has two advantages which we have already encountered.\n1. Object agnosticism Structured decompositions allow us to describe decompositions of objects of any adhesive category and thus one doesn\u2019t need to define ad-hoc decompositions on a caseby-case basis whenever one encounters a new kind of combinatorial data.\n2. Functorial Algorithmics The functoriality of Dm (i.e. of categories of structured decompositions) allows us to make explicit use of solution spaces and decompositions thereof. This allows us to state the correctness of algorithmic results as the commutativity of appropriate diagrams (e.g. Diagram (4)) from which one can moreover infer running time bottlenecks.\nHowever, there is a further, more practical benefit of our category-theoretic perspective: it allows for a very smooth transition from mathematics to implementation. Indeed, our theoretical algorithmic results of Section 4 can be easily paired with corresponding implementations [37] in the AlgebraicJulia ecosystem [38]. As a proof of concept, we have implemented structured decompositions and Algorithm 2 for SHEAFDECISION on tree-shaped decompositions which demonstrates the seamless transition from mathematics to code which one can experience one category theory is embraced as the core theoretical abstraction. We encourage the reader to consult the relevant repository [37] for further details of the implementation."
        },
        {
            "heading": "5. An Open Problem on the Shapes of the Decompositions",
            "text": "Theorem 1.1 yields FPT-time algorithms for problems encoded as sheaves on adhesive categories. When instantiated, this allows us to obtain algorithmic results on many mathematical objects of algo-\nrithmic interest such as: 1. databases, 2. simple graphs, 3. directed graphs, 4. directed multigraphs, 5. hypergraphs, 6. directed hypergraphs, 7. simplicial complexes, 8. circular port graphs [33] and 9. half-edge graphs. However one should note that these parameterizations are only useful if: (1) not all objects in this class have bounded structured decomposition width and (2) only if the feedback vertex number of the class of decomposition shapes is bounded. Notice that it is easy to verify that, for all the examples mentioned above, not all objects have bounded tree-shaped decompositions. However, when it comes to decomposition shapes that are not trees, the question of whether all objects have bounded width with respect to a fixed class of decomposition shapes, it not obvious. Indeed, this will motivate Open Problem 6 which will arise naturally by the end of this section in which we will enquire about how our algorithmic results \u2013 which involve arbitrary decomposition shapes \u2013 compare to more traditional results in graph theory which solely make use of tree-shaped decompositions. In particular we will now briefly argue that, for the case of graph decomposition width (as defined by Carmesin [18]), our results end up yielding FPT algorithms only on classes of graphs which have bounded tree-width. Determining whether these observations can be carried over to more general classes of objects is a fascinating new direction for work (see Open Problem 6).\nTo see this, first of all note that, for any FinGr-valued decomposition d : \u222b\nH \u2192 FinGr of a graph G, it is easy to see that the treewidth tw(H) of our shape graph H is at most its feedback vertex number. Furthermore, if the shape graph H has treewidth at most tH and the input graph G has Hwidth at most tG, then we can easily build a tree decomposition of G of width tH \u00b7 tG, implying that we only compute on graphs with bounded treewidth. Since we are now only dealing with graphs, it will be convenient to switch to Carmesin\u2019s [18] more combinatorial notation13. Let T T = (T,(Xt)t\u2208V (T )) be a tree decomposition of H and T G = (H,(Yt)t\u2208V (H)) be a H-decomposition of G. We claim that T = (T,(\u222at \u2032\u2208XtYt \u2032)t\u2208V (T ) is a tree decomposition of G. Coverage is easy as each bag of T\nH is contained in at least one bag of T as all bags are covered in T G. For the coherence, we argue as follows. Assume a vertex v \u2208 V (G) is in two bags t, t \u2032 \u2208 V (T ), but not in a bag t \u2032\u2032 on the path in T from t to t \u2032. By the construction of the bags of T , there is a vertex u \u2208 Yt whose bag contains v and similarly a vertex u\u2032 \u2208 Yt \u2032 containing v. By the coherence of T H , there has to be a path p between u and u\u2032 in T H such that v is in all bags Yt\u0303 for t\u0303 \u2208V (p) (the subgraph of H induced by the bags containing v is connected). As v is not in the bag of t \u2032\u2032 of T , no vertex of V (p) is in Xt \u2032\u2032 (of T T ), which contradicts that the removal of Xt \u2032\u2032 separates u \u2208 Xt \\Xt \u2032\u2032 from Xt \u2032 \\Xt \u2032\u2032 \u220b u\u2032.\nHence, if the treewidth of the graphs of the class H allowed for the shape of the structured decomposition is bounded, the graphs with bounded H -width have bounded treewidth. Hence, to obtain new FPT algorithms the treewdith of the graphs of the class H should not be bounded. On the other hand, the class H has to be quite restricted, as otherwise each graph will have bounded H -width. For example, if H contains the n\u00d7 n-grid, every n-vertex graph was width 1 in the class, as we can see as follows. Consider the n\u00d7 n-grid H and let vi, j for 1 \u2264 i, j \u2264 n be such that vi\u22121, jvi, j \u2208 E(H) for 2\u2264 i\u2264 n and vi, j\u22121vi, j \u2208 E(H) for 2\u2264 j\u2264 n. We claim that (H,({i, j})vi, j\u2208V (H)) is a H-decomposition of every graph with vertex set {1, . . . ,n}. Coverage is easy to see as for each 1 \u2264 i, j \u2264 n, we constructed a bag containing i and j and hence the complete graph over {1, . . . ,n} is covered. For the coherence, notice that a vertex k is contained in the bags Xk, j for 1 \u2264 j \u2264 n and Xi,k for 1 \u2264 i \u2264 n, 13We refer the reader to Bumpus, Kocis and Master [34] for details of how to choose a graph-theoretic instantiation of our categorical notation which neatly corresponds to that of Carmesin\u2019s notation of graph decompositions [18].\nwhich build a cross in the grid H and hence these bags are connected. This construction can be generalized to graphs having the n\u00d7n-grid as a minor by making the bag of a vertex contracted with vi, j equal to the bag Xvi, j and making all bags of vertices that are removed empty. Hence, all graphs have planar-width at most one. This motivates the following fascinating open problem.\nOpen Problem 6. Does there exists an adhesive category C such that there is a class \u03c7 of objects in C and a graph class G of bounded feedback vertex number such that the following two conditions hold simultaneously?\n\u2022 The class \u03c7 has unbounded tree-shaped structured decomposition width and\n\u2022 the class \u03c7 has bounded G-shaped structured decomposition width."
        },
        {
            "heading": "7. Discussion",
            "text": "Our main contribution is to bridge the \u201cstructure\u201d and \u201cpower\u201d communities by proving an algorithmic meta-theorem (Theorem 1.1) which informally states that decision problems encoded as sheaves (Representational Compositionality) can be solved by dynamic programming (Algorithmic Compositionality) in linear time on classes of inputs which admit structured decompositions of bounded width and whose decomposition shape has bounded feedback vertex number (Structural Compositionality). Our results thus bridge the mathematical and linguistic differences of these two communities \u2013 of \u201cstructure\u201d and \u201cpower\u201d \u2013 by showing how to use category theory and sheaf theory to amalgamate three kinds of compositionality found in mathematics and theoretical computer science. This is summarized at a very high level via the following diagram (i.e. Diagram 1 which was formalized as Diagram 6).\nData Sol. Spaces Answer Space\nData w/ Decomps.\nDecomps. of Data Decomps. of Sol. Spaces Decomps. of Sol. Spaces Decomps. of Answers\ncollect\nGlobalSolSpace\nLocalSolSpace\ncomm.\nis Empty?\nAlgorithm is Empty (locally) ?\n\u2227comm.\nFuture work. Other than Open Problem 6, directions for further work abound. Here we mention but a few obvious, yet exciting candidates. First of all it is clear that, although our meta-theoretic results achieve a remarkable degree of horizontal generality (in terms of the kinds of mathematical structures to which they apply), their vertical generality (the breadth of problems which can be solved) is still surpassed by more traditional results such as Courcelle\u2019s theorem [23]. It is a fascinating direction for further work to understand the connection between these model-theoretic approaches and our category- and sheaf-theoretic ones. Furthermore, we provide the following two more concrete lines of future work.\n1. Studying the connections between other kinds of topologies (such as those generated by more permissive containment relations such as graph minors) and the topologies given by structured decompositions.\n2. For other problems \u2013 such as vertex cover or Hamilton Path \u2013 we need more tools since, although they can be presented as presheaves, they fail to be sheaves. Indeed, note that this failure of compositionality \u201con the nose\u201d is not specific to our approach and it exists in algorithmics as well: when solving Hamilton path by dynamic programming on a tree decomposition, one does not map the bags of the decomposition to local Hamilton Paths, but instead to disjoint collections of paths (see Flum and Grohe [24] for details). The seasoned algorithmicist will point out that there is a template which can be often followed in order to choose the correct partial solutions: consider a global solution, induce it locally on the bags and then use this information to determine the obstructions to algorithmic compositionality. From our perspective this looks a lot like asking: \u201cwhat are the obstructions to the problem being a sheaf and how can we systematically track that information?\u201d Fortunately there are many powerful and welldeveloped tools from sheaf cohomology which appear to be appropriate for this task. This is an exciting new direction for research which we are already actively exploring."
        },
        {
            "heading": "A. Notions from Sheaf Theory",
            "text": "Here we collect basic sheaf-theoretic definitions which we use throughout the document. We refer the reader to Rosiak\u2019s textbook [29] for an introduction to sheaf theory which is suitable for beginners.\nDefinition A.1. Let C be a category with pullbacks and let K be a function assigning to each object c in C a family of sets of morphisms with codomain c called a family of covering sets. We call K a a Grothendieck pre-topology on C if the following three conditions hold for all c \u2208C.\n( PT1) If f : c\u2032\u2192 c is an isomorphism, then { f} \u2208 K(c).\n( PT2) If S \u2208 K(c) and g : b\u2192 c is a morphism in C, then the pullback of S and g is a covering set for b; i.e. {g\u00d7c f | f \u2208 S} \u2208 K(b).\n( PT3) If { fi : ci\u2192 c | i \u2208 I} \u2208 K(c), then, whenever we are given\n{gi j : bi j\u2192 ci| j \u2208 Ji} \u2208 K(ci)\nfor all i \u2208 I, we must have\n{ fi \u25e6gi j : bi j\u2192 ci\u2192 c | i \u2208 I, j \u2208 Ji} \u2208 K(c).\nDefinition A.2. A sieve on an object c \u2208 C is a family Sc of morphisms with codomain c which is closed under pre-composition.\nSieves are essentially what happens when we decide to just use those families that are \u201csaturated\u201d (in the sense that they are closed under pre-composition with morphisms in C); they are introduced in order to present the definition of a Grothendieck topology (see A.3), a revision of A.1.\nObserve that (at least when C is locally small) sieves can be identified with subfunctors of the representable hom-functor hom(\u2212,c) = yc (note that the category SetC op of presheaves on C has pullbacks, letting us drop, via this sieve approach, the assumption on C itself). Note also that if S\u2286 hom(\u2212,c) is a sieve on c and f : b\u2192 c is any morphism to c, then the pullback sieve along f\nf \u2217(S) = {g|cod(g) = b, f \u25e6g \u2208 S}\nis a sieve on b. Typically, the definition of a Grothendieck topology is then given in terms of a function J assigning sieves to the objects of C such that three axioms (maximal sieve, stability under base change, and transitivity) are satisfied. But really the stability axiom \u2013 requiring that if S \u2208 J(c), then f \u2217(S) \u2208 J(b) for any arrow f : b\u2192 c \u2013 just amounts to requiring that J is in fact a functor J : Cop \u2192 Set, i.e., an object in the presheaf category SetC op . If we let Sieve : Cop\u2192 Set be the functor which takes objects c of a small category C to the set of all sieves on c, and for any morphism f : x\u2192 y in C use the map\nf \u2217 : (S \u2208 Sieve(y)) 7\u2192 ( {g : w\u2192 x | ( f g : w\u2192 x\u2192 y) \u2208 S} \u2208 Sieve(x) ) ,\nthen we can give a somewhat condensed definition of a Grothendieck topology (by already building the usual stability axiom into the characterization of J as a particular functor), as follows.\nDefinition A.3. Let C be a category and consider a subfunctor J of Sieve : Cop\u2192 Set of \"permissible sieves\". We call J a Grothendieck topology on C if it satisfies the following two conditions:\n( Gt1) the maximal sieve is always permissible; i.e. { f \u2208Mor(C) | cod( f ) = c} \u2208 J(c) for all c \u2208 C\n( Gt2) for any sieve R on some object c \u2208 C, if there is a permissible sieve S \u2208 J(c) on c such that for all (h : b\u2192 c) \u2208 S the sieve h\u2217(R) is permissible on b (i.e. h\u2217(R) \u2208 J(b)), then R is itself permissible on c (i.e. R \u2208 J(c)).\nFor any c\u2208C we call the elements S\u2208 J(c) J-covers or simply covers, if J is understood from context. A site is a pair (C,J) consisting of a category C and a Grothendieck topology on C.\nDefinition A.4. Let (C,J) be a site, S be a J-cover of an object c \u2208 C and P : Cop\u2192 Set be a presheaf. Then a matching family of sections of P with respect to the cover S is a morphism (natural transformation) of presheaves \u03c7 : S\u21d2 P.\nDefinition A.5. Let P : Cop\u2192 Set be a presheaf on a site (C,J). Then we call P a sheaf with respect to J (or a J-sheaf) if for all c \u2208 C and for all covering sieves ( \u03b9 : S\u21d2 yc ) \u2208 J(c) of c each matching family \u03c7 : S\u21d2 P has a unique extension to the morphism E : yc\u21d2 P."
        }
    ],
    "title": "Compositional Algorithms on Compositional Data: Deciding Sheaves on Presheaves",
    "year": 2023
}