{
    "abstractText": "Moving from the mathematical theory of (abstract) syntax, we develop a general relational theory of symbolic manipulation parametric with respect to, and accounting for, general notions of syntax. We model syntax relying on categorical notions, such as free algebras and monads, and show that a general theory of symbolic manipulation in the style of rewriting systems can be obtained by extending such notions to an allegorical setting. This way, we obtain an augmented calculus of relations accounting for syntax-based rewriting. We witness the effectiveness of the relational approach by generalising and unifying milestones results in rewriting, such as the parallel moves and the TaitMartin-L\u00f6f techniques.",
    "authors": [
        {
            "affiliations": [],
            "name": "Francesco Gavazzo"
        }
    ],
    "id": "SP:6c111b6833f6e2807ce5103b4e427a3e9795779f",
    "references": [
        {
            "authors": [
                "J.A. Goguen",
                "J.W. Thatcher",
                "E.G. Wagner",
                "J.B. Wright"
            ],
            "title": "Initial algebra semantics and continuous algebras",
            "venue": "J. ACM, vol. 24, no. 1, pp. 68\u201395, 1977.",
            "year": 1977
        },
        {
            "authors": [
                "A. Pitts"
            ],
            "title": "Nominal Sets: Names and Symmetry in Computer Science, ser. Cambridge Tracts in Theoretical Computer Science",
            "year": 2013
        },
        {
            "authors": [
                "M. Gabbay",
                "A.M. Pitts"
            ],
            "title": "A new approach to abstract syntax involving binders",
            "venue": "14th Annual IEEE Symposium on Logic in Computer Science, Trento, Italy, July 2-5, 1999. IEEE Computer Society, 1999, pp. 214\u2013224.",
            "year": 1999
        },
        {
            "authors": [
                "A.M. Pitts"
            ],
            "title": "A fresh approach to representing syntax with static binders in functional programming",
            "venue": "Proceedings of the Sixth ACM SIG- PLAN International Conference on Functional Programming (ICFP \u201901), Firenze (Florence), Italy, September 3-5, 2001, B. C. Pierce, Ed. ACM, 2001, p. 1.",
            "year": 2001
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "Equivariant syntax and semantics",
            "venue": "Automata, Languages and Programming, 29th International Colloquium, ICALP 2002, Malaga, Spain, July 8-13, 2002, Proceedings, ser. Lecture Notes in Computer Science, P. Widmayer, F. T. Ruiz, R. M. Bueno, M. Hennessy, S. J. Eidenbenz, and R. Conejo, Eds., vol. 2380. Springer, 2002, pp. 32\u201336.",
            "year": 2002
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "Alpha-structural recursion and induction",
            "venue": "J. ACM, vol. 53, no. 3, pp. 459\u2013506, 2006.",
            "year": 2006
        },
        {
            "authors": [
                "M.P. Fiore",
                "G.D. Plotkin",
                "D. Turi"
            ],
            "title": "Abstract syntax and variable binding",
            "venue": "14th Annual IEEE Symposium on Logic in Computer Science, Trento, Italy, July 2-5, 1999. IEEE Computer Society, 1999, pp. 193\u2013202.",
            "year": 1999
        },
        {
            "authors": [
                "N. Arkor",
                "M. Fiore"
            ],
            "title": "Algebraic models of simple type theories: A polynomial approach",
            "venue": "LICS \u201920: 35th Annual ACM/IEEE Symposium on Logic in Computer Science, Saarbr\u00fccken, Germany, July 8-11, 2020, H. Hermanns, L. Zhang, N. Kobayashi, and D. Miller, Eds. ACM, 2020, pp. 88\u2013101.",
            "year": 2020
        },
        {
            "authors": [
                "M. Hamana"
            ],
            "title": "Free s-monoids: A higher-order syntax with metavariables",
            "venue": "Programming Languages and Systems: Second Asian Symposium, APLAS 2004, Taipei, Taiwan, November 4-6, 2004. Proceedings, ser. Lecture Notes in Computer Science, W. Chin, Ed., vol. 3302. Springer, 2004, pp. 348\u2013363.",
            "year": 2004
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "Polymorphic abstract syntax via grothendieck construction",
            "venue": "Foundations of Software Science and Computational Structures - 14th International Conference, FOSSACS 2011, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2011, Saarbr\u00fccken, Germany, March 26-April 3, 2011. Proceedings, ser. Lecture Notes in Computer Science, M. Hofmann, Ed., vol. 6604. Springer, 2011, pp. 381\u2013395.",
            "year": 2011
        },
        {
            "authors": [
                "M. Hofmann"
            ],
            "title": "Semantical analysis of higher-order abstract syntax",
            "venue": "14th Annual IEEE Symposium on Logic in Computer Science, Trento, Italy, July 2-5, 1999. IEEE Computer Society, 1999, pp. 204\u2013213.",
            "year": 1999
        },
        {
            "authors": [
                "F. Pfenning",
                "C. Elliott"
            ],
            "title": "Higher-order abstract syntax",
            "venue": "Proceedings of the ACM SIGPLAN\u201988 Conference on Programming Language Design and Implementation (PLDI), Atlanta, Georgia, USA, June 22- 24, 1988, R. L. Wexelblat, Ed. ACM, 1988, pp. 199\u2013208.",
            "year": 1988
        },
        {
            "authors": [
                "D. Miller"
            ],
            "title": "Abstract syntax for variable binders: An overview",
            "venue": "Computational Logic - CL 2000, First International Conference, London, UK, 24-28 July, 2000, Proceedings, ser. Lecture Notes in Computer Science, J. W. Lloyd, V. Dahl, U. Furbach, M. Kerber, K. Lau, C. Palamidessi, L. M. Pereira, Y. Sagiv, and P. J. Stuckey, Eds., vol. 1861. Springer, 2000, pp. 239\u2013253.",
            "year": 2000
        },
        {
            "authors": [
                "M.H.A. Newman"
            ],
            "title": "On theories with a combinatorial definition of \"equivalence",
            "venue": "Annals of Mathematics, vol. 43, no. 2, pp. 223\u2013243, 1942.",
            "year": 1942
        },
        {
            "authors": [
                "M. Bezem",
                "J. Klop",
                "E. Barendsen",
                "R. de Vrijer",
                "Terese"
            ],
            "title": "Term Rewriting Systems, ser. Cambridge Tracts in Theoretical Computer Science",
            "year": 2003
        },
        {
            "authors": [
                "F. Baader",
                "T. Nipkow"
            ],
            "title": "Term rewriting and all that",
            "year": 1998
        },
        {
            "authors": [
                "G.P. Huet"
            ],
            "title": "Confluent reductions: Abstract properties and applications to term rewriting systems: Abstract properties and applications to term rewriting systems",
            "venue": "J. ACM, vol. 27, no. 4, pp. 797\u2013821, 1980.",
            "year": 1980
        },
        {
            "authors": [
                "J.W. Klop"
            ],
            "title": "Combinatory reduction systems",
            "venue": "Ph.D. dissertation, Univ. Utrecht, 1980.",
            "year": 1980
        },
        {
            "authors": [
                "M. Fern\u00e1ndez",
                "M. Gabbay"
            ],
            "title": "Nominal rewriting",
            "venue": "Inf. Comput., vol. 205, no. 6, pp. 917\u2013965, 2007.",
            "year": 2007
        },
        {
            "authors": [
                "N. Ghani",
                "C. L\u00fcth"
            ],
            "title": "Rewriting via coinserters",
            "venue": "Nord. J. Comput., vol. 10, no. 4, pp. 290\u2013312, 2003.",
            "year": 2003
        },
        {
            "authors": [
                "A. Burroni"
            ],
            "title": "Higher-dimensional word problems with applications to equational logic",
            "venue": "Theoretical Computer Science, vol. 115, no. 1, pp. 43\u201362, 1993.",
            "year": 1993
        },
        {
            "authors": [
                "A. Power"
            ],
            "title": "An abstract formulation for rewrite systems",
            "venue": "Category Theory and Computer Science, D. Pitt, D. Rydehard, P. Dybjer, A. Pitts, and A. Poign\u00e9, Eds., vol. 389. Springer, 1989, pp. 300\u2013312.",
            "year": 1989
        },
        {
            "authors": [
                "H. Reichel"
            ],
            "title": "A 2-category approach to critical pair completion",
            "venue": "Recent Trends in Data Type Specification, ser. Lecture Notes in Computer Science, vol. 534. Springer Verlag, 1991, pp. 266\u2013273.",
            "year": 1991
        },
        {
            "authors": [
                "D.E. Rydeheard",
                "J.G. Stell"
            ],
            "title": "Foundations of equational deduction: A categorical treatment of equational proofs and unification algorithms",
            "venue": "Category Theory and Computer Science, ser. Lecture Notes in Computer Science, vol. 283. Springer Verlag, 1987, pp. 114\u2013139.",
            "year": 1987
        },
        {
            "authors": [
                "J.G. Stell"
            ],
            "title": "Modelling term rewriting systems by sesqui-categories",
            "venue": "Keele University, Tech. Rep. TR94-02, 1994.",
            "year": 1994
        },
        {
            "authors": [
                "R.A.G. Seely"
            ],
            "title": "Modelling computations: A 2-categorical framework",
            "venue": "Proceedings of the Second Annual Symposium on Logic in Computer Science, 1987, pp. 65\u201371.",
            "year": 1987
        },
        {
            "authors": [
                "C. L\u00fcth",
                "N. Ghani"
            ],
            "title": "Monads and modular term rewriting",
            "venue": "Category Theory in Computer Science CTCS\u201997, ser. Lecture Notes in Computer Science, vol. 1290. Santa Margherita, Italy: Springer Verlag, 1997, pp. 69\u201386.",
            "year": 1997
        },
        {
            "authors": [
                "C. L\u00fcth"
            ],
            "title": "Categorical term rewriting: Monads and modularity",
            "venue": "Ph.D. dissertation, University of Edinburgh, 1998.",
            "year": 1998
        },
        {
            "authors": [
                "P.J. Freyd",
                "A. Scedrov"
            ],
            "title": "Categories, allegories, ser",
            "venue": "North-Holland mathematical library. North-Holland,",
            "year": 1990
        },
        {
            "authors": [
                "P. Johnstone"
            ],
            "title": "Sketches of an Elephant: A Topos Theory Compendium: Volume 2, ser. Oxford Logic Guides",
            "year": 2002
        },
        {
            "authors": [
                "A.M. Pitts"
            ],
            "title": "Applications of sup-lattice enriched category theory to sheaf theory",
            "venue": "Proc. London Math. Soc., vol. 57, pp. 433\u2013480, 1988.",
            "year": 1988
        },
        {
            "authors": [
                "M. Barr"
            ],
            "title": "Relational algebras",
            "venue": "Lect. Notes Math., vol. 137, pp. 39\u201355, 1970. 21",
            "year": 1970
        },
        {
            "authors": [
                "A. Carboni",
                "G.M. Kelly",
                "R.J. Wood"
            ],
            "title": "A 2-categorical approach to change of base and geometric morphisms i",
            "venue": "Cahiers de Topologie et G\u00e9om\u00e9trie Diff\u00e9rentielle Cat\u00e9goriques, vol. 32, no. 1, pp. 47\u201395, 1991.",
            "year": 1991
        },
        {
            "authors": [
                "S. Eilenberg",
                "J.B. Wright"
            ],
            "title": "Automata in general algebras",
            "venue": "Information and Control, vol. 11, no. 4, pp. 452\u2013470, 1967.",
            "year": 1967
        },
        {
            "authors": [
                "R.S. Bird",
                "O. de Moor"
            ],
            "title": "Algebra of programming, ser. Prentice Hall International series in computer science",
            "year": 1997
        },
        {
            "authors": [
                "A. Barber"
            ],
            "title": "Dual intuitionistic linear logic",
            "venue": "The Laboratory for Foundations of Computer Science, University of Edinburgh, Tech. Rep. ECS-LFCS-96-347, 1996.",
            "year": 1996
        },
        {
            "authors": [
                "P. Aczel"
            ],
            "title": "A general church-rosser theorem",
            "venue": "Draft, Manchester, 1978.",
            "year": 1978
        },
        {
            "authors": [
                "M. Takahashi"
            ],
            "title": "Parallel reductions in lambda-calculus",
            "venue": "Inf. Comput., vol. 118, no. 1, pp. 120\u2013127, 1995.",
            "year": 1995
        },
        {
            "authors": [
                "A. Tarski"
            ],
            "title": "On the calculus of relations",
            "venue": "J. Symb. Log., vol. 6, no. 3, pp. 73\u201389, 1941.",
            "year": 1941
        },
        {
            "authors": [
                "G. Schmidt"
            ],
            "title": "Relational Mathematics, ser. Encyclopedia of Mathematics and its Applications",
            "year": 2011
        },
        {
            "authors": [
                "R.D. Maddux"
            ],
            "title": "Relation algebras",
            "venue": "Relational Methods in Computer Science, ser. Advances in computing science, C. Brink, W. Kahl, and G. Schmidt, Eds. Springer, 1997, pp. 22\u201338.",
            "year": 1997
        },
        {
            "authors": [
                "S. Lassen"
            ],
            "title": "Relational reasoning about functions and nondeterminism",
            "venue": "Ph.D. dissertation, Dept. of Computer Science, University of Aarhus, May 1998.",
            "year": 1998
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "Relational reasoning about contexts",
            "venue": "Higher Order Operational Techniques in Semantics, A. D. Gordon and A. M. Pitts, Eds., 1998, pp. 91\u2013136.",
            "year": 1998
        },
        {
            "authors": [
                "D. Howe"
            ],
            "title": "Proving congruence of bisimulation in functional programming languages",
            "venue": "Inf. Comput., vol. 124, no. 2, pp. 103\u2013112, 1996.",
            "year": 1996
        },
        {
            "authors": [
                "A. Pitts"
            ],
            "title": "Howe\u2019s method for higher-order languages",
            "venue": "Advanced Topics in Bisimulation and Coinduction, ser. Cambridge Tracts in Theoretical Computer Science, D. Sangiorgi and J. Rutten, Eds. Cambridge University Press, 2011, vol. 52, pp. 197\u2013232.",
            "year": 2011
        },
        {
            "authors": [
                "S. Abramsky"
            ],
            "title": "The lazy lambda calculus",
            "venue": "Research Topics in Functional Programming, D. Turner, Ed. Addison Wesley, 1990, pp. 65\u2013117.",
            "year": 1990
        },
        {
            "authors": [
                "A. Corradini",
                "F. Gadducci",
                "U. Montanari"
            ],
            "title": "Relating two categorial models of term rewriting",
            "venue": "Proc. of RTA 1995, ser. Lecture Notes in Computer Science, J. Hsiang, Ed., vol. 914. Springer, 1995, pp. 225\u2013240.",
            "year": 1995
        },
        {
            "authors": [
                "J. Meseguer"
            ],
            "title": "Twenty years of rewriting logic",
            "venue": "The Journal of Logic and Algebraic Programming, vol. 81, no. 7, pp. 721\u2013781, 2012, rewriting Logic and its Applications.",
            "year": 2012
        },
        {
            "authors": [
                "H. B\u00e4umer"
            ],
            "title": "On the use of relation algebra in the theory of reduction systems",
            "venue": "CSN, vol. 92, 1992, p. 5464.",
            "year": 1992
        },
        {
            "authors": [
                "G. Struth"
            ],
            "title": "Calculating church-rosser proofs in kleene algebra",
            "venue": "Proc. of RelMICS 2001, ser. Lecture Notes in Computer Science, H. C. M. de Swart, Ed., vol. 2561. Springer, 2001, pp. 276\u2013290.",
            "year": 2001
        },
        {
            "authors": [
                "H. Doornbos",
                "R.C. Backhouse",
                "J. van der Woude"
            ],
            "title": "A calculational approach to mathematical induction",
            "venue": "Theor. Comput. Sci., vol. 179, no. 1-2, pp. 103\u2013135, 1997.",
            "year": 1997
        },
        {
            "authors": [
                "G. Struth"
            ],
            "title": "Abstract abstract reduction",
            "venue": "J. Log. Algebraic Methods Program., vol. 66, no. 2, pp. 239\u2013270, 2006.",
            "year": 2006
        },
        {
            "authors": [
                "L. Bachmair",
                "N. Dershowitz"
            ],
            "title": "Commutation, transformation, and termination",
            "venue": "Proc. of International Conference on Automated Deduction 1986. Springer, 1986, pp. 5\u201320.",
            "year": 1986
        },
        {
            "authors": [
                "F. Gavazzo",
                "C. Faggian"
            ],
            "title": "A relational theory of monadic rewriting systems, part I",
            "venue": "Proc. of LICS 2021. IEEE, 2021, pp. 1\u201314.",
            "year": 2021
        },
        {
            "authors": [
                "R. Belohl\u00e1vek",
                "T. Kuhr",
                "V. Vychodil"
            ],
            "title": "Confluence and termination of fuzzy relations",
            "venue": "Inf. Sci., vol. 180, no. 17, pp. 3288\u20133303, 2010.",
            "year": 2010
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "Confluence and related properties of fuzzy relations",
            "venue": "FUZZ- IEEE 2009, IEEE International Conference on Fuzzy Systems, Jeju Island, Korea, 20-24 August 2009, Proceedings. IEEE, 2009, pp. 569\u2013574.",
            "year": 2009
        },
        {
            "authors": [
                "T. Kuhr",
                "V. Vychodil"
            ],
            "title": "Rewriting systems over similarity and generalized pseudometric spaces and their properties",
            "venue": "Fuzzy Sets Syst., vol. 275, pp. 110\u2013129, 2015.",
            "year": 2015
        },
        {
            "authors": [
                "F. Gavazzo",
                "C. Di Florio"
            ],
            "title": "Elements of quantitative rewriting",
            "venue": "Proc. ACM Program. Lang., vol. 7, no. POPL, jan 2023. [Online]. Available: https://doi.org/10.1145/3571256",
            "year": 2023
        },
        {
            "authors": [
                "G. Gonthier",
                "J. L\u00e9vy",
                "P. Melli\u00e8s"
            ],
            "title": "An abstract standardisation theorem",
            "venue": "Proc. of LICS 1992. IEEE Computer Society, 1992, pp. 72\u201381.",
            "year": 1992
        },
        {
            "authors": [
                "P. Melli\u00e8s"
            ],
            "title": "A factorisation theorem in rewriting theory",
            "venue": "Proc. of CTCS 1997, ser. Lecture Notes in Computer Science, E. Moggi and G. Rosolini, Eds., vol. 1290. Springer, 1997, pp. 49\u201368.",
            "year": 1997
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "A stability theorem in rewriting theory",
            "venue": "Proc. of LICS 1998. IEEE Computer Society, 1998, pp. 287\u2013298.",
            "year": 1998
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "Axiomatic rewriting theory II: the \u03bb\u03c3-calculus enjoys finite normalisation cones",
            "venue": "J. Log. Comput., vol. 10, no. 3, pp. 461\u2013487, 2000.",
            "year": 2000
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "Axiomatic rewriting theory VI residual theory revisited",
            "venue": "Proc. of RTA 2002, ser. Lecture Notes in Computer Science, S. Tison, Ed., vol. 2378. Springer, 2002, pp. 24\u201350.",
            "year": 2002
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "Axiomatic rewriting theory I: A diagrammatic standardization theorem",
            "venue": "Processes, Terms and Cycles: Steps on the Road to Infinity, Essays Dedicated to Jan Willem Klop, on the Occasion of His 60th Birthday, ser. Lecture Notes in Computer Science, A. Middeldorp, V. van Oostrom, F. van Raamsdonk, and R. C. de Vrijer, Eds., vol. 3838. Springer, 2005, pp. 554\u2013638.",
            "year": 2005
        },
        {
            "authors": [
                "A.D. Gordon"
            ],
            "title": "Bisimilarity as a theory of functional programming",
            "venue": "Proc. of MFPS 1995, ser. Electronic Notes in Theoretical Computer Science, S. D. Brookes, M. G. Main, A. Melton, and M. W. Mislove, Eds., vol. 1. Elsevier, 1995, pp. 232\u2013252.",
            "year": 1995
        },
        {
            "authors": [
                "R.C. Backhouse"
            ],
            "title": "Galois connections and fixed point calculus",
            "venue": "Algebraic and Coalgebraic Methods in the Mathematics of Program Construction, International Summer School and Workshop, Oxford, UK, April 10-14, 2000, Revised Lectures, ser. Lecture Notes in Computer Science, R. C. Backhouse, R. L. Crole, and J. Gibbons, Eds., vol. 2297. Springer, 2000, pp. 89\u2013148.",
            "year": 2000
        },
        {
            "authors": [
                "D. Hoffman"
            ],
            "title": "A cottage industry of lax extensions",
            "venue": "Categories and General Algebraic Structures with Applications, vol. 3, no. 1, pp. 113\u2013 151, 2015.",
            "year": 2015
        },
        {
            "authors": [
                "R.C. Backhouse",
                "P.F. Hoogendijk"
            ],
            "title": "Elements of a relational theory of datatypes",
            "venue": "Formal Program Development - IFIP TC2/WG 2.1 State-of-the-Art Report, 1993, pp. 7\u201342.",
            "year": 1993
        },
        {
            "authors": [
                "A. Kurz",
                "J. Velebil"
            ],
            "title": "Relation lifting, a survey",
            "venue": "J. Log. Algebr. Meth. Program., vol. 85, no. 4, pp. 475\u2013499, 2016.",
            "year": 2016
        },
        {
            "authors": [
                "Y. Kawahara"
            ],
            "title": "Notes on the universality of relational functors",
            "venue": "Memoirs of the Faculty of Science, Kyushu University. Series A, Mathematics, vol. 27, no. 2, pp. 275\u2013289, 1973.",
            "year": 1973
        },
        {
            "authors": [
                "R.C. Backhouse",
                "P.J. de Bruin",
                "P.F. Hoogendijk",
                "G. Malcolm",
                "E. Voermans",
                "J. van der Woude"
            ],
            "title": "Polynomial relators (extended abstract)",
            "venue": "Proc. of (AMAST \u201991, ser. Workshops in Computing. Springer, 1991, pp. 303\u2013326.",
            "year": 1991
        },
        {
            "authors": [
                "J. Lambek"
            ],
            "title": "A fixpoint theorem for complete categories.",
            "venue": "Mathematische Zeitschrift,",
            "year": 1968
        },
        {
            "authors": [
                "P. Selinger"
            ],
            "title": "A Survey of Graphical Languages for Monoidal Categories",
            "year": 2011
        },
        {
            "authors": [
                "F. Bonchi",
                "R. Piedeleu",
                "P. Sobocinski",
                "F. Zanasi"
            ],
            "title": "Bialgebraic semantics for string diagrams",
            "venue": "30th International Conference on Concurrency Theory, CONCUR 2019, August 27-30, 2019, Amsterdam, the Netherlands, ser. LIPIcs, W. J. Fokkink and R. van Glabbeek, Eds., vol. 140. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2019, pp. 37:1\u201337:17.",
            "year": 2019
        },
        {
            "authors": [
                "F. Bonchi",
                "F. Gadducci",
                "A. Kissinger",
                "P. Sobocinski",
                "F. Zanasi"
            ],
            "title": "String diagram rewrite theory i: Rewriting with frobenius structure",
            "venue": "Journal of the ACM, 2022.",
            "year": 2022
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "String diagram rewrite theory ii: Rewriting with symmetric monoidal structure",
            "venue": "Mathematical Structures in Computer Science, 2022.",
            "year": 2022
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "String diagram rewrite theory iii: Confluence with and without frobenius",
            "venue": "Mathematical Structures in Computer Science, 2022.",
            "year": 2022
        },
        {
            "authors": [
                "S. MacLane"
            ],
            "title": "Categories for the Working Mathematician",
            "year": 1971
        },
        {
            "authors": [
                "J. Ad\u00e1mek"
            ],
            "title": "Free algebras and automata realizations in the language of categories",
            "venue": "Commentationes Mathematicae Universitatis Carolinae, vol. 015, no. 4, pp. 589\u2013602, 1974.",
            "year": 1974
        },
        {
            "authors": [
                "H. Barendregt"
            ],
            "title": "The lambda calculus: its syntax and semantics, ser. Studies in logic and the foundations of mathematics",
            "year": 1984
        },
        {
            "authors": [
                "M. Miculan"
            ],
            "title": "A categorical model of the fusion calculus",
            "venue": "Proceedings of the 24th Conference on the Mathematical Foundations of Programming Semantics, MFPS 2008, Philadelphia, PA, USA, May 22-25, 2008, ser. Electronic Notes in Theoretical Computer Science, A. Bauer and M. W. Mislove, Eds., vol. 218. Elsevier, 2008, pp. 275\u2013293.",
            "year": 2008
        },
        {
            "authors": [
                "E. Robinson"
            ],
            "title": "Variations on algebra: Monadicity and generalisations of equational theories",
            "venue": "Formal Aspects Comput., vol. 13, no. 3-5, pp. 308\u2013326, 2002.",
            "year": 2002
        },
        {
            "authors": [
                "R. Matthes",
                "T. Uustalu"
            ],
            "title": "Substitution in non-wellfounded syntax with variable binding",
            "venue": "Electronic Notes in Theoretical Computer Science, vol. 82, no. 1, pp. 191\u2013205, 2003, cMCS\u201903, Coalgebraic Methods in Computer Science (Satellite Event for ETAPS 2003).",
            "year": 2003
        },
        {
            "authors": [
                "M.P. Fiore"
            ],
            "title": "Second-order and dependently-sorted abstract syntax",
            "venue": "Proc. of LICS 2008. IEEE Computer Society, 2008, pp. 57\u201368.",
            "year": 2008
        },
        {
            "authors": [
                "A. Hirschowitz",
                "M. Maggesi"
            ],
            "title": "Modules over monads and linearity",
            "venue": "Proc. of WoLLIC 2007, ser. Lecture Notes in Computer Science, D. Leivant and R. J. G. B. de Queiroz, Eds., vol. 4576. Springer, 2007, pp. 218\u2013237.",
            "year": 2007
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "Modules over monads and initial semantics",
            "venue": "Inf. Comput., vol. 208, no. 5, pp. 545\u2013564, 2010.",
            "year": 2010
        },
        {
            "authors": [
                "A. Hirschowitz",
                "T. Hirschowitz",
                "A. Lafont"
            ],
            "title": "Modules over monads and operational semantics (expanded version)",
            "venue": "Log. Methods Comput. Sci., vol. 18, no. 3, 2022.",
            "year": 2022
        },
        {
            "authors": [
                "A. Hirschowitz",
                "T. Hirschowitz",
                "A. Lafont",
                "M. Maggesi"
            ],
            "title": "Variable binding and substitution for (nameless) dummies",
            "venue": "Proc. of FOS- SACS 2022, ser. Lecture Notes in Computer Science, P. Bouyer and L. Schr\u00f6der, Eds., vol. 13242. Springer, 2022, pp. 389\u2013408.",
            "year": 2022
        },
        {
            "authors": [
                "M. Menni"
            ],
            "title": "About n-quantifiers",
            "venue": "Appl. Categorical Struct., vol. 11, no. 5, pp. 421\u2013445, 2003.",
            "year": 2003
        },
        {
            "authors": [
                "O. de Moor"
            ],
            "title": "Categories, relations and dynamic programming",
            "venue": "Math. Struct. Comput. Sci., vol. 4, no. 1, pp. 33\u201369, 1994. [Online]. Available: https://doi.org/10.1017/S0960129500000360",
            "year": 1994
        },
        {
            "authors": [
                "A. Gordon"
            ],
            "title": "A tutorial on co-induction and functional programming",
            "venue": "Workshops in Computing. Springer London, September 1994, pp. 78\u201395.",
            "year": 1994
        },
        {
            "authors": [
                "C. Hermida",
                "B. Jacobs"
            ],
            "title": "Structural induction and coinduction in a fibrational setting",
            "venue": "Inf. Comput., vol. 145, no. 2, pp. 107\u2013152, 1998.",
            "year": 1998
        },
        {
            "authors": [
                "D. Hofmann",
                "G. Seal",
                "W. Tholen",
                "Eds"
            ],
            "title": "Monoidal Topology. A Categorical Approach to Order, Metric, and Topology, ser. Encyclopedia of Mathematics and its Applications",
            "year": 2014
        },
        {
            "authors": [
                "B. Davey",
                "H. Priestley"
            ],
            "title": "Introduction to lattices and order",
            "year": 1990
        },
        {
            "authors": [
                "M. Hamana"
            ],
            "title": "An initial algebra approach to term rewriting systems with variable binders",
            "venue": "High. Order Symb. Comput., vol. 19, no. 2-3, pp. 231\u2013262, 2006.",
            "year": 2006
        },
        {
            "authors": [
                "B. Jacobs",
                "J.J.M.M. Rutten"
            ],
            "title": "A tutorial on (co)algebras and (co)induction",
            "venue": "Bulletin of The European Association for Theoretical Computer Science, 1997.",
            "year": 1997
        },
        {
            "authors": [
                "P. Levy"
            ],
            "title": "Infinitary howe\u2019s method",
            "venue": "Electr. Notes Theor. Comput. Sci., vol. 164, no. 1, pp. 85\u2013104, 2006.",
            "year": 2006
        },
        {
            "authors": [
                "A. Church",
                "J.B. Rosser"
            ],
            "title": "Some properties of conversion",
            "venue": "Trans. AMS, vol. 39, pp. 472\u2013482, 1936.",
            "year": 1936
        },
        {
            "authors": [
                "T. Yamada"
            ],
            "title": "Confluence and termination of simply typed term rewriting systems",
            "venue": "Proc. of RTA 2001, ser. Lecture Notes in Computer Science, A. Middeldorp, Ed., vol. 2051. Springer, 2001, pp. 338\u2013 352.",
            "year": 2001
        },
        {
            "authors": [
                "C.L. Ong"
            ],
            "title": "Non-determinism in a functional setting",
            "venue": "Proc. of LICS 1993. IEEE Computer Society, 1993, pp. 275\u2013286.",
            "year": 1993
        },
        {
            "authors": [
                "U. Dal Lago",
                "D. Sangiorgi",
                "M. Alberti"
            ],
            "title": "On coinductive equivalences for higher-order probabilistic functional programs",
            "venue": "Proc. of POPL 2014, 2014, pp. 297\u2013308.",
            "year": 2014
        },
        {
            "authors": [
                "U. Dal Lago",
                "F. Gavazzo",
                "P. Levy"
            ],
            "title": "Effectful applicative bisimilarity: Monads, relators, and howe\u2019s method",
            "venue": "Proc. of LICS 2017, 2017, pp. 1\u201312.",
            "year": 2017
        },
        {
            "authors": [
                "U. Da Lago",
                "F. Gavazzo"
            ],
            "title": "On bisimilarity in lambda calculi with continuous probabilistic choice",
            "venue": "2019, to appear.",
            "year": 2019
        },
        {
            "authors": [
                "F. Gavazzo"
            ],
            "title": "Coinductive equivalences and metrics for higherorder languages with algebraic effects",
            "venue": "Ph.D. dissertation, University of Bologna, Italy, 2019. [Online]. Available: http://amsdottorato.unibo.it/9075/",
            "year": 2019
        },
        {
            "authors": [
                "U. Dal Lago",
                "F. Gavazzo",
                "R. Tanaka"
            ],
            "title": "Effectful applicative similarity for call-by-name lambda calculi",
            "venue": "Joint Proceedings of the 18th Italian Conference on Theoretical Computer Science and the 32nd Italian Conference on Computational Logic co-located with the 2017 IEEE International Workshop on Measurements and Networking (2017 IEEE M&N), 2017, pp. 87\u201398.",
            "year": 2017
        },
        {
            "authors": [
                "R. Crubill\u00e9",
                "U. Dal Lago"
            ],
            "title": "On probabilistic applicative bisimulation and call-by-value lambda-calculi",
            "venue": "Proc. of ESOP 2014, 2014, pp. 209\u2013228.",
            "year": 2014
        },
        {
            "authors": [
                "D. Biernacki",
                "S. Lenglet"
            ],
            "title": "Applicative bisimilarities for call-byname and call-by-value \u03bb\u03bc-calculus",
            "venue": "Electr. Notes Theor. Comput. Sci., vol. 308, pp. 49\u201364, 2014.",
            "year": 2014
        },
        {
            "authors": [
                "U. Dal Lago",
                "F. Gavazzo",
                "R. Tanaka"
            ],
            "title": "Effectful applicative similarity for call-by-name lambda calculi",
            "venue": "Theor. Comput. Sci., vol. 813, pp. 234\u2013247, 2020.",
            "year": 2020
        },
        {
            "authors": [
                "U. Dal Lago",
                "F. Gavazzo"
            ],
            "title": "A relational theory of effects and coeffects",
            "venue": "Proc. ACM Program. Lang., vol. 6, no. POPL, pp. 1\u201328, 2022.",
            "year": 2022
        },
        {
            "authors": [
                "P. Borthelle",
                "T. Hirschowitz",
                "A. Lafont"
            ],
            "title": "A cellular howe theorem",
            "venue": "Proc. of LICS 2020, H. Hermanns, L. Zhang, N. Kobayashi, and D. Miller, Eds. ACM, 2020, pp. 273\u2013286.",
            "year": 2020
        },
        {
            "authors": [
                "T. Hirschowitz",
                "A. Lafont"
            ],
            "title": "A categorical framework for congruence of applicative bisimilarity in higher-order languages",
            "venue": "Log. Methods Comput. Sci., vol. 18, no. 3, 2022.",
            "year": 2022
        },
        {
            "authors": [
                "H. Urbat",
                "S. Tsampas",
                "S. Goncharov",
                "S. Milius",
                "L. Schr\u00f6der"
            ],
            "title": "Weak similarity in higher-order mathematical operational semantics",
            "venue": "CoRR, vol. abs/2302.08200, 2023. [Online]. Available: https://doi.org/10.48550/arXiv.2302.08200",
            "year": 2023
        },
        {
            "authors": [
                "A. Joyal"
            ],
            "title": "Foncteurs analytiques et esp\u00e8ces de structures",
            "venue": "Comptes rendus de l\u2019Acad\u00e9mie des sciences. S\u00e9rie I. Math\u00e9matique, vol. 298, no. 15, pp. 393\u2013396, 1984.",
            "year": 1984
        },
        {
            "authors": [
                "C. Mcbride"
            ],
            "title": "The derivative of a regular type is its type of one-hole contexts (extended abstract)",
            "venue": "04 2009.",
            "year": 2009
        },
        {
            "authors": [
                "M.G. Abbott",
                "T. Altenkirch",
                "N. Ghani",
                "C. McBride"
            ],
            "title": "Derivatives of containers",
            "venue": "Proc. of TLCA 2003, ser. Lecture Notes in Computer Science, M. Hofmann, Ed., vol. 2701. Springer, 2003, pp. 16\u201330.",
            "year": 2003
        },
        {
            "authors": [
                "M.G. Abbott",
                "T. Altenkirch",
                "C. McBride",
                "N. Ghani"
            ],
            "title": "for data: Differentiating data structures",
            "venue": "Fundam. Informaticae, vol. 65, no. 1- 2, pp. 1\u201328, 2005.",
            "year": 2005
        },
        {
            "authors": [
                "M.M. Clementino",
                "D. Hofmann",
                "G. Janelidze"
            ],
            "title": "The monads of classical algebra are seldom weakly cartesian",
            "venue": "Journal of Homotopy and Related Structures, vol. 9, pp. 175\u2013197, 2014.",
            "year": 2014
        },
        {
            "authors": [
                "C. Faggian"
            ],
            "title": "Probabilistic rewriting: Normalization, termination, and unique normal forms",
            "venue": "Proc. of FSCD 2019, 2019, pp. 19:1\u201319:25.",
            "year": 2019
        },
        {
            "authors": [
                "S.B. Lassen"
            ],
            "title": "Bisimulation in untyped lambda calculus: B\u00f6hm trees and bisimulation up to context",
            "venue": "Electr. Notes Theor. Comput. Sci., vol. 20, pp. 346\u2013374, 1999.",
            "year": 1999
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "Eager normal form bisimulation",
            "venue": "Proceedings of LICS 2005, 2005, pp. 345\u2013354.",
            "year": 2005
        },
        {
            "authors": [
                "U. Dal Lago",
                "F. Gavazzo"
            ],
            "title": "Effectful normal form bisimulation",
            "venue": "Proc. of ESOP 2019, 2019, pp. 263\u2013292.",
            "year": 2019
        },
        {
            "authors": [
                "R. Hasegawa"
            ],
            "title": "Two applications of analytic functors",
            "venue": "Theor. Comput. Sci., vol. 272, no. 1-2, pp. 113\u2013175, 2002.",
            "year": 2002
        },
        {
            "authors": [
                "H. Doornbos",
                "B. von Karger"
            ],
            "title": "On the union of well-founded relations",
            "venue": "Log. J. IGPL, vol. 6, no. 2, pp. 195\u2013201, 1998.",
            "year": 1998
        },
        {
            "authors": [
                "H. Doornbos",
                "R.C. Backhouse"
            ],
            "title": "Algebra of program termination",
            "venue": "Algebraic and Coalgebraic Methods in the Mathematics of Program Construction, International Summer School and Workshop, Oxford, UK, April 10-14, 2000, Revised Lectures, ser. Lecture Notes in Computer Science, R. C. Backhouse, R. L. Crole, and J. Gibbons, Eds., vol. 2297. Springer, 2000, pp. 203\u2013236.",
            "year": 2000
        },
        {
            "authors": [
                "B. Accattoli",
                "C. Faggian",
                "G. Guerrieri"
            ],
            "title": "Factorize factorization",
            "venue": "Proc. of CSL 2021, ser. LIPIcs, C. Baier and J. Goubault-Larrecq, Eds., vol. 183. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2021, pp. 6:1\u20136:25.",
            "year": 2021
        },
        {
            "authors": [
                "E. Nelson"
            ],
            "title": "Iterative algebras",
            "venue": "Theoretical Computer Science, vol. 25, no. 1, pp. 67\u201394, 1983.",
            "year": 1983
        },
        {
            "authors": [
                "J. Endrullis",
                "H.H. Hansen",
                "D. Hendriks",
                "A. Polonsky",
                "A. Silva"
            ],
            "title": "Coinductive foundations of infinitary rewriting and infinitary equational logic",
            "venue": "Log. Methods Comput. Sci., vol. 14, no. 1, 2018.",
            "year": 2018
        },
        {
            "authors": [
                "C. Schubert"
            ],
            "title": "Lax algebras: A scenic approach",
            "venue": "Ph.D. dissertation, Universit\u1e97 Bremen, 2006.",
            "year": 2006
        },
        {
            "authors": [
                "F. Gavazzo"
            ],
            "title": "Quantitative behavioural reasoning for higher-order effectful programs: Applicative distances",
            "venue": "Proceedings of the 33rd 23 Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2018, Oxford, UK, July 09-12, 2018, 2018, pp. 452\u2013461.",
            "year": 2018
        },
        {
            "authors": [
                "D. Orchard",
                "V.-B. Liepelt",
                "H. Eades III"
            ],
            "title": "Quantitative program reasoning with graded modal types",
            "venue": "Proc. ACM Program. Lang., vol. 3, no. ICFP, pp. 110:1\u2013110:30, 2019.",
            "year": 2019
        },
        {
            "authors": [
                "F. Dagnino",
                "F. Pasquali"
            ],
            "title": "Logical foundations of quantitative equality",
            "venue": "pp. 16:1\u201316:13, 2022.",
            "year": 2022
        },
        {
            "authors": [
                "A.K. Wright",
                "M. Felleisen"
            ],
            "title": "A syntactic approach to type soundness",
            "venue": "Inf. Comput., vol. 115, no. 1, pp. 38\u201394, 1994.",
            "year": 1994
        },
        {
            "authors": [
                "G.D. Plotkin",
                "J. Power"
            ],
            "title": "Adequacy for algebraic effects",
            "venue": "Proc. of FOSSACS 2001, 2001, pp. 1\u201324. 24",
            "year": 2001
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n30 5.\n01 77\n2v 1\n[ cs\n.L O\n] 2\nM ay\n2 02\n3\nIndex Terms\u2014Rewriting, Relational Reasoning, Confluence\nI. INTRODUCTION\nThe study of symbolic expressions and their manipulation has always been one of the prime goals of mathematics and, even more, of theoretical computer science. Indeed, it is precisely its \u201csymbol pushing\u201d that makes symbolic reasoning, and the associated notion of symbolic computation, so effective. Charles Wells1 greatly summarises the deep and fundamental relationship between symbolic expressions and their manipulation by writing symbolic terms are encapsulated computations.\nThe study of symbolic expressions as used by mathematicians, logicians, and computer scientists has been of little interest to mathematicians and logicians for a long time. Remarkable achievements, instead, have been achieved by computer scientists starting from the seventies [1]\u2013[13], mostly in the field of programming language theory, where algebraic theories of (abstract) syntax have been developed in terms of initial algebras and free monads [1]. Altogether, these results gave raise to a new research field which is generically referred to as mathematics of syntax, where syntax is tacitly understood as being abstract.\nSymbolic syntax, however, is largely sterile without a (symbolic) dynamics or operational semantics.2 Traditionally, rewriting theory [14]\u2013[17] is the discipline studying such symbolic, discrete transformations between expressions. However, even if considerably older than the aforementioned mathematics of syntax, rewriting has arguably not yet reached the same level of generality. Symbolic expressions, in fact, come in different flavours: they can be first-order, as in algebra, or higher-order, as in calculus; typed, as in programming language theory, or untyped, as in logic; one-dimensional, as\n1See https://abstractmath.org/MM/ (The Symbolic Language of Math). 2Operational semantics usually covers a large class of semantic behaviours,\nsymbolic manipulation being just one of them.\nin traditional mathematics, or two-dimensional, as in category theory, etc. This simple observation is at the very heart of the mathematical theory of syntax previously mentioned: there, different forms of syntax are obtained by different data structures which are uniformly understood in terms of algebras [1]. 1) Rewriting: Does anything similar happen to rewriting? Not really! Indeed, each kind of expressions previously mentioned leads to the development of a specific, syntaxbased rewriting theory. Term rewriting [15]\u2013[17], for instance, studies the symbolic manipulation of first-order expressions, whereas higher-order [15], [18] and nominal [19] rewriting focus on expressions with variable binding. This proliferation of ad hoc rewriting formalism has prevented rewriting from qualifying as a general theory of symbolic manipulation.\nActually, a general theory of symbolic manipulation, the socalled theory of Abstract Reduction Systems (ARSs) [14], [17], has been proposed almost one century ago (although its current formulation is due to Huet [17]). Such a theory moves from the conceptual assumption that \u201csymbol pushing\u201d is a relational notion and studies abstract properties of such a relation, such as confluence and termination. ARSs achieve their generality by simply ignoring the syntactic structure of expressions and they thus provide a limited (albeit not negligible) contribution to a general theory of symbolic manipulation. Unfortunately, being essentially syntax-free, ARSs can only account for symbolic manipulation as discrete transformations, this way giving no information on how such transformations interact with the syntactic structure of expressions. Quoting Ghani and L\u00fcth [20]:\n[. . .] ARSs lack sufficient structure to adequately model key concepts such as substitution, context and the layer structure whereby terms from one system are layered over terms from another in modularity problems. Hence ARSs are mainly used as an organisational tool with the difficult results proved directly at the syntactic level.\nThe proliferation of ad hoc syntax-based theories of rewriting is precisely caused by the aforementioned deficiencies of ARSs. To overcome all of that and move towards a general theory of symbolic reduction parametric with respect to, but at the same time accounting for, the syntactic structure of expressions, several authors have proposed to rebuild rewriting on a categorical, rather than relational, basis, notable examples being theories based on polygraphs [21], Lawvere theories [22], 2-categories (and variations thereof) [23]\u2013[26], and (enriched) monads [20], [27], [28].\nAlthough employing different categorical frameworks, all these theories share two common traits: first, they loose the relational understanding of symbolic manipulation replacing it with categorical constructions, such as suitable natural transformations, that are conceptually farther from the everyday practice and understanding of symbolic manipulation; second, they are denotational, rather than operational, meaning that symbolic manipulation is defined not on syntactic expressions, but on denotations thereof (e.g. arrows in suitable categories). Generality is thus achieved only denotationally, and at the expense of intuition. The question is now obvious: can the same level of generality be achieved operationally, maintaining the intuitive, relational understanding of symbolic manipulation?"
        },
        {
            "heading": "A. Contribution",
            "text": "In this paper, we answer the above question in the affirmative by showing that the relational approach at the heart of ARSs can account for a large class of syntactic expressions in a highly general, modular, and remarkably natural way that complements the previously mentioned mathematics of (abstract) syntax. This allows us to establish a new bridge between what one may ambitiously refer to as the mathematics of (formal) expressions and the mathematics of their (symbolic) manipulation. Whereas the former is algebraic and builds upon category theory, the latter is relational and builds upon allegory theory [29]. Remarkably, what is needed to define the relational theory of rewriting is exactly the allegorical counterpart of the categorical notions used to define syntax, namely initial algebras, free monads, etc. This outlines a general framework where categorical notions are used to define syntactic expressions, and their allegorical extensions provide symbolic manipulations for such expressions. We achieve these results proceeding as follows.\n1. We use suitable categories (viz. Grothendieck toposes [30])\nE to model the different kinds of expressions we are interested in (e.g. sets for first-order expressions [1] and presheaves for expressions with binders [2], [7]). 2. Syntax specification is then given by suitable signature\nfunctors on E , whereas syntax itself is defined by free monads over such functors. 3. We then apply the relational methodology observing that\nif a topos E models a universe of expressions, then its induced allegory [29], [31] Rel(E) models symbolic transformations between such expressions. 4. By extending functors, monads, and (initial) algebras from\nE to Rel(E) \u2013 something that, under suitable conditions, can be always done [32]\u2013[35] \u2013 we define new syntaxbased operators on relations that allow us to define interesting notions of rewriting in a purely relational way. 5. By exploiting the algebraic laws of the aforementioned op-\nerators, we model and prove nontrivial rewriting properties. For instance, we prove confluence of orthogonal systems by giving relational generalisation of the so-called parallel moves [18] and Tait and Martin-L\u00f6f [36]\u2013[38] techniques. 1) The Augmented Calculus of Relations: By extending the categorical constructions defining syntax to allegories, we\nobtain a rich and novel relational vocabulary that allows us to define many rewriting notions in an allegorical setting. Even if such a vocabulary is obtained throughout a relational analysis of (the mathematics of) syntax, it turns out that all that matters for our purposes is the collection of new operators given by such an analysis, together with the (algebraic) laws governing their (operational) behaviour. At this point, the abstraction step is natural: we can forget about the syntax structure (and its relational counterpart) and work in a completely axiomatic fashion within a calculus of relations [39]\u2013[41] augmented with the aforementioned operators and their laws. Much in the same way as the ordinary calculus of relations provide an elegant framework for the study of abstract reduction systems, the aforementioned augmented calculus of relations provide a similar framework for the study of (several kinds of) syntaxbased reduction systems in a rather syntax-independent way.\n2) A Bridge Between Rewriting and Program Equivalence: Perhaps surprisingly, this augmented calculus of relations is not entirely new: it can be seen as a (nontrivial) generalisation of the calculus of \u03bb-term relations developed by Lassen [42], [43] in the context of higher-order program equivalence. This way, we obtain a novel connection between rewriting and program equivalence. A first (and surprising) consequence of that is the observation that the construction of the socalled multi-step reduction [36]\u2013[38] as used in the Tait and Martin-L\u00f6f confluence technique coincides with Howe\u2019s construction [44], [45] of the pre-congruence candidate, the key notion in the (operational) proof of congruence of applicative bisimilarity [46]. This connection not only allows us to import results and techniques from the field of program equivalence to rewriting (as we shall do in this work), but also sheds new light on operational notions (for instance, we will see that the aforementioned Howe\u2019s construction is obtained via initial relational algebras)."
        },
        {
            "heading": "B. Related Work",
            "text": "Looking at the literature on rewriting, it is quite natural to classify theories and results according to three distinct schools of thought [47] reflecting mainstream divisions in program semantics: operational [15], [16], logical [48], and denotational [20]\u2013[28]. There is, however, a fourth, albeit less known, school of thought, namely the relational one.\nThe first observation of the relevance of relational reasoning in rewriting is due to B\u00e4umer [49] and since then several relational calculi (and alike) have been employed to study abstract reduction systems. Among the many results achieved in this line of research, we mention relational proofs of Church-Rosser theorem [50], of Newman\u2019s Lemma [51], [52], and modularity theorems for termination [51], [53]. Relational rewriting has been also extended to non-traditional notions of relations, such as monadic relations [54] and fuzzy and quantitative relations [55]\u2013[58]. To the best of the author\u2019s knowledge, the literature offers no relational analysis of syntax-based systems. Finally, we mention the axiomatic approach to rewriting [59]\u2013[64] which, even if non-relational, is close in spirit to the present work."
        },
        {
            "heading": "II. PROLOGUE: (TERM) REWRITING WITHOUT SYNTAX",
            "text": "Before moving to the general theory of rewriting, we gently introduce the reader to some of the main ideas behind this work by studying a simple, yet instructive example: term rewriting. In their broadest sense, term rewriting systems [15]\u2013 [17] (TRSs) specify how first-order terms can be syntactically manipulated. Given a signature \u03a3, i.e. a set containing operation symbols o and their arity, and a set X of variables, recall that the set T (X) of (\u03a3-)terms is inductively defined thus:\nx \u2208 X x \u2208 T (X)\nt1 \u2208 T (X) \u00b7 \u00b7 \u00b7tn \u2208 T (X) (o,n) \u2208 \u03a3\no(t1, . . . , tn) \u2208 T (X)\nA TRS is then given by a binary relation 7\u2192 on T (X). We refer to relations such as 7\u2192 as reduction relations.\nViewed that way, there is no conceptual difference between TRSs and ARSs, the latter being sets endowed with a binary endorelation. It takes only a few seconds, however, to realise that the relation 7\u2192 alone is of little interest, as it says nothing on how to instantiate 7\u2192 on arbitrarily complex expressions, nor on how to propagate it along their structures. For instance, consider the following relation modelling natural number addition: add(0, y) 7\u2192 y, add(succ(x), y) 7\u2192 succ(add(x, y)). Relying on 7\u2192 only, there is no way to reduce, e.g., the term succ(add(0, 0)) to succ(0), as the former is not a redex,3 although it contains a substitution instance of one.\nConsequently, to obtain useful notions of reduction on \u03a3terms we need (i) to consider substitution instances of 7\u2192 and (ii) to specify how such instances can be propagated along term syntax. The first point is handled by working with the substitution closure _ of 7\u2192, whereby we consider (substitution) instances of 7\u2192.4 For the second point, there are many possible natural extensions of _, depending on the notion of reduction one has in mind. For example: \u2022 Sequential reduction is the relation \u2192 that _-reduces exactly one redex at a time. \u2022 Parallel reduction is the relation \u21d2 that _-reduces an arbitrary number of non-nested redexes in parallel. \u2022 Full reduction is the relation \u21db that _-reduces an arbitrary number of possibly nested redexes in parallel.\nA formal definition of all these notions requires to first introduce several specific syntactic notions on terms, such as positions, occurrences, contexts, etc. Sequential reduction, for example, is defined by stipulating that C[t]p \u2192 C[s]p holds if and only if t _ s does, where p is a position and C[\u2212]p is a context with one hole at position p. As a main consequence of that, TRSs become intrinsically term-dependent, this way loosing the relational understanding of reduction given by ARSs. The shift from reduction relations per se to the syntactic structure of the objects reduced massively impacts the way one reasons about TRSs, with relational reasoning leaving the place to syntactic arguments on terms. Such arguments have several well-known drawbacks: they are error-prone, difficult to formalise, and, most importantly, they lack modularity.\n3Recall that a redex is a term that can be 7\u2192-reduced. 4Formally, we have t[v\u0304/x\u0304] _ s[v\u0304/x\u0304] whenever t 7\u2192 s.\nSmall changes in the syntactic structure of terms require to (re)develop the underlying rewriting theory from scratch.\n1) Term Rewriting, Syntactically Relationally: The just described scenario shows a conceptual gap between abstract and term (and, more generally, syntax-based) rewriting systems. This gap, however, is by no means substantial and it is possible to develop a fully relational theory of TRSs, as we shall show in this paper.\nFirst, we observe that parallel and full reduction can obtained by means of suitable relational constructions applied on _.5 For instance, the following relational construction, known as compatible refinement [42], [65], defines relations a\u0302 between terms with the same outermost syntactic constructs and argumentiwse a-related terms.\nx \u2208 X x a\u0302 x\nt1 a\u0302 s1 \u00b7 \u00b7 \u00b7 tn a\u0302 sn o(t1, . . . , tn) a\u0302 o(s1, . . . , sn)\nUsing compatible refinement, we obtain a relational (inductive) definition of \u21d2 as \u00b5x._\u2228 x\u0302. This change of perspective is not just a way to give more compact definitions. Having separated the definition of \u21d2 from the (simplest) one of \u2212\u0302, it is natural to focus on the algebraic properties of the latter, rather than on the syntax of terms. For instance, it is easy to prove that \u2212\u0302 is functorial (it preserves relation composition and the identity relation) and (\u03c9-)continuous: this way, not only the aforementioned relational definition of \u21d2 is wellgiven, but it also allows us to reason about parallel reduction using algebraic calculations and fixed point induction [66].\nMoreover, we can use algebraic and relational reasoning to prove rewriting properties of\u21d2. As an example, in section VII we shall prove the diamond property of \u21d2 for orthogonal systems [17] by showing the following Kleisli-like extension lemma (here properly instantiated to \u21d2) akin to a semiconfluence proof technique: ^;\u21d2 \u2286 \u21d2;\u21d0 implies \u21d0;\u21d2 \u2286 \u21d2;\u21d0. We will prove such a result relying on algebraic laws only, and then show that the inclusion in the aforementioned extension lemma holds for a large class of (relationallydefined) reduction systems (i.e. orthogonal systems) using the same methodology. All of that is done relationally by decomposing _ throughout a further relational construction, viz. relation substitution [42], and its algebraic laws. The reader familiar with TRSs can see such a result as a generalisation of the well-known parallel moves technique [18].\n2) Hello Syntax, My Old Friend: The discussion made so far hints that a relational analysis of TRSs is possible by introducing suitable relational operators describing, at an algebraic level, how syntax act on reductions. This makes the operational analysis of TRSs indeed closer to the corresponding one of ARSs: for the former one simply needs a more powerful calculus of relations than the one needed for ARSs (we shall come back to this point later). All of that significantly improves reasoning, but does not overcome syntax-dependency: the definition of the new relational constructions, such as \u2212\u0302, still relies on the syntax at hand.\n5The same can be said about sequential reduction too, although we leave its formal analysis for future work (see section X).\nTo make the relational framework truly general, we notice that the actual syntax of term is not really needed for our purposes. In fact, it is well-known that notions of syntax can be modelled as free algebras (and their associated monads) over suitable signature functors [1]. In the case of first-order terms, any signature \u03a3 induces a (signature) functor \u03a3 on the category Set of sets and functors. Such a functor acts as syntax specification and induces a functor S that, given a set X , returns the set of \u03a3-terms over X . The functor S is the carrier of a monad (S, \u03b7, \u03c1), which is the free monad over \u03a3, in the sense that the structure X \u03b7 \u2212\u2192 SX \u03c3 \u2190\u2212 \u03a3(SX) gives the free \u03a3-algebra over X . The map \u03b7 acts as the variable constructor mapping x to x, whereas the map \u03c3 describe the inductive step in the definition of \u03a3-terms, whereby terms are closed under operation symbols; the multiplication \u03c1, finally, flattens a \u2018term of terms\u2019 into a term, and it is de facto recursively defined relying on \u03b7 and \u03c3. The key observation now is to notice that these data acting on sets (of terms) are precisely what is needed to define (the relational operators behind) reduction relations, provided that we can extend their action from functions to relations, hence to the category Rel of sets and relations. For instance, given a relation a on SX , we recover a\u0302 as \u03b7\u25e6; \u03b7 \u2228 \u03c3\u25e6; \u03a3a;\u03c3 where, for a relation6 a : A +\u2192 B, we denote by a\u25e6 : B +\u2192 A the converse of a and by \u03a3 the relational extension of \u03a3, namely a functor-like mapping a to \u03a3a : \u03a3A +\u2192 \u03a3B (of course, we have to check that using \u03a3 we indeed recover a\u0302, but we will see that this is the case; even more, this is canonically the case).\nThe question now is: how can we define \u03a3? Luckily, the answer has been given long ago, and we can now rely on a mature theory of relational extensions of set-constructions [67]\u2013 [69]. In particular, by a celebrated result by Barr [32], \u03a3 extends to a converse-preserving monotone functor \u03a3 on Rel . Moreover, \u03a3 \u2013 which is usually generically referred to as the Barr extension of \u03a3 \u2013 is unique and it furthermore induces a converse-preserving monotone functor S which, as suggested by the notation, is the Barr extension of S.\nConverse-preserving monotone functors are known as relator [33], [70], [71] and there is a rich theory both on relators and on how to extend functors to relators. We view relators as describing how (reduction) relations are propagated along the syntactic structure given by the underlying functor. For instance, \u03a3 indeed defines \u2212\u0302 as sketched above. Moreover, looking at SX monadically, we can use S to obtain a further decomposition of \u21d2 as \u03c1\u25e6;S(_); \u03c1. From a syntactic perspective, this definition corresponds to the \u2018context-based\u2019 definition of parallel reduction, where using relators we can talk about contexts in a syntax-free way. Finally, we can show that the two definitions of parallel reduction hereby sketched indeed coincide.\n3) From Algebra to Program Equivalence: This (informal) analysis shows that parallel reduction can be fully understood relationally; moreover, the role played by relators (and by Barr\n6We use the notation a : A +\u2192 B in place of a \u2286 A\u00d7B.\nextensions, in particular) hints that parallel reduction is the canonical notion of reduction induced by the syntax. Is that really the case? And what about other notions of reduction?\nThe answer to the first question is in the affirmative, at least as long as we think about S as a monad. At the same time, however, parallel reduction is not the only canonical notion of reduction induced by the syntax. In fact, SX being free, the theory of initial algebra tells us that we can equivalently described it as the initial algebra of the (Set) functor X + \u03a3(\u2212), so that we can think about syntax also as an initial algebra.\nHow is that relevant for rewriting? The so-called EilenbergWright Lemma [34] states that an initial algebra in Set is such also in Rel . In particular, whenever we have a relation a : X + \u03a3A +\u2192 A, then initiality gives a unique relation LaM : SX +\u2192 A such that7 [\u03b7,\u03c3]; LaM = \u03a3LaM; a. Thinking about a as a reduction, then LaM recursively a-reduces along the syntactic structure of terms.\nMoving from this intuition, we discover that \u21db is precisely L[\u03b7,\u03c3];_M. But this is not the end of the story. In fact, even if this initial algebra-based definition of \u21db goes \u2018beyond\u2019 the relational operators used to define (the least fixed point characterisation of) parallel reduction, we can give an inductive characterisation of \u21db using that vocabulary, viz. as \u00b5x.x\u0302;_. This should ring a bell to the reader familiar with program equivalence: in fact, relations of the form \u00b5x.x\u0302; a are not new, as they are precisely the so-called pre-congruence candidates (on a) used in the well-known Howe\u2019s technique [44], [45] to prove congruence of applicative bisimilarity [46]. As for parallel reduction, this relational machinery is powerful enough also to prove interesting rewriting properties of \u21db. We will witness that by giving a fully relational generalisation of the so-called Tait-Martin-L\u00f6f technique [36]\u2013[38].\n4) Beyond TRSs: The discussion conducted so far hints that the theory of TRSs can be given within a relational framework. This observation builds upon three crucial points: (i) the syntax of first-order expressions can be modelled categorically on Set ; (ii) the latter category has a rich category of relations, viz. Rel , that models symbolic manipulations of first-order expressions; (iii) the categorical notions modelling syntax can be extended to Rel , and such notions are precisely what is needed to define reduction relations and to prove theorems about them ((iv) as a bonus point that we will discuss later, we notice that such extensions allow us to extend the rich calculus of relations given by Rel with suitable operators, this way giving a kind of extended calculus of relations within which rewriting theories can be expressed).\nThe realm of symbolic expressions, however, is far richer than first-order terms: there are expressions with names and binders [2], [7], sorted and typed expressions, diagrams and two-dimensional expressions [73], etc. All these expressions come with suitable notions of symbolic manipulation between them (e.g. higher-order rewriting [15], [18], nominal rewriting [19], diagrammatic rewriting [74]\u2013[77], etc.), and\n7By Lambek Lemma [72], we have [\u03b7,\u03c3] : X + \u03a3(SX) \u223c= SX .\nto qualify as a general theory of symbolic manipulation, the relational theory we are going to develop has to account for all these examples.\nTo achieve this goal, we notice that the aforementioned key points are not at all specific to Set , Rel , and first-order terms. All the expressions mentioned so far can be understood in terms of initial algebras and free monads, provided that one moves to categories other than Set . For instance, expressions with binders are modelled on variable (i.e. presheaves) [7] and nominal sets [2], [3], whereas diagrammatic expressions rely on categories of spans [74].\nThis allows us to recover point (i) above. If we recover points (ii) and (iii) too, then we can give relational theories of symbolic manipulation for all the classes of symbolic expressions at issue. This is indeed the case, as each category E mentioned so far induces a rich category of relations Rel(E) over it together with extensions of syntax functors and monads on E to Rel(E). The last step we need to take to achieve a truly general theory is to crystallise the above procedure by means of a suitable axiomatics that captures the essential structure E and Rel (E) need to have. We will achieve that goal by taking a non-minimal yet effective axiomatisation whereby E is a Grothendieck topos [30]. In fact, any Grothendieck topos E induces a category of relations Rel(E) that has the structure of a locally complete power allegory [29], [31]. The latter allegories provide a powerful and highly expressive calculus of relations that allows us to develop a general theory of rewriting in a remarkably clear and elegant way. Although slogans should be avoided, the allegorical theory of rewriting we develop in this paper and its deep connection with the mathematical theory of syntax, seem to suggest that syntax is categorical, and syntax manipulation is allegorical.\n5) An Axiomatic Approach: Let us summarise what we have achieved so far. Looking at syntax as a categorical construction and considering its relational extension, we have recovered notions of reduction in fully relational ways. This process can be organised into two complementary approaches, both of which define notions of reduction and prove properties about them. The first approach proceeds in an algebraic fashion by enriching traditional relational calculi with suitable operators on relations (compatible refinement, relation substitution, etc.) and relying on their algebraic laws to prove rewriting properties. The second approach, instead, is structural and builds upon the relationally extended categorical properties of syntax to give definitions of reduction, relying on their universality to prove rewriting properties.\nA natural further abstraction step is to make the first approach completely axiomatic. That is, rather than building upon signature functors, relators, etc. to build relational operators, we simply add them (as well as their algebraic laws) to the traditional calculus of relations (or variations thereof) [39]\u2013 [41] in an axiomatic fashion. We can then develop theory of rewriting systems within such an augmented calculus of relations, this way giving a truly relational foundation to rewriting. The structural approach previously mentioned can then be seen as a way to build models of such a calculus. This\naxiomatic approach have several advantages: for instance, it allows us to establish novel and deep connections between rewriting and program equivalence, and opens the door to enhance proof formalisation of rewriting theories.8\nNow that the reader has familiarised with the spirit of this\nwork, we move to its formal development."
        },
        {
            "heading": "III. MATHEMATICAL PRELIMINARIES",
            "text": "Before going any further, we recall some preliminary notions. We assume the reader is familiar with basic category theory [79]. We will use standard notation except for: composition of arrows is in diagrammatic order (f ; g) and identity is denoted as \u2206 (relational notation).\n1) Initial Algebras: Given a category C and a functor \u03a3 : C \u2192 C on it, a \u03a3-algebra consists of an object A (the carrier) and an arrow \u03b1 : \u03a3A \u2192 A (the algebra map). Such algebras are the objects of a category, \u03a3-Alg , whose arrows f : (A,\u03b1) \u2192 (B,\u03b2) are C-arrows f : A \u2192 B such that \u03b1; f = \u03a3f ;\u03b2. The initial algebra of \u03a3, if it exists, is the initial object in \u03a3-Alg . Explicitly, it is a \u03a3-algebra (\u00b5\u03a3, \u03be) such that for any \u03a3-algebra (A,\u03b1), there exists a unique \u03a3-Alg-arrow L\u03b1M : \u00b5\u03a3 \u2192 A. We denote the carrier of the initial algebra \u03a3 by \u00b5\u03a3 (or \u00b5x.\u03a3x) and refer to arrows L\u03b1M as catamorphisms. Being initial objects, initial algebras are unique up-to isomorphism. Moreover, the well-known Lambek Lemma [72] states that \u03be has an inverse and thus \u00b5\u03a3 \u223c= \u03a3(\u00b5\u03a3). Initial algebras need not exist, in general. The following result [80] gives a sufficient condition on functors that guarantees existence of initial algebras.\nTheorem 1 ( [80]). Let C be a category with initial object 0 and let \u03a3 be a finitary endofunctor on it, i.e. \u03a3 preserves \u03c9-colimits Then \u00b5\u03a3 exists and coincides with colimit of the chain 0 ! \u2212\u2192 \u03a30 \u03a3! \u2212\u2192 \u03a320 \u03a32! \u2212\u2212\u2192 \u00b7 \u00b7 \u00b7\u03a3n0 \u03a3n! \u2212\u2212\u2192 \u00b7 \u00b7 \u00b7 .\n2) Monads: Recall that a monad on a category C is a triple (R, \u03b7, \u03c1) consisting of a functor R : C \u2192 C and natural transformations \u03b7A : A \u2192 RA, \u03c1A : RRA \u2192 RA satisfying suitable coherence conditions [79]. To avoid unnecessary proliferation of notation, we denote by R both the monad (R, \u03b7, \u03c1) and its carrier functor, provided that does not create confusion.\nWhen a functor \u03a3 as above has initial algebra (and C has enough structure), it induces a monad S, called the free monad over \u03a3. Let us assume that C has finite coproducts and that for any object A the initial algebra of the functor A + \u03a3(\u2212) exists, which it does whenever the one of \u03a3 does. Then, the assignment SA , \u00b5x.A+\u03a3x determines a monad, called the (algebraically) free monad generated by \u03a3 [79]. The initial algebra map \u03be : A + \u03a3SA \u2192 SA can be decomposed as [\u03b7,\u03c3], with \u03b7 : A \u2192 SA and \u03c3 : \u03a3SA \u2192 SA. Both \u03b7 and \u03c3 are mono, provided that coproducts injections are monos in C, a condition satisfied by any topos. The arrow \u03b7 gives the\n8Relational calculi turned out to be well-suited for proof formalisation [40], [78], with remarkable example of that in rewriting being given by the proof of Newman\u2019s Lemma [51], [78].\nunit of S, whereas the multiplication \u03c1 is defined by initiality as L[\u2206,\u03c3]M."
        },
        {
            "heading": "IV. OUTLINE OF A CATEGORICAL THEORY OF SYNTAX",
            "text": "Having recalled the notions of initial algebra and free monad, in this section we succinctly summarise how these notions can be instantiated to give a mathematical theory of syntax [1]\u2013[13]. Although different authors propose different approaches to (different aspects of) abstract syntax, all such approaches can (perhaps) be understood in the following conceptual framework (see figure 1).\n1. A category (the universe of expressions) E capturing the kind of expressions one is interested in is fixed. 2. Syntax specification is given by a (signature) functor \u03a3 : E \u2192 E , usually polynomial, that specifies how expressions can be combined 3. The actual syntax of the language is given by the free\nmonad S generated by \u03a3. Obviously, the above schema does work only for suitable categories and functors which, in turn, may depend on specific features the framework aims to describe. In what follows, we discuss each point in detail and explicitly state the axioms of our propaedeutic theory of syntax (upon which we shall develop the theory of symbolic maniopulations).\n1) Universe of Expressions: Beginning with point 1, i.e. the universe of expressions E , we have already observed that formal expressions come in several flavours (first-order, higher-order, typed, two-dimensional, etc.) and that each of these alternatives corresponds to a specific category (sets, presheaves, nominal sets, spans, hypergraphs, etc.). The purpose of the category E is precisely to formally specify the nature of expressions. As the examples mentioned so far share the same structure: the category E is a topos; even more, it is a Grothendieck topos [30]. In light of that, we formulate the first axiom of our theory.\nAssumption 1. The universe E is a Grothendieck topos.\nAssumption 1 is by no means minimal and we could weaken it in many ways (e.g. working with elementary toposes with countable colimits, or even weaker structure) The advantage of Assumption 1 is that (i) it covers many interesting examples without requiring the introduction of ad hoc definitions; (ii) E supports an expressive calculus of relations upon which we shall build a general theory of symbolic manipulation.\n2) Syntax Specification: The signature functor \u03a3 : E \u2192 E specifies how expressions can be articulated, i.e. combined together to form new expressions. We require that \u03a3 captures a crucial features of the kind of syntax we are interested in: syntax is finitary and recursively defined9. By Theorem 1, this means that \u03a3 must be finitary. Additionally, we need to be able to manipulate expressions along their syntactic structures so that, for instance, we can apply a syntactic transformation on parts of an expression.\n9We leave the investigation of infinitary syntax to future work.\nAssumption 2. The signature functor \u03a3 : E \u2192 E : (i) nearly preserves pullbacks (pbs); (ii) preserves strong epimorphisms; (iii) is finitary.\nConditions (i) and (ii), which we shall discuss in detail in the next section, ensure that \u03a3 comes with a well-behaved notion of \u201csymbol pushing\u201d, the latter being obtained via relational extensions of \u03a3. Such conditions, due to Carboni et al. [33], are rather weak: condition (i) is implied by weak pbs preservation, which is in turn implied by pbs preservation; condition (ii), instead, is equivalent to regular epimorphisms preservation [29], which is itself implied by epimorphisms preservation. In Set , the presence of the axiom of choice ensures that any functor preserves epimorphisms, but this is not the case in arbitrary topoi. Nonetheless, one can show that in any topos E simple polynomial functors preserve epimorphisms.\n3) Syntax: Having axioms on E and \u03a3, there is not much to say about S. It simply acts as the actual syntax of the language which, given an object A representing some collection of basic expressions, builds full expressions by recursively combining previously defined expressions according to \u03a3. Indeed, since E has coproducts, if S exists it maps an object A to \u00b5xA+\u03a3x. Assumption 2 ensures such an initial algebra to exist and, additionally, to be obtained by Theorem 1, since S is finitary whenever \u03a3 is. This precisely captures our assumption that syntax is finitary. Clearly, S should also have a relational extension, and thus we may ask whether additional requirements have to imposed on S. The answer is in the negative, for S has a relational extension if \u03a3 has, as we shall see in next sections."
        },
        {
            "heading": "A. Examples",
            "text": "We conclude this section by looking at some examples of how specific notions of abstract syntax are captured by the general categorical framework.\nExample 1. Before moving to concrete examples, we observe that a large family of instances of the theory of syntax is obtained throughout simple polynomial functors. Recall that a functor on a topos E is a simple polynomial functor [81] if it is built from the identity and constant functors using composition, finite products, and set-indexed coproducts.10 Simple polynomial functors (and suitable extensions thereof) can be thought as abstract notions of syntax (specification) [8].\nExample 2 (First-Order Terms). We have already seen in section II that a first-order signature \u03a3 induces a (simple polynomial) functor \u03a3 on Set , and that S gives the syntax of \u03a3-terms.\n10More generally, given an arrow f : B \u2192 A in E , the polynomial functor Pf : E \u2192 E induced by f is defined as Pf (X) = \u2211 a:A X\nB(a) , where the latter expression is written using the internal language of E (equivalently, let us consider the adjoint functors on the slice category \u2211 B \u22a3 f \u2217 \u22a3 \u220f\nB with\u2211 B , \u220f B : E/B \u2192 E/A and f\n\u2217 : E/A \u2192 E/B; writing B\u2217 : E \u2192 E/B for the functor obtained taking A = 1 (and thus f : B \u2192 1), we have Pf = B \u2217; \u220f f ; \u2211 f ).\nExample 3 (Higher-Order Terms: the \u03bb-calculus). We now go beyond first-order syntax and introduce variable binding. For the sake of exposition, instead of defining binding signatures and terms in full generality (something that can be easily done [7]), we focus on a single example of such syntax: terms of the \u03bb-calculus modulo \u03b1-conversion [82]. Following the seminal work by Fiore et al. [7], the key insight to model terms with binders is to move from Set to categories of expressions in context. Let N be the category of finite cardinals, i.e. the full subcategory of Set with objects sets n , {0, . . . ,n\u2212 1}. We think of sets n as (indexes of variables of) finite contexts and of a function f : n \u2192 m as a context renaming. Accordingly, we consider the presheaf category SetN of sets (of expressions) in context. Fixed a countable collection of variables x0, x1, . . ., the presheaf \u039b of \u03bb-terms maps n to the set \u039b(n) of \u03bb-terms modulo (\u03b1-)renaming with free variables in {x0, . . . , xn\u22121}. An inductive definition of \u039b is given thus:\ni \u2208 n xi \u2208 \u039b(n)\nt \u2208 \u039b(n+ 1)\n\u03bbxn+1.t \u2208 \u039b(n)\nt \u2208 \u039b(n) s \u2208 \u039b(n)\nt s \u2208 \u039b(n)\nAs it is customary [45], we oftentimes write n \u22a2 t (or x\u0304 \u22a2 t, tacitly assuming x\u0304 = x0, . . . , xn\u22121) in place of t \u2208 \u039b(n). Let us consider the signature functor \u03a3X , \u03b4X+(X\u00d7X), where \u03b4X(n) , X(n+ 1), and let us write V for the presheaf of variables mapping n to x0, . . . , xn\u22121. Then the free monad S over \u03a3 maps V to the presheaf SV \u223c= V +\u03b4(SV )+(SV \u00d7SV ) of \u03bb-terms modulo \u03b1-renaming. The functor \u03b4 is finitary polynomial) [7], [8] and satisfies the conditions of Assumption 2), so that the whole functor \u03a3 does. In light of that, we can extend the class of simple polynomial functors by including \u03b4 without altering the \u2018good\u2019 properties of simple polynomial functors. The resulting class is sometimes referred to as che class of binding functors [83].\nExample 4 (Nominal Sets). An alternative universe for modelling expressions with variable binding and names is given by the category Nom of nominal sets [2], [3]. Due to space constraints, we will not give details about that but simply remark that Nom is a Grothendieck topos (it is isomorphic to the Schanuel topos [2]), and that syntax for expressions with names and binders can be given as free monads over a mild variation of the binding functors defined in the previous example.\nExample 5 (Further Examples). More generally, presheaf categories of the form SetC op\n, with C small, can be used to model many universes of expressions, and several notions\nof syntax have been given as initial algebras of suitable functors on them. Examples include sorted expressions [84], simply [8] and polymorphically-typed expressions [9], [10], graphs and hypergraphs, and diagrams [73]. For instance, Bonchi et al. [74] model string diagram as initial algebra of polynomial-like functors in the category of spans N\u2190 S \u2192 N in Set (arrows are are span morphisms).Notice that such a category is isomorphic to SetN\u00d7N, where N\u00d7N is the discrete category with objects pairs of natural numbers."
        },
        {
            "heading": "B. Substitution",
            "text": "In addition to the aforementioned crucial features of mathematical syntax (e.g. recursive term formation, structural induction, etc.), there is another major syntactic-like structure that characterise (many notions of) symbolic syntax: substitution. Whereas there is a general consensus on the initial algebra approach to term-formation, several axiomatics for substitution have been proposed \u2014 such as monoids on monoidal categories [7], [9], substitution algebras and (heterogeneous) structure [7], [85], monads with pointed strength [86], modules [87]\u2013[90], and monads on nominal sets [2], [3], just to mention but a few \u2014 and a general consensus on them is arguably missing.\nNonetheless, all these approaches share a common trait; they all view substitution as a (structurally) recursively-defined syntax-preserving morphism. When dealing with first-order syntax (i.e. signature functors and their free algebras on Set ), a satisfactory account of substitution can be given in terms of monads only: being in Set , it is possible to internalise the monad structure of S, this way obtaining (monadic binding) maps \u03c2 : SX \u00d7 SXX \u2192 SX , natural in X , implementing substitution: given a term t and a substitution [s\u0304/x\u0304] viewed as a map from variables X to SX , the term \u03c2(t, [s\u0304/x\u0304]) \u2014 usually written as t[s\u0304/x\u0304] \u2014 represents the result of simultaneously substituting variables xi with si in t. Monad laws ensures desired equational properties of substitution: moreover, since any signature functor \u03a3 has a strength \u031f : \u03a3A\u00d7B \u2192 \u03a3(A\u00d7B), we recover substitution via (a suitable instance of) the unique arrow SA \u00d7 B \u2192 S(A \u00d7 B) extending \u031f [7]. This way, we obtain a structurally recursive definition of substitution.\nThe aforementioned view of substitution does not scale to to richer forms of syntax, such as syntax with variable binding. To overcome this problem, among the many structures defined, we rely on substitution algebras [7], namely objects A together with arrows \u03bd : 1\u2192 AV (generic new variable) and \u03c2 : A \u00d7 AV \u2192 A (substitution) subject to suitable coherence\nconditions. Here, V is a suitable object acting as an object of variables. Intuitively, the latter is any object ensuring the existence of maps for variable manipulation (like duplicating or swapping variables) that are necessary to express the aforementioned coherence conditions.11\nFixed such an object V , the (currying of the) map \u03b7 gives us a candidate map \u03bd; moreover, assuming \u03a3 to have strength \u031f : \u03a3(SV V ) \u00d7 SV \u2192 \u03a3(SV V \u00d7 SV ),12 we obtain the map \u03c2 by initiality. These maps are compatible with the \u03a3-algebra structure of SV , and thus give to \u03a3V the status of an initial \u03a3-substitution algebra [7].\nDefinition 1. 1. An object V of E is an object of variables if it comes with the maps given in [7, Definition 3.1].\n2. A substitution algebra is a triple (A, \u03bd, \u03c2) with A an object of E , and arrows \u03bd : 1 \u2192 AV and \u03c2 : A \u00d7 AV \u2192 A. We require these data to satisfy the compatibility conditions\nof [7, Definition 3.1].\n3. \u03a3-substitution algebras are \u03a3-algebras endowed with a compatible substitution algebra structure as in [7].\nFinally, we assume the signature functor \u03a3 to have the aforementioned (pointed) strength, this way ensuring (SV , [\u03b7,\u03c3], \u03bd, \u03c2) to be \u03a3-substitution algebra.\nRemark 1. Definition 1 is deliberately sloppy and there is no objective reason to rely on substitution algebras rather than on other structures. The reason behind all of that is twofold: on the one hand, this choice improves accessibility of the paper by making it digestible to the reader lacking the specific categorical background; on the other hand (and most importantly), once gone throughout the relational analysis of rewriting, the reader should be convinced that the chosen model of substitution is not operationally relevant: what matters is to have a notion of substitution inducing an operationally well-behaved relational substitution operator. By operationally well-behaved we mean a collection of algebraic laws giving an axiomatic definition of relational substitution. Such laws (Proposition 9 and Proposition 10) are all that matters for rewriting, up to the point that we could be completely agnostic with respect to the substitution structure used and simply assume to have one inducing such a relational operator. Substitution algebras do so, but the reader can easily check that many other structures (such as \u03a3-monoids) do that as well. As a general (albeit informal) principle, any structure modelling substitution as a recursively-defined syntax-preserving map gives raise to a well-behaved relational substitution operator (see Remark 4 and the end of section VI).\n11For instance, in the presheaf-based framework by Fiore et al. [7], such an object is given by the presheaf of variables, whereas in nominal sets it is given by the (nominal) sets of names. A more general analysis of objects of names is given by Menni [91].\n12This point is actually delicate: in fact, it turns out that crucial in this procedure is the fact that SV is pointed on V , meaning that we have an arrow V \u2192 SV . This observation led to the identification of monads with pointed strength as a way to internalise notions of substitutions [86]."
        },
        {
            "heading": "V. ALLEGORIES: THE THEORETICAL MINIMUM",
            "text": "Initial algebras and free monads provide an elegant mathematical description of (abstract) syntax. The kind of syntax we are interested in here is the one of symbolic expressions. The \u201cmathematics of syntax approach\u201d works perfectly for this kind of syntax (as witnessed by the many examples previously mentioned), but it does not capture its deep essence, that thing that makes symbolic syntax different from the syntax of, e.g., natural language. The peculiarity of symbolic expressions, in fact, does not rely in their syntax, but in their (operational) \u201csemantics\u201d: they can be manipulated symbolically (cf. section I: symbolic terms are encapsulated computations).\nIn this work, we move from the conceptual assumption that symbolic manipulation is an inherently relational notion. Such a conceptual point of view is remarkably powerful as it draws a path from syntax to semantics: to obtain the symbolic dynamics of expressions, we simply take the categorical theory of abstract syntax and extend it to a relational setting, in a precise sense that we are going to define. Any universe of expressions E , in fact, induces a category Rel(E) of relations describing manipulations between expressions. Rel(E) is an allegory [29] and thus we can rely on a rich relational framework to study it.\nSwitching from the categorical to the allegorical point of view one sees that many categorical notions have an allegorical counterpart, and that to define a relational theory of symbolic manipulation one precisely needs the allegorical extensions of the notions defining categorical syntax, namely free monads and initial algebras, as summarised in figure 1. We dedicate this section to study such extensions."
        },
        {
            "heading": "A. Allegories",
            "text": "Given a universe of expressions E , the category of its relations Rel(E) has objects of E as objects, whereas an arrow from A to B is a subobject a : A \u00d7 B \u2192 \u2126, where \u2126 is the subobject classifier of E . Subobjects of the form a : A \u00d7 B \u2192 \u2126 behave as relations from A to B: they have converse, compositions, union, etc. The precise sense in which they behave relationally has been defined through the notion of an allegory [29]. More precisely, Rel(E) is a locally-complete power allegory [29], [35].\nDefinition 2 ( [29]). An allegory A is a category such that each hom-set A(A,B) is endowed with: (i) a partial order \u2264 and a meet operation \u2227 making composition monotone; (ii) an order-preserving contravariant involution \u2212\u25e6 (so that a\u25e6\u25e6 = a, (a; b)\u25e6 = b\u25e6; a\u25e6, and (a \u2227 b)\u25e6 = a\u25e6 \u2227 b\u25e6). All these data, additionally, have to obey the so-called modular law: a; b \u2227 c \u2264 (a \u2227 c; b\u25e6); b.\nGiven an allegory A, we refer to its arrows as relations and we call the relation a\u25e6 : B \u2192 A the converse of a : A\u2192 B. As usual, we say that a relation a : A \u2192 A is reflexive, symmetric, and transitive if \u2206 \u2264 a, a\u25e6 \u2264 a, and a; a \u2264 a, respectively. Moreover, we say that a : A \u2192 B is entire if \u2206 \u2264 a; a\u25e6, simple if a\u25e6; a \u2264 \u2206, and that it is a map if it is entire and simple. The subcategory Map(A) of an allegory\nA is the category having objects of A as objects and maps of A as arrows.\nExample 6. Maps in Rel(E) are precisely arrows in E , so that Map(Rel (E)) \u2243 E . This means that instead of working with E as a primitive notion we may (and we will) take a truly relational perspective and work with (an axiomatisation) of Rel(E), this way thinking about E as the restriction of Rel(E) to functional relation.13 Theorem 2 generalises this correspondence to large classes of allegories and categories.\nRemark 2. To avoid ambiguities when working both with E and Rel (E), we use the notation f : A\u2192 B and a : A +\u2192 B for arrows in E and in Rel (E), respectively. We actually need this convention in this section only, since in the next one we will in a full allegorical framework.\nDefinition 3. Given an allegory A, we say that A is:\n1. Tabular if any relation a : A\u2192 B has a (necessary unique, up-to isomorphism) tabulation, i.e. maps f : R \u2192 A and g : R\u2192 B such that a = f\u25e6; g and f ; f\u25e6 \u2227 g; g\u25e6 = \u2206. 2. Unitary if it has a unit U , i.e. an object U such that: (i) \u2206 : U \u2192 U is the largest relation in A(U ,U); (ii) for any object A, there is an entire relation (which is necessarily a map) u : A\u2192 U . 3. Locally complete if it is unitary and tabular and, for\nall objects A, B, the set A(A,B) is a complete lattice with composition and finite intersection distributing over arbitrary joins.14 We denote by a \u2228 b the relation \u2228 {a, b} and by \u22a5 the relation \u2228 \u2205. 4. A locally complete power allegory (LCP allegory) if it is\nlocally complete and for any object A there is a power object PA such that: (i) to any relation a : A \u2192 B is associated a map \u039ba : A \u2192 PB; (ii) there are relations \u220bA: PA\u2192 A; (iii) such that f = \u039ba iff f ;\u220b= a.\nDefinition 3 is standard in the literature on allegory theory. From a categorical perspective, it can be motivated by the following result.\nTheorem 2 ( [29], [31]). For any Grothendieck topos E , its category of relations Rel(E) is a LCP allegory, and E \u2243 Map(Rel (E)). Vice versa, for any LCP allegory A, its subcategory of maps Map(A) is a Grothendieck topos, and A \u2243 Rel(Map(A)).\nConsequently, for a universe of expressions E , we see that Rel(E) is a LCP allegory.\nExample 7. Examples are, in principle, not needed (just construct Rel (E) for the examples of E seen in the previous section). Nonetheless, we mention:\n1. Rel(Set) is Rel . 2. Rel(SetN ) is the allegory of dependent relations closed\nunder context renaming and weakening. That is, a relation\n13Following this perspective, we think about a topos as a structure in which relations coincide with set-valued maps [92].\n14In particular, we have a; \u2228 i bi = \u2228 i a; bi and ( \u2228 i ai); b = \u2228 i ai; b.\na : A\u2192 B is an element a \u2208 \u220f\nn Rel(A(n),B(n)) such\nthat, for any \u03c6 : n\u2192m, we have: a(n);B\u03c6 \u2286 A\u03c6; a(m).\nA(n)\n\u2286\nA\u03c6 //\na(n)\nA(m)\na(m)\nB(n) B\u03c6 // B(m)\nNotice that considering the presheaf of \u03bb-terms, relations in Rel (F) are precisely the so-called term relations [42], [45], [93] used in relational reasoning on \u03bb-terms. Accordingly, we employ the notation x\u0304 \u22a2 t a s to state that x\u0304 \u22a2 t, s and t a(x\u0304) s. In particular, notice that we have the following weakening and renaming rule:\nx\u0304 \u22a2 t a s x\u0304, y\u0304 \u22a2 t a s\nx\u0304 \u22a2 t a s y\u0304 \u22a2 t[y\u0304/x\u0304] a s[y\u0304/x\u0304]\n3. Rel (Nom) is the allegory of equivariant relations [2]."
        },
        {
            "heading": "B. Relators",
            "text": "The construction of Rel(E) from E gives a relational counterpart of Assumption 1: we need a LCP allegory. To extend syntax and syntax specification, however, we need to understand what are the relational counterparts of initial algebras and free monads. The crucial notion to do that is the one of a relator [35], [68], [70], [71]15, the relational counterpart of functors.\nDefinition 4. A relator on an allegory A is a functor \u0393 : A \u2192 A that is monotone and preserves converse.\nIn particular, a relator \u0393 satisfies the law \u0393(a\u25e6) = (\u0393a)\u25e6, so that we can unambiguously write \u0393a\u25e6. It is easy to prove that \u0393f is a map, whenever f is. Moreover, since A is tabular, we see that a functor is a relator if and only if it preserves converse [35, Theorem 5.1].\nSince abstract syntax is specified by functors on E , we are interested in the following question: given a functor \u03a3 on E , can we extend it to a relator \u03a3 on Rel (E)?\nDefinition 5. A relational extension of a functor \u03a3 : E \u2192 E , is a relator \u03a3 on Rel(E) such that \u03a3A = \u03a3A and \u03a3f = \u03a3f , for any object A and map f .\nConsequently, we see that if a is tabulated as f\u25e6; g, then we must have \u03a3a = \u03a3(f\u25e6; g) = \u03a3f\u25e6; \u03a3g = (\u03a3f)\u25e6; \u03a3g. Therefore, a relational extension of \u03a3, if it exists, it must be unique and defined by \u03a3(f\u25e6; g) , (\u03a3f)\u25e6; \u03a3g (notice that this definition is independent of the choice of the tabulation). This means that for any \u03a3, we have a candidate relator \u03a3. Barr [32] and Carboni et al. [33] found conditions to answer the aforementioned question in the affirmative, this way ensuring that \u03a3 is indeed a relator.\n15Notions essentially equivalent to the one of a relator, such as relational extensions [32], relation lifting [81], [94], and lax extensions [67], [95] have been independently introduced in several fields.\nTheorem 3 ( [32], [33]). \u03a3 is a relator if and only if \u03a3 nearly preserves pullbacks and preserves strong epimorphisms. Moreover, \u03a3 is the only relational extension of \u03a3.\nTheorem 3 can also be seen from an allegorical perspective by stating that any relator \u0393 : A \u2192 A gives a functor \u0393 : Map(A) \u2192 Map(A) that nearly preserves pullbacks and preserves strong epimorphisms. It is worth noticing that if a functor preserves (weak) pullbacks, then it nearly preserves pullbacks and that strong and regular epimorphisms coincide in any topos (cf. Assumption 2).\nExample 8. 1. Since Set satisfies the axiom of choice, any\nfunctor on it preserves regular epimorphisms. Therefore,\nif \u03a3 nearly preserves pullbacks, then \u03a3 is a relator. 2. Simple polynomial functors all extend to relators [92]. The\nresulting class of relators is called the class of polynomial relators. Polynomial relators can be defined explicitly by means of (co)product (bi)relators, constant, and identity relator. [92] 3. The functor \u03b4 on SetN extends to a relator [7], [83], so that binding polynomial functors all extends to relators.\nSumming up, Assumption 1 entails that Rel (E) is a LCP allegory, whereas Assumption 2 implies that \u03a3 is a relator. The latter axiom, however, imposes a further condition on \u03a3 that is not needed to ensure that \u03a3 is a relator: \u03a3 must be finitary. How does that impact on \u03a3? Playing a bit with the definition of countable union in Rel(E) (which uses the coproduct relator [92]), we see that if \u03a3 is finitary, then \u03a3 is \u03c9-continuous, meaning that \u03a3( \u2228 n an) = \u2228 n \u03a3an, for any \u03c9-chain (an)n\u22650 of relations.\nProposition 1. If \u03a3 : E \u2192 E is finitary, then \u03a3 is \u03c9continuous.\nIn light of Proposition 1, we say that a relator on A is finitary if it is so as a functor on Map(A). Consequently, \u03a3\u0302 is finitary whenever \u03a3 is. What remains to do is to give a relational counterpart to S. Since (the carrier of) S is a functor, we can simply pick S as its relational extension. Of course, we have to ensure that S is a relator. That directly follows from the fact that \u03a3 is a relator.\nProposition 2 ( [35]). If \u03a3 is a relator, then so is S .\nExample 9. 1. Let \u03a3 be the functor given by a first-order signature \u03a3 on Set , so that S is the \u03a3-term monad. The relator S has the following inductive characterisation:\nx a y\nx Sa y\nt1 Sa s1 \u00b7 \u00b7 \u00b7 tn Sa sn\no(t1, . . . , tn) Sa o(s1, . . . , sn)\nEquivalently, we say that t Sa s if and only if there exists a context C such that t = C[x1, . . . , xn], s = C[y1, . . . , yn], and xi a yi, for any i. 2. A similar inductive characterisation can be given for, e.g.,\nthe monad of \u03bb-term on SetN .\n1) Relational Initial Algebras: At this point a question natural arises. The relationship between a functor \u03a3 on E and\nthe free monad S it generates is clear: the latter is essentially defined as the (unique) fixed point of a suitable construction on \u03a3 (Lambek Lemma). If, additionally, \u03a3 is finitary, then S is the fixed point of iterated application of (a construction on) \u03a3 (Theorem 1). Does something similar hold for \u03a3 and S? The answer is in the affirmative and a fixed point characterisation of S as a suitable fixed point can be elegantly given relying on two beautiful results: the already mentioned Eilenberg-Wright Lemma [34] and the Hylomorphism Theorem [35].\nTheorem 4 (Eilenber-Wright Lemma). Given a functor \u03a3 on a topos E with relational extension \u03a3, initial \u03a3-algebras in E coincide with initial \u03a3-algebras in Rel(E).\nConsequently, given an initial algebra \u03be : \u03a3(\u00b5\u03a3) \u2192 \u00b5\u03a3 (in E) and a relation a : \u03a3A +\u2192 A, there is a unique relation LaM : \u00b5\u03a3 +\u2192 A such that \u03be; LaM = \u03a3LaM; a.\nBefore stating the hylomorphism theorem, we recall that in LCP allegory A, by Knaster-Tarski Theorem [96], any monotone (set-theoretic) function of the form F : A(A,B)\u2192 A(A,B) has a least fixed point, denoted by \u00b5F (or \u00b5x.F ), which is the least of the pre-fixed points of F .\nTheorem 5 (Hylomorphism). Given a : \u03a3A \u2192 A and b : \u03a3B \u2192 B, we have LbM\u25e6; LaM = \u00b5x.b\u25e6; \u03a3x; a.\nTheorem 5 gives a powerful proof technique that we shall extensively use in subsequent sections. We conclude this section showing how Theorem 5 gives an inductive characterisation of S . To the best of the author\u2019s knowledge, this result, which is folklore on Set , is not present in the literature.\nProposition 3. Sa = \u00b5x.(\u03b7\u25e6; a; \u03b7) \u2228 (\u03c3\u25e6; \u03a3x;\u03c3).\nProof. Since [\u03b7,\u03c3]\u25e6; (a+\u03a3x); [\u03b7,\u03c3] = (\u03b7\u25e6; a; \u03b7)\u2228(\u03c3\u25e6; \u03a3x;\u03c3), it is enough to show Sa = \u00b5x.[\u03b7,\u03c3]\u25e6; (a + \u03a3x); [\u03b7,\u03c3]. Let us consider a tabulation A f \u2190\u2212 R g \u2212\u2192 B of a, so that a = f\u25e6; \u2206R; g and Sa = (Sf) \u25e6;Sg. Since Sf = L[f ; \u03b7,\u03c3]M (and similarly for g), we obtain, Sa = L[f ; \u03b7,\u03c3]M\u25e6; L[g; \u03b7,\u03c3]M and thus Sa = \u00b5x.[f ; \u03b7,\u03c3]\u25e6; (\u2206R + \u03a3x); [g; \u03b7,\u03c3], by Theorem 5 and the definition of Barr extension of coproduct and constant functors. We then obtain the desired thesis thus:\nSa = L[f ; \u03b7,\u03c3]M\u25e6; L[g; \u03b7,\u03c3]M\n= \u00b5x.[f ; \u03b7,\u03c3]\u25e6; (\u2206R +\u03a3x); [g; \u03b7,\u03c3] = \u00b5x.(\u03b7\u25e6; f\u25e6; \u2206R; g; \u03b7) \u2228 (\u03c3 \u25e6; \u03a3x;\u03c3) = \u00b5x.(\u03b7\u25e6; a; \u03b7) \u2228 (\u03c3\u25e6; \u03a3x;\u03c3)"
        },
        {
            "heading": "C. On Fixed Points and Induction",
            "text": "Before moving to the main subject of this work, namely the allegorical theory of symbolic manipulations, we exploit a few fixed point induction principles [66], [96] that we shall use in proofs of theorem about such a theory notions about fixed points. In the following, we tacitly assume that functions are of the form of the form F : A(A,B) \u2192 A(A,B). The first induction principle we state is the so-called fixed point\ninduction principle, which is an immediate consequence of Knaster-Tarski Theorem.\nProposition 4 (Fixed Point Induction). If F is monotone, then to prove \u00b5F \u2264 a, it is sufficient to prove F (a) \u2264 a.\nAlmost all the relational operators we will define in next sections are not just monotone, but \u03c9-continuous \u2014 recall that F is \u03c9-continuous if preserves joins of \u03c9-chains: F (\n\u2228 n xn) =\u2228\nn F (xn). By Kleene Fixed Point Theorem [96], if F is \u03c9continuous, then we can give an iterative characterisation of \u00b5F , namely: \u00b5F = \u2228\nn F n(\u22a5), where Fn is the n-th iteration\nof F . As for Knaster-Tarski, also Kleene Fixed Point Theorem comes with an associated induction principle, to which we refer to as \u03c9-continuous fixed point induction.16\nProposition 5 (\u03c9-Continuous Fixed Point Induction). If F is \u03c9-continuous, then to prove \u00b5F \u2264 a, it is sufficient to prove x \u2264 \u00b5F \u2227 a =\u21d2 F (x) \u2264 a, for any x.\nProof. Let us assume \u2200x. x \u2264 \u00b5F \u2227 a =\u21d2 F (x) \u2264 a (to which we refer to as the induction hypothesis). Since F is \u03c9continuous, proving \u00b5F \u2264 a means proving \u2228 n F\nn(\u22a5) \u2264 a. We proceed by induction on n. The base is trivial, since F 0(\u22a5) = \u22a5 \u2264 a. Assuming now F k(\u22a5) \u2264 a, we show F (F k(\u22a5)) \u2264 a. Since F k(\u22a5) \u2264 \u2228 n F\nn(\u22a5) = \u00b5F , from F k(\u22a5) \u2264 a we infer F k(\u22a5) \u2264 \u00b5F \u2227 a. We can thus use the induction hypothesis to conclude F (F k(\u22a5)) \u2264 a.\nFinally, we mention an enhancement of Proposition 5 whereby we can perform induction insider an \u03c9-continuous strict function (recall that F is strict if F (\u22a5) = \u22a5).\nProposition 6 (Enhanced \u03c9-Continuous Fixed Point Induction). Let F ,G be \u03c9-continuous functions. Assume also that G is strict. Then, to prove G(\u00b5F ) \u2264 a, it is sufficient to show that for any x such that x \u2264 \u00b5F and G(x) \u2264 a, we have G(F (x)) \u2264 x.\nProof. Let us assume G(x) \u2264 a implies G(F (x)) \u2264 x, for any x \u2264 \u00b5F . We call this implication the induction hypothesis. Proving G(F (x)) \u2264 a means proving G( \u2228 n F\nn(\u22a5)) \u2264 a, i.e.\u2228 n G(F\nn(\u22a5)) \u2264 a, since G is \u03c9-continuous. We proceed by induction on n. The base case amounts to prove G(\u22a5) \u2264 a, which holds since G is strict (hence G(\u22a5) = \u22a5). For the inductive, we assume G(F k(\u22a5)) \u2264 a and notice that we can appeal to the induction hypothesis, since F k(\u22a5) \u2264 \u00b5F .\nWe will use Proposition 6 for functions G of the form G(x) , a;x; b, for given relations a, b. Notice that G is indeed strict and \u03c9-continuous (this follows from distributivity of composition over join).\nFinally, we observe that using fixed points, we can easily generalise relational notions useful in rewriting to any LCP allegory. For instance, the reflexive and transitive closure a\u2217 of a : A\u2192 A is defined as \u00b5x.\u2206\u2228a;x. Moreover, any relator\n16Even if straightforward to prove, the author was unable to find the induction principle of Proposition 5 in the literature. For the sake of completeness, we thus give a proof of it.\nhas least fixed point, and on finitary ones we can apply \u03c9continuous fixed point induction principle just stated. Notice also that if \u0393 is finitary and f , g are maps, then f\u25e6; \u0393(\u2212); g is finitary too. This also entails that both \u03a3 and S are finitary whenever \u03a3 is."
        },
        {
            "heading": "VI. AN ALLEGORICAL THEORY OF SYMBOLIC MANIPULATIONS",
            "text": "We are now ready to put the allegorical machinery to work. In this section, we formalise the main contribution of the paper, this way beginning to develop an allegorical theory of symbolic manipulations. The main structure studied by such a theory is the one of an (abstract) expression system (E-system, for short),17 namely a triple (\u03a3,V , a) consisting of a signature functor \u03a3 : E \u2192 E , an object of variables V , and a (ground) reduction relation a : SV +\u2192 SV in Rel(E). As in concrete systems one assumes the collection variables and the signature to be disjoint, we assume \u03b7;\u03c3\u25e6 = \u22a5.\nExample 10. Standard examples of E-systems include TRSs (\u03a3,X , 7\u2192) on Set and higher-order rewriting systems [97] in presheaves. As a paradigmatic example of the latter, we consider the E-system of \u03bb-terms (\u03a3,V ,\u03b2), where \u03a3 is the signature of \u03bb-terms and ~x \u22a2 (\u03bbx.t)s \u03b2 t[s/x].\nRemark 3. To facilitate the development of the theory of Esystems, it is convenient to work within an allegorical setting right from the beginning. Consequently, instead of starting with a topos E and a signature functor \u03a3 (from which one constructs Rel(E) and \u03a3), from now on we assume to have fixed (i) a LCP allegory A and (ii) a finitary signature relator \u03a3 : A \u2192 A. Consequently, we think about E as Map(A) and as the signature functor as the relator \u03a3 on Map(A). This way we also obtain the syntax relator S which indeed gives the free monad over \u03a3 when restricted to Map(A). In light of that, we use the notation a : A\u2192 B for arrows (hence relations) in A, this way dropping the distinction between \u2192 and +\u2192 (but we still reserve letters f , g, . . . for maps in A). Finally, recall that by Theorem 4, [\u03b7,\u03c3] : V +\u03a3(SV )\u2192 SV is the initial (V +\u03a3(\u2212))-algebra in A.\nGiven an E-system (\u03a3,V , a), the relation a is meant to model ground reduction. Actual reduction relations shall be then obtained by extending a to account for the substitution structure of syntax \u2014 this way allowing to consider substitution instances of a \u2014 and by propagating reductions along the syntactic structure of terms. Both these (families of) operations, which are generally defined in a syntactic fashion, can be elegantly recovered in a purely relational fashion. In what follows, we introduce the powerful operations of relational substitution and compatible refinement [42], [65], [93] which will be crucial to define the aforementioned extensions of ground reduction.\n17For the sake of readaability, we depart from standard rewriting nomenclature and follow Aczel\u2019s terminology [37].\n1) Compatible Refinement: The compatible refinement of [65] relation a relates expressions that have the same outermost syntactic construct and a-related arguments, and thus plays a crucial role in the definition and analysis of many forms of (parallel) reduction.\nDefinition 6. Given an E-system (\u03a3,V , a), the compatible refinement of a is the relation a\u0302 : SV \u2192 SV defined as [\u03b7,\u03c3]\u25e6; (\u2206V +\u03a3a); [\u03b7,\u03c3]. Notice that a\u0302 = \u03b7 \u25e6; \u03b7 \u2228 \u03c3\u25e6; \u03a3a;\u03c3.\nSince a\u0302 = \u03b7\u25e6; \u03b7 \u2228 \u03c3\u25e6; \u03a3a;\u03c3, we can clean up the definition of \u2212\u0302 by defining the operator a\u0303 , \u03c3\u25e6; \u03a3a;\u03c3, hence recovering a\u0302 by joining a\u0303 with the relation I\u03b7 , \u03b7\n\u25e6; \u03b7 (viz. a\u0302 = I\u03b7 \u2228 a\u0303). The latter is a so-called coreflexive [29], [35], namely relation a such that a \u2264 \u2206, and it can be regarded as the property of being a variable (in Set , for instance, I\u03b7 states that a term is actually a variable). Moreover, since we assume that variables and signatures are disjoint \u2014 i.e. \u03b7;\u03c3\u25e6 = \u22a5 \u2014 we have a\u0303 \u2227 I\u03b7 = \u22a5, from which follows I\u03b7; a\u0303 = \u22a5 (= a\u0303; I\u03b7), since I\u03b7 \u2264 \u2206.\nProposition 7. Both \u2212\u0303 and \u2212\u0302 are \u03c9-continuous relators.\nWhen instantiated on a first-order system (\u03a3,X , 7\u2192), we see that a\u0302 is defined by the following rules:\nx \u2208 X x \u03027\u2192 x\nt1 7\u2192 s1 \u00b7 \u00b7 \u00b7 tn 7\u2192 sn o \u2208 \u03a3\no(t1, . . . , tn) \u03027\u2192 o(s1, . . . , sn)\nIf we consider the second rule only, we obtain \u02dc7\u2192. Having the notion of a compatible refinement, the natural next step is to define the notion of compatibility and the associated context closure operator.\nDefinition 7. 1. A relation a is compatible if a\u0302 \u2264 a. 2. The context closure of a is defined thus: aC , \u00b5x.a \u2228 x\u0302.\nContinuing the example of first-order systems (\u03a3,X , 7\u2192), we see that 7\u2192C is inductively defined as follows:\nt 7\u2192 s t 7\u2192C s x \u2208 X x 7\u2192C x\nt1 7\u2192C s1 \u00b7 \u00b7 \u00b7 tn 7\u2192C sn o \u2208 \u03a3\no(t1, . . . , tn) 7\u2192C o(s1, . . . , sn)\nIt is easy to see that \u2212C is monotone and idempotent, and that if a\u0302 \u2264 a, then aC = a. Since aC = a \u2228 a\u0302C, we observe that aC is compatible and extends a, and thus aC is the least compatible relation containing a. Moreover, as a\u0302 = \u03b7\u25e6; \u03b7 \u2228 \u03c3\u25e6; \u03a3a;\u03c3, we have that aC is reflexive on variables. Given the the inductive nature of aC, it is then natural to expect to have full reflexivity of aC. This is indeed the case (cf. binary induction principle [98]).\nProposition 8. The identity relation is the least compatible relation \u2014 i.e. \u2206 = \u00b5x.x\u0302 \u2014 and thus any compatible relation is reflexive.\nProof. We already know \u2206\u0302 \u2264 \u2206. We prove that it is the least such a relation. Given a compatible relation a, by initiality we have \u2206 = L[\u03b7,\u03c3]M, so that to prove \u2206 \u2264 a we can rely on Theorem 5 and prove \u03b7\u25e6; \u03b7\u2228\u03c3\u25e6; \u03a3a;\u03c3 \u2264 a, but this is nothing but a\u0302 \u2264 a.\n2) Relational Substitution: Having compatible refinement and context closure \u2014 hence ways to propagate reductions along syntactic constructs \u2014 we now need an operator extending substitution to (reduction) relations. For that, we rely on an extension of Lassen\u2019s relation substitution [42].\nDefinition 8. Given a substitution algebra A\u00d7AV \u03c2 \u2212\u2192 A \u03bd \u2190\u2212 V and relations a, b : A\u2192 A, we define the substitution of b into a as the relation a[b] : A\u2192 A defined by \u03c2\u25e6; (a\u00d7bV ); \u03c2 , where we recall that both \u00d7 and V \u2212 are the (bi)relator associated with the corresponding functor.\nWhen instantiated on, e.g., first- or second-order syntax, the relation a[b] relates all terms t[s\u0304/x\u0304], t\u2032[s\u0304\u2032/x\u0304] such that t, t\u2032 are related by a and si, s \u2032 i are related by b, for any i.\nProposition 9 ( [42], [99]). 1) \u2212[=] is a (bi-)relator. 2) \u2212[=] is \u03c9-continuous in the first argument. 3) \u2212[=] is associative: a[b][c] = a[b[c]].\nWhen it comes to calculate with \u2212[=], it is useful to notice that it has a right adjoint [42]: a[b] \u2264 x iff a \u2264 b\u00bbx. Explicitly, a\u00bbb = \u2228 {x | x[a] \u2264 b}. Notice that \u00bb is lax functorial (i.e. (a\u00bbb); (a\u2032\u00bbb\u2032) \u2264 (a; a\u2032)\u00bb(b; b\u2032)), antitone in the first argument, and monotone in the second one.\nDefinition 9. We say that a relation a is closed under substitution if a[\u2206] \u2264 a, and that it is substitutive if a[a] \u2264 a.\nIn particular, we think about a[\u2206] as the reduction obtained by taking substitution instances of a. For instance, in a TRS (\u03a3,X , 7\u2192), the relation _ seen in section II is precisely 7\u2192[\u2206]. Notice that since \u2212[=] is \u03c9-continuous in the first argument, the (unary) operator \u2212[\u2206] is \u03c9-continuous itself.\nAt this point we have introduced some new relational operators that compactly describe rewriting notions (as we shall better see in forthcoming sections). To make them really useful, we also have to provide algebraic laws for calculating with them.18\nProposition 10. We have the following laws [42], [99]:\n1) a\u0303[b] \u2264 a\u0303[b] 2) I\u03b7[b] \u2264 b 3) a\u0302[b] \u2264 a\u0302[b] \u2228 b.\nRemark 4. The algebraic laws in Proposition 10 and Proposition 9 constitute the operational definition of substitution at a relational level. Even if built upon a specific definition of substitution structure (viz. substitution algebra), what truly\n18Laws in Proposition 10 have been first proved by Lassen [42], and then extended by Levy [99], in the context of specific \u03bb-calculi. Our rule a\u0302[b] \u2264 a\u0302[b]\u2228b differs from Lassen\u2019s one \u2014 namely a\u0302[b] \u2264 a\u0302[b] \u2228 b \u2014 which seems wrong. For suppose x a\u0302 x and \u03bby.y b yy. Then, taking the two substitutions [\u03bby.y/x] and yy/x], we obtain \u03bby.y a\u0302[b] yy. The latter terms, however, cannot be related by the compatible refinement of any relation, as they are not variables and have different outermost syntactic constructs (viz. abstraction, for the first, and application, for the second). Notice that this inequality plays a crucial role in Lassen\u2019s proof of substitutivity of the Howe extension of a relation. Contrary to usual presentations of the same results, Lassen does not require the relation to be transitive, a condition which is instead needed if one reviews the proof using the correct inequality as stated in Proposition 10.\nmatters when it comes to (operational) reasoning and symbolic manipulation is to have an operator \u2212[=] obeying the aforementioned algebraic laws. For instance, \u03c9-continuity of \u2212[=] in the first argument says that substitution is defined by\nstructural recursion, whereas the rule a\u0303[b] \u2264 a\u0303[b] states that substitution behaves as a syntax-preserving morphism. The actual structure used to model substitution is irrelevant: any \u2018good\u2019 structure will induce a relational substitution operator satisfying the aforementioned laws. For instance, readers can convince themselves that replacing substitution algebras with, e.g., \u03a3-monoid, leads to essentially (i.e. operationally) the same operator \u2212[=]. Moreover, as soon as a \u2018substitution\u2019 operator satisfying Proposition 10 and Proposition 9 is available, one can study rewriting properties of substitution, regardless of the actual definition of the latter. This observation can be pushed even further by completely forgetting the actual syntax of a system and working axiomatically within an augmented calculus of relations, viz. a traditional calculus of relations enriched with operators and laws as described in this section: whenever there is a model of syntax admitting an instance of such a relational calculus, rewriting is obtained for free. We will comment further on the axiomatic approach at the end of this section.\nFinally, we can merge the definition of substitution and context closure, this way obtaining the substitutive context closure of a.\nDefinition 10. The substitutive context closure of a relation a is the relation aSC , a[\u2206]C = \u00b5x.a[\u2206] \u2228 x\u0302.\nWhen instantiated on a first-order system (\u03a3,X , a), we obtain the following inductive characterisation of aSC:\nt 7\u2192 s t[v\u0304/x\u0304] 7\u2192SC s[v\u0304/x\u0304] x \u2208 X x 7\u2192SC x\n\u2200i \u2264 n. ti 7\u2192SC si o \u2208 \u03a3\no(t1, . . . , tn) 7\u2192SC o(s1, . . . , sn)\nWe conclude this section with a methodological (and perhaps conceptual) consideration.\n3) The Augmented Calculus of Relations: Let us have a look at the relational apparatus developed so far from an operational perspective. Accordingly, can think about our framework as an augmented calculus of relations where, in addition to the classic operations on relations (such as composition, meet, join, etc), we have the operations \u2212\u0303, I\u03b7 (hence \u2212\u0302), and \u2212[=] together with suitable equational laws (viz. those in Proposition 7, Proposition 9, and Proposition 10) and proof principles (viz. fixed point induction). Assuming to have fixed point operators, one can then define inside such an augmented calculus the operators \u2212SC and \u2212C (otherwise, one can add them as primitive operators, together with suitable equational laws and proof principles).\nAs we are going to see, this augmented calculus of relation is expressive enough to define interesting notions of reductions and to prove nontrivial properties about them. Moving from this observation, we could make the whole relational framework developed completely axiomatic, abstracting over syntax and simply working with the aforementioned augmented rela-\ntional calculus. The fact that we have extracted such a calculus out of a syntactic system (\u03a3,V ) can be then read as a way to build a model of the augmented calculus.\nThe remaining part of the paper is devoted to the definition and analyisis of specific notions of reduction: we shall do so first relying on the algebra of syntax (this way showing how they indeed correspond to those given in the rewriting literature), and then showing how syntax-dependency can be avoided by giving equivalent definitions in the augmented calculus of relations. Moreover, to prove our confluence theorems \u2014 the main result proved \u2014 we will use the laws of the augmented calculus only, hence witnessing the effectiveness of the axiomatic approach (see also section X for a more general discussion on the impact of such an approach in operational reasoning)."
        },
        {
            "heading": "VII. PARALLEL REDUCTION",
            "text": "Having defined E-systems and a (augmented) relational calculus to reason about them, it is time to introduce extensions of ground reductions, such extensions giving actual (operational) reduction. We shall focus on two such extensions \u2014 namely parallel and full reduction \u2014 confining ourselves to just few observations on sequential reduction in the last part of the work. Besides introducing such notions and proving basic facts about them, the main results we proved are confluence theorems for a generalisation of the so-called orthogonal systems [17]. We begin with parallel reduction.\nRemark 5. In the remaining part of the paper, we assume that in an E-system (\u03a3,V , a), we have I\u03b7; a = \u22a5. This corresponds to the usual assumption that the left-hand side of reduction rule cannot be a variable [15].\nLet us ignore substitution for the moment and recall that, in concrete reduction systems (such as term and higherorder systems), parallel reduction applies ground reduction on arbitrarily chosen set of disjoint redexes in parallel. Abstractly, we obtain parallel reduction relying on the monad structure of syntax (as we will see, parallel reduction corresponds to looking at syntax as a monad, whereas full reduction corresponds to looking at syntax as a free algebra).\nDefinition 11. Given an E-system (\u03a3,V , a), we define parallel reduction (without substitution) aP : SV \u2192 SV as \u03c1\u25e6;Sa; \u03c1.19 Substitutive parallel extension is defined as aSP , a[\u2206]P.\nThe relation aSP generalises the context-based definition of parallel reduction in syntax-based rewriting systems.\nExample 11. When instantiated on a TRS (\u03a3,X , 7\u2192), we see that t \u21d2 s, where \u21d2 = 7\u2192SP, if and only if there exist a context C, terms t1, . . . , tn, s1, . . . , sn, and substitutions \u03b3i such that: (i) ti 7\u2192 si, for each i; (ii) t = C[t1\u03b31, . . . , tn\u03b3n]; (iii) s = C[s1\u03b31, . . . , sn\u03b3n]; (iv) all ti and sj are pairwise disjoint in t and s, respectively.\n19Recall that working naively within allegories, S is a relator (which is necessarily the Barr extension of its restriction to Map(A)).\nSince S is finitary, we immediately notice that \u2212P inherits many of the structural properties of S: it is \u03c9-continuous (and thus monotone) and commutes with converse (aP\u25e6 = a\u25e6P). Moreover, it indeed extends a, i.e. a \u2264 aP.\nThe definition of aP (and thus of aSP) relies on the monad multiplication of S, and thus goes beyond the augmented calculus of relations outlined in the previous section. As it happens in concrete syntax-based systems, aP can be characterised inductively and such a characterisation precisely shows us how to define parallel extension in the relational calculus.\nProposition 11. aP = aC (= \u00b5x.a \u2228 x\u0302), and thus aSP = aSC.\nProof. First, we notice that aP = a \u2228 a\u0302P, and thus aC \u2264 aP. To see that, consider the following diagram and calculation (where we use the inductive characterisation of S provided by Proposition 3):\nSA +\u03a3SA [\u2206,\u03c3]\n%%\u2751\u2751 \u2751\u2751\n\u2751\u2751 \u2751\u2751\n\u2751\u2751\nSA+\u03a3SSA [\u03b7,\u03c3] //\n\u2206+\u03a3\u00b5 66\u2665\u2665\u2665\u2665\u2665\u2665\u2665\u2665\u2665\u2665\u2665\u2665\na+\u03a3Sa\nSSA \u00b5 //\nSa\nSA\na\u0302\nSA+\u03a3SSA [\u03b7,\u03c3] //\n\u2206+\u03a3\u00b5 ((PP PP\nPP PP\nPP PP\nSSA \u00b5\n// SA\nSA +\u03a3SA\n[\u2206,\u03c3] 99ssssssssss\naP = \u03c1\u25e6;Sa; \u03c1\n= ((\u2206 + \u03a3\u03c1); [\u2206,\u03c3])\u25e6; (a+\u03a3Sa); (\u2206 + \u03a3\u03c1); [\u2206,\u03c3] = [\u2206,\u03a3\u03c1;\u03c3]\u25e6; (a+\u03a3Sa); [\u2206,\u03a3\u03c1;\u03c3] = a \u2228 \u03c3\u25e6; \u03a3\u03c1\u25e6; \u03a3Sa; \u03a3\u03c1;\u03c3 = a \u2228 \u03c3\u25e6; \u03a3(\u03c1\u25e6;Sa; \u03c1);\u03c3 = a \u2228 \u03c3\u25e6; \u03a3aP;\u03c3\n= a \u2228 a\u0302P\nLet us now prove aP \u2264 aC. Since by Proposition 3 we have Sa = \u00b5x.(\u03b7\u25e6; a; \u03b7) \u2228 (\u03c3\u25e6; \u03a3x;\u03c3), we can proceed by \u03c9continuous fixed point induction on. Assuming \u03c1\u25e6;x; \u03c1 \u2264 aC, we have:\n\u03c1\u25e6; ((\u03b7\u25e6; a; \u03b7) \u2228 (\u03c3\u25e6; \u03a3x;\u03c3)); \u03c1\n= (\u03c1\u25e6; \u03b7\u25e6; a; \u03b7; \u03c1) \u2228 (\u03c1\u25e6;\u03c3\u25e6; \u03a3x;\u03c3; \u03c1) = a \u2228 (\u03c1\u25e6;\u03c3\u25e6; \u03a3x;\u03c3; \u03c1) = a \u2228 (\u03c3\u25e6; \u03a3\u03c1\u25e6; \u03a3x; \u03a3\u03c1;\u03c3; ) = a \u2228 (\u03c3\u25e6; \u03a3(\u03c1\u25e6;x; \u03c1);\u03c3; ) = a \u2228 (\u03c3\u25e6; \u03a3aC;\u03c3; )\n= a \u2228 a\u0302C\n= aC.\nBy Proposition 11, aP and aSP are compatible, and since compatible relations are reflexive, they are reflexive too.\nTherefore, we see that indeed aP reduces disjoint redexes at will. Before moving to confluence properties of aSP, we observe that aSP is closed under substitution.\nProposition 12. aSP[\u2206] \u2264 aSP.\nProof. It is sufficient to prove aSP \u2264 \u2206 \u00bb aSP, and we do so by fixed point induction. The interesting case is showing \u2206\u0302 \u00bb aSP \u2264 \u2206\u00bbaSP. For that, we notice that we have the general law x\u0302 \u00bb y \u2264 x\u00bb(y\u0302\u2228x),20 which gives \u2206\u0302 \u00bb aSP \u2264 \u2206\u00bb(a\u0302SP\u2228\u2206) \u2264 \u2206 \u00bb aSP, since \u00bb is monotone in the second argument and aSP is reflexive and compatible."
        },
        {
            "heading": "A. The Relational Parallel Moves Technique",
            "text": "Having defined parallel reduction, we now give evidences of its effectiveness. We do so by looking at one of the most important property of symbolic systems: confluence [100]. In full generality: (i) a relation a : A \u2192 A has the diamond property if a\u25e6; a \u2264 a; a\u25e6, (ii) is confluent if a\u2217 has the diamond property, (iii) is weakly confluent if a\u25e6; a \u2264 a\u2217; a\u2217\u25e6 (notice that a\u25e6\u2217 = a\u2217\u25e6).\nWhen it comes to prove confluence of parallel reduction aSP (and reductions alike), it is desirable to have local proof techniques at disposal. Confluence, in fact, is a non-local property in two ways: (i) it refers to reduction sequences (viz. aSP\u2217) rather than single reduction steps; (ii) it performs reduction inside complex expressions. The proof techniques we shall prove in this paper are mostly given in the form of diamond-like properties (hence obtaining locality of the first type above) with hypotheses formulated on ground reduction a or substitution instances thereof, viz. a[\u2206], hence obtaining semi-locality of the second type above.\nThe first main result we prove here is an abstract and relational version of the so-called parallel moves lemma [18], a well-known technique to prove confluence of orthogonal systems [17]. When specialised to first-order systems, orthogonality of a TRS means that the system has no critical pair [17] and all ground reductions are left-linear (i.e. variables in a ground redexes occur at most once). These conditions are heavily syntax-dependent and they hardly generalise to arbitrarily syntax-based systems.\nWe overcome this issue by isolating an operational notion of orthogonality which, when instantiated to TRSs, is indeed implied by the aforementioned syntactic definition of orthogonality. Such an operational notion of orthogonality directly translates into the relational framework the informal intuition behind orthogonal systems, namely that redexes remains so whenever their subterms are reduced (stated otherwise: reduction is local, in the sense that reducing a redex does not affect other redexes).\nDefinition 12. An E-system (\u03a3,V , a) is orthogonal if:\na[\u2206]\u25e6; a[\u2206] \u2264 \u2206 a[\u2206]\u25e6; a\u0303SP \u2264 a\u25e6[aSP].\n20It is sufficient to prove x\u0302 \u00bb y[x] \u2264 y\u0302 \u2228 x. The latter follows from\nProposition 9 thus: x\u0302 \u00bb y[x] \u2264 \u0302(x \u00bb y)[x] \u2228 x \u2264 y\u0302 \u2228 x.\nThe first condition in Definition 12 is clear: ground reduction rules are essentially unique.21 The second condition states that a redex (instance) remains such when we reduce its subterms. In the case of TRSs, we can spell out such a condition as follows: for any ground reduction \u2113 7\u2192 r, if we reduce a proper subterm s of an instance \u2113[v\u0304/x\u0304] of \u2113, say s \u21d2 t, then t = \u2113[w\u0304/x\u0304] and vi \u21d2 wi. Notice that using the compatible refinement operator, we can indeed express that the reduction s\u21d2 t happens on a proper subterm of \u2113[v\u0304/x\u0304]. Our goal now is to prove that orthogonal systems are confluent by showing that parallel reduction has the diamond property: this technique goes under the name of parallel moves [15], [18]. Before going any further, we remark that the latter statement is not true in general; it fails, for instance, for syntax involving variable binding. In those cases, parallel reduction is only weakly confluent. Working relationally, we see clearly the point where the parallel moves technique breaks and thus we can isolate the operational condition needed to make it work, such a condition holding for, e.g., first-order syntax. Moreover, by weakening the orthogonality condition, we obtain (perhaps) novel techniques to prove weak confluence of non-orthogonal systems.\nAs a first step towards confluence, we notice that the parallel\noperator enjoys a Kleisli-like lifting property.\nLemma 1. If a\u25e6; aP \u2264 aP; aP\u25e6, then aP\u25e6; aP \u2264 aP; aP\u25e6\nProof. We assume a\u25e6; aP \u2264 aP; aP\u25e6 and notice that, dualising, we also obtain aP\u25e6; a \u2264 aP; aP\u25e6. Since aP\u25e6 = a\u25e6P = \u00b5x.a\u25e6 \u2228 x\u0302, we can prove the thesis by \u03c9-continuous induction (notice that indeed \u03c6(x) , a\u25e6\u2228 x\u0302 is \u03c9-continuous \u2014 this also follows from Proposition 11 \u2014 and that so is \u03c6(x); aP). Let us assume x \u2264 aP\u25e6 and x; aP \u2264 aP; aP\u25e6. We show (a\u25e6 \u2228 x\u0302); aP \u2264 aP; aP\u25e6. The latter amounts to prove a\u25e6; aP \u2228 x\u0302; aP \u2264 aP; aP\u25e6, which in turn follows from a\u25e6; aP \u2264 aP; aP\u25e6 and x\u0302; aP \u2264 aP; aP\u25e6. The former follows by hypothesis. For the latter, since aP = a\u2228 a\u0302P, it is sufficient to prove x\u0302; a \u2264 aP; aP\u25e6 and x\u0302; a\u0302P \u2264 aP; aP\u25e6. The first follows from (the dualised version of the) hypothesis, since x \u2264 aP\u25e6 gives\nx\u0302; a \u2264 a\u0302P\u25e6; a \u2264 a\u0302P \u25e6 ; a \u2264 aP\u25e6; a.\nFor the second inequality, we first use the induction hypothesis as follows\nx\u0302; a\u0302P = x\u0302; aP \u2264 a\u0302P; aP\u25e6\nand then notice that aP; aP\u25e6 is indeed compatible (from which the thesis follows). For\na\u0302P; aP\u25e6 = a\u0302P; a\u0302P\u25e6\n= a\u0302P; a\u0302\u25e6P\n\u2264 (a \u2228 a\u0302P); (a\u25e6 \u2228 a\u0302\u25e6P) = aP; a\u25e6P = aP; aP\u25e6.\n21Notice that such a rule actually gives weak orthogonality [15].\nSince aSP = a[\u2206]P, we can prove that the latter has the diamond property relying on Lemma 1 by showing a[\u2206]\u25e6; a[\u2206]P \u2264 a[\u2206]P; a[\u2206]P\u25e6. To do so, we need two auxiliary results. The first stating that parallel reduction extends to substitutions.22\nLemma 2. \u2206[aSP] \u2264 aSP.\nProof. It is sufficient to prove \u2206 \u2264 aSP \u00bbaSP. Since \u2206 = \u00b5x.x\u0302, we proceed by fixed point induction showing that aSP \u00bb aSP is compatible. Since aSP is compatible (and \u00bb is monotone in the second argument), we have: \u0302aSP \u00bb aSP \u2264 aSP \u00bb (a\u0302SP \u2228 aSP) \u2264 aSP \u00bb aSP.\nThe second property needed states that a reduction cannot\nproduce nested redexes.\nDefinition 13. An E-system (\u03a3,V , a) has the nesting property if a\u25e6[aSP] \u2264 aSP; a\u25e6[\u2206].\nThe nesting property holds for TRSs, as well as for higherorder systems without binders [101]. However, as already mentioned, it fails on syntax with variable binding. For instance, in the case of the \u03bb-calculus, it states that whenever we have\nt[v\u0304/x\u0304][s[v\u0304/x\u0304]/x]\u2190\u03b2 (\u03bbx.t[v\u0304/x\u0304])s[v\u0304/x\u0304]\u21d2\u03b2 (\u03bbx.t[w\u0304/x\u0304])s[w\u0304/x\u0304],\nthen t[v\u0304/x\u0304][s[v\u0304/x\u0304]/x] \u21d2 t[w\u0304/x\u0304][s[w\u0304/x\u0304]/x]. The latter reduction does not hold, as there could nested redexes vis. As we shall see in the next section, such a property is implied by substitutivity, a property not enjoyed by aSP.\nTheorem 6 (Parallel Moves). Let (\u03a3,V , a) be an orthogonal system satisfying the nesting property. Then aSP has the diamond property.\nProof. By Lemma 1 it is sufficient to prove a[\u2206]\u25e6; a[\u2206]P \u2264 a[\u2206]P; a[\u2206]P\u25e6. Let b be a[\u2206]P; a[\u2206]P\u25e6. Since a[\u2206]P = a[\u2206] \u2228 a\u0302[\u2206]P, it is sufficient to show a[\u2206]\u25e6; a[\u2206] \u2264 b and a[\u2206]\u25e6; a\u0302[\u2206]P \u2264 b, i.e. a[\u2206]\u25e6; a\u0302SP \u2264 b. The former directly follows from orthogonality, since \u2206 \u2264 b. For the latter, it is sufficient to show a[\u2206]\u25e6; I\u03b7 \u2264 b and a[\u2206]\u25e6; a\u0303SP \u2264 b. The first trivially follows by Remark 5, whereas for the second by orthogonality and the nesting property, we have\na[\u2206]\u25e6; a\u0303SP \u2264 a\u25e6[aSP] \u2264 aSP; a\u25e6[\u2206].\nWe conclude the thesis since aSP is closed under substitution (Lemma 2) (and thus a\u25e6[\u2206] \u2264 aSP\u25e6[\u2206] \u2264 aSP\u25e6).\n1) Beyond Confluence: We have seen that in presence of the nesting property orthogonal systems are confluent. But what happens if such a property fails, as in the case of the \u03bb-calculus? In the next section, we shall see another route to achieve confluence. Here, we notice that our relational parallel moves technique outlines a blueprint that can be used to prove weaker forms of confluence in presence of relaxed conditions. For instance, we can massage Lemma 1 to deal with weak confluence.\n22On a TRS we have: vi \u21d2 wi implies t[v\u0304/x\u0304] \u21d2 t[w\u0304/x\u0304].\nLemma 3. a\u0302\u2217 = a\u0302\u2217.\nProof. By Proposition 7 using that a\u2217 = \u00b5x.\u2206 \u2228 a;x.\nProposition 13. If a\u25e6; aP \u2264 aP\u2217; aP\u2217\u25e6, then aP\u25e6; aP \u2264 aP\u2217; aP\u2217\u25e6\nProof Sketch. We proceed as in the proof of Lemma 1 by noticing that: (i) a\u0302P\u2217 \u2264 aP\u2217 (this follows from Lemma 3); and (ii) \u0302aP\u2217; aP\u2217\u25e6 \u2264 aP\u2217; aP\u2217\u25e6.\nTaking advantage of Proposition 13, we can now mimic the proof of Theorem 6 but with weaker assumptions. For instance, we can weaken the nesting property by allowing multiple steps of parallel reductions, i.e. a\u25e6[aSP] \u2264 a[\u2206];\u2206[aSP\u2217\u25e6]. Such a property, that holds also on syntax with binders, allows us to conclude that orthogonal systems are weakly confluent. This may not be that interesting, as we are going to see that using deep reduction we can prove confluence of orthogonal systems, but observe that the result can be further weakened by, e.g., requiring a\u25e6[\u2206]; a[\u2206] \u2264 aSP\u2217; aSP\u2217\u25e6, hence going beyond orthogonality."
        },
        {
            "heading": "VIII. FULL REDUCTION",
            "text": "Looking at syntax as the (free) monad S, we can qualify parallel reduction \u2014 which is defined relying on the monad multiplication and relational extension \u2014 as the canonical notion of reduction induced by the syntax S. We can also look at S as an initial algebra and rely on Theorem 4 to exploit initiality at a relational level. In fact, any ground relation a : SV \u2192 SV (for reasons that will become clear soon, we will actually consider a\u2228\u2206) induces a relatonal (V +\u03a3)algebra on SV via post-composition with the algebra map [\u03b7,\u03c3] : V +\u03a3(SV )\u2192 SV .\nDefinition 14. Given an E-system (\u03a3,V , a), we define the full reduction relation as aF , L[\u03b7,\u03c3]; (a \u2228\u2206)M.\nSpecific instances of deep reduction have been extensively employed both in first- and higher-order rewriting to prove confluence. For instance, for a TRS (X , \u03a3, 7\u2192), we see that 7\u2192F is the relation inductively defined thus:\nx 7\u2192F x x 7\u2192 t x 7\u2192F t\nt1 7\u2192F s1 \u00b7 \u00b7 \u00b7 tn 7\u2192F sn o(t1, . . . , tn) 7\u2192F o(s1, . . . , sn)\nt1 7\u2192F s1 \u00b7 \u00b7 \u00b7 tn 7\u2192F sn o(s1, . . . , sn) 7\u2192 u\no(t1, . . . , tn) 7\u2192F u\nNotice that since in TRSs variables cannot be redexes, the second clause above never applies. By taking a[\u2206]F, we recover the traditional notion of full reduction \u21db.\nThe relation aF recursively applies a \u2228 \u2206 on the whole expression, hence reducing in parallel possibly nested redexes at will. This ensures that aF extends a. Moreover, the presence of \u2206 allows one to stop reducing at any time.\nLemma 4. 1) \u2206 \u2264 aF, 2) a \u2264 aF.\nUsing Theorem 5 we can exploit the inductive nature of aF.\nProposition 14. aF = \u00b5x.I\u03b7 \u2228 I\u03b7; a \u2228 x\u0303 \u2228 x\u0303; a.\nRemark 6. Actually, if we exploit the assumption in Remark 5, we further simplify Proposition 14 obtaining aF = \u00b5x.I\u03b7 \u2228 I\u03b7; a \u2228 x\u0303 \u2228 x\u0303; a.\nBefore studying rewriting properties of aF, it is natural to ask how aF relates to aP. Intuitively, the latter is the subrelation of the former obtained by reducing non-nested redexes only. Consequently, one expects aP \u2264 aF. Moreover, the same kind of argument suggests that aF can be recovered by possibly many steps of aP. This is indeed the case: actually, aF and aP determine the same reduction sequences.\nLemma 5. aP \u2264 aF \u2264 aP\u2217 = aF\u2217.\nProof Sketch.. The proof is a straightforward (fixed point) induction. The only (perhaps) non-immediately trivial passage is observing that a\u0303P\u2217; a \u2264 aP\u2217. This follows from Lemma 3 thus: a\u0303P\u2217; a \u2264 a\u0302P\u2217; a \u2264 aP\u2217; a \u2264 aP\u2217; aP \u2264 aP\u2217.\nWriting aSF for a[\u2206]F, we see that all the above results extend to aSF and aSP.\nLet us now move to confluence of full reduction. Since aSF reduces also nested redexes, we expect such a relation to satisfy the nesting property of Definition 13 (properly reformulated replacing aSP with aSF), at least on orthogonal systems, where now orthogonality is defined as in Definition 12 but with aSF in place of aSP. To prove the nesting property for aSF we first observe that the latter is implied by substitutivity.\nLemma 6. If aSF is substitutive (i.e. aSF[aSF] \u2264 aSF]), then it has the nesting property: that is, a\u25e6[aSF] \u2264 aSF; a\u25e6[\u2206].\nProof. Recall that \u2212[=] is functorial and that \u2206 \u2264 aSF. We have: a\u25e6; [aSF] = (\u2206; a\u25e6)[aSF; \u2206] \u2264 (aSF; a\u25e6)[aSF; \u2206] = aSF[aSF]; a\u25e6[\u2206] \u2264 aSF; a\u25e6[\u2206], where the last inequality follows from substitutivity.\nWe now aim to prove substitutivity of aSF. We do so by exploiting an unexpected connection between aSF and a wellknown relational technique in program equivalence: Howe\u2019s method [44], [45]."
        },
        {
            "heading": "A. Full Reduction and Howe\u2019s Method",
            "text": "Howe\u2019s method is a powerful operational technique to prove congruence of applicative (bi)similarity originally developed in the context of the pure \u03bb-calculus. Howe\u2019s method has been extended to a variety of concrete formalism \u2014 such as calculi with computational effects [42], [99], [102]\u2013[111] \u2014 and categorical semantics [112]\u2013[114]. Gordon [65], [93] and Lassen [42], [43] have developed an elegant relational account of Howe\u2019s method on specific \u03bb-calculi; such an account can be made completely general by abstracting over the concrete syntax, along the lines of section VI.\nWe are going to show that the Howe extension of a relation a coincides with aF. The advantage of such an equality \u2014 which is, in spite of its simplicity, new ( at least to the best of the author\u2019s knowledge) \u2014 is twofold: on the one hand, we obtain a novel understanding of Howe\u2019s method in terms of\ninitial relation algebras as in Definition 14; on the other hand, we obtain powerful proof techniques for reasoning about full reduction.\nDefinition 15. For a relation a : SV \u2192 SV , define its Howe extension23 as aH , \u00b5x.x\u0302; (a \u2228\u2206). We define aSH as a[\u2206]H.\nWe now show that aH and aF coincides, and infer from that an inductive characterisation of aSF. For the remaining part of this section, we use the notation y= for the reflexive closure of y, i.e. y= , y \u2228\u2206.\nLemma 7. aH = aF.\nProof. By Theorem 5, we have:\naF = L[\u03b7,\u03c3]; a=M\n= \u00b5x.[\u03b7,\u03c3]\u25e6; (\u2206V +\u03a3x); [\u03b7,\u03c3]; a = = \u00b5x.\u03b7\u25e6; \u03b7; a= \u2228 \u03c3\u25e6; \u03a3x;\u03c3; a=\n= \u00b5x.I\u03b7; a = \u2228 x\u0303; a= = \u00b5x.(I\u03b7 \u2228 x\u0303); a = = \u00b5x.x\u0302; a=\n= aH.\nTo exploit the consequences of Lemma 7, we first make explicit a (straightforward) property of the reflexive closure operator.\nLemma 8. a[\u2206]= = a=[\u2206].\nProof. Unfolding the definition of (\u2212)=, we see that we have to prove a[\u2206]\u2228\u2206 = (a\u2228\u2206)[\u2206]. First, we notice that a[\u2206]\u2228 \u2206 \u2264 (a \u2228 \u2206)[\u2206] follows from a[\u2206] \u2264 (a \u2228 \u2206)[\u2206] ((which follows from Proposition 9, since a \u2264 a \u2228\u2206)) and \u2206 \u2264 (a \u2228 \u2206)[\u2206]. (again, by Proposition 9 we have \u2206 = \u2206[\u2206] \u2264 (a \u2228 \u2206)[\u2206]). To conclude the proof, it is thus enough to prove the opposite inequality, namely (a\u2228\u2206)[\u2206] \u2264 a[\u2206]\u2228\u2206. The latter is equivalent to a\u2228\u2206 \u2264 \u2206 \u00bb (a[\u2206] \u2228\u2206), which follows from a \u2264 \u2206 \u00bb (a[\u2206] \u2228 \u2206) (i.e. a[\u2206] \u2264 a[\u2206] \u2228 \u2206, which trivially holds) and \u2206 \u2264 \u2206\u00bb (a[\u2206]\u2228\u2206) (i.e. \u2206[\u2206] \u2264 a[\u2206]\u2228\u2206, which trivially follows from \u2206[\u2206] = \u2206).\nProposition 15. For an E-system (\u03a3,V , a), we have:\n1) aSF = aSH = \u00b5x.I\u03b7 \u2228 x\u0303; a=[\u2206]. 2) aSF\u25e6 = aSH\u25e6\u00b5x.I\u03b7 \u2228 a=[\u2206]\u25e6; x\u0303.\nProof. We prove item 1, as item 2 is a direct consequence of it. By Lemma 7, we have\naSF = aSH = a[\u2206]H = \u00b5x.x\u0302; a[\u2206]=.\n23Usually one defines aH as \u00b5x.x\u0302; a \u2014 hence without forcing reflexivity on a \u2014 and then restricts the analysis to reflexive relations (program approximations and equivalences being such). For the ease of exposition, we force reflexivity into the very definition of aH, much in the same way as we did with aF. Of course, it is possible to remove reflexivity from both such definitions and obtain the same results we prove in this section mutatis mutandis.\nWe then calculate:\n\u00b5x.x\u0302; a[\u2206]= = \u00b5x.x\u0302; a=[\u2206] (Lemma 8)\n= \u00b5x.(I\u03b7 \u2228 x\u0303); a =[\u2206] = \u00b5x.I\u03b7; a =[\u2206] \u2228 x\u0303; a=[\u2206] = \u00b5x.I\u03b7; a[\u2206] = \u2228 x\u0303; a=[\u2206] (Lemma 8) = \u00b5x.I\u03b7; (a[\u2206] \u2228\u2206) \u2228 x\u0303; a =[\u2206] = \u00b5x.I\u03b7; a[\u2206] \u2228 I\u03b7 \u2228 x\u0303; a =[\u2206] = \u00b5x.\u22a5 \u2228 I\u03b7 \u2228 x\u0303; a =[\u2206] (Remark 5) = \u00b5x.I\u03b7 \u2228 x\u0303; a =[\u2206].\nWe are now ready to prove substitutivity (and compatibility)\nof full reduction.\nProposition 16. aSF is compatible and substitutive.\nProof. We first show that aSF is substitutive, i.e. aSF[aSF] \u2264 aSF. We prove the equivalent inequality aSF \u2264 aSF \u00bb aSF by \u03c9continuous fixed point induction (recall that \u2212[=] is \u03c9continuous in the first argument). using Proposition 15. We thus assume x \u2264 aSF and x \u2264 aSF \u00bb aSF \u2014 i.e. x[aSF] \u2264 aSF \u2014 and show I\u03b7\u2228 x\u0303; a=[\u2206] \u2264 aSF \u00bbaSF. Proving the latter amounts to prove I\u03b7 \u2264 a\nSF \u00bbaSF and x\u0303; a=[\u2206] \u2264 aSF \u00bbaSF. The former is equivalent to I\u03b7[a\nSF] \u2264 aSF, which follows from Proposition 9. For the latter, it sufficient to prove (x\u0303; a=[\u2206])[aSF] \u2264 aSF. We calculate:24\n(x\u0303; a=[\u2206])[aSF] = (x\u0303; a=[\u2206])[aSF; \u2206]\n\u2264 x\u0303[aSF]; a=[\u2206]\n\u2264 x\u0303[aSF]; a=[\u2206]\n\u2264 a\u0303SF; a=[\u2206] (since x[aSF] \u2264 aSF)\n\u2264 I\u03b7 \u2228 a\u0303SF; a =[\u2206] = aSF.\nFor compatibility, i.e. a\u0302SH \u2264 aSH, we notice that since a=[\u2206] is reflexive, we have a\u0302SH = a\u0302SH; \u2206 \u2264 a\u0302SH; a=[\u2206] \u2264 aSH.\nRemark 7. Notice that substitutivity of aSH holds independently of reflexivity of a=[\u2206] (whereas compatibility actively uses it). This is a consequence of Remark 5 \u2014 which gives Proposition 15 \u2014 whereby we do not have to account for the case I\u03b7; a =[I\u03b7] \u2264 aSF \u00bb aSF. To handle such a case, we indeed need to rely on reflexivity of a=[I\u03b7].\nPutting together Proposition 16 and Lemma 6 we obtain the\nnesting property for aSF.\nCorollary 1. Full reduction aSF has the nesting property.\nWe now have all he ingredients to prove that full reduction has the diamond property. Before that, however, we mention another candidate definition of a \u2018full reduction\u2019 that makes actively use of substitutivity. Such a definition is usually\n24By associativity of relation substitution, i.e. x[y][z] = x[y[z]], we have a=[\u2206][\u2206] = a=[\u2206[\u2206]] \u2264 a=[\u2206].\ncalled multi-step reduction in term rewriting [15] and it is sometimes used in the context of the so-called Tait-MartinL\u00f6f technique [36]\u2013[38] \u2014 notice, however, that in concrete calculi, such as the \u03bb-calculus, such a technique uses (concrete instances of) full reduction, rather than multi-step reduction.\nAs for parallel and full reduction, also multi-step reduction can be (re)discovered in the literature on program equivalence, where it goes under the name of substitutive context closure of a relation [42], [43].\nDefinition 16. Let (\u03a3,V , a) be an E-system. The substitutive context closure of a is defined as aSCC , \u00b5x.a[x] \u2228 x\u0302.\nSince aSH is substitutive and compatible, aSCC is contained in it (aSCC \u2264 aSH), and the two relations give the same reduction sequences. We do not investigate multi-step reduction any further, although we observe (without giving a formal proof) that aSCC enjoys the so-called triangle property (i.e. x \u2264 x;x\u25e6) from which confluence follows."
        },
        {
            "heading": "B. The Tait-Martin-L\u00f6f Technique",
            "text": "We are finally ready to prove the main result of this section, namely that in orthogonal systems full reduction has the diamond property, and thus it is confluent. Our result provides an abstract and relational version of the so-called Tait-Martin-L\u00f6f technique [36]\u2013[38], whereby confluence of a system (originally the \u03bb-calulus) is proved showing the diamond property of full reduction.\nTheorem 7. Say that an E-system (\u03a3,V , a) is orthogonal if a[\u2206]\u25e6; a[\u2206] \u2264 \u2206 and a[\u2206]\u25e6; a\u0303SF \u2264 a\u25e6[aSF]. Then, in an orthogonal system full reduction aSF has the diamond property: aSF\u25e6; aSF \u2264 aSF; aSF\u25e6.\nProof. First of all, we notice that using orthogonality and the nesting property (Corollary 1), we obtain:\na[\u2206]\u25e6; a\u0303SF \u2264 a\u25e6[aSF] \u2264 aSF; a\u25e6[\u2206] (ortho-nesting) a\u0303SF \u25e6 ; a[\u2206] \u2264 a[aSF\u25e6] \u2264 a[\u2206]; aSF\u25e6 (ortho-nesting\u25e6)\nLet s , aSF; aSF\u25e6. We prove aSF\u25e6; aSF \u2264 s by \u03c9-continuous fixed point induction on aSF\u25e6 (Proposition 15). We thus assume x \u2264 aSF\u25e6 and x; aSF \u2264 s and show (we tacitly exploit distributivity of composition over join and the universal property of the latter):\nI\u03b7; a SF \u2264 s (1)\na=[\u2206]\u25e6; x\u0303; aSF \u2264 s (2)\nFor (1), we first observe that I\u03b7; z\u0303 = \u22a5, for any z. Consequently, we have:\nI\u03b7; a SF = I\u03b7; (I\u03b7 \u2228 a\u0303SF; a =[\u2206])\n= I\u03b7; I\u03b7 \u2228 I\u03b7; a\u0303SF; a =[\u2206]\n= I\u03b7 \u2228 \u22a5\n\u2264 s.\nLet us now move to (2). Proceeding as for (1), we have:\na=[\u2206]\u25e6; x\u0303; aSF = a=[\u2206]\u25e6; x\u0303; (I\u03b7 \u2228 a\u0303SF; a =[\u2206])\n= a=[\u2206]\u25e6; x\u0303; I\u03b7 \u2228 a =[\u2206]\u25e6; x\u0303; a\u0303SF; a=[\u2206] = a=[\u2206]\u25e6; x\u0303; a\u0303SF; a=[\u2206].\nWe now exploit the induction hypothesis and obtain:\na=[\u2206]\u25e6; x\u0303; a\u0303SF; a=[\u2206] = a=[\u2206]\u25e6; x\u0303; aSF; a=[\u2206]\n\u2264 a=[\u2206]\u25e6; a\u0303SF; aSF\u25e6; a=[\u2206] \u2264 a=[\u2206]\u25e6; a\u0303SF; a\u0303SF \u25e6 ; a=[\u2206].\nConsequently, to conclude the thesis it is sufficient to prove a=[\u2206]\u25e6; a\u0303SF; a\u0303SF \u25e6 ; a=[\u2206] \u2264 s. We use Lemma 8 (which also gives a=[\u2206]\u25e6 = a\u25e6[\u2206]= = a[\u2206]\u25e6=) and reduce the proof of the above inequality to the proofs of the following ones:\na\u0303SF; a\u0303SF \u25e6 \u2264 s\na[\u2206]\u25e6; a\u0303SF; a\u0303SF \u25e6 \u2264 s\na\u0303SF; a\u0303SF \u25e6 ; a[\u2206] \u2264 s\na[\u2206]\u25e6; a\u0303SF; a\u0303SF \u25e6 ; a[\u2206] \u2264 s.\nThe first is tautological. For the second, we calculate:\na[\u2206]\u25e6; a\u0303SF; a\u0303SF \u25e6 ; a[\u2206] \u2264 aSF; a\u25e6[\u2206]; a\u0303SF \u25e6 ; a[\u2206] (ortho-nesting)\n= aSF; a[\u2206]\u25e6; a\u0303SF \u25e6 ; a[\u2206]\n= aSF; (a\u0303SF; a[\u2206])\u25e6\n\u2264 aSF; (a\u0303SF; a=[\u2206])\u25e6 \u2264 aSF; aSF\u25e6 (= s).\nFor the third inequality we proceed as for the second one, but in a dual fashion (hence relying on (ortho-nesting\u25e6)). Finally, for the fourth inequality we have:\na[\u2206]\u25e6; a\u0303SF; a\u0303SF \u25e6 ; a[\u2206] \u2264 aSF; a\u25e6[\u2206]; a\u0303SF \u25e6 ; a[\u2206] (ortho-nesting)\n\u2264 aSF; a\u25e6[\u2206]; a[\u2206]; aSF\u25e6 (ortho-nesting\u25e6) \u2264 aSF; aSF\u25e6 (= s). (Orthogonality)"
        },
        {
            "heading": "IX. SEQUENTIAL REDUCTION: A FEW WORDS ONLY",
            "text": "The theory developed so far shows that parallel and full reduction are remarkably natural, at least from a structural and algebraic perspective. When it comes to think about reduction computationally, however, sequential (or linear) reduction is usually considered more fundamental. In fact, almost all textbooks in rewriting theory first define sequential reduction, and then introduce parallel (and full) reduction on top of that.\nEven if the relational analysis of sequential reduction is still work in progress, we mention that sequentiual reduction can be recovered in the allegorical framework, both structurally and algebraically. In the former case, one relies on the derivative [115]\u2013[118] of the signature functor (as well as of the corresponding monad). In fact, the derivative of a functor F : E \u2192 E , if it exists, is the functor \u2202F : E \u2192 E coming with a plug-in weakly cartesian natural transformation\ndFX : \u2202FX \u00d7 X \u2192 FX satisfying the following universal mapping property: for any functor G with a weakly cartesian25 natural transformation \u03d1 : GX \u00d7 X \u2192 FX , there exists a unique weakly cartesian natural transofmation \u03d1\u2032 : GX \u2192 \u2202FX satisfying the following diagram.\n\u2202FX \u00d7X \u03b8 // FX\nGX \u00d7X\n\u03d1\u2032\u00d7\u2206\nOO\n\u03d1 99ssssssssss\nDerivatives of simple polynomial functors and of their free monads, for instance, always exist [116]\u2013[118]. In those cases, one clearly sees that such derivatives provides contexts with one linear hole, which is exactly what is required to define sequential reduction. Consequently, one possible definition of the sequential reduction (on an E-system (\u03a3,V , a) is the relation aL , dS\u25e6; (\u2206\u00d7 a); dS.\nIn a similar fashion, it is possible to define a linear compatible refinement operator \u00caa , d\u03a3\u25e6; (\u2206\u00d7 a); d\u03a3 and use the latter to give an inductive characterisation of aL as \u00b5x.a\u2228\u00cax. At this point, it is possible to proceed following the methodology of the augmented calculus of relations isolating the algebraic laws defining \u00c1\u2212. Notice, however, that such laws largely differ from those of \u2212\u0302. For instance, we have \u00c8a; b \u2264 \u00caa;\u00cab but not the vice versa.\nAnother option to capture forms of sequentiality (albeit not sequential reduction itself) is to think about parallel and full reduction as primitives, and to regard sequential-like reductions as their restrictions. Following this direction, we may introduce the notion of a sequentialisation of a relator \u03a3, namely a family of finitary maps \u0393 : A(A,A)\u2192 A(\u03a3A, \u03a3A) such that:\n\u2206 = \u0393\u2206\n\u0393(a\u25e6) = (\u0393a)\u25e6\n\u0393(a \u2228 b) = \u0393a \u2228 \u0393b\n\u0393a \u2264 \u03a3a \u03a3a \u2264 (\u0393a)\u2217.\nFor instance, if \u03a3 is the functor induced by a first-order signature, then a sequantialisation of (the Barr extension of) \u03a3 is the following inductively defined map:\nx a y\nx \u0393a y\nt \u0393a s n \u2265 0\no(u1, . . . , t, . . . , un) \u0393a o(u1, . . . , s, . . . , un)\nNotice that (the reduction induced by) \u0393 does not coincide with the usual sequential reduction. In fact, \u0393 allows to always reduce 0-ary operations (i.e. constants) to themselves (otherwise, it behaves as sequential reduction).\nAt this point, we can proceed as in the previous sections, simply working with (fixed) a sequentialisation \u0393 of \u03a3 in place of the latter. We do not go any further but simply remark that\n25A natural transformation is weakly cartesian if its naturality squares are weak pullbacks [119]. Intuitively, we can think about such natural transformations as linear maps between functors [120].\na weak Kleisli-like lemma along the lines of Proposition 13 can be easily proved for sequentialised reductions."
        },
        {
            "heading": "X. CONCLUSION",
            "text": "In this work, we have outlined a general relational theory of symbolic manipulations in rewriting style. The theory is given in the framework of allegory theory and goes in tandem with the so-called mathematical theory of syntax: remarkably, these two theories build upon the same collection of concepts, the theory of syntax implementing them in a categorical way, the theory of symbolic manipulation implementing them in an allegorical, relational way. We have then pushed the relational approach even further by noticing how the aforementioned relational counterparts of syntactic notions define new operators on relations subject to specific algebraic laws. Such operators and their laws turned out to be all that matters to study symbolic manipulation, and thus give raise to a syntaxindependent augmented calculus of relations within which we have defined classic reduction relations (viz. parallel and full reduction) and proved nontrivial properties about them."
        },
        {
            "heading": "A. Relational Rewriting and Operational Semantics",
            "text": "The results presented in this paper give (first) evidences that the relational approach to rewriting goes considerably beyond abstract reduction systems. The author hopes that such results will contribute to a renewed interest in the relational approach to rewriting (an outline of a research program for that is given in the next section).\n(Relational) Rewriting, however, is just one piece in the (operational) jigsaw. In fact, the augmented calculus of relations and, most importantly, its underlying methodology, suggest that (part of) operational reasoning can be developed in an axiomatic and syntax-independent fashion. Indeed, one way to read the results of this work, together with previous results on program equivalence, is that the augmented calculus of relations is expressive enough to account for two main forms of operational reasoning: rewriting and program equivalence (and refinement).26 Furthermore, the author conjectures that much more operational reasoning, such as theories of program dynamics, can be developed within such a calculus (or variations thereof).\nThis perspective, which we may refer to as relational or allegorical operational semantics, aims to achieve a systematic development of operational techniques within a (truly) relational paradigm, whereby program relations,27 their operations, and algebraic properties are first-class citizens. The successful application of relational calculi to the field of program equivalence and rewriting hints that the relational approach to operational semantics has the potential to achieve\n26Calculi subsumed by the augmented calculus of relations have been employed to give relational accounts of logical relations [111], contextual and CIU equivalence [42], [106], and applicative and normal bisimilarity [42], [65], [104], [121]\u2013[123].\n27I.e. suitable notions of relation on programs texts, rather than on their abstract denotations.\na general axiomatic and largely syntax-independent basis for operational reasoning.28"
        },
        {
            "heading": "B. Future Work",
            "text": "Following the discussion made so far, future work can be divided into two research directions. The first one is devoted to the development of relational rewriting, hence complementing the confluence results proved in previous sections; the second, instead, focuses on extending the relational framework to cover more operational behaviours, hence going towards the aforementioned allegorical operational semantics.\nBeginning with the former and omitting the already discussed issue of sequential reduction (section IX), here is a possible research agenda.\n1. Termination. The work by Hasegawa [124] shows how\nsyntax-based termination techniques (such as multiset and recursive path ordering [15]) on TRSs can be abstractly recovered in terms of lifting of (analytic) functors [115], and thus suggests that syntax-based termination can be indeed analysed in a relational framework.29 It thus seems natural to incorporate and extend Hasegawa\u2019s results in the allegorical framework. 2. Strategies and Factorisation. Together with confluence and\ntermination, another crucial property of rewriting systems is factorisation [127]. The Kleisli-like lemmas proved in the paper can be already generalised to factorisation techniques (simply replace a\u25e6 and alike with arbitrary relations b). These, however, provide only a superficial account of factorisation and it is thus interesting to ask whether deeper analyses of factorisation can be given relationally, perhaps along the line of the recent work by Accattoli et al. [128]. 3. Analytic Functors and Rewriting Modulo. In this work, our\nexamples were intended to model notions of syntax-based symbolic systems. Consequently, we focused on syntaxlike finitary functors (and free monads), polynomial functors being a prime examples of those. Another interesting class of examples that we have not studied is the one of analytic functors [115]. In a first approximation, analytic functors can be seen as polynomial functors modulo an equivalence obtained via a group of symmetries. From a rewriting perspective, working with analytic functors we recover notions of syntax modulo permutations, in a very general sense. Looking at analytic functors, consequently, we may apply relational rewriting to rather liberal notions of syntax carrying a nontrivial semantic import. 4. Infinitary and Coinductive Rewriting. The theory devel-\noped in this paper applies to finitary syntax and rewriting. This naturally leads to asking whether the allegorical account scales to infinitary syntax and coinductive rewriting. An educated guess in this direction is to replace finitary\n28Notice also that such a basis seems to be also well suited for machine formalisation.\n29Relational analysis of termination for abstract systems have already been given, especially concerning modularity results [51], [125], [126].\nsyntax with infinitary one, modelling the latter through iterative algebras [129], or structures alike. Notice that doing so, reduction relations will be still defined via relators, although they would be recasted in the extended calculus of relations not as inductive relations (viz. least fixed points), but as coinductive (viz. greatest fixed points) or mixed inductive-conductive (viz. nested least and greatest fixed points) relations [130]. 5. Quantitative Rewriting. Last but not least, an interesting\nlimitation of the allegorical framework is that it cannot cope with quantitative forms of rewriting [55]\u2013[58]. The problem is foundational, in the sense that categories of quantitative relations do not form an allegory, as they fail to satisfy the modular law. However, they form Frobenius quantaloids [131] and it is natural to explore whether an allegorical-like theory of rewriting can be given on top of such structures (very likely enriched with structures such as power objects). Interestingly, from the axiomatic perspective of the augmented calculus of relations, one observes that relational calculi for modal and quantitative program equivalence (viz. program metrics) have already been defined [111], [132]. Such calculi are impressively close to the augmented calculus of relations except for the addition of a graded comonadic modality acting as scaling [133], [134]. Consequently, one promising direction to approach quantitative rewriting is to proceed axiomatically by extending the augmented calculus of relations with suitable modalities. Let us now move to allegorical operational semantics. In this case, outlining a research agenda is more difficult, as the subject is considerably vast. Nonetheless, we can fix a couple of general research-goals aiming to explore the potential of the relational approach (and, more specifically, of the augmented calculus of relations) as a foundational formalism for operational reasoning.\n1. Reduction-Based Semantics. A first, natural question to\nanswer in order to test the robustness of relational calculi is: can theories of program dynamics be given in such calculi? A possible path towards an answer is showing that reduction-based operational semantics can be given inside suitable extensions of the augmented calculus of relations. Such extensions should be obtained in a rather uniform way by defining a relational counterpart of Felleisenstyle evaluation contexts [135] methodology. Accordingly, the specification of an operational dynamics, such as a call-by-name one, is given not syntactically by means of suitable evaluation contexts, but relationally throughout context operators defining the action of evaluation contexts on relations. Notice that this approach closely relates to reduction strategies, and we can see context operators as refining the compatible refinement operator used in this work (morally, the latter operator would be recovered as the context operator regarding any context as an evaluation context). Following this idea, it becomes interesting to focus not on explicit definitions of operational dynamics, but on suitable axiomatics on context operators ensuring\ndesirable semantic properties: for instance, rather than giving an explicit definition of a call-by-name semantics (which is language specific), we may prove that any lax functorial context operator behaves in such and such way, showing only in a second moment that, on suitable families of languages, a call-by-name dynamics induces such an operator. 2. Computational Effects. Operational behaviours being of-\ntentimes effectful, it is desirable to have extensions of the relational framework accounting for the production of computational effects. One way to introduce them in operational semantics is by means of monadic evaluation semantics [104], [136]; another, approach, that seems better suited for our purposes, is the one of monadic rewriting [54]. The latter develops a general relational theory of abstract reduction systems with (monadic) computational effects relying on monadic relations which, roughly, can be seen as arrows in the Kleisli allegory of the monad modelling computational effects. Unfortunately, monadic rewriting has been developed for abstract systems only, and no extension of the theory to syntax-based systems is currently available. The theory developed in this paper suggests that the key to account for both syntax-based and effectful rewriting relies on the combination of monads for syntax and for computational effects, at an allegorical level."
        },
        {
            "heading": "ACKNOWLEDGMENT",
            "text": "The author would like to thank the anonymous reviewers for their helpful observations. Special thanks go to Filippo Bonchi, Francesco Dagnino, Ugo Dal Lago, and Simone Martini."
        }
    ],
    "title": "Allegories of Symbolic Manipulations",
    "year": 2023
}