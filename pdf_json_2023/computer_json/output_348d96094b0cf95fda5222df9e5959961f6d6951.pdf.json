{
    "abstractText": "Temporal logic is a concise way of specifying complex tasks. But motion planning to achieve temporal logic specifications is difficult, and existing methods struggle to scale to complex specifications and high-dimensional system dynamics. In this paper, we cast Linear Temporal Logic (LTL) motion planning as a shortest path problem in a Graph of Convex Sets (GCS) and solve it with convex optimization. This approach brings together the best of modern optimization-based temporal logic planners and older automata-theoretic methods, addressing the limitations of each: we avoid clipping and passthrough by representing paths with continuous Bezier curves; computational complexity is polynomial (not exponential) in the number of sample points; global optimality can be certified (though it is not guaranteed); soundness and probabilistic completeness are guaranteed under mild assumptions; and most importantly, the method scales to complex specifications and high-dimensional systems, including a 30-DoF humanoid. Open-source code is available at https://github.com/vincekurtz/ltl_gcs.",
    "authors": [
        {
            "affiliations": [],
            "name": "Vince Kurtz"
        },
        {
            "affiliations": [],
            "name": "Hai Lin"
        }
    ],
    "id": "SP:b7d00a7a5fbfb5a726fa68ed3550286a67f9a9a8",
    "references": [
        {
            "authors": [
                "Calin Belta",
                "Sadra Sadraddini"
            ],
            "title": "Formal methods for control synthesis: An optimization perspective",
            "venue": "Annual Review of Control, Robotics, and Autonomous Systems,",
            "year": 2019
        },
        {
            "authors": [
                "Vince Kurtz",
                "Hai Lin"
            ],
            "title": "A more scalable mixedinteger encoding for metric temporal logic",
            "venue": "IEEE Control Systems Letters,",
            "year": 2021
        },
        {
            "authors": [
                "William Vega-Brown",
                "Nicholas Roy"
            ],
            "title": "Admissible abstractions for near-optimal task and motion planning",
            "venue": "arXiv preprint arXiv:1806.00805,",
            "year": 2018
        },
        {
            "authors": [
                "Dawei Sun",
                "Jingkai Chen",
                "Sayan Mitra",
                "Chuchu Fan"
            ],
            "title": "Multi-agent motion planning from signal temporal logic specifications",
            "venue": "IEEE Robotics and Automation Letters,",
            "year": 2022
        },
        {
            "authors": [
                "Tobia Marcucci",
                "Jack Umenberger",
                "Pablo A Parrilo",
                "Russ Tedrake"
            ],
            "title": "Shortest paths in graphs of convex sets",
            "venue": "arXiv preprint arXiv:2101.11565,",
            "year": 2021
        },
        {
            "authors": [
                "Tobia Marcucci",
                "Mark Petersen",
                "David von Wrangel",
                "Russ Tedrake"
            ],
            "title": "Motion planning around obstacles with convex optimization",
            "venue": "arXiv preprint arXiv:2205.04422,",
            "year": 2022
        },
        {
            "authors": [
                "Calin Belta",
                "Boyan Yordanov",
                "Ebru Aydin Gol"
            ],
            "title": "Formal methods for discrete-time dynamical systems, volume",
            "year": 2017
        },
        {
            "authors": [
                "Christel Baier",
                "Joost-Pieter Katoen"
            ],
            "title": "Principles of model checking",
            "year": 2008
        },
        {
            "authors": [
                "Rafael Rodrigues da Silva",
                "Vince Kurtz",
                "Hai Lin"
            ],
            "title": "Active perception and control from temporal logic specifications",
            "venue": "IEEE Control Systems Letters,",
            "year": 2019
        },
        {
            "authors": [
                "Rafael Rodrigues da Silva",
                "Vince Kurtz",
                "Hai Lin"
            ],
            "title": "Automatic trajectory synthesis for real-time temporal logic",
            "venue": "IEEE Transactions on Automatic Control,",
            "year": 2021
        },
        {
            "authors": [
                "Edmund Clarke",
                "Orna Grumberg",
                "Somesh Jha",
                "Yuan Lu",
                "Helmut Veith"
            ],
            "title": "Counterexampleguided abstraction refinement",
            "venue": "In International Conference on Computer Aided Verification,",
            "year": 2000
        },
        {
            "authors": [
                "Cristian Ioan Vasile",
                "Calin Belta"
            ],
            "title": "Samplingbased temporal logic path planning",
            "venue": "In 2013 IEEE/RSJ International Conference on Intelligent Robots and Systems,",
            "year": 2013
        },
        {
            "authors": [
                "Xusheng Luo",
                "Yiannis Kantaros",
                "Michael M Zavlanos"
            ],
            "title": "An abstraction-free method for multirobot temporal logic optimal control synthesis",
            "venue": "IEEE Transactions on Robotics,",
            "year": 2021
        },
        {
            "authors": [
                "Yiannis Kantaros",
                "Samarth Kalluraya",
                "Qi Jin",
                "George J Pappas"
            ],
            "title": "Perception-based temporal logic planning in uncertain semantic maps",
            "venue": "IEEE Transactions on Robotics,",
            "year": 2022
        },
        {
            "authors": [
                "Liangjun Zhang",
                "Dinesh Manocha"
            ],
            "title": "An efficient retraction-based rrt planner",
            "venue": "IEEE International Conference on Robotics and Automation,",
            "year": 2008
        },
        {
            "authors": [
                "Marius Kloetzer",
                "Calin Belta"
            ],
            "title": "A fully automated framework for control of linear systems from temporal logic specifications",
            "venue": "IEEE Transactions on Automatic Control,",
            "year": 2008
        },
        {
            "authors": [
                "Hadas Kress-Gazit",
                "Georgios E Fainekos",
                "George J Pappas"
            ],
            "title": "Temporal-logic-based reactive mission and motion planning",
            "venue": "IEEE transactions on robotics,",
            "year": 2009
        },
        {
            "authors": [
                "Richard M Murray",
                "Muruhan Rathinam",
                "Willem Sluis"
            ],
            "title": "Differential flatness of mechanical control systems: A catalog of prototype systems",
            "venue": "In ASME International Mechanical Engineering Congress and Exposition. Citeseer,",
            "year": 1995
        },
        {
            "authors": [
                "Vasumathi Raman",
                "Alexandre Donz\u00e9",
                "Mehdi Maasoumy",
                "Richard M Murray",
                "Alberto Sangiovanni- Vincentelli",
                "Sanjit A Seshia"
            ],
            "title": "Model predictive control with signal temporal logic specifications",
            "venue": "In 53rd IEEE Conference on Decision and Control,",
            "year": 2014
        },
        {
            "authors": [
                "Eric M Wolff",
                "Ufuk Topcu",
                "Richard M Murray"
            ],
            "title": "Optimization-based trajectory generation with linear temporal logic specifications",
            "venue": "In 2014 IEEE International Conference on Robotics and Automation (ICRA),",
            "year": 2014
        },
        {
            "authors": [
                "Guang Yang",
                "Calin Belta",
                "Roberto Tron"
            ],
            "title": "Continuous-time signal temporal logic planning with control barrier functions",
            "venue": "American Control Conference (ACC),",
            "year": 2020
        },
        {
            "authors": [
                "Sadra Sadraddini",
                "Calin Belta"
            ],
            "title": "Formal synthesis of control strategies for positive monotone systems",
            "venue": "IEEE Transactions on Automatic Control,",
            "year": 2018
        },
        {
            "authors": [
                "Vincent Kurtz",
                "Hai Lin"
            ],
            "title": "Mixed-integer programming for signal temporal logic with fewer binary variables",
            "venue": "IEEE Control Systems Letters,",
            "year": 2022
        },
        {
            "authors": [
                "Yash Vardhan Pant",
                "Houssam Abbas",
                "Rahul Mangharam"
            ],
            "title": "Smooth operator: Control using the smooth robustness of temporal logic",
            "venue": "IEEE Conference on Control Technology and Applications (CCTA),",
            "year": 2017
        },
        {
            "authors": [
                "Noushin Mehdipour",
                "Cristian-Ioan Vasile",
                "Calin Belta"
            ],
            "title": "Arithmetic-geometric mean robustness for control from signal temporal logic specifications",
            "venue": "American Control Conference",
            "year": 2019
        },
        {
            "authors": [
                "Yann Gilpin",
                "Vince Kurtz",
                "Hai Lin"
            ],
            "title": "A smooth robustness measure of signal temporal logic for symbolic control",
            "venue": "IEEE Control Systems Letters,",
            "year": 2020
        },
        {
            "authors": [
                "Vince Kurtz",
                "Hai Lin"
            ],
            "title": "Trajectory optimization for high-dimensional nonlinear systems under stl specifications",
            "venue": "IEEE Control Systems Letters,",
            "year": 2020
        },
        {
            "authors": [
                "Mingyu Cai",
                "Shaoping Xiao",
                "Baoluo Li",
                "Zhiliang Li",
                "Zhen Kan"
            ],
            "title": "Reinforcement learning based temporal logic control with maximum probabilistic satisfaction",
            "venue": "IEEE International Conference on Robotics and Automation (ICRA),",
            "year": 2021
        },
        {
            "authors": [
                "K. Leung",
                "M. Pavone"
            ],
            "title": "Semi-supervised trajectory-feedback controller synthesis for signal temporal logic specifications",
            "venue": "American Control Conference",
            "year": 2022
        },
        {
            "authors": [
                "Lars Lindemann",
                "Dimos V Dimarogonas"
            ],
            "title": "Control barrier functions for signal temporal logic tasks",
            "venue": "IEEE control systems letters,",
            "year": 2018
        },
        {
            "authors": [
                "Mohit Srinivasan",
                "Samuel Coogan"
            ],
            "title": "Control of mobile robots using barrier functions under temporal logic specifications",
            "venue": "IEEE Transactions on Robotics,",
            "year": 2020
        },
        {
            "authors": [
                "Francesco Fuggitti"
            ],
            "title": "Ltlf2dfa, March 2019",
            "year": 2019
        },
        {
            "authors": [
                "Nils Klarlund",
                "Anders M\u00f8ller"
            ],
            "title": "MONA Version 1.4 User Manual",
            "venue": "BRICS, Department of Computer Science, University of Aarhus, January",
            "year": 2001
        },
        {
            "authors": [
                "Myoung-Jun Kim",
                "Myung-Soo Kim",
                "Sung Yong Shin"
            ],
            "title": "A general construction scheme for unit quaternion curves with simple high order derivatives",
            "venue": "In Proceedings of the 22nd annual conference on Computer graphics and interactive techniques,",
            "year": 1995
        },
        {
            "authors": [
                "Zhongxuan Luo",
                "Qian Wang",
                "Xin Fan",
                "Yaqi Gao",
                "Panpan Shui"
            ],
            "title": "Generalized rational b\u00e9zier curves for the rigid body motion design",
            "venue": "The Visual Computer,",
            "year": 2016
        },
        {
            "authors": [
                "Daniel Mellinger",
                "Vijay Kumar"
            ],
            "title": "Minimum snap trajectory generation and control for quadrotors",
            "venue": "In 2011 IEEE international conference on robotics and automation,",
            "year": 2011
        },
        {
            "authors": [
                "Boris Lau",
                "Christoph Sprunk",
                "Wolfram Burgard"
            ],
            "title": "Kinodynamic motion planning for mobile robots using splines",
            "venue": "In 2009 IEEE/RSJ International Conference on Intelligent Robots and Systems,",
            "year": 2009
        },
        {
            "authors": [
                "Russ Tedrake",
                "the Drake"
            ],
            "title": "Development Team. Drake: Model-based design and verification for robotics, 2019",
            "year": 2019
        },
        {
            "authors": [
                "Yurii Nesterov",
                "Arkadii Nemirovskii"
            ],
            "title": "Interiorpoint polynomial algorithms in convex programming",
            "year": 1994
        },
        {
            "authors": [
                "MOSEK ApS"
            ],
            "title": "The MOSEK optimization toolbox",
            "venue": "Version 9.0.",
            "year": 2022
        },
        {
            "authors": [
                "Alexandre Amice",
                "Hongkai Dai",
                "Peter Werner",
                "Annan Zhang",
                "Russ Tedrake"
            ],
            "title": "Finding and optimizing certified, collision-free regions in configuration space for robot manipulators",
            "venue": "In International Workshop on the Algorithmic Foundations of Robotics,",
            "year": 2023
        },
        {
            "authors": [
                "Robin Deits",
                "Russ Tedrake"
            ],
            "title": "Computing large convex regions of obstacle-free space through semidefinite programming",
            "venue": "In Algorithmic foundations of robotics XI,",
            "year": 2015
        },
        {
            "authors": [
                "Hai Lin"
            ],
            "title": "Mission accomplished: An introduction to formal methods in mobile robot motion planning and control",
            "venue": "Unmanned Systems,",
            "year": 2014
        }
    ],
    "sections": [
        {
            "text": "I. INTRODUCTION\nRobotic and cyber-physical systems often need to do more than avoid obstacles or regulate around a set point. To this end, temporal logics like Linear Temporal Logic (LTL), Metric Temporal Logic (MTL), and Signal Temporal Logic (STL) have grown in popularity as a compact means of expressing complex control objectives. Beyond being both expressive and concise, they are relatively easy for humans to understand, with a combination of familiar boolean operators (\u201cand\u201d, \u201cor\u201d, \u201cnot\u201d) and temporal operators with intuitive names (\u201cnext\u201d, \u201calways\u201d, \u201ceventually\u201d). The usefulness of temporal logic becomes most obvious in scenarios like that shown in Fig. 1a, where a mobile robot may not pass through a door (red) until it has picked up a corresponding key (green) and must eventually reach a goal (blue).\nTemporal logic motion planning is a fundamentally difficult (NP-hard) problem, and is especially challenging for high degree-of-freedom (DoF) systems. The current state-of-the art is to use Mixed-Integer Convex Programming (MICP) [1]. The MICP approach is sound and complete (it will always find the optimal solution if\nThe support of the National Science Foundation (Grant No. CNS1830335, IIS-2007949) is gratefully acknowledged.\nVince Kurtz and Hai Lin are both with the Electrical Engineering Department, University of Notre Dame, Notre Dame, IN, USA.\n(a) A benchmark from [3], where a mobile robot must pick up keys (k1, k2, . . . ) before passing through doors (d1, d2, . . . ) and reach a goal. The fastest reported solve time is 49.5 seconds for a piecewise-linear solution [4]. Our proposed approach finds a C2 globally optimal solution in 5.8 seconds.\n(b) A 30-DoF humanoid is tasked with touching the green target with its left hand, then the red target with its right foot, then the blue target with its right hand. Convex optimization finds a smooth configuration-space solution in under 10 seconds.\nFig. 1: Our proposed approach scales to both complex task specifications (a) and high-dimensional systems (b).\na solution exists) but it has some significant drawbacks. In particular, standard MICP encodings introduce binary variables for each subformula at each time step. Since the worst-case complexity of MICP is exponential in the number of binary variables, MICP scales poorly with both specification complexity and the number of sample points used to represent a path [1, 2].\nar X\niv :2\n30 1.\n07 77\n3v 2\n[ cs\n.R O\n] 1\nJ un\n2 02\n3\n2 (a) Standard MICP\n(b) Our approach\nFig. 2: A mobile robot must pick up two keys before it can pass through corresponding doors to reach a goal region, as encoded in formula (10). A standard MICP (2a) uses a fixed discretizaiton of time, leading to a path that passes through an obstacle. Our proposed approach (2b) considers all values along a smooth Bezier spline, avoiding clipping and pass-through.\nThe discretization of time used in standard MICP encodings compounds this problem. A coarse discretization gives rise to \u201cclipping\u201d, where the path may intersect with obstacles between timesteps, violating the specification. An example of this is shown in Fig. 2a. Clipping can be mitigated with a finer discretization, but this increases computational cost exponentially [1].\nWhile exponential cost with the specification complexity is inevitable given the NP-hardness of the problem, it is less clear whether exponential cost with the number of sample points is also inevitable. Intuitively, planning to achieve the same specification with a finer discretization does not seem to make the problem fundamentally harder. Indeed, we show that this exponential complexity can be avoided: our proposed approach scales polynomially with the number of sample points.\nOur key idea is to re-frame LTL motion planning as a shortest path problem in a Graph of Convex Sets (GCS) [5]. This results in an MICP with a very tight convex\nrelaxation\u2014so tight, in fact, that it can often be solved to global optimality with convex optimization and rounding [6]. Even if the approximate solution to this MICP is sub-optimal (bounds on sub-optimality are available [6] and convex optimization often finds the globally optimal solution in practice), any integer-feasible solution is guaranteed to satisfy the specification.\nOur proposed approach scales well to complex specifications and high-dimensional configuration spaces, outperforming the state-of-the-art on numerous benchmark problems (see Section VII). Furthermore, we parameterize motion plans with Bezier splines, allowing us to design smooth paths without clipping or pass-through.\nOur primary contributions are summarized as follows: \u2022 We show that LTL motion planning can be for-\nmulated as a shortest path problem in a GCS and solved efficiently using convex programming. \u2022 By representing paths with smooth Bezier splines, we avoid the clipping and pass-through problems associated with most discrete-time temporal logic formulations. \u2022 Our proposed approach scales polynomially with the number of control points used to represent a smooth path, in contrast with the exponential complexity of standard methods. \u2022 We provide proofs of soundness and probabilistic completeness. \u2022 We demonstrate the scalability of our proposed approach to complex specifications and highdimensional configuration spaces with several simulation examples, and provide open-source code to reproduce these results [7].\nThe remainder of this paper is organized as follows: Section II reviews related work on temporal logic motion planning. A formal problem statement and relevant definitions are given in Section III. Background information on Bezier curves and graphs of convex sets is given in Section IV. Our main result\u2014a convex programming solution to temporal logic motion planning\u2014is described in Section V. Section VI provides proofs of the soundness, completeness, and computational complexity of our proposed approach. We provide examples in Section VII, discuss limitations of our proposed method in Section VIII, and conclude with Section IX."
        },
        {
            "heading": "II. RELATED WORK",
            "text": "Early work on temporal-logic-based control was dominated by automata-theoretic methods [3, 8]. These methods generally assume that the system can be modeled as a finite-state transition system. Once a given LTL formula is transformed into an equivalent automaton, a simple graph search in the product of the transition system and the automaton reveals a satisfying path\n3\n[8, Chapter 5]. For finite-state transition systems, such automata-based methods are sound, complete, and computationally efficient. Similar techniques have achieved widespread adoption in formal verification and model checking applications [9].\nApplying automata-based methods to motion planning is non-trivial, as we must plan in (non-finite) configuration space. The dominant idea in the literature is to use some sort of finite transition system abstraction [3, 10, 11], typically related to labeled regions in configuration space. Once a satisfying abstract path is found, a lower-level motion planner searches for a path through the corresponding regions. While this can be computationally efficient, as it separates logical constraints from physical dynamics, it is difficult to account for the gap between the geometry of the scenario and the abstract transition system. In practice, this means that an abstract path may be dynamically infeasible or inefficient once it is translated to a motion plan: shortest paths in the abstraction do not necessarily correspond to shortest paths in configuration space, as illustrated in Fig. 3.\nIn prior work, we sought to address this gap with a Counter Example Guided Inductive Synthesis (CEGIS) [12] inspired cycle of planning and re-planning for both a high-level automata-based planner and a low-level motion planner [10, 11]. While this allows for completeness guarantees, even local optimality is difficult to achieve and many re-planning cycles may be required.\nAnother drawback for many automata-based methods stems from a reliance on sampling-based motion planning [10, 13, 14, 15]. While such methods can have good scalability properties, they often struggle on problems with narrow passages [16] and it is difficult to enforce dynamic feasibility. It is also often difficult to tell whether a specification is infeasible, as sampling-based methods do not provide certificates of infeasibility.\nA particularly interesting set of automata-based planners do not search for specific satisfying paths, but rather\ngenerate feedback controllers that guarantee closed-loop satisfaction of the specification [17, 18]. While these methods provide an elegant way to bridge the gap between continuous dynamics and the discrete specification, their scalability is limited by the fact that they search for solutions across the whole state space. To the best of our knowledge, such techniques have not been able to scale beyond 4-dimensional state spaces.\nDespite these limitations, we are strongly inspired by automata-theoretic methods in this paper. Specifically, we use the GCS framework to perform graph search in the product of a transition system and an automaton. In contrast to existing abstraction-based methods, this graph search accounts for the geometry of the scenario directly, avoiding the need for separate low-level and high-level planners. Unlike sampling-based methods, our GCS method can navigate narrow passages with ease and enforce dynamical feasibility for differentially flat systems [19]. Unlike methods that search for feedback controllers, our approach scales to high-dimensional systems, including a 30-DoF humanoid.\nOptimization-based methods using mixed-integer programming were developed to address the limitations of abstraction-based methods [1]. MICP methods typically do not require any abstraction, and consider the state (or configuration) space directly. Continuous variables represent the state at discrete time steps along the path. Binary variables and additional constraints are added to enforce the specification [20, 1]. The MICP approach is sound, complete, and (unlike automata-based methods) allows for guarantees of global optimality. MICP is particularly popular for STL [20, 2], but has also been applied to LTL [21], MTL [2], and a variety of other temporal logics. MICP is widely considered to be the state-of-the-art in temporal logic motion planning [1].\nNonetheless, MICP methods have some significant limitations. New binary variables are introduced for each subformula (or predicate) for each time step. This means that the computational complexity is exponential not only in the size of the formula, but also in the number of time steps. Making matters worse, too few timesteps can lead to clipping and pass-through problems, where the path intersects obstacles between timesteps (Fig. 2a).\nMitigating these limitations is an area of much active research. [22] uses a control-barrier function between time steps to avoid clipping and pass-through. [23] and [24] reduce the size of the MICP, but are still left with exponential complexity in the number of time steps. [4] formulates an MICP based on piecewise linear paths, accounting for constraint satisfaction between time steps. [4] is a significant source of inspiration for us, and our use of Bezier splines to represent smooth paths is a generalization of this idea. In addition to allowing us to place constraints on the whole path, not just\n4 the sample points, Bezier splines allow us to enforce dynamic feasibility for differentially flat systems, as well as to optimize for quantities like path length, velocity, and acceleration.\nAs an alternative way to make MICP more efficient, we proposed a formulation with more binary variables but a tighter convex relaxation in [2], resulting in better branch-and-bound solver performance in practice. The results in this paper are a substantial improvement on that basic idea. Our proposed approach results in an MICP with an even tighter convex relaxation: so tight, in fact, that it can be solved with convex optimization and rounding [6]. Interestingly, it is only through connections with older automata-theoretic methods that we are able to formulate this efficiently-solvable MICP. In this sense, we believe that our proposed approach brings together the best of automata-based and MICP-based methods.\nFinally, we acknowledge the recent trend of attempting to avoid the NP-hardness of temporal logic motion planning altogether by providing approximate solutions via non-convex optimization [25, 26, 27, 28], learning [29, 30], or control barrier functions [31, 32]. While such approaches can be extremely efficient and may be practical for some applications, they offer limited or no completeness guarantees and rarely scale to very complex specifications like that shown in Fig. 1a."
        },
        {
            "heading": "III. PROBLEM FORMULATION",
            "text": ""
        },
        {
            "heading": "A. Linear Temporal Logic",
            "text": "In this section, we introduce the basics of LTL. Further details can be found in [8] and [9].\nThe syntax, or grammar, of LTL is defined as follows:\n\u03c6 := \u22a4 | a | \u00ac\u03c6 | \u03c61 \u2227 \u03c62 | \u20dd\u03c6 | \u03c61U\u03c62, (1)\nwhere \u22a4 denotes \u201ctrue\u201d, a is an atomic proposition from the set AP , \u00ac (\u201cnot\u201d) is the negation operator, \u2227 (\u201cand\u201d) is the conjunction operator, \u20dd is the \u201cnext\u201d temporal operator, and U is the \u201cuntil\u201d temporal operator. These operators can be combined to form new operators like \u201cor\u201d (\u03c61 \u2228 \u03c62 = \u00ac(\u00ac\u03c61 \u2227 \u00ac\u03c62)), \u201ceventually\u201d (\u2662\u03c6 = \u22a4U\u03c6), and \u201calways\u201d (\u25a1\u03c6 = \u00ac\u2662\u00ac\u03c6).\nThe semantics, or meaning, of LTL is defined over sequences of atomic propositions called words:\nDefinition 1. A word \u03c3 = A0, A1, A2, . . . is a sequence of atomic propositions, where Ai \u2208 2AP is a set of atomic propositions. We denote the suffix beginning at index j as \u03c3[j . . . ] = Aj , Aj+1, . . . .\nWith this in mind, LTL semantics are defined recursively as follows, where we denote the fact that a word \u03c3 satisfies an LTL formula \u03c6 with \u03c3 \u22a8 \u03c6:\n\u2022 \u03c3[j . . . ] \u22a8 \u22a4. \u2022 \u03c3[j . . . ] \u22a8 a if and only if a \u2208 Aj .\n\u2022 \u03c3[j . . . ] \u22a8 \u03c61 \u2227 \u03c62 if and only if \u03c3[j . . . ] \u22a8 \u03c61 and \u03c3[j . . . ] \u22a8 \u03c62. \u2022 \u03c3[j . . . ] \u22a8 \u00ac\u03c6 if and only if \u03c3[j . . . ] \u22ad \u03c6. \u2022 \u03c3[j . . . ] \u22a8 \u20dd\u03c6 if and only if \u03c3[j + 1 . . . ] \u22a8 \u03c6. \u2022 \u03c3[j . . . ] \u22a8 \u03c61U\u03c62 if and only if \u2203k \u2265 j such that\n\u03c3[k . . . ] \u22a8 \u03c62 and \u03c3[i . . . ] \u22a8 \u03c61 for all j \u2264 i < k.\nFull LTL, as defined above, is evaluated on infinite length words \u03c3 \u2208 (2AP )\u03c9 . An important subset, or fragment, of LTL is the set of syntactically co-safe formulas:\n\u03c6 := \u22a4 | a | \u00aca | \u03c61\u2227\u03c62 | \u03c61\u2228\u03c62 | \u20dd\u03c6 | \u03c61U\u03c62. (2)\nSatisfaction of such a co-safe formula can be uniquely determined by a finite-length word. This fragment is of particular interest for motion planning problems, since most motion plans are of finite length. Infinite words can be relevant to motion planning, however, if plans contain loops: for example, \u03c6 = \u25a1\u2662a might specify that a robot must visit a recharging station labeled \u201ca\u201d infinitely often. In this paper, we present motion planning algorithms for both the co-safe fragment and full LTL, though we are able to provide the strongest completeness and optimality guarantees only for co-safe formulas.\nThe final aspect of LTL that we will highlight here is its relationship with automata. In short, any LTL formula can be transformed into a Deterministic Buchi Automaton (DBA), and any co-safe LTL formula can be transformed into a Deterministic Finite Automaton (DFA). These are defined as follows:\nDefinition 2. An deterministic automaton is a tuple A = (Q, q0,\u03a3, \u03b4, F ), where\n\u2022 Q is a set of states, \u2022 q0 \u2208 Q is an initial state, \u2022 \u03a3 is an input alphabet, \u2022 \u03b4 : Q\u00d7 \u03a3 \u2192 Q are transition relations \u2022 F \u2286 Q is a set of accepting states"
        },
        {
            "heading": "If A is a DFA, any accepting run must end at a state in F . If A is a DBA, any accepting run must visit F infinitely often.",
            "text": "An example of an LTL formula and a corresponding automaton is shown in Figure 4. Only those words that satisfy the LTL formula are accepted as inputs to the automaton. The initial state is (1), while the accepting state (2) is marked with a double circle.\nDetails of the conversion process between LTL and DFA/DBA can be found in [9, 8]. While the worst-case complexity for this conversion is double-exponential in the size of the LTL formula, mature model-checking software is available which can perform the conversion fairly rapidly for modestly sized formulas [8, 33, 34].\n5"
        },
        {
            "heading": "B. LTL Motion Planning",
            "text": "To apply LTL formulas to motion planning, we assume that a set of labeled convex sets in the robot\u2019s configuration space is given. More formally, we use X to denote a set of convex regions of the robot\u2019s configuration space, Xi \u2286 Rn. We also define L : X \u2192 2AP as the mapping from these regions to a set of atomic propositions. The label L(Xi) indicates which atomic propositions hold in region Xi. This label applies to every configuration in Xi. It it possible that no atomic propositions hold at a given region, i.e., L(Xi) = \u2205, and the regions may or may not overlap. Additionally, the set of labeled regions need not cover the entire configuration space.\nInformally, our goal is to find a path in configuration space that satisfies a given specification. More formally, we define LTL satisfaction for a path as follows:\nDefinition 3. A path p : R+ \u2192 Rn is a mapping from time t \u2208 R+ to configuration1 q \u2208 Rn, such that qt = p(t) is the system configuration at time t.\nDefinition 4. The trace of path p is the sequence of labels L(Xi) associated with the regions Xi visited by p, i.e., trace(p) = L(X0), L(X1), . . . .\nIn this way, we can say that a path p satisfies a specification \u03c6 if trace(p) \u22a8 \u03c6."
        },
        {
            "heading": "C. Problem",
            "text": "With this notion of path satisfaction in mind, we present a formal problem statement as follows:\nProblem 1. Given an initial configuration q0, convex regions X , labels L, and an LTL specification \u03c6, find a\n1Systems where the configuration space is not Rn could be considered if we represent paths with generalized Bezier splines [35, 36]. It is often the case for differentially flat systems, however, that even if the configuration space is non-Euclidean, flat outputs are in Rn [19].\nminimum-cost path that satisfies the specification, i.e.,\nmin p J(p) (3a)\ns.t. trace(p) \u22a8 \u03c6, (3b)\np \u2208 Cd, d \u2265 0, (3c) p(0) = q0. (3d)\nThe cost J can be any convex function of the path p or its time derivatives. For example, it might be desirable to minimize path length or snap (second derivative of acceleration) [37]. A variety of costs which are are convex in our parameterization of p are discussed in Section V-A. The constraint p \u2208 Cd ensures d-times continuous differentiability, allowing us to enforce dynamical feasibility for any differentially flat system [19]."
        },
        {
            "heading": "IV. BACKGROUND",
            "text": ""
        },
        {
            "heading": "A. Bezier Curves",
            "text": "To solve the optimization problem (3) numerically, we need to somehow represent the continuous path p with a finite set of points. The standard approach in the temporal logic literature is to discretize the path, considering its value only at regularly spaced sample points [1]. But, as discussed in Section II, this sort of discretization leads to clipping and pass-through problems.\nIn this paper, we parameterize the path p with a sequence of Bezier curves (i.e., a Bezier spline). A Bezier curve b : [0, 1] \u2192 Rn is defined by\nb(s) = k\u2211 i=0 ( k i ) (1\u2212 s)k\u2212isi\u03b3i, (4)\nwhere k is the order and \u03b3i \u2208 Rn are the k + 1 control points. Note that piecewise linear paths, such as those considered in [4], are a special case where k = 1.\nBezier curves have numerous appealing properties, and indeed they have been widely used in the robotic motion planning literature [38], though they are less common in the context of temporal logic:\n\u2022 A Bezier curve of order k is differentiable k \u2212 1 times. \u2022 The time derivative of a Bezier curve is another Bezier curve. \u2022 Bezier curves can be lined up to form a path (spline) by placing constraints on their control points, i.e., the last control point of the previous segment must be equal to the first control point of the next segment. Similar constraints can be applied to enforce a desired degree of differentiability. \u2022 A Bezier curve is contained in the convex hull of its control points.\nFigures 2, 3, and 7 show such Bezier splines. Control points are illustrated with red dots connected by dotted lines, while the path is shown in solid blue.\n6"
        },
        {
            "heading": "B. Graphs of Convex Sets",
            "text": "The computational workhorse behind our proposed approach is Graphs of Convex Sets (GCS), a framework first introduced in [5] and applied to standard motion planning problems (reach a goal and avoid obstacles) in [6]. In this work, we are heavily inspired by [6], and show that the promising computational attributes of GCS can be applied to motion planning problems much more complex than the classical reach-avoid problem. In particular, we show that LTL motion planning can be cast as a shortest path problem in a GCS, which can be solved efficiently using tools developed in [5, 6].\nIn short, the GCS framework aims to find the shortest path in a graph, where each vertex of the graph is associated with a convex set, and path lengths depend on which point in the set is chosen. A simple illustration can be found in [5, Fig. 1]. More formally, a GCS is defined as follows:\nDefinition 5. A Graph of Convex Sets G = (V, E) is a directed graph where\n\u2022 V is a set of vertices, \u2022 Each vertex v \u2208 V is associated with a convex set\nXv and a point xv \u2208 Xv , \u2022 E \u2282 V \u00d7 V is a set of edges, \u2022 Each edge e = (u, v) \u2208 E is associated with a\nconvex non-negative length function le(xu, xv) and (optionally) a convex constraint (xu, xv) \u2208 Xe.\nGiven a GCS, the goal is to find a minimium-cost path from a source vertex v0 \u2208 V to a target vertex vT \u2208 V . Defining a path \u03be as a sequence of vertices, denoting the set of all paths that connect v0 and vT as \u039e, and denoting as E\u03be the set of edges traversed by path \u03be, we can state this problem formally as follows:\nmin \u2211\ne=(u,v)\u2208E\u03be\nle(xu, xv) (5a)\ns.t. \u03be \u2208 \u039e (5b) xv \u2208 Xv \u2200v \u2208 p (5c) (xu, xv) \u2208 Xe \u2200e = (u, v) \u2208 E\u03be. (5d)\nThis problem turns out to be NP-hard in general, and but an efficient MICP encoding (using perspective functions and harnessing graph-theoretic connections) was proposed in [5]. This MICP has a very tight convex relaxation, meaning it is fairly close to convex optimization and tends to be efficiently solved by branchand-bound solvers. The convex relaxation is so tight, in fact, that good solutions can often be found with a combination of convex optimization and rounding [6]. When convex optimization is used in this way, it is possible to bound the optimality gap without solving a full MICP [6, Section 4.2], and convex optimization is\noften able to find a globally optimal solution\u2014such is the case with the example in Fig. 1a.\nWhile there are many important details in the transcription of problem (5) into a convex program, we refer the interested reader to [5, 6] for these details. In this paper, we use the GCS tools provided in Drake [39]. With that in mind, our primary contribution is to show that Problem 1 can be rewritten as a GCS problem of the form (5): then existing tools can be used to solve (5) rapidly with convex programming."
        },
        {
            "heading": "V. LTL MOTION PLANNING AS A GRAPH OF CONVEX SETS",
            "text": "In this section, we present our main results on transforming an LTL motion planning problem into a GCS problem. Once we have a GCS problem of the form (5), we can solve (5) exactly using MICP or approximately using convex optimization and rounding.\nIn Section V-A we consider co-safe LTL formulas, a fragment which includes most specifications relevant to motion planning. In Section V-B we extend these result to full LTL formulas, considering infinite-length paths via loops."
        },
        {
            "heading": "A. Co-Safe Formulas",
            "text": "The basic idea, outlined in Algorithm 1, is as follows: first we construct a finite transition-system abstraction and convert the given co-safe LTL formula into a DFA. We then construct a graph of convex sets as the product of the transition system and the DFA. The shortest path in this product GCS corresponds to a minimum-cost path that satisfies the LTL specification.\nAlgorithm 1 Co-Safe LTL Motion Planning Require: spec \u03c6, regions X , labels L, initial state q0 TS = TransitionSystem(X , L) \u25b7 Def. 6 A = DFA(\u03c6) G = TS \u2297A \u25b7 Def. 7 p\u2217 = shortest path in G \u25b7 MICP or convex opt.\nreturn p\u2217\nThis procedure is very similar to, and indeed heavily inspired by, classical model checking approaches that also take a product between a DFA and a transition system, then perform graph search to certify satisfaction [8]. They key difference in this case is that the physical layout of the scenario and constraints on the continuous path are included in the product graph, which is a GCS. Existing automata-based LTL motion planning methods return a sequence of regions from graph search, and an additional low-level planner is needed to find a continuous path consistent with this sequence of regions [3, 10, 11]. Our approach, on the other hand, combines\n7 the automata-based handling of logical constraints and optimization-based consideration of a continuous path in one step, via the GCS framework.\nFirst, we construct a transition system from the given labeled convex regions as follows:\nDefinition 6. The transition system abstraction is a tuple TS = (S, s0,\u2192,L,P), where\n\u2022 S is a set of states corresponding to each region, \u2022 P : S \u2192 X is a mapping from states to convex sets\nin configuration space, \u2022 s0 is an initial state such that q0 \u2208 P(s0), \u2022 \u2192 is a transition relation, where s \u2192 s\u2032 if and only\nif P(s) \u2229 P(s\u2032) \u0338= \u2205, \u2022 L : S \u2192 2AP is a labeling function, L(s) =\nL(P(s)).\nNote that we define a transition whenever there is a non-empty intersection between regions. Intersecting regions may have significant overlap, or may simply be adjacent to one another.\nTo transform the LTL formula \u03c6 into a DFA A, we can use any one of a variety of existing software tools. In the examples of Section VII, we use the LTLf2DFA tool [33]. Further details on this conversion procedure can be found in [8, 9].\nThe final step is to formulate a GCS as the product of TS and A:\nDefinition 7. The product G = TS \u2297 A is a GCS as follows:\n\u2022 V = {S \u00d7Q, vT } are the vertices, \u2022 v0 = (s0, q0), \u2022 vT is an extra vertex, where edges (s, q) \u2192 vT exist\nonly if q \u2208 F , \u2022 other edges in E are such that (s, q) \u2192 (s\u2032, q\u2032)\nexists if and only if s \u2192 s\u2032 is a transition in TS, and \u03b4(q,L(s)) = q\u2032 is a transition in A, \u2022 Xv = P(s)k+1, where k is is the desired Bezier curve degree and Yk denotes the Cartesian power of convex set Y , \u2022 xv = [(\u03b3 v 0 ) T , (\u03b3v1 ) T , . . . , (\u03b3vk)\nT ]T are Bezier curve control points associated with vertex v, \u2022 Xe are defined such that \u03b3uk = \u03b3v0 , ensuring continuity of adjacent Bezier curves. Similar constraints are applied to control points for the derivatives of the Bezier curve, up to a desired degree of smoothness.\nThe basic idea is to define a vertex for each unique pair of states in the DFA and the TS. Edges connect vertices only if corresponding edges exist in both the DFA and the TS: this ensures that both the physical constraints of the scenario and the logical constraints from the LTL formula are met. The target state vT is defined such that any path to vT must first pass through an accepting state\n(F ) of the DFA, enforcing satisfaction of the formula. The convex set Xv for each vertex corresponds to a convex region. The continuous variables xv \u2208 Xv are the control points of a Bezier curve that is constrained to lie within the corresponding region. Edge constraints Xe ensure that control points of adjacent states line up, forming a continuous and smooth path.\nDefined in this way, any path from v0 to vT in the GCS G corresponds to a smooth Bezier spline in configuration space, and is guaranteed to satisfy the given co-safe LTL specification.\nThe last step is to define edge lengths le(xu, xv), which corresponds to setting the path cost J(p) in (3). While any convex function could be used, an approximation of the Bezier curve length such as\nle(xu, xv) = k\u2211 i=0 \u2225\u03b3ui \u2212 \u03b3ui+1\u2225 (6)\nis particularly appealing. If \u2225 \u00b7 \u2225 is chosen to be the L2 norm, then J(p) is a strict overapproximation of the actual path length, with the approximation typically growing tighter the more control points are used. For very large-scale problems, it may be more appealing to choose \u2225 \u00b7 \u2225 as the L1 norm. While this gives a looser approximation of the path length, the resulting convex programs are Linear Programs (LPs) rather than Second Order Cone Programs (SOCPs) [5], for which numerical solvers are more mature and scalability can be improved. Since the derivative of a Bezier curve is another Bezier curve, a similar procedure can be applied to add cost terms related to the time derivatives of the path."
        },
        {
            "heading": "B. Full LTL",
            "text": "To consider full LTL specifications, we need to somehow reason about infinite-length paths with a finite number of decision variables. Again inspired by the model checking literature, we choose to represent such infinite paths with loops [9], e.g.,\n\u03c3 = A0, A1, . . . , Ak, (B0, B1, . . . , Bl) \u03c9. (7)\nThis representation allows us to consider infinite behavior by searching for two finite paths: a prefix that is executed once and a suffix that repeats forever.\nMuch of the machinery developed in Section V-A above can be applied directly to the full LTL case. We can similarly define a transition system TS, convert the LTL formula \u03c6 into a DBA (rather than a DFA) AB , and compute a GCS as the product G = TS \u2297AB .\nThe key difference is the acceptance condition for a DBA. For a DBA, it is not sufficient to simply reach an accepting state: we must both reach an accepting state and find a loop that visits the accepting state infinitely\n8 often. This loop corresponds to the second finite path, with trace B0, B1, . . . , Bl.\nWe address this problem by breaking down the solution into two separate GCS solves. This procedure is outlined in Algorithm 2. The first solve is identical to the procedure for co-safe formulas outlined above: we simply find a path from the initial state to an accepting state. The trace of this path is the first finite word A0, A1, . . . , Ak. The second GCS solve looks for a loop that starts and ends with the same Bezier curve segment as the first solve. The trace of this loop corresponds to the repeated finite word B0, B1, . . . , Bl. Concatenating these two paths provides an infinite-length path with a loop that satisfies the specification.\nAlgorithm 2 Full LTL Motion Planning Require: spec \u03c6, regions X , labels L, initial state q0\nTS = TransitionSystem(X , L) AB = DBA(\u03c6) G = TS \u2297AB while G contains accepting states do\np1 = shortest path in G from v0 to vT vF = (sF , qF ), qF \u2208 F is accepting state from p1 p2 = shortest path in G from vF to vF if p2 \u0338= \u2205 then\nreturn p\u2217 = p1 \u00b7 p2 else\nG.pop(vF ) \u25b7 Remove vF and try again end if\nend while return no solution found\nIt may be possible that the first GCS solve returns a path from which no loops are possible, even though another initial path might admit a valid loop. In this case, we take a CEGIS-inspired approach, discarding the accepting state used in the first GCS solve and attempting to re-solve the problem. As explored in further detail in Section VI, this procedure comes with less satisfying formal guarantees than the procedure for co-safe formulas.\nNonetheless, this two-step procedure is able to find solutions for full LTL specifications like that shown in Fig. 5. In that example, the specification\n\u03c6 = \u25a1(\u2662a \u2227 \u2662b) (8)\nrequires a mobile robot to visit two regions infinitely often. The first segment, p1, drives the robot to visit regions a and b, reaching an accepting state of the automaton AB . The second segment, p2, forms a loop and lines up with p1 in region b."
        },
        {
            "heading": "VI. THEORETICAL ANALYSIS",
            "text": "In this section, we provide a formal analysis of the soundness, completeness, and computational complexity\n(a) p1 (b) p2 (c) p\u2217\nFig. 5: A solution to the LTL specification (8), which requires the robot to visit both regions a and b infinitely often, and is not part of the co-safe fragment.\nof our proposed approach. In short, our method is sound and complete for co-safe LTL formulas, sound for general LTL formulas, has double exponential complexity in the formula size, polynomial complexity in the number of control points, and polynomial complexity in the configuration space dimension.\nIn all of this analysis, there are four cases to consider, since we can have co-safe or general LTL formulas, and we can solve the GCS problem with either MICP or convex optimization and rounding."
        },
        {
            "heading": "A. Soundness",
            "text": "In this section we consider soundness. An LTL motion planner is sound if every motion plan returned by the planner satisfies the given specification.\nSoundness is a relatively easy property to ensure, and our proposed approach is sound regardless of whether co-safe or full LTL formulas are used, and regardless of whether the GCS problem is solved with MICP or convex optimization.\nTheorem 1 (Soundness for co-safe LTL formulas). If Algorithm 1 returns a non-empty path p for co-safe LTL specification \u03c6, then trace(p) \u22a8 \u03c6.\nProof. By construction of the GCS G (Def. 7), any path in G that reaches the target vertex vT corresponds to a path in the DFA A that reaches an accepting state qF \u2208 F . By the relationship between LTL formula \u03c6 and the DFA A, this means that the continuous path p travels through a sequence of regions such that the corresponding sequence of labels satisfies \u03c6. Thus the theorem holds, regardless of whether MICP or convex programming is used to find such a path.\nTheorem 2 (Soundness for full LTL formulas). If Algorithm 2 returns a non-empty path p given LTL specification \u03c6, then trace(p) \u22a8 \u03c6.\nProof. By construction of the GCS G, any solution to the two-step procedure of Algorithm 2 corresponds to a path that reaches an accepting state qF \u2208 F in the DBA AB and loops back to qF . Therefore the path visits\n9 F infinitely often, satisfying the specification. Thus the theorem holds, regardless of whether MICP or convex programming is used to find such a path.\nIt is worth noting that these soundness properties apply to the whole path p, not just predefined sample points. This is a notable improvement over much prior work on temporal logic motion planning in discrete time [1, 8], where clipping between time samples might falsify the specification (e.g., lead to a collision with obstacles). Our method guarantees that each Bezier curve segment is completely contained in a single region, eliminating this soundness gap."
        },
        {
            "heading": "B. Completeness",
            "text": "In this section we consider the completeness of Algorithms 1 and 2. An LTL motion planner is complete if it always finds a solution when one is available. The completeness guarantees in this section are posed over a given set of convex regions: optimal decomposition of configuration space into labeled convex regions remains an important area for future research.\nWe first consider the case of a co-safe LTL specification where MICP is used to solve the GCS subproblem. This case offers the strongest completeness guarantees under relatively modest assumptions:\nTheorem 3 (Completeness for co-safe LTL with MICP). Assume that there exists a satisfying Bezier spline solution of the desired degree and smoothness, and that the control points of each segment are each contained within a single region. If MICP is used to solve the GCS subproblem, then Algorithm 1 will return a path that satisfies the given co-safe LTL specification.\nProof. By construction of the GCS G (Def. 7), if a satisfying path exists then there exists a path from v0 to vT in G. This follows from the relationship between the specification \u03c6 and the automaton A. By [5, Theorem 5.6], the MICP used to solve (5) is guaranteed to find the optimal path from v0 to vT .\nThe primary assumption required for this theorem merits some discussion. It may be the case that a satisfying path exists, but it cannot be represented by a Bezier spline of the desired degree and smoothness. It could also be the case that a Bezier spline solution exists, but requires control points that lie outside a region. In either of these cases, Algorithm 1 may fail to find a solution even though one exists.\nFortunately, there is a simple practical fix to this problem: increase the number of control points, and/or reduce the desired smoothness. Increasing the number of control points adds additional flexibility, and typically brings control points closer to the path. Reducing the\nsmoothness (e.g. C1 rather than C2) eliminates some of the constraints on the control points, and may similarly allow for solutions that were previously unavailable.\nIn the case of co-safe LTL specifications where convex optimization and rounding are used to solve the GCS subproblem, we can certify probabilistic completeness:\nTheorem 4 (Completeness for co-safe LTL with Convex Optimization). Assume that there exists a satisfying path made up of Bezier curve segments of desired degree and continuity, and that the control points of each segment are contained within a single region. Furthermore, assume that the convex relaxation of the GCS subproblem assigns nonzero values to binary variables on the optimal path. If the convex optimization and rounding scheme described in [6] is used to solve the GCS subproblem, then Algorithm 1 will return a path p that satisfies the given co-safe LTL specification with probability 1 as the number of rounding iterations approaches infinity.\nProof. By construction of the GCS G (Def. 7), if a satisfying path exists then there exists a path from v0 to vT in G. This follows from the relationship between the specification \u03c6 and the automaton A. The rounding scheme described in [6, Section 4.2] treats the values of binary variables from the convex relaxation as probabilities, and performs rounding as a randomized depth-first search with backtracking. As the number of rounding iterations approaches infinity, this procedure will eventually explore all possible paths in G with probability 1. If the convex relaxation of (5) is not feasible, then the MICP is not feasible and no solution exists (by Theorem 3).\nRemark 1. The assumption of nonzero values for binary variables on the optimal path is minimally restrictive in practice. In fact, branch-and-bound MICP solvers often prune branches based on integer-valued binary variables in the convex relaxation [40].\nIn practice (see the examples in Section VII), the gap between convex optimization and MICP is quite small. For all of the examples considered in this paper, convex optimization was able to find a satisfying solution\u2014if not a certified globally optimal solution\u2014with only a few (< 10) rounding iterations.\nFor full-LTL specifications, the necessity of finding a loop makes any completeness guarantees significantly more limited. Nonetheless, we can guarantee completeness under a set of more restrictive assumptions:\nTheorem 5. Assume that the conditions for Theorem 3 hold. Furthermore, assume that for at least one accepting state v = (s, q), q \u2208 F in the GCS G, every Bezier curve b contained in Xv admits a loop through G that\n10\nstarts and ends with b. Then Algorithm 2 will return a satisfying path.\nProof. By Theorem 3, Algorithm 2 will eventually find a path p1 that reaches the special accepting state v. If Algorithm 2 finds a path p1 to an accepting state v\u2032 that does not admit a loop for every Bezier curve in Xv\u2032 , then v\u2032 will be removed from the graph and a new p1 computed. Once a suitable p1 is found, a loop p2 is similarly guaranteed to be found by Theorem 3 and the assumption that a loop exists. The complete path p\u2217 = p1 \u00b7 p2 corresponds to visiting the accepting set F infinitely often, thus the Theorem holds.\nProbabilistic completeness guarantees can be obtained for the full LTL case when convex optimization is used instead of MICP, following similar reasoning to Theorem 4.\nThe extra assumption that every Bezier curve in at least one accepting state admit a loop is needed to ensure that the CEGIS-inspired procedure in Algorithm 2 eventually returns a solution. The assumption that every Bezier curve admit a loop is particularly restrictive\u2014 it may be the case that a loop (p2) is possible, but not from the starting Bezier curve segment that ends p1. This restriction is necessary because the GCS framework does not allow for constraints between continuous variables xv that are not connected by an edge. This means that to find a loop, we must constrain the initial and final continuous variables x0 and xT to some a-priori fixed values."
        },
        {
            "heading": "C. Complexity",
            "text": "In this section, we formally characterize the computational complexity of our proposed approach, focusing on the case where the GCS subproblem is solved with convex optimization and rounding, as described in [6].\nAt first glance, it may appear that since LTL motion planning is NP-hard, convex optimization is solvable in polynomial time, and we solve LTL motion planning with convex optimization, we have shown that P = NP . We emphasize that this is not the case for two reasons: first, convex optimization provides only an approximate solution to the GCS subproblem, which is itself NPhard [5]. Second, and more importantly, the size of the automaton A is double exponential in the size of the LTL formula \u03c6, resulting in a GCS G which is also double exponential in the size of the LTL formula.\nTheorem 6. Given the GCS G, the time complexity of finding an approximate solution to the shortest path problem with convex optimization is O(22 |\u03c6| ), where |\u03c6| is the size of \u03c6.\nProof. The conversion of \u03c6 to automaton A results in an automaton with O(22 |\u03c6| ) states [8], so the GCS G has\nO(22 |\u03c6|\n) vertices and edges. The convex optimization encoding of [6] results in an LP or SOCP with variables for each vertex and edge in G. Since LP and SOCP have polynomial time complexity in the number of decision variables [41], the overall time complexity is O(22 |\u03c6| ).\nWhile exponential complexity in the formula size is inevitable due to the NP-hardness of the problem, our proposed approach scales polynomially in a number of variables of practical interest:\nTheorem 7. Given the GCS G, the time complexity of finding an approximate solution to the shortest path problem with convex optimization is polynomial in k, the degree of each Bezier curve segment.\nProof. This follows from the fact that the number of decision variables increases linearly with k, and the convex optimization problem is an LP or SOCP which can be solved in polynomial time with interior point methods [41].\nThis means that the complexity is polynomial in the total number of control points \u03b3i used to represent a curve. This is in contrast to standard MICP-based methods, which scale exponentially in the number of sample points used to represent a path. In practice, we find that increasing the number of control points has little practical impact on solve times, see Fig. 6.\nTheorem 8. Given the GCS G, the time complexity of finding an approximate solution to the shortest path problem with convex optimization is polynomial in n, the dimension of the configuration space.\nProof. This follows from the fact that the number of decision variables increases linearly with n, and the convex optimization problem is an LP or SOCP which can be solved in polynomial time with interior point methods [41].\nThis is a key factor in enabling our approach to scale to high-dimensional configurations spaces, as explored in Section VII-C."
        },
        {
            "heading": "VII. EXAMPLES",
            "text": "In this section, we demonstrate the scalability of our proposed approach with several simulation examples. Code for reproducing these examples is available at [7]. All experiments were performed on a laptop with an Intel i7 CPU and 32GB RAM. The underlying convex optimization solver was MOSEK [42], accessed via Drake [39] Python bindings.\nSolve times for all of the examples are shown in Table I. In addition to the final solve time, we report the time converting the LTL specification \u03c6 to a DFA\n11\nA and time to form the GCS G = A\u2297 TS. Converting LTL to DFA can be particularly expensive for complex specifications due to the double exponential complexity of this operation [8].\nOf these steps, only the final solve is an online operation: all other steps can be performed offline and their results reused for different initial conditions. In all of the examples, we use convex optimization rather than MICP to solve the GCS problem."
        },
        {
            "heading": "A. Planar Motion Planning",
            "text": "In this section, we consider motion planning for a simple planar robot. As we consider path planning rather than trajectory planning, the particular dynamics of the robot are not used. We can, however, design paths with a desired degree of smoothness (see Section IV-A), ensuring feasibility for any differentially flat system [19].\nThe first example, shown in Fig. 3, illustrates the advantage of considering both logical constraints and scenario geometry at the same time (something that most automata-based methods struggle with). A mobile robot is tasked with eventually reaching one of two target regions, labeled a and b respectively:\n\u03c6 = \u2662(a \u2228 b). (9)\nAn abstraction-based motion planner such as [11] would likely choose the longer path to region a, since this requires fewer transitions in G. Our planner, on the other hand, finds the shorter path to target b directly.\nThe cost in this example is a simple penalty on path length (L2 norm of distance between control points). A Bezier curve of order k = 4 is used, and C2 continuity is enforced. Bezier control points are shown as red dots in Fig. 3, while the final path itself is in blue.\nIn the second planar motion example, illustrated in Fig. 2, the robot must pick up two keys (i.e., visit green regions labeled key1 and key2) in order to pass through corresponding doors (red, labeled door1 and door2) before eventually reaching a goal (blue, labeled goal). More formally, this specification can be written as an LTL formula\n\u03c6 = (\u00acdoor1Ukey1) \u2227 (\u00acdoor2Ukey2) \u2227 \u2662goal. (10)\nA more complicated version of this specification with five keys and five doors is shown in Fig. 1a. This benchmark example was first proposed in [3], where it was solved with an abstraction-based approach, though no solve times were reported. To the best of our knowledge, the fastest reported solve time for this benchmark is 49.5 seconds from [4]. [4] finds a piecewise linear path (avoiding clipping and pass-through) with MICP. Our proposed approach is roughly an order of magnitude faster (Table I), provided conversion from LTL to DFA and construction of the GCS is performed offline. Furthermore, the path generated with our approach is twice continuously differentiable and certified globally optimal. The extremely long time to convert from LTL to DFA is indicative of the double-exponential complexity of this operation [8].\nWe use the simpler key-door example (with two doors) to compare with standard MICP-based temporal logic motion planners, which consider a discretization of time rather than continuous-valued curves for motion planning. In particular, we compare with the MICP approach of [20] as implemented in the stlpy [24] python library2.\nThe standard MICP represents continuous paths with a pre-specified number of time steps. If too few time steps are used, clipping and pass-through problems can cause the path to intersect with obstacles between time steps, as illustrated in Fig. 2a. Our proposed approach, on the other hand, considers the whole curve, and therefore does not suffer from clipping or pass-through even if relatively few control points are used, as shown in Fig. 2b.\nTypically, clipping and pass-through are addressed by sampling the path more finely, using more time steps. Unfortunately, this leads to an exponential blowup in time-complexity for the standard approach. Our approach, on the other hand, scales only polynomially with the number of control points (Theorem 7). The practical impact of this fact is illustrated in Fig. 6.\nIn Fig. 6, we compare solve times for the standard MICP and our proposed approach, varying the number of time steps for the standard approach and the total number of control points used (the rough equivalent of time steps) for our method. Solve times for the standard MICP increase exponentially, as expected: using more than about 30 timesteps is impractical for this specification. Solve times for our proposed approach, on the other hand, stay roughly constant as the total number of control points increases. We can use as many as 90 control points\u201410 per Bezier curve segment in this example\u2014 with minimal impact on solve time.\nOur final planar motion planning example, illustrated in Fig. 7, showcases a more complex scenario as well as\n2While this library is for STL rather than LTL, the specification in question does not have active timing constraints, rendering the STL and LTL specifications equivalent.\n12\na specification that is not part of the co-safe fragment. The robot is tasked with eventually visiting regions labeled a, c, and d, while always avoiding b:\n\u03c6 = \u2662a \u2227\u25a1\u00acb \u2227 \u2662c \u2227 \u2662d. (11)\nThe always operator (\u25a1) means that this specification is not syntactically co-safe [8]. The final loop which renders infinite-length behaviors is trivial, however: the robot simply remains at the final configuration.\nThe GCS for this multi-target example is relatively large, and the shortest-path subproblem is a large and possibly poorly conditioned SOCP if an L2 norm approximation of the path length is used. We found that MOSEK [42] was unable to converge to a solution to\nthe SOCP in this case, returning an Solver Status: UNKNOWN error code. To avoid this, we used an L1 norm approximation of the path length (see Section V-A) instead. This leads to a LP rather than a SOCP, for which solvers are more mature and reliable. With this L1/LP formulation, MOSEK finds the solution shown in Fig. 7."
        },
        {
            "heading": "B. Comparison with Sampling-Based Motion Planning",
            "text": "For simple reach-avoid problems (a special case of LTL motion planning), GCS-based motion planning was shown to outperform sampling-based methods in [6]. In this section, we explore whether similar advantages hold for motion planning under LTL specifications.\nWe compare our proposed approach with the state-ofthe-art sampling-based planner described in [14]. This method is especially appealing because it does not require computing the product of a transition system and the specification automaton, but rather incrementally builds trees to explore the state-space of the product without constructing it explicitly.\nIn particular, we consider the example in [14, Section VII.A.]. This example ([14, Fig. 6]) has with six regions of interest (ri) and two obstacles (obs). The task is specified by the LTL formula\n\u03c6 = \u2662(r1 \u2227 \u2662r3) \u2227 (\u00acr1Ur2)\u2227 \u2662(r5 \u2227 \u2662(r6 \u2227 \u2662r4)) \u2227 (\u00acr4Ur5) \u2227\u25a1\u00acobs. (12)\nThis specification requires a mobile robot to do the following: eventually visit region r1, then r3; not visit r1 until visiting r2; eventually visit r5, r6, and r4 in that order; not visit r4 before r5; and avoid obstacles.\nTo compare our approach and [14], we randomly generated 100 initial positions and solved the motion planning problem using our approach and samplingbased planning. For the sampling-based planner we used a maximum of nmax = 1000 iterations and default parameters from the implementation provided with [14]. For our approach, we solved for a first order Bezier spline with an L2 norm penalty on path length and performed a single rounding iteration. A histogram of solve times is shown in Fig. 8. For both approaches, we exclude the time needed to construct an automaton, as this can be performed offline.\nSolve times for our proposed approach were both faster on average (mean of 0.30 vs 0.69 seconds) and more consistent (standard deviation of 0.024 vs 0.52 seconds) than the sampling based approach, though there were some initial conditions for which the samplingbased method found a solution faster."
        },
        {
            "heading": "C. High-DoF Systems",
            "text": "Our proposed approach scales well to highdimensional configuration spaces. To demonstrate this,\n13\nwe consider the 7-DoF model of a Franka Panda arm shown in Fig. 9 and the 30-DoF model of an Atlas humanoid shown in Fig. 10. Both models are from Drake [39].\n1) 7-DoF Manipulator: The arm is tasked reaching a target configuration that places its end-effector through a doorway (red box), but it must press a button (blue half circle) before passing through the doorway. This specification can be written as\n\u03c6 = \u2662target \u2227 \u00acdoorwayUbutton. (13)\nLabeled collision-free convex polytopes in configuration space were generated using C-IRIS [43], as implemented in Drake [39].\nOur proposed approach offers considerable performance improvements over state-of-the-art methods for temporal logic motion planning in large configuration spaces. In prior work [28], we showed how non-convex trajectory optimization could be used to solve temporal logic motion planning for a similar 7-DoF robot arm, and solved a relatively simple specification (\u2662(a\u2228 b)) in 160 seconds. In contrast, the considerably more complex specification (13) is solved by our proposed approach in about a second.\n2) 30-DoF Humanoid: The Atlas humanoid is tasked with reaching three target boxes, shown in green, blue, and red in Fig. 1b. We use inverse kinematics and C-IRIS [43] to define labeled convex regions of configuration space corresponding to (a) the left hand touching the green target, (b) the right foot touching the red target, and (c) the right hand touching the blue target. We also define an unlabeled convex region without kinematic constraints (d). Seed configurations used to generate these convex sets are shown in Fig. 10.\nThe specification is then given by\n\u03c6 = \u2662(a \u2227 \u2662(b \u2227 \u2662c)), (14)\nwhich states that the robot should eventually reach targets a, b, and c, in that order.\nWe fix the pose of the pelvis in the world frame, and do not consider contact interactions with the ground. Balance, contact wrench cone, or other dynamic feasibility constraints are not considered: our goal is merely to find a configuration space path that satisfies the specification. Without a floating base, this is a 30-DoF system.\nWe search for a satisfying path using Bezier splines of degree k = 3 and enforce C2 smoothness. In addition to an L2 norm penalty on path length, we add a small penalty on configuration space accelerations. As shown in Table I, a locally optimal path is found in 7.72 seconds."
        },
        {
            "heading": "VIII. LIMITATIONS",
            "text": "In this section, we provide a brief overview of the limitations of our proposed approach along with concrete suggestions for mitigating these limitations in practice.\nA major drawback is the double-exponential complexity of converting LTL formulas to automata [8]. This limitation is illustrated most clearly in Table I, where conversion to a DFA takes over half an hour for the complex key-door scenario. We performed this conversion using the LTLf2DFA python library [33], which uses MONA [34] to perform the underlying conversion. While it is possible that other model checking software (see [8] for a list) might be more performant, any such conversion software will run up against the fundamental double exponential complexity of this conversion.\nTo mitigate this issue in practice, we note that conversion to an automaton and construction of the GCS can be performed offline if the labeled regions and specification are known a-priori. Any initial condition can be used with this offline-computed GCS: only the initial vertex v0 = (s0, q0) will change. Given a GCS, convex optimization solve times tend to be relatively fast (on the order of seconds), even for specifications where the conversion to an automaton was extremely slow.\nA related limitation is the need for labeled convex regions. For simple planar scenarios like those in Section VII-A this may be a reasonable expectation, but for more complex systems with high-dimensional configuration spaces, like the robot arm in Section VII-C, it is not always obvious how to obtain such labeled regions. Fortunately, there has been considerable recent progress in decomposition of free space into convex sets. Algorithms like IRIS [44], and C-IRIS [43], provide iterative procedures for inflating convex regions of free space. Such algorithms provide a convenient means of constructing labeled convex sets for high-dimensional\n14\nsystems. Efficiently generating convex regions from temporal logic labels directly remains an important area for future research.\nAnother drawback of this approach is that we consider path planning rather than trajectory planning. This means that satisfying paths do not consider the natural dynamics of the system and may not be dynamically feasible. The ability of Bezier splines to enforce a desired degree of smoothness, however, allows for dynamical feasibility to be enforced for any differentially flat system, a large class of systems that includes quadrotors [37] and differential-drive mobile robots [19].\nFrom a theoretical perspective, the convex optimization approach provides more limited guarantees than MICP, since convex optimization and rounding is not guaranteed to find a globally optimal solution. In prac-\ntice, however, this does not appear to be a significant concern. As of the time of writing, we have not come across any examples for which MICP finds a satisfying solution but convex optimization does not.\nFinally, we highlight the limited completeness guarantees available for for full LTL (non-co-safe) specifications (Theorem 5). This limitation ultimately stems from the difficulty of encoding loop constraints in the GCS framework. Nonetheless, many LTL specifications of practical interest for motion planning either fall within the co-safe fragment (9, 10, 13) or are not syntactically co-safe but have solutions with trivial loops (11)."
        },
        {
            "heading": "IX. CONCLUSION AND FUTURE WORK",
            "text": "We presented a convex optimization solution to temporal logic motion planning. The key idea is to convert the LTL motion planning problem into a shortest path problem in a graph of convex sets. This GCS problem can be solved exactly with mixed-integer programming, but also admits a practical approximate solution via convex optimization and rounding [5, 6].\nOur proposed approach scales to complex specifications (Fig. 1a) and high-dimensional configuration spaces (Fig. 9), and addresses many of the limitations of standard temporal-logic motion planning methods. We avoid the clipping and pass-through problems associated with discrete-time temporal logic formulations [45] by representing paths with Bezier splines. Unlike standard MICP-based approaches [20, 1, 4], our proposed approach does not scale exponentially with the number of sample points used to represent a path (Fig. 6). Unlike local optimization [25, 26, 27], learning-based [29, 30], or CBF-based [31] approaches, our proposed approach provides probabilistic completeness guarantees under modest assumptions.\nPotential areas of future work include extensions to multi-agent and distributed systems, extensions to timed temporal logics like STL and MTL, and use in a model predictive control framework.\n15"
        }
    ],
    "title": "Temporal Logic Motion Planning with Convex Optimization via Graphs of Convex Sets",
    "year": 2023
}