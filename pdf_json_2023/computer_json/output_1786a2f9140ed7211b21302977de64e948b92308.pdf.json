{
    "abstractText": "With the waning of Moore\u2019s law, optimizing program performance has become a major focus of software research. However, high-level optimizations such as API and algorithm changes remain elusive due to the difficulty of understanding the semantics of code. Simultaneously, pretrained large language models (LLMs) have demonstrated strong capabilities at solving a wide range of programming tasks. To that end, we introduce a framework for adapting LLMs to high-level program optimization. First, we curate a dataset of performance-improving edits made by human programmers of over 77 K competitive C++ programming submission pairs, accompanied by extensive unit tests. A major challenge is the significant variability of measuring performance on commodity hardware, which can lead to spurious \u201cimprovements\u201d. To isolate and reliably evaluate the impact of program optimizations, we design an environment based on the gem5 full system simulator, the de facto simulator used in academia and industry. Next, we propose a broad range of adaptation strategies for code optimization; for prompting, these include retrieval-based few-shot prompting and chain-of-thought, and for finetuning, these include performanceconditioned generation and synthetic data augmentation based on self-play. A combination of these techniques achieves an average speedup of 5.65\u00d7 on CodeLlama-13B and 6.86\u00d7 on GPT-3.5, surpassing the best human performance (4.06\u00d7). We find our proposed performance-conditioned generation is particularly effective at improving performance as well as increasing the fraction of optimized programs.1",
    "authors": [
        {
            "affiliations": [],
            "name": "Alexander Shypula"
        },
        {
            "affiliations": [],
            "name": "Aman Madaan"
        },
        {
            "affiliations": [],
            "name": "Yimeng Zeng"
        },
        {
            "affiliations": [],
            "name": "Uri Alon"
        },
        {
            "affiliations": [],
            "name": "Jacob Gardner"
        },
        {
            "affiliations": [],
            "name": "Milad Hashemi"
        },
        {
            "affiliations": [],
            "name": "Graham Neubig"
        },
        {
            "affiliations": [],
            "name": "Parthasarathy Ranganathan"
        },
        {
            "affiliations": [],
            "name": "Osbert Bastani"
        },
        {
            "affiliations": [],
            "name": "Amir Yazdanbakhsh"
        }
    ],
    "id": "SP:fce28a81f3cf2d61a65792ef31705c3080696286",
    "references": [
        {
            "authors": [
                "REFERENCES Mansi Agnihotri",
                "Anuradha Chug"
            ],
            "title": "A Systematic Literature Survey of Software Metrics, Code Smells and Refactoring Techniques",
            "venue": "Journal of Information Processing Systems,",
            "year": 2020
        },
        {
            "authors": [
                "Alfred V Aho",
                "Ravi Sethi",
                "Jeffrey D Ullman"
            ],
            "title": "Compilers: Principles, Techniques, and Tools, volume 2",
            "venue": "Addison-wesley Reading,",
            "year": 2007
        },
        {
            "authors": [
                "David F Bacon",
                "Susan L Graham",
                "Oliver J Sharp"
            ],
            "title": "Compiler Transformations for High-Performance Computing",
            "venue": "CSUR,",
            "year": 1994
        },
        {
            "authors": [
                "Nathan Binkert",
                "Bradford Beckmann",
                "Gabriel Black",
                "Steven K. Reinhardt",
                "Ali Saidi",
                "Arkaprava Basu",
                "Joel Hestness",
                "Derek R. Hower",
                "Tushar Krishna",
                "Somayeh Sardashti",
                "Rathijit Sen",
                "Korey Sewell",
                "Muhammad Shoaib",
                "Nilay Vaish",
                "Mark D. Hill",
                "David A. Wood"
            ],
            "title": "The gem5 simulator",
            "venue": "SIGARCH Comput. Archit. News,",
            "year": 2011
        },
        {
            "authors": [
                "Aymeric Blot",
                "Justyna Petke"
            ],
            "title": "MAGPIE: Machine Automated General Performance Improvement via Evolution of Software, 2022",
            "venue": "URL https://arxiv.org/abs/2208.02811",
            "year": 2022
        },
        {
            "authors": [
                "Tom B Brown",
                "Benjamin Mann",
                "Nick Ryder",
                "Melanie Subbiah",
                "Jared Kaplan",
                "Prafulla Dhariwal",
                "Arvind Neelakantan",
                "Pranav Shyam",
                "Girish Sastry",
                "Amanda Askell"
            ],
            "title": "Language models are few-shot learners",
            "year": 2005
        },
        {
            "authors": [
                "Binghong Chen",
                "Daniel Tarlow",
                "Kevin Swersky",
                "Martin Maas",
                "Pablo Heiber",
                "Ashish Naik",
                "Milad Hashemi",
                "Parthasarathy Ranganathan"
            ],
            "title": "Learning to Improve Code Efficiency, 2022",
            "venue": "URL https://arxiv. org/abs/2208.05297",
            "year": 2022
        },
        {
            "authors": [
                "Lichang Chen",
                "Shiyang Li",
                "Jun Yan",
                "Hai Wang",
                "Kalpa Gunaratna",
                "Vikas Yadav",
                "Zheng Tang",
                "Vijay Srinivasan",
                "Tianyi Zhou",
                "Heng Huang"
            ],
            "title": "Alpagasus: Training a better alpaca with fewer data",
            "venue": "arXiv preprint arXiv:2307.08701,",
            "year": 2023
        },
        {
            "authors": [
                "Lili Chen",
                "Kevin Lu",
                "Aravind Rajeswaran",
                "Kimin Lee",
                "Aditya Grover",
                "Misha Laskin",
                "Pieter Abbeel",
                "Aravind Srinivas",
                "Igor Mordatch"
            ],
            "title": "Decision transformer: Reinforcement learning via sequence modeling",
            "venue": "Advances in neural information processing systems,",
            "year": 2021
        },
        {
            "authors": [
                "Chris Cummins",
                "Zacharias V Fisches",
                "Tal Ben-Nun",
                "Torsten Hoefler",
                "Michael FP O\u2019Boyle",
                "Hugh Leather"
            ],
            "title": "ProGraML: A Graph-based Program Representation for Data Flow Analysis and Compiler Optimizations",
            "venue": "In ICLR,",
            "year": 2021
        },
        {
            "authors": [
                "Daniel Fried",
                "Armen Aghajanyan",
                "Jessy Lin",
                "Sida Wang",
                "Eric Wallace",
                "Freda Shi",
                "Ruiqi Zhong",
                "Wen-tau Yih",
                "Luke Zettlemoyer",
                "Mike Lewis"
            ],
            "title": "Incoder: A Generative Model for Code Infilling and Synthesis",
            "venue": "ArXiv preprint,",
            "year": 2022
        },
        {
            "authors": [
                "Spandan Garg",
                "Roshanak Zilouchian Moghaddam",
                "Colin B. Clement",
                "Neel Sundaresan",
                "Chen Wu"
            ],
            "title": "DeepPERF: A Deep Learning-Based Approach For Improving Software Performance, 2022",
            "venue": "URL https://arxiv.org/abs/2206.13619",
            "year": 2022
        },
        {
            "authors": [
                "Prakhar Gupta",
                "Cathy Jiao",
                "Yi-Ting Yeh",
                "Shikib Mehri",
                "Maxine Eskenazi",
                "Jeffrey P Bigham"
            ],
            "title": "Instructdial: improving zero and few-shot generalization in dialogue through instruction tuning",
            "venue": "In Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing,",
            "year": 2022
        },
        {
            "authors": [
                "Patrick Haluptzok",
                "Matthew Bowers",
                "Adam Tauman Kalai"
            ],
            "title": "Language models can teach themselves to program better",
            "venue": "arXiv preprint arXiv:2207.14502,",
            "year": 2022
        },
        {
            "authors": [
                "Youssef Hamadi"
            ],
            "title": "Autonomous Search",
            "venue": "Combinatorial Search: From Algorithms to Systems,",
            "year": 2013
        },
        {
            "authors": [
                "Edward J Hu",
                "Yelong Shen",
                "Phillip Wallis",
                "Zeyuan Allen-Zhu",
                "Yuanzhi Li",
                "Shean Wang",
                "Lu Wang",
                "Weizhu Chen"
            ],
            "title": "Lora: Low-rank adaptation of large language models",
            "venue": "arXiv preprint arXiv:2106.09685,",
            "year": 2021
        },
        {
            "authors": [
                "Changwu Huang",
                "Yuanxiang Li",
                "Xin Yao"
            ],
            "title": "A Survey of Automatic Parameter Tuning Methods for Metaheuristics",
            "venue": "IEEE transactions on evolutionary computation,",
            "year": 2019
        },
        {
            "authors": [
                "Jeff Johnson",
                "Matthijs Douze",
                "Herv\u00e9 J\u00e9gou"
            ],
            "title": "Billion-scale similarity search with GPUs",
            "venue": "IEEE Transactions on Big Data,",
            "year": 2019
        },
        {
            "authors": [
                "Sam Kaufman",
                "Phitchaya Phothilimthana",
                "Yanqi Zhou",
                "Charith Mendis",
                "Sudip Roy",
                "Amit Sabne",
                "Mike Burrows"
            ],
            "title": "A Learned Performance Model for Tensor Processing Units",
            "venue": "Proceedings of Machine Learning and Systems,",
            "year": 2021
        },
        {
            "authors": [
                "Pascal Kerschke",
                "Holger H Hoos",
                "Frank Neumann",
                "Heike Trautmann"
            ],
            "title": "Automated Algorithm Selection: Survey and Perspectives",
            "venue": "Evolutionary computation,",
            "year": 2019
        },
        {
            "authors": [
                "Lars Kotthoff"
            ],
            "title": "Algorithm Selection for Combinatorial Search Problems: A Survey. Data mining and constraint programming: Foundations of a cross-disciplinary approach, 2016",
            "year": 2016
        },
        {
            "authors": [
                "Charles E Leiserson",
                "Neil C Thompson",
                "Joel S Emer",
                "Bradley C Kuszmaul",
                "Butler W Lampson",
                "Daniel Sanchez",
                "Tao B Schardl"
            ],
            "title": "There\u2019s plenty of room at the top: What will drive computer performance after moore\u2019s",
            "venue": "law? Science,",
            "year": 2020
        },
        {
            "authors": [
                "Jhe-Yu Liou",
                "Xiaodong Wang",
                "Stephanie Forrest",
                "Carole-Jean Wu"
            ],
            "title": "GEVO: GPU Code Optimization using Evolutionary Computation",
            "venue": "TACO,",
            "year": 2020
        },
        {
            "authors": [
                "Jiachang Liu",
                "Dinghan Shen",
                "Yizhe Zhang",
                "Bill Dolan",
                "Lawrence Carin",
                "Weizhu Chen"
            ],
            "title": "What Makes Good In-Context Examples for GPT-$3$? arXiv:2101.06804 [cs], 2021",
            "venue": "URL http://arxiv.org/ abs/2101.06804",
            "year": 2021
        },
        {
            "authors": [
                "Shayne Longpre",
                "Le Hou",
                "Tu Vu",
                "Albert Webson",
                "Hyung Won Chung",
                "Yi Tay",
                "Denny Zhou",
                "Quoc V Le",
                "Barret Zoph",
                "Jason Wei"
            ],
            "title": "The flan collection: Designing data and methods for effective instruction tuning",
            "venue": "arXiv preprint arXiv:2301.13688,",
            "year": 2023
        },
        {
            "authors": [
                "Ilya Loshchilov",
                "Frank Hutter"
            ],
            "title": "Decoupled weight decay regularization, 2019",
            "year": 2019
        },
        {
            "authors": [
                "Aman Madaan",
                "Niket Tandon",
                "Peter Clark",
                "Yiming Yang"
            ],
            "title": "Memory-assisted prompt editing to improve gpt-3 after deployment",
            "venue": "In Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing,",
            "year": 2022
        },
        {
            "authors": [
                "Daniel J Mankowitz",
                "Andrea Michi",
                "Anton Zhernov",
                "Marco Gelmi",
                "Marco Selvi",
                "Cosmin Paduraru",
                "Edouard Leurent",
                "Shariq Iqbal",
                "Jean-Baptiste Lespiau",
                "Alex Ahern"
            ],
            "title": "Faster sorting algorithms discovered using deep reinforcement learning",
            "year": 2023
        },
        {
            "authors": [
                "Charith Mendis",
                "Cambridge Yang",
                "Yewen Pu",
                "Dr Amarasinghe",
                "Michael Carbin"
            ],
            "title": "Compiler AutoVectorization with Imitation Learning",
            "venue": "Advances in Neural Information Processing Systems,",
            "year": 2019
        },
        {
            "authors": [
                "Tom Mens",
                "Tom Tourw\u00e9"
            ],
            "title": "A Survey of Software Refactoring",
            "venue": "IEEE Transactions on software engineering,",
            "year": 2004
        },
        {
            "authors": [
                "Swaroop Mishra",
                "Daniel Khashabi",
                "Chitta Baral",
                "Yejin Choi",
                "Hannaneh Hajishirzi"
            ],
            "title": "Reframing Instructional Prompts to GPTk\u2019s Language",
            "venue": "arXiv preprint arXiv:2109.07830,",
            "year": 2021
        },
        {
            "authors": [
                "Erik Nijkamp",
                "Bo Pang",
                "Hiroaki Hayashi",
                "Lifu Tu",
                "Huan Wang",
                "Yingbo Zhou",
                "Silvio Savarese",
                "Caiming Xiong"
            ],
            "title": "Codegen: An open large language model for code with multi-turn program synthesis",
            "venue": "ArXiv preprint,",
            "year": 2022
        },
        {
            "authors": [
                "Dorit Nuzman",
                "Ira Rosen",
                "Ayal Zaks"
            ],
            "title": "Auto-vectorization of Interleaved Data for SIMD",
            "venue": "ACM SIGPLAN Notices,",
            "year": 2006
        },
        {
            "authors": [
                "David Peter"
            ],
            "title": "hyperfine, 2023. URL https://github.com/sharkdp/hyperfine",
            "year": 2023
        },
        {
            "authors": [
                "Gabriel Poesia",
                "Alex Polozov",
                "Vu Le",
                "Ashish Tiwari",
                "Gustavo Soares",
                "Christopher Meek",
                "Sumit Gulwani"
            ],
            "title": "Synchromesh: Reliable code generation from pre-trained language models",
            "venue": "In International Conference on Learning Representations,",
            "year": 2021
        },
        {
            "authors": [
                "Ruchir Puri",
                "David Kung",
                "Geert Janssen",
                "Wei Zhang",
                "Giacomo Domeniconi",
                "Vladmir Zolotov",
                "Julian Dolby",
                "Jie Chen",
                "Mihir Choudhury",
                "Lindsey Decker",
                "Veronika Thost",
                "Luca Buratti",
                "Saurabh Pujar",
                "Shyam Ramji",
                "Ulrich Finkler",
                "Susan Malaika",
                "Frederick Reiss"
            ],
            "title": "Codenet: A large-scale ai for code dataset for learning a diversity of coding tasks",
            "venue": "arXiv preprint arXiv:2105.12655,",
            "year": 2021
        },
        {
            "authors": [
                "Baptiste Rozi\u00e8re",
                "Jonas Gehring",
                "Fabian Gloeckle",
                "Sten Sootla",
                "Itai Gat",
                "Xiaoqing Ellen Tan",
                "Yossi Adi",
                "Jingyu Liu",
                "Tal Remez",
                "J\u00e9r\u00e9my Rapin"
            ],
            "title": "Code llama: Open foundation models for code",
            "venue": "arXiv preprint arXiv:2308.12950,",
            "year": 2023
        },
        {
            "authors": [
                "Ohad Rubin",
                "Jonathan Herzig",
                "Jonathan Berant"
            ],
            "title": "Learning To Retrieve Prompts for In-Context Learning",
            "venue": "[cs],",
            "year": 2021
        },
        {
            "authors": [
                "Ohad Rubin",
                "Jonathan Herzig",
                "Jonathan Berant"
            ],
            "title": "Learning to retrieve prompts for in-context learning",
            "venue": "In Proceedings of the 2022 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,",
            "year": 2022
        },
        {
            "authors": [
                "Yash Sherry",
                "Neil C. Thompson"
            ],
            "title": "How Fast Do Algorithms Improve? [Point of View",
            "venue": "Proceedings of the IEEE,",
            "year": 2021
        },
        {
            "authors": [
                "Hui Shi",
                "Yang Zhang",
                "Xinyun Chen",
                "Yuandong Tian",
                "Jishen Zhao"
            ],
            "title": "Deep symbolic superoptimization without human knowledge",
            "venue": "In International Conference on Learning Representations,",
            "year": 2019
        },
        {
            "authors": [
                "Disha Shrivastava",
                "Hugo Larochelle",
                "Daniel Tarlow"
            ],
            "title": "Repository-level prompt generation for large language models of code",
            "venue": "In International Conference on Machine Learning,",
            "year": 2023
        },
        {
            "authors": [
                "Alex Shypula",
                "Pengcheng Yin",
                "Jeremy Lacomis",
                "Claire Le Goues",
                "Edward Schwartz",
                "Graham Neubig"
            ],
            "title": "Learning to superoptimize real-world programs",
            "venue": "arXiv preprint arXiv:2109.13498,",
            "year": 2021
        },
        {
            "authors": [
                "Delaram Talaashrafi"
            ],
            "title": "Advances in the Automatic Detection of Optimization Opportunities in Computer Programs",
            "venue": "PhD thesis, Western University,",
            "year": 2022
        },
        {
            "authors": [
                "Lewis Tunstall",
                "Leandro Von Werra",
                "Thomas Wolf"
            ],
            "title": "Natural Language Processing with Transformers",
            "venue": "\"O\u2019Reilly Media,",
            "year": 2022
        },
        {
            "authors": [
                "Jason Wei",
                "Xuezhi Wang",
                "Dale Schuurmans",
                "Maarten Bosma",
                "Fei Xia",
                "Ed Chi",
                "Quoc V Le",
                "Denny Zhou"
            ],
            "title": "Chain-of-thought prompting elicits reasoning in large language models",
            "venue": "Advances in Neural Information Processing Systems,",
            "year": 2022
        },
        {
            "authors": [
                "Thomas Wolf",
                "Lysandre Debut",
                "Victor Sanh",
                "Julien Chaumond",
                "Clement Delangue",
                "Anthony Moi",
                "Pierric Cistac",
                "Tim Rault",
                "Remi Louf",
                "Morgan Funtowicz",
                "Joe Davison",
                "Sam Shleifer",
                "Patrick von Platen",
                "Clara Ma",
                "Yacine Jernite",
                "Julien Plu",
                "Canwen Xu",
                "Teven Le Scao",
                "Sylvain Gugger",
                "Mariama Drame",
                "Quentin Lhoest",
                "Alexander Rush"
            ],
            "title": "Transformers: State-of-the-art natural language processing",
            "venue": "In Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing: System Demon-",
            "year": 2020
        },
        {
            "authors": [
                "Frank F Xu",
                "Uri Alon",
                "Graham Neubig",
                "Vincent Josua Hellendoorn"
            ],
            "title": "A Systematic Evaluation of Large Language Models of Code",
            "venue": "In MAPS,",
            "year": 2022
        },
        {
            "authors": [
                "Tianjun Zhang",
                "Fangchen Liu",
                "Justin Wong",
                "Pieter Abbeel",
                "Joseph E Gonzalez"
            ],
            "title": "The wisdom of hindsight makes language models better instruction followers",
            "venue": "arXiv preprint arXiv:2302.05206,",
            "year": 2023
        },
        {
            "authors": [
                "Zihao Zhao",
                "Eric Wallace",
                "Shi Feng",
                "Dan Klein",
                "Sameer Singh"
            ],
            "title": "Calibrate before use: Improving fewshot performance of language models",
            "venue": "In International Conference on Machine Learning,",
            "year": 2021
        },
        {
            "authors": [
                "Chunting Zhou",
                "Pengfei Liu",
                "Puxin Xu",
                "Srini Iyer",
                "Jiao Sun",
                "Yuning Mao",
                "Xuezhe Ma",
                "Avia Efrat",
                "Ping Yu",
                "Lili Yu"
            ],
            "title": "Lima: Less is more for alignment",
            "venue": "arXiv preprint arXiv:2305.11206,",
            "year": 2023
        },
        {
            "authors": [
                "Shuyan Zhou",
                "Uri Alon",
                "Sumit Agarwal",
                "Graham Neubig"
            ],
            "title": "Codebertscore: Evaluating code generation with pretrained models of code",
            "venue": "2023b. URL https://arxiv.org/abs/2302.05527",
            "year": 2023
        }
    ],
    "sections": [
        {
            "heading": "1 INTRODUCTION",
            "text": "Despite the impressive progress of optimizing compilers and other tools for performance engineering (Aho et al., 2007), programmers are still largely responsible for high-level performance considerations such as algorithms and API choices. Recent work has demonstrated the promise of deep learning for automating performance optimization (Garg et al., 2022; Mankowitz et al., 2023). However, these techniques are either narrow or difficult to build on due to the lack of open datasets and lack of reliable performance measurement techniques, which has stymied research in this direction. Recently, pre-trained large language models (LLMs) have demonstrated impressive performance at a wide range of programming tasks (Chen et al., 2021b; Fried et al., 2022; Xu et al., 2022; Nijkamp et al., 2022). Yet, the effectiveness of large, pre-trained LLMs for program optimization remains an open research question. We study whether such LLMs can be adapted for performance optimization. To this end, we introduce a novel benchmark for performance opti-\n\u2217Equal contribution. \u2020Now at Google DeepMind 1The project website can be found at www.pie4perf.com\nar X\niv :2\n30 2.\n07 86\n7v 4\n[ cs\n.S E\n] 8\nN ov\n2 02\n3\nmization that addresses the key challenge of replicable performance measurement, and perform an extensive evaluation of a wide range of adaptation techniques based on it.\nFirst, we construct a dataset of Performance-Improving Edits (PIE). We collect C++ programs written to solve competitive programming problems, where we track a single programmer\u2019s submissions as they evolve over time, filtering for sequences of edits that correspond to performance improvements.\nNext, a major challenge is the significant variability of measuring performance on real hardware due to server workload and configuration issues. Indeed, we find that benchmarking on real hardware can lead to large, phantom performance \u201cimprovements\u201d due only to random chance. To address this challenge, we evaluate performance using the gem5 CPU simulator (Binkert et al., 2011), the gold standard CPU simulator in academia and industry, and models state-of-the-art general-purpose processors. This evaluation strategy is entirely deterministic, ensuring both reliability and reproducibility.\nBased on this benchmark, we evaluate a variety of techniques for adapting pre-trained code LLMs for performance optimization. First, we consider baseline prompting approaches, including techniques such as chain-of-thought (Wei et al., 2022b) (CoT). We find that LLMs are limited in the challenging task of code optimization. Without data-driven methods that leverage PIE, our strongest baseline COT only warrants 1.61\u00d7 average speedups vs. 4.06\u00d7 human reference. Next we consider a retrieval-based prompting approach where retrieval is used to select examples most similar to the current one (Liu et al., 2021; Poesia et al., 2021). Lastly, we consider several finetuning strategies: these include using synthetic data generated via self-play (Haluptzok et al., 2022), where synthetic training examples are generated by an LLM without the need for direct human examples, as well as performance-conditioned generation, where we condition generation on the performance of the generated program.\nWe find that data-driven methods using PIE, like retrieval-based few-shot prompting and fine-tuning, are highly effective at achieving strong optimization abilities in LLMs. When allowing a model to take 8 samples and filtering for correctness and execution time, our fine-tuned performance-conditioned version of CODELLAMA 13B can achieve an average speedup of 5.65\u00d7 on our test set, and a fine-tuned version of GPT-3.5 augmented with synthetic data via self-play achieves an average speedup of 6.86\u00d7, whereas the fastest human solutions we found achieve an average speedup of 4.06\u00d7. In summary, our contributions are: \u2022 We introduce a new code dataset of more than 77 K C++ program pairs, named PIE, with execution time annotations collected from the gem5 simulator. PIE enables reproducible evaluation of LLMs for program optimization and reliable performance annotations for training.\n\u2022 Enabled by our benchmark, we evaluate different prompting and fine-tuning approaches for adapting pretrained LLMs to optimize programs. Our results indicate that pre-trained code LLMs are limited in their ability to optimize code without a dataset like PIE. \u2022 We develop three effective strategies for adapting LLMs for code optimization: retrieval-based prompting, performance-conditioning, and self-play. Overall, our best model, GPT-3.5 augmented with synthetic data obtained from self-play, achieves an average speedup of 6.86\u00d7, and optimizes 87.68% of the test set by at least 10%.\nRelated work. Beyond the approaches described above, machine learning has been applied to improve performance by refactoring code (Mens & Tourw\u00e9, 2004; Agnihotri & Chug, 2020), identify compiler transformations (Bacon et al., 1994; Talaashrafi, 2022), perform parameter search (Hamadi & Hamadi, 2013; Huang et al., 2019; Kaufman et al., 2021), auto-vectorize code (Nuzman et al., 2006; Mendis et al., 2019), optimize GPU code (Liou et al., 2020; Cummins et al., 2021), and automatically select algorithms (Kotthoff, 2016; Kerschke et al., 2019). and room at the top (Leiserson et al., 2020; Sherry & Thompson, 2021). DeepPERF (Garg et al., 2022) uses a transformer-based model fine-tuned to generate performance improvement patches for C# applications. Additionally, Chen et al. (2022) uses a discrete variational auto-encoder, each latent representation maps to a different category of code edits, and canonicalized code representations to automatically suggest performance improvements, Shypula et al. (2021) trains seq2seq models from scratch on optimization data to superoptimize assembly programs after compilation, Shi et al. (2019) trains tree-LSTM from scratch with RL to superoptimize halide IR, and MAGPIE (Blot & Petke, 2022) uses genetic algorithms for tasks including optimization. AlphaCode (Li et al., 2021) leverages language models to generate solutions to competitive programming problems in natural language, but it does not attempt to improve the performance of existing solutions. In contrast, we focus on adapting pre-trained LLMs (Chen et al., 2021b; Nijkamp et al., 2022; Tunstall et al., 2022; Xu et al., 2022; Fried et al., 2022) to performance optimization."
        },
        {
            "heading": "2 PERFORMANCE IMPROVING EDITS (PIE) DATASET",
            "text": "We construct a dataset targeted at adapting code LLMs to performance optimization, focusing on optimizing program execution time. Our dataset is constructed based on performance-improving edits (PIE) made by human programmers in a range of competitive programming tasks from CodeNet (Puri et al., 2021). Given a problem, programmers typically write an initial solution and iteratively improve it. Let Yu = [yu1 , yu2 , ...] be a chronologically sorted series of programs, written by user u for problem x. From Yu, we remove programs that were not accepted by the automated system, eliminating incorrect programs (fail one or more unit tests) or take more than the allowed time to run, resulting in a trajectory of programs Y\u2217 = [y\u22171 , y\u22172 , . . . , y\u2217n].\nFor each trajectory Y\u2217, we construct pairs P = (y1, y2), (y1, y3), (y2, y3) . . ., and keep only pairs for which (time(yi)\u2212time(y>i))\ntime(yi) > 10% where time (y) is the measured latency of program y (i.e., the relative time\nimprovement is more than 10%). The CodeNet dataset includes CPU time, but we found the information to be inconsistent (see Appendix A.3). Thus, we relabel the execution time using gem5 as described below; to create these annotated runtimes, we performed over 42.8 million simulations in our gem5 environment.\nWe split the resulting dataset of pairs P into train/validation/test sets, ensuring that any particular competitive programming problem only appears in one of them. We obtain a training set of 77,967 pairs from 1,474 problems, a validation set of 2,544 pairs from 77 problems, and a test set of 982 pairs from 41 problems. For each pair in the test set, we also record the fastest human submission execution time for that problem; in Section 4, we include this running time as a comparison point.\nTest cases. Our goal is to improve performance while ensuring correctness. We evaluate correctness through unit tests; we reject the program if a single test fails. CodeNet includes an average of 4 test cases per problem. To improve coverage, we include additional test cases from AlphaCode (Li et al., 2021) generated with a fine-tuned LLM. A small set of test cases would lead to substantial timeouts above 2 minutes in gem5;\nafter excluding them, we obtain a median of 82.5 test cases per problem in our training set, 75 test cases per problem in our validation set, and 104 test cases per problem for our test set. See Appendix A.2 for additional details.\nPerformance measurement using gem5. Benchmarking program performance is notoriously difficult. For instance, code instrumentation introduces overhead, and there is substantial variance across executions due to numerous factors, including server load and idiosyncrasies introduced by the operating system. If benchmarking is not performed carefully, it is easy to mistakenly over-report program optimization results. With enough samples and variance, benchmarking the same exact program can easily lead us to report significant optimizations.\nTo illustrate the challenges, consider HYPERFINE Peter (2023), a Rust library designed to precisely benchmark binaries. We benchmarked 500 programs \u201cpairs\u201d where the \u201cslow\u201d and \u201cfast\u201d programs are identical. Ideally, we should have source timetarget time = 1 (i.e., the two programs have identical performance). However, we observed a mean speedup of 1.12\u00d7, with a standard deviation of 0.36, and the top 5% of pairs exhibited a speedup of 1.91\u00d7. These results underscore the significant challenges in performance measurement. To address this challenge, we measure program performance using the gem5 (Binkert et al., 2011) full system detailed microarchitectural simulator of state-of-the-art processors. Executing deterministic programs in gem5 provides fully deterministic performance results, enabling reliable isolation of the impact of performance-improving edits and reproducibility. We use the Verbatim configuration of the Intel Skylake architecture from gem5.2. An advantage of this approach is that our framework can be applied to other platforms like ARM or RISC-V without having access to hardware for those platforms."
        },
        {
            "heading": "3 ADAPTING CODE LLMS TO PROGRAM OPTIMIZATION",
            "text": ""
        },
        {
            "heading": "3.1 FEW-SHOT PROMPTING",
            "text": "Instruction-prompting. We use prompts instructing the LLM to improve the performance of the given program, an approach commonly referred to as instruction prompting (Mishra et al., 2021; Gupta et al., 2022; Longpre et al., 2023); details on the prompt are in Figure 10 in Appendix A.8.\nFew-shot prompting. Next, we use few-shot prompting (Brown et al., 2020). In particular, we create a prompt with the format \u201cslow1 \u2192 fast1 || slow2 \u2192 fast2 || . . . \u201d. A slow test set program is appended to this prompt during inference and supplied to the model. We create the prompts by randomly sampling two (fast, slow) pairs from the training set. Examples of prompts are shown in Figure 11 in Appendix A.8.\nChain-of-thought prompting. Inspired by Chain-of-Thought (COT) prompting (Wei et al., 2022b), we also designed prompts that ask the LLM to think about how to optimize the program before actually producing the optimized program. This strategy is used in conjunction with few-shot prompting. Examples of prompts are shown in Figure 12 in Appendix A.8.\nDynamic retrieval-based few-shot prompting. Recent work has demonstrated that retrieval-based mechanisms can improve language models for various tasks requiring factual or procedural knowledge (Liu et al., 2021; Poesia et al., 2021; Rubin et al., 2021; Madaan et al., 2022; Rubin et al., 2022; Shrivastava et al., 2023). Program optimization is a non-trivial task requiring knowledge of algorithms, data structures, and programming grounded in performance; thus, retrieving highly relevant examples may improve an LLM\u2019s optimization ability. For example, a solution optimized for a knapsack problem in dynamic programming could inform strategies for the coin change problem. Through dynamic retrieval-based prompts, we aim to match tasks with analogous structures or challenges, allowing models to better harness the patterns in PIE. We use the CodeBertScore models trained for C++ (Zhou et al., 2023b) to embed both the program to be\n2https://github.com/darchr/gem5-skylake-config\noptimized and the programs in PIE. We use FAISS (Johnson et al., 2019) to retrieve K closest programs from the training set; and to construct a \u201cslow1 \u2192 fast1 || ...\u201d style prompt on the fly. Examples of prompts are shown in Figure 13 in Appendix A.8."
        },
        {
            "heading": "3.2 FINETUNING",
            "text": "We also consider fine-tuning to improve pretrained code LLMs using our PIE dataset. In addition to standard fine-tuning on the entire dataset, we describe additional strategies we used.\nDataset imbalance. While we have tens of thousands of slow-fast pairs in the PIE training dataset, these submissions target just 1,474 problems, which may limit the learned model\u2019s ability to generalize to new programs. Furthermore, submissions are not uniformly distributed across problems. To address this imbalance, we additionally introduce a subset of 4,085 \u201chigh-quality\u201d slow-fast pairs\u2014in particular, we take examples with the highest speedup and disallow more than 4 submissions per problem, for an average of 2.77 submissions per problem. Given the high costs of training models through the OpenAI API, we also use this dataset as a base for fine-tuning experiments with GPT-3.5.\nPerformance-conditioned generation. Programs can typically be written in many ways with different performance profiles. Consequently, when training a model to predict performance-improving edits with a large dataset like PIE, it is trained on a mix of large and small improvements, without any information on which improvements are more desirable than others. Inspired by recent prompting strategies (Zhang et al., 2023) and offline-rl (Chen et al., 2021a), we introduce performance tags during training by associating each \u201cfast\u201d program with a tag indicating the optimal achievable performance across all solutions in the dataset. Specifically, the tag indicates how close that program is to peak performance on a binned-scale {1, 2, . . . , 10}. We instantiate our tags by categorizing the top 10% of optimized solutions in the dataset for a given task as \u201c10/10\", the next 10% as \u201c9/10\u201d, and so on. These tags enable the model to discern the relationship between specific problem attributes and their corresponding high-performance solutions (Figure 2, left). During inference, we prompt the model with a test input and a maximal score tag \u201c10/10\u201d, directing it to generate the most optimal solution (Figure 2, right).\nSynthetic data. Given the high cost of obtaining human-written programs, we also augment our dataset with synthetic examples through a multi-stage process. First, we prompt OpenAI\u2019s GPT-3.5 with examples from the PIE dataset, instructing it to produce new programs that produce different outputs given the same inputs. After filtering out programs producing outputs identical to those in PIE and tracking semantic duplicates among those generated, we obtain 3,314 unique synthetic programs and many thousand more duplicates. Next, we generate an optimized version for each synthetic \"slow\" program using a GPT-3.5 model that has\nbeen fine-tuned on the original PIE dataset. Finally, we retain pairs where the optimized program is at least 5\u00d7 faster and limit semantic duplicates to three, resulting in 1,485 optimized synthetic examples. This methodology aligns with self-play and self-instruct approachs in neural program synthesis (Haluptzok et al., 2022; Rozi\u00e8re et al., 2023). We provide additional details on the generation process in Appendix A.4."
        },
        {
            "heading": "4 EXPERIMENTS",
            "text": "Models. We evaluate and adapt models from the CODELLAMA models (Rozi\u00e8re et al., 2023) and models from OpenAI available through their API. We also used pretrained checkpoints of (Rozi\u00e8re et al., 2023): CODELLAMA {7B,13B,34B} obtained via HuggingFace (Wolf et al., 2020). For the CODELLAMA family of models, we use the base set of models that have not been instruction-tuned, as the authors of the paper note that instruction-tuning diminished the performance on code generation. We provide training details in Appendix A.6. We experiment with gpt-3.5-turbo-0613 by prompting the pre-trained model and using the fine-tuning API. We evaluate gpt-4-0613 by prompting the pre-trained model; to date, finetuning GPT4 is not available through the API.\nMetrics. To evaluate performance, we measure the following for functionally correct programs:\n\u2022 Percent Optimized [%OPT]: The fraction of programs in the test set (out of 1000 unseen samples) improved by a certain method. A program must be at least 10% faster and correct to contribute.\n\u2022 Speedup [SPEEDUP]: the absolute improvement in running time. If o and n are the \u201cold\u201d and \u201cnew\u201d running times, then SPEEDUP(O, N) = ( o n ) . A program must be correct to contribute. \u2022 Percent Correct [%Correct]: The proportion of programs in the test set that are at least functionally equivalent to the original program (included as a secondary outcome).\nAs described in Section 2, we count a program as functionally correct if it passes every test case in our dataset. Though correctness is not our primary focus, we include it to help interpret our results. In addition, we report our SPEEDUP as the average speedup across all test set examples. For generations that are either incorrect or slower than the original program, we use a speedup of 1.0 for that example, given that, in the worst case, the original program has a speedup of 1.0. We benchmark performance using our gem5\nenvironment and all test cases mentioned in Section 2. We compile all C++ programs with GCC version 9.3.0 and C++17 as well as the -O3 optimization flag; therefore, any reported improvements would be those on top of the optimizing compiler.\nDecoding strategy. Code generation is known to benefit from sampling multiple candidate outputs for each input and choosing the best one (Li et al., 2021); in our case, \u201cbest\u201d is the fastest program that passes all test cases. We use BEST@k to denote this strategy with k samples and a temperature of 0.7."
        },
        {
            "heading": "4.1 RESULTS FOR FEW-SHOT PROMPTING",
            "text": "Baseline few-shot prompting. Table 2 (top) shows results on standard few-shot prompting techniques (Section 3.1, prompts are shown in appendix A.8). We find that generic few-shot prompts often yield similar results compared to simple instruction-prompting. For instance, when prompted with instructions alone, both GPT-3.5 and CODELLAMA 34B demonstrated superior %OPT and SPEEDUP metrics. This observation aligns with the findings of Zhao et al. (2021), which highlighted that few-shot examples can sometimes bias the model and lead to an incorrect understanding of the task. In the context of our study, the consistent use of the same fixed prompt might constrain the model to only apply optimization techniques present in the prompt, thereby resulting in sub-optimal performance. Finally, in line with the findings of Wei et al. (2022a) that identified COT prompting as an emergent capability, we observe improvements with this approach over both instruction-tuned and fixed prompt setups, but notably only for the larger CODELLAMA (13B and 34B) and GPT-3.5 models.\nRetrieval-based few-shot prompting. Table 2 (bottom) shows results using our dynamic retrieval-based few-shot prompting strategy, with the optimal setting at K = 2 retrieved prompts. Extended results for\nK \u2208 {1, 2, 4} are detailed in Appendix A.5. The results show that dynamic few-shot prompting outperforms all the baseline variants, showing that PIE effectively adapts LLMs for program optimization in few-shot settings. We note that increased speedup may, however, come with some cost of correctness."
        },
        {
            "heading": "4.2 RESULTS FOR FINETUNING",
            "text": "Fine-tuning with PIE substantially improves all models. We fine-tune CODELLAMA and GPT-3.5 models on our PIE dataset. Due to the cost of fine-tuning and sampling models through the OpenAI API, we were only able to train GPT-3.5 on the smaller, high-quality dataset (HQ) in Section 3.2. The top of Table 3 shows results for traditional fine-tuning on all models. We see substantially stronger results when fine-tuning on the smaller, high-quality dataset. These results reflect the observation that to adapt LLMs, a small set of high-quality examples can elicit strong performance (Zhou et al., 2023a; Chen et al., 2023).\nPerformance-conditioned training outperforms fine-tuning. Table 3 shows results for performanceconditioned (perf-cond) generation (Section 3.2). Both fine-tuned CODELLAMA models (7B and 13B) show significant improvements in %OPT and SPEEDUP. These gains highlight how the performance improvement information (Figure 2) can enable models to distinguish optimal and sub-optimal solutions, leading to more effective optimizations.\nSynthetic data from self-play marginally improves generalization. Next, we fine-tuned both CODELLAMA and GPT-3.5 using our PIE dataset augmented with our synthetic examples. We show results at the bottom of Table 3. For CODELLAMA and GPT-3.5, compared to using no synthetic data, the additional data improves both %OPT and often SPEEDUP, particularly with BEST@1. We believe the small set of synthetic examples helped generalize the fine-tuned model, as evidenced by the higher %OPT. 3"
        },
        {
            "heading": "4.3 DISCUSSION AND KEY TAKEAWAYS",
            "text": "CODELLAMA vs. GPT-3.5 . Our results demonstrate that openly available models such as CODELLAMA can be competitive with GPT-3.5. For prompting, CODELLAMA 34B with dynamic retrieval (42.16% %OPT,\n3For GPT-3.5, to be sure the increases came from the type of data and not the quantity of data, we performed an ablation by fine-tuning on the top 5,793 examples from PIE with a maximum of 8 duplicates (instead of the 5,570 pairs that included synthetic programs), and we saw BEST@1 performance degrade %OPT to 36.66% and SPEEDUP to 2.67\u00d7, and BEST@8 performance degrade %OPT to 83.63% and SPEEDUP to 6.03\u00d7.\n2.57\u00d7 SPEEDUP for BEST@8) roughly matched the performance of GPT-3.5 with dynamic retrieval (48.16% %OPT, 2.14\u00d7 SPEEDUP for BEST@8). With fine-tuning, CODELLAMA 13B with performance-conditioned generation (66.60% %OPT, 5.65\u00d7 SPEEDUP for BEST@8) approached the performance of GPT-3.5 with synthetic data (87.68% %OPT, 6.86\u00d7 SPEEDUP for BEST@8); indeed, we may expect that fine-tuning CODELLAMA 34B using the same strategy would further bridge this gap. These results demonstrate that with the right adaptation strategies, open models can be competitive with closed ones.\nPrompting vs. fine-tuning. Our results demonstrate that while prompting can be an effective way to adapt models (with retrieval), fine-tuning significantly outperforms prompting for models of the same size.\nEffectiveness of retrieval-based few-shot learning. Our results show that dynamic retrieval provides enormous gains over all other prompting approaches; for instance, it improved the performance of CODELLAMA 34B from 20.07 %OPT, 1.61\u00d7 SPEEDUP to 42.16% %OPT, 2.57\u00d7 SPEEDUP for BEST@8. Effectiveness of performance-conditioned generation. We find that performance-conditioned generation is incredibly effective for achieving good performance; in particular, it improved the performance of CODELLAMA 13B from 47.86% %OPT, 3.43\u00d7 SPEEDUP to 66.60% %OPT, 5.65\u00d7 SPEEDUP for BEST@8. Ineffectiveness of LoRA. We also experimented with low-rank adaptors (LoRA) (Hu et al., 2021), but they performed significantly worse than end-to-end; see Appendix A.7 for results. We hypothesize that this gap may be because performance optimization examples do not occur naturally in the training data."
        },
        {
            "heading": "4.4 ANALYSIS OF GENERATED CODE EDITS",
            "text": "Next, we study the kinds of edits LLMs make that lead to our performance gains, focusing on our bestperforming model, GPT-3.5 fine-tuned with synthetic data. We manually analyze a randomly sampled set of 120 (source, optimized) program pairs to understand the algorithmic and structural changes responsible for the performance gains. We find that the transformations can be broadly categorized into four kinds: Algorithmic changes, Input/Output operations (IO), Data Structure modifications, and Miscellaneous adjustments. Algorithmic changes (complex modifications, such as changing recursive methods to dynamic programming, and unexpected ones, such as omitting Binary Indexed Trees for simpler constructs) are most common, comprising ~34.15% of changes; Input/Output operations (e.g., changing \u2018cin/cout\u2018 to \u2018scanf/printf\u2018, efficiently reading strings) comprised ~26.02%; Data Structures (e.g., switching from vectors to arrays) comprised ~21.14%, and Miscellaneous (e.g., code cleanups and constant optimizations) comprised ~18.70%. These findings show the LLM\u2019s capability to perform sophisticated optimizations while preserving functionality. See Appendix A.1 for details.\nIn Appendix A.1, we show several examples to demonstrate the nature of optimizations made by our model. In these examples, we highlight the removal of a wasteful nested loop (Figure 4), eliminating the need to sort (Figure 3), avoiding unnecessary precomputations (Figure 5), use of simple modular arithmetic properties for optimization (Figure 6), and restructuring loops to improve performance (Figure 7).\nFinally, while our analysis showcases a variety of optimizations, it is essential to address certain speedup sources that may be considered spurious. Specifically, in 10 out of the 120 cases we examined, the speedup stemmed from reducing the constants used to allocate arrays. These speedups might not always reflect genuine algorithmic improvements, and indicate that the test cases may not perfectly cover all the cases, an open problem in code synthesis (Li et al., 2021). Thus, while they contribute to the overall speedup metrics, they should be interpreted with caution. Nevertheless, our analysis shows that the vast majority of speedups do not suffer from this issue, supporting our strong empirical results."
        },
        {
            "heading": "5 CONCLUSION",
            "text": "Our work is an initial step towards unlocking the potential of LLMs in leveraging the opportunities at the \u201ctop\u201d of the computing stack. In particular, we improve algorithmic efficiency and, given a correctness oracle, enable automatic code optimization beyond optimizing compilers. Our results pave an exciting path for improving computing efficiency post Moore\u2019s law."
        },
        {
            "heading": "ACKNOWLEDGEMENTS",
            "text": "This material is partly based on research sponsored in part by the Air Force Research Laboratory (agreement number FA8750-19-2-0200), Army Research Office Award W911NF-20-1-0080, and NSF Award CCF1917852. The U.S. Govt. is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the Air Force Research Laboratory or the U.S. Government. We would like to extend our gratitude towards Herman Schmit, Chandu Thekkath, Mangpo Phothilimthana, James Laudon, Stella Aslibekyan, and Tianjun Zhang for reviewing the paper and providing insightful feedback. We also thank the extended team at Google Research, Brain Team (now Google DeepMind) who enabled this research and helped us with the paper."
        },
        {
            "heading": "A APPENDIX",
            "text": ""
        },
        {
            "heading": "A.1 ADDITIONAL ANALYSIS OF OPTIMIZATIONS",
            "text": "Algorithmic Transformations (34.15%). The most dominant transformation, representing approximately 34.15% of the changes, is the Algorithmic category. Edits in this category exhibited sophisticated code restructuring. A frequent transformation was the shift from recursive methodologies to dynamic programming approaches, which can significantly enhance running time for specific problem types. Other examples include replacing Binary Indexed Trees with more straightforward constructs, removing redundant conditional checks, bit manipulations, and in some cases, using identities from number theory and algebra to replace complex computation with a formula.\nInput/Output Operations (26.02%). The Input/Output operations category, accounting for roughly 26.02% of the changes, primarily centered on transitioning from C++ standard I/O methods (\u2018cin/cout\u2018) to the faster C-standard methods (\u2018scanf/printf\u2018). Other examples include reading a string character-by-character vs. reading in one go, This transformation is particularly beneficial for problems dealing with extensive datasets, where I/O operations can be a bottleneck.\nData Structure Modifications (21.14%). Changes in the Data Structures category, which constituted about 21.14% of the transformations, showcased the model\u2019s adeptness in selecting optimal data structures for the task. A recurring modification was the transition from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate.\nMiscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants."
        },
        {
            "heading": "A.2 PIE DATASET DETAILS",
            "text": ""
        },
        {
            "heading": "A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES",
            "text": "Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments."
        },
        {
            "heading": "A.4 SELF-PLAY DATA GENERATION DETAILS",
            "text": "We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of\ngeneration parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively promising rates of novelty.\nWe found that after attempting to generate 10,000 new programs through the prompting strategy, 6,553 were not in the training/validation/test set of PIE. We keep track of equivalent programs of the ones generated, and of these 6,553 generations we found 3,314 equivalence sets. In total, this required executing over 1.4 million binary input pairs. Parallelized on a 24-core Intel 13900k processor with 64GB of RAM, this took less than 72 hours to complete."
        },
        {
            "heading": "A.5 ABLATION OF RETRIEVAL-BASED FEW-SHOT PROMPTING CONFIGURATION",
            "text": "For our retrieval-based prompting experiment we tried multiple configurations for the number of retrieved prompts where of K = {1, 2, 4} of the K closest retrieved prompts."
        },
        {
            "heading": "A.6 TRAINING DETAILS",
            "text": "We fine-tuned the 7B and 13B variants using the HuggingFace Transformers library with FSDP to distribute the training process across 8\u00d7 48GB GPUs (NVIDIA RTX A6000/NVIDIA L40). For our high-quality dataset, which consists of approximately 4,000 examples, the models were fine-tuned until convergence was achieved, which can be done under 12 hours with 8 GPUs. For tasks related to full data fine-tuning and performance-conditioned fine-tuning, we only train for 1 epoch, which takes 24 to 36 hours, depending on the model of GPU used. All experiments were conducted using the AdamW optimizer (Loshchilov & Hutter, 2019). For the 7B and 13B variants of CODELLAMA, we used a batch size of 32 and a learning rate of 1e\u22125 for all of the experiments."
        },
        {
            "heading": "A.7 LORA RESULTS",
            "text": "We show results using low-rank adaptors for finetuning in Table 8."
        },
        {
            "heading": "A.8 PROMPTS",
            "text": ""
        }
    ],
    "title": "LEARNING PERFORMANCE-IMPROVING CODE EDITS",
    "year": 2023
}