{
    "abstractText": "PL is a low-complexity profile of OWL2, expressly designed to encode data usage policies and personal data protection regulations such as the GDPR in a machine understandable way. With PL, the compliance of privacy policies with the GDPR and with the data subjects\u2019 consent to processing can be checked automatically and in real time. In this paper, we extend PL to support \u201dsticky policies\u201d. They are a sort of license that applies to data transfers, and specifies how the recipient can use the data. Sticky policies may be \u201drecursive\u201d, i.e. they may apply not only to the first data transfer, but also to all subsequent transfer operations that the (direct or indirect) recipients may execute in the future. Recursive sticky policies can be encoded with fixpoints or transitive role closure. In this paper we prove that such extensions make compliance checking intractable. Since the scalability of compliance checking is a major requirement in this area, these results justify a specialized, polynomial-time approach to encoding sticky policies.",
    "authors": [
        {
            "affiliations": [],
            "name": "Piero A. Bonatti"
        }
    ],
    "id": "SP:a1a87c4141edff281672f8b9a2353be20d1f187a",
    "references": [
        {
            "authors": [
                "M. Bienvenu",
                "D. Calvanese",
                "M. Ortiz",
                "M. Simkus"
            ],
            "title": "Nested regular path queries in description logics",
            "venue": "Baral, C.; Giacomo, G. D.; and Eiter, T., eds., Principles of Knowledge Representation and Reasoning: Proceedings of the Fourteenth International Conference, KR 2014, Vienna,",
            "year": 2014
        },
        {
            "authors": [
                "P.A. Bonatti",
                "A. Peron"
            ],
            "title": "On the undecidability of logics with converse, nominals, recursion and counting",
            "venue": "Artif. Intell. 158(1):75\u201396.",
            "year": 2004
        },
        {
            "authors": [
                "P.A. Bonatti",
                "C. Lutz",
                "A. Murano",
                "M.Y. Vardi"
            ],
            "title": "The complexity of enriched mu-calculi",
            "venue": "Log. Methods Comput. Sci. 4(3).",
            "year": 2008
        },
        {
            "authors": [
                "P.A. Bonatti",
                "L. Ioffredo",
                "I.M. Petrova",
                "L. Sauro",
                "I.S.R. Siahaan"
            ],
            "title": "Real-time reasoning in OWL2 for GDPR compliance",
            "venue": "Artif. Intell. 289:103389.",
            "year": 2020
        },
        {
            "authors": [
                "P.A. Bonatti",
                "S. De Capitani di Vimercati",
                "P. Samarati"
            ],
            "title": "An algebra for composing access control policies",
            "venue": "ACM Trans. Inf. Syst. Secur. 5(1):1\u201335.",
            "year": 2002
        },
        {
            "authors": [
                "P.A. Bonatti",
                "L. Sauro",
                "J. Langens"
            ],
            "title": "Representing consent and policies for compliance",
            "venue": "IEEE European Symposium on Security and Privacy Workshops, EuroS&P 2021, Vienna, Austria, September 6-10, 2021, 283\u2013 291. IEEE.",
            "year": 2021
        },
        {
            "authors": [
                "D. Calvanese",
                "G.D. Giacomo",
                "M. Lenzerini"
            ],
            "title": "Reasoning in expressive description logics with fixpoints based on automata on infinite trees",
            "venue": "Dean, T., ed., Proceedings of the Sixteenth International Joint Conference on",
            "year": 1999
        },
        {
            "authors": [
                "F.M. Donini"
            ],
            "title": "Complexity of reasoning",
            "venue": "Baader et al. (2003). 96\u2013136.",
            "year": 2003
        },
        {
            "authors": [
                "E. Franconi",
                "D. Toman"
            ],
            "title": "Fixpoints in temporal description logics",
            "venue": "Walsh, T., ed., IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence, Barcelona, Catalonia, Spain, July 16-22, 2011, 875\u2013880. IJCAI/AAAI.",
            "year": 2011
        },
        {
            "authors": [
                "C. Haase",
                "C. Lutz"
            ],
            "title": "Complexity of subsumption in the family of description logics: Acyclic and cyclic tboxes",
            "venue": "Ghallab, M.; Spyropoulos, C. D.; Fakotakis, N.; and Avouris, N. M., eds., ECAI 2008 - 18th European Conference on Artificial Intelligence, Patras, Greece, July 21-25,",
            "year": 2008
        },
        {
            "authors": [
                "B. Nebel"
            ],
            "title": "Terminological reasoning is inherently intractable",
            "venue": "Artif. Intell. 43(2):235\u2013249.",
            "year": 1990
        },
        {
            "authors": [
                "B. Rosser"
            ],
            "title": "Explicit bounds for some functions of prime numbers",
            "venue": "American Journal of Mathematics 63(1):211\u2013232.",
            "year": 1941
        },
        {
            "authors": [
                "U. Sattler"
            ],
            "title": "A concept language extended with different kinds of transitive roles",
            "venue": "G\u00f6rz, G., and H\u00f6lldobler, S., eds., KI-96: Advances in Artificial Intelligence, 20th Annual German Conference on Artificial Intelligence, Dresden, Germany, September 17-19, 1996, Proceedings, vol-",
            "year": 1996
        }
    ],
    "sections": [
        {
            "heading": "1 Introduction",
            "text": "The European General Data Protection Regulation (GDPR) has changed the landscape of personal data processing. Due to the heavy sanctions and reputation loss incurred in case of violations, the legal entities that process personal data (controllers in GDPR\u2019s terminology), are calling for automated support to compliance. The European H2020 projects SPECIAL1 and TRAPEZE2 tackle this need by means of semantic technnologies, that effectively yield reliability, interoperability, extensibility, flexibility, usability and scalability (Bonatti, Sauro, and Langens 2021). In particular, usability and scalability have been addressed in SPECIAL by identifying a profile of OWL2, called OWL2-PL (policy language), that is simpler to grasp for users with no background in logic, and can be processed very efficently using specialized reasoners (Bonatti et al. 2020). The description logic correponding to OWL2-PL is called PL. One of the goals of TRAPEZE is extending PLwith additional constructs, so as to support more general use cases. In this paper we focus on extending PL to support sticky policies. They are a sort of license that applies to data transfers, and specifies how direct and indirect recipients can use the data. Before delving\n1https://specialprivacy.ercim.eu/ 2https://trapeze-project.eu/\ninto technical details, let us summarize the basic features of the semantic policy framework of SPECIAL and TRAPEZE that we are going to enrich.\nThe privacy policies of controllers, the consent to processing of data subjects, and the personal data protection regulations themselves are all policies. A policy can be identified with the set of operations authorized by the policy; such operations can be abstracted as tuples of attributes (Bonatti, De Capitani di Vimercati, and Samarati 2002). Accordingly, the semantic policy framework encodes policies in OWL2 as classes of reified tuples. In the personal data protection domain, the characteristic attributes of operations include (not exclusively) the data category being processed, the purpose and the nature of the processing, the third parties with which data are shared, the legal basis of the processing, and other information related to the regulation (Bonatti et al. 2020). For example, a privacy policy stating that email addresses are transferred to third parties for advertising purposes, based on the data subject\u2019s consent, is encoded in description logics as follows:\n\u2203has data.Email u \u2203has processing.Transfer u \u2203has purpose.Advertising u \u2203has legal basis.Consent .\nA (privacy) policy P complies with a policy P \u2032 (a consent statement or regulation) if, and only if, all the operations authorized by P are also authorized by P \u2032, that is, P is a subclass of P \u2032. Thus, compliance checking is naturally reduced to subsumption checking in description logic. For example, if Email is a subclass of Contact (contact data) and Advertising a subclass of Marketing, then the above policy complies with the consent to transferring contact data to third parties for marketing purposes, which is formalized as:\n\u2203has data.Contact u \u2203has processing.Transfer u \u2203has purpose.Marketing .\nNote that the classical semantics of subsumption checking (based on entailment) treats policies as closed policies, that is, only what is explicitly allowed is permitted. For example, a privacy policy whose purpose is not subsumed by Marketing would not comply with the above consent statement.\nData transfers can be constrained with sticky policies. For instance, the above consent statement can be refined to state that third parties are allowed (only) to directly use the data subject\u2019s contact information for marketing purposes (which implicitly forbids further transfers to third parties, if we assume that Transfer is not subsumed by DirectUse):\n\u2203has data.Contact u \u2203has processing.Transfer u \u2203has purpose.Marketing u \u2203sticky.( \u2203has data.Contact u \u2203has processing.DirectUse u \u2203has purpose.Marketing) .\nProperty \u201csticky\u201d should be functional in order to avoid the ambiguities that may arise from the application of different, overlapping policies.\nBy nesting sticky policies, one may allow further transfers to third parties, as in the following expression:\nP0 u \u2203sticky.(P1 u \u2203sticky.(P2 u . . . \u2203sticky.Pn . . .)) .\nHere the controller should satisfy P0, while its direct recipients have to satisfy P1; in turn, their recipients should satisfy P2, and so on. Clearly, the above concept regulates only finite disclosure chains of length n. In general, however, disclosure chains can be unbounded. Then sticky policies should be recursive, that is, they should identically apply to all (direct and indirect) recipients, and allow each of them to further transfer data to other third parties. Formally, one would like to express something like the infinitary concept\nP0 u \u2203sticky.(P1 u \u2203sticky.(P1 u \u2203sticky.(P1 u . . .))) .\nLogic provides at least two ways of expressing the above class with a finite expression: greatest fixpoint operators (\u03bd) and transitive role closure (R+). Since sticky is a functional property, the following are equivalent to the above concept:\nP0 u \u03bdX.(\u2203sticky.(P1 uX)) , P0 u (\u2203sticky.P1) u \u2200sticky+.(\u2203sticky.P1) .\nAccordingly, in this paper, we are going to investigate the extensions of PL with greatest fixpoints, universal quantifiers, and transitive role closure. The ultimate goal is supporting sticky policies in a very efficient manner, as some of the use cases of interest to the industrial partners of SPECIAL and TRAPEZE require to complete thousands of compliance checks per second.\nExample 1 (Streaming Scenario). Telecom providers, that today are also Internet providers, receive from their base stations about 15000 call records per second, and almost 10000 probing records per second from their wi-fi network. The data contained in the aforementioned records are of great interest for strategic applications and services, such as location-based services and taylored recommendations; however, call and probing records contain personal data, and the European regulation on data protection prohibits the above usage without the consent of the data subjects. Without consent, even storing the data temporarily, waiting for\na batch process to discard the records that cannot be processed, is illegal. Then the description of how and why each application processes the data must be checked in real-time for compliance with the consent statements that apply to the records being processed. This scenario is further complicated by the fact that each data subject can withdraw or modify her consent anytime, and that she may selectively decide to opt in or out each processing option (e.g. a customer might accept only location tracking, and not internet tracking).\nMore generally, subsumption checks are going to be as frequent as access control checks in our target applications. Therefore, the semantic policy framework must satisfy extreme scalability requirements, that are not common in the knowledge representation area. Thus, an implied necessary requirement is that subsumption checking must be possible in deterministic polynomial time, and the degree of the polynomial should be low.\nIn (Bonatti et al. 2020), it has been proved \u2013 both theoretically and experimentally \u2013 that PL satisfies the scalability requirement, and that real policies can be checked for compliance in a few hundreds of \u00b5-seconds using a sequential Java implementation (i.e. a technology that is not intrinsically performant). The challenge now is supporting sticky policies while preserving the performance of PL.\nIn sections 3 and 4 we prove that the extensions of PL with \u03bd, and with the combination of \u2200 and transitive role closure \u2013 respectively \u2013 are intractable. We prove lower complexity bounds at the first level of the polynomial hierarchy; they suffice to conclude that the above extensions of PL are not suitable for our purposes. Concerning upper complexity bounds, the complexity of the logics supporting \u03bd and transitive role closure is typically much higher, namely, EXPTIME or harder, if a full set of boolean operators is supported. In our setting, getting a tighter complexity estimate is difficult, due to the limited expressiveness of PL; this aspect is further detailed in section 6.\nThe intractability results justify a tractable approach tailored to the use cases, based on a restricted language PLsticky0 that will be illustrated in section 5. This language preserves the asymptotic complexity of reasoning of PL, so it is a promising approach to sticky policy representation.\nThe basic notions about description logics and PL are recalled in the next section. Related and future works are discussed in section 6."
        },
        {
            "heading": "2 Preliminary Definitions",
            "text": "We assume the reader to be familiar with the basic notions of Description Logics (DL) (Baader et al. 2003). Here we recall only the aspects needed for this work. The DL languages of our interest are built from countably infinite sets of concept names (NC), role names (NR), and concrete property names (NF). An interpretation I is a structure I = (\u2206I , \u00b7I) where \u2206I is a nonempty set, and the interpretation function \u00b7I is such that (i) AI \u2286 \u2206I if A \u2208 NC; (ii) RI \u2286 \u2206I \u00d7\u2206I if R \u2208 NR; (iii)fI \u2286 \u2206I \u00d7 N if f \u2208 NF, where N denotes the set of natural numbers.\nCompound concepts and roles are built from concept names, role names, and the logical constructors listed in Ta-\nble 1. We use metavariables A,B for concept names, C,D for (possibly compound) concepts, R,S for role names, and f, g for concrete property names. The third column shows how to extend the valuation \u00b7I of an interpretation I to compound expressions; in the first row, let (R1)I = RI and (Ri)I = RI \u25e6 (Ri\u22121)I , for all i > 1.\nIn (Bonatti et al. 2020) several extensions of PL are considered, where knowledge bases can be expressed with fragments of Horn-SRIQ, under suitable restriction related to import-by-query and knowledge compilation techniques, cf. (Bonatti et al. 2020). Here, we consider only the axioms that suffice to prove our lower bounds. These axioms and the corresponding semantics are shown in Table 2.3 As usual, an interpretation I is a model of a PL knowledge base KB (in symbols, I |= KB) if and only if I |= \u03b1, for all axioms \u03b1 occurring in KB.\nIn PL, the query language differs from the knowledge base language, and is equipped with the constructs needed to express policies. Specifically, a simple PL concept is defined by the following grammar, where A \u2208 NC, R \u2208 NR, and f \u2208 NF :"
        },
        {
            "heading": "C ::= A | \u22a5 | \u2203f.[l, u] | \u2203R.C | C u C .",
            "text": "A full PL concept is a union D1 t . . . tDn of simple PL\n3Interestingly, the axioms listed in Table 2 also suffice to axiomatize the vocabularies that are actually employed in the use cases of SPECIAL and TRAPEZE. Such vocabularies are being developed by the DPVCG,4 a community group of the W3C devoted to the development of standardized data privacy vocabularies.\nconcepts (n \u2265 1). PL\u2019s subsumption queries are inclusions C v D where C,D are full PL concepts. A PL subsumption query C v D is simple if both C and D are simple.\nIf KB entails a subsumption query C v D (in symbols, KB |= C v D), then we say that C complies with D (under KB). Compliance checking is in general coNP-complete, however it downgrades to P whenever the query C v D is interval safe, that is: for all interval constraints \u2203f.[l, u] and \u2203f \u2032.[l\u2032, u\u2032] occurring in C and D, respectively, either [l, u] \u2286 [l\u2032, u\u2032] or [l, u] \u2229 [l\u2032, u\u2032] = \u2205 (Bonatti et al. 2020).\nNotably, coming back to the general case where C and D may contain partially overlapping intervals, and C = C1 t \u00b7 \u00b7 \u00b7 t Cn, it is always possible to turn C v D into an equivalent, interval safe query by splitting the intervals of C in a suitable way. The resulting concept C \u2032 has size O(|C| \u00b7 |D|c), where c = max1\u2264i\u2264n ci and each ci is the number of interval constraints occurring in Ci, for i = 1, . . . , n. Fortunately, the exponent c is a fixed constant in our use cases, therefore, C \u2032 can be computed in polynomial time and compliance checking is tractable. In particular, policy encoding requires at most one interval constraint per simple concept (such interval is used to specify how long data are kept by the controller). In the following, no more details about these complexity issues will be needed; the interested reader is referred to (Bonatti et al. 2020) for a complete discussion.\nHereafter, in order to keep different sources of complexity cleanly separated in the complexity analysis, we consider (and extend) the restricted logic PL0 obtained from PL by disallowing interval constraints \u2013 therefore, in PL0, subsumptions are vacuously interval safe, and subsumption checking is tractable. PL will be considered again in section 6.\nNext, let us define the greatest fixpoint operator \u03bd that will be used in section 3 to augment the query language. To this aim, we consider a supplementary countably infinite set NV of variables; similarly to an atomic concept, a variable X is interpreted as a set of individuals, XI \u2286 \u2206I . Let E be a subset of \u2206I ; by I[X \u2192 E ] we mean the interpretation such that X is interpreted as E , and all the other symbols are interpreted as in I. Then, the semantics of a fixpoint concept \u03bdX.C is the following:\n(\u03bdX.C)I = \u22c3 {E \u2286 \u2206I | E \u2286 CI[X\u2192E]} .\nFinally, a pointed interpretation is a pair (I, d), where d \u2208 \u2206I . We say that (I, d) satisfies a concept C (in symbols, I, d |= C) iff d \u2208 CI . We also say that (I, d) is a model of a knowledge base KB if I |= KB."
        },
        {
            "heading": "3 PL with Fixpoints",
            "text": "Let PL\u03bd0 be the extension of PL0 where greatest fixpoints may occur in subsumption queries. At a first glance, PL\u03bd0 constitutes a promising way of encoding sticky policies, due to its similarity with ELwith greatest fixpoints, that has been proved to be tractable in (Lutz, Piro, and Wolter 2010).\nHowever, the interplay of greatest fixpoints with functional roles (that are supported only in PL) makes subsumption checking at least coNP-hard. This holds not only for\nPL, but also for all the description logics that support u, v, and func in knowledge base axioms, and u, \u2203, and \u03bd in subsumption queries.\nTheorem 2. LetDL be any description logics that supports u, v, and func in knowledge base axioms, and u, \u2203, and \u03bd in subsumption queries. Subsumption checking in DL is coNP-hard.\nProof. The proof is by reduction of the validity problem to subsumption checking. Let \u03c6 = \u2228m i=1 `i,1 \u2227 `i,2 \u2227 `i,3 be any propositional formula in 3-DNF, and let x1, . . . , xk be the propositional variables occurring in \u03c6. Introduce a fresh concept name Ai for each xi and a fresh concept name A\u0304i for each negative literal \u00acxi. For each propositional literal `, let \u02dc\u0300 denote the corresponding concept name. Informally speaking, the knowledge base KB encodes \u03c6 in such a way that if an individual d satisfies \u03c6 (up to the correspondence between literals and concepts), then d satisfies also a distinguished atomic concept F that represents the truth of \u03c6. More formally, let KB consist of the following axioms, where each concept Bi represents the truth of the i-th disjunct of \u03c6:\n\u02dc\u0300 i,1 u \u02dc\u0300i,2 u \u02dc\u0300i,3 v Bi Bi v F func(R)\n(where i = 1, . . . ,m). The use of role R will be explained later.\nGreatest fixpoints are used to create periodic chains of instance types. To make this more precise, we need some auxiliary definitions. First, for all i = 1, . . . , k (where k is the number of propositional variables in \u03c6), define\nC1i = Ai u \u2203R.X Cj+1i = A\u0304i u \u2203R.C j i\n(where X is a concept variable). For example,\nC2i = A\u0304i u \u2203R.(Ai u \u2203R.X) C3i = A\u0304i u \u2203R.(A\u0304i u \u2203R.(Ai u \u2203R.X)) C4i = A\u0304i u \u2203R.(A\u0304i u \u2203R.(A\u0304i u \u2203R.(Ai u \u2203R.X)))\n...\nNote that the instances of any concept \u03bdX.Cji are the first elements of infinite R-chains where Ai is satisfied (at least) every j steps, while the other elements satisfy (at least) A\u0304i.\nLet p1 = 2, p2 = 3, p3 = 5, . . . , pk be the first k prime numbers, and define:\nC = kl\ni=1\n\u03bdX.Cpii . (1)\nClaim: \u03c6 is valid iff KB |= C v \u03bdX.(F u \u2203R.X) .\nFirst we prove the \u201conly if\u201d part of the claim. If \u03c6 is valid, then for all models I of KB and all individuals d \u2208 \u2206I , the following clearly holds: If d belongs to AIi or A\u0304 I i for all i = 1, . . . , k, then d \u2208 F I . Note that C forces all the direct\nand indirect R-successors of its instances to be in AIi or A\u0304 I i , for all i = 1, . . . , k, so all such successors are in F I . It follows, by definition of \u03bd, that all the instances of C belong to \u03bdX.(F u \u2203R.X), which proves the \u201conly if\u201d part of the claim.\nTo prove the \u201cif\u201d part of the claim, suppose that \u03c6 is not valid, and construct a counterexample I to the subsumption as follows. Let \u2206I be an infinite set {di | i \u2208 N}. LetRI = {(di, di+1) | i \u2208 N}. For all i \u2208 N and j = 1, . . . , k, let di \u2208 AIj iff i mod pj = 0, and let A\u0304Ij = \u2206I \\ AIj . Finally, for all i = 1, . . . ,m, let BIi = (\u02dc\u0300i,1u \u02dc\u0300i,2u \u02dc\u0300i,3)I and F I =\u22c3m i=1B I i . By construction, we have both that I satisfies KB, and d1 \u2208 CI . Moreover, since the numbers p1, . . . , pk that determine the periodic behavior of C\u2019s fixpoints are distinct prime numbers, the individuals d1, d2, . . . , di, . . . collectively satisfy all possible combinations of literal encodings that contain no pair of complementary concepts Aj and A\u0304j (j = 1, . . . , k). So the concepts satisfied by I\u2019s elements represent all possible truth assignments to x1, . . . , xk.5 One of this truth assignments falsifies \u03c6, by assumption, so \u2013 by construction \u2013 there exists dj \u2208 \u2206I such that dj 6\u2208 F I . As a consequence, d1 6\u2208 \u03bdX.(F u \u2203R.X). This proves that CI 6\u2286 \u03bdX.(F u \u2203R.X)I , which completes the proof of the claim.\nThe reduction is correct by the claim; we are only left to show that it can be computed in polynomial time. The size of the knowledge base and the size of the concept \u03bdX.(F u \u2203R.X) are obviously polynomial in the size of \u03c6, so we only have to provide a polynomial bound on the size of C. In order to see this, we use a results by Rosser (Rosser 1941). The kth prime number pk is bounded by\npk < k(log k + log log k + 2)\nso, for sufficiently large k, pk < 2k2. It follows that the length of each concept \u03bdX.Cpii in (1) isO(k\n2) and the entire concept C is O(k3), so the reduction can be computed in polynomial time.6\nAs a corollary, subsumption checking in PL\u03bd0 is coNPhard, even if neither disjointness axioms nor range axioms are used, and only one functional role is used."
        },
        {
            "heading": "4 PL with Universal Restrictions and Transitive Role Closure",
            "text": "Transitive role closure provides an alternative way of expressing sticky policies. Transitive closure can be regarded as a restricted form of fixpoint: every concept of the form \u2200R+.C can be expressed with \u03bd as \u03bdX.\u2200R.(C u X) . So, reasoning in PL0 with transitive role closure might turn out to be less complex than reasoning in PL0 with greatest fixpoints. Unfortunately, tractability is not preserved, due to the interplay of \u2200 and \u2203. We are going to prove that the NP-complete EXACT COVER (XC) problem can be reduced\n5In particular, each propositional interpretation {xi1 , . . . , xin} corresponds to the element dh with h = \u220fn l=1 pil .\n6It is not hard to see that it can even be computed in logarithmic space.\nto subsumption in two extensions of PL0 that employ the operators \u2200 and \u00b7+ needed to encode sticky policies.\nWe prove these results by adapting a reduction of XC to concept (un)satisfiability in ALE , extensively illustrated in (Donini 2003, Sec. 3.3.1). Let us first recall the definition of the problem: Definition 3 (EXACT COVER, XC). Given a finite set U = {u1, . . . , un} and a familyM = {M1, . . . ,Mm} of subsets of U , decide whether there exist an exact cover of U , that is, a family of mutually disjoint setsMi1 , . . . ,Miq whose union equals U .\nThe following lemma introduces the reduction and states its correctness : Lemma 4. (Donini 2003) An instance of XC has an exact cover if, and only if, the concept CM defined below is unsatisfiable:\nCM = C 1 1 u . . . u Cm1 uD\nwhere each Cjl is inductively defined as\nCj2n+1 = > (base case)\nCjl =  \u2203R.Cjl+1 either l \u2264 n \u2227 ul \u2208 Mj or n < l \u2264 2n \u2227 ul\u2212n \u2208Mj \u2200R.Cjl+1 either l \u2264 n \u2227 ul 6\u2208 Mj or\nn < l \u2264 2n \u2227 ul\u2212n 6\u2208Mj and D = \u2200R.\u2200R. . . . \u2200R\ufe38 \ufe37\ufe37 \ufe38\n2n\n.\u22a5 .\nExample 5. Let U = {u1, u2} andM = {M1,M2}, where M1 = {u1} and M2 = {u2}. Concept CM is\n\u2203R.\u2200R.\u2203R.\u2200R.> u (C11 ) \u2200R.\u2203R.\u2200R.\u2203R.> u (C21 ) \u2200R.\u2200R.\u2200R.\u2200R.\u22a5 (D)\nNote that this instance of XC has an exact cover (M itself) and CM is indeed inconsistent.\nLemma 4 was proved by showing that an exact cover exists iff the tableaux for CM has a clash, caused by a node labelled with both > and \u22a5, where > has been introduced by some of the concepts Cj1 and \u22a5 has been introduced by D. Clearly, the same result can be obtained by replacing > (that is not supported in PL) with a concept name A. So, from Lemma 4, we get: Corollary 6. Let CAM be the concept resulting from CM by replacing each occurrence of > with concept name A. An instance of XC has an exact cover if, and only if, the concept CAM is unsatisfiable.\nIt follows that subsumption is intractable in the extension of PL0 with \u2200, that will be denoted by PL\u22000 . Corollary 7. Subsumption checking in PL\u22000 is NP-hard, even if the knowledge base is empty.\nProof. The exact cover problem is reduced to subsumption as follows: let A and B two distinct concept names. For a given instance of XC, the corresponding concept CAM and B have no symbols in common, therefore CAM v B is valid iff CAM is unsatisfiable. Then this corollary immediately follows from Corollary 6.\nAs a last attempt to restore tractability, one may consider another extension of PL0 where the problematic quantifier \u2200 can be used only in conjunction with transitive role closure (as required by sticky policy modeling), and viceversa. In other words, expressions like \u2200R+.C and \u2203R.C are permitted, while \u2200R.C and \u2203R+.C are disallowed. This logic will be denoted with PL\u2200+0 . This attempt is motivated by the observation that if \u2200R were replaced with \u2200R+ in CAM, then the resulting concept would not capture exact covers anymore. Example 8. Let U = {u1, u2, u3} and M = {M1,M2}, where M1 = {u1} and M2 = {u2}. The replacement of \u2200R with \u2200R+ in CAM yields:\n\u2203R.\u2200R+.\u2200R+.\u2203R.\u2200R+.\u2200R+.A u \u2200R+.\u2203R.\u2200R+.\u2200R+.\u2203R.\u2200R+.A u \u2200R+.\u2200R+.\u2200R+.\u2200R+.\u2200R+.\u2200R+.\u22a5\nThe concepts in the first two lines create an infinite sequence of R-successors that clashes with the concept in the third line. So the above concept is inconsistent although this instance of XC has no exact covers.\nUnfortunately, the restriction on \u2200 and \u00b7+ does not yield a tractable logic, either. First note that the reduction reported in Lemma 4 works equally well if different roles are used at each level, as in the following example. Example 9. The conceptCM illustrated in Example 5 could be equivalently replaced with\n\u2203R1.\u2200R2.\u2203R3.\u2200R4.> u \u2200R1.\u2203R2.\u2200R3.\u2203R4.> u \u2200R1.\u2200R2.\u2200R3.\u2200R4.\u22a5 .\nThis version preserves the correspondence with XC stated in Lemma 4, because the tableaux produced by the two reductions have the same structure and differ only in the role names. Now each \u2200Ri can be equivalently replaced with \u2200R+i ; more precisely, it is easy to verify that also this second change preserves the structure of the tableaux for CM, and that the only difference is that \u2200Ri is replaced by \u2200R+i in node labels.\nAs a consequence of the above discussion, subsumption checking in PL\u2200+0 is intractable due to the following reduction from XC: Lemma 10. An instance of XC has an exact cover if, and only if, the concept C \u2032AM defined below is unsatisfiable:\nC \u2032AM = C \u2032 1 1 u . . . u C \u20321m uD\u2032\nwhere each C \u2032l j is inductively defined as\nC \u20322n+1 j = A (base case)\nC \u2032l j =  \u2203Rl.C \u2032l+1j either l \u2264 n \u2227 ul \u2208 Mj or n < l \u2264 2n \u2227 ul\u2212n \u2208Mj \u2200R+l .C \u2032l+1j either l \u2264 n \u2227 ul 6\u2208 Mj or\nn < l \u2264 2n \u2227 ul\u2212n 6\u2208Mj\nand D\u2032 = \u2200R+1 .\u2200R + 2 . . . . \u2200R + 2n.\u22a5 .\nThe lower complexity bound (next theorem) can be proved by analogy with the proof of Corollary 7, using C \u2032AM and Lemma 10 in place of CAM and Corollary 6. Theorem 11. Subsumption checking in PL\u2200+0 is NP-hard."
        },
        {
            "heading": "5 Towards A Tractable Approach",
            "text": "Here we introduce a language tailored to the encoding of sticky policies. Such a specialized approach is motivated by the intractability results proved in the previous sections. The complexity caused by the interactions between \u03bd and \u2203 identified in section 3 will be avoided by restricting the language so as to allow only simple, linear recursions whose cyclic behavior has period 1.\nDefinition 12 (Pol,PLsticky0 ). Let Pol be the least language containing: \u2022 all the simple concepts of PL0 with no occurrence of sticky (called sticky-free concepts);\n\u2022 all the conceptsCu\u2203sticky.D such thatC is a sticky-free PL0 concept and D a \u03bd-free concept in Pol; \u2022 all the concepts Cu\u03bdX.\u2203(sticky.DuX) such that C and D are sticky-free PL0 concepts.\nPLsticky0 knowledge bases are PL knowledge bases containing only axioms from Table 2, and at least the axiom func(sticky), that must also be the unique axiom where sticky occurs. PLsticky0 subsumption queries are expressions C v D where C and D are in Pol. Example 13. The following policies are in Pol and can be used in PLsticky0 subsumption queries:\n\u2203has data.Contact u \u2203has processing.Transfer u \u2203has purpose.Marketing u \u2203sticky.( \u2203has data.Contact u \u2203has processing.Transfer u \u2203has purpose.Marketing u \u2203sticky.( \u2203has data.Contact u \u2203has processing.DirectUse u \u2203has purpose.Marketing)) .\n\u2203has data.Contact u \u2203has processing.Transfer u \u2203has purpose.Marketing u \u03bdX.\u2203sticky.( \u2203has data.Contact u \u2203has processing.SomeProcessing u \u2203has purpose.Marketing uX) .\nPLsticky0 subsumption checking can be reduced to the same problem in PL0. To see this, we first prove a lemma that considers the four possible cases in which the given PLsticky0 subsumption contains the fixpoint operator \u03bd (the other PLsticky0 subsumptions are just classic PL0 subsumptions). Each case is reduced to a small number of PL0 subsumptions.\nLemma 14. Let KB be a PLsticky0 knowledge base, and let C, D, E, and F be sticky-free Pol concepts.\n1. KB |= C u\u03bdX.\u2203sticky.(DuX) v Eu\u03bdX.\u2203sticky.(F u X) iff some of the following conditions hold: \u2022 KB |= C v \u22a5, \u2022 KB |= D v \u22a5, \u2022 both KB |= C v E and KB |= D v F hold;\n2. if G is \u03bd-free, then KB |= G v C u \u03bdX.\u2203sticky.(D uX) iff KB |= G v \u22a5;\n3. if E is both \u03bd-free and sticky-free, then KB |= C u \u03bdX.\u2203sticky.(D u X) v E iff either KB |= C v E or KB |= D v \u22a5;\n4. if G is \u03bd-free but not sticky-free, that is,\nG = G0 u\u2203sticky.(G1 u\u2203sticky.(...\u2203sticky.Gn...)) (2)\n(where G0, . . . , Gn are sticky-free PL0 concepts), then KB |= C u \u03bdX.\u2203sticky.(D u X) v G iff some of the following conditions hold: \u2022 KB |= C v \u22a5, \u2022 KB |= D v \u22a5, \u2022 both KB |= C v G0 and KB |= D v G1 u . . . u Gn\nhold;\nProof. We start by proving statement 2. Since G is \u03bd-free, it belongs to PL0, therefore \u2013 if consistent w.r.t. KB\u2013 it has a finite tree-shaped model that satisfies KB (Bonatti et al. 2020). In such models, the concept on the right-hand side (that has only infinite models) is empty, so the subsumption is false. It follows easily that the subsumption holds iff KB |= G v \u22a5. This proves 2.\nProof of 3, \u201cif\u201d. If KB |= C v E, then the subsumption holds because its left-hand side is subsumed by C and v is transitive. If KB |= D v \u22a5, then also KB |= \u03bdX.\u2203sticky.(DuX) v \u22a5, so the subsumption holds because its left-hand side is subsumed by \u22a5.\nProof of 3, \u201conly if\u201d. By contraposition, assume that KB 6|= C v E and KB 6|= D v \u22a5. Then there exist two pointed interpretations (I1, d1) and (I2, d2), that are models of KB, and satisfy the sticky-free concepts C u \u00acE and D, respectively. We may assume w.l.o.g. that I1 and I2 are disjoint. Define an interpretation J as the union of I1 and I2 extended with the following definition of sticky: stickyJ = {(d1, d2), (d2, d2)}. By construction, J satisfies KB: indeed, the union of I1 and I2 satisfies KB by the disjoint model union property (Bonatti et al. 2020), and the definition of sticky satisfies func(sticky), that is the unique axiom involving sticky in KB. Moreover, by construction, (J , d1) satisfies the left-hand side of the subsumption but not E. Then J witnesses that the subsumption does not hold.\nProof of 1. The \u201cif\u201d part is straightforward and left to the reader. The \u201conly if\u201d part is proved similarly to the previous case. More precisely, by contraposition, assume that KB 6|= C v \u22a5, KB 6|= D v \u22a5, and either KB 6|= C v E or KB 6|= D v F holds. In the former case, construct a counterexample (J , d1) to the subsumption by composing two models of C u \u00acE and D, respectively, as shown in the\nproof of statement 3. Similarly, in the latter case, construct a counterexample (J , d1) to the subsumption by composing two models of C and D u \u00acF , respectively.\nProof of 4, \u201cif\u201d. Let FP denote the fixpoint expression in the left-hand side of the subsumption, and note that the left-hand side is equivalent to:\nC u \u2203sticky.(D u \u2203sticky.(. . . \u2203sticky.(D\ufe38 \ufe37\ufe37 \ufe38 ntimes uFP) . . .))\nThis makes the left-hand side directly comparable with (2). Now the \u201cif\u201d part is straightforward and left to the reader.\nProof of 4, \u201conly if\u201d. By contraposition, assume that KB 6|= C v \u22a5, KB 6|= D v \u22a5, and either KB 6|= C v G0 or KB 6|= D v G1 u . . . u Gn holds. In the former case, obtain a counterexample to the subsumption by composing two models of Cu\u00acG0 andD, respectively, as shown in the proof of 3. In the latter case, there exists i (1 \u2264 i \u2264 n) such that KB 6|= D v Di. Then obtain a counterexample to the subsumption by composing two models of C and D u \u00acGi, respectively, using the same approach as in 3.\nAs a consequence of the above lemma, we get:\nTheorem 15. Subsumption checking in PLsticky0 can be done in polynomial time.\nProof. PLsticky0 subsumption checking can always be reduced to subsumption checking in PL0. In particular, for all given PLsticky0 subsumptions C v D, either C and D are \u03bd-free (so C v D is a PL0 subsumption), or C v D falls in one of the four cases covered by Theorem 14. For each of these cases, Theorem 14 provides an equivalent set of subsumption checks that involve PL0 concepts only (as \u03bd-free PLsticky0 concepts are PL0 concepts). Since subsumption checking in PL0 is in PTIME, the same holds for PLsticky0 .\nNote that, in the worst case, a subsumption check in PLsticky0 is reduced to four subsumption checks in PL0, therefore PLsticky0 preserves the asymptotic complexity of compliance checking in PL0."
        },
        {
            "heading": "6 Discussion and Related Work",
            "text": "The approach to sticky policies outlined in the previous section is only a first step towards a complete tractable solution. The language PLsticky0 does not yet support some of the features of PL, such as intervals and unions. These two features are related, because the normalization of intervals that makes PL subsumption queries interval-safe (hence tractable) introduces unions. Some of these unions may occur within the range of \u03bd, and it is not possible \u2013 in general \u2013 to move them to the top level to reduce general policies to mere unions of Pol concepts. Therefore, it is necessary to investigate the interplay of fixpoints and unions, and its potential impact on complexity. We conjecture that \u2013 with a careful definition of PLsticky \u2013 interval safety can still be obtained efficiently (given the natural restrictions satified by\npolicies), and that the proof of Theorem 14 can be generalized to prove that tractability is preserved also in the presence of intervals and unions. Of course, the theoretical complexity analysis shall be complemented by an experimental performance evaluation to see if the ad hoc framework meets the scalability requirements of use cases.\nAnother limitation of the current version of PLsticky0 is that a single consent policy cannot permit both finite and infinite data transfer chains at the same time (cf. Theorem 14, point 2), while in some cases it may be useful to state that any number of transfers is permitted. Thus, PLsticky0 should be extended to support classes that may contain both finite and infinite chains, such as:\n\u03bdX. ( (\u2203sticky.(C uX)) tD ) ,\nwhere C is a policy that admits transfers and D a policy that does not admit transfers. This provides an independent motivation for introducing unions within the scope of \u03bd.\nIt is not easy to turn the lower complexity bounds presented in this paper into exact characterizations. On the one hand, the extensions of PL that we considered make it possible to axiomatize complex, exponentially large structures, like those used in some proofs of PSPACE-hardness; on the other hand, the limited expressiveness of PL (and in particular the restrictions on union and negation) makes it difficult to use those structures to reconstruct the complexity results that have been proved for DLs that (unlike PL) support a full set of boolean concept operators. An additional difficulty stems from the fact that, in PL\u2019s extensions, fixpoints and transitive role closures may occur only in the queries and cannot be used inside axioms.\nThe logicPL\u22000 investigated in Section 4 is similar toFL0, in some respects. It has been proved in (Nebel 1990) that subsumption checking in FL0 is coNP-complete for acyclic TBoxes.\nFixpoints have been extensively investigated in the context of description logics, see for example (Calvanese, Giacomo, and Lenzerini 1999; Bonatti and Peron 2004; Bonatti et al. 2008; Lutz, Piro, and Wolter 2010; Franconi and Toman 2011). Most of these papers deal with expressive logics whose reasoning tasks are at least EXPTIME-hard (sometimes even undecidable). The only exception is (Lutz, Piro, and Wolter 2010), that proves the tractability of EL with greatest fixpoints. This logic and PL\u03bd0 have several traits in common. The intractability of PL\u03bd0 is due to the interplay of functionality axioms (not supported by EL) with the fixpoints occurring in the queries.\nThe seminal work that started the investigation of transitive role closures is (Sattler 1996). One of its results is the proof that extendingALC with transitive role closure makes concept satisfiability EXPTIME-complete. Subsumption checking has the same complexity because, in ALC and its extensions, concept satisfiability and subsumption checking are mutually reducible to each other. The complexity of transitive role closure in EL has been studied in (Haase and Lutz 2008). It is proved that subsumption checking is complete for coNP, PSPACE, and EXPTIME if TBoxes are empty, acyclic, and cyclic, respectively.\nIt may be interesting to investigate whether regular path queries can be used to model sticky policies. A rich set of results on nested regular path queries and low-complexity DLs can be found in (Bienvenu et al. 2014). However, this paper deals with query evaluation, while the counterpart of compliance checking (i.e. subsumption checking) is query containment.\nWe conclude by pointing out that the same approach adopted for data usage policies works out of the box for licenses in financial data markets, an area that has similar requirements (i.e. support to data transfers, and need for massive and reliable compliance checking, in order to reduce the risks of sanctions due to license violations). Moreover, the \u201cShare Alike\u201d Creative Commons licence has a transitive nature, much like sticky policies. These observations open up a brand new range of applications for PL and its extensions."
        },
        {
            "heading": "Acknowledgments",
            "text": "This work is funded by the European Union with grant n. 883464. The autors are grateful to the anonymous reviewers for their insightful and constructive comments."
        }
    ],
    "title": "Sticky Policies in OWL2: Extending PL with Fixpoints and Transitive Closure",
    "year": 2022
}