{
    "abstractText": "In this work, we initiate the study of network agnostic MPC protocols with statistical security. Network agnostic MPC protocols give the best possible security guarantees, irrespective of the underlying network type. While network agnostic MPC protocols have been designed earlier with perfect and computational security, nothing is known in the literature regarding the possibility of network agnostic MPC protocols with statistical security. We consider the generaladversary model, where the adversary is characterized by an adversary structure, which enumerates all possible candidate subsets of corrupt parties. Given an unconditionally-secure PKI setup (a.k.a pseudo-signature setup), known statistically-secure synchronous MPC (SMPC) protocols are secure against adversary structures satisfying the Q condition, meaning that the union of any two subsets from the adversary structure does not cover the entire set of parties. On the other hand, known statistically-secure asynchronous MPC (AMPC) protocols can tolerate Q adversary structures where the union of any three subsets from the adversary structure does not cover the entire set of parties. Fix a set of n parties P = {P1, . . . , Pn} and adversary structures Zs and Za, satisfying the Q (2) and Q conditions respectively, where Za \u2282 Zs. Then given an unconditionally-secure PKI, we ask whether it is possible to design a statistically-secure MPC protocol, which is resilient against Zs and Za in a synchronous and an asynchronous network respectively, even if the parties in P are unaware of the network type. We show that it is possible iff Zs and Za satisfy the Q (2,1) condition, meaning that the union of any two subsets from Zs and any one subset from Za is a proper subset of P . Enroute our MPC protocol, we design several important network agnostic building blocks with the Q condition, such as Byzantine broadcast, Byzantine agreement (BA), information checking protocol (ICP), verifiable secret-sharing (VSS) and secure multiplication protocol, whose complexity is polynomial in n and |Zs|.",
    "authors": [
        {
            "affiliations": [],
            "name": "Ananya Appan"
        },
        {
            "affiliations": [],
            "name": "Ashish Choudhury"
        }
    ],
    "id": "SP:825a73e6e34b63208d7ed00252ef432c4bc063d6",
    "references": [
        {
            "authors": [
                "I. Abraham",
                "D. Dolev",
                "J.Y. Halpern"
            ],
            "title": "An Almost-surely Terminating Polynomial Protocol for Asynchronous Byzantine Agreement with Optimal Resilience",
            "venue": "In PODC,",
            "year": 2008
        },
        {
            "authors": [
                "I. Abraham",
                "D. Dolev",
                "G. Stern"
            ],
            "title": "Revisiting Asynchronous Fault Tolerant Computation with Optimal Resilience",
            "venue": "In PODC,",
            "year": 2020
        },
        {
            "authors": [
                "A. Appan",
                "A. Chandramouli",
                "A. Choudhury"
            ],
            "title": "Perfectly-Secure Synchronous MPC with Asynchronous Fallback Guarantees",
            "venue": "In PODC,",
            "year": 2022
        },
        {
            "authors": [
                "A. Appan",
                "A. Chandramouli",
                "A. Choudhury"
            ],
            "title": "Perfectly Secure Synchronous MPC with Asynchronous Fallback Guarantees Against General Adversaries",
            "venue": "IACR Cryptol. ePrint Arch.,",
            "year": 2022
        },
        {
            "authors": [
                "A. Appan",
                "A. Chandramouli",
                "A. Choudhury"
            ],
            "title": "Revisiting the Efficiency of Asynchronous MPC with Optimal Resilience Against General Adversaries",
            "venue": "J. Cryptol.,",
            "year": 2023
        },
        {
            "authors": [
                "R. Bacho",
                "D. Collins",
                "C. Liu-Zhang",
                "J. Loss"
            ],
            "title": "Network-Agnostic Security Comes for Free in DKG and MPC",
            "venue": "Cryptology ePrint Archive,",
            "year": 2022
        },
        {
            "authors": [
                "L. Bangalore",
                "A. Choudhury",
                "A. Patra"
            ],
            "title": "The Power of Shunning: Efficient Asynchronous Byzantine Agreement Revisited",
            "venue": "J. ACM,",
            "year": 2020
        },
        {
            "authors": [
                "D. Beaver"
            ],
            "title": "Efficient Multiparty Protocols Using Circuit Randomization",
            "venue": "In J. Feigenbaum, editor, CRYPTO,",
            "year": 1991
        },
        {
            "authors": [
                "Z. Beerliov\u00e1-Trub\u0301\u0131niov\u00e1",
                "M. Hirt"
            ],
            "title": "Efficient multi-party computation with dispute control",
            "venue": "In S. Halevi and T. Rabin, editors, Theory of Cryptography, Third Theory of Cryptography Conference,",
            "year": 2006
        },
        {
            "authors": [
                "Z. Beerliov\u00e1-Trub\u0301\u0131niov\u00e1",
                "M. Hirt"
            ],
            "title": "Simple and Efficient Perfectly-Secure Asynchronous MPC",
            "venue": "In ASIACRYPT,",
            "year": 2007
        },
        {
            "authors": [
                "M. Ben-Or"
            ],
            "title": "Another Advantage of Free Choice (Extended Abstract): Completely Asynchronous Agreement Protocols",
            "venue": "In PODC,",
            "year": 1983
        },
        {
            "authors": [
                "M. Ben-Or",
                "R. Canetti",
                "O. Goldreich"
            ],
            "title": "Asynchronous Secure Computation",
            "venue": "In STOC,",
            "year": 1993
        },
        {
            "authors": [
                "M. Ben-Or",
                "S. Goldwasser",
                "A. Wigderson"
            ],
            "title": "Completeness Theorems for NonCryptographic Fault-Tolerant Distributed Computation (Extended Abstract)",
            "venue": "In STOC,",
            "year": 1988
        },
        {
            "authors": [
                "M. Ben-Or",
                "B. Kelmer",
                "T. Rabin"
            ],
            "title": "Asynchronous Secure Computations with Optimal Resilience (Extended Abstract)",
            "venue": "In PODC,",
            "year": 1994
        },
        {
            "authors": [
                "E. Blum",
                "J. Katz",
                "J. Loss"
            ],
            "title": "Synchronous Consensus with Optimal Asynchronous Fallback Guarantees",
            "venue": "In TCC,",
            "year": 2019
        },
        {
            "authors": [
                "E. Blum",
                "J. Katz",
                "J. Loss"
            ],
            "title": "Tardigrade: An Atomic Broadcast Protocol for Arbitrary Network Conditions",
            "venue": "In ASIACRYPT,",
            "year": 2021
        },
        {
            "authors": [
                "E. Blum",
                "C. Liu Zhang",
                "J. Loss"
            ],
            "title": "Always Have a Backup Plan: Fully Secure Synchronous MPC with Asynchronous Fallback",
            "venue": "In CRYPTO,",
            "year": 2020
        },
        {
            "authors": [
                "G. Bracha"
            ],
            "title": "An Asynchronous [(n-1)/3]-Resilient Consensus Protocol",
            "venue": "In PODC, pages 154\u2013162",
            "year": 1984
        },
        {
            "authors": [
                "R. Canetti"
            ],
            "title": "Studies in Secure Multiparty Computation and Applications",
            "venue": "PhD thesis, Weizmann Institute,",
            "year": 1995
        },
        {
            "authors": [
                "R. Canetti"
            ],
            "title": "Universally Composable Security: A New Paradigm for Cryptographic Protocols",
            "venue": "In FOCS,",
            "year": 2001
        },
        {
            "authors": [
                "R. Canetti",
                "T. Rabin"
            ],
            "title": "Fast Asynchronous Byzantine Agreement with Optimal Resilience",
            "venue": "In STOC,",
            "year": 1993
        },
        {
            "authors": [
                "B. Chor",
                "S. Goldwasser",
                "S. Micali",
                "B. Awerbuch"
            ],
            "title": "Verifiable Secret Sharing and Achieving Simultaneity in the Presence of Faults (Extended Abstract)",
            "venue": "In 26th Annual Symposium on Foundations of Computer Science, Portland, Oregon, USA,",
            "year": 1985
        },
        {
            "authors": [
                "A. Choudhury"
            ],
            "title": "Almost-Surely Terminating Asynchronous Byzantine Agreement Against General Adversaries with Optimal Resilience",
            "venue": "In ICDCN,",
            "year": 2023
        },
        {
            "authors": [
                "A. Choudhury",
                "A. Patra"
            ],
            "title": "An Efficient Framework for Unconditionally Secure Multiparty Computation",
            "venue": "IEEE Trans. Information Theory,",
            "year": 2017
        },
        {
            "authors": [
                "A. Choudhury",
                "A. Patra"
            ],
            "title": "On the Communication Efficiency of Statistically Secure Asynchronous MPC with Optimal Resilience",
            "venue": "J. Cryptol.,",
            "year": 2023
        },
        {
            "authors": [
                "R. Cramer",
                "I. Damg\u030aard",
                "S. Dziembowski",
                "M. Hirt",
                "T. Rabin"
            ],
            "title": "Efficient Multiparty Computations Secure Against an Adaptive Adversary",
            "venue": "In EUROCRYPT,",
            "year": 1999
        },
        {
            "authors": [
                "I. Damg\u030aard",
                "V. Pastro",
                "N.P. Smart",
                "S. Zakarias"
            ],
            "title": "Multiparty Computation from Somewhat Homomorphic Encryption",
            "venue": "Advances in Cryptology - CRYPTO 2012 - 32nd Annual Cryptology Conference, Santa Barbara, CA,",
            "year": 2012
        },
        {
            "authors": [
                "G. Deligios",
                "C. Liu-Zhang"
            ],
            "title": "Synchronous Perfectly Secure Message Transmission with Optimal Asynchronous Fallback Guarantees",
            "venue": "IACR Cryptol. ePrint Arch.,",
            "year": 2022
        },
        {
            "authors": [
                "D. Dolev",
                "C. Dwork",
                "O. Waarts",
                "M. Yung"
            ],
            "title": "Perfectly Secure Message Transmission",
            "venue": "J. ACM,",
            "year": 1993
        },
        {
            "authors": [
                "Danny Dolev",
                "H. Raymond Strong"
            ],
            "title": "Authenticated algorithms for byzantine agreement",
            "venue": "SIAM J. Comput.,",
            "year": 1983
        },
        {
            "authors": [
                "Pesech Feldman",
                "Silvio Micali"
            ],
            "title": "An optimal probabilistic protocol for synchronous byzantine agreement",
            "venue": "SIAM Journal on Computing,",
            "year": 1997
        },
        {
            "authors": [
                "M.J. Fischer",
                "N.A. Lynch",
                "M. Paterson"
            ],
            "title": "Impossibility of Distributed Consensus with One Faulty Process",
            "venue": "J. ACM,",
            "year": 1985
        },
        {
            "authors": [
                "M. Fitzi",
                "U.M. Maurer"
            ],
            "title": "Efficient Byzantine Agreement Secure Against General Adversaries",
            "venue": "In DISC,",
            "year": 1998
        },
        {
            "authors": [
                "Matthias Fitzi"
            ],
            "title": "Generalized Communication and Security Models in Byzantine Agreement",
            "venue": "PhD thesis,",
            "year": 2002
        },
        {
            "authors": [
                "D. Ghinea",
                "C. Liu-Zhang",
                "R. Wattenhofer"
            ],
            "title": "Optimal Synchronous Approximate Agreement with Asynchronous Fallback",
            "venue": "In PODC,",
            "year": 2022
        },
        {
            "authors": [
                "O. Goldreich",
                "S. Micali",
                "A. Wigderson"
            ],
            "title": "How to Play any Mental Game or A Completeness Theorem for Protocols with Honest Majority",
            "venue": "Proceedings of the 19th Annual ACM Symposium on Theory of Computing,",
            "year": 1987
        },
        {
            "authors": [
                "V. Goyal",
                "Y. Song",
                "C. Zhu"
            ],
            "title": "Guaranteed Output Delivery Comes Free in Honest Majority MPC",
            "venue": "In CRYPTO,",
            "year": 2020
        },
        {
            "authors": [
                "Martin Hirt",
                "Ueli Maurer"
            ],
            "title": "Complete characterization of adversaries tolerable in secure multi-party computation (extended abstract)",
            "venue": "In PODC,",
            "year": 1997
        },
        {
            "authors": [
                "Martin Hirt",
                "Ueli Maurer"
            ],
            "title": "Player simulation and general adversary structures in perfect multiparty computation",
            "venue": "Journal of Cryptology,",
            "year": 2000
        },
        {
            "authors": [
                "Martin Hirt",
                "Daniel Tschudi"
            ],
            "title": "Efficient general-adversary multi-party computation",
            "venue": "In ASIACRYPT,",
            "year": 2013
        },
        {
            "authors": [
                "M. Ito",
                "A. Saito",
                "T. Nishizeki"
            ],
            "title": "Secret Sharing Schemes Realizing General Access Structures)",
            "venue": "In Global Telecommunication Conference,",
            "year": 1987
        },
        {
            "authors": [
                "M.V.N. Ashwin Kumar",
                "K. Srinathan",
                "C. Pandu Rangan"
            ],
            "title": "Asynchronous Perfectly Secure Computation Tolerating Generalized Adversaries",
            "venue": "In ACISP,",
            "year": 2002
        },
        {
            "authors": [
                "K. Kursawe",
                "F.C. Freiling"
            ],
            "title": "Byzantine Fault Tolerance on General Hybrid Adversary Structures",
            "venue": "Technical Report, RWTH Aachen,",
            "year": 2005
        },
        {
            "authors": [
                "U.M. Maurer"
            ],
            "title": "Secure Multi-party Computation Made Simple",
            "venue": "In SCN,",
            "year": 2002
        },
        {
            "authors": [
                "A. Momose",
                "L. Ren"
            ],
            "title": "Multi-Threshold Byzantine Fault Tolerance",
            "venue": "In CCS,",
            "year": 2021
        },
        {
            "authors": [
                "Atsuki Momose",
                "Ling Ren"
            ],
            "title": "Multi-threshold byzantine fault tolerance",
            "venue": "In Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security, CCS",
            "year": 2021
        },
        {
            "authors": [
                "A. Most\u00e9faoui",
                "H. Moumen",
                "M. Raynal"
            ],
            "title": "Signature-Free Asynchronous Binary Byzantine Consensus with t < n/3",
            "venue": "Expected Time. J. ACM,",
            "year": 2015
        },
        {
            "authors": [
                "A. Patra",
                "A. Choudhury",
                "C. Pandu Rangan"
            ],
            "title": "Efficient Asynchronous Verifiable Secret Sharing and Multiparty Computation",
            "venue": "J. Cryptology,",
            "year": 2015
        },
        {
            "authors": [
                "Marshall Pease",
                "Robert Shostak",
                "Leslie Lamport"
            ],
            "title": "Reaching Agreement in the Presence of Faults",
            "venue": "Journal of the ACM (JACM),",
            "year": 1980
        },
        {
            "authors": [
                "B. Pfitzmann",
                "M.Waidner"
            ],
            "title": "Information-theoretic Pseudosignatures and Byzantine Agreement for t \u2265 n/3",
            "venue": "Technical Report RZ",
            "year": 1996
        },
        {
            "authors": [
                "Michael O. Rabin"
            ],
            "title": "Randomized Byzantine Generals",
            "venue": "In 24th Annual Symposium on Foundations of Computer Science, Tucson, Arizona, USA,",
            "year": 1983
        },
        {
            "authors": [
                "T. Rabin",
                "M. Ben-Or"
            ],
            "title": "Verifiable Secret Sharing and Multiparty Protocols with Honest Majority (Extended Abstract)",
            "venue": "In STOC,",
            "year": 1989
        }
    ],
    "sections": [
        {
            "text": "ar X\niv :2\n30 6.\n01 40\n1v 1\n[ cs\n.C R\n] 2\nJ un\n2 02\nFix a set of n parties P = {P1, . . . , Pn} and adversary structures Zs and Za, satisfying the Q\n(2) and Q(3) conditions respectively, where Za \u2282 Zs. Then given an unconditionally-secure PKI, we ask whether it is possible to design a statistically-secure MPC protocol, which is resilient against Zs and Za in a synchronous and an asynchronous network respectively, even if the parties in P are unaware of the network type. We show that it is possible iff Zs and Za satisfy the Q\n(2,1) condition, meaning that the union of any two subsets from Zs and any one subset from Za is a proper subset of P . Enroute our MPC protocol, we design several important network agnostic building blocks with the Q(2,1) condition, such as Byzantine broadcast, Byzantine agreement (BA), information checking protocol (ICP), verifiable secret-sharing (VSS) and secure multiplication protocol, whose complexity is polynomial in n and |Zs|."
        },
        {
            "heading": "1 Introduction",
            "text": "A secure multiparty computation (MPC) protocol [53,36,13,52] allows a set of n mutually distrusting parties P = {P1, . . . , Pn} with private inputs to securely compute any known function f of their inputs. This is achieved even if a subset\n\u22c6 Work done as a student at IIIT Bangalore.\nof the parties are under the control of a centralized adversary and behave maliciously in a Byzantine fashion during the protocol execution. In any MPC protocol, the parties need to interact over the underlying communication network. Two types of networks have been predominantly considered. The more popular synchronous MPC (SMPC) protocols operate over a synchronous network, where every message sent is delivered within a known \u2206 time. Hence, if a receiving party does not receive an expected message within \u2206 time, then it knows that the corresponding sender party is corrupt. The synchronous model does not capture real world networks like the Internet appropriately, where messages can be arbitrarily delayed. Such networks are better modelled by the asynchronous communication model [19]. In any asynchronous MPC (AMPC) protocol [12,14], there are no timing assumptions on message delays and messages can be arbitrarily, yet finitely delayed. The only guarantee is that every message sent will be eventually delivered. The major challenge here is that no participant will know how long it has to wait for an expected message and cannot distinguish a \u201cslow\u201d sender party from a corrupt sender party. Consequently, in any AMPC protocol, a party cannot afford to receive messages from all the parties, to avoid an endless wait. Hence, to make \u201cprogress\u201d, as soon a party receives messages from a \u201csubset\u201d of the parties, it has to process them as per the protocol, thus ignoring messages from a subset of potentially non-faulty but slow parties.\nSMPC protocols are relatively simpler and enjoy better fault-tolerance (which is the maximum number of faults tolerable) compared to AMPC protocols. However, SMPC protocols become completely insecure even if a single message (from a non-faulty party) gets delayed. AMPC protocols do not suffer from this shortcoming. On the negative side, AMPC protocols are far more complex than SMPC protocols and enjoy poor fault-tolerance. Moreover, every AMPC protocol suffers from input deprivation [10] where, to avoid an endless wait, inputs of all non-faulty parties may not be considered for the computation of f .\nNetwork Agnostic MPC Protocols. There is a third category of protocols called network agnostic MPC protocols, where the parties will not be knowing the network type and the protocol should provide the best possible security guarantees depending upon the network type. Such protocols are practically motivated, since the parties need not have to worry about the network type."
        },
        {
            "heading": "1.1 Our Motivation and Results",
            "text": "One of the earliest demarcations made in the literature is to categorize MPC protocols based on the computing power of the underlying adversary. The two main categories are unconditionally-secure protocols, which remain secure even against computationally-unbounded adversaries, and conditionally-secure MPC protocols (also called cryptographically-secure), which remain secure only against computationally-bounded adversaries [53,36]. Unconditionally-secure protocols can be further categorized as perfectly-secure [13,12] or statistically-secure [52,14], depending upon whether the security guarantees are error-free or achieved except with a negligible probability. The fault-tolerance of statistically-secure MPC\nprotocols are significantly better compared to perfectly-secure protocols. The above demarcation carries over even for network agnostic MPC protocols. While perfectly-secure and cryptographically-secure network agnostic MPC protocols have been investigated earlier, nothing is known regarding network agnostic statistically-secure MPC protocols. In this work we derive necessary and sufficient condition for such protocols for the first time.\nExisting Results for Statistically-Secure MPC. Consider the threshold setting, where the maximum number of corrupt parties under the adversary\u2019s control is upper bounded by a given threshold. In this model, it is known that statistically-secure SMPC tolerating up to ts faulty parties is possible iff ts < n/2 [52], provided the parties are given some unconditionally-secure PKI (a.k.a pseudo-signature setup) [50,34].3 On the other hand, statistically-secure AMPC tolerating up to ta faulty parties is possible iff ta < n/3 [14,2].\nA more generalized form of corruption is the general adversary model (also called non-threshold model) [38]. Here, the adversary is specified through a publicly known adversary structure Z \u2282 2P , which is the set of all subsets of potentially corruptible parties during the protocol execution. The adversary is allowed to choose any one subset from Z for corruption. There are several \u201cmerits\u201d of studying the general adversary model. For example, it provides more flexibility to model corruption in a fine-grained fashion. A threshold adversary is always a \u201cspecial\u201d type of non-threshold adversary. Consequently, a protocol in the nonthreshold setting always implies a protocol in the threshold setting. Also, the protocols in this model are relatively simpler and based on simpler primitives, compared to protocols against threshold adversaries based on complex properties of bivariate polynomials. The downside is that the complexity of the protocols in the non-threshold model is polynomial in n and |Z|, where the latter could be O(2n) in the worst case. In fact, as noted in [38,39], this is unavoidable.\nFollowing [38], given a subset of parties P \u2032 \u2286 P and Z, we say that Z satisfies the Q(k)(P \u2032,Z) condition, if the union of any k subsets from Z does not \u201ccover\u201d P \u2032. That is, for any subsets Zi1 , . . . , Zik \u2208 Z, the condition (Zi1 \u222a . . . \u222a Zik) \u2282 P\n\u2032 holds. In the non-threshold model, statistically-secure SMPC is possible if the underlying adversary structure Zs satisfies the Q(2)(P ,Zs) condition, provided the parties are given an unconditionally-secure PKI setup [40], while statistically-secure AMPC requires the underlying adversary structure Za to satisfy the Q(3)(P ,Za) condition [40,5].\nOur Results for Network Agnostic Statistically-Secure MPC. We consider the most generic form of corruption and ask the following question:\nGiven an unconditionally-secure PKI, a synchronous adversary structure Zs and an asynchronous adversary structure Za satisfying the Q(2)(P ,Zs) and\nQ(3)(P ,Za) conditions respectively, where Za \u2282 Zs, does there exist a statistically-secure MPC protocol, which remains secure against Zs and Za in a\nsynchronous and an asynchronous network respectively?\n3 The setup realizes unconditionally-secure Byzantine agreement [49] with ts < n/2.\nWe answer the above question affirmatively, iff Zs and Za satisfy the Q(2,1)(P ,Zs,Za) condition, where by Q(k,k\n\u2032)(P ,Zs,Za) condition, we mean that for any Zi1 , . . . , Zik \u2208 Zs and Zj1 , . . . ,Zjk\u2032 \u2208 Za, the following holds:\n(Zi1 \u222a . . . \u222a Zik \u222a Zj1 \u222a . . . \u222a Zj\u2032k) \u2282 P .\nOur results when applied against threshold adversaries imply that given an unconditionally-secure PKI, and thresholds 0 < ta < n 3 < ts < n 2 , network agnostic statistically-secure MPC tolerating ts and ta corruptions in the synchronous and asynchronous network is possible, iff 2ts + ta < n holds. Our results in the context of relevant literature are summarized in Table 1."
        },
        {
            "heading": "1.2 Detailed Technical Overview",
            "text": "We perform shared circuit-evaluation [13,52], where f is abstracted as an arithmetic circuit ckt over a finite field F and the goal is to securely evaluate each gate in ckt in a secret-shared fashion. For every value during the circuit-evaluation, each party holds a share, such that the shares of the corrupt parties do not reveal any additional information. Once the function output is secret-shared, it is publicly reconstructed. We deploy a linear secret-sharing scheme, which enables the parties to evaluate linear gates in ckt in a non-interactive fashion. Non-linear gates are evaluated using Beaver\u2019s method [8] by deploying secret-shared random multiplication-triples which are generated beforehand.\nTo instantiate the above approach with statistical security, we need the following ingredients: a Byzantine agreement (BA) protocol [49], an information checking protocol (ICP) [52], a verifiable secret sharing (VSS) protocol [22], a\nreconstruction protocol and finally, a secure multiplication protocol. All existing statistically-secure SMPC [52,26,9,37,40] and AMPC [14,48,24,25,5] protocols have instantiations of the above building blocks, either in the synchronous or asynchronous setting. However, in a network agnostic setting, we face several challenges to instantiate the above building blocks. We now take the reader through a detailed tour of the technical challenges and how we deal with them.\n1.2.1 Network Agnostic BA with Q(2,1)(P,Zs,Za) Condition\nA BA protocol [49] allows the parties in P with private input bits to agree on a common output bit (consistency), which is the input of the non-faulty parties, if they have the same input bit (validity). Given an unconditionally-secure PKI, synchronous BA (SBA) is possible iff the underlying adversary structure Zs satisfies the Q(2)(P ,Zs) condition [50,33,34], while asynchronous BA (ABA) requires the underlying adversary structure Za to satisfy the Q(3)(P ,Za) condition [23]. Existing SBA protocols become completely insecure in an asynchronous network. On the other hand, any ABA protocol becomes insecure when executed in a synchronous network, since Zs need not satisfy the Q(3)(P ,Zs) condition. Hence, we design a network agnostic BA protocol with Q(2,1)(P ,Zs,Za) condition. The protocol is obtained by generalizing the blueprint for network agnostic BA against threshold adversaries, first proposed in [15] and later used in [3]. While [15] proposed it for computational security with conditions 0 < ta < n 3 < ts < n 2 and 2ts + ta < n in the presence of a computationally-secure PKI, later, [3] modified it for perfect security and used it with conditions ta, ts < n/3.\n4 We replace the computationally-secure PKI with an unconditionally-secure PKI and generalize the building blocks of [15] against non-threshold adversaries and upgrade their security to unconditional-security. Additionally, we also generalize certain primitives from [3] and adapt them to work with the Q(2,1)(P ,Zs,Za) condition. Since this part mostly follows the existing works, we refer to Section 3 for full details.\n1.2.2 Network Agnostic ICP with Q(2,1)(P,Zs,Za) Condition\nAn ICP [52,26] is used for authenticating data in the presence of a computationally-unbounded adversary. In an ICP, there are four entities, a signer S \u2208 P , an intermediary I \u2208 P , a receiver R \u2208 P and all the parties in P acting as verifiers (note that S, I and R also act as verifiers). An ICP has two sub-protocols, one for the authentication phase and one for the revelation phase.\nIn the authentication phase, S has a private input s \u2208 F, which it distributes to I along with some authentication information. Each verifier is provided with some verification information, followed by the parties verifying whether S has distributed \u201cconsistent\u201d information. If the verification is \u201csuccessful\u201d, then the data held by I at the end of this phase is called S\u2019s IC-Signature on s for intermediary I and receiver R, denoted by ICSig(S, I,R, s). Later, during the revelation\n4 Unlike computationally-secure BA, the necessary condition for perfectly-secure BA is t < n/3 for both SBA as well as ABA, where t is the maximum number of faults.\nphase, I reveals ICSig(S, I,R, s) to R, who \u201cverifies\u201d it with respect to the verification information provided by the verifiers and either accepts or rejects s. We require the same security guarantees from ICP as expected from cryptographic signatures, namely correctness (if S, I and R are all honest, then R should accept s), unforgeability (a corrupt I should fail to reveal an honest S\u2019s signature on s\u2032 6= s) and non-repudiation (if an honest I holds some ICSig(S, I,R, s), then later an honest R should accept s, even if S is corrupt). Additionally, we need privacy, guaranteeing that if S, I and R are all honest, then Adv does not learn s.5\nThe only known instantiation of ICP in the synchronous network [40] is secure against Q(2) adversary structures and becomes insecure in the asynchronous setting. On the other hand, the only known instantiation of ICP in the asynchronous setting [5] can tolerate only Q(3) adversary structures. Our network agnostic ICP is a careful adaptation of the asynchronous ICP of [5]. We first try to naively adapt the ICP to deal with the network agnostic setting, followed by the technical problems in the naive adaptation and the modifications needed.\nDuring authentication phase, S embeds s in a random t-degree polynomial F (x) at x = 0, where t is the cardinality of the maximum-sized subset in Zs, and gives F (x) to I. In addition, each verifier Pi is given a random verificationpoint (\u03b1i, vi) on F (x). To let the parties securely verify that it has distributed consistent information, S additionally distributes a random t-degree polynomial M(x) to I, while each verifier Pi is given a point on M(x) at \u03b1i. Each verifier, upon receiving its verification-points, publicly confirms the same. Upon receiving these confirmations, I identifies a a subset of supporting verifiers SV which have confirmed the receipt of their verification-points. To avoid an endless wait, I waits until P \\ SV \u2208 Zs. After this, the parties publicly check the consistency of the F (x),M(x) polynomials and the points distributed to SV , with respect to a random linear combination of these polynomials and points, where the linear combiner is selected by I. This ensures that S has no knowledge beforehand about the random combiner and hence, any \u201cinconsistency\u201d will be detected with a high probability. If no inconsistency is detected, the parties proceed to the revelation phase, where I reveals F (x) to R, while each verifier in SV reveals its verificationpoint to R, who accepts F (x) (and hence F (0)) if it sure that the verification point of at least one non-faulty verifier in SV is \u201cconsistent\u201d with the revealed F (x). This would ensure that the revealed F (x) is indeed correct with a high probability, since a corrupt I will have no information about the verification point of any non-faulty verifier in SV , provided S is non-faulty. To avoid an endless wait, once R finds a subset of verifiers SV \u2032 \u2286 SV , where SV \\ SV \u2032 \u2208 Zs, whose verification-points are found to be \u201cconsistent\u201d with F (x), it outputs F (0)."
        },
        {
            "heading": "5 IC-signatures are different from pseudo-signatures. Pseudo-signatures are \u201ctransferable\u201d, where a party can transfer a signed message to other parties for verification",
            "text": "(depending upon the allowed level of transferability), while IC-signatures can be verified only by the designated R and cannot be further transferred. Due to the same reason, IC-signatures satisfy the privacy property unlike pseudo-signatures. Most importantly, IC-signatures are generated from the scratch, assuming a pseudo-signature setup which is used to instantiate the instances of broadcast in the ICP.\nA Technical Problem and Way-out. The protocol outlined above will achieve all the properties in an asynchronous network, due to the Q(3)(P ,Za) condition. However, it fails to satisfy the unforgeability property in a synchronous network. Namely, a corrupt I may not include all the non-faulty verifiers in SV and may purposely exclude a subset of non-faulty verifiers belonging to Zs. Let HSV be the set of non-faulty verifiers in SV and let CSV be the set of corrupt verifiers in SV . Due to the above strategy, the condition Q(1)(HSV ,Zs) may not be satisfied and SV \\ CSV = HSV \u2208 Zs may hold. As a result, during the revelation phase, I may produce an incorrect F \u2032(x) 6= F (x) and the verifiers in CSV may change their verification points to \u201cmatch\u201d F \u2032(x), while only the verification points of the verifiers in HSV may turn out to be inconsistent with F\n\u2032(x). Consequently, SV \u2032 = CSV and if HSV \u2208 Zs, then clearly s\u2032 = F \u2032(0) will be the output of R, thus breaking the unforgeability property.\nTo deal with the above issue, we let S identify and announce SV . This ensures that all honest verifiers are present in SV , if S is honest and the network is synchronous, provided S waits for \u201csufficient\u201d time to let the verifiers announce the receipt of their verification points. Consequently, now the condition Q(1)(HSV ,Zs) will be satisfied. Hence, if a corrupt I reveals an incorrect F (x), then it will not be accepted, as the condition SV \\ CSV \u2208 Zs no longer holds.\nLinearity of ICP. Our ICP satisfies the linearity property (which will be useful later in our VSS), provided \u201cspecial care\u201d is taken while generating the ICsignatures. Consider a fixed S, I and R and let sa and sb be two values, such that I holds ICSig(S, I,R, sa) and ICSig(S, I,R, sb), where all the following conditions are satisfied during the underlying instances of the authentication phase. \u2013 The set of supporting verifiers SV are the same during both the instances. \u2013 For i = 1, . . . , n, corresponding to the verifier Pi, signer S uses the same \u03b1i,\nto compute the verification points, during both the instances. \u2013 I uses the same linear combiner to verify the consistency of the distributed\ndata in both the instances.\nLet s def = c1 \u00b7sa+ c2 \u00b7sb, where c1, c2 are publicly known constants from F. It then follows that if all the above conditions are satisfied, then I can locally compute ICSig(S, I,R, s) from ICSig(S, I,R, sa) and ICSig(S, I,R, sb), while each verifier in SV can locally compute their corresponding verification information."
        },
        {
            "heading": "1.2.3 Network Agnostic VSS and Reconstruction",
            "text": "In the network agnostic setting, to ensure privacy, all the values during the circuit evaluation need to be secret-shared \u201cwith respect\u201d to Zs irrespective of the network type. We follow the notion of additive secret-sharing [41], also used in the earlier MPC protocols [44,40,5]. Given Zs = {Z1, . . . , Z|Zs|}, we consider the sharing specification SZs = {S1, . . . , S|Zs|}, where each Sq = P \\ Zq. Hence there exists at least one subset Sq \u2208 S|Zs| which does not contain any faulty party, irrespective of the network type (since Za \u2282 Zs). A value s \u2208 F is said to be secret-shared, if there exist shares s1, . . . , s|Zs| which sum up to s, such that all (non-faulty) parties in Sq have the share sq. We denote a secret-sharing of s by [s],\nwith [s]q denoting the share corresponding to Sq. If [s]1, . . . , [s]|Zs| are randomly chosen, then the probability distribution of the shares learnt by the adversary will be independent of s, since at least one share will bemissing for the adversary. We also note that the above secret-sharing is linear since, given secret-sharings [a] and [b] and publicly known constants c1, c2 \u2208 F, the condition c1 \u00b7[a]+c2 \u00b7[b] = [c1 \u00b7a+ c2 \u00b7 b] holds. Consequently, the parties can non-interactively compute any publicly known linear function of secret-shared values. Unfortunately, the above secret-sharing does not allow for the robust reconstruction of a secret-shared value. This is because the corrupt parties may produce incorrect shares at the time of reconstruction. To deal with this, we \u201caugment\u201d the above secret-sharing. As part of secret-sharing s, we also have publicly known core-sets W1, . . . ,W|Zs|, where each Wq \u2286 Sq such that Zs satisfies the Q(1)(Wq,Zs) condition (ensuring Wq has at least one non-faulty party). Moreover, each (non-faulty) Pi \u2208 Wq will have the IC-signature ICSig(Pj , Pi, Pk, [s]q) of every Pj \u2208 Wq, for every Pk 6\u2208 Sq, such that the underlying IC-signatures satisfy the linearity property.\nWe call this augmented secret sharing as linear secret-sharing with ICsignatures, which is still denoted as [s]. Now to robustly reconstruct a secretshared s, we ask the parties in Wq to make public the share [s]q, along with the IC-signatures of all the parties in Wq on [s]q. Any party Pk can then verify whether [s]q revealed by Pi is correct by verifying the IC-signatures. If Pi is corrupt then, due to the unforgeability if ICP, it will fail to forge IC-signature of a non-faulty Pj on an incorrect [s]q. On the other hand, a non-faulty Pi will be able to reveal the correct [s]q and the IC-signature of every Pj \u2208 Wq on [s]q, which are accepted even if Pj is corrupt (follows from non-repudiation of ICP).\nWe design a network agnostic VSS protocol \u03a0VSS, which allows a designated dealer D \u2208 P with input s \u2208 F to verifiably generate [s], where s remains private for a non-faulty s. If D is faulty then either no non-faulty party obtains any output (if D does not invoke the protocol) or there exists some s\u22c6 \u2208 F such that the parties output [s\u22c6]. To design \u03a0VSS, we use certain ideas from the statisticallysecure synchronous VSS (SVSS) and asynchronous VSS (AVSS) of [40] and [5] respectively, along with some new counter-intuitive ideas. In the sequel, we first give a brief outline of the SVSS and AVSS of [40,5], followed by the technical challenges arising in the network agnostic setting and how we deal with them.\nStatistically-Secure SVSS of [40] with Q(2)(P ,Zs) Condition. The SVSS of [40] proceeds as a sequence of synchronized phases. During the first phase, D picks random shares s1, . . . , s|Zs| which sum up to s and sends sq to the parties in Sq. To verify whether D has distributed consistent shares to the parties in Sq, during the second phase, every pair of parties Pi, Pj \u2208 Sq exchange the supposedly common shares received from D, along with their respective IC-signatures. That is Pi, upon receiving sqi from D, gives {ICSig(Pi, Pj , Pk, sqi)}Pk\u2208P to Pj while Pj , upon receiving sqj from D, gives {ICSig(Pj , Pi, Pk, sqj)}Pk\u2208P to Pi. Then during the third phase, the parties in Sq publicly complain about any \u201cinconsistency\u201d, in response to which D makes public the share sq corresponding to Sq during the fourth phase. Hence, by the end of fourth phase it is ensured that, for every Sq, either the share sq is publicly known (if any complaint was\nreported for Sq) or all (non-faulty) parties in Sq have the same share (along with the respective IC-signatures of each other on it). The privacy of s is maintained for a non-faulty D, since the share sq corresponding to the set Sq consisting of only non-faulty parties is never made public.\nStatistically-Secure AVSS of [5] with Q(3)(P ,Za) Condition. Let Za = {Z1, . . . ,Z|Za|} and SZa = {S1, . . . , S|Za|}, where each Sq = P \\ Zq. The AVSS protocol of [5] also follows an idea similar to the SVSS of [40]. However, now the parties cannot afford to wait for all the parties in Sq to report the statuses of pairwise consistency tests, as the corrupt parties in Sq may never turn up. Hence instead of looking for inconsistencies in Sq, the parties rather check how many parties in Sq are reporting the pairwise consistency of their supposedly common share. The idea is that if D has not cheated, then a subset of parties Wq where Sq \\ Wq \u2208 Za should eventually confirm the receipt of a common share from D. Hence, the parties check for core-sets W1, . . . ,W|Za|, where each Sq \\Wq \u2208 Za, such that the parties in Wq have confirmed the receipt of a common share from D. Note that irrespective of D, each Wq is bound to have at least one non-faulty party, since Za will satisfy the Q(1)(Wq,Za) condition.\nThe existence of W1, . . . ,W|Za| does not imply that all non-faulty parties in Sq have received a common share, even if D is non-faulty, since there might be non-faulty parties outside Wq. Hence, after the confirmation of the sets W1, . . . ,W|Za|, the goal is to ensure that every (non-faulty) party in Sq \\ Wq also gets the common share held by the (non-faulty) parties in Wq. For this, the parties in Wq reveal their shares to these \u201coutsider\u201d parties, along with the required IC-signatures. The outsider parties then \u201cfilter\u201d out the correctly revealed shares. The existence of at least one non-faulty party in each Wq guarantees that the shares filtered by the outsider parties are indeed correct.\nTechnical Challenges for Network Agnostic VSS and Way Out. Since, in our context, the parties will not be knowing the network type, our approach will be to follow the AVSS of [5], where we look for pairwise consistency of supposedly the common share in each group. Namely, D on having the input s, picks random shares s1, . . . , s|Zs| which sum up to s and distributes sq to each Sq \u2208 S|Zs|\n6. The parties in Sq then exchange IC-signed versions of their supposedly common share. To avoid an endless wait, the parties can only afford to wait till a subset of parties Wq \u2286 Sq have confirmed the receipt of a common share from D, where Sq \\Wq \u2208 Zs holds. Unfortunately, Sq \\Wq \u2208 Zs need not guarantee that Wq has at least one non-faulty party, since Zs need not satisfy the Q(1)(Wq,Zs) condition, which is desired as per our semantics of linear secretsharing with IC-signatures.\nTo deal with the above problem, we note that if D has distributed the shares consistently, then the subset of parties S \u2208 SZs which consists of only nonfaulty parties will publicly report the pairwise consistency of their supposedly common share. Hence, we now let D search for a candidate set Sp of parties from\n6 Recall that we need [s] with respect to Zs, irrespective of the network type.\nSZs which have publicly confirmed the pairwise consistency of their supposedly common share. Once D finds such a candidate Sp, it computes and make public the core-sets Wq as per the following rules, for q = 1, . . . , |Zs|. \u2013 If all the parties in Sq have confirmed the pairwise consistency of their sup-\nposedly common share, then set Wq = Sq. (A) \u2013 Else if Zs satisfies the Q(1)(Sp \u2229Sq,Zs) condition and the parties in (Sp \u2229Sq)\nhave confirmed the consistency of their supposedly common share, then set Wq = (Sp \u2229 Sq). (B) \u2013 Else set Wq = Sq and make public the share sq. (C) The parties wait till they see D making public some set Sp \u2208 SZs , along with sets W1, . . . ,W|Zs|. Upon receiving, the parties verify and \u201capprove\u201d these sets as valid, provided all parties in Sp have confirmed the pairwise consistency of their supposedly common share and if each Wq is computed as per the rule (A), (B) or (C). If W1, . . . ,W|Zs| are approved, then they indeed satisfy the requirements of core-sets as per our semantics of linear secret-sharing with ICsignatures. While this is trivially true if any Wq is computed either using rule (A) or rule (B), the same holds even if Wq is computed using rule (C). This is because, in this case, the parties publicly set [s]q = sq. Moreover, the parties take a \u201cdefault\u201d (linear) IC-signature of sq on the behalf of Sq, where the IC-signature as well as verification points are all set to sq.\nIf D is non-faulty, then irrespective of the network type, it will always find a candidate Sp and hence, compute and make public W1, . . . ,W|Zs| as per the above rules. This is because the set S always constitutes a candidate Sp. Surprisingly we can show that even if the core-sets are computed with respect to some different candidate Sp 6= S, a non-faulty D will never make public the share corresponding to S, since the rule (C) will not be applicable over S, implying the privacy of s. If the network is synchronous, then the parties in Sp as well as S would report the pairwise consistency of their respective supposedly common share at the same time. This is ensured by maintaining sufficient \u201ctimeouts\u201d in the protocol to report pairwise consistency of supposedly common shares. Consequently, rule (A) will be applied on S. For an asynchronous network, rule (B) will be applicable for S, as Zs will satisfy the Q(1)(Sp \u2229 S,Zs) condition, due to the Q(2,1)(P ,Zs,Za) condition and the fact that S = P \\ Z for some Z \u2208 Za in the asynchronous network."
        },
        {
            "heading": "1.2.4 Network Agnostic VSS for Multiple Dealers with Linearity",
            "text": "Technical Challenge in \u03a0VSS for Multiple Dealers. If different dealers invoke instances of \u03a0VSS to secret-share their inputs, then the linearity property of [\u00b7]-sharing need not hold, since the underlying core-sets might be different. In more detail, let Da and Db be two different dealers which invoke instances \u03a0 (a) VSS and \u03a0 (b) VSS to generate [a] and [b] respectively. Let W (a) 1 , . . . ,W (a) |Zs| and W (b) 1 , . . . ,W (b) |Zs| be the underlying core-sets for \u03a0 (a) VSS and \u03a0 (b) VSS respectively. Now consider a scenario where, for some q \u2208 {1, . . . , |Zs|}, the core-sets W (a) q and W (b) q are different, even though Zs satisfies the Q(1)(W (a) q ,Zs) and\nQ(1)(W (b) q ,Zs) conditions. Let c def = a + b. Then the parties in Sq can compute [c]q = [a]q + [b]q. As part of [a], every (non-faulty) Pi \u2208 W (a) q has the ICsignature {ICSig(Pj , Pi, Pk, [a]q)}Pj\u2208W(a)q ,Pk 6\u2208Sq , while as part of [b], every (nonfaulty) Pe \u2208 W (b) q has the IC-signature {ICSig(Pd, Pe, Pf , [b]q)}Pd\u2208W(b)q ,Pf 6\u2208Sq , where the underlying IC-signatures satisfy the linearity property. However, since W (a) q 6= W (b) q , it is not guaranteed that we have a core-set W (c) q as part of [c], where Zs satisfies the Q(1)(W (c) q ,Zs) condition, such that every (non-faulty) Pi \u2208 W (c) q has the IC-signature {ICSig(Pj , Pi, Pk, [c]q)}Pj\u2208W(c)q ,Pk 6\u2208Sq . If W (a) q = W (b) q , then the parties could set W (c) q to W (a) q and the linearity of IC-signatures would have ensured that every (non-faulty) Pi \u2208 W (c) q non-interactively computes {ICSig(Pj , Pi, Pk, [c]q)}Pj\u2208W(c)q ,Pk 6\u2208Sq from the IC-signatures, held by Pi as part of [a] and [b]. In the absence of any core-set W (c) q , robust reconstruction of [c]q will fail, which further implies failure of shared circuit-evaluation of ckt, where the inputs for ckt are shared by different parties.\nWay Out. To deal with the above problem, we ensure that the core-sets are common for all the secret-shared values during the circuit-evaluation. Namely, there exist global core-sets GW1, . . . ,GW |Zs|, which constitute the core-sets for all the secret-shared values during the circuit-evaluation, where for each GWq, Zs satisfies the Q(1)(GWq,Zs) condition. Maintaining common core-sets is challenging, especially in an asynchronous network and \u03a0VSS alone is not sufficient to achieve this goal. Rather we use a different approach. We generate a \u201cbunch\u201d of linearly secret-shared random values with IC-signatures and common core-sets GW1, . . . ,GW |Zs| in advance through another protocol called \u03a0Rand (discussed in the next section). Later, if any party Pi needs to secret-share some x, then one of these random values is reconstructed only towards Pi, which uses it as a one-time pad (OTP) and makes public an OTP-encryption of x. The parties can then take the \u201cdefault\u201d secret-sharing of the OTP-encryption with IC-signatures and GW1, . . . ,GW |Zs| as the core-sets and then non-interactively \u201cremove\u201d the pad from the OTP-encryption. This results in [x], with GW1, . . . ,GW |Zs| as coresets. To ensure privacy, we need to generate L random values through \u03a0Rand, if L is the maximum number of values which need to be secret-shared by different parties during the circuit-evaluation. We show that L \u2264 n3 \u00b7cM+4n2 \u00b7cM+n2+n where cM is the number of multiplication gates in ckt."
        },
        {
            "heading": "1.2.5 Secret-Shared Random Values with Global Core Sets",
            "text": "Protocol \u03a0Rand generates linearly secret-shared random values with ICsignatures and common core-sets. We explain the idea behind the protocol for generating one random value. The \u201cstandard\u201d way will be to let each Pi pick a random value r(i) and generate [r(i)] by invoking an instance of \u03a0VSS. To avoid an endless wait, the parties only wait for the completion of \u03a0VSS instances invoked by a set of dealers P \\Z for some Z \u2208 Zs. To identify the common subset\nof dealers for which the corresponding \u03a0VSS instances have completed, the parties run an instance of agreement on a common subset (ACS) primitive [14,19]. This involves invoking n instances of our network agnostic BA, one on behalf of each dealer, to decide the \u03a0VSS instances of which dealers have completed. Let C be the set of common dealers identified through ACS, where P \\C \u2208 Zs. The set C has at least one non-faulty party who has shared a random value. Hence, the sum of the values shared by the dealers in C will be random for the adversary.\nTechnical Challenges. The above approach fails in our context due to the following two \u201cproblems\u201d in the protocol \u03a0VSS, when executed by different dealers.\nProblem I: The first challenge is to maintain the linearity of underlying ICsignatures. To understand the issue, consider a triplet of parties Pi, Pj , Pk, acting as S, I and R respectively in various instances of \u03a0VSS invoked by different dealers. Recall that, to maintain the linearity of IC-signatures, it is necessary that Pi selects the same set of supporting-verifiers SV in all the instances of authentication phase involving Pj and Pk. This is possible only if Pi knows all the values on which it wants to generate the IC-signature for Pj and Pk and starts invoking all the instances of authentication phase. Instead, if Pi invokes instances of authentication phase as and when it has some data to be authenticated for Pj and Pk, then it may not be possible to have the same SV in all the instances of authentication phase, involving Pi, Pj and Pk in the above roles, especially in an asynchronous network. Since, in \u03a0VSS, IC-signatures are generated on the supposedly common shares (after receiving them from the underlying dealer) and multiple instances of \u03a0VSS are invoked (by different dealers), this means that Pi should first have the data from all the dealers for the various instances of \u03a0VSS and before invoking instances of authentication phase to generate IC-signatures on these values for Pj . This may not be possible, since Pi need not know beforehand which dealers it will be receiving shares from as part of \u03a0VSS.\nWay Out. To deal with the above issue, we now let the dealers publicly commit their shares for the \u03a0VSS instances through secure verifiable multicast (SVM). The primitive allows a designated sender Sen \u2208 P with input v to \u201cverifiably\u201d send v to a designated set of receivers R \u2286 P , without leaking any additional information. The verifiability guarantees that even if Sen is corrupt, if the nonfaulty parties in R get any value from Sen, then it will be common and all the (non-faulty) parties in P will \u201cknow\u201d that Sen has sent some value to R. Our instantiation of SVM is very simple: Sen acts as a dealer and generates [v] through \u03a0VSS. Once [v] is generated, the parties know that Sen has \u201ccommitted\u201d to some unknown value. The next step is to let only the parties in R reconstruct v.\nUsing SVM, we now let the various dealers distribute the shares during the underlying instances of \u03a0VSS (for \u03a0Rand) as follows. Consider the dealer P\u2113 who has invoked an instance of \u03a0VSS with input r (\u2113). For this, it picks random shares r (\u2113) 1 , . . . , r (\u2113) |Zs| which sum up to r(\u2113). Now instead of directly sending send r (\u2113) q to the parties in Sq, it invokes |Zs| instances of SVM with input r (\u2113) 1 , . . . , r (\u2113) |Zs| and S1, . . . , S|Zs| as the designated set of receivers respectively. This serves two\npurposes. First, it guarantees that all the parties in Sq receive a common share from P\u2113. Second and more importantly, all the parties in P will now know that P\u2113 has distributed shares to each set from SZs . The parties then run an instance of ACS to identify a common subset of committed dealers CD \u2286 P , where P \\CD \u2208 Zs, which have invoked the desired instances of SVM and delivered the required shares to each group Sq \u2208 S|Zs|. The way timeouts are maintained as part of the ACS, it will be ensured that in a synchronous network, all non-faulty dealers are present in CD. Once the set CD is identified, it is guaranteed that every nonfaulty party Pi will have the shares from all the dealers in CD. And once it has the shares from all the dealers in CD, it starts generating the IC-signatures on these shares for the designated parties as part of the \u03a0VSS instances corresponding to the dealers in CD and ensures that all the pre-requisites are satisfied to guarantee the linearity of the underlying IC-signatures. Now instead of selecting the set of dealers C (for \u03a0Rand) from P , the parties run an instance of ACS over the set of committed dealers CD to select C where CD \\ C \u2208 Zs holds. We stress that irrespective of the network type, the set C is still guaranteed to have at least one non-faulty party. While this is trivially true in an asynchronous network where Za satisfies the Q(1)(C,Za) condition, the same is true in the synchronous network because CD will have all non-faulty dealers.\nProblem II: The second problem (in the proposed\u03a0Rand) is that the underlying core-sets might be different for the values shared by the dealers in CD (and hence C). Instead, we require every dealer in CD to secret-share random values with common underlying core-sets. Only then will it be ensured that the random values generated through \u03a0Rand are secret-shared with common core-sets.\nWay Out. Getting rid of the above problem is not possible if we let every dealer in CD compute individual core-sets during their respective instances of \u03a0VSS, as per the steps of \u03a0VSS. Recall that in \u03a0VSS, the dealer D computes the underlying core-sets with respect to the \u201cfirst\u201d set of parties Sp from S|Zs| which confirm the pairwise consistency of their supposedly common share after exchanging ICsignatures on these values. As a result, different dealers (in \u03a0Rand) may end up computing different core-sets in their instances of \u03a0VSS with respect to different candidate Sp sets. To deal with this issue, we instead let each dealer in CD continue computing and publishing different \u201clegitimate\u201d core-sets with respect to various \u201celigible\u201d candidate Sp sets from SZs . The parties run an instance of ACS to identify a common subset of dealers C \u2208 CD where CD\\C \u2208 Zs, such that all the dealers have computed and published \u201cvalid\u201d core-sets, computed with the respect to the same Sp \u2208 SZs . The idea here is that there always exists a set S \u2208 SZs consisting of only non-faulty parties. So if the set of non-faulty dealers H in CD keep computing and publishing all possible candidate core-sets in their \u03a0VSS instances, then they will publish core-sets with respect to S. Hence, H and S always constitute the candidate CD and the common Sp set.\nNote that identifying C out of CD through ACS satisfying the above requirements is non-trivial and requires carefully executing the underlying instances of BA in \u201ctwo-dimensions\u201d. We first run |Zs| instances of \u03a0BA, one on the behalf of\neach set in SZs , where the q th instance is executed to decide whether a subset of dealers in CD\\Z for some Z \u2208 Zs have published valid core-sets with respect to the set Sq \u2208 SZs . This enables the parties to identify a common set Sqcore \u2208 SZs , such that it is guaranteed that a subset of dealers in CD \\ Z for some Z \u2208 Zs have indeed published valid core-sets with respect to the set Sqcore . Once the set Sqcore is identified, the parties then run |CD| instances of BA to decide which dealers in CD have published core-sets with respect to Sqcore ."
        },
        {
            "heading": "1.2.6 Network Agnostic Secure Multiplication",
            "text": "To generate secret-shared random multiplication-triples for evaluating the multiplication gates in ckt (using Beaver\u2019s trick), we need a network agnostic secure multiplication protocol which securely generates a secret-sharing of the product of two secret-shared values. The key subprotocol behind our multiplication protocol is a non-robust multiplication protocol \u03a0BasicMult (standing for basic multiplication), which takes inputs [a] and [b] and an existing set of globally discarded parties GD, which contains only corrupt parties. The protocol securely generates [c] without revealing any additional information about a, b (and c). If no party in P \\ GD cheats, then c = a \u00b7 b holds. The idea behind the protocol is to let each summand [a]p \u00b7 [b]q be secret-shared by a summand-sharing party. Then [a \u00b7 b] can be computed from the secret-sharing of each summand, owing to the linearity property. Existing multiplication protocols in the synchronous and asynchronous setting [40,5] also use an instantiation of \u03a0BasicMult, based on the above idea. In the sequel, we recall them, followed by the technical challenges faced in the network agnostic setting and how we deal with them.\n\u03a0BasicMult in the Synchronous Setting with Q (2)(P ,Zs) Condition [40]. In [40], each summand [a]p \u00b7 [b]q is statically assigned to a designated summandsharing party through some deterministic assignment, which is possible since [a]p and [b]q are held by the parties in (Sp \u2229 Sq). This is non-empty, since the Q(2)(P ,Zs) condition holds. Since the parties in GD are already known to be corrupted, all the shares [a]p, [b]p held by the parties in GD are publicly reconstructed and instead of letting the parties in GD secret-share their assigned summands, the parties take the \u201cdefault\u201d secret-sharing of these summands.\n\u03a0BasicMult in the Asynchronous Setting with Q (3)(P ,Za) Condition [5]. The idea of statically designating each summand [a]p \u00b7 [b]q to a unique party in P \\ GD need not work in the asynchronous setting, since the designated party may be corrupt and need not secret-share any summand, thus resulting in an endless wait. To deal with this challenge, [5] dynamically selects the summandsharing parties for each summand. In more detail, let Za = {Z1, . . . ,Z|Za|} and SZa = {S1, . . . , S|Za|}, where each Sr = P \\ Zr. Since the Q (3)(P ,Za) condition is satisfied and GD \u2208 Za, it follows that (Sp \u2229 Sq) \\ GD 6= \u2205. This implies that there exists at least one non-faulty party in (Sp \u2229 Sq) who can secret-share the summand [a]p \u00b7 [b]q. Hence, every party in P \\ GD is allowed to secret-share all the summands it is \u201ccapable\u201d of, with special care taken to ensure that\neach summand [a]p \u00b7 [b]q is considered exactly once. For this, the protocol now proceeds in \u201chops\u201d, where in each hop all the parties in P \\ GD secret-share all the summands they are capable of, but a single summand sharing party is finally selected for the hop through ACS. Then, all the summands which have been shared by the elected summand-sharing party are \u201cmarked\u201d as shared and not considered for sharing in the future hops. Moreover, a party who has already served as a summand-sharing party is not selected in the future hops.\nTechnical Challenges in the Network Agnostic Setting. The asynchronous \u03a0BasicMult based on dynamically selecting summand-sharing parties will fail in the synchronous network, since the Q(3) condition need not be satisfied. On the other hand, synchronous \u03a0BasicMult based on statically selecting summandsharing parties will fail if a designated summand-sharing party does not secretshare the required summands, resulting in an endless wait. The way out is to select summand-sharing parties in three phases. We first select summand-sharing parties dynamically in hops, following the approach of [5], till we find a subset of parties from SZs which have shared all the summands they are capable of. Then in the second phase, the remaining summands which are not yet secretshared are statically assigned and shared by the respective designated summandsharing parties. To avoid an endless wait in this phase, the parties wait only for a \u201cfixed\u201d time required for the parties to secret-share the assigned summands (corresponding to the time taken in a synchronous network) and run instances of BA to identify which of the designated summand-sharing parties have shared their summands up during the second phase. During the third phase, any \u201cleftover\u201d summand which is not yet shared is publicly reconstructed by reconstructing the corresponding shares and a default sharing is taken for such summands.\nThe idea here is the following: all non-faulty parties will share the summands which are assigned to them, either statically or dynamically, irrespective of the network type. Consequently, the first phase will be always over, since the set consisting of only non-faulty parties always constitutes a candidate set of summand-sharing parties which the parties look for to complete of the first phase. Once the first phase is over, the second phase is bound to be over since the parties wait only for a fixed time. The third phase is always bound to be over, once the first two phases are over, since it involves publicly reconstructing the leftover summands. The way summands are assigned across the three phases, it will be always guaranteed that every summand is considered for sharing once in exactly one of the three phases and no summand will be left out. The crucial point here is that the the shares held only by the non-faulty parties never get publicly reconstructed, thus guaranteeing that the adversary does not learn any additional information about a and b. This is obviously true in a synchronous network because we always have the second phase where every non-faulty party who is not selected as a summand-sharing party during the first phase will get the opportunity to secret-share its assigned summands. On the other hand, in an asynchronous network, it can be shown that all the summands which involve any share held by the non-faulty parties would have been secret-shared during the first phase itself. In more detail, let Z\u22c6 \u2208 Za be the set of corrupt parties and\nlet H = P \\Z\u22c6 be the set of honest parties. Moreover, let Sh \u2208 SZs be the group consisting of only non-faulty parties which hold the shares [a]h and [b]h. Consider an arbitrary summand [a]h \u00b7 [b]q. Suppose the first phase gets over because every party in S\u2113 \u2208 SZs has been selected as a summand-sharing party during the first phase. Then consider the set (S\u2113 \u2229H \u2229 Sq), which is not empty due to the Q(2,1)(P ,Zs,Za) condition. Hence, there exists some Pj \u2208 (H \u2229 S\u2113 \u2229 Sq), who would have shared [a]h \u00b7 [b]q when selected as a summand-sharing party during some hop in the first phase. Due to a similar reason, any summand of the form [a]q \u00b7 [b]h would have been secret-shared during the first phase itself."
        },
        {
            "heading": "1.3 Other Related Works",
            "text": "The domain of network agnostic cryptographic protocols is relatively new and almost all the existing works have considered threshold adversaries. The work of [16] presents a network agnostic cryptographically-secure atomic broadcast protocol. The work of [45] studies Byzantine fault tolerance and state machine replication protocols for multiple thresholds, including ts and ta. The work of [35] presents a network agnostic protocol for the task of approximate agreement using the condition 2ts + ta < n. The same condition has been used to design a network agnostic distributed key-generation (DKG) protocol in [6]. A recent work [28] has studied the problem of network agnostic perfectly-secure message transmission (PSMT) [29] over incomplete graphs."
        },
        {
            "heading": "1.4 Open Problems",
            "text": "There are several interesting directions to explore for network agnostic MPC protocols. Here we mention few of them. It is not known whether the condition 3ts + ta < n (resp. Q\n(3,1)(P ,Zs,Za)) is necessary for the network agnostic MPC with perfect security against threshold (resp. non-threshold) adversary. An abundant amount of research effort has been spent to improve both the theoretical as well as practical efficiency of (unconditionally-secure) SMPC and AMPC protocols. The works of [3,4] and this work just focus on the possibility of unconditionally-secure network agnostic MPC. Upgrading the efficiency of these protocols to those of state of the art SMPC and AMPC protocols seems to require a significant research effort. Even though the complexity of our MPC protocol is polynomial in n and |Zs|, when instantiated for threshold adversaries (where |Zs| has all subsets of P of size up to ts), it may require an exponential (in n) amount of computation and communication. This is unlike the case for perfect security, where we have a network agnostic MPC protocol against threshold adversaries with a complexity polynomial (in n) [3]. Hence, designing network agnostic MPC protocol against threshold adversaries with statistical security and polynomial complexity is left as a challenging open problem."
        },
        {
            "heading": "2 Preliminaries and Definitions",
            "text": "We assume the pair-wise secure channel model, where the parties in P are assumed to be connected by pair-wise secure channels. The underlying communication network can be either synchronous or asynchronous, with parties being unaware about the exact network type. In a synchronous network, every message sent is delivered within a known time \u2206. In an asynchronous network, messages can be delayed arbitrarily, but finitely, with every message sent being delivered eventually. The distrust among P is modelled by a malicious (Byzantine) adversary Adv, who can corrupt a subset of the parties in P and force them to behave in any arbitrary fashion during the execution of a protocol. The parties not under the control of Adv are called honest. We assume the adversary to be static, who decides the set of corrupt parties at the beginning of the protocol execution. As our main goal is to show the possibility of statistically-secure network agnostic MPC, we keep the formalities to a bare minimum and prove the security of our protocols using the property-based definition, by listing the security properties achieved by our protocols. However, our protocols can also be proven to be secure using the more rigorous Universal Composability (UC) definitional framework [20], without affecting their efficiency.\nAdversary Adv can corrupt any one subset of parties from Zs and Za in synchronous and asynchronous network respectively. The adversary structures are monotone, implying that if Z \u2208 Zs (Z \u2208 Za resp.), then every subset of Z also belongs to Zs (resp. Za). We assume that Zs and Za satisfy the conditions Q(2)(P ,Zs) and Q(3)(P ,Za) respectively, which are necessary for statistically-secure MPC in the synchronous and asynchronous network respectively. Additionally, we assume that Za \u2282 Zs. Moreover, Zs and Za satisfy the Q(2,1)(P ,Zs,Za) condition.\nIn our protocols, all computations are done over a finite field F, where |F| > n5 \u00b7 2ssec and ssec is the underlying statistical security parameter. Looking ahead, this will ensure that the error probability in our MPC protocol is upper bounded by 2\u2212ssec. Without loss of generality, we assume that each Pi has an input xi \u2208 F, and the parties want to securely compute a function f : F\nn \u2192 F, represented by an arithmetic circuit ckt over F, consisting of linear and non-linear (multiplication) gates, where ckt has cM multiplication gates and a multiplicative depth of DM .\nWe assume the existence of an unconditionally-secure public-key infrastructure (PKI), for an unconditionally-secure signature scheme, also called pseudosignature [50,34]. We briefly explain the requirements from such a setup and refer to [34] for complete formal details. There exists a publicly known vector of public keys (pk1, . . . , pkn), where each honest Pi holds the generated secret key ski, associated with pki.\n7 A valid signature \u03c4 on message m from Pi is one for which Verifypki(m, \u03c4) = 1, where Verify is the verification function of the underlying signature scheme. For simplicity, we make the standard convention of treating signatures as idealized objects during our protocol analysis; i.e., we assume that\n7 Corrupt parties may choose their keys arbitrarily.\nthe signatures are perfectly unforgeable and hence Adv will fail to forge signature of an honest party on any message, which is not signed by the party. We also assume that the signatures are transferable and any party upon receiving a valid signature from a party can send and get it verified by any other party. However, unlike the standard digital signatures which are computationally-secure and offer arbitrary number of transfers, pseudo-signatures offer a \u201climited\u201d number of transfers, which is typically bounded as a function of the number of parties in the protocol where pseudo-signature is used as a primitive. We assume that the given setup supports the required number of transfers demanded by our protocols. We use |\u03c3| to represent the size of a pseudo-signature in bits. If Pi signs a message m, then we denote the resultant signed message as \u3008m\u3009i.\nTermination Guarantees of Our Sub-Protocols: As done in [3,5], for simplicity, we will not be specifying any termination criteria for our sub-protocols. The parties will keep on participating in these sub-protocol instances even after computing their outputs. The termination criteria of our MPC protocol will ensure the termination of all underlying sub-protocol instances. We will be using an existing randomized ABA protocol [23] which ensures that the honest parties (eventually) obtain their respective output almost-surely with probability 1. This means that the probability that an honest party obtains its output after participating for infinitely many rounds approaches 1 asymptotically [1,47,7]. That is:\nlim T\u2192\u221e Pr[An honest Pi obtains its output by local time T ] = 1,\nwhere the probability is over the random coins of the honest parties and the adversary in the protocol. The property of almost-surely obtaining the output carries over to the \u201chigher\u201d level protocols, where ABA is used as a building block. We will say that the \u201chonest parties obtain some output almost-surely from protocol \u03a0\u201d to mean that every honest Pi asymptotically obtains its output in \u03a0 with probability 1, in the above sense."
        },
        {
            "heading": "3 Network Agnostic Unconditionally Secure Byzantine Agreement",
            "text": "We recall the definition of BA from [4], which is adapted from [15,3].\nDefinition 3.1 (BA). Let \u03a0 be a protocol for P, where every party Pi has an input bi \u2208 {0, 1} and a possible output from {0, 1,\u22a5}. Moreover, let Adv be a computationally-unbounded adversary, characterized by adversary structure Z, where Adv can corrupt any subset of parties from Z during the execution of \u03a0. \u2013 Z-Guaranteed Liveness: \u03a0 has Z-guaranteed liveness if all honest parties\nobtain an output. \u2013 Z-Almost-Surely Liveness: \u03a0 has Z-almost-surely liveness if, almost-\nsurely, all honest parties obtain some output. \u2013 Z-Validity: \u03a0 has Z-validity if the following holds: If all honest parties have\ninput b, then every honest party with an output, outputs b.\n\u2013 Z-Weak Validity: \u03a0 has Z-weak validity if the following holds: If all honest parties have input b, then every honest party with an output, outputs b or \u22a5.\n\u2013 Z-Consistency: \u03a0 has Z-consistency if all honest parties with an output, output the same value (which can be \u22a5).\n\u2013 Z-Weak Consistency: \u03a0 has Z-weak consistency if all honest parties with an output, output either a common v \u2208 {0, 1} or \u22a5.\n\u03a0 is called a Z-secure synchronous BA (SBA) if, in a synchronous network, it achieves Z-guaranteed liveness, Z-validity, and Z-consistency. \u03a0 is called a Z-secure asynchronous BA (ABA) if, in an asynchronous network it has Zalmost-surely liveness, Z-validity and Z-consistency.8\nTo design our network agnostic BA protocol, we will be using a special type of broadcast protocol. We next review the definition of broadcast from [4] which is further adapted from [15,3].\nDefinition 3.2 (Broadcast). Let \u03a0 be a protocol, where a designated sender Sen \u2208 P has input m \u2208 {0, 1}\u2113, and parties obtain a possible output, including \u22a5. Moreover, let Adv be a computationally-unbounded adversary, characterized by an adversary structure Z, where Adv can corrupt any subset from Z during \u03a0. \u2013 Z-Liveness: \u03a0 has Z-liveness if all honest parties obtain some output. \u2013 Z-Validity: \u03a0 has Z-validity if the following holds: if Sen is honest, then\nevery honest party with an output, outputs m. \u2013 Z-Weak Validity: \u03a0 has Z-weak validity if the following holds: if Sen is\nhonest, then every honest party with an output, outputs either m or \u22a5. \u2013 Z-Consistency: \u03a0 has Z-consistency if the following holds: if Sen is cor-\nrupt, then every honest party with an output, outputs a common value. \u2013 Z-Weak Consistency: \u03a0 has Z-weak consistency if the following holds: if\nSen is corrupt, then every honest party with an output, outputs a common m\u22c6 \u2208 {0, 1}\u2113 or \u22a5.\n\u03a0 is called a Z-secure broadcast protocol if it has Z-Liveness, Z-Validity, and Z-Consistency.\nWe next recall a blueprint for network agnostic BA from [15,3]."
        },
        {
            "heading": "3.1 A Blueprint for Network Agnostic BA [15,3]",
            "text": "To design our network agnostic BA, we assume the existence of the following sub-protocols. \u2013 Synchronous BA with Asynchronous Guarantees: we assume the existence of\na protocol \u03a0SBA, which is a Zs-secure SBA and which has Za-weak validity and Za-guaranteed liveness in the asynchronous network. At (local) time\n8 The seminal FLP impossibility result [32] rules out the possibility of any deterministic ABA, where there always exists a \u201cbad\u201d execution in which the honest parties may keep on running the protocol forever, without obtaining any output. To circumvent this, one can opt for randomized ABA protocols and hope that the bad executions occur asmptotically with probability 0.\nTSBA, all honest parties will have an output (which could be \u22a5), irrespective of the network type.\n\u2013 Asynchronous BA with Synchronous Guarantees: we assume the existence of a protocol \u03a0ABA, which is a Za-secure ABA. Moreover, in a synchronous network, the protocol has Zs-validity, with all honest parties computing their output within time TABA = c \u00b7\u2206 in this case, for some known constant c.9 Based on \u03a0SBA and \u03a0ABA, one can design a network agnostic BA protocol \u03a0BA as follows, following the blueprint of [15,3]. The parties first invoke an instance of \u03a0SBA, assuming a synchronous network. If the network is indeed synchronous, then the (honest) parties should have a binary output at time TSBA. The parties check the same and either switch their input to the output of \u03a0SBA, if it is not \u22a5, or stick to their original input. The parties then invoke an instance of \u03a0ABA with \u201cupdated\u201d inputs and the output of \u03a0ABA is set to be the overall output. The description of \u03a0BA, taken from [3], is presented in Fig 1.\nTheorem 3.1, follows from [3], given that \u03a0SBA and \u03a0ABA achieve the stated properties. For completeness, the theorem is proved in Appendix A.\nTheorem 3.1. Let Za \u2282 Zs such that Zs and Za satisfy the conditions Q(2)(P ,Zs) and Q(3)(P ,Za) respectively. Moreover, let Zs and Za satisfy the Q(2,1)(P ,Zs,Za) condition. Then protocol \u03a0BA achieves the following.10\n\u2013 Synchronous Network: the protocol is a Zs-secure SBA, where all honest parties get their output at time TBA = TSBA + TABA. \u2013 Asynchronous Network: the protocol is a Za-secure ABA.\nWe now proceed to instantiate protocols \u03a0SBA and \u03a0ABA."
        },
        {
            "heading": "3.2 \u03a0SBA: Synchronous BA with Asynchronous Weak Validity and Guaranteed Liveness",
            "text": "To design protocol \u03a0SBA, we again follow the blueprint of [3], which design \u03a0SBA based on three components.\n9 Thus \u03a0ABA has Zs-guaranteed liveness in the synchronous network, if all honest parties have the same input. However, if the honest parties have different inputs, then \u03a0ABA need not provide guaranteed liveness or consistency guarantees in the synchronous network. 10 As the number of invocations of \u03a0BA in our MPC protocol will be independent of |ckt|, we do not focus on its exact complexity. However, we confirm that it will be polynomial in n and |Zs|."
        },
        {
            "heading": "3.2.1 SBA with Asynchronous Guaranteed Liveness",
            "text": "The first component for designing \u03a0SBA is an SBA protocol, which has just guaranteed liveness in an asynchronous network. In [50], the authors have presented an SBA protocol against threshold adversaries, tolerating up to ts < n/2 faults. The protocol which we denote as \u03a0PW, modifies the Dolev-Strong BA protocol [30], by replacing digital signatures with pseudo-signatures. We note that \u03a0PW can be easily generalized, if Zs satisfies the Q\n(2)(P ,Zs) condition. To achieve guaranteed liveness in an asynchronous network, the parties run the protocol till the supposed timeout in the synchronous network and check if any output is computed and in case no output is computed, \u22a5 is taken as the output. Since the protocol is an easy generalization of the existing protocol against threshold adversaries, protocol \u03a0PW and proof of Lemma 3.1 are available in Appendix A.\nLemma 3.1. Protocol \u03a0PW achieves the following, where t is the cardinality of the maximum-sized subset in Zs. \u2013 Synchronous Network: The protocol is a Zs-secure SBA protocol, where\nall honest parties compute their output at time TPW def = (t+ 1) \u00b7\u2206.\n\u2013 Asynchronous Network: The protocol achieves Za-guaranteed liveness, where all honest parties compute their output at time TPW. \u2013 Communication Complexity: O(n4 \u00b7 \u2113 \u00b7 |\u03c3|) bits are sent by the honest parties, if the inputs of the parties are of size \u2113 bits."
        },
        {
            "heading": "3.2.2 Asynchronous Broadcast with Synchronous Guarantees",
            "text": "The second component for designing \u03a0SBA is an asynchronous broadcast protocol \u03a0Acast (also called Acast), which provides liveness, validity and a \u201cvariant\u201d of consistency in a synchronous network. The variant guarantees that if Sen is corrupt and the honest parties compute an output in a synchronous network, then they may not do it at the same time and there might be a gap in the time at which the honest parties compute an output. In [43,4], an instantiation of \u03a0Acast is provided against Q\n(3) adversary structures.11 Unfortunately, the protocol fails to provide any security guarantees in a synchronous network against Q(2) adversary structures. So we provide a different instantiation of Acast for our setting (see Fig 2). The protocol is obtained by generalizing the ideas used in the broadcast protocol of [46]. The protocol of [46] uses a computational PKI, which we replace with an unconditional PKI. The protocol consists of three phases and each (honest) party executes a phase at most once.\nEach Pi \u2208 P executes each of the following phases at most once. \u2022 (Propose): If Pi = Sen, then on having the input m, send \u3008(propose, m)\u3009Sen to\nall the parties.\nProtocol \u03a0Acast(Sen, m,Zs,Za)\n11 The protocol is a generalization of the classic Bracha\u2019s threshold Acast protocol [18], tolerating t < n/3 corruptions.\nThe proof of Lemma 3.2 is available in Appendix A.\nLemma 3.2. Protocol \u03a0Acast achieves the following properties. \u2013 Asynchronous Network: The protocol is a Za-secure broadcast protocol. \u2013 Synchronous Network: (a) Zs-Liveness: If Sen is honest, then all honest\nparties obtain an output within time 3\u2206. (b) Zs-Validity: If Sen is honest, then every honest party with an output, outputs m. (c) Zs-Consistency: If Sen is corrupt and some honest party outputs m\u22c6 at time T , then every honest Pi outputs m\n\u22c6 by the end of time T +\u2206. \u2013 Communication Complexity: O(n3 \u00b7\u2113\u00b7|\u03c3|) bits are communicated by the honest\nparties, where \u2113 is the size of Sen\u2019s input.\nTerminologies for Using \u03a0Acast. In the protocol \u03a0Acast, any party from P can be designated as Sen. In the rest of the paper we will say that \u201cPi Acasts m\u201d to mean that Pi acts as Sen and invokes an instance of \u03a0Acast with input m, and the parties participate in this instance. Similarly, \u201cPj receives m from the Acast of Pi\u201d means that Pj outputs m in the corresponding instance of \u03a0Acast."
        },
        {
            "heading": "3.2.3 Synchronous Broadcast with Asynchronous Guarantees",
            "text": "The third component for designing \u03a0SBA is a broadcast protocol \u03a0BC, which is secure in a synchronous network and which also provides liveness, weak validity and weak consistency in an asynchronous network. Note that the guarantees of \u03a0BC are different from that of\u03a0Acast. The design of\u03a0BC is based on the idea from [4], by carefully combining protocols \u03a0Acast and \u03a0PW. In the protocol, Sen first Acasts its message. If the network is synchronous, then at time 3\u2206, all honest parties should have an output. To confirm this, the parties start participating in an instance of \u03a0PW, with whatever output has been obtained from the \u03a0Acast instance at time 3\u2206; in case no output is obtained, then the input is \u22a5. Finally, at time 3\u2206 + TPW, the parties output an m\n\u22c6, if it is the output of the \u03a0Acast instance as well as the output of \u03a0PW, else the output of the parties will be \u22a5. We recall the description of \u03a0BC from [4] and present it in Fig 3.\nProtocol \u03a0BC as a Network Agnostic Secure Broadcast. Protocol \u03a0BC only guarantees weak validity and weak consistency in an asynchronous network, since only a subset of honest parties may receive Sen\u2019s message from the Acast\nof Sen within time 3\u2206+TPW. Note that maintaining the time-out is essential, as we need liveness from \u03a0BC (irrespective of the network type) when used later in protocol \u03a0SBA. Looking ahead, we will use \u03a0BC in our VSS protocol for broadcasting values. The weak validity and consistency may lead to a situation where, in an asynchronous network, one subset of honest parties may output a value different from \u22a5 at the end of the time-out 3\u2206+ TPW, while others may output \u22a5. For the security of the VSS protocol, we would require the latter category of parties to eventually output the common non-\u22a5 value if the parties continue participating in \u03a0BC. Following [3,4], we make a provision for this in \u03a0BC. Namely, each Pi who outputs \u22a5 at time 3\u2206 + TPW \u201cswitches\u201d its output to m\u22c6, if Pi eventually receives m\u22c6 from Sen\u2019s Acast. We stress that this switching is only for the parties who obtained \u22a5 at time 3\u2206+ TPW. To differentiate between the two ways of obtaining output, we use the terms regular-mode and fallback-mode. Regular-mode is the process of deciding the output at time 3\u2206 + TPW, while fallback-mode is the process of deciding the output beyond time 3\u2206+ TPW.\nTheorem 3.2 follows from [4] and is proved in Appendix A.\nTheorem 3.2. Protocol \u03a0BC achieves the following, with a communication complexity of O(n4 \u00b7 \u2113 \u00b7 |\u03c3|) bits, where TBC = 3\u2206+ TPW.\n\u2013 Synchronous network: (a) Zs-Liveness: At time TBC, each honest party has an output. (b) Zs-Validity: If Sen is honest, then at time TBC, each honest party outputs m. (c) Zs-Consistency: If Sen is corrupt, then the output of every honest party is the same at time TBC. (d) Zs-Fallback Consistency: If Sen is corrupt, and some honest party outputs m\u22c6 6= \u22a5 at time T through fallback-mode, then every honest party outputs m\u22c6 by time T +\u2206.\n\u2013 Asynchronous Network: (a) Za-Liveness: At time TBC, each honest party has an output. (b) Za-Weak Validity: If Sen is honest, then at time TBC, each honest party outputs m or \u22a5. (c) Za-Fallback Validity: If Sen is honest, then each honest party with output \u22a5 at time TBC, eventually outputs m through fallback-mode. (d) Za-Weak Consistency: If Sen is corrupt, then there exists an m\u22c6 6= \u22a5, such that at time TBC, each honest party outputs m\u22c6 or \u22a5. (e) Za-Fallback Consistency: If Sen is corrupt, and\nsome honest party outputs m\u22c6 6= \u22a5 at time T \u2265 TBC, then each honest party eventually outputs m\u22c6.\nIn the rest of the paper, we use the following terminologies while using \u03a0BC.\nTerminologies for \u03a0BC: We say that Pi broadcasts m to mean that Pi invokes an instance of \u03a0BC as Sen with input m, and the parties participate in this instance. Similarly, we say that Pj receives m from the broadcast of Pi through regular-mode (resp. fallback-mode), to mean that Pj has the output m at time TBC (resp. after time TBC) during the instance of \u03a0BC."
        },
        {
            "heading": "3.2.4 \u03a0BC \u2192 \u03a0SBA",
            "text": "Finally, using \u03a0BC we instantiate protocol\u03a0SBA, following the blueprint of [4]. In the protocol, every party broadcasts its input bit (for \u03a0SBA) through an instance of \u03a0BC. At time TBC, the parties check if \u201csufficiently many\u201d instances of \u03a0BC have produced a binary output (which should have happened in a synchronous network) and if so, they output the \u201cmajority\u201d of those values. Otherwise, the network is asynchronous, in which case the parties output \u22a5. The description of \u03a0SBA is recalled from [4] and presented in Fig 4.\nTheorem 3.3 follows from [4] and is proved in Appendix A.\nTheorem 3.3. Protocol \u03a0SBA achieves the following where TSBA = TBC, incurring a communication of O(n5 \u00b7 |\u03c3|) bits. \u2013 Synchronous Network: the protocol is a Zs-secure SBA protocol where honest\nparties have an output, different from \u22a5, at time TSBA. \u2013 Asynchronous Network: the protocol achieves Za-guaranteed liveness and Za-\nweak validity, such that all honest parties have an output at (local) time TSBA."
        },
        {
            "heading": "3.3 \u03a0ABA: Asynchronous BA with Synchronous Validity",
            "text": "To the best of our knowledge, the only known unconditionally-secure ABA protocol is due to [23], which generalizes the framework of randomized ABA\n[51,11,21,31] against general adversaries. The protocol of [23] uses a graded agreement (GA) protocol (also known as the vote protocol), along with a secure coin-flip protocol. Unfortunately, both these primitives provide security (in an asynchronous network) against Q(3) adversary structures and fail to provide any security guarantees against Q(2) adversary structures in a synchronous network. Consequently, the ABA protocol of [23] fails to provide any security guarantees in a synchronous network againstQ(2) adversary structures.12 We give a different instantiation of \u03a0ABA by generalizing a few ideas used in [15]. Our instantiation of \u03a0ABA is based on following two components.\nComponent I: Asynchronous Graded Agreement with Synchronous Validity. We assume the existence of a GA protocol \u03a0GA, where each party has a binary input. The output for each party is a value from {0, 1,\u22a5}, along with a grade from {0, 1, 2}. The protocol achieves the following properties. \u2013 Asynchronous Network \u2014 The following properties are achieved, even if the\nadversary corrupts any subset from Za: (a): Za-Liveness: If all honest parties participate in the protocol, then each honest party eventually obtains an output. (b) Za-Graded Validity: If every honest party\u2019s input is b, then all honest parties with an output, output (b, 2). (c) Za-Graded Consistency: If two honest parties output grades g, g\u2032, then |g \u2212 g\u2032| \u2264 1 holds; moreover, if two honest parties output (v, g) and (v\u2032, g\u2032) with g, g\u2032 \u2265 1, then v = v\u2032.\n\u2013 Synchronous Network \u2014 The following properties are achieved, even if the adversary corrupts any subset from Zs: (a): Zs-Liveness: If all honest parties participate in the protocol with the same input, then after some fixed time TGA, all honest parties obtain an output. (b) Zs-Graded Validity: If every honest party\u2019s input is b, then all honest parties with an output, output (b, 2).\nNote that we do not require any form of consistency from\u03a0GA in the synchronous network. We give an instantiation of \u03a0GA with the Q\n(2,1)(P ,Zs,Za) condition, by generalizing the threshold GA protocol of [15] with condition 2ts + ta < n, such that TGA = 4 \u00b7 \u2206. The protocol of [15] uses digital signatures (hence, is computationally secure), which we replace with pseudo-signatures. For the description of \u03a0GA and its properties, see Appendix A.\nComponent II: Asynchronous Coin-Flipping with Synchronous Liveness. We assume the existence of a p-coin-flipping protocol \u03a0CoinFlip, where 0 < p < 1 is a parameter. In the protocol, the parties participate with random inputs and the output of each party is a bit satisfying the following properties. \u2013 Asynchronous Network: The following properties are achieved even if the ad-\nversary corrupts any subset from Za: (a): Za-Almost-Surely Liveness: If all honest parties participate in the protocol, then almost-surely, all honest parties eventually get an output. (b): (Za, p)-Commonness: With probability p, the output of all honest parties is a random bit b \u2208 {0, 1}.\n12 Recall that we need validity, coupled with guaranteed liveness from \u03a0ABA, when used in our network agnostic BA protocol \u03a0BA.\n\u2013 Synchronous Network: The following property is achieved even if the adversary corrupts any subset from Zs: (a): Zs-Guaranteed Liveness: If all honest parties participate in the protocol, then all honest parties get an output, after some fixed time TCoinFlip. In [23], the authors presented an instantiation of \u03a0CoinFlip, which achieves ZaAlmost-Surely Liveness as well as (Za, p)-Commonness in an asynchronous network, where p = 1\nn , provided Za satisfies the Q(3)(P ,Za) condition. The protocol\nincurs an expected communication of O(poly(n, |Zs|, log |F|)) bits. Interestingly, the protocol also achieves Zs-Guaranteed Liveness in a synchronous network, irrespective of Zs. Namely, after time TCoinFlip = 20 \u00b7\u2206, all honest parties will have an output, with (honest) parties communicating O(poly(n, |Zs|, log |F|)) bits.\n3.3.1 \u03a0GA + \u03a0CoinFlip \u2192 \u03a0ABA\nOnce we have instantiations of \u03a0GA and \u03a0CoinFlip, we can easily combine it using the framework of [51,11,21,31] to get the protocol \u03a0ABA. The protocol consists of several iterations, where in each iteration, the parties run two instances of \u03a0GA, along with an instance of \u03a0CoinFlip. Using the first instance of \u03a0GA, the parties check if they all have the same input. Independent of this finding, they then run an instance of \u03a0CoinFlip. Finally, they again run an instance of \u03a0GA, with inputs being carefully chosen. Namely, if a party obtained an output with the highest grade from the first instance of \u03a0GA, then it participates with this input, else it participates with the coin-output. Finally, based on the output received from the second instance of \u03a0GA, the parties update their input for the next iteration as follows: if a bit with a non-zero grade is obtained, then it is set as the updated input, else the updated input is set to the input of the second instance of \u03a0GA. During each iteration, the parties keep a tab on whether they have received an output bit with the highest grade from the second instance of \u03a0GA, in which case, they indicate it to the others by sending a signed ready message and the bit. Once \u201csufficiently many\u201d parties send the same signed ready bit, it is taken as the output of the protocol.\nThe idea here is that if the honest parties start an iteration with the same input bit b, then the output of \u03a0CoinFlip is not considered (irrespective of the network type) and all instances of \u03a0GA output (b, 2). Thus, all honest parties will send a signed ready message for b. Consequently, all honest parties will output b. This ensures validity, coupled with guaranteed liveness, both in synchronous and asynchronous networks. On the other hand, if the honest parties start an iteration with different inputs, then with probability at least p \u00b7 12 = 1 n \u00b7 12 , all of them will have the same input for the second instance of\u03a0GA. And consequently, all honest parties will have the same input from the next iteration onward and consistency is achieved (in the asynchronous network). The description of \u03a0ABA based on \u03a0GA and \u03a0CoinFlip is recalled from [23] and presented in Fig 5.\nTheorem 3.4 follows from [15] and is proved in Appendix A.\nTheorem 3.4. Protocol \u03a0ABA achieves the following where TABA = TCoinFlip + 2TGA +\u2206. \u2013 Synchronous Network: If all honest parties have the same input b \u2208\n{0, 1}, then all honest parties output b, at time TABA. Moreover, O(poly(n, |Zs|, log |F|)) bits are communicated by the honest parties. \u2013 Asynchronous Network: the protocol is a Za-secure ABA, incurring an expected communication of O(poly(n, |Zs|, log |F|)) bits."
        },
        {
            "heading": "4 Network Agnostic Information Checking Protocol",
            "text": "In this section, we present our network agnostic ICP protocol (Fig 6). A detailed overview of the protocol has been already presented in Section 1.2.2. The protocol consists of two subprotocols \u03a0Auth and \u03a0Reveal, implementing the authentication and revelation phase respectively, where the parties participate in the revelation phase only upon completing the authentication phase. During the authentication phase, S distributes the authentication and verification information, followed by parties publicly verifying the consistency of distributed information and once the consistency is established, the authentication phase is over. During the revelation phase, I reveals the IC-signature which is verified by R with respect to the verification information revealed by a \u201cselected\u201d subset of the verifiers.\nThe proof of Theorem 4.1 is available in Appendix B.\nTheorem 4.1. Protocols (\u03a0Auth, \u03a0Reveal) satisfy the following properties, except with probability at most \u01ebICP def = nt|F|\u22121 , where t = max{|Z| : Z \u2208 Zs}.\n\u2013 If S, I and R are honest, then the following hold. \u2013 Zs-Correctness: In a synchronous network, each honest party sets\nauthCompleted(S,I,R) to 1 during \u03a0Auth at time TAuth = \u2206+ 4TBC. Moreover R outputs s during \u03a0Reveal which takes TReveal = \u2206 time. \u2013 Za-Correctness: In an asynchronous network, each honest party eventually sets authCompleted(S,I,R) to 1 during \u03a0Auth and R eventually outputs s during \u03a0Reveal.\n\u2013 Privacy: The view of Adv is independent of s, irrespective of the network. \u2013 Unforgeability: If S,R are honest, I is corrupt and if R outputs s\u2032 \u2208 F\nduring \u03a0Reveal, then s \u2032 = s holds, irrespective of the network type.\n\u2013 If S is corrupt, I,R are honest and if I sets ICSig(S, I,R, s) = F (x) during \u03a0Auth, then the following holds. \u2013 Zs-Non-Repudiation: In a synchronous network, R outputs s = F (0)\nduring during \u03a0Reveal, which takes TReveal = \u2206 time. \u2013 Za-Non-Repudiation: In an asynchronous network, R eventually out-\nputs s = F (0) during during \u03a0Reveal. \u2013 Communication Complexity: Irrespective of the network type, \u03a0Auth in-\ncurs a communication of O(n5 \u00b7 log |F| \u00b7 |\u03c3|) bits, while \u03a0Reveal incurs a communication of O(n \u00b7 log |F|) bits.\nLooking ahead, in our VSS protocols, there will be several instances of ICP running, with different parties playing the role of S, I and R. It will be convenient to use the following notations while invoking instances of ICP.\nNotation 4.2 (for ICP) While using (\u03a0Auth, \u03a0Reveal), we will say that: \u2013 \u201cPi gives ICSig(Pi, Pj , Pk, s) to Pj\u201d to mean that Pi acts as S and invokes\nan instance of \u03a0Auth with input s, where Pj and Pk play the role of I and R respectively.\n\u2013 \u201cPj receives ICSig(Pi, Pj , Pk, s) from Pi\u201d to mean that Pj , as I, has set authCompleted(Pi,Pj ,Pk) to 1 and ICSig(Pi, Pj , Pk, s) to some t-degree polynomial with s as the constant term during the instance of \u03a0Auth, where Pi and Pk play the role of S and R respectively. \u2013 \u201cPj reveals ICSig(Pi, Pj , Pk, s) to Pk\u201d to mean Pj, as I, invokes an instance of \u03a0Reveal, with Pi and Pk playing the role of S and R respectively. \u2013 \u201cPk accepts ICSig(Pi, Pj , Pk, s)\u201d to mean that Pk, as R, outputs s during the instance of \u03a0Reveal, invoked by Pj as I, with Pi playing the role of S."
        },
        {
            "heading": "4.1 Linearity of IC Signature",
            "text": "Our ICP satisfies the linearity property, provided \u201cspecial care\u201d is taken while generating the IC-signatures. In more detail, consider a fixed S, I and R and let sa and sb be two values, such that I has received ICSig(S, I,R, sa) and ICSig(S, I,R, sb) from S, through instances \u03a0 (a) Auth and \u03a0 (b) Auth of \u03a0Auth respectively, where all the following conditions are satisfied.\n\u2013 Supporting verifiers SVa and SVb, during \u03a0 (a) Auth and \u03a0 (b) Auth, are the same. \u2013 For i = 1, . . . , n, corresponding to the verifier Pi, S has used the same \u03b1i \u2208\nF \\ {0}, to compute the verification points, during \u03a0 (a) Auth and \u03a0 (b) Auth\n\u2013 I has used the same linear combiner d \u2208 F \\ {0} during the instances \u03a0 (a) Auth\nand \u03a0 (b) Auth, to compute the linearly-combined masked polynomials.\nLet s def = c1 \u00b7 sa + c2 \u00b7 sb, where c1, c2 are publicly known constants from F. It then follows that if all the above conditions are satisfied, then I can locally compute ICSig(S, I,R, s) from ICSig(S, I,R, sa) and ICSig(S, I,R, sb). Namely, I can set ICSig(S, I,R, s) = c1 \u00b7 ICSig(S, I,R, sa) + c2 \u00b7 ICSig(S, I,R, sb). On the other hand, let the verifier Pi \u2208 SVa hold the verification points (\u03b1i, va,i,ma,i) and (\u03b1i, vb,i,mb,i), corresponding to ICSig(S, I,R, sa) and ICSig(S, I,R, sb) respectively. Then Pi can locally compute (\u03b1i, vi,mi) as its verification point corresponding to ICSig(S, I,R, s), where vi = c1\u00b7va,i+c2\u00b7vb,i andmi = c1\u00b7ma,i+c2\u00b7mb,i. During the protocol \u03a0Reveal, to reveal ICSig(S, I,R, s), the intermediary I can reveal ICSig(S, I,R, s) to R, while each verifier Pi \u2208 SVa can reveal the verification information (\u03b1i, vi,mi). To accept (\u03b1i, vi,mi), the receiver R either checks for the \u201cconsistency\u201d of (\u03b1i, vi) with ICSig(S, I,R, s), or the \u201cinconsistency\u201d of masked polynomial B(x) def = c1 \u00b7Ba(x)+c2 \u00b7Bb(x) with (d, vi,mi); here Ba(x) and Bb(x) denote the masked polynomials, made public by I, during the instances \u03a0 (a) Auth and \u03a0 (b) Auth respectively, both computed with respect to the linear combiner d.\nLooking ahead, we will require the linearity property from ICP, when used in our VSS protocols, where there will be multiple instances of \u03a0Auth running, involving the same (S, I,R) triplet. To achieve this, we will ensure that in all the \u03a0Auth instances invoked during VSS involving the same triplet (S, I,R), the signer uses the same non-zero evaluation point \u03b1S,I,R,i for the verifier Pi, while distributing verification information to Pi, as part of the respective \u03a0Auth instances. Similarly, S should find and make public a common set of supporting verifiers SV , on behalf of all the instances of \u03a0Auth. And finally, I should use the same non-zero random linear combiner d, to compute the masked polynomials for all the instances of \u03a0Auth and once computed, it should together make public d and the masked polynomials for all the instances of \u03a0Auth.\nIn the rest of the paper, we will use the term \u201cparties follow linearity principle while generating IC-signatures\u201d, to mean that the underlying instances of \u03a0Auth are invoked as above."
        },
        {
            "heading": "4.2 Default IC Signature",
            "text": "In our VSS protocols, we will also encounter situations where some publicly known value s and a triplet (S, I,R) exist. Then I can locally compute ICSig(S, I,R, s) by setting ICSig(S, I,R, s) to the constant polynomial F (x) = s. Each verifier Pi \u2208 P locally sets (\u03b1S,I,R,i, vi,mi) as its verification information, where vi = mi = s. Moreover, the set of supporting verifiers SV is set as P . Notice that the way in which ICSig(S, I,R, s) and the verification information is\nset guarantees that, later, if an honest I reveals ICSig(S, I,R, s) to an honest R during \u03a0Reveal, then R always outputs s.\nIn the rest of the paper, we will use the term \u201cparties set ICSig(S, I,R, s) to the default value\u201d, to mean the above."
        },
        {
            "heading": "5 Network Agnostic Verifiable Secret Sharing (VSS)",
            "text": "This section presents our network-agnostic VSS protocol, which allows a designated dealer to generate a linear secret-sharing with IC-signatures for its input. We first define the notion of linear secret-sharing with IC-signatures.\nDefinition 5.1 (Linear Secret Sharing with IC-Signatures). A value s \u2208 F is said to be linearly secret-shared with IC-signatures, if there exist shares s1, . . . , s|Zs| \u2208 F where s = s1 + . . . + s|Zs|. Moreover, for q = 1, . . . , |Zs|, there exists some publicly-known core-set Wq \u2286 Sq, such that all the following hold. \u2013 Zs satisfies the Q(1)(Wq,Zs) condition and all (honest) parties in the set Sq\nhave the share sq. \u2013 Every honest Pi \u2208 Wq has the IC-signature ICSig(Pj , Pi, Pk, sq) of every\nPj \u2208 Wq for every Pk 6\u2208 Sq. Moreover, if any corrupt Pj \u2208 Wq has ICSig(Pj , Pi, Pk, s \u2032 q) of any honest Pi \u2208 Wq for any Pk 6\u2208 Sq, then s \u2032 q = sq holds. Furthermore, all the underlying IC-signatures satisfy the linearity property.\nThe vector of information corresponding to a linear secret-sharing with ICsignature of s is denoted by [s], which includes the share s1, . . . , s|Zs|, the core sets W1, . . . ,W|Zs| and IC-signatures {ICSig(Pj , Pi, Pk, sq)}Pj ,Pi\u2208Wq,Pk 6\u2208Sq . For convenience, we denote the qth share of s, corresponding to Sq, by [s]q.\nA vector of values ~S = (s(1), . . . , s(L)) where L \u2265 1 is said to be linearly secret-shared with IC-signatures, if each s(\u2113) \u2208 ~S is linearly secret-shared with IC-signatures and if there exist common core sets W1, . . . ,W|Zs|, corresponding to the secret-sharings [s(1)], . . . , [s(\u2113)].\nIf ~S = (s(1), . . . , s(L)) are linearly secret-shared with IC-signatures, then the parties can locally compute any publicly-known function of these secret-shared values. In more detail, let c1, . . . , cL \u2208 F be publicly-known constants and let s def = c1 \u00b7 s(1) + . . .+ cL \u00b7 s(L). Then the following holds:\nc1 \u00b7 [s (1)] + . . .+ cL \u00b7 [s (L)] = [s],\nwhere the core-sets corresponding to [s] are W1, . . . ,W|Zs|. And corresponding to each Sq \u2208 SZs , the share [s]q for each (honest) party in Sq can be computed locally as c1 \u00b7 [s(1)]q + . . . + c\u2113 \u00b7 [s(\u2113)]q. Moreover, every (honest) Pi \u2208 Wq can compute the IC-signature ICSig(Pj , Pi, Pk, [s]q) of every Pj \u2208 Wq for every Pk 6\u2208 Sq, from ICSig(Pj , Pi, Pk, [s (1)]q), . . . , ICSig(Pj , Pi, Pk, [s (\u2113)]q). In the rest of the paper, we will say that the \u201cparties in P locally compute [c1 \u00b7 s(1)+ . . .+ c\u2113 \u00b7 s(\u2113)] from [s(1)], . . . , [s(\u2113)]\u201d to mean the above."
        },
        {
            "heading": "5.1 The VSS Protocol",
            "text": "We present a network-agnostic VSS protocol \u03a0VSS (Fig 7). In the protocol, there exists a designated dealer D \u2208 P with input s (the protocol can be easily generalized if D has L inputs). The protocol allows D to \u201cverifiably\u201d generate a linear secret-sharing of s with IC-signatures. In a synchronous network, the (honest) parties output [s] after a \u201cfixed\u201d time, while in an asynchronous network, they do so eventually, such that s remains private. The verifiability here guarantees that if D is corrupt and some honest party gets an output, then there exists some value, say s\u22c6 (which could be different from s), such that s\u22c6 is linearly secret-shared with IC-signatures. Note that in this case, we cannot bound the time within which s\u22c6 will be secret-shared, since a potentially corrupt D may delay sending the required messages and the parties will not be knowing the exact network type. A detailed overview of the protocol has been already presented in Section 1.2.3 and so we directly present the protocol.\n\u2013 Distribution of Shares: D, on having input s, randomly chooses s1, . . . , s|Zs| \u2208 F, such that s = s1+\u00b7 \u00b7 \u00b7+s|Zs|. It then sends sq to all Pi \u2208 Sq, for q = 1, . . . , |Zs|. \u2013 Exchanging IC-Signed Values: Each Pi \u2208 P (including D), waits till the local time becomes \u2206. Then, for each Sq \u2208 SZs such that Pi \u2208 Sq, upon receiving sqi from D, give ICSig(Pi, Pj , Pk, sqi) to every Pj \u2208 Sq , for every Pk \u2208 P , such that the parties follow the linearity principle while generating IC-signatures (see Section 4.1).\n\u2013 Announcing Results of Pairwise Consistency Tests: Each Pi \u2208 P (including D) waits till the local time becomes \u2206+ TAuth and then does the following. \u2013 Upon receiving ICSig(Pj , Pi, Pk, sqj) from Pj for each Sq \u2208 S such that Pj , Pi \u2208\nSq , corresponding to every Pk \u2208 P , broadcast OK(i, j), if sqi = sqj holds. \u2013 Corresponding to every Pj \u2208 P , participate in any instance of \u03a0BC initiated\nby Pj as a sender, to broadcast any OK(Pj , \u22c6) message. \u2013 Constructing Consistency Graph: Each Pi \u2208 P (including D) waits till the\nlocal time becomes \u2206+TAuth+TBC and then constructs an undirected consistency graph G(i) with P as the vertex set, where the edge (Pj , Pk) is added to G\n(i), provided OK(j, k) and OK(k, j) is received from the broadcast of Pj and Pk respectively (through any mode).\n\u2013 Identification of Core Sets and Public Announcement by the Dealer: D waits till its local time is \u2206 + TAuth + TBC, and then executes the following steps to compute core sets. \u2013 Once any Sp \u2208 SZs forms a clique in the graph G\n(D), then for q = 1, . . . , |Zs|, compute core-set Wq and broadcast-set BS with respect to Sp as follows, followed by broadcasting (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS). a \u2013 If Sq constitutes a clique in the graph G (D), then set Wq = Sq. \u2013 Else if (Sp\u2229Sq) constitutes a clique in G (D) and Zs satisfies the Q\n(1)(Sp\u2229 Sq ,Zs) condition, then set Wq = (Sp \u2229 Sq). \u2013 Else set Wq = Sq and include q to BS . \u2013 Identifying Valid Core Sets: Each Pi \u2208 P waits till its local time is \u2206 +\nTAuth + 2TBC and then initializes a set Ci = \u2205. For p = 1, . . . , |Zs|, party Pi includes (D, Sp) to Ci (initialized to \u2205), provided all the following hold.\nProtocol \u03a0VSS(D,Zs,Za, s, SZs)\nThe properties of \u03a0VSS as stated in Theorem 5.1 are proved in Appendix C.\nTheorem 5.1. Protocol \u03a0VSS achieves the following, except with a probability of O(|SZs | \u00b7 n\n2 \u00b7 \u01ebICP), where D has input s \u2208 F for \u03a0VSS and where TVSS = \u2206+ TAuth + 2TBC + TReveal.\n\u2013 If D is honest, then the following hold. \u2013 Zs-correctness: In a synchronous network, the honest parties output [s]\nat time TVSS. \u2013 Za-correctness: In an asynchronous network, the honest parties eventu-\nally output [s]. \u2013 Privacy: Adversary\u2019s view remains independent of s in any network.\n\u2013 If D is corrupt, then the following hold. \u2013 Zs-commitment: In a synchronous network, either no honest party com-\nputes any output or there exists some s\u22c6 \u2208 F, such that the honest parties output [s\u22c6]. Moreover, if any honest party computes its output at time T , then all honest parties compute their required output by time T +\u2206.\n\u2013 Za-commitment: In an asynchronous network, either no honest party computes any output or there exists some s\u22c6 \u2208 F, such that the honest parties eventually output [s\u22c6]. \u2013 Communication Complexity: O(|Zs| \u00b7 n8 \u00b7 log |F| \u00b7 |\u03c3|) bits are communicated by the honest parties."
        },
        {
            "heading": "6 Network Agnostic Reconstruction Protocols and",
            "text": "Secure Verifiable Multicast\nLet s be a value which is linearly secret-shared with IC-signatures and let Sq \u2208 SZs . Moreover, let R \u2286 P be a designated set. Then protocol\u03a0RecShare([s], Sq,R) allows all the (honest) parties in R to reconstruct the share [s]q without disclosing any additional information. For this, every Pi \u2208 Wq reveals [s]q to all the parties outside Wq, who are in R (the parties in Wq who are in R already have [s]q). To ensure that Pi does not cheat, Pi actually reveals the IC-signature of every party in Wq on the revealed [s]q. The idea here is that since Wq has at least one honest party (irrespective of the network type), a potentially corrupt Pi will fail to reveal the signature of an honest party from Wq on an incorrect [s]q. On the other hand, an honest Pi will be able to reveal the signature of all the parties in Wq on [s]q.\nBased on \u03a0RecShare, we design another protocol \u03a0Rec([s],R), which allows all the (honest) parties in R to reconstruct s. The idea is to run an instance of \u03a0RecShare for every Sq \u2208 SZs . Since the protocols are standard, we present them and prove there properties (Lemma 6.1 and Lemma 6.2) in Appendix D.\nLemma 6.1. Let s be a value which is linearly secret-shared with IC signatures, let Sq \u2208 SZs be a designated set and let R \u2286 P be a designated set of receivers. Then protocol \u03a0RecShare achieves the following. \u2013 Zs-correctness: In a synchronous network, all honest parties in R output\n[s]q after time TRecShare = TReveal, except with a probability of O(n2 \u00b7 \u01ebICP). \u2013 Za-correctness: In an asynchronous network, all honest parties in R even-\ntually output [s]q, except with a probability of O(n2 \u00b7 \u01ebICP). \u2013 Privacy: If R consists of only honest parties, then the view of the adversary\nremains independent of [s]q. \u2013 Communication Complexity: O(|R| \u00b7 n3 \u00b7 log |F|) bits are communicated.\nLemma 6.2. Let s be a value which is linearly secret-shared with IC signatures and let R \u2286 P be a set of designated receivers. Then protocol \u03a0Rec achieves the following. \u2013 Zs-correctness: In a synchronous network, all honest parties in R output s\nafter time TRec = TRecShare, except with probability O(|SZs | \u00b7 n 2 \u00b7 \u01ebICP).\n\u2013 Za-correctness: In an asynchronous network, all honest parties in R eventually output s, except with probability O(|SZs | \u00b7 n\n2 \u00b7 \u01ebICP). \u2013 Privacy: If R consists of only honest parties, then the view of the adversary\nremains independent of s. \u2013 Communication Complexity: O(|Zs| \u00b7 |R| \u00b7 n3 \u00b7 log |F|) bits are communi-\ncated.\n6.1 \u03a0VSS and Reconstruction Protocol for Superpolynomial |Zs|\nFrom Theorem 5.1 and Lemma 6.2, the error probability of \u03a0VSS and \u03a0Rec depend linearly on |SZs |, which is the same as |Zs|. This is because there are \u2126(|Zs|) instances of \u03a0Auth/\u03a0Reveal in which the unforgeability/non-repudiation properties might get violated with probability \u01ebICP. This might be problematic for a \u201clarge-sized\u201d Zs. To avoid this, we use the idea of local dispute control used in [40,4], which ensures that irrespective of the number of instances of\u03a0Auth/\u03a0Reveal, the overall error probability is only O(n3 \u00b7\u01ebICP). This is done by ensuring that the unforgeability/non-repudiation properties get violated onlyO(n3) times across all these instances. The idea here is that the parties start locally discarding corrupt parties the \u201cmoment\u201d they are caught cheating during any instance of \u03a0Auth or \u03a0Reveal. Once a party Pj is locally discarded by any party Pi, then Pi \u201cbehaves\u201d as if Pj has certainly behaved maliciously in all the \u201cfuture\u201d instances of \u03a0Auth or \u03a0Reveal, even if this is not the case. This restricts the number of attempts of cheating for the adversary to a \u201cfixed\u201d number and consequently, the total error probability of arbitrary many instances of \u03a0Auth/\u03a0Reveal will no longer depend on |Zs|. To incorporate the above idea, each party Pi now maintains a list of locally discarded parties LD(i), which it keeps populating across all the instances of \u03a0Auth and \u03a0Reveal, as soon as Pi identifies any party cheating. It will be ensured that an honest Pi never includes an honest Pj to LD\n(i). We next discuss the modifications in \u03a0Auth and \u03a0Reveal and how the parties populate their LD sets across instances of \u03a0Auth and \u03a0Reveal.\nPopulating LD Sets During Instances of \u03a0Auth. In any instance of \u03a0Auth, if Pi is present in the corresponding set of supporting verifiers SV (i.e. Pi \u2208 SV), then Pi includes the corresponding signer Pj of the \u03a0Auth instance to LD (i) if the following condition holds during \u03a0Auth:\n(Pj broadcasts OK) \u2227 (B(\u03b1i) 6= dvi +mi),\nwhere B(x) is the masked polynomial broadcasted by the corresponding I of the \u03a0Auth instance. The idea here is that if Pi is honest and if the above condition holds, then clearly the signer Pj is corrupt and is trying to break the non-repudiation property. Once Pj \u2208 LD (i), then in any pair of (\u03a0Auth, \u03a0Reveal) instances involving Pj as the signer, if Pi is present in the corresponding set SV , then in the \u03a0Reveal instance, Pi reveals \u22a5 as its verification information to the corresponding receiver R.13 Upon receiving \u22a5 as the verification information, the strategy for R is to always accepts it without doing any verification, irrespective of the polynomial F (x) revealed as ICSig by the corresponding I.\nThe above modification ensures that if in any instance of \u03a0Auth involving a corrupt signer Pj and an honest I, Pj distributes an inconsistent verification point to an honest verifier Pi from the corresponding SV set and still broadcasts an OK message during \u03a0Auth, then Pj will locally be discarded by the verifier Pi, except with probability \u01ebICP (follows from the non-repudiation property of ICP). From\n13 This serves as an indicator for R that Pi is in conflict with the signer Pj .\nthen onwards, in all the instances of (\u03a0Auth, \u03a0Reveal), involving Pj as the signer, if the verifier Pi is added to the SV set, then the \u201cspecial\u201d verification information revealed by Pi during \u03a0Reveal will always be considered as accepted, irrespective of what verification information it actually receives from Pj during\u03a0Auth. Hence, Pj will not have any chance of cheating the verifier Pi in any \u03a0Auth instance. By considering all possibilities for a corrupt S and an honest verifier Pi, along with an honest I, it follows that except with probability at most O(n3 \u00b7 \u01ebICP), the verification-points of all honest verifiers from corresponding SV , will be accepted by every honest R, during all the instances of \u03a0Reveal, in any instance of \u03a0VSS or \u03a0Rec. Consequently, except with probability at most O(n3 \u00b7 \u01ebICP), the signatures revealed by all honest I will be always accepted.\nWe stress that the above modification does not help a corrupt I to break the unforgeability property for an honest S and an honest R, with the help of potentially corrupt verifiers.\nPopulating LD Sets During Instances of \u03a0Reveal. Consider an instance of \u03a0Reveal involving Pi as R and Pj as I. If Pi finds that Pj has tried to forge signature on an incorrect value, then Pi adds Pj to LD (i). To achieve this goal, during\u03a0Reveal, Pi (as R) now additionally checks if there exists a subset of verifiers SV \u2032\u2032 \u2286 SV , where SV \\ SV \u2032\u2032 \u2208 Za, such that the verification-points of all the parties in SV \u2032\u2032 are rejected. If such a subset SV \u2032\u2032 exists, then clearly Pj (as I) has cheated and tried to break the unforgeability property, since SV \u2032\u2032 is bound to contain at least one honest verifier. If the verification point of an honest verifier is rejected, then clearly Pj is corrupt. Once Pj \u2208 LD\n(i), from then onwards, in any instance of \u03a0Reveal involving Pj as I and Pi as R, party Pi always rejects any IC-signature revealed by Pi.\nThe above modification ensures that if in any instance of \u03a0Reveal involving an honest signer, a corrupt intermediary Pj and an honest receiver Pi, Pj tries to reveal an incorrect signature during \u03a0Reveal, then except with probability \u01ebICP, the intermediary Pj will be locally discarded by the receiver Pi (follows from the unforgeability property of ICP). From then onwards, in all the instances of (\u03a0Auth, \u03a0Reveal), involving Pj as the intermediary and Pi as the receiver, the signature revealed by Pj during \u03a0Reveal will always be rejected, irrespective of what data is actually revealed by Pj . Hence, by considering all possibilities for a corrupt I, honest S and honest R, it follows that except with probability at most O(n3 \u00b7 \u01ebICP), no corrupt I will be able to forge an honest S\u2019s signature to any honest R, in any instance of \u03a0Reveal, during any instance of \u03a0VSS or \u03a0Rec."
        },
        {
            "heading": "6.2 Network Agnostic Secure Multicast",
            "text": "Based on protocols \u03a0VSS and \u03a0Rec, we design a secure verifiable multicast protocol \u03a0SVM. In the protocol, there exists a designed sender Sen \u2208 P with input v \u2208 F and a designated set of receivers R. The goal is to let every party in R receive v, without revealing any additional information to the adversary.14 While\n14 Note that the requirements here are different from broadcast since we need the privacy of v if Sen is honest and if R consists of only honest parties.\nin a synchronous network, the (honest) parties in R get v after a \u201cfixed\u201d time, in an asynchronous network, they do so eventually. Note that if Sen is corrupt, then the parties need not obtain any output, as Sen may not invoke the protocol. However, if any honest party in R computes an output v\u22c6 (which could be different from v), then all honest parties in R will also output v\u22c6. The \u201cverifiability\u201d here guarantees that in case the honest parties in R get any output, then all the (honest) parties in P will be \u201caware\u201d of this; namely there will be a Boolean variable flag(Sen,R), which all the honest parties will set to 1.\nThe idea behind \u03a0SVM is very simple. The parties participate in an instance of \u03a0VSS, where Sen plays the role of the dealer with input v. Once any (honest) party computes an output during \u03a0VSS (implying that Sen is committed to some value v\u22c6 which is the same as v for an honest Sen), then it turns flag(Sen,R) to 1. Once flag(Sen,R) is turned to 1, the parties invoke an instance of \u03a0Rec to let only the parties in R reconstruct the committed value. Protocol \u03a0SVM and proof of its properties (stated in Lemma 6.3), are available in Appendix D.\nLemma 6.3. Protocol \u03a0SVM achieves the following, where Sen participates with input v and where each honest party initializes flag(Sen,R) to 0.\n\u2013 Synchronous Network: If Sen is honest, then all honest parties set flag(Sen,R) to 1 at time TVSS and except with probability O(n3 \u00b7 \u01ebICP), all honest parties in R output v, after time TSVM = TVSS + TRec. Moreover, if R consists of only honest parties, then the view of Adv remains independent of v. If Sen is corrupt and some honest party sets flag(Sen,R) to 1, then there exists some v\u22c6 such that, except with probability O(n3 \u00b7 \u01ebICP), all honest par-\nties in R output v\u22c6. Moreover, if any honest party sets flag(Sen,R) to 1 at time T , then all honest parties in R output v\u22c6 by time T + 2\u2206.\n\u2013 Asynchronous Network: If Sen is honest, then all honest parties eventually set flag(Sen,R) to 1 and except with probability O(n3 \u00b7 \u01ebICP), all honest parties in R eventually output v. Moreover, if R consists of only honest parties, then the view of the adversary remains independent of v. If Sen is corrupt and some honest party sets flag(Sen,R) to 1, then there exists some v\u22c6 such that , except with probability O(n3 \u00b7 \u01ebICP), all honest parties in R eventually output v\u22c6. \u2013 Communication Complexity: O(|Zs| \u00b7 n8 \u00b7 log |F| \u00b7 |\u03c3|) bits are communicated."
        },
        {
            "heading": "7 Network Agnostic Protocol for Generating Linearly Secret-Shared Random Values with IC-Signatures",
            "text": "In this section, we present a network agnostic protocol \u03a0Rand, which allows the parties to jointly generate linear secret-sharing of random values with ICsignatures. To design the protocol \u03a0Rand, we first design a subprotocol \u03a0MDVSS."
        },
        {
            "heading": "7.1 Network Agnostic VSS for Multiple Dealers",
            "text": "Protocol\u03a0MDVSS (Fig 8) is a multi-dealer VSS. In the protocol, each party P\u2113 \u2208 P participates as a dealer with some input s(\u2113). Then, irrespective of the network type, the protocol outputs a common subset of dealers CORE \u2286 P , which is guaranteed to have at least one honest dealer. Moreover, corresponding to every dealer P\u2113 \u2208 CORE, there will be some value, say s\u22c6\n(\u2113), which will be the same as s(\u2113) for an honest P\u2113, such that the values {s\u22c6 (\u2113)}P\u2113\u2208CORE are linearly secretshared with IC-signatures. While in a synchronous network, {[s\u22c6(\u2113)]}P\u2113\u2208CORE is generated after a \u201cfixed\u201d time, in an asynchronous network, {[s\u22c6(\u2113)]}P\u2113\u2208CORE is generated eventually.\nThe high level overview of \u03a0MDVSS has been already discussed in detail in Section 1.2.5.15 The idea is to let every dealer P\u2113 to invoke an instance of \u03a0VSS to secret-share its input. However, we need to take special care to ensure that the inputs of all the dealers in CORE are secret-shared with common core-sets. For this, each individual dealer in its instance of \u03a0VSS computes and publishes as many \u201clegitimate\u201d core-sets as possible and the parties run instances of agreement on common subset (ACS) to identify whether \u201csufficiently many\u201d dealers have published the same legitimate core-sets in their respective instances of\u03a0VSS. Moreover, to ensure that all the underlying IC-signatures satisfy the linearity property, we first need to identify the dealers who distribute shares as part of their respective \u03a0VSS instances. For this, we let each dealer distribute shares in its instance of \u03a0VSS through instances of \u03a0SVM. This enables the parties to identify a set of committed dealers CD who have indeed distributed shares as part of their \u03a0VSS instances through instances of \u03a0SVM.\n\u2013 Committing Shares: Each Pi \u2208 P executes the following steps. \u2013 On having input s(i), randomly choose s\n(i) 1 , . . . , s (i) |Zs| , such that\ns(i) = s (i) 1 + \u00b7 \u00b7 \u00b7 + s (i) |Zs| . Act as Sen and invoke instances \u03a0SVM(Pi, s (i) 1 , S1), . . . ,\u03a0SVM(Pi, s (i) |Zs|\n, S|Zs|) of \u03a0SVM. \u2013 Corresponding to every dealer P\u2113 \u2208 P , participate in the instances of \u03a0SVM,\ninvoked by P\u2113 as a Sen and wait till the local time becomes TSVM. For q = 1, . . . , |Zs|, let flag (P\u2113,Sq) be the Boolean flag, corresponding to the instance \u03a0SVM(P\u2113, s (\u2113) q , Sq), invoked by P\u2113.\n\u2013 Identifying the Set of Committed Dealers Through ACS: Each Pi \u2208 P does the following. \u2013 For \u2113 = 1, . . . , n, participate in an instance \u03a0\n(\u2113) BA of \u03a0BA with input 1, provided\nPi has set flag (P\u2113,Sq) = 1, for q = 1, . . . , |Zs|.\n\u2013 Once there exists a subset of dealers CDi where P \\ CDi \u2208 Zs, such that\ncorresponding to every dealer P\u2113 \u2208 CDi, the instance \u03a0 (\u2113) BA has produced output 1, then participate with input 0 in all the BA instances \u03a0 (\u22c6) BA , for which no input is provided yet.\nProtocol \u03a0MDVSS(P ,Zs,Za, (s (1), . . . , s(n)), SZs)"
        },
        {
            "heading": "15 Actually, the overview was for the protocol \u03a0Rand, but the same idea is also used in",
            "text": "the protocol \u03a0MDVSS.\n\u2013 Once all the n instances of \u03a0 (\u22c6) BA have produced a binary output, set CD to be\nthe set of dealers P\u2113, such that \u03a0 (\u2113) BA has produced output 1.\n\u2013 Exchanging IC-Signed Values: Each Pi \u2208 P waits till the local time becomes TSVM + 2TBA. Then corresponding to each dealer P\u2113 \u2208 CD, does the following. \u2013 For each Sq \u2208 SZs such that Pi \u2208 Sq, upon computing an output s (\u2113) qi during\n\u03a0SVM(P\u2113, s (\u2113) q , Sq), give ICSig(Pi, Pj , Pk, s (\u2113) qi ) to every Pj \u2208 Sq, for every Pk \u2208 P , where the parties follow the linearity principle while generating IC-signatures.\n\u2013 Announcing Results of Pairwise Consistency Tests: Each Pi \u2208 P waits till the local time becomes TSVM + 2TBA + TAuth and then does the following, corresponding to each dealer P\u2113 \u2208 CD. \u2013 Upon receiving ICSig(Pj , Pi, Pk, s (\u2113) qj ) from Pj for each Sq \u2208 S such that\nPj , Pi \u2208 Sq , corresponding to every Pk \u2208 P , broadcast OK (\u2113)(i, j), if s (\u2113) qi = s (\u2113) qj holds. \u2013 Corresponding to every Pj \u2208 P , participate in any instance of \u03a0BC initiated by Pj as a sender, to broadcast any OK\n(\u2113)(Pj , \u22c6) message. \u2013 Constructing Consistency Graphs: Each Pi \u2208 P waits till the local time\nbecomes TSVM + 2TBA + TAuth + TBC and then does the following, corresponding to each dealer P\u2113 \u2208 CD. \u2013 Construct an undirected consistency graph G(\u2113,i) with P as the vertex\nset, where the edge (Pj , Pk) is added to G (\u2113,i), provided OK(\u2113)(j, k) and OK(\u2113)(k, j) is received from the broadcast of Pj and Pk respectively (through any mode).\n\u2013 Public Announcement of Core Sets by the Committed Dealers: Each dealer P\u2113 \u2208 CD waits till its local time is TSVM + 2TBA + TAuth + TBC, and then executes the following steps to compute core sets. \u2013 \u2200Sp \u2208 SZs , once Sp forms a clique in G (\u2113,\u2113), then for q = 1, . . . , |Zs|, compute\ncore-set W(\u2113)p,q and broadcast-set BS (\u2113) p with respect to Sp as follows, followed by broadcasting (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }\nq\u2208BS (\u2113) p\n).\n\u2013 If Sq constitutes a clique in the graph G (\u2113,\u2113), then set W(\u2113)p,q = Sq. \u2013 Else if (Sp\u2229Sq) constitutes a clique in G (\u2113,\u2113) and Zs satisfies the Q (1)(Sp\u2229\nSq ,Zs) condition, then set W (\u2113) p,q = (Sp \u2229 Sq).\n\u2013 Else set W(\u2113)p,q = Sq and include q to BS (\u2113) p .\n\u2013 Identifying Valid Core Sets: Each Pi \u2208 P waits for time TSVM + 2TBA + TAuth + 2TBC and then initializes a set Ci = \u2205. Corresponding to P\u2113 \u2208 CD and p = 1, . . . , |Zs|, party Pi includes (P\u2113, Sp) to Ci, provided all the following hold.\n\u2013 (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }\nq\u2208BS (\u2113) p\n) is received from the\nbroadcast of P\u2113, such that for q = 1, . . . , |Zs|, the following hold. \u2013 If q \u2208 BS(\u2113)p , then the set W (\u2113) p,q = Sq . \u2013 If (q 6\u2208 BS(\u2113)p ), then W (\u2113) p,q is either Sq or (Sp \u2229 Sq), such that:\n\u2013 If W(\u2113)p,q = Sq, then Sq constitutes a clique in G (\u2113,i). \u2013 Else if W(\u2113)p,q = (Sp \u2229 Sq), then (Sp \u2229 Sq) constitutes a clique in G (\u2113,i)\nand Zs satisfies the Q (1)(Sp \u2229 Sq ,Zs) condition.\n\u2013 Selecting the Common Committed Dealers and Core Sets through ACS: Each party Pi \u2208 P does the following.\nThe properties of \u03a0MDVSS, stated in Theorem 7.1 are proved in Appendix E.\nTheorem 7.1. Protocol \u03a0MDVSS achieves the following where each P\u2113 participates with input s(\u2113) and where TMDVSS = TSVM + TAuth + 2TBC + 6TBA.\n\u2013 Zs-Correctness&Commitment: If the network is synchronous, then except with probability O(n3 \u00b7 \u01ebICP), at time TMDVSS, all honest parties output a common set CORE \u2286 P such that at least one honest party will be present in CORE. Moreover, corresponding to every P\u2113 \u2208 CORE, there exists some s\u22c6(\u2113), where s\u22c6(\u2113) = s(\u2113) for an honest P\u2113, such that the values {s\u22c6\n(\u2113)}P\u2113\u2208CORE are linearly secret-shared with IC-signatures.\n\u2013 Za-Correctness&Commitment: If the network is asynchronous, then except with probability O(n3 \u00b7 \u01ebICP), almost-surely all honest parties output a common set CORE \u2286 P eventually such that at least one honest party will be present in CORE. Moreover, corresponding to every P\u2113 \u2208 CORE, there exists some s\u22c6(\u2113), where s\u22c6(\u2113) = s(\u2113) for an honest P\u2113, such that the values {s\u22c6(\u2113)}P\u2113\u2208CORE are eventually linearly secret-shared with IC-signatures. \u2013 Privacy: Irrespective of the network type, the view of the adversary remains independent of s(\u2113), corresponding to every honest P\u2113 \u2208 CORE. \u2013 Communication Complexity: O(|Zs|2 \u00b7 n9 \u00b7 log |F| \u00b7 |\u03c3|) bits are communicated by the honest parties. In addition, O(|Zs|+ n) instances of \u03a0BA are invoked.\nProtocol \u03a0MDVSS with L Values for Each Dealer. In protocol \u03a0MDVSS, each dealer P\u2113 \u2208 P participates with a single input. Consider a scenario where each P\u2113 participates with L inputs \u2212\u2212\u2192 S(\u2113) = (s(\u2113,1), . . . , s(\u2113,L)), where L \u2265 1. The goal is to identify a common subset of dealers CORE \u2286 P which is guaranteed to have at least one honest dealer, irrespective of the network type. Corresponding to every dealer P\u2113 \u2208 CORE, there exist L values, say \u2212\u2212\u2212\u2192 S\u22c6(\u2113) = (s\u22c6(\u2113,1), . . . , s\u22c6(\u2113,L)), which will be the same as \u2212\u2212\u2192 S(\u2113) for an honest P\u2113, where all the values in { \u2212\u2212\u2212\u2192 S\u22c6(\u2113)}P\u2113\u2208CORE are linearly secret-shared with IC-signatures. To achieve this, we run the protocol \u03a0MDVSS with the following modifications, so that the number of instances of \u03a0BA in the protocol still remains to be O(|Zs|+ n), which is independent of L.\nCorresponding to each s(\u2113) \u2208 \u2212\u2212\u2192 S(L), the dealer P\u2113 will pick |Zs| random shares (which sum up to s(\u2113)) and the shares corresponding to the group Sq \u2208 S|Zs| are communicated through an instance of \u03a0SVM; hence |Zs| \u00b7L instances are invoked by P\u2113 as a Sen. Then, while identifying the set of committed dealers CD, parties vote 1 for P\u2113 in the instance \u03a0 (\u2113) BA provided the underlying flag variable is set to 1 in all the |Zs| \u00b7 L instances of \u03a0SVM invoked by P\u2113. The rest of the steps for identifying CD remains the same. This way, by executing only O(n) instances of \u03a0BA, we identify the set CD.\nNext, the parties exchange IC-signatures on their supposedly common shares for each group, corresponding to all the L values shared by each dealer from CD. However, each Pi now broadcasts a single OK\n(\u2113)(i, j) message, corresponding to each Pj \u2208 Sq, provided Pi receives IC-signed common share from Pj on the behalf of all the L values, shared by P\u2113. This ensures that, for each P\u2113, every Pi constructs a single consistency graph. Next, each dealer P\u2113 computes and broadcasts the candidate core-sets and broadcast-sets, as and when they are ready. The parties identify the CORE set by runningO(|Zs|+n) instances of\u03a0BA.\nTo avoid repetition, we do not present the formal steps of the modified \u03a0MDVSS protocol. The protocol incurs a communication of O(|Zs|2 \u00b7 L \u00b7 n9 \u00b7 log |F| \u00b7 |\u03c3|) bits, apart from O(|Zs|+ n) instances of \u03a0BA."
        },
        {
            "heading": "7.2 Protocol for Generating Secret-Shared Random Values",
            "text": "Protocol\u03a0Rand (Fig 9) allows the parties to jointly generate linear secret-sharings of L values with IC-signatures, where L \u2265 1, which are random for the adversary. For this, the parties invoke an instance of the (modified) \u03a0MDVSS where each dealer P\u2113 \u2208 P participates with a random vector of L values. Let CORE be the set of common dealers identified during the instance of \u03a0MDVSS. Then for l = 1, . . . , L, the parties output the sum of lth value shared by all the dealers in CORE. Since there will be at least one honest dealer in CORE whose shared values will be random for the adversary, it follows that the resultant values also remain random for the adversary.\nIn the rest of the paper, we will refer to the core sets W1, . . . ,W|Zs| obtained during \u03a0Rand as global core-sets and denote them by GW1, . . . ,GW |Zs|. From now onwards, all the secret-shared values will be generated with respect to these global core-sets.\nTheorem 7.2 follows easily from the above discussion.\nTheorem 7.2. Protocol \u03a0Rand achieves the following where TRand = TMDVSS = TSVM + TAuth + 2TBC + 6TBA and L \u2265 1. \u2013 Zs-correctness: If the network is synchronous, then except with prob-\nability O(n3 \u00b7 \u01ebICP), at the time TRand, there exist values r(1), . . . , r(L), which are linearly secret-shared with IC-signatures, where the core-sets are GW1, . . . ,GW |Zs|. \u2013 Za-correctness: If the network is asynchronous, then except with probability O(n3 \u00b7 \u01ebICP), there exist values r(1), . . . , r(L), which are almost-surely linearly secret-shared with IC-signatures, where the core-sets are GW1, . . . ,GW |Zs|. \u2013 Privacy: Irrespective of the network type, the view of the adversary remains independent of r(1), . . . , r(L).\n\u2013 Communication Complexity: The protocol incurs a communication of O(|Zs|2 \u00b7 L \u00b7 n9 \u00b7 log |F| \u00b7 |\u03c3|) bits, apart from O(|Zs|+ n) instances of \u03a0BA."
        },
        {
            "heading": "8 Network Agnostic Protocol for Generating Random Multiplication Triples",
            "text": "In this section, we present our network-agnostic triple-generation protocol, which generates random and private multiplication-triples which are linearly secretshared with IC-signatures. The protocol is based on several sub-protocols which we present next. Throughout this section, we will assume the existence of global core-sets GW1, . . . ,GW |Zs|, where Zs satisfies the Q\n(1)(GWq,Zs) condition for q = 1, . . . , |Zs|. Looking ahead, these core-sets will be generated by first running the protocol \u03a0Rand, using an appropriate value of L, which will be determined across all the sub-protocols which we will be discussing next. All the secret-shared values in the various sub-protocols in the sequel will have GW1, . . . ,GW |Zs| as underlying core-sets."
        },
        {
            "heading": "8.1 Verifiably Generating Linear Secret Sharing of a Value with IC-signatures",
            "text": "In protocol \u03a0LSh (Fig 10), there exists a designated dealer D \u2208 P with private input s. In addition, there is a random value r \u2208 F, which is linearly secret-shared with IC-signatures, such that the underlying core-sets are GW1, . . . ,GW |Zs| (the value r will not be known to D at the beginning of the protocol). The protocol allows the parties to let D verifiably generate a linear secret-sharing of s with IC-signatures, such that the underlying core-sets are GW1, . . . ,GW |Zs|, where s remains private for an honest D. The verifiability guarantees that even if D is corrupt, if any (honest) party computes an output, then there exists some value, say s\u22c6, which is linearly secret-shared with IC-signatures, such that the underlying core-sets are GW1, . . . ,GW |Zs|.\nThe protocol idea is very simple and standard. We first let D reconstruct the value r, which is then used as a one-time pad (OTP) by D to make public an OTP-encryption of s. Then, using the linearity property of secret-sharing, the parties locally remove the OTP from the OTP-encryption.\nThe properties of the protocol \u03a0LSh stated in Lemma 8.1 are proved in Appendix F.\nLemma 8.1. Let r be a random value which is linearly secret-shared with ICsignatures with GW1, . . . ,GW |Zs| being the underlying core-sets. Then protocol \u03a0LSh achieves the following where D participates with the input s.\n\u2013 If D is honest, then the following hold, where TLSh = TRec + TBC. \u2013 Zs-Correctness: If the network is synchronous, then except with prob-\nability O(n3 \u00b7 \u01ebICP), the honest parties output [s] at the time TLSh, with GW1, . . . ,GW |Zs| being the underlying core-sets. \u2013 Za-Correctness: If the network is asynchronous, then except with probability O(n3 \u00b7 \u01ebICP), the honest parties eventually output [s], with GW1, . . . ,GW |Zs| being the underlying core-sets. \u2013 Privacy: Irrespective of the network type, the view of the adversary remains independent of s.\n\u2013 If D is corrupt then either no honest party computes any output or there exists some value, say s\u22c6, such that the following hold. \u2013 Zs-Commitment: If the network is synchronous, then except with prob-\nability O(n3 \u00b7 \u01ebICP), the honest parties output [s\u22c6], with GW1, . . . ,GW |Zs| being the underlying core-sets. Moreover, if any honest party computes its output at the time T , then all honest parties will have their respective output by the time T +\u2206.\n\u2013 Za-Commitment: If the network is asynchronous, then except with probability O(n3 \u00b7 \u01ebICP), the honest parties eventually output [s\u22c6], with GW1, . . . ,GW |Zs| being the underlying core-sets. \u2013 Communication Complexity: O(|Zs| \u00b7n3 \u00b7 log |F|+n4 \u00b7 log |F| \u00b7 |\u03c3|) bits are communicated by the honest parties.\nWe end this section with some notations which we use while invoking the protocol \u03a0LSh in the rest of the paper.\nNotation 8.1 (Notations for Using Protocol \u03a0LSh) Let Pi \u2208 P. In the rest of the paper we will say that \u201cPi invokes an instance of \u03a0LSh with input s\u201d to mean that Pi acts as D and invokes an instance \u03a0LSh(D, s,Zs,Za, SZs , [r],GW1, . . . ,GW |Zs|) of \u03a0LSh. Here, r will be the corresponding random \u201cpad\u201d for this instance of \u03a0LSh, which will already be linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. If there are multiple instances of \u03a0LSh invoked by D, then corresponding to each instance, there will be a random secret-shared pad available to the parties beforehand. The parties will be knowing which secret-shared pad is associated with which instance of \u03a0LSh. This will be ensured by upper-bounding the maximum number of \u03a0LSh instances Lmax invoked across all our protocols. The parties then generate Lmax number of linearly secret-shared random values with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets, by running the protocol \u03a0Rand beforehand with L = Lmax."
        },
        {
            "heading": "8.2 Non-Robust Multiplication Protocol",
            "text": "Protocol \u03a0BasicMult (Fig 11) takes input a and b, which are linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets and a publicly known subset GD \u2282 P , consisting of only corrupt parties. The parties output a linear secret-sharing of c with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. If all the parties in P \\GD behave honestly, then c = a \u00b7 b, else c = a \u00b7 b + \u03b4, where \u03b4 6= 0. Moreover, the adversary does not learn anything additional about a and b in the protocol. The protocol also takes input an iteration number iter and all the sets computed in the protocol are tagged with iter. Looking ahead, our robust triple-generation protocol will be executed iteratively, with each iteration invoking instances of \u03a0BasicMult.\nA detailed overview of the protocol \u03a0BasicMult has been already presented in Section 1.2.6. The idea is to let each summand [a]p \u00b7 [b]q be linearly secret-shared by exactly one summand-sharing party. A secret-sharing of a \u00b7b then follows from the secret-sharing of each summand [a]p \u00b7 [b]q owing to the linearity property of the secret-sharing. To deal with the network agnostic condition, the summandsharing parties are selected in two phases: first, we select them dynamically, without pre-assigning any summand to any designated party. Once there exists a subset of parties from SZs who have served the role of summand-sharing parties, we go to the second phase, where each remaining summand is designated to the left-over parties through some publicly known assignment. Strict timeouts are maintained to ensure that we don\u2019t stuck forever during the second phase. Finally, if there are still any remaining summands which are not yet secretshared, they are publicly reconstructed and the default sharing is taken on their behalf. Throughout, the parties in GD are not let to secret-share any summand, since they are already known to be corrupt and at the same time, it is ensured that the shares of the honest parties are never publicly reconstructed.\n\u2013 Initialization: The parties in P do the following. \u2022 Initialize the summand-index-set of indices of all summands:\nSISiter = {(p, q)}p,q=1,...,|SZs |.\n\u2022 Initialize the summand-index-set corresponding to each Pj \u2208 P \\ GD:\nSIS (j) iter = {(p, q)}Pj\u2208Sp\u2229Sq .\n\u2022 Initialize the summand-index-set corresponding to each Sq \u2208 SZs :\nSIS (Sq) iter = \u222aPj\u2208SqSIS (j) iter .\n\u2022 Initialize the set of summands-sharing parties:\nSelectediter = \u2205.\n\u2022 Initialize the hop number: hop = 1.\nProtocol \u03a0BasicMult(Zs,Za, SZs , [a], [b], GW1, . . . ,GW |Zs|,GD, iter)\nPhase I: Sharing Summands Through Dynamic Assignment\n\u2013 While there exists no Sq \u2208 SZs , where SIS (Sq)\niter = \u2205, the parties do the following: \u2022 Sharing Sum of Eligible Summands: Every Pi /\u2208 (Selectediter\u222aGD) invokes\nan instance \u03a0 (phI,hop,i) LSh of \u03a0LSh with input c (i) iter, where\nc (i) iter =\n\u2211\n(p,q)\u2208SIS (i) iter\n[a]p[b]q .\nCorresponding to every Pj /\u2208 (Selectediter \u222aGD), the parties in P participate in the instance \u03a0 (phI,hop,j) LSh , if invoked by Pj . \u2022 Selecting Summand-Sharing Party for the Hop Through ACS: The parties in P wait for time TLSh and then do the following. \u2013 For j = 1, . . . , n, participate in an instance \u03a0\n(phI,hop,j) BA of \u03a0BA correspond-\ning to Pj \u2208 P with input 1 if all the following hold: \u2013 Pj /\u2208 (Selectediter \u222a GD); \u2013 An output [c (j) iter ] is computed during the instance \u03a0 (phI,hop,j) LSh .\n\u2013 Upon computing an output 1 during the instance\u03a0 (phI,hop,j) BA corresponding\nto some Pj \u2208 P , participate with input 0 in the instances \u03a0 (phI,hop,k) BA corresponding to parties Pk /\u2208 (Selectediter\u222aGD), for which no input has been provided yet. \u2013 Upon computing outputs during the instances \u03a0 (phI,hop,i) BA corresponding to\neach Pi /\u2208 (Selectediter\u222aGD), let Pj be the least-indexed party, such that the output 1 is computed during the instance \u03a0 (phI,hop,j) BA . Then update the following. \u2013 Selectediter = Selectediter \u222a {Pj}. \u2013 SISiter = SISiter \\ SIS (j) iter . \u2013 \u2200Pk \u2208 P \\ {GD \u222a Selectediter}: SIS (k) iter = SIS (k) iter \\ SIS (j) iter. \u2013 For each Sq \u2208 SZs , SIS (Sq) iter = SIS (Sq) iter \\ SIS (j) iter. \u2013 Set hop = hop+ 1.\nPhase II: Sharing Remaining Summands Through Static Assignment \u2022 Re-assigning the Summand-Index-Set of Each Party: Corresponding to\neach Pj \u2208 P \\ Selectediter, the parties in P set SIS (j) iter as\nSIS (j) iter = SISiter \u2229 {(p, q)}Pj=min(Sp\u2229Sq),\nwhere min(Sp \u2229 Sq) denotes the minimum indexed party in (Sp \u2229 Sq). \u2022 Sharing Sum of Assigned Summands: Every party Pi /\u2208 (Selectediter \u222a GD)\ninvokes an instance \u03a0 (phII,i) LSh of \u03a0LSh with input c (i) iter, where\nc (i) iter =\n\u2211\n(p,q)\u2208SIS (i) iter\n[a]p[b]q .\nCorresponding to every Pj \u2208 P \\ (Selectediter \u222aGD), the parties in P participate in the instance \u03a0 (phII,j) LSh , if invoked by Pj . \u2022 Agreeing on the Summand-Sharing parties of the Second Phase: The parties in P wait for TLSh time after the beginning of the second phase. Then for\nThe properties of the protocol \u03a0BasicMult are claimed in the following lemmas, which are proved in Appendix F.\nLemma 8.2. During any instance \u03a0BasicMult(Zs,Za, SZs , [a], [b],GW1, . . . , GW |Zs|,GD, iter) of \u03a0BasicMult, if Pj \u2208 Selectediter then Pj 6\u2208 GD, irrespective of the network type.\nLemma 8.3. Suppose that no honest party is present in GD. If the honest parties start participating during hop number hop of Phase I of \u03a0BasicMult with iteration number iter, then except with probability O(n3 \u00b7 \u01ebICP), the hop takes TLSh + 2TBA time to complete in a synchronous network, or almost-surely completes eventually in an asynchronous network.\nLemma 8.4. If no honest party is present in GD, then in protocol \u03a0BasicMult, except with probability O(n3 \u00b7\u01ebICP), all honest parties compute some output by the time TBasicMult = (2n+ 1) \u00b7 TBA + (n+ 1) \u00b7 TLSh + TRec in a synchronous network, or almost-surely, eventually in an asynchronous network.\nLemma 8.5. If no honest party is present in GD, then the view of the adversary remains independent of a and b throughout the protocol, irrespective of the network type.\nLemma 8.6. If no honest party is present in GD and if all parties in P \\ GD behave honestly, then in protocol \u03a0BasicMult, the honest parties output a linear secret-sharing of a \u00b7 b with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets, irrespective of the network type.\nLemma 8.7. Protocol \u03a0BasicMult incurs a communication of O(|Zs| \u00b7n5 \u00b7 log |F|+ n6 \u00b7 log |F| \u00b7 |\u03c3|) bits and makes O(n2) calls to \u03a0BA.\nAs a corollary of Lemma 8.7, we can derive the following corollary, which determines the maximum number of instances of \u03a0LSh which are invoked during an instance of \u03a0BasicMult. Looking ahead, this will be useful to later calculate the maximum number of instances of \u03a0LSh which need to be invoked as part of our final multiplication protocol. This will be further useful to determine the number of linearly secret-shared values with IC-signatures and coresets GW1, . . . ,GW |Zs|, which need to be generated through the protocol \u03a0Rand beforehand.\nCorollary 8.1. During any instance of \u03a0BasicMult, there can be at most n 2 + n instances of \u03a0LSh invoked.\nProtocol \u03a0BasicMult for L Pairs of Inputs. Protocol \u03a0BasicMult can be easily generalized, if there are L pairs of inputs {(a\u2113, b\u2113)}\u2113=1,...,L, all of which are linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. However, with a slight modification during Phase I and Phase II, we can ensure that the number of instances of \u03a0BA remain only O(n2), which is independent of L. Consider Phase I. During hop number hop, every party Pi 6\u2208 (Selectediter\u222aGD) invokes L instances of\u03a0LSh to linearly secret-share L candidate summand-sums. Now while selecting the summand-sharing party through ACS for this hop, the parties vote for a candidate Pj 6\u2208 (Selectediter \u222a GD), provided an output is computed in all the L instances of \u03a0LSh invoked by Pj . Consequently, the number of instances of \u03a0BA during Phase I will be O(n2). Similarly during Phase II, each party outside (Selectediter \u222a GD) invokes L instances of \u03a0LSh to linearly secret-share L candidate re-assigned summand-sums. And then the parties vote for a candidate Pj as a summand-sharing party, if an output is computed in all the L instances of \u03a0LSh invoked by Pj . Finally, during Phase III, the default linear secret-sharing with IC-signatures is taken for the sum of all the summands, which are not yet secret-shared by any party, by making public all these summands. The resultant protocol incurs a communication of O(|Zs|3 \u00b7 n4 \u00b7 L \u00b7 log |F| + |Zs| \u00b7 n5 \u00b7 L \u00b7 log |F| + n6 \u00b7 L \u00b7 log |F| \u00b7 |\u03c3|) bits and makes O(n2) calls to \u03a0BA. We also note that there will be at most n2 \u00b7L+ n \u00b7L instances of \u03a0LSh invoked in the generalized protocol. To avoid repetition, we do not present the steps of the generalized protocol here."
        },
        {
            "heading": "8.3 Network Agnostic Random Triple Generation with Cheater Identification",
            "text": "The network-agnostic protocol \u03a0RandMultCI (Fig 12) takes an iteration number iter and a publicly known subset of parties GD, who are guaranteed to be corrupt. If all the parties in P \\ GD behave honestly, then the protocol outputs a random linearly secret-shared multiplication-triple with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core sets. Otherwise, with a high probability, the honest parties identify a new corrupt party, which is added to GD.\nProtocol\u03a0RandMultCI is based on [40] and consists of two stages: during the first stage, the parties jointly generate a pair of random values, which are linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core sets. During the second stage, the parties run an instance of \u03a0BasicMult to compute the product of the pair of secret-shared random values from the first stage. To check whether any cheating has occurred during the instance of \u03a0BasicMult, the parties then run a probabilistic test, namely the \u201csacrificing trick\u201d [27], for which the parties need additional secret-shared random values, which are generated during the first stage itself.\n\u2013 Generating Linear Secret Sharing of Random Values with ICsignatures: Each Pi \u2208 P does the following. \u2013 Invoke instances of \u03a0LSh with randomly chosen inputs a (i) iter, b (i) iter, b \u2032(i) iter , r (i) iter \u2208 F.\n\u2013 Corresponding to every Pj \u2208 P , participate in the instances of \u03a0LSh invoked by Pj (if any) and wait for time TLSh. Initialize a set Ci = \u2205 after local time TLSh and include Pj in Ci, if any output is computed in all the instances of \u03a0LSh invoked by Pj . \u2013 Corresponding to every Pj \u2208 P , participate in an instance of \u03a0 (j) BA of \u03a0BA with\ninput 1, if Pj \u2208 Ci. \u2013 Once 1 has been computed as the output from instances of \u03a0BA corresponding\nto a set of parties in P \\ Z for some Z \u2208 Zs, participate with input 0 in all the \u03a0BA instances \u03a0 (j) BA , such that Pj 6\u2208 Ci. \u2013 Once a binary output is computed in all the instances of \u03a0BA corresponding to the parties in P , compute CS, which is the set of parties Pj \u2208 P , such\nthat 1 is computed as the output in the instance \u03a0 (j) BA .\nOnce CS is computed, the parties in P locally compute [aiter], [biter], [b \u2032 iter] and [riter] from {[a(j)iter ]}Pj\u2208CS , {[b (j) iter ]}Pj\u2208CS , {[b \u2032(j) iter ]}Pj\u2208CS and {[r (j) iter ]}Pj\u2208CS respectively as follows:\n[aiter] = \u2211\nPj\u2208CS\n[a (j) iter ], [biter] =\n\u2211\nPj\u2208CS\n[b (j) iter], [b \u2032 iter] =\n\u2211\nPj\u2208CS\n[b \u2032(j) iter ], [riter] =\n\u2211\nPj\u2208CS\n[r (j) iter ].\n\u2013 Computing Secret-Shared Products: The parties in P do the following. \u2013 Participate in instances \u03a0BasicMult(Zs,Za, SZs , [aiter], [biter], GW1, . . . ,GW |Zs|,\nGD, iter) and \u03a0BasicMult(Zs,Za, SZs , [a], [b \u2032 iter],GW1, . . . ,GW |Zs|,GD, iter) of \u03a0BasicMult to compute the outputs (GW1, . . . , GW |Zs|, [c (1) iter ], . . . , [c (n) iter ], [citer]) and (GW1, . . . ,GW |Zs|, [c \u2032(1) iter ], . . . , [c \u2032(n) iter ], [c \u2032 iter]) respectively. Let Selectediter,c and Selectediter,c\u2032 be the summand-sharing parties for the two in-\nProtocol \u03a0RandMultCI(P ,Zs,Za, SZs ,GW1, . . . ,GW |Zs|,GD, iter)\nThe properties of the protocol \u03a0RandMultCI are claimed in the following lemmas, which are proved in Appendix F.\nLemma 8.8. In protocol \u03a0RandMultCI, the following hold. \u2013 Synchronous Network: Except with probability O(n3 \u00b7 \u01ebICP), honest parties\nwill have linearly secret-shared aiter, biter, b \u2032 iter and riter with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets, by the time TLSh + 2TBA. Moreover, adversary\u2019s view is independent of aiter, biter, b \u2032 iter and riter. \u2013 Asynchronous Network: Except with probability O(n3\u00b7\u01ebICP), almost-surely, honest parties will eventually have linearly secret-shared aiter, biter, b \u2032 iter and\nriter with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying coresets. Moreover, adversary\u2019s view is independent of aiter, biter, b \u2032 iter and riter.\nLemma 8.9. Consider an arbitrary iter, such that all honest parties participate in the instance \u03a0RandMultCI(P ,Zs,Za, SZs ,GW1, . . . ,GW |Zs|,GD, iter), where no\nhonest party is present in GD. Then except with probability O(n3 \u00b7\u01ebICP), all honest parties reconstruct a (common) value diter and set flagiter to a common Boolean value, at the time TLSh + 2TBA + TBasicMult + 3TRec in a synchronous network, or eventually in an asynchronous network.\nLemma 8.10. Consider an arbitrary iter, such that all honest parties participate in the instance \u03a0RandMultCI(P ,Zs,Za, SZs ,GW1, . . . ,GW |Zs|,GD, iter), where no honest party is present in GD. If no party in P \\ GD behaves maliciously, then diter = 0 and the honest parties output ([aiter], [biter], [citer]) at the time TLSh + 2TBA + TBasicMult + 3TRec in a synchronous network or eventually in an asynchronous network, where citer = aiter \u00b7 biter and where GW1, . . . ,GW |Zs| are the underlying core-sets\nLemma 8.11. Consider an arbitrary iter, such that all honest parties participate in the instance \u03a0RandMultCI(P ,Zs,Za, SZs ,GW1, . . . ,GW |Zs|,GD, iter), where no honest party is present in GD. If diter 6= 0, then except with probability O(n3\u00b7\u01ebICP), the honest parties update GD by adding a new maliciously-corrupt party in GD, either at the time TRandMultCI = TLSh+2TBA +TBasicMult +4TRec in a synchronous network or eventually in an asynchronous network.\nLemma 8.12. Consider an arbitrary iter, such that all honest parties participate in the instance \u03a0RandMultCI(P ,Zs,Za, SZs ,GW1, . . . ,GW |Zs|,GD, iter), where no honest party is present in GD. If diter = 0, then the honest parties output linearly secret-shared (aiter, biter, citer) with IC-signatures with GW1, . . . ,GW |Zs| being the underlying core-sets, at the time TLSh+2TBA+TBasicMult+3TRec in a synchronous network or eventually in an asynchronous network where, except with probability 1 |F| , the condition citer = aiter \u00b7 biter holds. Moreover, the view of Adv will be independent of (aiter, biter, citer).\nLemma 8.13. Protocol \u03a0RandMultCI incurs a communication of O(|Zs| \u00b7 n5 \u00b7 log |F|+ n6 \u00b7 log |F| \u00b7 |\u03c3|) bits and makes O(n2) calls to \u03a0BA.\nProtocol \u03a0RandMultCI for L Triples. Protocol \u03a0RandMultCI can be easily generalized to generate L triples with cheater identification, such that the number of instances of\u03a0BA is independent of L. To begin with, every party Pi now picks 3L+1 random values (r (i) iter, {a (\u2113,i) iter , b (\u2113,i) iter , b \u2032(\u2113,i) iter }\u2113=1,...,L) and invokes 3L+ 1 instances of \u03a0LSh to generate linear secret-sharing of these values with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. Next, to determine CS, the parties invoke only n instances of \u03a0BA, where the j th instance is used to decide whether Pj should be included in CS, the criteria being whether some output is computed in all the 3L+1 instances of \u03a0LSh invoked by Pj . Once CS is decided, the parties locally compute {[a (\u2113) iter]}\u2113=1,...,L, {[b (\u2113) iter]}\u2113=1,...,L, {[b \u2032(\u2113) iter]}\u2113=1,...,L and [riter] from {[a (\u2113,j) iter ]}Pj\u2208CS,\u2113=1,...,L, {[b (\u2113,j) iter ]}Pj\u2208CS,\u2113=1,...,L, {[b \u2032(\u2113,j) iter ]}Pj\u2208CS,\u2113=1,...,L and {[r (j) iter]}Pj\u2208CS respectively. The parties then invoke two instances of (generalized) \u03a0BasicMult protocol with L pairs of secret-shared inputs to compute {[c (\u2113) iter]}\u2113=1,...,L and {[c \u2032(\u2113) iter]}\u2113=1,...,L respectively. Note that this requires only\nO(n2) instances of \u03a0BA, apart from n2 \u00b7 L + n \u00b7 L instances of \u03a0LSh. The rest of the protocol steps are then generalized to deal with L inputs. The resultant protocol incurs a communication of O(|Zs| \u00b7 n\n5 \u00b7 L \u00b7 log |F|+ n6 \u00b7 L \u00b7 log |F| \u00b7 |\u03c3|) bits and makes O(n2) calls to \u03a0BA. We also note that there will be at most n2 \u00b7 L+ 4n \u00b7 L+ n instances of \u03a0LSh invoked overall in the generalized protocol. To avoid repetition, we do not present the steps of the generalized protocol here."
        },
        {
            "heading": "8.4 The Multiplication-Triple Generation Protocol",
            "text": "Protocol \u03a0TripGen for generating a single secret-shared multiplication-triple is presented in Fig 13. The idea of the protocol is very simple and based on [40]. The parties iteratively run instances of\u03a0RandMultCI, till they hit upon an instance when no cheating is detected. Corresponding to each \u201cfailed\u201d instance of \u03a0RandMultCI, the parties keep updating the set GD. Since after each failed instance the set GD is updated with one new corrupt party, there will be at most (t + 1) iterations, where t is the cardinality of the largest-sized subset in Zs.\nThe properties of the protocol \u03a0TripGen are claimed in the following lemmas, which are proved in Appendix F.\nLemma 8.14. Let t be the size of the largest set in Zs. Then except with probability O(n3 \u00b7 \u01ebICP), the honest parties compute an output during \u03a0TripGen, by the time TTripGen = (t + 1) \u00b7 TRandMultCI in a synchronous network, or almostsurely, eventually in an asynchronous network, where TRandMultCI = TLSh+2TBA+ TBasicMult + 4TRec.\nLemma 8.15. If the honest parties output (GW1, . . . ,GW |Zs|, [aiter], [biter], [citer]) during the protocol \u03a0TripGen, then aiter, biter and citer are linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. Moreover, citer = aiterbiter holds, except with probability 1 |F| . Furthermore, the view of the adversary remains independent of aiter, biter and citer.\nLemma 8.16. Protocol \u03a0TripGen incurs a communication of O(|Zs| \u00b7n6 \u00b7 log |F|+ n7 \u00b7 log |F| \u00b7 |\u03c3|) bits and makes O(n3) calls to \u03a0BA.\nProtocol \u03a0TripGen for Generating L Multiplication-Triples. To generate L multiplication-triples, the parties now need to invoke an instance of the generalized (modified) \u03a0RandMultCI protocol in each iteration, which generates L triples with cheater identification. The rest of the protocol steps remain the same. To avoid repetition, we do not present the formal details here. The protocol incurs a communication of O(|Zs| \u00b7 n6 \u00b7 L \u00b7 log |F|+ n7 \u00b7 L \u00b7 log |F| \u00b7 |\u03c3|) bits and makes O(n3) calls to \u03a0BA.\nOn the Maximum Number of Calls of \u03a0LSh in \u03a0TripGen. As discussed in the previous section, each instance of \u03a0RandMultCI for L triples requires at most n2 \u00b7 L + 4n \u00b7 L + n instances of \u03a0LSh. Now as there can be up to t + 1 \u2248 n such instances of \u03a0RandMultCI in the protocol \u03a0TripGen, it follows that at most n3 \u00b7 L + 4n2 \u00b7 L + n2 instances of \u03a0LSh are invoked in the protocol \u03a0TripGen for generating L multiplication-triples."
        },
        {
            "heading": "9 Network Agnostic Circuit-EvaluationProtocol",
            "text": "The network-agnostic circuit-evaluation protocol \u03a0cktEval is presented in Fig 14. The idea behind the protocol is to perform shared circuit-evaluation, where each value remains linearly secret-shared with IC-signatures and common core-sets Once the function-output is secret-shared, it is publicly reconstructed. To achieve this goal, the parties first secret-share their respective inputs for the function f through instances of \u03a0LSh. The parties then agree on a common subset of parties CS, where P \\ CS \u2208 Zs, such that the inputs of the parties in CS are linearly secret-shared with IC-signatures. If the network is synchronous then it will be ensured that all honest parties are present in CS and hence the inputs of all honest parties are considered for the circuit-evaluation. The linearity of secretsharing ensures that the linear gates in ckt are evaluated non-interactively, while Beaver\u2019s trick is deployed for evaluating multiplication gates in ckt. For the latter, the parties need to have cM number of random multiplication-triples apriori, which are linearly secret-shared with IC-signatures. This is achieved by apriori calling the protocol \u03a0TripGen with L = cM , which in turn will require at most n3\u00b7cM+4n2\u00b7cM+n2 number of instances of\u03a0LSh. As the total number of instances of \u03a0LSh across \u03a0TripGen and the input-phase is at most n\n3 \u00b7cM +4n2 \u00b7cM +n2+n, the parties first invoke an instance of \u03a0Rand by setting L = n\n3 \u00b7 cM + 4n2 \u00b7 cM + n\n2 + n, to generate these many linearly secret-shared random values with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. This will ensure that all the values during the circuit-evaluation are linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets.\nNotice that if the network is asynchronous then different parties may be in the different phases of the protocol. And consequently, a party upon reconstructing the function output cannot afford to immediately terminate, as its presence may be required in the other parts of the protocol. Hence there is also a termination phase, which is executed concurrently, where the parties check if it is \u201csafe\u201d to terminate the protocol.\nPre-Processing Phase \u2013 Generating Linearly Secret-Shared Random Values with IC-\nsignatures: The parties invoke an instance \u03a0Rand(P ,Zs,Za, SZs , L) where L = n3 \u00b7cM+4n 2 \u00b7cM+n 2+n and compute output (GW1, . . . ,GW |Zs|, {[r\n(l)]}l=1,...,L) \u2013 Generating Linearly Secret-Shared Random Multiplication-Triples\nwith IC-signatures: Upon computing an output in the instance of \u03a0Rand, the parties invoke an instance \u03a0TripGen(P ,Zs,Za, SZs ,GW1, . . . ,GW |Zs|) with L = cM and compute output (GW1, . . . ,GW |Zs|, {[a (\u2113)], [b(\u2113)], [c(\u2113)]}\u2113=1,...,cM ). During the instance of \u03a0TripGen, the secret-shared values {[r (l)]}l=1,...,n3\u00b7cM+4n2\u00b7cM+n2 are used as the corresponding pads in the underlying instances of \u03a0LSh, invoked as part of \u03a0TripGen.\nInput Phase\nUpon computing an output during the instance of \u03a0TripGen, each Pi \u2208 P does the following. \u2013 On having the input x(i), invoke an instance of \u03a0LSh with input x (i).a\n\u2013 Corresponding to every Pj \u2208 P , participate in the instance of \u03a0LSh invoked by Pj and wait for local time TLSh after starting the input phase. Then initialize a set Ci = \u2205 and include Pj in Ci, if any output is computed in the instance of \u03a0LSh invoked by Pj . \u2013 Corresponding to every Pj \u2208 P , participate in an instance of \u03a0 (j) BA of \u03a0BA with\ninput 1, if Pj \u2208 Ci. \u2013 Once 1 has been computed as the output from instances of \u03a0BA corresponding\nto a set of parties in P \\ Z for some Z \u2208 Zs, participate with input 0 in all the \u03a0BA instances \u03a0 (j) BA , such that Pj 6\u2208 Ci. \u2013 Once a binary output is computed in all the instances of \u03a0BA corresponding to the parties in P , compute CS, which is the set of parties Pj \u2208 P , such that 1 is\ncomputed as the output in the instance \u03a0 (j) BA .\nOnce CS is computed, corresponding to every Pj 6\u2208 CS, the parties set x (j) = 0 and take the default linear secret-sharing of 0 with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets.\nCircuit-Evaluation Phase\n\u2013 Evaluate each gate g in the circuit according to the topological ordering as follows, depending upon the type. \u2013 Addition Gate: If g is an addition gate with inputs x, y and output z, then\nthe parties in P locally compute [z] = [x+ y] from [x] and [y]. \u2013 Multiplication Gate: If g is the \u2113th multiplication gate with inputs x, y and\noutput z, where \u2113 \u2208 {1, . . . ,M}, then the parties in P do the following: \u2013 Locally compute [d(\u2113)] = [x\u2212a(\u2113)] from [x] and [a(\u2113)] and [e(\u2113)] = [y\u2212 b(\u2113)]\nfrom [y] and [b(\u2113)]. \u2013 Participate in instances \u03a0Rec([d (\u2113)],P) and \u03a0Rec([e (\u2113)],P) of \u03a0Rec to pub-\nlicly reconstruct d(\u2113) and e(\u2113), where d(\u2113) def = x\u2212a(\u2113) and e(\u2113) def = y\u2212b(\u2113). \u2013 Upon reconstructing d(\u2113) and e(\u2113), take the default linear secret-sharing of d(\u2113)\u00b7e(\u2113) with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying\nProtocol \u03a0cktEval(P ,Zs,Za, SZs , ckt, cM )\nThe properties of the protocol \u03a0cktEval stated in Theorem 9.1, are proved in Appendix G.\nTheorem 9.1. Let Zs and Za be monotone adversary structures where Za \u2282 Zs, the set Zs satisfy the condition Q(2)(P ,Zs), the set Za satisfy the condition Q(3)(P ,Za) and Zs,Za together satisfy the Q(2,1)(P ,Zs,Za) condition. Let F be a finite field such that |F| \u2265 n5 \u00b7 2ssec where ssec is the statistical security parameter. Moreover, let y = f(x(1), . . . , x(n)) be a publicly known function over F represented by an arithmetic circuit ckt over F, where each Pi \u2208 P has the input x(i). Furthermore, let cM and DM be the number of multiplication gates and the multiplicative depth of ckt respectively. Then given an unconditionally-secure PKI, protocol \u03a0cktEval achieves the following, where every honest Pj participates with the input x(j) and where t denotes the cardinality of the maximum sized subset in Zs.\n\u2013 Synchronous Network: Except with probability 2\u2212ssec, all honest parties output y = f(x(1), . . . , x(n)) at the time [(3n+ 5)t2 + (74n+ 140)t+ 69n+ DM + 438] \u00b7 \u2206, where x(j) = 0, for every Pj 6\u2208 CS and where every honest party is present in CS, such that P \\ CS \u2208 Zs. \u2013 Asynchronous Network: Except with probability 2\u2212ssec, almost-surely, all honest parties eventually output y = f(x(1), . . . , x(n)) where x(j) = 0, for every Pj 6\u2208 CoreSet and where P \\ CS \u2208 Zs.\nThe protocol incurs a communication of O(|Zs|2 \u00b7 n12 \u00b7 log |F|) bits and makes O(n3) calls to \u03a0BA. Moreover, irrespective of the network type, the view of the adversary remains independent of the inputs of the honest parties in CS."
        },
        {
            "heading": "10 Impossibility Result",
            "text": "Here we show the necessity of the Q(2,1)(P ,Zs,Za) condition for network agnostic MPC. In fact we show that the condition is even necessary for network agnostic BA. For this, we generalize the impossibility proof of [15] which shows the impossibility of network agnostic BA against threshold adversaries if 2ts+ta \u2265 n.\nTheorem 10.1. Let Zs and Za satisfy the Q(2)(P ,Zs) and Q(3)(P ,Za) conditions respectively, where Za \u2282 Zs.16 Moreover, let the parties have access to the setup of an unconditional PKI. Furthermore, let \u03a0 be an n-party protocol, which is a Zs-secure SBA protocol in the synchronous network and which is a Za-secure ABA protocol in the asynchronous network (as per Definition 3.1). Then \u03a0 exists only if Zs and Za satisfy the Q(2,1)(P ,Zs,Za) condition.\nProof. The proof is by contradiction. Let \u03a0 exist, even if Zs and Za do not satisfy the Q(2,1)(P ,Zs,Za) condition. Then, there exist sets, say Z0, Z1 \u2208 Zs and Z2 \u2208 Za such that Z0 \u222a Z1 \u222a Z2 \u2287 P holds. For simplicity and without loss of generality, assume that Z0, Z1 and Z2 are disjoint. Now consider the following executions of \u03a0 . In all these executions, parties in Z0 participate with input 0, and parties in Z1 participate with input 1. \u2013 Execution E1: In this execution, the network is synchronous. All the parties\nin Z0 are corrupted by the adversary and simply abort, and all parties in Z2 participate with input 1. Since all the honest parties (namely the parties in Z1\u222aZ2) have input 1, from the Zs-validity of \u03a0 in the synchronous network, the parties in Z1 \u222a Z2 should output 1 after some fixed time, say T1. \u2013 Execution E2: In this execution, the network is synchronous. All the parties in Z1 are corrupted by the adversary and simply abort, and all parties in Z2 participate with input 0. Since all the honest parties (namely the parties in Z0\u222aZ2) have input 0, from the Zs-validity of \u03a0 in the synchronous network, the parties in Z0 \u222a Z2 should output 0 after some fixed time, say T2. \u2013 Execution E3: In this execution, the network is asynchronous, the adversary corrupts all the parties in Z2 and behave as follows: the communication between the parties in Z0 and Z1 is delayed by at least time max(T1, T2). The adversary communicates with parties in Z0 and Z1, such that the views of the parties in Z0 and Z1 are identical to E1 and E2 respectively. For this, the adversary runs \u03a0 with input 0 when interacting with the parties in Z0 and runs \u03a0 with input 1 when interacting with the parties in Z1. Hence, the parties in Z0 output 0, while the parties in Z1 output 1, which violates the Za-consistency of \u03a0 in the asynchronous network. This is a contradiction and hence, \u03a0 does not exist.\n16 The necessity of the Q(2)(P ,Zs) and Q (3)(P ,Za) conditions follow from the existing\nresults on the impossibility of unconditionally-secure SBA and ABA respectively, without these conditions. The condition Za \u2282 Zs is also necessary since any potential corrupt subset which is tolerable in an asynchronous network should also be tolerable if the network is synchronous."
        },
        {
            "heading": "11 Acknowledgements",
            "text": "We would like to thank Anirudh Chandramouli for several helpful discussions during the early stages of this research."
        },
        {
            "heading": "11. M. Ben-Or. Another Advantage of Free Choice (Extended Abstract): Completely",
            "text": "Asynchronous Agreement Protocols. In PODC, pages 27\u201330. ACM, 1983."
        },
        {
            "heading": "12. M. Ben-Or, R. Canetti, and O. Goldreich. Asynchronous Secure Computation. In",
            "text": "STOC, pages 52\u201361. ACM, 1993."
        },
        {
            "heading": "13. M. Ben-Or, S. Goldwasser, and A. Wigderson. Completeness Theorems for NonCryptographic Fault-Tolerant Distributed Computation (Extended Abstract). In",
            "text": "STOC, pages 1\u201310. ACM, 1988."
        },
        {
            "heading": "14. M. Ben-Or, B. Kelmer, and T. Rabin. Asynchronous Secure Computations with",
            "text": "Optimal Resilience (Extended Abstract). In PODC, pages 183\u2013192. ACM, 1994."
        },
        {
            "heading": "15. E. Blum, J. Katz, and J. Loss. Synchronous Consensus with Optimal Asynchronous",
            "text": "Fallback Guarantees. In TCC, volume 11891 of Lecture Notes in Computer Science, pages 131\u2013150. Springer, 2019."
        },
        {
            "heading": "16. E. Blum, J. Katz, and J. Loss. Tardigrade: An Atomic Broadcast Protocol for",
            "text": "Arbitrary Network Conditions. In ASIACRYPT, volume 13091 of Lecture Notes in Computer Science, pages 547\u2013572. Springer, 2021."
        },
        {
            "heading": "17. E. Blum, C. Liu Zhang, and J. Loss. Always Have a Backup Plan: Fully Secure",
            "text": "Synchronous MPC with Asynchronous Fallback. In CRYPTO, volume 12171 of Lecture Notes in Computer Science, pages 707\u2013731. Springer, 2020. 18. G. Bracha. An Asynchronous [(n-1)/3]-Resilient Consensus Protocol. In PODC, pages 154\u2013162. ACM, 1984. 19. R. Canetti. Studies in Secure Multiparty Computation and Applications. PhD thesis, Weizmann Institute, Israel, 1995."
        },
        {
            "heading": "20. R. Canetti. Universally Composable Security: A New Paradigm for Cryptographic",
            "text": "Protocols. In FOCS, pages 136\u2013145. IEEE Computer Society, 2001."
        },
        {
            "heading": "21. R. Canetti and T. Rabin. Fast Asynchronous Byzantine Agreement with Optimal",
            "text": "Resilience. In STOC, pages 42\u201351, 1993."
        },
        {
            "heading": "22. B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch. Verifiable Secret Sharing and",
            "text": "Achieving Simultaneity in the Presence of Faults (Extended Abstract). In 26th Annual Symposium on Foundations of Computer Science, Portland, Oregon, USA, 21-23 October 1985, pages 383\u2013395. IEEE Computer Society, 1985."
        },
        {
            "heading": "23. A. Choudhury. Almost-Surely Terminating Asynchronous Byzantine Agreement",
            "text": "Against General Adversaries with Optimal Resilience. In ICDCN, pages 167\u2013176. ACM, 2023."
        },
        {
            "heading": "24. A. Choudhury and A. Patra. An Efficient Framework for Unconditionally Secure",
            "text": "Multiparty Computation. IEEE Trans. Information Theory, 63(1):428\u2013468, 2017."
        },
        {
            "heading": "25. A. Choudhury and A. Patra. On the Communication Efficiency of Statistically",
            "text": "Secure Asynchronous MPC with Optimal Resilience. J. Cryptol., 36(2):13, 2023. 26. R. Cramer, I. Damg\u030aard, S. Dziembowski, M. Hirt, and T. Rabin. Efficient Multiparty Computations Secure Against an Adaptive Adversary. In EUROCRYPT, volume 1592 of Lecture Notes in Computer Science, pages 311\u2013326. Springer, 1999."
        },
        {
            "heading": "27. I. Damg\u030aard, V. Pastro, N. P. Smart, and S. Zakarias. Multiparty Computation from Somewhat Homomorphic Encryption. In R. Safavi-Naini and R. Canetti, editors,",
            "text": "Advances in Cryptology - CRYPTO 2012 - 32nd Annual Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2012. Proceedings, volume 7417 of Lecture Notes in Computer Science, pages 643\u2013662. Springer, 2012."
        },
        {
            "heading": "28. G. Deligios and C. Liu-Zhang. Synchronous Perfectly Secure Message Transmission",
            "text": "with Optimal Asynchronous Fallback Guarantees. IACR Cryptol. ePrint Arch., page 1397, 2022. 29. D. Dolev, C. Dwork, O. Waarts, and M. Yung. Perfectly Secure Message Transmission. J. ACM, 40(1):17\u201347, 1993."
        },
        {
            "heading": "30. Danny Dolev and H. Raymond Strong. Authenticated algorithms for byzantine",
            "text": "agreement. SIAM J. Comput., 12(4):656\u2013666, 1983. 31. Pesech Feldman and Silvio Micali. An optimal probabilistic protocol for synchronous byzantine agreement. SIAM Journal on Computing, 26(4):873\u2013933, 1997. 32. M. J. Fischer, N. A. Lynch, and M. Paterson. Impossibility of Distributed Consensus with One Faulty Process. J. ACM, 32(2):374\u2013382, 1985."
        },
        {
            "heading": "33. M. Fitzi and U. M. Maurer. Efficient Byzantine Agreement Secure Against General",
            "text": "Adversaries. In DISC, volume 1499 of Lecture Notes in Computer Science, pages 134\u2013148. Springer, 1998. 34. Matthias Fitzi. Generalized Communication and Security Models in Byzantine Agreement. PhD thesis, 2002."
        },
        {
            "heading": "35. D. Ghinea, C. Liu-Zhang, and R. Wattenhofer. Optimal Synchronous Approximate",
            "text": "Agreement with Asynchronous Fallback. In PODC, pages 70\u201380. ACM, 2022."
        },
        {
            "heading": "36. O. Goldreich, S. Micali, and A. Wigderson. How to Play any Mental Game or A Completeness Theorem for Protocols with Honest Majority. In A. V. Aho, editor,",
            "text": "Proceedings of the 19th Annual ACM Symposium on Theory of Computing, 1987, New York, New York, USA, pages 218\u2013229. ACM, 1987."
        },
        {
            "heading": "37. V. Goyal, Y. Song, and C. Zhu. Guaranteed Output Delivery Comes Free in Honest",
            "text": "Majority MPC. In CRYPTO, volume 12171 of Lecture Notes in Computer Science, pages 618\u2013646. Springer, 2020."
        },
        {
            "heading": "38. Martin Hirt and Ueli Maurer. Complete characterization of adversaries tolerable",
            "text": "in secure multi-party computation (extended abstract). In PODC, pages 25\u201334. ACM, 1997."
        },
        {
            "heading": "39. Martin Hirt and Ueli Maurer. Player simulation and general adversary structures",
            "text": "in perfect multiparty computation. Journal of Cryptology, 13(1):31\u201360, 2000.\n40. Martin Hirt and Daniel Tschudi. Efficient general-adversary multi-party computation. In ASIACRYPT, volume 8270 of Lecture Notes in Computer Science, pages 181\u2013200. Springer, 2013."
        },
        {
            "heading": "41. M. Ito, A. Saito, and T. Nishizeki. Secret Sharing Schemes Realizing General",
            "text": "Access Structures). In Global Telecommunication Conference, Globecom, pages 99\u2013102. IEEE Computer Society, 1987.\n42. M. V. N. Ashwin Kumar, K. Srinathan, and C. Pandu Rangan. Asynchronous Perfectly Secure Computation Tolerating Generalized Adversaries. In ACISP, volume 2384 of Lecture Notes in Computer Science, pages 497\u2013512. Springer, 2002."
        },
        {
            "heading": "43. K. Kursawe and F. C. Freiling. Byzantine Fault Tolerance on General Hybrid Adversary Structures. Technical Report, RWTH Aachen, 2005.",
            "text": "44. U. M. Maurer. Secure Multi-party Computation Made Simple. In SCN, volume 2576 of Lecture Notes in Computer Science, pages 14\u201328. Springer, 2002.\n45. A. Momose and L. Ren. Multi-Threshold Byzantine Fault Tolerance. In CCS, pages 1686\u20131699. ACM, 2021.\n46. Atsuki Momose and Ling Ren. Multi-threshold byzantine fault tolerance. In Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security, CCS \u201921, page 1686\u20131699, New York, NY, USA, 2021. Association for Computing Machinery."
        },
        {
            "heading": "47. A. Moste\u0301faoui, H. Moumen, and M. Raynal. Signature-Free Asynchronous Binary Byzantine Consensus with t < n/3, O(n2) Messages, and O(1) Expected Time. J.",
            "text": "ACM, 62(4):31:1\u201331:21, 2015."
        },
        {
            "heading": "48. A. Patra, A. Choudhury, and C. Pandu Rangan. Efficient Asynchronous Verifiable",
            "text": "Secret Sharing and Multiparty Computation. J. Cryptology, 28(1):49\u2013109, 2015."
        },
        {
            "heading": "49. Marshall Pease, Robert Shostak, and Leslie Lamport. Reaching Agreement in the",
            "text": "Presence of Faults. Journal of the ACM (JACM), 27(2):228\u2013234, 1980.\n50. B. Pfitzmann and M.Waidner. Information-theoretic Pseudosignatures and Byzantine Agreement for t \u2265 n/3. Technical Report RZ 2882 (#90830), IBM Research, 1996.\n51. Michael O. Rabin. Randomized Byzantine Generals. In 24th Annual Symposium on Foundations of Computer Science, Tucson, Arizona, USA, 7-9 November 1983, pages 403\u2013409, 1983."
        },
        {
            "heading": "52. T. Rabin and M. Ben-Or. Verifiable Secret Sharing and Multiparty Protocols with",
            "text": "Honest Majority (Extended Abstract). In STOC, pages 73\u201385. ACM, 1989.\n53. A. C. Yao. Protocols for Secure Computations (Extended Abstract). In FOCS, pages 160\u2013164. IEEE Computer Society, 1982."
        },
        {
            "heading": "A Properties of the Network Agnostic BA Protocol",
            "text": "In this section, we prove the properties of the network agnostic BA protocol (see Fig 1 for the protocol). We first formally present the sub-protocol \u03a0PW and prove its properties.\nA.1 Protocol \u03a0PW: Synchronous BA with Asynchronous Guaranteed Liveness\nProtocol \u03a0PW is presented in Fig 15, where for simplicity we assume that the input of each party is a bit. The protocol is very simple. Each party Pi uses a Dolev-Strong (DS) style protocol [30] to broadcast its input bi. The protocol runs for t+ 1 \u201crounds\u201d, where t is the size of the largest set in Zs. Each party Pi accumulates values on the behalf of every party Pj in a set ACCij . A bit b is added to ACCij during round r only if Pi receives signatures on b from r distinct parties including Pj . Party Pi computes the final output by taking the \u201cmajority\u201d among the accumulated values. This is done by computing a final set FINi of values based on each ACCij set. Since the DS protocol is designed for the synchronous network, for convenience, we present the protocol \u03a0PW in a round-based fashion, where the parties set the duration of each round to \u2206 and will know the beginning and end of each round.\nWe next prove the properties of the protocol \u03a0PW, which are a straightforward generalization of the properties of the DS protocol.\nLemma A.1. Protocol \u03a0PW achieves Zs-Consistency in a synchronous network.\nProof. We claim that each honest party Pi computes the same set ACCij corresponding to every party Pj , by time (t + 1) \u00b7 \u2206. Assuming the claim is true, the proof then follows from the fact that FINi is computed deterministically at the time (t + 1) \u00b7 \u2206, based on the sets ACCij . To prove the claim, consider an arbitrary honest party Pi and an arbitrary Pj . If Pi includes b to ACCij , then we show that by the time (t+1) \u00b7\u2206, the value b will be present in the set ACCkj of every honest party Pk. For this, we consider the following two cases. \u2013 Case 1 - Pi added b to ACCij during round r where r \u2264 t: In this\ncase, Pi must have received (b, j, SETj) in round r, where SETj contained valid signatures on b from r\u22121 distinct parties apart from Pj . Party Pi then computes \u03c3ij , adds this to SETj , and sends (b, j, SETj) to every party. When Pk receives this during round r + 1, it will find that SETj contains r valid signatures on b apart from party Pj \u2019s, including \u03c3ij . Hence, Pk will add b to ACCkj . Since r + 1 \u2264 t+ 1, this happens by time (t+ 1) \u00b7\u2206. \u2013 Case 2 - Pi added b to ACCij during round r = t + 1: In this case Pi must have received (b, j, SETj) in round t + 1, where SETj contained valid signatures on b from t distinct parties apart from Pj . This means that, in total, Pi has received valid signatures on b from t+1 distinct parties. Among these, at least one party, say Ph, must be honest, as there can be at most t corrupt parties. This means that Ph must have added b to ACChj during some round r\u2032, where r\u2032 \u2264 t. Thus, as argued in the previous case, each party Pk also adds b to ACCkj by round t+ 1 and hence time (t+ 1) \u00b7\u2206.\nLemma A.2. Protocol \u03a0PW achieves Zs-Validity in a synchronous network.\nProof. Suppose that all honest parties have the same input b. Corresponding to each honest party Pj , every honest Pi sets ACCij = {b}. This is because Pi would receive a valid signature on b from Pj during round 0, and adds b to ACCij . Further, Pi will not add any b\n\u2032 6= b to ACCij during any of the rounds, since the adversary cannot forge a signature on b\u2032 on the behalf of Pj . Thus, for each honest Pj , party Pi adds (j, b) to FINi. Let Z\n\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. Hence corresponding to every Pj \u2208 H, then value (j, b) is added to FINi of every Pi \u2208 H by time (t + 1) \u00b7 \u2206. Moreover, since Q(2)(P ,Zs) conditions holds, P \\Z\u22c6 6\u2208 Zs. Consequently, as per the \u201cmajority\u201d rule, every party in H outputs b.\nLemma A.3. In protocol \u03a0PW, irrespective of the network type, all honest parties obtain an output at the time (t+ 1) \u00b7\u2206.\nProof. The proof follows from the fact that irrespective of the network type, the parties compute an output (which could be \u22a5) at the local time (t+ 1) \u00b7\u2206.\nIf the inputs of the parties are of size \u2113 bits, then we invoke \u2113 instances of \u03a0PW. The following lemma describes the communication cost incurred while doing this.\nLemma A.4. If the inputs of the parties are of size \u2113 bits, then protocol \u03a0PW incurs a communication of O(n4 \u00b7 \u2113 \u00b7 |\u03c3|) bits from the honest parties.\nProof. During round 0, each party signs its input and sends this to every other party, incurring a total communication of O(\u2113 \u00b7 n2 \u00b7 |\u03c3|) bits. During the next t rounds, each party Pi sends (b, j, SETj) to every other party Pk at most once. This is because Pi sends this only if b /\u2208 ACCij holds, and does not do this once it adds b to ACCij . Considering all possibilities for b, i, j and k, and taking into account that SETj will contain O(n) signatures, the communication cost of this will be O(\u2113 \u00b7 n4 \u00b7 |\u03c3|) bits.\nThe proof of Lemma 3.1 now follows from Lemma A.1-A.4.\nA.2 Protocool \u03a0Acast: Asynchronous Broadcast with Synchronous Guarantees\nIn this section, we prove the properties of the protocol \u03a0Acast (see Fig 2 for the protocol description).\nLemma 3.2. Protocol \u03a0Acast achieves the following properties. \u2013 Asynchronous Network: The protocol is a Za-secure broadcast protocol. \u2013 Synchronous Network: (a) Zs-Liveness: If Sen is honest, then all honest\nparties obtain an output within time 3\u2206. (b) Zs-Validity: If Sen is honest, then every honest party with an output, outputs m. (c) Zs-Consistency: If Sen is corrupt and some honest party outputs m\u22c6 at time T , then every honest Pi outputs m\n\u22c6 by the end of time T +\u2206. \u2013 Communication Complexity: O(n3 \u00b7\u2113 \u00b7 |\u03c3|) bits are communicated by the honest\nparties, where \u2113 is the size of Sen\u2019s input.\nProof. We first consider a synchronous network, followed by an asynchronous network.\nProperties in the Synchronous Network. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. Suppose Sen is honest. Then by time \u2206, each party in H receives \u3008(propose,m)\u3009Sen from Sen and no honest party ever receives \u3008(propose,m\u2032)\u3009Sen from any party by time 2\u2206, for any m\u2032 6= m, since signature of an honest Sen cannot be forged. Thus, every Pj \u2208 H sends \u3008(vote,m)\u3009j by time 2\u2206. Consequently, by time 3\u2206, every Pi \u2208 H will have a quorum C(m) of legitimately signed \u3008(vote,m)\u3009j messages corresponding to every Pj \u2208 H. The parties Pk \u2208 Z\n\u22c6 may send signed \u3008(vote,m\u2032)\u3009k messages where m\u2032 6= m and consequently the parties in H may also have a quorum C(m\u2032) of legitimately signed \u3008(vote,m\u2032)\u3009k messages corresponding to every Pk \u2208 Z\u22c6. However, since Zs satisfies the Q(2)(P ,Zs) condition, P \\ Z\u22c6 = H 6\u2208 Zs. Consequently, the parties in H outputs m by time 3\u2206, as the condition for outputting an m\u2032 6= m will be never satisfied for the parties in H. This proves the Zs-liveness and Zs-validity.\nWe now consider Sen to be corrupt. We first show that no two parties in H can vote for different messages. On the contrary, let Pi \u2208 H sends \u3008vote,m\u2032)\u3009i at time Ti, and let Pj \u2208 H sends \u3008(vote,m\n\u2032\u2032)\u3009j at time Tj , where Tj \u2265 Ti. This implies that Pi must have received \u3008(propose,m\u2032)\u3009Sen from Sen within time Ti\u2212\u2206, and would have sent \u3008(propose,m\u2032)\u3009Sen to Pj . And Pj would have received \u3008(propose,m\u2032)\u3009Sen from Pi within time Ti. Now since Ti \u2264 Tj , it implies that Pj would not have sent \u3008(vote,m\u2032\u2032)\u3009j at time Tj , and this is a contradiction.\nNow based on the above fact, we proceed to prove that Zs-consistency holds. Let Ph \u2208 H outputs m\u22c6 at time T . This implies that at time T , there exists a subset Z\u03b1 \u2208 Zs, such that Ph has a quorum C(m\u22c6) of legitimately signed \u3008(vote,m)\u3009j messages, corresponding to every Pj \u2208 P\\Z\u03b1. Now since Zs satisfies the Q(2)(P ,Zs) condition, it follows that H \u2229 (P \\ Z\u03b1) 6= \u2205. This implies that there exists at least one party in H, say Pk, who has voted for m\u22c6 by sending a \u3008(vote,m)\u3009k message. Consequently, no other party in H every votes for m\u22c6\u22c6 6= m\u22c6. The parties in Z\u22c6 may vote for m\u22c6\u22c6 6= m\u22c6. But since P \\Z\u22c6 6\u2208 Zs, it follows that no party in H will ever have a sufficiently large quorum of legitimately signed vote messages for m\u22c6\u22c6 to output m\u22c6\u22c6. Since Ph sends C(m\u22c6) to all parties at time T , every other party inH will receive C(m\u22c6) by time T+\u2206. Consequently, all the parties in H will output m\u22c6, latest by time T +\u2206.\nProperties in the Asynchronous Network. We now consider an asynchronous network. Let Z\u22c6 \u2208 Za be the set of corrupt parties and let H = P \\Z\u22c6 be the set of honest parties. We first consider an honest Sen. Each party in H eventually receives \u3008(propose,m)\u3009Sen from Sen. Furthermore, no party in H ever receives \u3008(propose,m\u2032)\u3009Sen from any party, for any m\u2032 6= m, since the signature of an honest Sen cannot be forged. Hence, each party in H eventually sends a signed vote message for m, which is eventually delivered to every party in H. The parties in Z\u22c6 may send signed vote messages for m\u2032 6= m. However, since Za satisfies the Q\n(3)(P ,Za) condition, it follows that each party in H eventually outputs m and the conditions for outputting m\u2032 6= m will be never satisfied for any party in H. This proves the Za-liveness and Za-consistency.\nNext, consider a corrupt Sen. Let Ph \u2208 H outputs m\u22c6. This implies there exists a subset Z\u03b1 \u2208 Zs, such that Ph has a quorum C(m\u22c6) of legitimately signed vote messages for m\u22c6, corresponding to every party in P \\ Z\u03b1. Now consider an arbitrary Pi \u2208 H, where Pi 6= Ph. We claim that for any Z \u2208 Zs, party Pi will never have a quorum C(m\u22c6\u22c6) of legitimately signed vote messages for m\u22c6\u22c6, corresponding to the parties in P \\ Z. On the contrary, let Pi eventually have a quorum C(m\u22c6\u22c6) of legitimately signed vote messages for m\u22c6\u22c6, corresponding to every party in P \\ Z\u03b2, for some Z\u03b2 \u2208 Zs. Now since the Q(2,1)(P ,Zs,Za) condition is satisfied, it follows that H \u2229 (P \\ Z\u03b1) \u2229 (P \\ Z\u03b2) 6= \u2205. This implies that there exists at least one party from H, say Pk, such that Pk has voted both for m\u22c6, as well as m\u22c6\u22c6, which is a contradiction. Consequently, Pi will never output m\u22c6\u22c6. Now, since Ph sends C(m\u22c6) to all the parties, party Pi eventually receives C(m\u22c6) and outputs m\u22c6. This proves Za-consistency.\nFinally, the communication complexity follows from the fact that irrespective of the type of network, every party may have to send a quorum of up to O(n) signed vote messages, to every other party.\nA.3 Properties of the Protocol \u03a0BC\nIn this section, we prove the properties of the protocol \u03a0BC (see Fig 3 for the formal description).\nTheorem 3.2. Protocol \u03a0BC achieves the following, with a communication complexity of O(n4 \u00b7 \u2113 \u00b7 |\u03c3|) bits, where TBC = 3\u2206+ TPW. \u2013 Synchronous network:\n\u2013 (a) Zs-Liveness: At time TBC, each honest party has an output. \u2013 (b) Zs-Validity: If Sen is honest, then at time TBC, each honest party\noutputs m. \u2013 (c) Zs-Consistency: If Sen is corrupt, then the output of every honest\nparty is the same at time TBC. \u2013 (d) Zs-Fallback Consistency: If Sen is corrupt and some honest party\noutputs m\u22c6 6= \u22a5 at time T through fallback-mode, then every honest party outputs m\u22c6 by time T +\u2206.\n\u2013 Asynchronous Network: \u2013 (a) Za-Liveness: At time TBC, each honest party has an output. \u2013 (b) Za-Weak Validity: If Sen is honest, then at time TBC, each honest\nparty outputs m or \u22a5. \u2013 (c) Za-Fallback Validity: If Sen is honest, then each honest party with\noutput \u22a5 at time TBC, eventually outputs m through fallback-mode. \u2013 (d) Za-Weak Consistency: If Sen is corrupt, then there exists some\nm\u22c6 6= \u22a5, such that at time TBC, each honest party outputs either m\u22c6 or \u22a5.\n\u2013 (e) Za-Fallback Consistency: If Sen is corrupt, and some honest party outputs m\u22c6 6= \u22a5 at time T where T \u2265 TBC, then each honest party eventually outputs m\u22c6.\nProof. The Zs-liveness and Za-liveness properties follow from the fact that every honest party outputs something (including \u22a5) at (local) time TBC, irrespective of the type of the network. We next prove the rest of the properties of the protocol in the synchronous network.\nProperties in the Synchronous Network. If Sen is honest, then due to the Zs-liveness and Zs-validity properties of \u03a0Acast in the synchronous network (see Lemma 3.2), all honest parties receive m from the Acast of Sen at time 3\u2206. Consequently, all honest parties participate with input m in the instance of \u03a0PW. The Zs-guaranteed liveness and Zs-validity properties of \u03a0PW in the synchronous network (see Lemma 3.1) guarantees that at time 3\u2206 + TPW, all honest parties will have m as the output from the instance of \u03a0PW. As a result, all honest parties output m at time TBC, thus proving the Zs-validity property.\nTo prove the Zs-consistency property, we consider a corrupt Sen. From the Zs-consistency property of\u03a0PW in the synchronous network (see Lemma 3.1), all honest parties will have the same output from the instance of \u03a0PW at time TBC. If all honest parties have the output \u22a5 for \u03a0BC at time TBC, then Zs-consistency holds trivially. So, consider the case when some honest party, say Pi, has the output m\u22c6 6= \u22a5 for \u03a0BC at time TBC. This implies that all honest parties have the output m\u22c6 from the instance of \u03a0PW. Moreover, at time 3\u2206, at least one honest party, say Ph, has received m\n\u22c6 from the Acast of Sen. If the latter does not hold, then all honest parties would have participated with input \u22a5 in the instance of \u03a0PW, and from the Zs-validity of \u03a0PW in the synchronous network (see Lemma 3.1), all honest parties would compute \u22a5 as the output during the instance of \u03a0PW, which is a contradiction. Since Ph has received m\n\u22c6 from Sen\u2019s Acast at time 3\u2206, it follows from the Zs-consistency property of \u03a0Acast in the synchronous network (see Lemma 3.2) that all honest parties will receive m\u22c6\nfrom Sen\u2019s Acast by time 4\u2206. Moreover, 4\u2206 < 3\u2206 + TPW holds. Consequently, at time 3\u2206 + TBC, all honest parties will have m\n\u22c6 from Sen\u2019s Acast and as the output of \u03a0PW, implying that all honest parties output m \u22c6 for \u03a0BC.\nWe next prove the Zs-fallback consistency property for which we again consider a corrupt Sen. Let Ph be an honest party who outputs m\n\u22c6 6= \u22a5 at time T through fallback-mode. Note that T > TBC, as the output during the fallbackmode is computed only after time TBC. We also note that each honest party has output \u22a5 at time TBC. This is because, from the proof of the Zs-consistency property of \u03a0BC (see above), if any honest party has an output m\n\u2032 6= \u22a5 at time TBC, then all honest parties (including Ph) must have computed the output m \u2032 at time TBC. Hence, Ph will never change its output to m \u22c6.17 Now since Ph has obtained the output m\u22c6, it implies that at time T , it has received m\u22c6 from the Acast of Sen. It then follows from the Zs-consistency of \u03a0Acast in the synchronous network that every honest party will also receive m\u22c6 from the Acast of Sen, latest by time T +\u2206 and output m\u22c6. This completes the proof of all the properties in the synchronous network.\nProperties in the Asynchronous Network. The Za-weak validity property follows from the Za-validity property of \u03a0Acast in the asynchronous network (see Lemma 3.2), which ensures that no honest party ever receives an m\u2032 from the Acast of Sen, where m\u2032 6= m. So, if at all any honest party outputs a value different from \u22a5 at time TBC, it has to bem. The Za-weak consistency property follows using similar arguments as used to prove Zs-consistency in the synchronous network; however we now rely on the Za-validity and Za-consistency properties of \u03a0Acast in the asynchronous network (see Lemma 3.2). The latter property ensures that for a corrupt Sen, two different honest parties never end up receiving m1 and m2 from the Acast of Sen, where m1 6= m2.\nFor the Zs-fallback validity property, consider an honest Sen, and let Pi be an arbitrary honest party who outputs \u22a5 at (local) time TBC. Since the parties keep"
        },
        {
            "heading": "17 Recall that in the protocol \u03a0BC, the parties who obtain an output different from \u22a5",
            "text": "at time TBC, never change their output.\non participating in the protocol beyond time TBC, it follows from the Za-liveness and Za-validity properties of \u03a0Acast in the asynchronous network (see Lemma 3.2) that party Pi will eventually receive m from the Acast of Sen, by executing the steps of the fallback-mode of\u03a0BC. Consequently, party Pi eventually changes its output from \u22a5 to m.\nFor the Za-fallback consistency property, we consider a corrupt Sen. Let Pj be an honest party who outputs somem\u22c6 different from\u22a5 at time T , where T \u2265 TBC. This implies that Pj has obtained m\n\u22c6 from the Acast of Sen. Now, consider an arbitrary honest Pi. From the Za-liveness and Za-weak consistency properties of \u03a0BC in asynchronous network proved above, it follows that Pi outputs either m\u22c6 or \u22a5 at local time TBC. If Pi has output \u22a5, then from the Za-consistency property of \u03a0Acast in the asynchronous network (see Lemma 3.2), it follows that Pi will also eventually obtain m\n\u22c6 from the Acast of Sen, by executing the steps of the fallback-mode of \u03a0BC. Consequently, party Pi eventually changes its output from \u22a5 to m\u22c6.\nThe communication complexity (both in the synchronous as well as asynchronous network) follows from the communication complexity of \u03a0PW and \u03a0Acast.\nA.4 Properties of the Protocol \u03a0SBA\nIn this section, we prove the properties of the protocol \u03a0SBA (see Fig 4 for the formal description).\nTheorem 3.3. Protocol \u03a0SBA achieves the following where TSBA = TBC, incurring a communication of O(n5 \u00b7 |\u03c3|) bits. \u2013 Synchronous Network: the protocol is a Zs-secure SBA protocol where honest\nparties have an output, different from \u22a5, at time TSBA. \u2013 Asynchronous Network: the protocol achieves Za-guaranteed liveness and Za-\nweak validity, such that all honest parties have an output at (local) time TSBA.\nProof. The communication complexity simply follows from the fact that n instances of \u03a0BC are invoked in the protocol. The guaranteed liveness, both in the synchronous and asynchronous network trivially follows from the Zs-liveness and Za-liveness of \u03a0BC (see Theorem 3.2), which ensures that all the n instances of \u03a0BC produce some output within (local) time TBC, both in a synchronous as well as an asynchronous network, through regular mode. Hence, at local time TSBA = TBC, all honest parties will have some output. We next prove the rest of the properties in a synchronous network.\nProperties in the Synchronous Network. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P\\Z\u22c6 be the set of honest parties. In a synchronous network, the instances of \u03a0BC corresponding to the senders in H, result in an output different from \u22a5 for all honest parties (follows from the Zs-validity property of \u03a0BC in the synchronous network, Theorem 3.2). Hence H \u2286 SV will hold.\nMoreover, from the Zs-consistency property of \u03a0BC in the synchronous network (Theorem 3.2), all the parties inH obtain a common output from the ith instance of \u03a0BC, for i = 1, . . . , n, at time TBC. Hence, all honest parties output the same value, different from \u22a5, at time TBC, proving the Zs-consistency of\u03a0SBA. Finally, if all parties in H have the same input bit b, then only the instances of \u03a0BC corresponding to the parties in SV \\H may output b\u0304 = 1\u2212 b. However, SV \\H \u2208 Zs. Moreover, SV \\ Z\u22c6 6\u2208 Zs (since Zs satisfies the Q(2)(P ,Zs) condition). It then follows that all honest parties output b, proving Zs-validity of \u03a0SBA.\nProperties in the Asynchronous Network. Let Z\u22c6 \u2208 Za be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. Suppose all the parties in H have the same input bit b. Let Pi \u2208 H be an arbitrary party, that obtains an output c, different from \u22a5, at time TBC. This implies that there exists a subset of parties SV for Pi, where P \\ SV \u2208 Zs, such that Pi has obtained a Boolean output b (j) i from the \u03a0BC instances, corresponding to every Pj \u2208 SV . Moreover, there also exists a subset of parties SV i \u2286 SV , where SV \\ SV i \u2208 Zs, such that the output b (j) i = c, corresponding to every Pj \u2208 SV i. Now since the Q(2,1)(P ,Zs,Za) condition is satisfied, it follows that Za satisfies the Q(1)(SV i,Za) condition and hence SV i \u2229H 6= \u2205. Consequently, c = b holds. This proves the Za-weak validity in the asynchronous network.\nA.5 Protocol \u03a0GA: Asynchronous Graded Agreement with Synchronous Validity\nTo design protocol\u03a0GA, we first design a sub-protocol\u03a0Prop for proposing values.\nA.5.1 \u03a0Prop: A Network Agnostic Protocol for Proposing Values\nProtocol \u03a0Prop takes an input value from each party from the set {0, 1, \u03bb} and outputs a set prop of proposed values for each party. Liveness is ensured in an asynchronous network as long as each honest party holds one of two inputs. In an asynchronous network, it will be ensured that each value in the output prop must be the input of some honest party. Moreover, if any two honest parties output a singleton set for prop, then they must output the same set. In a synchronous network, validity and liveness are ensured as long as each honest party participates with the same input. Protocol \u03a0Prop is presented in figure 16.\n1. Set vals = prop = \u2205. 2. On having the input v \u2208 {0, 1, \u03bb}, send (prepare, v) to every party Pj \u2208 P . 3. On receiving (prepare, b) for some b \u2208 {0, 1, \u03bb} from a set of parties S(b) satisfying\nQ1(S(b),Zs) condition, send (prepare, b) to all Pj \u2208 P , if not sent earlier. 4. Upon receiving the message (prepare, b) for some b \u2208 {0, 1, \u03bb} from parties in set\nPrepareSet(b) = P \\ Z for some Z \u2208 Zs, set vals = vals \u222a {b}. 5. Upon adding the first value b to vals, send (propose, b) to every party Pj \u2208 P .\nProtocol \u03a0Prop(P ,Zs,Za)\nThe guarantees provided by \u03a0Prop are proven in a series of lemmas below. In the below proofs, we assume that Z\u22c6 is the set of corrupt parties.\nLemma A.5. Suppose that the network is asynchronous. If two honest parties Pi and Pj output {b} and {b\u2032} respectively, then b = b\u2032.\nProof. Since Pi outputs {b}, it must have received (propose, b) from a set of parties ProposeSet = P\\Z for some Z \u2208 Zs. Similarly, since Pj outputs {b\u2032}, itmust have received (propose, b\u2032) from a set of parties ProposeSet\u2032 = P\\Z \u2032 for some Z \u2032 \u2208 Zs. Let ProposeSetH and ProposeSetH be the set of honest parties in ProposeSet and ProposeSet\u2032 respectively. Since Zs,Za satisfy the Q(2,1)(P ,Zs,Za) condition and Z\u22c6 \u2208 Za, it follows that ProposeSetH \u2229 ProposeSet \u2032 H 6= \u2205. Let Ph \u2208 ProposeSetH \u2229 ProposeSet \u2032 H. If b 6= b\n\u2032, this would mean that Ph has sent both (propose, b) and (propose, b\u2032), which is a contradiction, since an honest party sends at most one propose message as per the protocol.\nLemma A.6. Suppose that the network is asynchronous. If no honest party has input v, then no honest party outputs prop containing v.\nProof. If v was not input by any honest party, then no honest party sends (prepare, v) in step 2. Hence, no honest party receives (prepare, v) from a set of parties S(v) which satisfies the Q1(S(v),Zs) condition during step 3, since such a set must contain at least one honest party. Consequently, no honest party sends (propose, v). Thus, no honest party adds v to vals and no honest party outputs prop containing v.\nThe following lemmas help prove liveness.\nLemma A.7. Suppose that the network is asynchronous. If all honest parties hold one of two inputs, say v0 and v1, then all honest parties eventually compute an output.\nProof. We first show that every honest party eventually sends a proposemessage. Let H0 and H1 be the sets of honest parties holding inputs v0 and v1 respectively and let H be the set of honest parties. We know that due to the Q(2,1)(P ,Zs,Za) condition, Zs satisfies the Q(2)(H,Zs) condition. Now, consider the following cases.\n\u2013 Case 1 - H0 satisfies the Q1(H0,Zs) condition: In this case, H0 is a candidate for the set S(v0), since all the parties in H0 send (prepare, v0) in step 2.\n\u2013 Case 2 - H0 does not satisfy the Q1(H0,Zs) condition: In this case, Zs must satisfy the Q1(H1,Zs) condition, since Zs satisfies the Q(2)(H,Zs) condition. Then similar to what was argued in the previous case, H1 is a candidate for the set S(v1). Let vb be the input corresponding to the candidate set S (vb). Every honest party will now eventually send (prepare, vb) in step 3. This would mean that the set of honest parties H = P \\ Z\u22c6 is a candidate for the set PrepareSet(vb). Thus, every honest party eventually adds vb to vals and sends a propose message for some value vb. This way, every honest party eventually receives propose messages from every other honest party for vb and thus, the set H also forms a candidate for the set ProposeSet. Thus, all honest parties eventually compute an output.\nLemma A.8. If the network is synchronous and if all honest parties participate with input v, then all honest parties output prop = {v} at time 2\u2206.\nProof. Let H = P \\ Z\u22c6 be the set of honest parties. Then in step 2, every party in H sends (prepare, v) to every party, which is delivered within \u2206 time. Thus, at time \u2206, all the parties in H receive (prepare, v) from the parties in H and add v to vals. Further, no other value v\u22c6 will be added to vals, since only the parties in Z\u22c6 may send a prepare message for v\u22c6 and Zs does not satisfy the Q(1)(Z\u22c6,Zs) condition. Thus, all the parties in H send (propose, v) in step 5, which gets delivered to all the parties in H at time 2\u2206. Consequently, all the parties in H output prop = {v}.\nLemma A.9. Protocol \u03a0Prop incurs a communication of O(n2) bits.\nProof. The proof follows from the fact that each party sends (prepare, b) to every other party at most once for any value of b \u2208 {0, 1, \u03bb}.\nA.5.2 The Graded Agreement Protocol\nWe now present protocol \u03a0GA (Figure 17) based on protocol \u03a0Prop. The protocol cleverly \u201cstitches\u201d together two instances of \u03a0Prop, by defining the input for the second instance based on the output from the first instance. Each party, with input either 0 or 1, participates in the first instance of \u03a0Prop with their input. Since the parties participate with one of two inputs, this instance will eventually complete (in an asynchronous network), and the parties obtain an output, say prop1. Only if prop1 is a singleton set, say {b}, for some party, then that party participates in the second instance of \u03a0Prop with the input b. Otherwise, it participates in the second instance with a default input of \u03bb. Since no two honest parties can output different singleton sets for prop1, this ensures that each honest party participates with an input of either b or \u03bb (in an asynchronous network). Thus, the second instance of \u03a0Prop also eventually completed with an output, say prop2. This also ensures that prop2 can contain only values b and \u03bb. If prop2 contains only b for some honest party, then that party outputs b with a grade of 2. If prop2 contains b along with \u03bb, then the party outputs b with a grade of 1. Else, if prop2 contains only \u03bb, then the party\noutputs \u22a5 with a grade of 0. If the network is synchronous and all honest parties start the protocol with the same input, then both prop1 as well as prop2 will be a singleton set containing that value and hence all honest parties will output that value with the highest grade.\nWe now proceed to prove the properties of the protocol \u03a0GA.\nLemma A.10. Protocol \u03a0GA achieves the following in a synchronous network, where TGA = 4\u2206. \u2013 (a) Zs-Liveness: If all honest parties participate in the protocol with the\nsame input, then at time TGA, all honest parties obtain an output. \u2013 (b) Zs-Graded Validity: If every honest party\u2019s input is b, then all honest\nparties with an output, output (b, 2).\nProof. If all honest parties participate in the protocol \u03a0GA with the same input b, then from Lemma A.8, all honest parties output prop1 = {b} at time 2\u2206. Thus, all honest parties participate with input b2 = b in the second instance of \u03a0GA and, once again from Lemma A.8, output prop2 = {b} at time 4\u2206. Thus, all honest parties output (b, 2).\nLemma A.11. Protocol \u03a0GA achieves the following in an asynchronous network. \u2013 (a) Za-Liveness: If all honest parties participate in the protocol with a binary\ninput, then each honest party eventually obtains an output. \u2013 (b) Za-Graded Validity: If every honest party\u2019s input is b, then all honest\nparties with an output, output (b, 2). \u2013 (c) Za-Graded Consistency: If two honest parties output grades g, g\u2032, then\n|g \u2212 g\u2032| \u2264 1 holds; moreover, if two honest parties output (v, g) and (v\u2032, g\u2032) with g, g\u2032 \u2265 1, then v = v\u2032.\nProof. Since each honest party participates with a binary input, from Lemma A.7, each party eventually outputs some value for prop1 during the first instance of prop. Now there are two possible cases. \u2013 Case 1 - Some honest party outputs {b} as its value for prop1 where\nb \u2208 {0, 1}: From Lemma A.5, no honest party can output {b\u2032}, where b 6= b\u2032,\nas prop1. Thus, each honest party participates with input either b or \u03bb for the second instance of prop.\n\u2013 Case 2 - No honest party outputs {b} as its value for prop1 for any b \u2208 {0, 1}: In this case, all honest parties participate with input \u03bb in the second instance of prop.\nIn either case, the honest parties participate in the second instance of \u03a0Prop with no more than two different inputs. Thus, from Lemma A.7, all parties eventually compute some value for prop2 during the second instance of prop and hence compute some output for protocol \u03a0GA. This proves the Za-Liveness.\nWe next prove the Za-Graded Consistency. We first show that the grades output by any two parties differ by at most 1. For this, suppose that some honest party Pi outputs (b, 2). We show that no other honest party Pj can output (\u22a5, 0). Since Pi output (b, 2), from Lemma A.5, Pj cannot output prop2 = {\u03bb}. Thus, Pj cannot output (\u22a5, 0). Next, we show that any two honest parties which output non-zero grades must output the same value. Similar to what was argued for the proof of Za-Liveness, there exists a bit b such that each honest party participates in \u03a0Prop with input b or \u03bb during step 2. Thus, prop2 \u2286 {b, \u03bb} for every honest party. This means that any honest party which outputs a non-zero grade must output it along with the bit b.\nWe finally prove the Za-Graded Validity. Suppose that each honest party participates with the same input bit b. From Lemma A.7, we know that all honest parties output some value for prop1. From Lemma A.6, all honest parties must output prop1 = {b}. Hence, all honest parties participate in \u03a0Prop in step 2 with input b. By the same argument, all honest parties output prop2 = {b}. Hence, all honest parties output (b, 2).\nLemma A.12. Protocol \u03a0GA incurs a communication of O(n2) bits.\nProof. The proof follows from Lemma A.9, since \u03a0Prop is invoked twice in the protocol.\nA.6 Properties of the Protocol \u03a0ABA\nIn this section, we prove the properties of the protocol \u03a0ABA (see Fig 5 for the protocol steps). We start with the properties in the asynchronous network first, which mostly follows from [23] and are recalled from [23]. We start with the validity property.\nLemma A.13. In protocol \u03a0ABA, if the network is asynchronous and all honest parties have the same input bit b, then all honest parties eventually output b.\nProof. Let Z\u22c6 \u2208 Za be the set of corrupt parties. If every honest party has the same input bit b, then from the Za-Graded Validity of \u03a0GA in the asynchronous network (Lemma A.11), all honest parties eventually output (b, 2) at the end of the first as well as the second instance of the \u03a0GA protocol during the first iteration. Consequently, every honest party eventually sends a signed (ready, b) message to all the parties and only the parties in Z\u22c6 may send a signed (ready, b)\nmessage. It now follows easily from the steps of the output computation stage that no honest party ever sends a signed (ready, b) message and all hence honest parties eventually output b.\nWe next prove the consistency property.\nLemma A.14. In protocol \u03a0ABA, if the network is asynchronous and if any honest party outputs b, then every other honest party eventually outputs b.\nProof. Let Pi be the first honest party who sends a signed ready message for some bit b \u2208 {0, 1}, during some iteration, say iteration r. We show that no honest party ever sends a signed (ready, b) message during iteration r or in the subsequent iterations. Since Pi has sent a signed ready message for b, it implies that Pi outputs (b, 2) in the second instance of the \u03a0GA protocol during iteration r and sets committed to true. Then, from the Za-Graded Consistency of \u03a0GA in the asynchronous network (Lemma A.11), every other honest party outputs either (b, 2) or (b, 1) in the second instance of the \u03a0GA protocol during iteration r. Consequently, no other honest party sends the signed (ready, b) message during iteration r. Also, from the protocol steps, all honest parties update their input to b for the next iteration. This further implies that all honest parties will continue to input b to each subsequent invocation of \u03a0GA, ignoring the output of \u03a0CoinFlip, for as long as they continue running. Consequently, no honest party ever sends a signed (ready, b) message.\nNow let some honest party, say Ph, computes the output b during iteration k. This implies that Ph receives the signed (ready, b) message from a set of parties, say T , such that P \\ T \u2208 Zs. The set T is bound to have at least one honest party, due to the Q(2,1)(P ,Zs,Za) condition, implying that at least one honest party has sent a signed (ready, b) message, either during the iteration k or some previous iteration. From the protocol steps, Ph sends C(b), the set of signed (ready, b) messages of the parties in T to all other parties, which get eventually delivered. Moreover, as shown above, no honest party will ever send a signed (ready, b) message. Consequently, every honest party eventually receives sufficiently many numbers of signed (ready, b) messages and outputs b.\nWe next prove that at the end of each iteration, the updated value of all honest parties will be the same with the probability at least 12n .\nLemma A.15. In protocol \u03a0ABA, if the network is asynchronous and if all honest parties participate during iteration k, then with probability at least 12n , all honest parties have the same updated bit b at the end of iteration k.\nProof. To prove the lemma statement, we consider an event Agree, which denotes that all honest parties have the same input for the second instance of \u03a0GA during iteration k. If the event Agree occurs, then from the Za-Graded Validity of \u03a0GA in the asynchronous network (Lemma A.11), all honest parties will have the same updated bit at the end of iteration k. We show that the event Agree occurs during iteration k with a probability of at least 12n . For this, we consider two different possible cases with respect to the output from the first instance of \u03a0GA during iteration k.\n\u2013 Case I: No honest party obtains an output (b, 2) for any b \u2208 {0, 1} during the first instance of \u03a0GA. In this case, all honest parties set the output from the instance of \u03a0CoinFlip during iteration k as the input for the second instance of \u03a0GA. From the (Za, p)-commonness of \u03a0CoinFlip in asynchronous network [23], all honest parties will have the same output bit Coink from the instance of \u03a0CoinFlip with a probability of at least p = 1 n > 12n . \u2013 Case II: Some honest party obtains an output (b, 2) during the first instance of \u03a0GA. In this case, the Za-Graded Consistency of \u03a0GA in the asynchronous network (Lemma A.11) ensure that all honest parties obtain the output (b, 2) or (b, 1) from the first instance of \u03a0GA. Moreover, from the protocol steps, the output of the instance of \u03a0CoinFlip during iteration k is not revealed, until the first honest party generates an output from the first instance of \u03a0GA during iteration k. Consequently, the output bit b from the first instance of \u03a0GA is independent of the output of \u03a0CoinFlip. From the (Za, p)-commonness of \u03a0CoinFlip in asynchronous network [23], all honest parties will have the same output bit Coink from the instance of \u03a0CoinFlip with a probability of at least p = 1\nn . Then the probability that Coink = b\nholds is at least 12 \u00b7 1 n = 12n and with this probability, all honest parties will have the same input for the second instance of \u03a0GA.\nWe next derive the expected number of iterations required in the protocol \u03a0ABA for the honest parties to produce an output. This automatically gives the expected running time in an asynchronous network, since each iteration takes a constant time.\nLemma A.16. If the network is asynchronous, then in protocol \u03a0ABA, it requires expected O(n2) iterations for the honest parties to compute an output.\nProof. To prove the lemma, we need to derive the expected number of iterations, until all the honest parties have the same input during the second instance of \u03a0GA of an iteration. This is because once all the honest parties have the same input during the second instance of \u03a0GA of an iteration, then all honest parties will set committed to true at the end of that iteration and start sending signed ready messages, followed by computing an output. Let \u03c4 be the random variable which counts the number of iterations until all honest parties have the same input during the second instance of \u03a0GA in an iteration. Then the probability that \u03c4 = k is given as:\nPr(\u03c4 = k) = Pr(\u03c4 6= 1) \u00b7 Pr(\u03c4 6= 2 | \u03c4 6= 1) \u00b7 . . . \u00b7 Pr(\u03c4 6= (k \u2212 1) | \u03c4 6= 1 \u2229 . . .\u2229\n\u03c4 6= (k \u2212 2)) \u00b7 Pr(\u03c4 = k | \u03c4 6= 1 \u2229 . . . \u2229 \u03c4 6= (k \u2212 1)).\nFrom Lemma A.15, every multiplicand on the right-hand side in the above equation, except the last one, is upper bounded by (1\u2212 12n ) and the last multiplicand is upper bounded by 12n . Hence, we get\nPr(\u03c4 = k) \u2264 (1 \u2212 1\n2n )k\u22121(\n1\n2n ).\nNow the expected value E(\u03c4) of \u03c4 is computed as follows:\nE(\u03c4) =\n\u221e \u2211\nk=0\n\u03c4 \u00b7 Pr(\u03c4 = k)\n\u2264 \u221e \u2211\nk=0\nk(1\u2212 1\n2n )k\u22121(\n1\n2n )\n= 1\n2n\n\u221e \u2211\nk=0\nk(1\u2212 1\n2n )k\u22121\n= 1\n1\u2212 (1\u2212 12n ) +\n1\u2212 12n (\n1\u2212 (1\u2212 12n ) )2\n= 2n+ 4n2 \u2212 2n = 4n2\nThe expression for E(\u03c4) is a sum of AGP up to infinite terms, which is given by a 1\u2212r + dr (1\u2212r)2 , where a = 1, r = 1\u2212 1 2n and d = 1. Hence, we have E(\u03c4) \u2264 4n 2.\nWe finally prove the properties of the protocol \u03a0ABA in a synchronous network.\nLemma A.17. If the network is synchronous and if all honest parties have the same input b \u2208 {0, 1} during \u03a0ABA, then all honest parties output b, at time TABA = TCoinFlip + 2TGA +\u2206.\nProof. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. If all the parties in H participate with input b, then from the Zs-liveness and Zs-Graded Validity of \u03a0GA in the synchronous network (Lemma A.10), all the parties in H output (b, 2) during the first instance of \u03a0GA at time TGA in the first iteration. The Zs-Guaranteed Liveness of\u03a0GA in the synchronous network [23] ensures that all honest parties compute some output from the instance of \u03a0CoinFlip during the first iteration at the time TGA + TCoinFlip. Since the parties in H output (b, 2) during the first instance of \u03a0GA, they participate with input b during the second instance of \u03a0GA. Consequently, from the Zs-liveness and Zs-Graded Validity of \u03a0GA in the synchronous network, all the parties in H compute the output (b, 2) during the second instance of \u03a0GA in the first iteration at the time 2TGA + TCoinFlip. Hence every party in H sends a signed ready message for b at the time 2TGA+TCoinFlip, which gets delivered at the time TABA. Moreover, only the parties in Z\u22c6 may send a signed ready message for b. Since P \\H = Z\u22c6 \u2208 Zs and since H 6\u2208 Zs (due to the Q(2)(P ,Zs) condition), it follows that all the parties in H will have sufficiently many signed ready messages for b at the time TABA to output b.\nThe proof of Theorem 3.4 now follows from Lemma A.13-A.17. The communication complexity follows from the communication complexity of \u03a0CoinFlip [23] and the communication complexity of \u03a0GA (Lemma A.12) and the fact that in a synchronous network, only a constant number of invocations of\u03a0GA and \u03a0CoinFlip are involved, while in an asynchronous network, there are poly(n) invocations of \u03a0GA and \u03a0CoinFlip in expectation."
        },
        {
            "heading": "B Properties of Our Network Agnostic ICP",
            "text": "In this section, we prove the properties of our network-agnostic ICP (see Fig 6 for the formal details). Throughout this section, we assume that Zs and Za satisfy the conditions Za \u2282 Zs, Q(2)(P ,Zs), Q(3)(P ,Za) and Q(2,1)(P ,Zs,Za).\nLemma B.1. If S, I and R are honest, then the following hold during protocol \u03a0Auth and \u03a0Reveal. \u2013 Zs-Correctness: In a synchronous network, each honest party sets\nauthCompleted(S,I,R) to 1 during \u03a0Auth at time TAuth = \u2206 + 4TBC. Moreover R outputs s during \u03a0Reveal which takes TReveal = \u2206 time. \u2013 Za-Correctness: In an asynchronous network, each honest party eventually sets authCompleted(S,I,R) to 1 during \u03a0Auth and R eventually outputs s during \u03a0Reveal.\nProof. We first start with the synchronous network. Let Z\u22c6 \u2208 Zs be set of corrupt parties and let H = P \\Z\u22c6 be the set of honest parties. During \u03a0Auth, S chooses a random t-degree signing-polynomial F (x) such that s = F (0) holds, a random t-degree masking-polynomialM(x), and computes verification points (\u03b1i, vi,mi) such that vi = F (\u03b1i) and mi = M(\u03b1i) hold. S then sends the signing-polynomial F (x) and masking-polynomial M(x) to I, and the corresponding verificationpoint (\u03b1i, vi,mi) to each verifier Pi. Consequently, each verifier in H receives its verification-point by time \u2206, and indicates this by broadcasting (Received, i). Since P \\H = Z\u22c6 \u2208 Zs, from the Zs-validity of \u03a0BC in the synchronous network (see Theorem 3.2), it follows that at time \u2206 + TBC, S will find a set SV , such that P \\SV \u2208 Zs, where each verifier in SV has indicated that it has received its verification-point. Consequently, S will broadcast SV at time \u2206+TBC. From the Zs-validity of\u03a0BC in the synchronous network, I will receive SV at time\u2206+2TBC. Moreover, due to the Zs-Consistency and Zs-Validity of \u03a0BC in the synchronous network, party I would have gotten (Received, i), corresponding to every verifier Pi \u2208 SV , by time \u2206+ 2TBC. Furthermore, P \\ SV \u2208 Zs will hold. Hence, I will randomly select d \u2208 F, compute B(x) = dF (x)+M(x), and broadcast (d,B(x)). From the Zs-validity of \u03a0BC in the synchronous network, this will be delivered to every honest party, including S, by time \u2206 + 3TBC. Moreover, S will find that B(\u03b1j) = dvj +mj holds for all the verifiers Pj \u2208 SV . Consequently, S will broadcast an OK message, which is received by every Pi \u2208 H at time \u2206+ 4TBC, due to the Zs-validity of \u03a0BC in the synchronous network. Thus, each Pi \u2208 H sets authCompleted(S,I,R) to 1, while I additionally sets ICSig(S, I,R, s) to F (x) at time \u2206+ 4TBC.\nDuring \u03a0Reveal, I will send F (x) to R, and each verifier Pi \u2208 H \u2229 SV will send its verification point (\u03b1i, vi,mi) to R. These points and the polynomial F (x) are received by R within \u2206 time. Moreover, the condition vi = F (\u03b1i) will hold true for these points, and consequently, these points will be accepted. Since SV \\ (H\u2229SV) \u2286 Z\u22c6 \u2208 Zs, it follows that at time \u2206, receiver R will find a subset SV \u2032 \u2286 SV where SV \\ SV \u2032 \u2208 Zs, such that the points corresponding to all the parties in SV \u2032 are accepted. This implies that R will output s = F (0) within time \u2206.\nThe proof for the asynchronous case is similar as above, except that each \u201cfavourable\u201d event occurs eventually, and follows from the fact that every set in Za is a subset of some set in Zs. Moreover, we rely on the properties of \u03a0BC in the asynchronous network.\nWe next prove the privacy property, for which we again need to consider an honest S, I and R.\nLemma B.2. If S, I and R are honest, then the view of Adv remains independent of s during \u03a0Auth and \u03a0Reveal, irrespective of the network type.\nProof. We prove privacy in a synchronous network. The privacy in an asynchronous network automatically follows, since Za is a subset of Zs. Let t = max{|Z| : Z \u2208 Zs} and let Z\u22c6 \u2208 Zs be the set of corrupt parties. For simplicity and without loss of generality, let |Z\u22c6| = t. During \u03a0Auth, the adversary Adv learns t verification-points {(\u03b1i, vi,mi)}Pi\u2208Z\u22c6 . However, since F (x) is a random t-degree polynomial with F (0) = s, the points {(\u03b1i, vi)}Pi\u2208Z\u22c6 are distributed independently of s. That is, for every candidate s \u2208 F from the point of view of Adv, there is a corresponding unique t-degree polynomial F (x), such that F (\u03b1i) = vi holds corresponding to every Pi \u2208 Z\u22c6.\nDuring \u03a0Auth, the adversary Adv also learns d and the blinded-polynomial B(x) = dF (x) +M(x). However, this does not add any new information about s to the view of the adversary. This is because M(x) is a random t-degree polynomial and Adv learns t points on M(x), corresponding to the parties in Z\u22c6. Hence, for every candidateM(x) polynomial from the point of view of Adv where M(\u03b1i) = mi holds for every Pi \u2208 Z\u22c6, there is a corresponding unique t-degree polynomial F (x), such that F (\u03b1i) = vi holds corresponding to every Pi \u2208 Z\n\u22c6, and where dF (x) + M(x) = B(x). Finally, Adv does not learn anything new about s during \u03a0Reveal, since the verification-points and the signing-polynomial are sent only to R, who is honest as per the lemma conditions.\nWe next prove the unforgeability property, for which we have to consider a corrupt I.\nLemma B.3. If S,R are honest, I is corrupt and if R outputs s\u2032 \u2208 F during\n\u03a0Reveal, then s \u2032 = s holds except with probability at most \u01ebICP def = nt|F|\u22121 , where t = max{|Z| : Z \u2208 Zs}, irrespective of the network type.\nProof. Let H be the set of honest parties in P and let Z\u22c6 = P \\H be the set of corrupt parties. Since R outputs s\u2032 during \u03a0Reveal, it implies that during \u03a0Auth, the variable authCompleted(S,I,R) is set to 1 by R. This further implies that S has broadcasted an OK message during \u03a0Auth, which also implies that during \u03a0Auth, I had broadcasted a t-degree blinded-polynomial B(x), and S broadcasted the set SV . Furthermore, S has verified that B(\u03b1i) = dvi +mi holds for every verifier Pi \u2208 SV . Now during \u03a0Reveal, if I sends F (x) as ICSig(S, I,R, s) to R, then s\u2032 = s holds with probability 1. So, consider the case when I sends F \u2032(x) as ICSig(S, I,R, s) to R, where F \u2032(x) is a t-degree polynomial such that F \u2032(x) 6= F (x)\nand where F \u2032(0) = s\u2032. In this case, we claim that except with probability at most nt |F|\u22121 , the verification-point of no honest verifier from SV will get accepted by R during \u03a0Reveal, with respect to F \u2032(x). Now, assuming that the claim is true, the proof follows using the following arguments, depending upon the network type. \u2013 Synchronous Network: In this case, all the verifiers in H will be present in\nSV . This is because, each verifier Pi \u2208 H would have received its verificationpoint from S during \u03a0Auth, within time \u2206 and indicates this by broadcasting (Received, i), which is received by S at time \u2206 + TBC. Let SV\n\u2032 be the set of verifiers from which R receives verification points which it accepts. Since the verification point of none of the honest verifier will be accepted. Hence (H \u2229 SV \u2032) = \u2205 and so H \u2286 SV \\ SV \u2032 must hold. Since H satisfies the Q1(P ,Zs) condition, SV \\ SV\n\u2032 \u2208 Zs will never hold true. Hence, R will not output s\u2032 6= s.\n\u2013 Asynchronous Network: In this case, we first note that Zs and Za satisfy the Q(1,1)(SV ,Zs,Za) condition. This is because P \\ SV \u2208 Zs and Zs and Za satisfy the Q(2,1)(P ,Zs,Za) condition. From the steps of \u03a0Reveal, it follow that for R to output F \u2032(0), R should find a subset of verifiers SV \u2032 \u2286 SV , where SV \\ SV \u2032 \u2208 Zs, such that the verification-points of all the verifiers in SV \u2032 are accepted by R. This further implies that SV \u2032\u2229H 6= \u2205, as Za satisfies the Q(1)(SV \u2032,Za) condition. And hence SV\n\u2032 has at least one honest verifier, whose verification-point is accepted with respect to F \u2032(x). However, from the above claim, it is not possible and hence R will not output s\u2032 6= s.\nWe now prove the claimed statement. So consider an arbitrary verifier Pi \u2208 H \u2229 SV from whom R receives the verification-point (\u03b1i, vi,mi) during \u03a0Reveal. This point can be accepted with respect to F \u2032(x), only if either of the following holds. \u2022 vi = F \u2032(\u03b1i): This is possible with probability at most t\n|F|\u22121 . This is because\nF \u2032(x) and F (x), being distinct t-degree polynomials, can have at most t points in common. And the evaluation-point \u03b1i corresponding to Pi, being randomly selected from F\u2212 {0}, will not be known to I.\n\u2022 dvi +mi 6= B(\u03b1i): This is impossible, as otherwise S would have not broadcasted OK during \u03a0Auth, which is a contradiction. As there could be up to n \u2212 1 honest verifiers in SV , it follows from the union bound that except with probability at most nt|F|\u22121 , the verification-point of no honest verifier from SV will get accepted by R during \u03a0Reveal, with respect to F \u2032(x).\nWe next prove the non-repudiation property, for which we have to consider a corrupt S.\nLemma B.4. If S is corrupt, I,R are honest and if I sets ICSig(S, I,R, s) during \u03a0Auth, then the following hold, except with probability at most n |F|\u22121 .\n\u2013 Zs-Non-Repudiation: In a synchronous network, R outputs s during \u03a0Reveal, which takes TReveal = \u2206 time. \u2013 Za-Non-Repudiation: In an asynchronous network, R eventually outputs s during during \u03a0Reveal.\nProof. Let H be the set of honest parties in P and Z\u22c6 be the set of corrupt parties, where H = P \\Z\u22c6. Since I has set ICSig(S, I,R, s) during \u03a0Auth, it implies that I has set the variable authCompleted(S,I,R) to 1. This further implies that I has broadcasted (d,B(x)), where B(x) = dF (x) + M(x), and where F (x) and M(x) are the t-degree signing and masking-polynomials received by I from S. Moreover, I also received the set of supporting verifiers SV from the broadcast of S, and verified that P \\ SV \u2208 Zs holds. Furthermore, S has broadcasted an OK message. Consequently, from the consistency properties of \u03a0BC (see Theorem 3.2), irrespective of the network type, all honest parties including R eventually set authCompleted(S,I,R) to 1. Moreover, I sets ICSig(S, I,R, s) to F (x), where s = F (0). During \u03a0Reveal, I sends F (x) to R. Moreover, every verifier Pi \u2208 H\u2229SV sends its verification-point (\u03b1i, vi,mi) to R. In a synchronous network, these will be received by R within time \u2206, while in an asynchronous network, these will be eventually received by R. We claim that except with probability at most n|F|\u22121 , all these verification-points are accepted by R. Now, assuming that the claim is true, the proof follows from the fact that H\u2229SV = SV \\Z\u22c6, and Z\u22c6 \u2208 Zs holds, irrespective of the network type (since Za \u2282 Zs). Consequently, R accepts the verification-points from a subset of the verifiers SV \u2032 \u2286 SV where SV \\SV \u2032 \u2208 Zs. And hence it outputs s, either within time \u2206 in a synchronous network, or eventually, in an asynchronous network.\nWe now proceed to prove the claim. So consider an arbitrary verifier Pi \u2208 H\u2229SV whose verification-point (\u03b1i, vi,mi) is received by R during \u03a0Reveal. Now, there are two possible cases, depending upon the relationship that holds between F (\u03b1i) and vi during \u03a0Auth. \u2013 vi = F (\u03b1i) holds: In this case, according to the protocol steps of \u03a0Reveal, the\npoint (\u03b1i, vi,mi) is accepted by R. \u2013 vi 6= F (\u03b1i) holds: In this case, we claim that except with probability at most\n1 |F|\u22121 , the condition dvi + mi 6= B(\u03b1i) will hold, implying that the point (\u03b1i, vi,mi) is accepted by R. This is because the only way dvi +mi = B(\u03b1i) holds is when S distributes (\u03b1i, vi,mi) to Pi where vi 6= F (\u03b1i) and mi 6= M(\u03b1i) holds, and I selects d = (M(\u03b1i) \u2212 mi) \u00b7 (vi \u2212 F (\u03b1i))\u22121. However, S will not be knowing the random d from F\\{0} which I is going to pick, while distributing F (x),M(x) to I, and (\u03b1i, vi,mi) to Pi. Hence, the probability that I indeed selects d = (M(\u03b1i)\u2212mi) \u00b7 (vi \u2212 F (\u03b1i))\u22121 is 1 |F|\u22121 . As there can be up to n \u2212 1 honest verifiers in SV , from the union bound, it follows that except with probability at most n|F|\u22121 , the verification-point of all honest verifiers in SV are accepted by R.\nWe finally derive the communication complexity.\nLemma B.5. Protocol \u03a0Auth incurs a communication of O(n5 \u00b7 log |F| \u00b7 |\u03c3|) bits. Protocol \u03a0Reveal incurs a communication of O(n \u00b7 log |F|) bits.\nProof. During \u03a0Auth, signer S sends t-degree polynomials F (x) and M(x) to I, and verification-points to each verifier. This requires a communication of O(n \u00b7 log |F|) bits. Intermediary I needs to broadcast B(x) and d using protocol \u03a0BC,\nwhile S needs to broadcast the set SV using \u03a0BC. Moreover, S may need to broadcast s using \u03a0BC. By substituting the communication cost of \u03a0BC (see Theorem 3.2), the overall communication cost of \u03a0Auth turns out to be O(n\n5 \u00b7 log |F| \u00b7 |\u03c3|) bits. During \u03a0Reveal, I may send F (x) to R, and each verifier may send its verification-point to R. This incurs a communication of O(n \u00b7 log |F|) bits.\nThe proof of Theorem 4.1 now follows easily from Lemma B.1-B.5."
        },
        {
            "heading": "C Properties of Network Agnostic VSS",
            "text": "In this section, we prove the properties of the protocol\u03a0VSS (see Fig 7). Throughout this section, we assume that Zs and Za satisfy the conditions Za \u2282 Zs, Q(2)(P ,Zs), Q(3)(P ,Za) and Q(2,1)(P ,Zs,Za). We start with the properties in a synchronous network and first consider an honest D. We first show that an honest D will broadcast some candidate core-sets, which will be accepted by all honest parties. Moreover, adversary will not learn any additional information about s.\nLemma C.1. If the network is synchronous and D is honest, participating in \u03a0VSS with input s, then all the following hold, where H is the set of honest parties. \u2013 There exists some Sp \u2208 SZs , such that D broadcasts a message\n(CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS) at time \u2206 + TAuth + TBC, and every Pi \u2208 H includes (D, Sp) to the set Ci at time \u2206+ TAuth + 2TBC. Moreover, all the following hold for q = 1, . . . , |Zs|. \u2013 If Sq = H, then q 6\u2208 BS. \u2013 Wq will be either Sq or (Sp\u2229Sq). Moreover, Zs will satisfy the Q(1)(Wq,Zs)\ncondition. \u2013 Corresponding to every Sq \u2208 SZs , every honest Pi \u2208 Wq will have the IC-\nsignature ICSig(Pj , Pi, Pk, sq) of every Pj \u2208 Wq for every Pk 6\u2208 Sq, such that the underlying signatures will satisfy the linearity principle. Furthermore, if any corrupt Pj \u2208 Wq has the IC-signature ICSig(Pi, Pj , Pk, s\u2032q) of any honest Pi \u2208 Wq for any Pk \u2208 P, then s\u2032q = sq holds and the underlying signatures will satisfy the linearity principle.\n\u2013 Corresponding to every Sq \u2208 SZs , every honest Pi \u2208 Sq will have the share sq, except with a probability O(|SZs | \u00b7n\n2 \u00b7\u01ebICP), at time \u2206+TAuth+2TBC+ TReveal, where s = s1 + . . .+ s|Zs|.\n\u2013 The view of the adversary will be independent of s.\nProof. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. We note that H \u2208 SZs . Since D is honest, it picks the shares s1, . . . , s|Zs| such that s = s1 + \u00b7 \u00b7 \u00b7 + s|Zs| and sends sq to each party Pi \u2208 Sq, corresponding to every Sq \u2208 SZs . These shares are delivered within time \u2206. Now consider an arbitrary Sq \u2208 SZs . At time \u2206, each party Pi \u2208 (Sq \u2229H) starts giving ICSig(Pi, Pj , Pk, sqi) to every Pj \u2208 Sq, for every Pk \u2208 P , where sqi = sq\nholds. Moreover, the linearity principle is followed while generating these ICsignatures. Then from the Zs-correctness of \u03a0Auth in the synchronous network (Theorem 4.1), it follows that at time \u2206 + TAuth, each party Pi \u2208 (Sq \u2229 H) will receive ICSig(Pj , Pi, Pk, sqj) from every Pj \u2208 (Sq\u2229H), for every Pk \u2208 P , such that sqj = sqi = sq holds. Since Sq is arbitrary, it follows that at time \u2206+TAuth, every party Pi \u2208 H broadcasts an OK(i, j) message, corresponding to every Pj \u2208 H. From the Zs-validity of\u03a0BC in the synchronous network (Theorem 3.2), it follows that these OK(i, j) messages are received by every party in H through regularmode at time \u2206 + TAuth + TBC. Consequently, the set H constitutes a clique in the consistency graph of every party in H at time \u2206 + TAuth + TBC. Now since the set H \u2208 SZs , it follows that at time \u2206+ TAuth + TBC, there exists some Sp \u2208 SZs , such that D computes the core-sets {Wq}q=1,...,|Zs| and broadcast-set BS, followed by broadcasting (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS) at time \u2206+TAuth+TBC. Moreover, since D is honest, it computes the sets {Wq}q=1,...,|Zs| and BS honestly, satisfying the following conditions, for q = 1, . . . , |Zs|.\n\u2013 If Sq constitutes a clique in the graph G (D), then Wq = Sq. \u2013 Else if (Sp \u2229 Sq) constitutes a clique in G(D) and Zs satisfies the Q(1)(Sp \u2229 Sq,Zs) condition, then Wq = (Sp \u2229 Sq). \u2013 Else Wq = Sq and q \u2208 BS.\nNote that for each Wq, the condition Q(1)(Wq,Zs) holds. This is obviously true if Wq = (Sp\u2229Sq), since in this case D also checks that Q(1)(Sp\u2229Sq,Zs) condition holds. On the other hand, even if Wq = Sq, the condition Q(1)(Wq,Zs) holds, as Q(1)(Sq,Zs) holds due to the Q(2)(P ,Zs) condition. We also note that if Sq = H, then q /\u2208 BS and consequently, D does not make public the share sq. This is because as shown above, at time \u2206 + TAuth + TBC, the parties in Sq constitute a clique in the graph G(D).\nSince D broadcasts (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS) at time \u2206+ TAuth + TBC, from the Zs-validity of \u03a0BC in the synchronous network, it follows that all the parties inH will receive (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS) from the broadcast of D, at time \u2206+TAuth+2TBC. To show that every Pi \u2208 H will include (D, Sp) to the set Ci, we need to show that all the conditions which hold for D in its graphG(D) at time\u2206+TAuth+TBC, are bound to hold for every Pi \u2208 H, at the time \u2206+TAuth+2TBC. Namely, all the edges which are present in G\n(D) at time \u2206+ TAuth + TBC, are bound to be present in the graph G\n(i) every Pi \u2208 H, at the time \u2206+TAuth+2TBC. However, this simply follows from the Zs-validity, Zs-consistency and Zs-fallback consistency of \u03a0BC in the synchronous network (see Theorem 3.2) and the fact that edges are added to consistency graphs, based on the receipt of OK(\u22c6, \u22c6) messages, which are broadcasted through various \u03a0BC instances. Consequently, any edge (i, j) which is included in G(D) at the time \u2206 + TAuth + TBC, is bound to be included in the graph G\n(i) of every Pi \u2208 H, latest by time \u2206+ TAuth + 2TBC.\nWe next note that corresponding to every Sq \u2208 SZs , every honest Pi \u2208 Wq will have the share sq, which is either made public by D as part of the CanCS message or received from D. Each honest Pi \u2208 Wq will thus set [s]q to sq at time \u2206+ TAuth +2TBC. We next show that each Pi \u2208 H will have ICSig(Pj , Pi, Pk, sq)\ncorresponding to every Sq \u2208 SZs , where Pi \u2208 Wq, for every Pj \u2208 Wq and every Pk 6\u2208 Sq. This also is set at time \u2206 + TAuth + 2TBC. This is because there are two possible cases with respect to q. If q \u2208 BS, then from the protocol steps, Wq is publicly set to Sq and ICSig(Pj , Pi, Pk, sq) is set to the default value. On the other hand, if q 6\u2208 BS, then also Pi will possess ICSig(Pj , Pi, Pk, sq). This is because as per the protocol steps, since Pi, Pj \u2208 Wq, it follows that Pi must have verified that the edge (Pi, Pj) \u2208 G(i), which further implies that Pi has received ICSig(Pj , Pi, Pk, sqj) from Pj , where sqj = sqi holds. And since D is honest, sqi = sq holds, implying that ICSig(Pj , Pi, Pk, sqj) is the same as ICSig(Pj , Pi, Pk, sq). On the other hand, in the protocol, Pi gives ICSig(Pi, Pj , Pk, sqi) to every Pj \u2208 Sq for every Pk \u2208 P , where sqi = sq holds. Hence if any corrupt Pj \u2208 Wq has ICSig(Pi, Pj , Pk, s \u2032 q) of any honest Pi \u2208 Wq for any Pk \u2208 P , then s \u2032 q = sq holds.\nWe now show that, corresponding to each Sq \u2208 SZs , every honest party Pi \u2208 Sq \\ Wq sets [s]q to sq, except with a probability of O(|SZs | \u00b7 n\n2 \u00b7 \u01ebICP), at time \u2206 + TAuth + 2TBC + TReveal. For this, we first show that Pi sets [s]q to some value. Since Zs satisfies the Q(1)(Wq,Zs) condition, the set Wq contains at least one honest party, say Pj . Since Pj follows the protocol steps honestly, it reveals ICSig(Pk, Pj , Pi, [s]q) of every Pk \u2208 Wq to Pi, at time \u2206+ TAuth + 2TBC. From the Zs-correctness of ICP in the synchronous network (see Theorem 4.1), it follows that Pi will accept these signatures after time TReveal. On the other hand, even if Pk \u2208 Wq is corrupt, then also from the Zs-non-repudiation property of ICP in the synchronous network (see Theorem 4.1), it follows that Pi accepts ICSig(Pk, Pj , Pi, [s]q), except with a probability \u01ebICP, after time TReveal. As there can be O(n) corrupt parties in Wq, from the union bound, it follows that except with a probability O(n \u00b7 \u01ebICP), party Pi will find a candidate party from Wq, who reveals [s]q, along with the IC-signature of all the parties in Wq, after time TReveal. Now as there can be O(n) parties in Sq \\Wq, it follows that except with probability O(n2 \u00b7 \u01ebICP), every honest party Pi \u2208 Sq \\ Wq will find a candidate party from Wq, who reveals [s]q along with the IC-signature of all the parties in Wq at time \u2206+ TAuth + 2TBC + TReveal.\nWe next show that Pi \u2208 Sq \\Wq indeed sets [s]q to sq. Suppose that Pi sets [s]q to some value s\n\u2032. From the protocols steps, this implies that there exists some Pj \u2208 Wq, such that Pi has accepted ICSig(Pk, Pj , Pi, s\u2032) of every Pk \u2208 Wq, revealed by Pj . If Pj is honest, then indeed s\n\u2032 = [s]q, as one of the IC-signatures ICSig(Pk, Pj , Pi, s\n\u2032) is the same as ICSig(Pk, Pj , Pi, [s]q), corresponding to the honest Pk \u2208 Wq, which is guaranteed to exist. So consider the case when Pj is corrupt. Moreover, let Pk \u2208 Wq be an honest party (which is guaranteed to exist). In order that s\u2032 6= [s]q, it must be the case that Pi accepts ICSig(Pk, Pj , Pi, s\u2032), revealed by Pj . However, from the unforgeability property of ICP (see Theorem 4.1), this can happen only with probability \u01ebICP. Now as there can be up to O(n) corrupt parties in Wq, from the union bound, it follows that the probability that Pi outputs s\n\u2032 6= [s]q is at most O(n \u00b7 \u01ebICP). Since there can be up to O(n) parties in Sq \\Wq, it follows that except with probability at most O(n2 \u00b7\u01ebICP), the output of every honest party in Sq is indeed sq. Now, there can be |SZs | possibilities for Sq. From the union bound, it follows that corresponding to each Sq \u2208 SZs ,\nevery honest party Pi \u2208 Sq \\ Wq sets [s]q to sq, except with a probability of O(|SZs | \u00b7 n\n2 \u00b7 \u01ebICP). Finally, the privacy for s follows from the fact that throughout the protocol,\nthe view of the adversary remains independent of the share sq, corresponding to the group Sq, where Sq = H. This is because as shown above, q /\u2208 BS and consequently, D does not make public the share sq. Moreover, during the pairwise consistency tests, the view of the adversary remains independent of sq, when the parties in H exchange IC-signed sq, which follows from the privacy property of ICP (see Theorem 4.1). Further, while computing the output, ICSig(Pk, Pj , Pi, sq) is revealed by party Pj \u2208 Wq only to each party Pi \u2208 Sq\\Wq. Hence, the adversary does not learn sq.\nAn immediate corollary of Lemma C.1 is that if D is honest, then the parties output [s] at time \u2206+ TAuth + 2TBC + TReveal, which follows from the definition of [\u00b7]-sharing.\nCorollary C.1. If the network is synchronous and D is honest and participates in \u03a0VSS with input s, then the parties output [s] at time \u2206+TAuth+2TBC+TReveal, except with a probability of O(|SZs | \u00b7 n 2 \u00b7 \u01ebICP).\nWe next consider a corrupt D in the synchronous network and show that if any honest party computes an output at time T , then there exists some s\u22c6 \u2208 F such that the (honest) parties output [s\u22c6] by time T +\u2206, except with probability O(|SZs | \u00b7 n 2 \u00b7 \u01ebICP).\nLemma C.2. If the network is synchronous and D is corrupt and if any honest party computes an output at time T , then there exists some s\u22c6 \u2208 F, such that the honest parties output [s\u22c6] by time T +\u2206, except with a probability of O(|SZs | \u00b7 n2 \u00b7 \u01ebICP).\nProof. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. Let P\u2113 \u2208 H be the first honest party which computes an output at time T . The way in which the core sets are defined ensures that each set in {Wq}q=1,...,|Zs| must contain at least one honest party. Since \u03a0Reveal takes at least TReveal time to complete, this means that there exists Sp \u2208 SZs such that some honest party Pm receives a message (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS) from the broadcast of D by the time T \u2212 TReveal and includes (D, Sp) to Cm. This further implies that Pm has verified that the following hold, for q = 1, . . . , |Zs|, by time T \u2212 TReveal. \u2013 If q 6\u2208 BS, then Wq is either Sq or (Sp \u2229 Sq). Moreover, Zs satisfies the\nQ(1)(Wq,Zs) condition and the parties in Wq constitute a clique in the graph G(m).\n\u2013 If q \u2208 BS, then D has made public sq, as part of the CanCS message. Moreover, Wq is set to Sq. From the Zs-consistency and Zs-fallback consistency of \u03a0BC in the synchronous network (see Theorem 3.2), it follows that every party in H will receive (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS) from the broadcast of D, latest by time T \u2212 TReveal + \u2206. We next show that each Pi \u2208 H will include (D, Sp) to\nCi, latest by time T \u2212 TReveal + \u2206. For this, it is enough to show that all the edges which are present in G(m) at time T \u2212 TReveal, are bound to be present in the graph G(i) every Pi \u2208 H, by the time T \u2212 TReveal + \u2206. However, this simply follows from the Zs-validity, Zs-consistency and Zs-fallback consistency of \u03a0BC in the synchronous network (see Theorem 3.2) and the fact that edges are added to consistency graphs, based on the receipt of OK(\u22c6, \u22c6) messages, which are broadcasted through various \u03a0BC instances. Consequently, any edge (i, j) which is included in G(m) at the time T , is bound to be included in the graph G(i) of every Pi \u2208 H, latest by time T \u2212 TReveal +\u2206.\nWe next show that by time T \u2212TReveal+\u2206, corresponding to every Sq \u2208 SZs , every Pi \u2208 Wq will have a common share, say s\u22c6q . If q \u2208 BS, this is trivially true, since in this case, D makes public the share sq and hence s \u22c6 q = sq. On the other hand, consider the case when q 6\u2208 BS and consider arbitrary Pi, Pj \u2208 (Wq \u2229H). Since Pi and Pj are part of a clique, it follows that Pi and Pj have broadcasted the messages OK(i, j) and OK(j, i) respectively. Moreover, these messages were broadcasted, latest by time T \u2212 TReveal \u2212 TBC, since it takes at least TBC time to compute any output in an instance of \u03a0BC in the synchronous network (see Theorem 3.2). Now since Pi and Pj have broadcasted OK(i, j) and OK(j, i) messages, it implies that they have verified that sqi = sqj holds, where sqi and sqj are the shares, received by Pi and Pj respectively, from D. Let sqi = sqj = s \u22c6 q . We define\ns\u22c6 def =\n\u2211\nq=1,...,|Zs|\ns\u22c6q .\nTill now we have shown that there exists some s\u22c6 \u2208 F, such that by time T \u2212 TReveal + \u2206, all the parties in H will have the core-sets W1, . . . ,W|Zs|, where Sq \\ Wq \u2208 Za, for q = 1, . . . , |Zs| and where each Pi \u2208 (Wq \u2229 H) will have a common share [s\u22c6]q. We need to show that by the time T\u2212TReveal+\u2206, the parties in H will have the required IC-signatures, as part of [s\u22c6], satisfying the linearity property. Namely, each Pi \u2208 H will have ICSig(Pj , Pi, Pk, [s\u22c6]q), corresponding to every Sq \u2208 SZs where Pi \u2208 Wq, of every Pj \u2208 Wq and for every Pk \u2208 P . There are two possible cases with respect to q. If q \u2208 BS, then from the protocol steps, Wq is publicly set to Sq and ICSig(Pj , Pi, Pk, [s\u22c6]q) is set to the default value of ICSig(Pj , Pi, Pk, sq), where sq is made public by D. As per our notations, sq = s \u22c6 q for every q \u2208 BS. On the other hand, if q 6\u2208 BS, then also Pi will possess ICSig(Pj , Pi, Pk, [s \u22c6]q). This is because as per the protocol steps, since Pi, Pj \u2208 Wq, it follows that Pi must have verified that the edge (Pi, Pj) \u2208 G(i), which further implies that Pi has received ICSig(Pj , Pi, Pk, sqj) from Pj , where sqj = sqi holds. Here sqi is the share received by Pi from D and as per our notation, sqi = s \u22c6 q . Hence ICSig(Pj , Pi, Pk, sqj) is the same as ICSig(Pj , Pi, Pk, [s\n\u22c6]q). On the other hand, in the protocol, Pi gives ICSig(Pi, Pj , Pk, sqi) to every Pj \u2208 Sq for every Pk \u2208 P , where sqi = [s\u22c6]q holds. Hence if any corrupt Pj \u2208 Wq has ICSig(Pi, Pj , Pk, s \u2032 q), of any honest Pi \u2208 Wq for any Pk \u2208 P , then s \u2032 q = [s\n\u22c6]q holds. It is easy to see that all the underlying IC-signatures will be linear since the parties follow the linearity principle while generating IC-signatures.\nFinally, we now show that every honest party Pi \u2208 Sq \\ Wq gets [s\u22c6]q, except with a probability of O(|SZs | \u00b7 n\n2 \u00b7 \u01ebICP), at time T +\u2206. For this, we first show that Pi computes some share on the behalf of Sq. Since Zs satisfies the Q(1)(Wq,Zs) condition, the set Wq contains at least one honest party, say Pj . Since Pj follows the protocol steps honestly, it reveals ICSig(Pk, Pj , Pi, [s\n\u22c6]q) of every Pk \u2208 Wq to Pi, at time T \u2212 TReveal +\u2206. From the Zs-correctness of ICP in the synchronous network (see Theorem 4.1), it follows that Pi will accept the IC-signatures ICSig(Pk, Pj , Pi, [s\n\u22c6]q), revealed by Pj , after time TReveal. On the other hand, even if Pk \u2208 Wq is corrupt, then also from the Zs-non-repudiation property of ICP in the synchronous network (see Theorem 4.1), it follows that Pi accepts ICSig(Pk, Pj , Pi, [s\n\u22c6]q), except with a probability \u01ebICP, after time TReveal. As there can be O(n) corrupt parties in Wq, from the union bound, it follows that except with a probability O(n \u00b7 \u01ebICP), party Pi will find a candidate party from Wq, who reveals [s\u22c6]q, along with the IC-signature of all the parties in Wq, after time TReveal. Now as there can be O(n) parties in Sq \\ Wq, it follows that except with probability O(n2 \u00b7 \u01ebICP), every honest party Pi \u2208 Sq \\ Wq will find a candidate party from Wq, who reveals [s\u22c6]q along with the IC-signature of all the parties in Wq at time T +\u2206.\nWe next show that Pi \u2208 Sq \\Wq indeed sets [s \u22c6]q as the share corresponding to Sq. Suppose that Pi sets the share to some value s \u2032. From the protocol steps, this implies that there exists some Pj \u2208 Wq, such that Pi has accepted the IC-signatures ICSig(Pk, Pj , Pi, s\n\u2032) of every Pk \u2208 Wq, revealed by Pj . If Pj is honest, then indeed s\u2032 = [s\u22c6]q, as one of the IC-signatures ICSig(Pk, Pj , Pi, s\n\u2032) is the same as ICSig(Pk, Pj , Pi, [s\n\u22c6]q), corresponding to the honest Pk \u2208 Wq, which is guaranteed to exist. So consider the case when Pj is corrupt. Moreover, let Pk \u2208 Wq be an honest party (which is guaranteed to exist). In order that s\u2032 6= [s\u22c6]q, it must be the case that Pi accepts ICSig(Pk, Pj , Pi, s\n\u2032), revealed by Pj . However, from the unforgeability property of ICP (see Theorem 4.1), this can happen only with probability \u01ebICP. Now as there can be up to O(n) corrupt parties in Wq, from the union bound, it follows that the probability that Pi outputs s\u2032 6= [s\u22c6]q is at most O(n \u00b7 \u01ebICP). Since there can be up to O(n) parties in Sq \\Wq, it follows that except with probability at most O(n2 \u00b7\u01ebICP), the output of every honest party in Sq is indeed [s\n\u22c6]q. Now, there can be |SZs | possibilities for Sq. From the union bound, it follows that corresponding to each Sq \u2208 SZs , every honest party in Sq outputs [s \u22c6]q, except with a probability of O(|SZs | \u00b7n 2 \u00b7 \u01ebICP).\nWe next consider an asynchronous network and prove the analogue of Lemma C.1 by showing that if D is honest, then the parties eventually output [s] except with a probability of O(|SZs | \u00b7 n\n2 \u00b7 \u01ebICP). Further, the adversary learns no additional information about s. The proof of the lemma follows closely the proof of Lemma C.1, except that we now rely on the properties of \u03a0BC, and ICP in the asynchronous network.\nLemma C.3. If the network is asynchronous and D is honest, participating in \u03a0VSS with input s, then the honest parties eventually output [s] except with a probability of O(|SZs | \u00b7 n\n2 \u00b7 \u01ebICP), with the view of the adversary remaining independent of s.\nProof. Let Z\u22c6 \u2208 Za be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. We note that H \u2208 SZs , since Z\n\u22c6 \u2208 Zs as Za \u2282 Zs. Since D is honest, it picks the shares s1, . . . , s|Zs| such that s = s1+\u00b7 \u00b7 \u00b7+s|Zs| and sends sq to each party Pi \u2208 Sq, corresponding to every Sq \u2208 SZs . These shares are eventually delivered. Now consider an arbitrary Sq \u2208 SZs . After receiving the share sqi from D, each party Pi \u2208 (Sq \u2229H) starts giving ICSig(Pi, Pj , Pk, sqi) to every Pj \u2208 Sq, for every Pk \u2208 P , where sqi = sq holds, such that the linearity principle is followed while generating these IC-signatures. Then from the Za-correctness of \u03a0Auth in the asynchronous network (Theorem 4.1), it follows that each party Pi \u2208 (Sq\u2229H) will eventually receive ICSig(Pj , Pi, Pk, sqj) from every Pj \u2208 (Sq\u2229H), for every Pk \u2208 P , such that sqj = sqi = sq holds. Since Sq is arbitrary, it follows that eventually, every party Pi \u2208 H broadcasts an OK(i, j) message, corresponding to every Pj \u2208 H. From the Za-weak validity and Za-fallback validity of \u03a0BC in the asynchronous network (Theorem 3.2), it follows that these OK(i, j) messages are eventually received by every party in H. Consequently, the set H eventually constitutes a clique in the consistency graph of every party in H. Now since the set H \u2208 SZs , it follows that eventually, there exists some Sp \u2208 SZs , such that D computes the core-sets {Wq}q=1,...,|Zs| and broadcast-set BS, followed by broadcasting (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS). Moreover, since D is honest, it computes the sets {Wq}q=1,...,|Zs| and BS honestly, satisfying the following conditions, for q = 1, . . . , |Zs|.\n\u2013 If Sq constitutes a clique in the graph G (D), then Wq = Sq. \u2013 Else if (Sp \u2229 Sq) constitutes a clique in G(D) and Zs satisfies the Q(1)(Sp \u2229 Sq,Zs) condition, then Wq = (Sp \u2229 Sq). \u2013 Else Wq = Sq and q \u2208 BS.\nNote that for each Wq, the condition Q (1)(Wq,Zs) holds. This is obviously true if Wq = (Sp \u2229 Sq), since in this case D also checks that Q(1)(Sp \u2229 Sq,Zs) holds. On the other hand, even if Wq = Sq, the condition Q(1)(Wq,Zs) holds, since Q(1)(Sq,Zs) holds. We also note that if Sq = H, then q /\u2208 BS and consequently, D does not make public the share sq. This is because the parties in Sp \u2229 Sq will constitute a clique and the Q(1)(Sp \u2229 Sq,Zs) condition will be satisfied due to the Q(2,1)(P ,Zs,Za) condition. Hence Wq will be set to Sp \u2229 Sq.\nSince D eventually broadcasts (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS), from the Za-weak validity and Za-fallback validity of \u03a0BC in the asynchronous network, it follows that all the parties in H will eventually receive (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS) from the broadcast of D. We next show that every Pi \u2208 H will eventually include (D, Sp) to the set Ci. For this, we need to show that all the conditions which hold for D in its graph G(D) when it broadcasts the CanCS message, are bound to eventually hold for every Pi \u2208 H. However, this simply follows from the Za-weak validity, Za-fallback validity, Zaweak consistency and Za-fallback consistency of \u03a0BC in the asynchronous network (see Theorem 3.2) and the fact that edges are added to consistency graphs, based on the receipt of OK(\u22c6, \u22c6) messages, which are broadcasted through various \u03a0BC instances. Consequently, any edge (i, j) which is included in G\n(D), is bound to be eventually included in the graph G(i) of every Pi \u2208 H.\nNote that corresponding to every Sq \u2208 SZs , every honest Pi \u2208 Wq will have the share sq, which is either made public by D as part of the CanCS message or received from D. Next, we note that each Pi \u2208 H will have ICSig(Pj , Pi, Pk, sq), corresponding to every Sq \u2208 SZs where Pi \u2208 Wq, from every Pj \u2208 Wq and for every Pk \u2208 P . On the other hand, if any corrupt Pj \u2208 Wq has ICSig(Pi, Pj , Pk, s\u2032q) of any honest Pi \u2208 Wq for any Pk \u2208 P , then s\u2032q = sq holds. The proof for this is exactly the same as that of Lemma C.1.\nWe now show that every honest party Pi \u2208 Sq \\Wq eventually sets [s]q to sq, except with a probability of O(|SZs | \u00b7n\n2 \u00b7 \u01ebICP). We first show that Pi sets [s]q to some value. Since Zs satisfies the Q(1)(Wq,Zs) condition, this means that Wq contains at least one honest party, say Pj . Since Pj follows the protocol steps honestly, it reveals ICSig(Pk, Pj , Pi, [s]q) of every Pk \u2208 Wq to Pi. From the Zacorrectness property of ICP in the asynchronous network (see Theorem 4.1), it follows that Pi will eventually accept these signatures. On the other hand, even if Pk \u2208 Wq is corrupt, then from the Za-non-repudiation property of ICP in the asynchronous network (see Theorem 4.1), it follows that Pi eventually accepts ICSig(Pk, Pj , Pi, [s]q), except with a probability \u01ebICP. From the union bound, it follows that except with probability O(n2 \u00b7\u01ebICP), each party Pi \u2208 Sq outputs some value for [s]q. Further, this value must be sq. The proof of this follows from what was shown in C.1. Now, there can be |SZs | possibilities for Sq. From the union bound, it follows that corresponding to each Sq \u2208 SZs , every honest party in Sq eventually outputs [s]q, except with a probability of O(|SZs | \u00b7 n\n2 \u00b7 \u01ebICP). Finally, the privacy for s follows from the fact that throughout the protocol,\nthe view of the adversary remains independent of the share sq, corresponding to the group Sq, where Sq = H. This is because as shown above, q /\u2208 BS and consequently, D does not make public the share sq. Moreover, during the pairwise consistency tests, the view of the adversary remains independent of sq, when the parties in H exchange IC-signed sq, which follows from the privacy property of ICP (see Theorem 4.1). Further, while computing the output, ICSig(Pk, Pj , Pi, sq) is revealed by party Pj \u2208 Wq only to each party Pi \u2208 Sq\\Wq. Hence, the adversary does not learn sq.\nFinally, we consider a corrupt D in the asynchronous network and prove the analogue of Lemma C.2, whose proof is very similar to that of Lemma C.2.\nLemma C.4. If the network is asynchronous and D is corrupt and if any honest party computes an output, then there exists some s\u22c6 \u2208 F, such that the honest parties eventually output [s\u22c6], except with a probability of O(|SZs | \u00b7 n 2 \u00b7 \u01ebICP).\nProof. Let Z\u22c6 \u2208 Za be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. Let Pm \u2208 H be the first honest party, who computes an output in the protocol \u03a0VSS. This implies that there exists some Sp \u2208 SZs , such that Pm receives a message (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS) from the broadcast of D, and includes (D, Sp) to Cm. This further implies that Pm has verified that the following hold, for q = 1, . . . , |Zs|. \u2013 If q 6\u2208 BS, then Wq is either Sq or (Sp \u2229 Sq). Moreover, Zs satisfies the\nQ(1)(Wq,Zs) condition and the parties in Wq constitute a clique in the graph G(m).\n\u2013 If q \u2208 BS, then D has made public sq, as part of the CanCS message. Moreover, Wq is set to Sq. From the Za-weak consistency and Za-fallback consistency of \u03a0BC in the asynchronous network (see Theorem 3.2), it follows that every party in H will eventually receive (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS) from the broadcast of D. We next show that each Pi \u2208 H will eventually include (D, Sp) to Ci. For this, it is enough to show that all the edges which are present in G(m) when (D, Sp) is included in Ci, are bound to be eventually present in the graph G(i) of every Pi \u2208 H. However, this simply follows from the Za-weak validity, Zafallback validity, Za-weak consistency and Za-fallback consistency of \u03a0BC in the asynchronous network (see Theorem 3.2) and the fact that edges are added to consistency graphs, based on the receipt of OK(\u22c6, \u22c6) messages, which are broadcasted through various \u03a0BC instances.\nNext, it can be shown that corresponding to every Sq \u2208 SZs , every Pi \u2208 Wq will have a common share, say s\u22c6q . The proof for this is the same as Lemma C.2. We define\ns\u22c6 def =\n\u2211\nq=1,...,|Zs|\ns\u22c6q .\nNow similar to the proof of Lemma C.2, it can be shown that each party Pi in (H\u2229Wq) will eventually have the required IC-signatures on [s\u22c6]q as part of [s\u22c6] and will reveal these to parties in Sq \\Wq. Consequently, each party in H will eventually set [s\u22c6]q as the share corresponding to Sq and hence, s\n\u22c6 will eventually be secret-shared, except with a probability of O(|SZs | \u00b7 n 2 \u00b7 \u01ebICP).\nWe next derive the communication complexity of the protocol \u03a0VSS.\nLemma C.5. Protocol \u03a0VSS incurs a communication of O(|Zs| \u00b7n8 \u00b7 log |F| \u00b7 |\u03c3|) bits.\nProof. In the protocol, D needs to send the share sq to all the parties in Sq. This incurs a total communication of O(|Zs| \u00b7 n \u00b7 log |F|) bits. There are O(|Zs| \u00b7 n3) instances of \u03a0Auth invoked, to exchange IC-signed values, during the pairwise consistency tests. From Theorem 4.1, this incurs a total communication of O(|Zs| \u00b7 n8 \u00b7 log |F| \u00b7 |\u03c3|) bits. There are O(n2) OK messages which need to be broadcasted, which from Theorem 3.2, incurs a total communication of O(n6 \u00b7 logn \u00b7 |\u03c3|) bits, since each OK message encodes the identity of two parties, requiring logn bits. Finally, D needs to broadcast a candidate (CanCS,D, Sp, {Wq}q=1,...,|Zs|,BS, {sq}q\u2208BS) message, where Sp,BS and each Wq can be represented by O(n) bits. And corresponding to the indices in BS, the dealer D may end up broadcasting O(|Zs|) shares. From Theorem 3.2, this incurs a total communication of O(|Zs| \u00b7 (n5 \u00b7 |\u03c3| + n4 \u00b7 log |F| \u00b7 |\u03c3|)) bits. While computing the output, O(n3 \u00b7 |Zs|) instances of \u03a0Reveal are involved, which incur a communication of O(|Zs| \u00b7 n4 \u00b7 log |F|) bits.\nTheorem 5.1 now follows from Lemma C.1-C.5.\nTheorem 5.1. Protocol \u03a0VSS achieves the following, except with a probability of O(|SZs | \u00b7 n\n2 \u00b7 \u01ebICP), where D has input s \u2208 F for \u03a0VSS and where TVSS = \u2206+ TAuth + 2TBC + TReveal. \u2013 If D is honest, then the following hold.\n\u2013 Zs-correctness: In a synchronous network, the honest parties output [s] at time TVSS. \u2013 Za-correctness: In an asynchronous network, the honest parties eventually output [s].\n\u2013 Privacy: Adversary\u2019s view remains independent of s in any network. \u2013 If D is corrupt, then the following hold.\n\u2013 Zs-commitment: In a synchronous network, either no honest party obtains any output or there exists some s\u22c6 \u2208 F, such that the parties output [s\u22c6]. Moreover, if any honest party computes its output corresponding to [s\u22c6] at time T , then all honest parties compute their output corresponding to [s\u22c6] by time T +\u2206.\n\u2013 Za-commitment: In an asynchronous network, either no honest party obtains any output or there exists some s\u22c6 \u2208 F, such that the honest parties eventually output [s\u22c6]. \u2013 Communication Complexity: O(|Zs|\u00b7n 8 \u00b7log |F|\u00b7|\u03c3|) bits are communicated\nby the honest parties."
        },
        {
            "heading": "D Network Agnostic Reconstruction Protocols and Secure Multicast",
            "text": "This section presents our network-agnostic reconstruction protocols and secure multicast protocol, along with their properties. We start with the protocol \u03a0RecShare for reconstructing a designated share, presented in Fig 18.\nWe next prove the properties of the protocol \u03a0RecShare.\nLemma 6.1. Let s be a value which is linearly secret-shared with IC sig-\nnatures, let Sq \u2208 SZs be a designated set and let R \u2286 P be a designated set of receivers. Then protocol \u03a0RecShare achieves the following. \u2013 Zs-correctness: In a synchronous network, all honest parties in R output\n[s]q at time TRecShare = TReveal, except with a probability of O(n2 \u00b7 \u01ebICP). \u2013 Za-correctness: In an asynchronous network, all honest parties in R even-\ntually output [s]q, except with a probability of O(n2 \u00b7 \u01ebICP). \u2013 Privacy: If R consists of only honest parties, then the view of the adversary\nremains independent of [s]q. \u2013 Communication Complexity: O(|R| \u00b7 n3 \u00b7 log |F|) bits are communicated.\nProof. We first note that all honest parties in (R\u2229Wq) output [s]q correctly. So consider an arbitrary honest Pi \u2208 R\\Wq. We first show that Pi indeed computes an output in the protocol, irrespective of the network type.\nSince Zs satisfies the Q(1)(Wq,Zs) condition, it contains at least one honest party, say Pj . Since Pj follows the protocol steps honestly, it reveals ICSig(Pk, Pj , Pi, [s]q) of every Pk \u2208 Wq to Pi. From the correctness properties of ICP (see Theorem 4.1), it follows that Pi will accept the IC-signatures ICSig(Pk, Pj , Pi, [s]q), revealed by Pj , after time TReveal in a synchronous network, or eventually in an asynchronous network. On the other hand, even if Pk \u2208 Wq is corrupt, then also from the non-repudiation properties of ICP, it follows that Pi accepts ICSig(Pk, Pj , Pi, [s]q), except with a probability \u01ebICP, after time TReveal in a synchronous network, or eventually in an asynchronous network. As there can be O(n) corrupt parties in Wq, from the union bound, it follows that except with a probability O(n \u00b7 \u01ebICP), party Pi will find a candidate party from Wq, who reveals [s]q, along with the IC-signature of all the parties in Wq, after time TReveal in a synchronous network, or eventually in an asynchronous network. This is because the honest party in Wq always constitutes a candidate party. Now as there can be O(n) parties in R \\Wq, it follows that except with probability O(n2 \u00b7 \u01ebICP), every honest party in R\\Wq will find a candidate party from Wq, who reveals [s]q, along with the IC-signature of all the parties in Wq, after time TReveal in a synchronous network, or eventually in an asynchronous network. Hence all honest parties in R compute an output, after time TReveal in a synchronous network, or eventually in an asynchronous network, except with a probability O(n2 \u00b7 \u01ebICP).\nWe next show that the output computed by all the honest parties is indeed correct. While this is trivially true for the parties in (R\u2229Wq), consider an arbitrary honest party Pi \u2208 R\\Wq. The above argument shows that Pi computes an output in the protocol, irrespective of the network type. So let Pi output s\n\u2032. We wish to show that s\u2032 = [s]q. From the protocol steps, since Pi outputs s\n\u2032, it implies that there exists some Pj \u2208 Wq, such that Pi has accepted ICSig(Pk, Pj , Pi, s\n\u2032) of every Pk \u2208 Wq, revealed by Pj . If Pj is honest, then indeed s\u2032 = [s]q, as one of the IC-signatures ICSig(Pk, Pj , Pi, s\n\u2032) is the same as ICSig(Pk, Pj , Pi, [s]q), corresponding to the honest Pk \u2208 Wq, which is guaranteed to exist. So consider the case when Pj is corrupt. Moreover, let Pk \u2208 Wq be an honest party (which is guaranteed to exist). In order that s\u2032 6= [s]q, it must be the case that Pi accepts ICSig(Pk, Pj , Pi, s \u2032), revealed by Pj . However, from the unforgeability property of\nICP (see Theorem 4.1), this can happen only with probability \u01ebICP. Now as there can be up to O(n) corrupt parties in Wq, from the union bound, it follows that the probability that Pi outputs s\n\u2032 6= [s]q is at most O(n \u00b7 \u01ebICP). And since there can be up to O(n) parties in R \\Wq, it follows that except with probability at most O(n2 \u00b7 \u01ebICP), the output of every honest party in R is indeed [s]q.\nCommunication complexity follows from the communication complexity of \u03a0Reveal (Theorem 4.1) and the fact that O(|R| \u00b7 n2) instances of \u03a0Reveal are involved. And privacy follows from the privacy of ICP.\nProtocol\u03a0Rec for reconstructing s by a designated set of receivers is presented in Fig 19.\nThe properties of the protocol \u03a0Rec are stated in Lemma 6.2.\nLemma 6.2. Let s be a value which is linearly secret-shared with IC signatures and let R \u2286 P be a set of designated receivers. Then protocol \u03a0Rec achieves the following. \u2013 Zs-correctness: In a synchronous network, all honest parties in R output s\nat time TRec = TRecShare, except with probability O(|SZs | \u00b7 n 2 \u00b7 \u01ebICP).\n\u2013 Za-correctness: In an asynchronous network, all honest parties in R eventually output s, except with probability O(|SZs | \u00b7 n\n2 \u00b7 \u01ebICP). \u2013 Privacy: If R consists of only honest parties, then the view of the adversary\nremains independent of s. \u2013 Communication Complexity: O(|Zs| \u00b7 |R| \u00b7 n3 \u00b7 log |F|) bits are communi-\ncated.\nProof. The proof follows from Lemma 6.1, and the fact that |SZs | instances of \u03a0RecShare are invoked.\nD.1 Network Agnostic Secure Multicast\nProtocol \u03a0SVM is presented in Fig 20.\n\u2013 Sending the Value to the Parties: Sen on having the input v, invokes an instance of \u03a0VSS with input v and the parties in P participates in this instance.\nProtocol \u03a0SVM(Sen, v,R)\nWe next prove the properties of the protocol \u03a0SVM.\nLemma 6.3. Protocol \u03a0SVM achieves the following, where Sen participates with input v and where each honest party initializes flag(Sen,R) to 0. \u2013 Synchronous Network: If Sen is honest, then all honest parties set\nflag(Sen,R) to 1 at time TVSS and except with probability O(n3 \u00b7 \u01ebICP), all honest parties in R output v, after time TSVM = TVSS + TRec. Moreover, if R consists of only honest parties, then the view of Adv remains independent of v. If Sen is corrupt and some honest party sets flag(Sen,R) to 1, then there exists some v\u22c6 such that, except with probability O(n3 \u00b7 \u01ebICP), all honest parties in R output v\u22c6. Moreover, if any honest party sets flag(Sen,R) to 1 at time T , then all honest parties in R output v\u22c6 by time T + 2\u2206. \u2013 Asynchronous Network: If Sen is honest, then except with probability O(n3 \u00b7 \u01ebICP), all honest parties in R eventually output v. Moreover, if R consists of only honest parties, then the view of the adversary remains independent of v. If Sen is corrupt and some honest party sets flag(Sen,R) to 1, then there exists some v\u22c6 such that, except with probability O(n3 \u00b7 \u01ebICP), all honest parties in R eventually output v\u22c6. \u2013 Communication Complexity: O(|Zs|\u00b7n8 \u00b7log |F|\u00b7|\u03c3|) bits are communicated.\nProof. Let us first consider an honest Sen. If the network is synchronous, then from the Zs-correctness of \u03a0VSS in the synchronous network (Theorem 5.1), at time TVSS, all honest parties will output [v]. Consequently, each honest party will set flag(Sen,R) to 1 and start participating in the instance of \u03a0Rec. Hence, from the Zs-correctness of \u03a0Rec in the synchronous network (Lemma 6.2), coupled with the modifications presented in Section 6.1, it follows that all honest parties in R output v, except with probability O(n3 \u00b7\u01ebICP), after time TSVM = TVSS+TRec. The privacy of v follows from the privacy of \u03a0VSS (Theorem 5.1) and privacy of \u03a0Rec (Lemma 6.2). The proof for the case of honest Sen in an asynchronous network is the same as above, except that we now rely on the Za-correctness of \u03a0VSS in the asynchronous network (Theorem 5.1) and the Za-correctness of \u03a0Rec in the asynchronous network (Lemma 6.2).\nNext consider a corrupt Sen. Let us first consider a synchronous network. Let Pi be the first honest party who sets flag\n(Sen,R) to 1. This implies that there exists some v\u22c6, such that Pi outputs [v \u22c6]. Let T be the time when Pi outputs [v\u22c6] during the instance of \u03a0VSS (and hence sets flag (Sen,R) to 1). From the\nZs-commitment of \u03a0VSS in the synchronous network, it follows that all honest parties will output [v\u22c6] (and hence set flag(Sen,R) to 1), latest by time T + \u2206. Hence all honest parties will start participating in the instance of \u03a0Rec, latest by time T +\u2206. Hence, from the Zs-correctness of \u03a0Rec in the synchronous network (Lemma 6.2), coupled with the modifications presented in Section 6.1, it follows that all honest parties in R output v\u22c6, except with probability O(n3 \u00b7 \u01ebICP), by time T + 2\u2206.\nThe proof for the case of a corrupt Sen in an asynchronous network is the same as above, except that we now rely on the Za-commitment of \u03a0VSS in the asynchronous network (Theorem 5.1) and the Za-correctness of \u03a0Rec in the asynchronous network (Lemma 6.2).\nThe communication complexity follows from the communication complexity of \u03a0VSS and \u03a0Rec."
        },
        {
            "heading": "E Properties of the Protocol \u03a0MDVSS",
            "text": "In this section, we prove the properties of the protocol \u03a0MDVSS (see Fig 8 for the formal description).\nWe first show that if the network is synchronous, then all honest parties will compute a common candidate set of committed dealers CD set by time TSVM + 2TBA, such that all honest dealers are guaranteed to be present in CD.\nLemma E.1. If the network is synchronous and P\u2113 \u2208 P is an honest dealer participating with input s(\u2113), then all the following hold in \u03a0MDVSS, where H is the set of honest parties. \u2013 Except with probability O(n3 \u00b7 \u01ebICP), all the parties in H will have a common\nCD set by time TSVM + 2TBA, where H \u2286 CD. 18\n\u2013 Except with probability O(n3 \u00b7 \u01ebICP), corresponding to every dealer P\u2113 \u2208 CD and every Sq \u2208 S|Zs|, every party in (H\u2229Sq) will have a common share, say\ns\u22c6(\u2113)q , which is the same as s (\u2113) q , for an honest P\u2113.\nProof. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. From the properties of \u03a0SVM in the synchronous network (Lemma 6.3), it follows that every Pi \u2208 H will set flag\n(P\u2113,Sq) to 1 at time TVSS, corresponding to every P\u2113 \u2208 H and every Sq \u2208 SZs . Moreover, at time TSVM, corresponding to every P\u2113 \u2208 H and every Sq \u2208 SZs , each Pi \u2208 (H \u2229 Sq) computes the output s (\u2113) qi during the instance \u03a0 (P\u2113,Sq) SVM . Furthermore, except with probability O(n3 \u00b7 \u01ebICP), the value s (\u2113) qi will be the same as s (\u2113) q . Hence, corresponding to every P\u2113 \u2208 H, every Pi \u2208 H will start participating with input 1 during the instance \u03a0 (\u2113) BA , at time TSVM. Hence from the Zs-validity of \u03a0BA in the synchronous network (Theorem 3.1), at time TSVM+TBA, all the parties in H will obtain the output 1 from the \u03a0 (\u2113) BA instances, corresponding to each P\u2113 \u2208 H. Since P \\ H \u2208 Zs, it follows that at time TSVM + TBA, all the parties in H start\n18 This automatically implies that P \\ CD \u2208 Zs.\nparticipating with input 0 in any remaining instance \u03a0 (\u22c6) BA of \u03a0BA, for which no input is provided yet. Hence from the Zs-security of \u03a0BA in the synchronous network (Theorem 3.1), all the parties in H will compute some output in all the n instances of \u03a0 (\u22c6) BA by time TSVM+2TBA. Moreover, the outputs will be common for the parties in H. Consequently, all the parties in H will have a common CD set at the time TSVM + 2TBA. Moreover, H \u2286 CD, since CD includes all the dealers P\u2113 such that \u03a0 (\u2113) BA outputs 1. And as shown above the \u03a0 (\u2113) BA instances corresponding to P\u2113 \u2208 H outputs 1. Next, consider an arbitrary P\u2113 \u2208 CD. This implies that at time TSVM + TBA, at least one party from H, say Pk, has participated with input 1 during the instance \u03a0 (\u2113) BA . If not, then from the Zs-validity of \u03a0BA in the synchronous network (Theorem 3.1), all the parties in H would have obtained the output 0 from the instance \u03a0 (\u2113) BA at the time TSVM + 2TBA and hence P\u2113 6\u2208 CD, which is a contradiction. This implies that by the time TSVM + TBA, party Pk has set flag(P\u2113,Sq) to 1 during the instance \u03a0SVM(P\u2113, s (\u2113) q , Sq), for q = 1, . . . , |Zs|. So consider an arbitrary Sq \u2208 SZs . From the properties of \u03a0SVM in the synchronous network (Lemma 6.3), it follows that there exists some value s\u22c6(\u2113)q , which is the same as s (\u2113) q for an honest P\u2113, such that except with probabilityO(n3 \u00b7\u01ebICP), all the parties in H output s\u22c6(\u2113)q during the instance \u03a0 (P\u2113,Sq) SVM by time TSVM+TBA+2\u2206 < TSVM + 2TBA.\nWe next show that if the network is synchronous and if an honest dealer from CD broadcasts any set of candidate core-sets, then all honest parties will \u201caccept\u201d the core-sets. Moreover, the dealer will never make public the share corresponding to the group from SZs consisting of only honest parties while making public these core-sets. Furthermore, each honest dealer in CD will start making public at least one candidate set of core-sets, namely the one computed with respect to the group from SZs , consisting of only honest parties. A consequence of all these properties is that if the dealer is honest, the adversary will not learn any information about the dealer\u2019s input.\nLemma E.2. If the network is synchronous and P\u2113 \u2208 CD is an honest dealer participating with input s(\u2113), then all the following hold in \u03a0MDVSS except with probability O(n3 \u00b7 \u01ebICP), where H is the set of honest parties.\n\u2013 If Sp = H, then P\u2113 will broadcast (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p ,\n{s (\u2113) q }q\u2208BS(\u2113)p ) at time TSVM + 2TBA + TAuth + TBC.\n\u2013 If P\u2113 broadcasts any (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) at\ntime T , then every honest Pi \u2208 P will include (P\u2113, Sp) to Ci at time T +TBC. Moreover, the following will hold. \u2013 If Sq = H, then q 6\u2208 BS (\u2113) p . \u2013 For q = 1, . . . , |Zs|, each W (\u2113) p,q will be either Sq or (Sp \u2229 Sq). Moreover,\nZs will satisfy the Q(1)(W (\u2113) p,q,Zs) condition.\n\u2013 If q 6\u2208 BS(\u2113)p , then every honest Pi \u2208 Sq will have the share s (\u2113) q . Moreover,\nevery honest Pi \u2208 W (\u2113) p,q will have ICSig(Pj , Pi, Pk, s (\u2113) q ) of every Pj \u2208\nW (\u2113) p,q for every Pk \u2208 P. Furthermore, if any corrupt Pj \u2208 W (\u2113) p,q have ICSig(Pi, Pj , Pk, s \u2032(\u2113) q ) of any honest Pi \u2208 W (\u2113) p,q for any Pk \u2208 P, then s \u2032(\u2113) q = s (\u2113) q holds. Also, all the underlying IC-signatures will satisfy the\nlinearity property. \u2013 The view of the adversary will be independent of s(\u2113).\nProof. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. Since the dealer P\u2113 is honest, from Lemma E.1 it follows that corresponding to every Sq \u2208 SZs , every party in (H\u2229Sq) will have the share s (\u2113) qi , by time TSVM+2TBA, except with probability O(n3 \u00b7\u01ebICP), where s (\u2113) qi = s (\u2113) q . Now consider an arbitrary Sq \u2208 SZs . At time TSVM + 2TBA, each party Pi \u2208 (Sq \u2229H) starts giving ICSig(Pi, Pj , Pk, s (\u2113) qi ) to every Pj \u2208 Sq, for every Pk \u2208 P , where s (\u2113) qi = s (\u2113) q holds. Then from the Zs-correctness of \u03a0Auth in the synchronous network (Theorem 4.1), it follows that at time TSVM + 2TBA + TAuth, each party Pi \u2208 (Sq\u2229H) will receive ICSig(Pj , Pi, Pk, s (\u2113) qj ) from every Pj \u2208 (Sq\u2229H), for every Pk \u2208 P , such that s (\u2113) qj = s (\u2113) qi = s (\u2113) q holds. Since Sq is arbitrary, it follows that at time TSVM+2TBA+TAuth, every party Pi \u2208 H broadcasts an OK (\u2113)(i, j) message, corresponding to every Pj \u2208 H. From the Zs-validity of \u03a0BC in the synchronous network (Theorem 3.2), it follows that these OK(\u2113)(i, j) messages are received by every party in H through regular-mode at time TSVM + 2TBA + TAuth + TBC. Consequently, the set H constitutes a clique in the consistency graph G(\u2113,i) of every party Pi \u2208 H at time TSVM+2TBA+TAuth+TBC. Note that the set H \u2208 SZs . Let Sp be the set from SZs , such that Sp = H. From the protocol steps, it then follows that at time TSVM + 2TBA + TAuth + TBC, the dealer P\u2113 will compute core-sets W (\u2113) p,q for q = 1, . . . , |Zs| and broadcast-set BS (\u2113) p with respect to Sp as follows.\n\u2013 If Sq constitutes a clique in the graph G (\u2113,\u2113), then W (\u2113) p,q is set as Sq. \u2013 Else if (Sp \u2229 Sq) constitutes a clique in G(\u2113,\u2113) and Zs satisfies the Q(1)(Sp \u2229\nSq,Zs) condition, then W (\u2113) p,q is set as (Sp \u2229 Sq).\n\u2013 Else W (\u2113) p,q is set to Sq and q is included to BS (\u2113) p .\nAfter computing the core-sets and broadcast-set, P\u2113 will broadcast (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) at time TSVM + 2TBA + TAuth + TBC. This proves the first part of the lemma.\nWe next proceed to prove the second part of the lemma. So consider an arbitrary Sp \u2208 SZs , such that P\u2113 compute core-sets W (\u2113) p,q for q = 1, . . . , |Zs| and broadcast-set BS (\u2113) p with respect to Sp and broadcasts (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) at time T . This means at time T , the parties in Sp constitute a clique in the graph G (\u2113,\u2113). We also note that T \u2265 TSVM + 2TBA + TAuth + TBC. This is because any instance of \u03a0BC takes at least TBC time in a synchronous network to generate an output. And the parties in H start participating in any \u03a0BC instance invoked for broadcasting any OK(\u2113)(\u22c6, \u22c6) message, only after time TSVM+2TBA+TAuth. Consequently, any\nOK(\u2113)(\u22c6, \u22c6) message received by P\u2113, must be after time TSVM+2TBA+TAuth+TBC. We also note that any edge (Pj , Pk) which is present in the graph G\n(\u2113,\u2113) of P\u2113 at time T , is bound to be present in the graph G(\u2113,i) of every Pi \u2208 H, latest by time T +\u2206. This is because the edge (Pj , Pk) is added to G (\u2113,\u2113) upon the receipt of OK(\u2113)(j, k) and OK(\u2113)(k, j) messages from the broadcast of Pj and Pk respectively. And from the Zs-validity, Zs-consistency and Zs-fallback consistency of \u03a0BC in the synchronous network, these OK\n(\u2113)(\u22c6, \u22c6) messages will be received by every party Pi \u2208 H, latest by time T +\u2206. Since P\u2113 is assumed to be honest, it follows that the sets {W (\u2113) p,q}q=1,...,|Zs| and BS (\u2113) p satisfy the following properties.\n\u2013 If Sq constitutes a clique in the graph G (\u2113,\u2113), then W (\u2113) p,q is set as Sq. \u2013 Else if (Sp \u2229 Sq) constitutes a clique in G(\u2113,\u2113) and Zs satisfies the Q(1)(Sp \u2229\nSq,Zs) condition, then W (\u2113) p,q is set as (Sp \u2229 Sq).\n\u2013 Else W (\u2113) p,q is set to Sq and q is included to BS (\u2113) p .\nWe also note that if Sq = H, then q 6\u2208 BS (\u2113) p and consequently, P\u2113 will not make the share s (\u2113) q public. This is because T \u2265 TSVM + 2TBA + TAuth + TBC. And as shown in the proof of the first part, the set H will constitute a clique in the graph G(\u2113,\u2113) at time TSVM + 2TBA + TAuth + TBC. Since P\u2113 is honest, from the Zs-validity of \u03a0BC in the synchronous network, it follows that all the parties in H will receive (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) through the regular-mode at time T +TBC. Moreover, each party Pi \u2208 H will include (P\u2113, Sp) to the set Ci at time T + TBC. This is because since P\u2113 has computed the sets {W (\u2113) p,q}q=1,...,|Zs| and BS (\u2113) p honestly, these sets will pass all the verifications for each Pi \u2208 H at time T +\u2206.\nNext consider an arbitrary q 6\u2208 BS(\u2113)p . This implies that P\u2113 has set W (\u2113) p,q as (Sp\u2229Sq) because the parties in (Sp\u2229Sq) constitutes a clique in the graph G(\u2113,\u2113). Now consider an arbitrary Pi \u2208 (H\u2229Sq). This implies that Pi has computed s (\u2113) qi during the instance \u03a0SVM(P\u2113, s (\u2113) q , Sq) at time TSVM, which will be the same as s (\u2113) q , since P\u2113 is honest. Next consider arbitrary Pi, Pj \u2208 W (\u2113) p,q, such that Pj 6= Pi. This implies that the edge (i, j) is present in the graph G(\u2113,\u2113), which further implies that Pi has broadcasted the message OK (\u2113)(i, j). This further implies that Pi must have received ICSig(Pj , Pi, Pk, s (\u2113) qj ) from Pj , for every Pk \u2208 P , such that s (\u2113) qj = s (\u2113) qi holds. Since s (\u2113) qi = s (\u2113) q , it follows that ICSig(Pj , Pi, Pk, s (\u2113) qj ) is the same as ICSig(Pj , Pi, Pk, s (\u2113) q ). On the other hand, consider an arbitrary Pj \u2208 W (\u2113) p,q, such that Pj is corrupt and where Pj has received ICSig(Pi, Pj , Pk, s \u2032(\u2113) q ) from Pi, for any Pk \u2208 P . Then from the protocol steps, it follows that s \u2032(\u2113) q = s (\u2113) qi , since Pi gives the IC-signature on the share s (\u2113) qi , received from P\u2113. And since s (\u2113) qi = s (\u2113) q , it follows that ICSig(Pi, Pj , Pk, s \u2032(\u2113) q ) is the same as ICSig(Pi, Pj , Pk, s (\u2113) q ). The linearity of the underlying IC-signatures follow from the fact the parties follow the linearity principle while generating IC-signatures.\nFinally, the privacy of s(\u2113) follows from the fact that throughout the protocol, adversary does not learn anything about the share s (\u2113) q , provided Sq = H.\nNamely, during the instance \u03a0SVM(P\u2113, s (\u2113) q , Sq) where (Sq \u2229 Z\u22c6) = \u2205, the view of the adversary remains independent of s (\u2113) q , which follows from the privacy of \u03a0SVM (Lemma 6.3). Moreover, as shown above, P\u2113 never makes public the share s (\u2113) q , as q 6\u2208 BS (\u2113) p . Furthermore, since the set H will consists of only honest parties, from the privacy of ICP (see Theorem 4.1), it follows that the adversary does not learn any additional information about s (\u2113) q , when the parties in H exchange IC-signed s (\u2113) q during the pairwise consistency tests.\nWe next show that if the network is synchronous, then any candidate set of core-sets \u201caccepted\u201d on the behalf of a corrupt dealer by any honest party at the time T , is bound to be accepted by all honest parties, latest by time T +\u2206.\nLemma E.3. If the network is synchronous and if in \u03a0MDVSS any honest party Pi receives (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) from the broadcast of any corrupt dealer P\u2113 \u2208 CD and includes (P\u2113, Sp) to Ci at time T , then all honest parties Pj will receive (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) from the broadcast of P\u2113 and include (P\u2113, Sp) to Cj by time T + \u2206. Moreover, for q = 1, . . . , |Zs|, the following holds, except with probability O(n3 \u00b7 \u01ebICP).\n\u2013 W (\u2113) p,q is either Sq or (Sp \u2229 Sq). Moreover, Zs satisfies the Q(1)(W (\u2113) p,q,Zs)\ncondition. \u2013 If q 6\u2208 BS(\u2113)p , then every honest Pi \u2208 Sq will have a common share, say s \u22c6(\u2113) q .\nMoreover, every honest Pi \u2208 W (\u2113) p,q will have ICSig(Pj , Pi, Pk, s \u22c6(\u2113) q ) of every Pj \u2208 W (\u2113) p,q and for every Pk \u2208 P. Furthermore, if any corrupt Pj \u2208 W (\u2113) p,q has ICSig(Pi, Pj , Pk, s \u2032(\u2113) q ) of any honest Pi \u2208 W (\u2113) p,q for any Pk \u2208 P, then s \u2032(\u2113) q = s\u22c6 (\u2113) q holds. Also, all the underlying IC-signatures will satisfy the linearity principle.\nProof. The proof follows very closely the proof of Lemma E.2. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. Now consider an arbitrary corrupt dealer P\u2113 \u2208 CD and an arbitrary Pi \u2208 H, such that Pi receives (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) from the broadcast of P\u2113 and includes (P\u2113, Sp) to Ci at time T . Now consider another arbitrary Pj \u2208 H, such that Pj 6= Pi. From the Zs-consistency and Zs-fallback consistency of \u03a0BC in the synchronous network, it follows that Pj is bound to receive (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) from the broadcast of P\u2113, latest by time T + \u2206. We wish to show that Pj will include (P\u2113, Sp) to Cj , by time T +\u2206. For this, we note that since Pi has included (P\u2113, Sp) to Ci at time T , all the following conditions hold for Pi at time T , for q = 1, . . . , |Zs|.\n\u2013 If q \u2208 BS(\u2113)p , then the set W (\u2113) p,q = Sq. \u2013 If (q 6\u2208 BS(\u2113)p ), then W (\u2113) p,q is either Sq or (Sp \u2229 Sq), such that:\n\u2013 If W (\u2113) p,q = Sq, then Sq constitutes a clique in G (\u2113,i).\n\u2013 Else if W (\u2113) p,q = (Sp \u2229 Sq), then (Sp \u2229 Sq) constitutes a clique in G(\u2113,i) and\nZs satisfies the Q(1)(Sp \u2229 Sq,Zs) condition. We claim that all the above conditions will hold even for Pj by time T +\u2206. This is because all the edges which are present in the consistency graph G(\u2113,i) at time T are bound to be present in the consistency graph G(\u2113,j) by time T +\u2206. This follows from the Zs-validity, Zs-consistency and Zs-fallback consistency of \u03a0BC in the synchronous network (see Theorem 3.2) and the fact that the edges in the graph G(\u2113,i) are based on OK(\u2113)(\u22c6, \u22c6) messages, which are received through various \u03a0BC instances.\nNext consider an arbitrary q 6\u2208 BS(\u2113)p . This implies that W (\u2113) p,q is set as (Sp\u2229Sq) and all the parties in (Sp \u2229 Sq) constitute a clique in the consistency graph of every party in H. From the properties of \u03a0SVM in the synchronous network, all honest parties in Sq compute a common output, say s \u22c6(\u2113) q , during the instance \u03a0SVM(P\u2113, s (\u2113) q , Sq). Next consider an arbitrary Pi \u2208 (H\u2229W (\u2113) p,q) and any arbitrary Pj \u2208 W (\u2113) p,q. This implies that Pi has broadcasted the message OK (\u2113)(i, j), after receiving ICSig(Pj , Pi, Pk, s (\u2113) qj ) from Pj , for every Pk \u2208 P , and verifying that the\nshare s (\u2113) qj is the same as the one, computed during the instance \u03a0\n(P\u2113,s (\u2113) q ,Sq) SVM .\nSince the share computed by Pi during \u03a0SVM(P\u2113, s (\u2113) q , Sq) is s \u22c6(\u2113) q , it follows that ICSig(Pj , Pi, Pk, s (\u2113) qj ) is the same as ICSig(Pj , Pi, Pk, s \u22c6(\u2113) q ). On the other hand, since Pi gives its IC-signature on s \u22c6(\u2113) q to every Pj \u2208 Sq, it follows that if any corrupt Pj \u2208 W (\u2113) p,q has ICSig(Pi, Pj , Pk, s \u2032(\u2113) q ) from Pi for any Pk \u2208 P , then s \u2032(\u2113) q = s\u22c6 (\u2113) q holds. The linearity of the underlying IC-signatures follow from the fact that the parties follow the linearity principle while generating the IC-signatures.\nNow based on the previous two lemmas, we show that in a synchronous network, all honest parties will output a \u201clegitimate\u201d set of parties CORE after time TSVM+TAuth+2TBC+6TBA, such that at least one honest party is present in CORE. And corresponding to every party in CORE, there exists some value, which is linearly secret-shared with IC-signatures. Moreover, the values corresponding to the honest parties remain private.\nLemma E.4. If the network is synchronous, then in \u03a0MDVSS, except with probability O(n3 \u00b7 \u01ebICP), at the time TMDVSS = TSVM+TAuth +2TBC+6TBA, all honest parties output a common set CORE, such that at least one honest party will be present in CORE. Moreover, corresponding to every P\u2113 \u2208 CORE, there exists some s\u22c6(\u2113), where s\u22c6(\u2113) = s(\u2113) for an honest P\u2113, which is the input of P\u2113 for \u03a0MDVSS, such that the values {s\u22c6\n(\u2113)}P\u2113\u2208CORE are linearly secret-shared with ICsignatures. Furthermore, if P\u2113 is honest, then adversary\u2019s view is independent of s(\u2113).\nProof. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. From Lemma E.1, except with probability O(n3 \u00b7 \u01ebICP), all the parties in H will have a common set of committed dealers CD by the time\nTSVM + 2TBA, where H \u2286 CD. Moreover, corresponding to every dealer P\u2113 \u2208 CD and every Sq \u2208 S|Zs|, every party in (H \u2229 Sq) will have a common share, say s\u22c6(\u2113)q , which is the same as s (\u2113) q , for an P\u2113. We begin by showing that once the set of committed dealers CD is decided, then all the |Zs| instances \u03a0 (1,\u22c6) BA of \u03a0BA and then all the |CD| instances \u03a0 (2,\u22c6) BA of \u03a0BA will produce some output, for all the parties in H, by time TMDVSS.\nConsider the set Sp \u2208 SZs , such that Sp = H. Then corresponding to each P\u2113 \u2208 (H \u2229 CD), every Pi \u2208 H will receive (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) from the broadcast of P\u2113 and includes (P\u2113, Sp) to Ci at time TSVM + 2TBA + TAuth + 2TBC (see Lemma E.2). Since P \\ H \u2208 Zs and H \u2286 CD, it follows that at the time TSVM + 2TBA + TAuth + 2TBC, every party Pi \u2208 H will have a set Ap,i (namely Ap,i = H), where CD \\ Ap,i \u2208 Zs and where (P\u2113, Sp) \u2208 Ci for every P\u2113 \u2208 Ap,i. Consequently, each Pi \u2208 H starts participating in the instance \u03a0 (1,p) BA with input 1, at the time TSVM + 2TBA + TAuth + 2TBC. From the Zs-security of \u03a0BA in the synchronous network (see Theorem 3.1), it follows that at the time TSVM+TAuth+2TBC+3TBA, every Pi \u2208 H obtains the output 1 from the instance \u03a0 (1,p) BA . Consequently, at the time TSVM + TAuth + 2TBC + 3TBA, every party in H will start participating in the remaining \u03a0 (1,\u22c6) BA instances for which no input has been provided yet (if there are any), with input 0. And from the Zs-security of \u03a0BA in the synchronous network, these\u03a0 (1,\u22c6) BA instances will produce common outputs, for every party in H, at the time TSVM + TAuth + 2TBC + 4TBA. As a result, at the time TSVM + TAuth +2TBC +4TBA, all the parties in H will compute a qcore. Moreover, qcore will be common for all the parties in H, since it corresponds to the leastindexed \u03a0 (1,\u22c6) BA instance among \u03a0 (1,1) BA , . . . , \u03a0 (1,|Zs|) BA , which produces output 1. And from the Zs-security of \u03a0BA in the synchronous network, each \u03a0 (1,q) BA instance produces a common output for every party in H. We also note that qcore will be indeed set to some value from the set {1, . . . , |Zs|}. This is because as shown above, the index p where Sp = H always constitute a candidate qcore.\nWe next claim that corresponding to Sqcore , there exists a subset of parties Bqcore , where CD \\ Bqcore \u2208 Zs, such that corresponding to every Pj \u2208 Bqcore , the ordered pair (Pj , Sqcore) is present in the set Ci of every Pi \u2208 H, at the time TSVM + TAuth + 2TBC + 4TBA. Assuming that the claim is true, it implies that all the parties in H will participate with input 1 in the instances \u03a0 (2,j) BA , corresponding to every Pj \u2208 Bqcore , at the time TSVM + TAuth +2TBC +4TBA. And hence from the Zs-security of the \u03a0BA in the synchronous network (Theorem 3.1), all the parties will obtain the output 1 in the\u03a0 (2,j) BA instances, corresponding to every Pj \u2208 Bqcore , at the time TSVM+TAuth+2TBC+5TBA. As a result, at time TSVM + TAuth + 2TBC + 5TBA, all the parties in H will start participating in the remaining \u03a0 (2,\u22c6) BA instances for which no input has been provided yet (if there are any), with input 0. Consequently, from the Zs-security of the \u03a0BA in the synchronous network (Theorem 3.1), at the time TMDVSS, all the parties in H will have some output from all the |CD| instances of \u03a0 (2,\u22c6) BA . Moreover, the outputs\nwill be common for all the parties in H. Furthermore, the parties in H will have a subset CORE, which corresponds to all the \u03a0 (2,j) BA instances, which have produced output 1. Note that (H \u2229 CORE) 6= \u2205. This is because Bqcore \u2286 CORE and H \u2286 CD. Consequently, (H \u2229 Bqcore) 6= \u2205, as otherwise Zs does not satisfy the Q(2)(P ,Zs) condition, which is a contradiction.\nWe next proceed to prove our claim. Since the instance\u03a0 (1,qcore) BA has produced output 1, it follows that at least one party from H, say Pk, have participated with input 1 in the instance \u03a0 (1,qcore) BA . This is because if all the parties in H participates with input 0 in the instance \u03a0 (1,qcore) BA , then from the Zs-validity of \u03a0BA in the synchronous network (Theorem 3.1), all the parties in H would have obtained the output 0 from the instance \u03a0 (1,qcore) BA , which is a contradiction. We also note that Pk would have started participating with input 1 in the instance \u03a0 (1,qcore) BA , latest by time TSVM + TAuth + 2TBC + 3TBA. This is because as argued above, by time TSVM+TAuth+2TBC+3TBA, all the parties in H would have started participating in all the |Zs| instances of \u03a0 (1,\u22c6) BA , with some input. Now since Pk has participated with input 1 in the instance \u03a0 (1,qcore) BA , it follows that at the time TSVM + TAuth + 2TBC + 3TBA, there exists a subset of parties Aqcore,k, where CD \\ Aqcore,k \u2208 Zs, such that (P\u2113, Sqcore) is present in the set Ck, corresponding to every P\u2113 \u2208 Aqcore,k. We show that the set Aqcore,k constitutes the candidate Bqcore . For this, note that for any P\u2113 \u2208 Aqcore,k, party Pk includes (P\u2113, Sqcore) to Ci, only after receiving a message (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from the broadcast of P\u2113 and verifying it. Moreover, Pk must have received the message (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from each P\u2113 \u2208 Aqcore,k, latest by time TSVM + TAuth + 2TBC + 3TBA. It then follows from Lemma E.4 that by time TSVM + TAuth + 2TBC + 3TBA + \u2206 < TSVM + TAuth + 2TBC + 4TBA, every party in H would have received (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from each P\u2113 \u2208 Aqcore,k. And hence each party Pi \u2208 H would include (P\u2113, Sqcore) to the set Ci, corresponding to every P\u2113 \u2208 Aqcore,k, by time TSVM +TAuth +2TBC+4TBA. This proves our claim.\nWe next claim that at the time TMDVSS, corresponding to every P\u2113 \u2208 CORE, every Pi \u2208 H would have received a message (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from the broadcast of P\u2113. The proof for this is very similar to the proof of the previous claim and relies on the properties of \u03a0BA. So consider an arbitrary P\u2113 \u2208 CORE. This implies that the instance \u03a0 (2,\u2113) BA has produced output 1 for all the parties in H, which further implies that at least one party from H, say Pm, has participated with input 1 during the instance \u03a0 (2,\u2113) BA . If not, then from the Zsvalidity of \u03a0BA in the synchronous network (Theorem 3.1), the instance \u03a0 (2,\u2113) BA would have produced output 0 for all the parties in H, which is a contradiction. We also note that Pm must have started participating in the instance \u03a0 (2,\u2113) BA , latest by time TSVM + TAuth + 2TBC + 5TBA. This is because as shown\nabove, by time TSVM + TAuth + 2TBC + 5TBA, all the parties in H would have started participating in all the |CD| instances of \u03a0 (2,\u22c6) BA , with some input. Now since Pm participates with input 1 in the instance \u03a0 (2,\u2113) BA , it follows that by time TSVM + TAuth + 2TBC + 5TBA, party Pm must have received a message (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from the broadcast of P\u2113 and included (P\u2113, Sqcore) to Cm. It then follows from Lemma E.4 that by time TSVM+TAuth+2TBC+5TBA+\u2206 < TSVM+TAuth+2TBC+6TBA, every party Pi in H would have received (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from P\u2113 and would include (P\u2113, Sqcore) to Ci.\nTill now we have shown that all the all the |Zs| instances \u03a0 (1,\u22c6) BA of \u03a0BA and then all the |CD| instances \u03a0 (2,\u22c6) BA of \u03a0BA will produce some output, for all the parties in H, by time TMDVSS. Moreover, at the time TMDVSS, all the parties in H will have a common qcore \u2208 {1, . . . , |Zs|} and a common set CORE \u2286 P , where CORE has at least one honest party. Furthermore, corresponding to every P\u2113 \u2208 CORE, each Pi \u2208 H would have received a message (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from the broadcast of P\u2113. Furthermore, from Lemma E.4, corresponding to each P\u2113 \u2208 CORE, the set W (\u2113) qcore,q will be either the set Sq or (Sqcore \u2229Sq), for q = 1, . . . , |Zs|. If W (\u2113) qcore,q = Sq for every P\u2113 \u2208 CORE, then all the parties in H will set Wq to Sq. On the other hand, ifW (\u2113) qcore,q = (Sqcore\u2229Sq) for any P\u2113 \u2208 CORE, then all the parties inH will set Wq to (Sqcore \u2229 Sq). Irrespective of the case, all the parties in H would set Wq to a common subset. We also note that irrespective of the case, Sq \\Wq \u2208 Za holds. This is because from Lemma E.4 and Lemma E.3, the condition Sq\\W (\u2113) qcore,q \u2208 Za holds, corresponding to every P\u2113 \u2208 CORE. Finally consider an arbitrary P\u2113 \u2208 CORE and an arbitrary Sq \u2208 SZs . We claim that at the time TMDVSS, all the parties in (H\u2229Sq) will have a common share, say s\u22c6(\u2113)q , where s \u22c6(\u2113) q = s (\u2113) q for an honest P\u2113. For this, we consider two possible cases. If q \u2208 BS(\u2113)qcore , then each Pi \u2208 (H\u2229Sq) would have received s (\u2113) q from the broadcast of P\u2113, as part of the (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) message. Consequently, in this case s\u22c6(\u2113)q is the same as s (\u2113) q , received from the broadcast of P\u2113. On the other hand, if q 6\u2208 BS (\u2113) qcore , then from Lemma E.3, each Pi \u2208 (H \u2229 Sq) would have a common share, say s(\u22c6) (\u2113) q ; moreover, from Lemma E.2, if P\u2113 is honest, then s (\u22c6)(\u2113) q = s (\u2113) q holds. We define\ns\u22c6(\u2113) def =\n\u2211\nq=1,...,|Zs|\ns(\u22c6) (\u2113)\nq ,\nwhere s\u22c6(\u2113) = s(\u2113) for an honest P\u2113. Hence at time TMDVSS, each party in (H \u2229 Sq) has [s \u22c6(\u2113)]q. We also note that if q \u2208 BS (\u2113) qcore , then every Pi \u2208 Wq sets ICSig(Pj , Pi, Pk, [s \u22c6(\u2113)]q) to the default value, corresponding to every Pj \u2208 Wq and every Pk \u2208 P . On the other hand, if q 6\u2208 BS (\u2113) qcore , then every Pi \u2208 (H\u2229Sq) will\nhave ICSig(Pj , Pi, Pk, s \u22c6(\u2113) q ) of every Pj \u2208 Wq and for every Pk \u2208 P . Furthermore, if any corrupt Pj \u2208 Wq has ICSig(Pi, Pj , Pk, s \u2032(\u2113) q ) of any Pi \u2208 (H \u2229 Sq) for any Pk \u2208 P , then s \u2032(\u2113) q = s\u22c6 (\u2113) q holds. Moreover, from Lemma E.3, if P\u2113 is honest, then s\u22c6(\u2113)q in the IC-signatures mentioned above will be the same as s (\u2113) q . It then follows that s\u22c6(\u2113) will be linearly secret-shared; the linearity of the underlying IC-signatures follows since the (honest) parties follow the linearity principle, while generating the IC-signatures.\nThe privacy of s(\u2113) for an honest P\u2113 follows from Lemma E.3.\nWe next consider an asynchronous network. We first prove an analogue of Lemma E.1 in the asynchronous network.\nLemma E.5. If the network is asynchronous and P\u2113 \u2208 P is an honest dealer participating with input s(\u2113), then all the following hold in \u03a0MDVSS, where H is the set of honest parties. \u2013 Except with probability O(n3 \u00b7 \u01ebICP), almost-surely, all the parties in H will\neventually have a common CD set, where P \\ CD \u2208 Zs. \u2013 Except with probability O(n3 \u00b7 \u01ebICP), corresponding to every dealer P\u2113 \u2208 CD\nand every Sq \u2208 S|Zs|, every party in (H\u2229Sq) will eventually have a common share, say s\u22c6(\u2113)q , which is the same as s (\u2113) q , for an honest P\u2113.\nProof. Let Z\u22c6 \u2208 Za be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. Note that H \u2208 SZs , since Za \u2282 Zs. From the properties of \u03a0SVM in the asynchronous network (Lemma 6.3), it follows that every Pi \u2208 H will eventually set flag (P\u2113,Sq) to 1 during the instance \u03a0SVM(P\u2113, s (\u2113) q , Sq), corresponding to every P\u2113 \u2208 H and every Sq \u2208 SZs . Moreover, corresponding to every P\u2113 \u2208 H and every Sq \u2208 SZs , each Pi \u2208 (H \u2229 Sq) eventually computes an output s (\u2113) qi during the instance \u03a0SVM((P\u2113, s (\u2113) q , Sq). Furthermore, except with probability O(n3 \u00b7 \u01ebICP), the value s (\u2113) qi will be the same as s (\u2113) q .\nWe first claim that there always exists a subset of parties D, where P\\D \u2208 Zs, such that the \u03a0BA instance \u03a0 (\u2113) BA eventually produces output 1 for all the parties in H, corresponding to every P\u2113 \u2208 D. Assuming that the claim is true, it implies that all the parties in H will eventually participate with some input in the \u03a0BA instances \u03a0\n(1) BA , . . . , \u03a0 (n) BA . This is because from the protocol steps, once the \u03a0 (\u22c6) BA\ninstances corresponding to the parties in D produce output 1, all the parties in H will start participating with input 0 in the remaining instances \u03a0 (\u22c6) BA of \u03a0BA (if any), for which no input has been provided yet. And hence from the Za-security of \u03a0BA in the asynchronous network, it follows that almost-surely, all these \u03a0BA instances will eventually produce some output for all the parties in H. Moreover, the outputs will be the same for all the parties in H. Consequently, all the parties in H will eventually obtain a common CD set. Moreover, P \\ CD \u2208 Zs, since CD consists of all those parties P\u2113, such that the instance \u03a0 (\u2113) BA produces output 1. And according to our claim, D \u2286 CD holds. We now proceed to prove our claim. There are two possible cases. Consider the case when some Pi \u2208 H starts participating with input 0 in any \u03a0 (\u22c6) BA instance. This implies that for Pi, there\nexists a subset of parties CDi where P \\ CDi \u2208 Zs, such that corresponding to every P\u2113 \u2208 CDi, the instance \u03a0 (\u2113) BA has produced output 1 for Pi. In this case, the set CDi is the candidate D set, whose existence we want to prove. Next, consider the case when no party in H has started participating with input 0 in any of the \u03a0 (\u22c6) BA instances. In this case, the set H constitutes the candidate D set. This is because as shown above, every Pi \u2208 H will eventually set flag (P\u2113,Sq) to 1, corresponding to every P\u2113 \u2208 H and every Sq \u2208 SZs . And hence every Pi \u2208 H will eventually start participating with input 1 in the \u03a0 (\u2113) BA instances, corresponding to P\u2113 \u2208 H. Consequently, the Zs-validity of \u03a0BA in the asynchronous network (Theorem 3.1) will guarantee that the \u03a0 (\u2113) BA instances, corresponding to P\u2113 \u2208 H eventually produce output 1 for all the parties in H. Next, consider an arbitrary P\u2113 \u2208 CD. This implies that at least one party from H, say Pk, has participated with input 1 during the instance \u03a0 (\u2113) BA . If not, then from the Zs-validity of \u03a0BA in the asynchronous network (Theorem 3.1), all the parties in H would have obtained the output 0 from the instance \u03a0 (\u2113) BA and hence P\u2113 6\u2208 CD, which is a contradiction. This implies that party Pk has set flag(P\u2113,Sq) to 1 during the instance \u03a0SVM(P\u2113, s (\u2113) q , Sq), for q = 1, . . . , |Zs|. So consider an arbitrary Sq \u2208 SZs . From the properties of\u03a0SVM in the asynchronous network (Lemma 6.3), it follows that there exists some value s\u22c6(\u2113)q , which is the same as s (\u2113) q for an honest P\u2113, such that except with probability O(n3 \u00b7 \u01ebICP), all the parties in H eventually output s\u22c6(\u2113)q during the instance \u03a0SVM(P\u2113, s (\u2113) q , Sq).\nWe next prove the analogue of Lemma E.2 in the asynchronous network.\nLemma E.6. If the network is asynchronous and P\u2113 \u2208 CD is an honest dealer participating with input s(\u2113), then all the following hold in \u03a0MDVSS except with probability O(n3 \u00b7 \u01ebICP), where H is the set of honest parties.\n\u2013 If Sp = H, then P\u2113 will eventually broadcast (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,\nBS(\u2113)p , {s (\u2113) q }q\u2208BS(\u2113)p ).\n\u2013 If P\u2113 broadcasts any (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p )\nthen every honest Pi \u2208 P will eventually include (P\u2113, Sp) to Ci. Moreover, the following will hold. \u2013 If Sq = H, then q 6\u2208 BS (\u2113) p . \u2013 For q = 1, . . . , |Zs|, each W (\u2113) p,q will be either Sq or (Sp \u2229 Sq) such that Zs\nsatisfies the Q(1)(W (\u2113) p,q,Zs) condition.\n\u2013 If q 6\u2208 BS(\u2113)p , then every honest Pi \u2208 Sq will have the share s (\u2113) q . Moreover,\nevery honest Pi \u2208 W (\u2113) p,q will have ICSig(Pj , Pi, Pk, s (\u2113) q ) of every Pj \u2208 W (\u2113) p,q for every Pk \u2208 P. Furthermore, if any corrupt Pj \u2208 W (\u2113) p,q have ICSig(Pi, Pj , Pk, s \u2032(\u2113) q ) of any honest Pi \u2208 W (\u2113) p,q for any Pk \u2208 P, then s \u2032(\u2113) q = s (\u2113) q holds. Also, all the underlying IC-signatures will satisfy the\nlinearity property. \u2013 The view of the adversary will be independent of s(\u2113).\nProof. Let Z\u22c6 \u2208 Za be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. We first note that H \u2208 SZs , since Z\n\u22c6 \u2208 Zs as Za \u2282 Zs. The proof for the first part of the lemma is similar to the proof of the first part of Lemma E.2, except that all the \u201cfavourable\u201d conditions hold for an honest P\u2113 eventually. In more detail, consider an arbitrary Sq \u2208 SZs . Then each Pi \u2208 (Sq \u2229 H) eventually computes the share s (\u2113) qi during the instance \u03a0SVM(P\u2113, s (\u2113) q , Sq), where s (\u2113) qi = s (\u2113) q holds, except with probability O(n3 \u00b7 \u01ebICP). Consequently, Pi starts giving ICSig(Pi, Pj , Pk, s (\u2113) qi ) to every Pj \u2208 Sq, for every Pk \u2208 P . Then from the Za-correctness of \u03a0Auth in the asynchronous network (Theorem 4.1), it follows that each party Pi \u2208 (Sq\u2229H) will eventually receive ICSig(Pj , Pi, Pk, s (\u2113) qj ) from every Pj \u2208 (Sq \u2229 H), for every Pk \u2208 P , such that s (\u2113) qj = s (\u2113) qi = s (\u2113) q holds. Since Sq is arbitrary, it follows that eventually, every party Pi \u2208 H broadcasts an OK(\u2113)(i, j) message, corresponding to every Pj \u2208 H. From the Za-weak validity and Za-fallback validity of \u03a0BC in the asynchronous network (Theorem 3.2), it follows that these OK(\u2113)(i, j) messages are eventually received by every party in H. Consequently, the set H eventually becomes a clique in the consistency graph G(\u2113,i) of every party Pi \u2208 H. Let Sp be the set from SZs , such that Sp = H. From the protocol steps, it then follows that the dealer P\u2113 will eventually compute core-sets W (\u2113) p,q for q = 1, . . . , |Zs| and broadcast-set BS (\u2113) p with respect to Sp as follows,\n\u2013 If Sq constitutes a clique in the graph G (\u2113,\u2113), then W (\u2113) p,q is set as Sq. \u2013 Else if (Sp \u2229 Sq) constitutes a clique in G(\u2113,\u2113) and Zs satisfies the Q(1)(Sp \u2229\nSq,Zs) condition, then W (\u2113) p,q is set as (Sp \u2229 Sq).\n\u2013 Else W (\u2113) p,q is set to Sq and q is included to BS (\u2113) p .\nAfter computing the core-sets and broadcast-set, P\u2113 will eventually broadcast (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ).\nWe next proceed to prove the second part of the lemma, whose proof is again similar to the proof of the second part of the Lemma E.2, except that all the \u201cfavourable\u201d conditions which hold for P\u2113, are guaranteed to hold eventually for all the parties in H. In more detail, consider an arbitrary Sp \u2208 SZs , such that P\u2113 compute core-sets W (\u2113) p,q for q = 1, . . . , |Zs| and broadcast-set BS (\u2113) p with respect to Sp and broadcasts (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ). This means the parties in Sp constitute a clique in the graph G (\u2113,\u2113). We note that all the edges which are present in the graph G(\u2113,\u2113) when Sp constitute a clique in G(\u2113,\u2113) are bound to be eventually included in the graph G(\u2113,i) of every party Pi \u2208 H. This is because the edges are included by P\u2113 based on various OK(\u2113)(\u22c6, \u22c6) messages, which are received by P\u2113 through various \u03a0BC instances. Consequently, due to the various properties of \u03a0BC in the asynchronous network, these OK(\u2113)(\u22c6, \u22c6) messages are bound to be eventually delivered to every party in H. As a result, all the properties which hold for P\u2113 in the graph G(\u2113,\u2113) when Sp constitute a clique in G (\u2113,\u2113) are bound to hold eventually for every\nPi \u2208 H in the graph G(\u2113,\u2113). Since P\u2113 is assumed to be honest, it computes the sets {W (\u2113) p,q}q=1,...,|Zs| and BS (\u2113) p , satisfying the following properties.\n\u2013 If Sq constitutes a clique in the graph G (\u2113,\u2113), then W (\u2113) p,q is set as Sq. \u2013 Else if (Sp \u2229 Sq) constitutes a clique in G(\u2113,\u2113) and Zs satisfies the Q(1)(Sp \u2229\nSq,Zs) condition, then W (\u2113) p,q is set as (Sp \u2229 Sq).\n\u2013 Else W (\u2113) p,q is set to Sq and q is included to BS (\u2113) p .\nWe also note that if Sq = H, then q 6\u2208 BS (\u2113) p and consequently, P\u2113 will not make the share s (\u2113) q public. This is because P\u2113 will set W (\u2113) p,q to (Sp\u2229Sq). In more detail, the parties in (Sp \u2229 Sq) will constitute a clique in G(\u2113,\u2113), since Sp constitutes a clique in G(\u2113,\u2113), when P\u2113 starts computing the core-sets {W (\u2113) p,q}q=1,...,|Zs|. Moreover, Zs will satisfy the Q(1)(Sp\u2229Sq ,Zs) condition, due to the Q(2,1)(P ,Zs,Za) condition.\nSince P\u2113 is honest, from the Za-weak validity and Za-fallback validity of \u03a0BC in the asynchronous network (see Theorem 3.2), it follows that all the parties inH will eventually receive (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) from the broadcast of P\u2113. Moreover, each party Pi \u2208 H will eventually include (P\u2113, Sp) to the set Ci. This is because since P\u2113 has computed the sets {W (\u2113) p,q}q=1,...,|Zs| and BS (\u2113) p honestly, these sets will eventually pass all the verifications for each Pi \u2208 H. The last statement is true because as shown above, all the properties which hold for P\u2113 in the graph G\n(\u2113,\u2113) when Sp constitute a clique in G(\u2113,\u2113) are bound to hold eventually for every Pi \u2208 H in the graph G (\u2113,\u2113).\nThe proof for the rest of the properties stated in the lemma is similar to that of Lemma E.2, except that we now rely on the security properties of ICP in the asynchronous network; to avoid repetition we do not produce the details here. The linearity of the underlying IC-signatures is ensured since the parties follow the linearity principle while generating the IC-signatures.\nWe next prove an analogue of Lemma E.3 in the asynchronous network.\nLemma E.7. If the network is asynchronous and if in \u03a0MDVSS any honest party Pi receives (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) from the broadcast of any corrupt dealer P\u2113 \u2208 CD and includes (P\u2113, Sp) to Ci, then all honest parties Pj will eventually receive (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) from the broadcast of P\u2113 and include (P\u2113, Sp) to Cj. Moreover, for q = 1, . . . , |Zs|, the following holds, except with probability O(n3 \u00b7 \u01ebICP).\n\u2013 W (\u2113) p,q is either Sq or (Sp \u2229 Sq). Moreover, Zs satisfies the Q(1)(W (\u2113) p,q,Zs)\ncondition. \u2013 If q 6\u2208 BS(\u2113)p , then every honest Pi \u2208 Sq will have a common share, say\ns\u22c6(\u2113)q . Moreover, every honest Pi \u2208 W (\u2113) p,q will have ICSig(Pj , Pi, Pk, s \u22c6(\u2113) q ) of every Pj \u2208 W (\u2113) p,q for every Pk \u2208 P. Furthermore, if any corrupt Pj \u2208 W (\u2113) p,q has ICSig(Pi, Pj , Pk, s \u2032(\u2113) q ) of any honest Pi \u2208 W (\u2113) p,q for any Pk \u2208 P, then\ns \u2032(\u2113) q = s\u22c6 (\u2113) q holds. Also, all the underlying IC-signatures will satisfy the linearity property.\nProof. The proof is very similar to the proof of Lemma E.3, except that we now rely on the properties of \u03a0BC in the asynchronous network. Let Z\n\u22c6 \u2208 Za be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. Now consider an arbitrary corrupt dealer P\u2113 \u2208 CD and an arbitrary Pi \u2208 H, such that Pi receives (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) from the broadcast of P\u2113 and includes (P\u2113, Sp) to Ci. Now consider another arbitrary Pj \u2208 H, such that Pj 6= Pi. From the Za-weak consistency and Za-fallback consistency of \u03a0BC in the asynchronous network, it follows that Pj is bound to eventually receive (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) from the broadcast of P\u2113. We wish to show that Pj will eventually include (P\u2113, Sp) to Cj . For this, we note that since Pi has included (P\u2113, Sp) to Ci, all the following conditions hold for Pi, for q = 1, . . . , |Zs|.\n\u2013 If q \u2208 BS(\u2113)p , then the set W (\u2113) p,q = Sq. \u2013 If (q 6\u2208 BS(\u2113)p ), then W (\u2113) p,q is either Sq or (Sp \u2229 Sq), such that:\n\u2013 If W (\u2113) p,q = Sq, then Sq constitutes a clique in G (\u2113,i). \u2013 Else if W (\u2113) p,q = (Sp \u2229 Sq), then (Sp \u2229 Sq) constitutes a clique in G(\u2113,i) and\nZs satisfies the Q(1)(Sp \u2229 Sq,Zs) condition. We claim that all the above conditions will hold eventually even for Pj . This is because all the edges which are present in the consistency graph G(\u2113,i) when Pi includes (P\u2113, Sp) to Ci are bound to be eventually present in the consistency graph G(\u2113,j). This follows from the Za-weak validity, Za-fallback validity, Zaweak consistency and Za-fallback consistency of \u03a0BC in the asynchronous network (see Theorem 3.2) and the fact that the edges in the graph G(\u2113,i) are based on OK(\u2113)(\u22c6, \u22c6) messages, which are received through various \u03a0BC instances. The proof regarding the IC-signatures is exactly the same as Lemma E.3 and\nto avoid repetition, we do not produce the formal details here.\nFinally, based on the previous two lemmas, we prove an analogue of Lemma E.4 and show that in an asynchronous network, all honest parties will eventually output a \u201clegitimate\u201d set of parties CORE.\nLemma E.8. If the network is asynchronous, then in \u03a0MDVSS, except with probability O(n3 \u00b7 \u01ebICP), almost-surely all honest parties eventually output a common set CORE, such that at least one honest party will be present in CORE. Moreover, corresponding to every P\u2113 \u2208 CORE, there exists some s\u22c6 (\u2113), where s\u22c6(\u2113) = s(\u2113) for an honest P\u2113, which is the input of P\u2113 for \u03a0MDVSS, such that the values {s\u22c6(\u2113)}P\u2113\u2208CORE are linearly secret-shared with IC-signatures. Furthermore, if P\u2113 is honest, then the adversary\u2019s view is independent of s(\u2113).\nProof. The proof structure is very similar to that of Lemma E.4, except that we now rely on the properties of \u03a0BA and \u03a0BC in the asynchronous network and Lemma E.5-E.7. Let Z\u22c6 \u2208 Za be the set of corrupt parties and let H = P \\Z\u22c6 be\nthe set of honest parties. From Lemma E.5, except with probability O(n3 \u00b7 \u01ebICP), almost-surely all the parties inH will eventually have a common set of committed dealers CD, where P\\CD \u2208 Zs. Moreover, corresponding to every dealer P\u2113 \u2208 CD and every Sq \u2208 S|Zs|, every party in (H \u2229 Sq) will eventually have a common share, say s\u22c6(\u2113)q , which is the same as s (\u2113) q , for an P\u2113. We begin by showing that once the set of committed dealers CD is decided, then almost-seurely, all the |Zs| instances \u03a0 (1,\u22c6) BA of \u03a0BA and then all the |CD| instances \u03a0 (2,\u22c6) BA of \u03a0BA will eventually produce some output, for all the parties in H.\nWe first claim that irrespective of way messages are scheduled and the order in which the parties in H participate in various \u03a0 (1,\u22c6) BA instances, there will be some instance \u03a0 (1,p) BA corresponding to some Sp \u2208 SZs , which will eventually produce output 1 for all the parties in H. For this, consider the set Sp \u2208 S|Zs|, such that Sp = H (such an Sp is bound to exist since Z\u22c6 \u2208 Zs also holds, as Za \u2282 Zs). If there exists some Pi \u2208 H which starts participating with input 0 in the instance \u03a0 (1,p) BA , then the claim is true, because Pi participates with input 0 during \u03a0 (1,p) BA , only after receiving the output 1 from some other instance of \u03a0 (1,\u22c6) BA , say \u03a0 (1,q) BA . And hence from the Za-consistency of \u03a0BA in the asynchronous network (Theorem 3.1), all the parties in H will eventually obtain the output 1 from the instance \u03a0 (1,q) BA , thus proving our claim. On the other hand, consider the case when no party has yet started participating with any input in the instance \u03a0 (1,p) BA . Then corresponding to each P\u2113 \u2208 (H\u2229CD), every Pi \u2208 H will eventually receive (CanCS, P\u2113, Sp, {W (\u2113) p,q}q=1,...,|Zs|,BS (\u2113) p , {s (\u2113) q }q\u2208BS(\u2113)p ) from the broadcast of P\u2113 and includes (P\u2113, Sp) to Ci (see Lemma E.6). Since CD \\ H \u2286 Z\u22c6 and Z\u22c6 \u2208 Zs (due to condition Zs \u2282 Za), it follows that every party Pi \u2208 H will eventually have a set Ap,i (namely Ap,i = H), where CD \\ Ap,i \u2208 Zs and where (P\u2113, Sp) \u2208 Ci for every P\u2113 \u2208 Ap,i. Consequently, each Pi \u2208 H will eventually start participating in the instance \u03a0 (1,p) BA with input 1, if they have not done so. And from the Zs-validity of \u03a0BA in the asynchronous network (see Theorem 3.1), it follows that all the parties in H eventually obtain the output 1 from the instance \u03a0 (1,p) BA , thus proving our claim in this case as well.\nNow from the above claim, it follows that every party in H will eventually start participating in the remaining \u03a0 (1,\u22c6) BA instances for which no input has been provided yet (if there are any), with input 0. And from the Za-security of \u03a0BA in the asynchronous network, almost-surely, these \u03a0 (1,\u22c6) BA instances will eventually produce common outputs, for every party in H. As a result, all the parties in H will eventually compute a qcore \u2208 {1, . . . , |Zs|}. Moreover, qcore will be common for all the parties in H, since it corresponds to the least-indexed \u03a0 (1,\u22c6) BA instance among \u03a0 (1,1) BA , . . . , \u03a0 (1,|Zs|) BA , which produces output 1. And from the Za-security of \u03a0BA in the asynchronous network, each \u03a0 (1,\u22c6) BA instance produces a common output for every party in H. We also note that qcore will be indeed set to some value from the set {1, . . . , |Zs|}. This is because as shown above, the index p where Sp = H always constitute a candidate qcore.\nWe next claim that corresponding to Sqcore \u2208 SZs , there exists a subset of parties Bqcore , where CD\\Bqcore \u2208 Zs, such that corresponding to every Pj \u2208 Bqcore , the ordered pair (Pj , Sqcore) is eventually included in the set Ci of every Pi \u2208 H. Assuming that the claim is true, we next show that there always exists a set of parties B where CD \\ B \u2208 Zs, such that the \u03a0 (2,j) BA instance eventually produce output 1 for all the parties in H, corresponding to every Pj \u2208 B. For this, we consider two possible cases. If any Pi \u2208 H has started participating with input 0 in any instance \u03a0 (2,\u22c6) BA , then it implies that for Pi, there exists a subset Bi where CD \\ Bi \u2208 Zs and where corresponding to each Pj \u2208 Bi, the instance \u03a0 (2,j) BA has produced output 1. Hence from the Za-consistency of \u03a0BA in the asynchronous network (see Theorem 3.1), all these \u03a0 (2,j) BA instances will eventually produce output 1 for all the parties in H. On the other hand, consider the case when no party in H has started participating with input 0 in any instance \u03a0 (2,\u22c6) BA . Then as per the claim, all the parties in H will eventually start participating with input 1 in the instances \u03a0 (2,j) BA , corresponding to every Pj \u2208 Bqcore . Hence from the Za-security of the \u03a0BA in the synchronous network (Theorem 3.1), all the parties will eventually obtain the output 1 in the \u03a0 (2,j) BA instances, corresponding to every Pj \u2208 Bqcore . Thus irrespective of the case, the set B is guaranteed. As a result, all the parties in H will eventually start participating in the remaining \u03a0 (2,\u22c6) BA instances for which no input has been provided yet (if there are any), with input 0. Consequently, from the Za-security of the \u03a0BA in the asynchronous network (Theorem 3.1), almost-surely, all the parties in H will eventually have some output from all the |CD| instances of \u03a0 (2,\u22c6) BA . Moreover, the outputs will be common for all the parties in H. Furthermore, the parties in H will have a subset CORE, which corresponds to all the \u03a0 (2,j) BA instances, which produces output 1. Note that CD\\CORE \u2208 Zs holds, since we have shown that the \u03a0 (2,j) BA instances, corresponding to the parties Pj \u2208 B will produce output 1, implying B \u2286 CORE. And CD \\B \u2208 Zs holds. Now since P \\ CD \u2208 Zs and CD \\CORE \u2208 Zs, it follows that (H \u2229 CORE) 6= \u2205, since the Q(2,1)(P ,Zs,Za) condition is satisfied.\nWe next proceed to prove our claim about the existence of Bqcore . Since the instance \u03a0 (1,qcore) BA has produced output 1, it follows that at least one party from H, say Pk, must have participated with input 1 in the instance \u03a0 (1,qcore) BA . This is because if all the parties in H participates with input 0 in the instance \u03a0 (1,qcore) BA , then from the Za-validity of \u03a0BA in the asynchronous network (Theorem 3.1), all the parties in H would have obtained the output 0 from the instance \u03a0 (1,qcore) BA , which is a contradiction. Now since Pk has participated with input 1 in the instance \u03a0 (1,qcore) BA , it follows there exists a subset of parties Aqcore,k, where CD \\ Aqcore,k \u2208 Zs, such that (P\u2113, Sqcore) is present in the set Ck, corresponding to every P\u2113 \u2208 Aqcore,k. We show that the set Aqcore,k constitutes the candidate Bqcore . For this, note that for any P\u2113 \u2208 Aqcore,k, party Pk includes (P\u2113, Sqcore) to Ci, only after receiving a message (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from the broadcast of P\u2113 and verifying it. It then follows from Lemma E.8 that eventually, every party in H would have received\n(CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from each P\u2113 \u2208 Aqcore,k. Hence each party Pi \u2208 H would eventually include (P\u2113, Sqcore) to the set Ci, corresponding to every P\u2113 \u2208 Aqcore,k.\nWe next claim that corresponding to every P\u2113 \u2208 CORE, every Pi \u2208 H eventually receives a message (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from the broadcast of P\u2113. The proof for this is very similar to the proof of the previous claim and relies on the properties of \u03a0BA in the asynchronous network. So consider an arbitrary P\u2113 \u2208 CORE. This implies that the instance \u03a0 (2,\u2113) BA have produced output 1, which further implies that at least one party from H, say Pm, have participated with input 1 during the instance \u03a0 (2,\u2113) BA . If not, then from the Za-validity of \u03a0BA in the asynchronous network (Theorem 3.1), the instance \u03a0 (2,\u2113) BA would have produced output 0, which is a contradiction. Now since Pm participates with input 1 in the instance \u03a0 (2,\u2113) BA , it follows that Pm must have received a message (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from the broadcast of P\u2113 and included (P\u2113, Sqcore) to Cm. It then follows from Lemma E.8 that eventually, every party Pi in H would receive (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from P\u2113 and includes (P\u2113, Sqcore) to Ci.\nTill now we have shown that almost-surely, all the |Zs| instances \u03a0 (1,\u22c6) BA of \u03a0BA and then all the |CD| instances \u03a0 (2,\u22c6) BA of \u03a0BA will eventually produce some output, for all the parties in H. Moreover, all the parties in H will eventually have a common qcore \u2208 {1, . . . , |Zs|} and a common set CORE \u2286 P , where CORE has at least one honest party. Furthermore, corresponding to every P\u2113 \u2208 CORE, each Pi \u2208 H would eventually received a message (CanCS, P\u2113, Sqcore , {W (\u2113) qcore,q}q=1,...,|Zs|,BS (\u2113) qcore , {s (\u2113) q }q\u2208BS(\u2113)qcore ) from the broadcast of P\u2113. The rest of the proof will be now same as Lemma E.4, except that we now rely on Lemma E.6 and Lemma E.7. To avoid repetition, we do not produce the formal details here.\nWe finally derive the communication complexity of the protocol.\nLemma E.9. Protocol \u03a0MDVSS incurs a communication of O(|Zs| 2 \u00b7n9 \u00b7 log |F| \u00b7 |\u03c3|) bits. In addition, O(|Zs|+ n) instances of \u03a0BA are invoked.\nProof. The number of \u03a0BA instances follows easily from the protocol inspection. The communication complexity of the protocol is dominated by the instances of \u03a0SVM and \u03a0Auth invoked in the protocol. There are O(|Zs| \u00b7n) instances of \u03a0SVM and O(|Zs| \u00b7n\n4) instances of \u03a0Auth invoked. The communication complexity now follows from the communication complexity of \u03a0SVM (Lemma 6.3) and \u03a0Auth (Theorem 4.1).\nTheorem 7.1 now follows from Lemma E.4, Lemma E.8 and Lemma E.9."
        },
        {
            "heading": "F Properties of the Triple-Generation Protocol",
            "text": "In this section, we prove the properties of the triple-generation protocol and related sub-protocols.\nF.1 Properties of the Protocol \u03a0LSh\nWe first prove the properties of the protocol \u03a0LSh (see Fig 10 for the formal description).\nLemma 8.1. Let r be a random value which is linearly secret-shared with IC-signatures with GW1, . . . ,GW |Zs| being the underlying core-sets. Then protocol \u03a0LSh achieves the following where D participates with the input s. \u2013 If D is honest, then the following hold, where TLSh = TRec + TBC.\n\u2013 Zs-Correctness: If the network is synchronous, then except with probability O(n3 \u00b7 \u01ebICP), the honest parties output [s] at the time TLSh, with GW1, . . . ,GW |Zs| being the underlying core-sets. \u2013 Za-Correctness: If the network is asynchronous, then except with probability O(n3 \u00b7 \u01ebICP), the honest parties eventually output [s], with GW1, . . . ,GW |Zs| being the underlying core-sets. \u2013 Privacy: Irrespective of the network type, the view of the adversary remains independent of s.\n\u2013 If D is corrupt then either no honest party computes any output or there exists some value, say s\u22c6, such that the following hold. \u2013 Zs-Commitment: If the network is synchronous, then except with prob-\nability O(n3 \u00b7 \u01ebICP), the honest parties output [s\u22c6], with GW1, . . . ,GW |Zs| being the underlying core-sets. Moreover, if any honest party computes its output at the time T , then all honest parties will have their respective output by the time T +\u2206.\n\u2013 Za-Commitment: If the network is asynchronous, then except with probability O(n3 \u00b7 \u01ebICP), the honest parties eventually output [s\n\u22c6], with GW1, . . . ,GW |Zs| being the underlying core-sets.\n\u2013 Communication Complexity: O(|Zs| \u00b7n3 \u00b7 log |F|+n4 \u00b7 log |F| \u00b7 |\u03c3|) bits are communicated by the honest parties.\nProof. Let us first consider an honest dealer. Moreover, we consider a synchronous network. Form the Zs-correctness of \u03a0Rec in the synchronous network (Lemma 6.2), after time TRec, the dealer D will reconstruct r, except with probability O(n3 \u00b7\u01ebICP). Moreover, from the privacy property of \u03a0Rec, r will be random from the point of the view of the adversary. Since D is honest, from the Zs-validity of \u03a0BC in the synchronous network (Theorem 3.2), all honest parties will receive s from the broadcast of D at the time TRec + TBC, where s = s+ r. The parties then take the default linear secret-sharing [s] of s with the IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. Since r is also linearly secretshared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets, from the linearity property of the secret sharing, it follows that [s\u2212r] will be the\nsame as a linear secret-sharing of s with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. This proves the Zs-correctness. The privacy of s follows since r remains random for the adversary and hence s does not reveal any information about s to the adversary. The Za-correctness and privacy for an honest dealer in an asynchronous network follows using similar arguments as above, except that we now rely on the Za-correctness of \u03a0Rec in the asynchronous network (Lemma 6.2) and the Za-validity of \u03a0BC in the asynchronous network (Theorem 3.2).\nWe next consider a corrupt dealer and a synchronous network. Let Ph be the first honest party which computes some output in the protocol, at the time T . This implies that Ph has received some value s from the broadcast of D. From the Zs-consistency and Zs-fallback consistency of \u03a0BC in the synchronous network (Theorem 3.2), it follows that all the honest parties will receive s from the broadcast of D, latest by the time T +\u2206. We define\ns\u22c6 def = s\u2212 r.\nSince the (honest) parties take the default linear secret-sharing [s] of s with the IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets and since r is also linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets, from the linearity property of the secret sharing, it follows that [s \u2212 r] will be the same as a linear secret-sharing of s\u22c6 with ICsignatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. This completes the proof of the Zs-commitment in the synchronous network. The proof of the Za-commitment in the asynchronous network is similar as above, except that we now rely on the Za-weak consistency and Za-fallback consistency of \u03a0BC in the asynchronous network (Theorem 3.2) and Za-correctness of \u03a0Rec in the asynchronous network (Lemma 6.2).\nIn the protocol, one instance of \u03a0Rec with |R| = 1 and one instance of \u03a0BC with \u2113 = log |F| bits are invoked. The communication complexity now follows from the communication complexity of \u03a0Rec (Lemma 6.2) and communication complexity of \u03a0BC (Theorem 3.2).\nF.2 Properties of the Protocol \u03a0BasicMult\nIn this section, we prove the properties of the protocol \u03a0BasicMult (see Fig 11 for the formal details). While proving these properties, we will assume that no honest party is present in the set GD; looking ahead, this will be ensured in the protocol \u03a0RandMultCI (presented in Section 8.3), where the set GD is maintained.\nWe begin by showing that no summand-sharing party during the first two phases are from the discarded set of parties.\nLemma 8.2. During any instance \u03a0BasicMult(Zs,Za, SZs , [a], [b],GW1, . . . , GW |Zs|,GD, iter) of \u03a0BasicMult, if Pj \u2208 Selectediter then Pj 6\u2208 GD, irrespective of the network type.\nProof. Let Pj be an arbitrary party belonging to the set Selectediter. This implies that Pj is included to Selectediter, either during Phase I or Phase II. If Pj \u2208 GD, then no honest party will participate with input 1 in the instance \u03a0 (phI,hop,j) BA during Phase I for any value of hop and instance \u03a0 (phII,j) BA during Phase II. Consequently, from the Zs-validity and Za-validity of \u03a0BA (Theorem 3.1), party Pj will not be added to Selectediter, which is a contradiction.\nWe next show that the first phase will get over for the honest parties after a fixed time in a synchronous network and eventually in an asynchronous network. Towards this we show that if the honest parties start any hop during the first phase, then they will complete it after a fixed time in a synchronous network and eventually in an asynchronous network.\nLemma 8.3. Suppose that no honest party is present in GD. If the honest parties start participating during hop number hop of Phase I of \u03a0BasicMult with iteration number iter, then except with probability O(n3 \u00b7 \u01ebICP), the hop takes TLSh + 2TBA time to complete in a synchronous network, or almost-surely completes eventually in an asynchronous network.\nProof. Let Z\u22c6 be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. We note that since Za \u2282 Zs, irrespective of the network type, there exists some set in SZs , say Sh, such that Sh \u2208 SZs . Since the honest parties participate in hop number hop, it implies that there exists no Sq \u2208 SZs , such that SIS (Sq) iter = \u2205. Particularly, this implies that SIS (Sh) iter 6= \u2205. Hence there exists some Pj \u2208 H, such that Pj /\u2208 Selectediter. This is because if H \u2286 Selectediter, then clearly SIS (Sh) iter = \u2205 and hence the parties in H will not participate in hop number hop. Let us first consider a synchronous network. During the hop number hop,\nevery Pj \u2208 H such that Pj /\u2208 Selectediter will invoke an instance of \u03a0LSh with the input c (j) iter. Then from the Zs-correctness of \u03a0LSh in the synchronous network (Lemma 8.1), after time TLSh, the parties in H output [c (j) iter], except with probability O(n3 \u00b7 \u01ebICP). Since (H \u2229 GD) = \u2205, all the parties in H will participate in the instance \u03a0 (phI,hop,j) BA with input 1. Hence from the Zs-validity of \u03a0BA in the synchronous network (Theorem 3.1), all the parties in H output 1 during the instance \u03a0 (phI,hop,j) BA , after time TLSh + TBA. Consequently, the parties in H start participating with input 0 in the remaining \u03a0BA instances \u03a0 (phI,hop,k) BA (if any), for which no input is provided yet. Hence from the Zs-security of \u03a0BA in the synchronous network, at the time TLSh + 2TBA, the parties in H compute some output during the \u03a0BA instances invoked during hop number hop and hence complete the hop number hop.\nNext, consider an asynchronous network. From the Za-correctness of \u03a0LSh in the asynchronous network (Lemma 8.1), corresponding to every Pj \u2208 H such that Pj /\u2208 Selectediter, the parties in H eventually output [c (j) iter], except with probability O(n3 \u00b7 \u01ebICP), during the instance \u03a0 (phI,hop,j) LSh . Now there are now two cases.\n\u2013 Case 1 - There exists some Pj \u2208 H where Pj 6\u2208 Selectediter and some party Pi \u2208 H, such that Pi has started participating with input 0\nin the instance \u03a0 (phI,hop,j) BA : This implies that Pi has computed the output 1 in some \u03a0BA instance during the Phase I, say \u03a0 (phI,hop,m) BA . And hence Pi starts participating in all the remaining \u03a0BA instances of hop number hop of Phase I (if any) with the input 0. From the Za-consistency of \u03a0BA in the asynchronous network, all the parties in H will also eventually compute the output 1 during the instance \u03a0 (phI,hop,m) BA and will start participating in all the remaining \u03a0BA instances of hop number hop of Phase I (if any) with the input 0. Consequently, from the Za-security of \u03a0BA in the asynchronous network (Theorem 3.1), almost-surely, the parties in H eventually compute some output during all the \u03a0BA instances of hop number hop and hence complete the hop number hop.\n\u2013 Case 2 - No honest party has yet started participating with input 0 in any of the BA instances of Phase I corresponding to the honest parties: In this case, the honest parties will eventually start participating\nwith input 1 in the \u03a0BA instances \u03a0 (phI,hop,j) BA , corresponding to the parties Pj \u2208 H where Pj 6\u2208 Selectediter. Hence from the Za-validity of \u03a0BA in the asynchronous network (Theorem 3.1), it follows that eventually, there will be some Pj \u2208 H where Pj 6\u2208 Selectediter, such that all the parties in H compute the output 1 during the instance \u03a0 (phI,hop,j) BA . The rest of the proof is similar to what is argued in the previous case.\nWe next show that in protocol \u03a0BasicMult, the honest parties compute some output, after a fixed time in a synchronous network and eventually in an asynchronous network.\nLemma 8.4. If no honest party is present in GD, then in protocol \u03a0BasicMult, except with probability O(n3 \u00b7 \u01ebICP), all honest parties compute some output by the time TBasicMult = (2n + 1) \u00b7 TBA + (n + 1) \u00b7 TLSh + TRec in a synchronous network, or almost-surely, eventually in an asynchronous network.\nProof. In the protocol\u03a0BasicMult, to compute an output, the (honest) parties need to complete the three phases. We first show that irrespective of the network type, the honest parties will complete Phase II, provided they complete Phase I. This is because the honest parties will participate in all the \u03a0BA instances \u03a0 (phII,j) BA of phase II with some input, after waiting exactly for time TLSh. Consequently, once phase I is completed, from the Zs-security of \u03a0BA in the synchronous network (Theorem 3.1), it takes TLSh + TBA time for the honest parties to compute outputs in the \u03a0BA instances during phase II in a synchronous network. On the other hand, the Za-security of \u03a0BA in the asynchronous network (Theorem 3.1) guarantees that almost-surely, all honest parties eventually compute some output during the \u03a0BA instances during phase II in an asynchronous network. Now once Phase I and Phase II are completed, it takes TRec time for the parties to complete Phase III in a synchronous network (follows from Lemma 6.2), while in an asynchronous network, it gets completed eventually (see Lemma 6.2).\nWe now show that Phase I always gets completed for the honest parties. Lemma 8.3 guarantees that if the honest parties start any hop during Phase I, then it gets completed for all the honest parties after time TLSh + 2TBA in a synchronous network or eventually in an asynchronous network. From the protocol steps, it follows that there can be at most n hops during Phase I. This is because once the set of honest parties are included in the set of summandsharing parties Selectediter during Phase I, then the parties will exit Phase I.\nWe next show that the adversary does not learn anything additional about a and b during the protocol.\nLemma 8.5. If no honest party is present in GD, then the view of the adversary remains independent of a and b throughout the protocol, irrespective of the network type.\nProof. Let Z\u22c6 be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. The view of the adversary remains independent of a and b during Phase I and Phase II. This is because the privacy of \u03a0LSh (Lemma 8.1) ensures that the view of the adversary remains independent of the summandsums shared by the honest summand-sharing parties during Phase I and Phase II. Let Sh \u2208 SZs be the group consisting of only honest parties; i.e. (Sh\u2229Z\n\u22c6) = \u2205. To prove that the view of the adversary remains independent of a and b during Phase III, we show that irrespective of the network type, any summand of the form (h, q) or (p, h) will not be present in SISiter during this phase corresponding to any p, q \u2208 {1, . . . , |Zs|}, implying that the shares [a]h and [b]h does not get publicly reconstructed. Note that (h, q) 6\u2208 SIS (j) iter for any Pj \u2208 Z\n\u22c6, as otherwise it would imply that a corrupt Pj \u2208 (Sh \u2229 Z\u22c6), which is a contradiction. Similarly, (p, h) 6\u2208 SIS (j) iter for any Pj \u2208 Z \u22c6\nLet us first consider a synchronous network and consider an arbitrary ordered pair (h, q). Consider the case when (h, q) has not been removed from SISiter during Phase I in any of the hops. Then, during Phase II, the pair (h, q) will get statically re-assigned to the SIS (j) iter set of some Pj \u2208 H, such that Pj 6\u2208 Selectediter. From the protocol steps, Pj will include the summand [a]h \u00b7 [b]q while computing c (j) iter and share c (j) iter through an instance of \u03a0LSh. From the Zs-correctness of \u03a0LSh in the synchronous network, the parties in H will output [c (j) iter] during the instance of \u03a0LSh invoked by Pj . Since Pj /\u2208 (Selectediter \u222a GD), it follows that all the parties in H will participate in the instance \u03a0 (phII,j) BA with input 1 and compute the output 1. Consequently, (h, q) will be removed from the updated SISiter during Phase II, if not removed during Phase I. By the same logic, any ordered pair of the form (p, h) will also be removed from SISiter, by the end of Phase II.\nNext, consider an asynchronous network and an arbitrary (h, q). In this case, we show that (h, q) will eventually be removed from SISiter during Phase I itself. Let the parties in H complete Phase I. This implies that there exists some S\u2113 \u2208 SZs such that SIS (S\u2113) iter = \u2205 when Phase I gets over. We show that (h, q) was present in SIS (S\u2113) iter at the beginning of Phase I, when the parties initialize SIS (S\u2113) iter .\nThat is, at the time of initialization, there was some Pj \u2208 (S\u2113 \u2229 H \u2229 Sq) such that (h, q) \u2208 SIS (j) iter. For this, it is enough to show that (S\u2113 \u2229H\u2229 Sq) 6= \u2205, which follows from the fact that Zs and Za satisfy the condition Q(2,1)(P ,Zs,Za) and (S\u2113\u2229H\u2229Sq) = P \\(Z\u2113\u222aZ\u22c6\u222aZq), where Z\u22c6 \u2208 Za (because we are considering an asynchronous network) and Z\u2113, Zq \u2208 Zs (follows from the construction of SZs). Let Pj \u2208 (S\u2113 \u2229 H \u2229 Sq). Hence at the time of the initialization, (h, q) \u2208 SIS (j) iter, which further implies that (h, q) \u2208 SIS (j) iter \u2286 SIS (S\u2113) iter at the time of initialization. And hence (h, q) must have been removed from SISiter by the end of Phase I, since Pj would have been selected as the summand-sharing party in one of the hops during Phase I. The same logic also applies to any arbitrary (p, h), implying that (p, h) would have been removed from SISiter by the end of Phase I itself.\nWe next show that if all the parties behave honestly in the protocol, the parties output a linear-secret sharing of a \u00b7 b with IC-signatures.\nLemma 8.6. If no honest party is present in GD and if all parties in P \\ GD behave honestly, then in protocol \u03a0BasicMult, the honest parties output a linear secret-sharing of a \u00b7 b with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets, irrespective of the network type.\nProof. Note that (Selectediter \u2229 GD) = \u2205, which follows from Lemma 8.2. Now Consider an arbitrary (p, q) \u2208 SISiter. We claim that irrespective of the network type, if all the parties behave honestly, then the summand [a]p \u00b7 [b]q is considered on behalf of exactly one party while secret-sharing the summand-sums. That is there is exactly one Pj across the three phases, such that the following hold:\nc (j) iter = . . .+ [a]p[b]q + . . . .\nAssuming that the claim is true, the proof then follows from the linearity property of secret-sharing and the fact that citer = c (1) iter + . . . + c (n) iter holds. That is, corresponding to each Pj \u2208 Selectediter, the value c (j) iter is secret-shared through an instance of \u03a0LSh, with GW1, . . . ,GW |Zs| being the underlying core-sets, which guarantees that c (j) iter is linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. Moreover, by the end of Phase II, the parties will be publicly knowing the set Selectediter, which follows from the security properties of \u03a0BA. Furthermore, after Phase II, the parties will be publicly reconstructing the shares [a]p and [b]q corresponding to every (p, q), which are still present in SISiter. Since corresponding to each Pj \u2208 P \\Selectediter, the parties take the default linear secret-sharing of c (j) iter with IC-signatures and GW1, . . . ,GW |Zs| being the underlying core-sets, it follows that c will be linearly secret-shared with IC-signatures and GW1, . . . ,GW |Zs| being the underlying core-sets. Moreover, c = a\u00b7b holds, since each summand [a]p \u00b7[b]q is considered exactly once, as per our claim. We now proceed to prove our claim.\nWe first show that there exists at least one Pj in one of the three phases, such that the following holds:\nc (j) iter = . . .+ [a]p[b]q + . . . .\nFor this, consider the following cases. \u2013 Case 1 \u2014 During Phase I, there is some Pj \u2208 Selectediter, such that\n(p, q) was present in the set SIS (j) iter when Pj was added to Selectediter:\nIn this case, there is nothing to show. \u2013 Case 2 \u2014 At the end of Phase I, (p, q) is still present in SISiter:\nThis implies that at the end of Phase I, (Selectediter \u2229 Sp \u2229 Sq) = \u2205. Since Zs and Za satisfy the condition Q(2,1)(P ,Zs,Za), it follows that (Sp \u2229 Sq) 6= \u2205. Let Pj def = min(Sp, Sq). Note that Pj 6\u2208 Selectediter at the end of Phase I, otherwise (p, q) would have been removed from SISiter, which is a contradiction. Now if Pj 6\u2208 GD, then clearly the summand [a]p \u00b7 [b]q will be present in c (j) iter, shared by Pj during the Phase II. Else, during Phase III, the parties will publicly reconstruct [a]p and [b]q and consequently [a]p \u00b7 [b]q will be present in the default secret-sharing of c\n(j) iter, taken on the behalf of Pj .\nTo complete the proof of our claim, we next show that (p, q) cannot be present in the summand-sum of more than one party across the three phases. On contrary, let Pj and Pk be two distinct parties, such that the following holds across the three phases:\nc (j) iter = . . .+ [a]p[b]q + . . . \u2227 c (k) iter = . . .+ [a]p[b]q + . . .\nNow there are three following cases. \u2013 Case 1 - Pj , Pk \u2208 Selectediter at the end of Phase I: From the security\nproperties of \u03a0BA, the parties will agree on which party to add to Selectediter during every hop during Phase I. Moreover, from the protocol steps, exactly one party is selected as a summand-sharing party and added to Selectediter in each hop. Suppose that Pj was added to Selectediter during hop (j), and that Pk was added to Selectediter during hop (k). Moreover, without loss of generality, let hop(j) < hop(k). From the protocol steps, it follows that Pj , Pk 6\u2208 GD, as otherwise no honest party would have voted for Pj and Pk as a candidate summand-sharing party and consequently, Pj , Pk 6\u2208 Selectediter. Now as per the lemma conditions, all the parties (including Pk) behave honestly. Hence, the ordered pair (p, q) would be removed from SIS (k) iter at the end of hop\n(j). Consequently, Pk will not include the summand [a]p \u00b7 [b]q while computing c (k) iter during hop number hop\n(k), which is a contradiction. \u2013 Case 2 \u2014 Pj \u2208 Selectediter at the end of Phase I and Pk /\u2208 Selectediter\nat the end of Phase I: In this case, (p, q) will be removed from SISiter at the end of Phase I. Hence, it cannot get re-assigned to any other party Pk after Phase I and hence cannot belong to SIS\n(k) iter . Consequently, the summand\n[a]p \u00b7[b]q will not be considered while computing c (k) iter , which is a contradiction, \u2013 Case 3 - Pj /\u2208 Selectediter and Pk /\u2208 Selectediter at the end of Phase I: In this case, the summand [a]p \u00b7 [b]p is deterministically and statically reassigned to the least-indexed party from the set (Sp \u2229 Sq), as per the min function. Hence (p, q) will be re-assigned to either Pj or Pk, but not both.\nConsequently, the summand [a]p \u00b7 [b]q will be considered while computing either c (j) iter or c (k) iter , but not both, which is a contradiction.\nLemma 8.7. Protocol \u03a0BasicMult incurs a communication of O(|Zs| \u00b7 n5 \u00b7 log |F|+ n6 \u00b7 log |F| \u00b7 |\u03c3|) bits and makes O(n2) calls to \u03a0BA.\nProof. During Phase I, there can be O(n) hops, where during each hop, a party from P \\GD secret-shares a field element through an instance of \u03a0LSh. Moreover, n instances of \u03a0BA are invoked to agree upon the summand-sharing party of the hop. Hence, O(n2) instances of \u03a0LSh and O(n2) instances of \u03a0BA are required during Phase I. During Phase II, O(n) instances of \u03a0LSh and O(n) instances of \u03a0BA are required. Finally during Phase III, up to O(|Zs|) shares need to be publicly reconstructed. The communication complexity now follows from the communication complexity of \u03a0LSh (Lemma 8.1) and communication complexity of \u03a0RecShare with |R| = n (Lemma 6.1).\nAs a corollary of Lemma 8.7, we derive the following corollary, which determines the maximum number of instances of \u03a0LSh which are invoked during an instance of \u03a0BasicMult. Looking ahead, this will be useful to later calculate the maximum number of instances of \u03a0LSh which need to be invoked as part of our final multiplication protocol. This will be further useful to determine the number of linearly secret-shared values with IC-signatures and core-sets GW1, . . . ,GW |Zs|, which need to be generated through the protocol \u03a0Rand beforehand.\nCorollary 8.1. During any instance of \u03a0BasicMult, there can be at most n2 + n instances of \u03a0LSh invoked.\nProof. The proof follows from the fact that during Phase I, there can be up to n2 instances of \u03a0LSh, if GD = \u2205 and during Phase II, there can be up to n \u2212 1 instances of \u03a0LSh, if only one party is added to Selectediter during Phase I.\nF.3 Properties of the Protocol \u03a0RandMultCI\nIn this section, we prove the properties of the protocol \u03a0RandMultCI (see Fig 12 for the formal description). We begin by showing that irrespective of the network type, the (honest) parties compute linearly secret-shared aiter, biter, b \u2032 iter and riter with IC-signatures, which are random from the point of view of the adversary.\nLemma 8.8. In protocol \u03a0RandMultCI, the following hold. \u2013 Synchronous Network: Except with probability O(n3 \u00b7 \u01ebICP), honest parties\nwill have linearly secret-shared aiter, biter, b \u2032 iter and riter with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets, by the time TLSh + 2TBA. Moreover, adversary\u2019s view is independent of aiter, biter, b \u2032 iter and riter. \u2013 Asynchronous Network: Except with probability O(n3 \u00b7\u01ebICP), almost-surely, honest parties will eventually have linearly secret-shared aiter, biter, b \u2032 iter and\nriter with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying coresets. Moreover, adversary\u2019s view is independent of aiter, biter, b \u2032 iter and riter.\nProof. We first consider a synchronous network. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. Corresponding to each Pj \u2208 H, the honest parties compute the output [a (j) iter], [b (j) iter], [b \u2032(j) iter ] and [r (j) iter] during the instances of \u03a0LSh invoked by Pj at the time TLSh, except with probability O(n3 \u00b7 \u01ebICP). This follows from the Zs-correctness of \u03a0LSh in the synchronous network (Lemma 8.1). Consequently, at the time TLSh, all the parties in H will be present in the set Ci of every Pi \u2208 H. Hence corresponding to each Pj \u2208 H, each Pi \u2208 H starts participating with input 1 in the instance \u03a0 (j) BA at the time TLSh. Hence from the Zs-validity and Zs-guaranteed liveness properties of \u03a0BA in the synchronous network (Theorem 3.1), it follows that at the time TLSh+TBA, all the parties inH compute the output 1 during the instance \u03a0 (j) BA , corresponding to every Pj \u2208 H. Consequently, at the time TLSh + TBA, all the parties in H will start participating in the remaining \u03a0BA instances for which no input has been provided yet (if there are any). And from the Zsguaranteed liveness and Zs-consistency properties of \u03a0BA in the synchronous network (Theorem 3.1), these \u03a0BA instances will produce common outputs for every honest party by the time TLSh+2TBA. Hence, at the time TLSh+2TBA, the honest parties will have a common CS, where P \\ CS \u2208 Zs and where H \u2286 CS. We next wish to show that corresponding to every Pj \u2208 CS, there exists some quadruplet of values, which are linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets.\nConsider an arbitrary party Pj \u2208 CS. If Pj \u2208 H, then whatever we wish to show is correct, as shown above. Next, consider a corrupt Pj \u2208 CS. Since Pj \u2208 CS, it follows that the instance \u03a0 (j) BA produces the output 1 for all honest parties. This further implies that at least one honest Pi must have computed some output during the instances of \u03a0LSh invoked by Pj , by the time TLSh+TBA (implying that Pj \u2208 Ci) and participated with input 1 in the instance \u03a0 (j) BA . Otherwise, all honest parties would participate with input 0 in the instance \u03a0 (j) BA at the time TLSh+TBA and then from the Zs-validity of\u03a0BA in the synchronous network, every honest party would have computed the output 0 in the instance \u03a0 (j) BA and hence Pj will not be present in CS, which is a contradiction. Now if Pi has computed some output during the instances of \u03a0LSh invoked by Pj at the time TLSh + TBA, then from the Zs-commitment of \u03a0LSh in the synchronous network (Lemma 8.1), it follows that except with probability O(n3 \u00b7 \u01ebICP), there exist values (a (j) iter, b (j) iter, b \u2032(j) iter , r (j) iter), which will be linearly secret-shared with IC-signature, with GW1, . . . ,GW |Zs| being the underlying core-sets, by the time TLSh+TBA+\u2206. Since \u2206 < TBA, it follows that by the time TLSh + 2TBA, the honest parties will have [a (j) iter], [b (j) iter], [b \u2032(j) iter ] and [r (j) iter]. From the linearity property of secret-sharing, it then follows that by the time TLSh + 2TBA, the values aiter, biter, b \u2032 iter and riter will be linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets.\nFrom the privacy of \u03a0LSh (Lemma 8.1), the view of the adversary will be\nindependent of the values (a (j) iter, b (j) iter, b \u2032(j) iter , r (j) iter), corresponding to the parties Pj \u2208 H. As (H\u2229CS) 6= \u2205, it follows that aiter, biter, b\u2032iter and riter will be indeed random\nfrom the point of view of the adversary. This completes the proof for the case of synchronous network.\nWe next consider an asynchronous network. Let Z\u22c6 \u2208 Za be the set of corrupt parties and let H = P \\Z\u22c6 be the set of honest parties. Notice that P \\H \u2208 Zs, since Za \u2282 Zs. Now irrespective of the way messages are scheduled, there will be eventually a subset of parties P \\Z for some Z \u2208 Zs, such that all the parties in H participate with input 1 in the instances of \u03a0BA, corresponding to the parties in P \\ Z. This is because, corresponding to every Pj \u2208 H, all the parties in H eventually compute some output during the instances of \u03a0LSh invoked by Pj except with probability O(n3 \u00b7 \u01ebICP), which follows from the Za-correctness of \u03a0LSh in the asynchronous network (Lemma 8.1). So even if the corrupt parties Pj do not invoke their respective instances of \u03a0LSh, there will be a set of \u03a0BA instances corresponding to the parties in P \\ Z for some Z \u2208 Zs, in which all the parties in H eventually participate with input 1. Consequently, from the Zaalmost-surely liveness and Za-consistency properties of \u03a0BA in the asynchronous network (Theorem 3.1), these \u03a0BA instances eventually produce the output 1 for all the parties in H. Hence, all the parties in H eventually participate with some input in the remaining \u03a0BA instances, which almost-surely produce some output for every honest party eventually. From the properties of \u03a0BA in the asynchronous network, it then follows that all the honest parties output the same CS.\nNow consider an arbitrary Pj \u2208 CS. It implies that the honest parties computed the output 1 during the instance \u03a0 (j) BA , which further implies that at least one honest Pi participated with input 1 in \u03a0 (j) BA after computing its output in the instances of \u03a0LSh invoked by Pj . If Pj is honest, then the Za-correctness of \u03a0LSh in the asynchronous network guarantees that except with probability O(n3 \u00b7\u01ebICP), the values (a (j) iter, b (j) iter, b \u2032(j) iter , r (j) iter) will be eventually linearly secret-shared with ICsignatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. On the other hand, even if Pj is corrupt, the Za-commitment of \u03a0LSh in the asynchronous network (Lemma 8.1) guarantees that there exist values (a (j) iter, b (j) iter, b \u2032(j) iter , r (j) iter) which are eventually linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets, except with probability O(n3 \u00b7 \u01ebICP). From the linearity property of secret-sharing, it then follows that eventually, the values aiter, biter, b \u2032 iter and riter will be linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. The privacy of aiter, biter, b \u2032 iter and riter is similar as for the synchronous communication network and the fact that (H \u2229 CS) 6= \u2205 still holds in the asynchronous network.\nWe next claim that all honest parties will eventually agree on whether the instances of \u03a0BasicMult in \u03a0RandMultCI have succeeded or failed.\nLemma 8.9. Consider an arbitrary iter, such that all honest parties participate in the instance \u03a0RandMultCI(P ,Zs,Za, SZs ,GW1, . . . ,GW |Zs|,GD, iter), where no honest party is present in GD. Then except with probability O(n3 \u00b7\u01ebICP), all honest parties reconstruct a (common) value diter and set flagiter to a common\nBoolean value, at the time TLSh + 2TBA + TBasicMult + 3TRec in a synchronous network, or eventually in an asynchronous network.\nProof. From Lemma 8.8, the honest parties have [aiter], [biter], [b \u2032 iter] and [riter] at the time TLSh + 2TBA in a synchronous network, or eventually in an asynchronous network, except with probability O(n3 \u00b7 \u01ebICP), with GW1, . . . ,GW |Zs| being the underlying core-sets. From Lemma 8.4, it follows that the honest parties have {[c (1) iter], . . . , [c (n) iter ], [citer]} and {[c \u2032(1) iter ], . . . , [c \u2032(n) iter ], [c \u2032 iter]} from the corresponding instances of \u03a0BasicMult, either after time TBasicMult or eventually, based on the network type, where GW1, . . . ,GW |Zs| are the underlying core-sets. From Lemma 6.2, the honest parties reconstruct riter from the corresponding instance of \u03a0Rec after time TRec in a synchronous network or eventually in an asynchronous network, except with probability O(n3 \u00b7 \u01ebICP). From the linearity property of secret-sharing, it then follows that the honest parties compute [eiter] and hence reconstruct eiter from the corresponding instance of \u03a0Rec, after time TRec in a synchronous network or eventually in an asynchronous network, except with probability O(n3 \u00b7\u01ebICP). Moreover, GW1, . . . ,GW |Zs| will be the underlying coresets for [eiter]. Again, from the linearity property of secret-sharing, it follows that the honest parties compute [diter] with GW1, . . . ,GW |Zs| being the underlying core-sets, followed by reconstructing diter from the corresponding instance of \u03a0Rec, which takes TRec time in a synchronous network or happens eventually in an asynchronous network. Thus, the honest parties will have diter either at the time TLSh + 2TBA + TBasicMult + 3TRec in a synchronous network, or eventually in an asynchronous network. Now depending upon the value of diter, the honest parties set flagiter to either 0 or 1.\nWe next claim that if no cheating occurs, then the honest parties output a multiplication-triple, which is linearly secret-shared with IC-signatures.\nLemma 8.10. Consider an arbitrary iter, such that all honest parties participate in the instance \u03a0RandMultCI(P ,Zs,Za, SZs ,GW1, . . . ,GW |Zs|,GD, iter), where no honest party is present in GD. If no party in P \\ GD behaves maliciously, then diter = 0 and the honest parties output ([aiter], [biter], [citer]) at the time TLSh + 2TBA + TBasicMult + 3TRec in a synchronous network or eventually in an asynchronous network, where citer = aiter \u00b7 biter and where GW1, . . . ,GW |Zs| are the underlying core-sets\nProof. If no party in P \\ GD behaves maliciously, then from Lemma 8.6, the honest parties compute [citer] and [c \u2032 iter] from the respective instances of\u03a0BasicMult, such that citer = aiter \u00b7biter and c\u2032iter = aiter \u00b7b \u2032 iter holds and where GW1, . . . ,GW |Zs| are the underlying core-sets. Moreover, from Lemma 8.9, the honest parties will compute diter at the time TLSh + 2TBA + TBasicMult + 3TRec in a synchronous network or eventually in an asynchronous network. Furthermore, if citer = aiter \u00b7 biter and c \u2032 iter = aiter \u00b7 b \u2032 iter holds, the value diter will be 0 and consequently, the honest parties will output ([aiter], [biter], [citer]). Furthermore, it is easy to see that GW1, . . . ,GW |Zs| will be the underlying core-sets. This is because all the secretshared values in the protocol are linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets.\nWe next show that if diter 6= 0, then the honest parties include at least one new maliciously-corrupt party in the set GD.\nLemma 8.11. Consider an arbitrary iter, such that all honest parties participate in the instance \u03a0RandMultCI(P ,Zs,Za, SZs ,GW1, . . . ,GW |Zs|,GD, iter), where no honest party is present in GD. If diter 6= 0, then except with probability O(n3 \u00b7 \u01ebICP), the honest parties update GD by adding a new maliciously-corrupt party in GD, either at the time TRandMultCI = TLSh + 2TBA + TBasicMult + 4TRec in a synchronous network or eventually in an asynchronous network.\nProof. Let diter 6= 0 and let Selectediter be the set of summand-sharing parties across the two instances of \u03a0BasicMult executed in \u03a0RandMultCI. That is:\nSelectediter def = Selectediter,c \u222a Selectediter,c\u2032 .\nNote that there exists no Pj \u2208 Selectediter such that Pj \u2208 GD, which follows from Lemma 8.2. We claim that there exists at least one party Pj \u2208 Selectediter, such that corresponding to c (j) iter and c \u2032(j) iter , the following holds:\nriter \u00b7 c (j) iter + c \u2032(j) iter 6= riter \u00b7\n\u2211\n(p,q)\u2208SIS (j) iter,c\n[aiter]p[biter]q + \u2211\n(p,q)\u2208SIS (j)\niter,c\u2032\n[aiter]p[b \u2032 iter]q.\nAssuming the above holds, the proof now follows from the fact that once the parties reconstruct diter 6= 0, they proceed to reconstruct the shares {[aiter]q, [biter]q, [b\u2032iter]q}Sq\u2208SZs through appropriate instances of \u03a0RecShare and the values c (1) iter, . . . , c (n) iter , c \u2032(1) iter , . . . , c \u2032(n) iter through appropriate instances of \u03a0Rec. From Lemma 8.9, Lemma 6.1 and Lemma 6.2, this happens by the time TLSh + 2TBA + TBasicMult + 4TRec in a synchronous network or eventually in an asynchronous network, except with probability O(n3 \u00b7\u01ebICP). Upon reconstructing these values, party Pj will be included in the set GD. Moreover, it is easy to see that Pj is a maliciously-corrupt party since, for every honest Pj \u2208 Selectediter, the following conditions hold:\nc (j) iter =\n\u2211\n(p,q)\u2208SIS (j) iter,c\n[aiter]p[biter]q and c \u2032(j) iter =\n\u2211\n(p,q)\u2208SIS (j)\niter,c\u2032\n[aiter]p[b \u2032 iter]q.\nWe prove the above claim through a contradiction. Let the following condition hold for each Pj \u2208 Selectediter:\nriter \u00b7 c (j) iter + c \u2032(j) iter = riter \u00b7\n\u2211\n(p,q)\u2208SIS (j) iter,c\n[aiter]p[biter]q + \u2211\n(p,q)\u2208SIS (j)\niter,c\u2032\n[aiter]p[b \u2032 iter]q.\nNext, summing the above equation over all Pj \u2208 Selectediter, we get that the following holds:\n\u2211\nPj\u2208Selectediter\nriter\u00b7c (j) iter+c \u2032(j) iter =\n\u2211\nPj\u2208Selectediter\nriter\u00b7 \u2211\n(p,q)\u2208SIS (j) iter,c\n[aiter]p[biter]q+ \u2211\n(p,q)\u2208SIS (j)\niter,c\u2032\n[aiter]p[b \u2032 iter]q.\nThis implies that the following holds:\nriter\u00b7 \u2211\nPj\u2208Selectediter\nc (j) iter+c \u2032(j) iter = riter\u00b7\n\u2211\nPj\u2208Selectediter\n\u2211\n(p,q)\u2208SIS (j) iter,c\n[aiter]p[biter]q+ \u2211\n(p,q)\u2208SIS (j)\niter,c\u2032\n[aiter]p[b \u2032 iter]q.\nNow based on the way aiter, biter, b \u2032 iter, citer and c \u2032 iter are defined, the above implies that the following holds:\nriter \u00b7 citer + c \u2032 iter = r \u00b7 aiter \u00b7 biter + aiter \u00b7 b \u2032 iter\nThis further implies that\nriter \u00b7 citer + c \u2032 iter = (riter \u00b7 biter + b \u2032 iter) \u00b7 aiter\nSince in the protocol eiter def = riter \u00b7 biter + b\u2032iter, the above implies that\nriter \u00b7 citer + c \u2032 iter = eiter \u00b7 aiter \u21d2 eiter \u00b7 aiter \u2212 riter \u00b7 citer \u2212 c \u2032 iter = 0 \u21d2 diter = 0,\nwhere the last equality follows from the fact that in the protocol, diter def = eiter \u00b7 aiter \u2212 riter \u00b7 citer \u2212 c\u2032iter. However diter = 0 is a contradiction since, according to the hypothesis of the lemma, we are given that diter 6= 0.\nWe next show that if the honest parties output a secret-shared triple in the protocol, then except with probability 1|F| , the triple is a multiplication-triple. Moreover, the triple will be random for the adversary.\nLemma 8.12. Consider an arbitrary iter, such that all honest parties participate in the instance \u03a0RandMultCI(P ,Zs,Za, SZs ,GW1, . . . ,GW |Zs|,GD, iter), where no honest party is present in GD. If diter = 0, then the honest parties output linearly secret-shared ([aiter], [biter], [citer]) with IC-signatures with GW1, . . . ,GW |Zs| being the underlying core-sets, at the time TLSh + 2TBA + TBasicMult + 3TRec in a synchronous network or eventually in an asynchronous network where, except with probability 1|F| , the condition citer = aiter \u00b7 biter holds. Moreover, the view of Adv will be independent of (aiter, biter, citer).\nProof. Let diter = 0. From Lemma 8.4, all honest parties will agree that diter = 0, either at the time TLSh + 2TBA + TBasicMult + 3TRec in a synchronous network or eventually in an asynchronous network. Then, from the protocol steps, the honest parties output ([aiter], [biter], [citer]), with GW1, . . . ,GW |Zs| being the underlying core-sets. In the protocol diter def = eiter \u00b7 aiter \u2212 riter \u00b7 citer \u2212 c\u2032iter, where eiter def = riter \u00b7 biter + b\u2032iter. Since diter = 0 holds, it implies that the honest parties have verified that the following holds:\nriter(aiter \u00b7 biter \u2212 citer) = (c \u2032 iter \u2212 aiter \u00b7 b \u2032 iter).\nWe note that riter will be a random element from F and will be unknown to Adv till it is publicly reconstructed, which follows from Lemma 8.8 We also note\nthat riter will be unknown to Adv, till the outputs for the underlying instances of \u03a0BasicMult are computed, and the honest parties have [citer] and [c \u2032 iter]. This is because, in the protocol, the honest parties start participating in the instance of \u03a0Rec to reconstruct riter, only after they compute [citer] and [c \u2032 iter]. Now we have the following cases with respect to whether any party from P \\GD behaved maliciously during the underlying instances of \u03a0BasicMult.\n\u2013 Case I: citer = aiter \u00b7 biter and c\u2032iter = aiter \u00b7 b \u2032 iter \u2014 In this case, (aiter, biter, citer)\nis a multiplication-triple. \u2013 Case II: citer = aiter\u00b7biter, but c\u2032iter 6= aiter \u00b7b \u2032 iter \u2014This case is never possible, as\nthis will lead to the contradiction that riter(aiter \u00b7biter\u2212citer) 6= (c\u2032iter\u2212aiter \u00b7b \u2032 iter)\nholds. \u2013 Case III: citer 6= aiter \u00b7 biter, but c\u2032iter = aiter \u00b7 b \u2032 iter \u2014 This case is possible only\nif riter = 0, as otherwise this will lead to the contradiction that riter(aiter \u00b7 biter\u2212citer) 6= (c\u2032iter\u2212aiter \u00b7b \u2032 iter) holds. However, since riter is a random element from F, it implies that this case can occur only with probability at most 1|F| . \u2013 Case IV: citer 6= aiter \u00b7biter as well as c\u2032iter 6= aiter \u00b7b \u2032 iter \u2014 This case is possible\nonly if riter = (c \u2032 iter \u2212 aiter \u00b7 b \u2032 iter) \u00b7 (aiter \u00b7 biter \u2212 citer) \u22121, as otherwise this will lead to the contradiction that riter(aiter \u00b7 biter \u2212 citer) 6= (c\u2032iter \u2212aiter \u00b7 b \u2032 iter) holds. However, since riter is a random element from F, it implies that this case can occur only with probability at most 1|F| . Hence, we have shown that except with probability at most 1|F| , the triple (aiter, biter, citer) is a multiplication-triple. To complete the proof, we need to argue that the view of Adv in the protocol will be independent of the triple (aiter, biter, citer). For this, we first note that aiter, biter and b \u2032 iter will be random for the adversary at the time of their generation, which follows from Lemma 8.8. From Lemma 8.5, Adv learns nothing additional about aiter, biter and b \u2032 iter during the two instances of \u03a0BasicMult. While Adv learns the value of eiter, since b\u2032iter is a uniformly distributed for Adv, for every candidate value of b \u2032 iter from the view-point of Adv, there is a corresponding value of biter consistent with the eiter learnt by Adv. Hence, learning eiter does not add any new information about (aiter, biter, citer) to the view of Adv. Moreover, Adv will be knowing beforehand that diter will be 0 and hence, learning this value does not change the view of Adv regarding (aiter, biter, citer).\nWe next derive the communication complexity of the protocol \u03a0RandMultCI.\nLemma 8.13. Protocol \u03a0RandMultCI incurs a communication of O(|Zs| \u00b7 n5 \u00b7 log |F|+ n6 \u00b7 log |F| \u00b7 |\u03c3|) bits and makes O(n2) calls to \u03a0BA.\nProof. To generate [aiter], [biter], [b \u2032 iter] and [riter], O(n) instances of \u03a0LSh and \u03a0BA are invoked. To compute [citer] and [c \u2032 iter], two instances of \u03a0BasicMult are invoked. To publicly reconstruct eiter and diter, two instances of \u03a0Rec are invoked with |R| = n. Finally, if diter 6= 0, then 3\u00b7|SZs | instances of\u03a0RecShare and 2n instances of \u03a0Rec are invoked, with |R| = n. The communication complexity now follows from the communication complexity of\u03a0LSh (Lemma 8.1), communication complexity\nof \u03a0BasicMult (Lemma 8.7), communication complexity of \u03a0RecShare (Lemma 6.1) and communication complexity of \u03a0Rec (Lemma 6.2).\nF.4 Properties of the Protocol \u03a0TripGen\nIn this section, we prove the properties of the protocol \u03a0TripGen (see Fig 13 for the formal details.) We begin by showing that each party computes an output in the protocol.\nLemma 8.14. Let t be the size of the largest set in Zs. Then except with probability O(n3 \u00b7 \u01ebICP), the honest parties compute an output during \u03a0TripGen, by the time TTripGen = (t + 1) \u00b7 TRandMultCI in a synchronous network, or almost-surely, eventually in an asynchronous network, where TRandMultCI = TLSh + 2TBA + TBasicMult + 4TRec.\nProof. From Lemma 8.9, except with probability O(n3 \u00b7 \u01ebICP), the honest parties will know the outcome of each iteration iter, since all honest parties set the Boolean variable flagiter to a common value. For every iteration iter where flagiter is set to 1, from Lemma 8.11, a new corrupt party is added to GD. Thus, after at most t iterations, all the corrupt parties will be included in GD and the parties will set flagiter to 0 in the next iteration. Moreover, they will output (GW1, . . . ,GW |Zs|, [aiter], [biter], [citer]), computed during the corresponding instance of \u03a0RandMultCI.\nWe next claim that the output computed by the honest parties is indeed a multiplication-triple.\nLemma 8.15. If the honest parties output (GW1, . . . ,GW |Zs|, [aiter], [biter], [citer]) during the protocol \u03a0TripGen, then aiter, biter and citer are linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. Moreover, citer = aiterbiter holds, except with probability 1 |F| . Furthermore, the view of the adversary remains independent of aiter, biter and citer.\nProof. Follows from Lemma 8.12.\nWe finally derive the communication complexity of the protocol \u03a0TripGen.\nLemma 8.16. Protocol \u03a0TripGen incurs a communication of O(|Zs| \u00b7 n6 \u00b7 log |F|+ n7 \u00b7 log |F| \u00b7 |\u03c3|) bits and makes O(n3) calls to \u03a0BA.\nProof. The proof follows from the communication complexity of \u03a0RandMultCI (Lemma 8.13) and the fact that O(n) instances of \u03a0RandMultCI are invoked in the protocol."
        },
        {
            "heading": "G Properties of the Circuit Evaluation Protocol",
            "text": "In this section, we prove the properties of the protocol \u03a0cktEval (see Fig 14 for the formal description). We begin by showing that the honest parties compute some output during the pre-processing phase.\nLemma G.1. Protocol \u03a0cktEval achieves the following during the pre-processing phase. \u2013 Synchronous Network: Except with probability O(n3 \u00b7 \u01ebICP), at the time\nTRand, the honest parties have {r(l)}l=1,...,L, which are linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets, where L def = n3 \u00b7 cM +4n2 \u00b7 cM +n2 +n. Moreover, the view of the adversary remains independent of the values {r(l)}l=1,...,L. At the time TRand+TTripGen, the honest parties have triples {(a(\u2113), b(\u2113), c(\u2113))}\u2113=1,...,cM , which are linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets, where c(\u2113) = a(\u2113) \u00b7 b(\u2113), except with probability 1|F| . The view of the\nadversary will be independent of the multiplication-triples. \u2013 Asynchronous Network: Except with probability O(n3\u00b7\u01ebICP), almost-surely,\nthe honest parties eventually have {r(l)}l=1,...,L, which are linearly secretshared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying coresets, where L def = n3 \u00b7 cM + 4n2 \u00b7 cM + n2 + n. Moreover, the view of the adversary remains independent of the values {r(l)}l=1,...,L. Furthermore, the honest parties eventually have triples {(a(\u2113), b(\u2113), c(\u2113))}\u2113=1,...,cM , which are linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets, where c(\u2113) = a(\u2113) \u00b7 b(\u2113), except with probability 1|F| . The view of the adversary will be independent of the multiplication-triples.\nProof. The proof follows from the Zs-correctness, Za-correctness and privacy of the protocol \u03a0Rand (Theorem 7.2) and from the properties of \u03a0TripGen in the asynchronous and asynchronous network (Lemma 8.14 and Lemma 8.15). We also note that the multiplication-triples will be linearly secret-shared with ICsignatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. This is because there will be at most n3 \u00b7 cM + 4n2 \u00b7 cM + n2 instances of \u03a0LSh invoked as part of \u03a0TripGen for generating cM multiplication-triples. And prior to invoking the instance of\u03a0TripGen, the honest parties would have already generated n\n3\u00b7cM+4n2\u00b7 cM + n\n2 + n number of linearly secret-shared random pads with IC-signatures with GW1, . . . ,GW |Zs| being the underlying core-sets through the instance of \u03a0Rand, which can serve n 3 \u00b7 cM + 4n2 \u00b7 cM + n2 + n instances of \u03a0LSh.\nWe next show that during the input phase, the inputs of all honest parties will be linearly secret-shared with IC-signatures in a synchronous network and in an asynchronous network, the inputs of a subset of the parties will be linearly secret-shared with IC-signatures.\nLemma G.2. Protocol \u03a0cktEval achieves the following during the input phase.\n\u2013 Synchronous Network: Except with probability O(n3 \u00b7 \u01ebICP), at the time TRand + TTripGen + TLSh + 2TBA, the honest parties will have a common subset CS where P \\ CS \u2208 Zs, such that all honest parties will be present in CS. Moreover, corresponding to every Pj \u2208 CS, there will be some value,\nsay x\u22c6(j), which is the same as x(j), which will be linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. Fur-\nthermore, the view of the adversary will be independent of the x(j) values, corresponding to the honest parties Pj \u2208 CS. \u2013 Asynchronous Network: Except with probability O(n3\u00b7\u01ebICP), almost-surely, the honest parties will eventually have a common subset CS where P \\ CS \u2208 Zs. Moreover, corresponding to every Pj \u2208 CS, there will be some value,\nsay x\u22c6(j), which is the same as x(j), which will be eventually linearly secretshared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying coresets. Furthermore, the view of the adversary will be independent of the x(j)\nvalues, corresponding to the honest parties Pj \u2208 CS.\nProof. We first consider a synchronous network. From the protocol steps, the honest parties start participating in the input phase, only after computing output during the instance of \u03a0TripGen, which from Lemma G.1 happens at the time TRand + TTripGen. We also note that there can be at most n3 \u00b7 cM + 4n2 \u00b7 cM + n2 instances of \u03a0LSh, invoked as part of the instance of \u03a0TripGen, which will utilize the secret-shared values {r(l)}l=1,...,n3\u00b7cM+4n2\u00b7cM+n2 as pads. Consequently, the remaining linearly secretshared values {r(l)}l=n3\u00b7cM+4n2\u00b7cM+n2+1,...,n3\u00b7cM+4n2\u00b7cM+n2+n will be still available to the honest parties for being used as pads in up to n instances of \u03a0LSh, since these pads will be random from the adversary\u2019s point of view.\nLet Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. We claim that by the time TRand + TTripGen + TLSh + 2TBA, except with probability O(n3 \u00b7 \u01ebICP), all the parties in H will have a common subset CS, where P \\ CS \u2208 Zs and where H \u2286 CS. The proof for this is exactly the same as that of Lemma 8.8. Namely, at the time TRand+TTripGen+TLSh, all the parties in H would start participating with input 1 in the BA instances \u03a0 (j) BA , corresponding to the parties Pj \u2208 H, since by this time, the instances of \u03a0LSh invoked by the parties in H will produce output for all the parties in H. Consequently, these BA instances will produce output 1 at the time TRand + TTripGen + TLSh + TBA, after which all the parties in H will start participating with input 0 in the remaining BA instances (if any). Consequently, by the time TRand+TTripGen+TLSh+2TBA, all the n instances of \u03a0BA will produce some output and the parties in H will have a common CS. Next, it can be shown that corresponding to every Pj \u2208 CS, there exists some value, say x\u22c6(j), which is the same as x(j), such that the parties in H have a linear secret-sharing with IC-signatures of x\u22c6(j), with GW1, . . . ,GW |Zs| being the underlying core-sets. The proof for this follows similar lines as that of Lemma 8.8. It is easy to see that x\u22c6(j) will be linearly secret-shared with ICsignatures with GW1, . . . ,GW |Zs| being the underlying core-sets. This is because the instance of \u03a0LSh invoked by Pj utilizes r (n3\u00b7cM+4n 2\u00b7cM+n 2+j) as the pad, which is linearly secret-shared with IC-signatures with GW1, . . . ,GW |Zs| being the underlying core-sets.\nThe proof of the lemma for an asynchronous network is almost the same as above and follows using similar arguments as used to prove Lemma 8.8 for the case of asynchronous network.\nFinally, the privacy of the inputs x(j) of the parties Pj \u2208 (H\u2229CS) follows from\nthe privacy of \u03a0LSh and the fact that the underlying pads r (n3\u00b7cM+4n 2\u00b7cM+n 2+j) used in the corresponding instances of \u03a0LSh are still random for the adversary, after the instance of \u03a0TripGen.\nWe next show that the honest parties compute an output during the circuitevaluation phase.\nLemma G.3. Protocol \u03a0cktEval achieves the following during the circuitevaluation phase, where DM denotes the multiplicative depth of ckt. \u2013 Synchronous Network: Except with probability O(n3 \u00b7 \u01ebICP), at the time\nTRand + TTripGen + TLSh +2TBA + (DM +1) \u00b7 TRec, the honest parties will have y, where y = f(x\u22c6(1), . . . , x\u22c6(n)), such that x\u22c6(j) = x(j) for every honest party Pj \u2208 CS and where x\u22c6 (j) = 0 for every Pj 6\u2208 CS. Moreover, all honest parties will be present in CS. Furthermore, the view of the adversary will be independent of the x(j) values, corresponding to the honest parties Pj \u2208 CS. \u2013 Asynchronous Network: Except with probability O(n3\u00b7\u01ebICP), almost-surely,\nthe honest parties will eventually have y, where y = f(x\u22c6(1), . . . , x\u22c6(n)), where x\u22c6(j) = x(j) for every honest party Pj \u2208 CS and where x\u22c6 (j) = 0 for every Pj 6\u2208 CS. Furthermore, the view of the adversary will be independent of the x(j) values, corresponding to the honest parties Pj \u2208 CS.\nProof. Let us first consider a synchronous network. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. From Lemma G.1, at the time TRand + TTripGen, the parties in H will have the triples {(a(\u2113), b(\u2113), c(\u2113))}\u2113=1,...,cM , which are linearly secret-shared with ICsignatures, with GW1, . . . ,GW |Zs| being the underlying core-sets and where c(\u2113) = a(\u2113) \u00b7 b(\u2113), except with probability 1|F| . Moreover, from Lemma G.2, at the time TRand + TTripGen + TLSh + 2TBA, the honest parties will have a common subset CS where P \\ CS \u2208 Zs, such that all honest parties will be present in CS. Furthermore, corresponding to every Pj \u2208 CS, there will be some value, say x\u22c6(j), which is the same as x(j) for an honest Pj , which will be linearly secret-shared with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. At the end of the input phase, the parties take 0 as the input on behalf of the parties Pj 6\u2208 CS and take the default linear secret-sharing of 0 with IC-signatures, with GW1, . . . ,GW |Zs| being the underlying core-sets. To prove the lemma, we show that all the gates in ckt are correctly evaluated. Namely, for every gate in ckt, given the gate-inputs in a linearly secret-shared fashion with IC-signatures with GW1, . . . ,GW |Zs| being the underlying core-sets, the parties compute the gate-output in a linearly secret-shared fashion with ICsignatures with GW1, . . . ,GW |Zs| being the underlying core-sets. While this is true for the linear gates in ckt, which follows from the linearity of the secretsharing, the same is true even for the multiplication gates, except with probability O(n3 \u00b7 \u01ebICP). This is because, for every multiplication gate, the parties deploy a linearly secret-shared multiplication-triple from the pre-processing phase and apply Beaver\u2019s method. And the masked gate-inputs are correctly reconstructed\nthrough instances of\u03a0Rec, except with probability O(n3 \u00b7\u01ebICP). Since all the independent multiplication gates at the same multiplicative depth can be evaluated in parallel, to evaluate the multiplication gates, it will take a total DM \u00b7 TRec time. Finally, once the circuit-output is ready in a secret-shared fashion, it is publicly reconstructed through an instance of \u03a0Rec, which takes TRec time and produces the correct output, except with probability O(n3 \u00b7 \u01ebICP). The privacy of the inputs of the honest parties in CS follows from the privacy of \u03a0LSh (Lemma 8.1) and the fact no additional information is revealed during the evaluation of multiplication gates. This is because the underlying multiplication-triples which are deployed while applying Beaver\u2019s method are random for the adversary.\nThe proof for the case of asynchronous network follows similar arguments as above and depends upon the properties of the pre-processing phase and input phase in the asynchronous network (Lemma G.1 and Lemma G.2).\nWe finally show that the honest parties terminate the protocol.\nLemma G.4. If the network is synchronous, then except with probability O(n3 \u00b7 \u01ebICP), the honest parties terminate the protocol at the time TRand+TTripGen+TLSh+ 2TBA + (DM + 1) \u00b7 TRec + \u2206. If the network is asynchronous, then except with probability O(n3 \u00b7\u01ebICP), almost-surely, the honest parties eventually terminate the protocol.\nProof. Let us first consider a synchronous network. Let Z\u22c6 \u2208 Zs be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. From Lemma G.3, except with probability O(n3 \u00b7 \u01ebICP), at the time TRand + TTripGen + TLSh + 2TBA + (DM + 1) \u00b7 TRec, all the parties in H will have y. Hence every party in H will send a ready message for y to all the parties, which gets delivered within \u2206 time, while the parties in Z\u22c6 may send a ready message for some y\u2032 where y\u2032 6= y. Now since Zs does not satisfy the Q(1)(Z\u22c6,Zs) condition, it follows that no party in H will ever send a ready message for any y\u2032 where y\u2032 6= y. As P \\ H \u2208 Zs, it follows that at the time TRand + TTripGen + TLSh +2TBA + (DM +1) \u00b7 TRec +\u2206, all the parties in H will have sufficient number of ready messages for y and hence they terminate with output y.\nNext, consider an asynchronous network. Let Z\u22c6 \u2208 Za be the set of corrupt parties and let H = P \\ Z\u22c6 be the set of honest parties. Note that P \\ Z\u22c6 \u2208 Zs, since Za \u2282 Zs. From Lemma G.3, except with probability O(n3 \u00b7 \u01ebICP), almostsurely, all the parties in H will eventually compute y. Hence every party in H will eventually send some ready message. We claim that no party in H will ever send a ready message for any y\u2032 6= y. On the contrary, let Pi \u2208 H be the first party, which sends a ready message for y\u2032 6= y. From the protocol steps, it follows that Pi sends the ready message for y\n\u2032 after computing y\u2032 during the circuitevaluation phase. Otherwise, there should exist a subset of parties A where Zs satisfies Q(1)(A,Zs) condition (implying that A has at least one party from H), who should have sent the ready message for y\u2032 to Pi, which is not possible, since we are assuming Pi to be first party from H to send a ready message for y\u2032. From Lemma G.3, Pi will not compute y\n\u2032 and hence will not send a ready message for y\u2032. Now since every party in H eventually computes y in the circuit-evaluation\nphase, it eventually sends a ready message for y. And since P \\ Z\u22c6 \u2208 Zs and P \\Z\u22c6 6\u2208 Zs, it follows that irrespective of the behaviour of the corrupt parties, the parties in H will eventually receive a sufficient number of ready messages for y, to terminate with output y.\nLet Ph be the first party from H, who terminates with output y. This implies that there exists a subset of parties W with P \\ W \u2208 Zs, who sends a ready message for y to Ph. Now consider the set (H\u2229W). The set satisfies the Q(1)(H\u2229 W ,Zs) condition, due to the Q(2,1)(P ,Zs,Za) condition. The ready messages of these parties (for y) get eventually delivered to every party in H. Consequently, every party in H (including Ph) who has not yet sent any ready message will eventually send the ready message for y, which gets eventually delivered to all the parties. And as a result, every party in H will eventually have a sufficient number of ready messages for y, to terminate with the output y.\nWe next derive the communication complexity of the protocol.\nLemma G.5. Protocol \u03a0cktEval incurs a communication of O(|Zs|2 \u00b7n12 \u00b7 log |F| \u00b7 |\u03c3|) bits and makes O(n3) calls to \u03a0BA.\nProof. The communication complexity is dominated by the instance of \u03a0Rand to generate L def = n3 \u00b7 cM + 4n2 \u00b7 cM + n2 + n random secret-shared values and the instance of \u03a0TripGen to generate L = cM number of secret-shared multiplicationtriples. The proof now follows from the communication complexity of \u03a0Rand (Theorem 7.2) and the communication complexity of the (generalized) \u03a0TripGen protocol (Lemma 8.16).\nTheorem 9.1 now easily follows from Lemma G.1-G.5."
        }
    ],
    "title": "Network Agnostic MPC with Statistical Security",
    "year": 2023
}