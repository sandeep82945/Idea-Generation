{
    "abstractText": "Community detection techniques are useful tools for social media platforms to discover tightly connected groups of users who share common interests. However, this functionality often comes at the expense of potentially exposing individuals to privacy breaches by inadvertently revealing their tastes or preferences. Therefore, some users may wish to safeguard their anonymity and opt out of community detection for various reasons, such as affiliation with political or religious organizations. In this study, we address the challenge of community membership hiding, which involves strategically altering the structural properties of a network graph to prevent one or more nodes from being identified by a given community detection algorithm.We tackle this problem by formulating it as a constrained counterfactual graph objective, and we solve it via deep reinforcement learning. We validate the effectiveness of our method through two distinct tasks: node and community deception. Extensive experiments show that our approach overall outperforms existing baselines in both tasks.",
    "authors": [
        {
            "affiliations": [],
            "name": "Andrea Bernini"
        },
        {
            "affiliations": [],
            "name": "Fabrizio Silvestri"
        },
        {
            "affiliations": [],
            "name": "Gabriele Tolomei"
        }
    ],
    "id": "SP:4ed4ea40f2ed977ccfc1ec8f83b2970d841d0d62",
    "references": [
        {
            "authors": [
                "Vincent D. Blondel",
                "Jean-Loup Guillaume",
                "Renaud Lambiotte",
                "Etienne Lefebvre"
            ],
            "title": "Fast Unfolding of Communities in Large Networks",
            "venue": "Journal of Statistical Mechanics: Theory and Experiment 2008,",
            "year": 2008
        },
        {
            "authors": [
                "Ulrik Brandes",
                "Daniel Delling",
                "Marco Gaertler",
                "Robert G\u00f6rke",
                "Martin Hoefer",
                "Zoran Nikoloski",
                "Dorothea Wagner"
            ],
            "title": "On Modularity Clustering",
            "venue": "IEEE Transactions on Knowledge and Data Engineering",
            "year": 2008
        },
        {
            "authors": [
                "Alina Campan",
                "Yasmeen Alufaisan",
                "Traian Marius Truta"
            ],
            "title": "Preserving Communities in Anonymized Social Networks",
            "venue": "Trans. Data Privacy",
            "year": 2015
        },
        {
            "authors": [
                "Xianyu Chen",
                "Zhongyuan Jiang",
                "Hui Li",
                "Jianfeng Ma",
                "Philip S. Yu"
            ],
            "title": "Community Hiding by Link Perturbation in Social Networks",
            "venue": "IEEE Transactions on Computational Social Systems 8,",
            "year": 2021
        },
        {
            "authors": [
                "Ziheng Chen",
                "Fabrizio Silvestri",
                "Jia Wang",
                "He Zhu",
                "Hongshik Ahn",
                "Gabriele Tolomei"
            ],
            "title": "ReLAX: Reinforcement Learning Agent Explainer for Arbitrary Predictive Models",
            "venue": "In Proceedings of the 31st ACM International Conference on Information & Knowledge",
            "year": 2022
        },
        {
            "authors": [
                "Lee R. Dice"
            ],
            "title": "Measures of the Amount of Ecologic Association Between Species",
            "venue": "Ecology 26,",
            "year": 1945
        },
        {
            "authors": [
                "Claire Donnat",
                "Susan Holmes"
            ],
            "title": "Tracking Network Dynamics: A Survey of Distances and Similarity Metrics",
            "year": 2018
        },
        {
            "authors": [
                "Valeria Fionda",
                "Giuseppe Pirr\u00f2"
            ],
            "title": "Community Deception or: How to Stop Fearing Community Detection Algorithms",
            "venue": "IEEE Transactions on Knowledge and Data Engineering 30,",
            "year": 2018
        },
        {
            "authors": [
                "Santo Fortunato"
            ],
            "title": "Community Detection in Graphs",
            "venue": "Physics Reports 486,",
            "year": 2010
        },
        {
            "authors": [
                "Daniele Gammelli",
                "Kaidi Yang",
                "James Harrison",
                "Filipe Rodrigues",
                "Francisco C. Pereira",
                "andMarco Pavone"
            ],
            "title": "GraphNeural Network Reinforcement Learning for Autonomous Mobility-on-Demand Systems",
            "year": 2021
        },
        {
            "authors": [
                "M. Girvan",
                "M.E.J. Newman"
            ],
            "title": "Community Structure in Social and Biological Networks",
            "venue": "Proceedings of the National Academy of Sciences 99,",
            "year": 2002
        },
        {
            "authors": [
                "Aditya Grover",
                "Jure Leskovec"
            ],
            "title": "node2vec: Scalable Feature Learning for Networks",
            "year": 2016
        },
        {
            "authors": [
                "Paul Jaccard"
            ],
            "title": "The Distribution of the Flora in the Alpine Zone",
            "venue": "New Phytologist 11,",
            "year": 1912
        },
        {
            "authors": [
                "Di Jin",
                "Zhizhi Yu",
                "Pengfei Jiao",
                "Shirui Pan",
                "Dongxiao He",
                "Jia Wu",
                "Philip S. Yu",
                "Weixiong Zhang"
            ],
            "title": "A Survey of Community Detection Approaches: From Statistical Modeling to Deep Learning",
            "year": 2021
        },
        {
            "authors": [
                "N. Kalaichelvi",
                "K.S. Easwarakumar"
            ],
            "title": "A Comprehensive Survey on Community Deception Approaches in Social Networks",
            "venue": "In Computer, Communication, and Signal Processing,",
            "year": 2022
        },
        {
            "authors": [
                "Arzum Karata\u015f",
                "Serap \u015eahin"
            ],
            "title": "Application Areas of Community Detection: A Review",
            "venue": "In Proceedings of the International Congress on Big Data, Deep Learning and Fighting Cyber Terrorism (IBIGDELFT). 65\u201370",
            "year": 2018
        },
        {
            "authors": [
                "Thomas N. Kipf",
                "Max Welling"
            ],
            "title": "Semi-Supervised Classification with Graph Convolutional Networks",
            "year": 2017
        },
        {
            "authors": [
                "J. Kreer"
            ],
            "title": "A Question of Terminology",
            "venue": "IRE Transactions on Information Theory 3,",
            "year": 1957
        },
        {
            "authors": [
                "Suchi Kumari",
                "Riteshkumar Jayprakash Yadav",
                "Suyel Namasudra",
                "Ching- Hsien Hsu"
            ],
            "title": "Intelligent deception techniques against adversarial attack on the industrial system",
            "venue": "International Journal of Intelligent Systems 36,",
            "year": 2021
        },
        {
            "authors": [
                "Andrea Lancichinetti",
                "Santo Fortunato",
                "J\u00e1nos Kert\u00e9sz"
            ],
            "title": "Detecting the Overlapping and Hierarchical Community Structure in Complex Networks",
            "venue": "New Journal of Physics 11,",
            "year": 2009
        },
        {
            "authors": [
                "Yiwei Liu",
                "Jiamou Liu",
                "Zijian Zhang",
                "Liehuang Zhu",
                "Angsheng Li"
            ],
            "title": "REM: From Structural Entropy to Community Structure Deception",
            "year": 2019
        },
        {
            "authors": [
                "Ana Lucic",
                "Maartje A. ter Hoeve",
                "Gabriele Tolomei",
                "Maarten de Rijke",
                "Fabrizio Silvestri"
            ],
            "title": "CF-GNNExplainer: Counterfactual Explanations for Graph Neural Networks",
            "venue": "In International Conference on Artificial Intelligence and Statistics,",
            "year": 2022
        },
        {
            "authors": [
                "Shravika Mittal",
                "Debarka Sengupta",
                "Tanmoy Chakraborty"
            ],
            "title": "Hide and Seek: Outwitting Community Detection Algorithms",
            "venue": "IEEE Transactions on Computational Social Systems 8,",
            "year": 2021
        },
        {
            "authors": [
                "Vijaymeena M.K",
                "Kavitha K"
            ],
            "title": "A Survey on Similarity Measures in Text Mining",
            "year": 2016
        },
        {
            "authors": [
                "Volodymyr Mnih",
                "Adri\u00e0 Puigdom\u00e8nech Badia",
                "Mehdi Mirza",
                "Alex Graves",
                "Timothy P. Lillicrap",
                "Tim Harley",
                "David Silver",
                "Koray Kavukcuoglu"
            ],
            "title": "Asynchronous Methods for Deep Reinforcement Learning",
            "year": 2016
        },
        {
            "authors": [
                "Mohammad Javad Mosadegh",
                "Mehdi Behboudi"
            ],
            "title": "Using Social Network Paradigm for Developing a Conceptual Framework in CRM",
            "venue": "Australian Journal of Business and Management Research",
            "year": 2011
        },
        {
            "authors": [
                "Shishir Nagaraja"
            ],
            "title": "The Impact of Unlinkability on Adversarial Community Detection: Effects and Countermeasures",
            "venue": "In Privacy Enhancing Technologies,",
            "year": 2010
        },
        {
            "authors": [
                "Mark E.J. Newman"
            ],
            "title": "Finding Community Structure in Networks Using the Eigenvectors of Matrices",
            "venue": "Phys. Rev. E",
            "year": 2006
        },
        {
            "authors": [
                "Mark E.J. Newman"
            ],
            "title": "Modularity and Community Structure in Networks",
            "venue": "Proceedings of the National Academy of Sciences 103,",
            "year": 2006
        },
        {
            "authors": [
                "Pascal Pons",
                "Matthieu Latapy"
            ],
            "title": "Computing Communities in Large Networks Using Random Walks",
            "year": 2005
        },
        {
            "authors": [
                "Usha Nandini Raghavan",
                "R\u00e9ka Albert",
                "Soundar Kumara"
            ],
            "title": "Near Linear Time Algorithm to Detect Community Structures in Large-Scale Networks",
            "venue": "Phys. Rev. E",
            "year": 2007
        },
        {
            "authors": [
                "J\u00f6rg Reichardt",
                "Stefan Bornholdt"
            ],
            "title": "Statistical Mechanics of Community Detection",
            "venue": "Phys. Rev. E",
            "year": 2006
        },
        {
            "authors": [
                "Peter Ronhovde",
                "Zohar Nussinov"
            ],
            "title": "Multiresolution Community Detection forMegascale Networks by Information-Based Replica Correlations",
            "venue": "Physical Review E 80,",
            "year": 2009
        },
        {
            "authors": [
                "XingMao Ruan",
                "YueHeng Sun",
                "BoWang",
                "Shuo Zhang"
            ],
            "title": "The Community Detection of Complex Networks Based onMarkovMatrix SpectrumOptimization",
            "venue": "In 2012 International Conference on Control Engineering and Communication Technology",
            "year": 2012
        },
        {
            "authors": [
                "C.E. Shannon"
            ],
            "title": "A Mathematical Theory of Communication",
            "venue": "The Bell System Technical Journal 27,",
            "year": 1948
        },
        {
            "authors": [
                "Gabriele Tolomei",
                "Fabrizio Silvestri"
            ],
            "title": "Generating Actionable Interpretations from Ensembles of Decision Trees",
            "venue": "IEEE Transactions on Knowledge and Data Engineering 33,",
            "year": 2021
        },
        {
            "authors": [
                "Gabriele Tolomei",
                "Fabrizio Silvestri",
                "Andrew Haines",
                "Mounia Lalmas"
            ],
            "title": "Interpretable Predictions of Tree-based Ensembles via Actionable Feature Tweaking",
            "venue": "In Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining,",
            "year": 2017
        },
        {
            "authors": [
                "Marcin Waniek",
                "Tomasz P. Michalak",
                "Michael J. Wooldridge",
                "Talal Rahwan"
            ],
            "title": "Hiding Individuals and Communities in a Social Network",
            "venue": "Nature Human Behaviour 2,",
            "year": 2018
        },
        {
            "authors": [
                "Joyce Jiyoung Whang",
                "David F. Gleich",
                "Inderjit S. Dhillon"
            ],
            "title": "Overlapping Community Detection Using Neighborhood-Inflated Seed Expansion",
            "year": 2015
        },
        {
            "authors": [
                "Yunpeng Zhao",
                "Elizaveta Levina",
                "Ji Zhu"
            ],
            "title": "Consistency of Community Detection in Networks Under Degree-Corrected Stochastic Block Models",
            "venue": "The Annals of Statistics 40,",
            "year": 2012
        }
    ],
    "sections": [
        {
            "text": "KEYWORDS community detection, community membership hiding, node deception, community deception, counterfactual graph"
        },
        {
            "heading": "1 INTRODUCTION",
            "text": "In the ever-expanding landscape of interconnected entities, such as social networks, online platforms, and collaborative ecosystems, the identification of coherent communities plays a pivotal role in understanding complex network graph structures [9]. The task of identifying these communities is typically accomplished by running community detection algorithms on the network graphs, which allows the unveiling of hidden patterns and relationships among nodes within these structures. These algorithms effectively group entities, users, or objects based on shared characteristics or interactions, shedding light on the underlying organization and dynamics of the network.\nThe successful detection of communities in complex network graphs is useful in several application domains [16]. For instance, the insights gained from accurately identifying communities can significantly impact business strategies, leading to better monetization opportunities through targeted advertising. By understanding the specific interests and behaviors of community members, businesses can provide better service solutions and tailor advertisements that are more relevant to their customer segments, resulting in higher engagement and increased revenue [26].\nHowever, while community detection algorithms offer immense benefits, they also raise concerns regarding individual privacy and data protection. In some cases, certain nodes within the network\nmight prefer to remain undetected as part of any specific community. These nodes could belong to sensitive or private groups (e.g., political organizations or religious associations) or may simply wish to retain their anonymity for personal reasons. Anyway, the right to opt out of community detection becomes crucial to strike a balance between preserving privacy and maximizing the utility of these algorithms.\nMotivated by the need above, in this paper, we address the intriguing challenge of community membership hiding.\nTaking inspiration from the concept of counterfactual reasoning [36, 37], specifically for graph data [22], our objective is to offer users personalized recommendations to preserve their anonymity from community detection. We effectively guide them in adjusting their connections so that they cannot be identified as members of a given community. For instance, we might suggest to a hypothetical user of a social network, \u201cIf you unfollow users X and Y, you will no longer be recognized as a member of community Z.\u201d\nThe core challenge of this problem lies in determining how to strategically modify the structural properties of a network graph, effectively excluding one or more nodes from being identified by a given community detection algorithm. To the best of our knowledge, we are the first to formulate the community membership hiding problem as a constrained counterfactual graph objective. Furthermore, inspired by [5], we cast this problem into a Markov decision process (MDP) framework and we propose a deep reinforcement learning (DRL) approach to solve it.\nOur method works as follows. We start with a graph and a set of communities identified by a specific community detection algorithm whose inner logic remains unknown or undisclosed. When given a target node within a community, our objective is to find the optimal structural adjustment of the target node\u2019s neighborhood. This adjustment should enable the target node to remain concealed when the same community detection algorithm is reapplied to the modified graph. We refer to this primary task as node deception, and we consider it successful when a predefined similarity threshold between the original community and the new community containing the target node is met. In addition to this, we define a community deception task \u2013 already investigated in the literature [8] \u2013 whose goal is to mask all the nodes of a given community.\nWe validate our approach on three real-world datasets, and we demonstrate that it outperforms existing baselines using standard quality metrics both on node and community deception tasks. Furthermore, unlike their competitors, our method maintains its effectiveness even when used in conjunction with a community detection algorithm that was not seen during the training phase.\nThe main contributions of our work are summarized below.\nar X\niv :2\n31 0.\n08 90\n9v 1\n[ cs\n.S I]\n1 3\nO ct\n2 02\n3\n\u2022 We formulate the community membership hiding problem as a constrained counterfactual graph objective. \u2022 We cast this problem within an MDP framework and solved it via DRL. \u2022 We utilize a graph neural network (GNN) representation to capture the structural complexity of the input graph, which in turn is used by the DRL agent to make its decisions. \u2022 We validate the performance of our method in comparison with existing baselines using standard quality metrics both on node and community deception tasks. \u2022 We publicly release both the source code and the data utilized in this study to encourage reproducibility.1\nThe remainder of this paper is structured as follows. In Section 2, we review related work. Section 3 contains background and preliminaries. We present our problem formulation in Section 4. In Section 5, we describe our method, which we validate through extensive experiments in Section 6. Section 7 discusses the potential ethical impact of our method. Finally, we conclude in Section 8."
        },
        {
            "heading": "2 RELATEDWORK",
            "text": ""
        },
        {
            "heading": "2.1 Community Detection",
            "text": "Community detection algorithms are essential tools in network analysis, aiming to uncover densely connected groups of nodes within a graph. Their applications span various domains, including social network analysis, biology, and economics.\nThese algorithms can be broadly categorized into two types: nonoverlapping and overlapping community detection. Non-overlapping community detection assigns each node to a single community, employing various techniques such as Modularity Optimization [1], Spectrum Analysis [34], Random Walk [30], or Label Propagation [31]. On the other hand, overlapping community detection seeks to better represent real-world networks where nodes can belong to multiple communities. Mature methods have been developed for this purpose, including NISE (Neighborhood-Inflated Seed Expansion) [40] and techniques centered around minimizing the Hamiltonian of the Potts model [33]. For a more comprehensive overview, we recommend consulting the work by Jin et al. [14]"
        },
        {
            "heading": "2.2 Community Deception",
            "text": "Community deception is closely related to the community membership hiding problem we investigate in this work. In fact, community deception can be seen as a specialization of community membership hiding, where the objective is to hide an entire community from community detection algorithms. Community deception can serve various purposes, such as preserving individuals\u2019 anonymity in online monitoring scenarios, like social networks, or aiding public safety by identifying online criminal activities. However, there is also a darker side to these techniques, as malicious actors can exploit them to evade detection algorithms and operate covertly, potentially violating the law.\nSeveral techniques exist for hiding communities, including those based on the concept of Modularity. Notable examples in this category include the algorithm proposed by Nagaraja [27], one of the pioneering approaches in this field, the DICE algorithm introduced\n1https://anonymous.4open.science/r/community-deception-0618/\nby Waniek et al. [39], and the algorithm developed by Fionda and Pirr\u00f2 [8]. Other deception techniques are founded on the idea of Safeness, as defined by Fionda and Pirr\u00f2 [8] and further explored by Chen et al. [4], as well as the concept of Permanence as developed by Mittal et al. [23]. For a more exhaustive summary of these methods, we suggest referring to [15]."
        },
        {
            "heading": "3 BACKGROUND AND PRELIMINARIES",
            "text": "In this section, we will briefly review the definition of the wellknown community detection problem. Afterward, we will utilize this definition as the foundation to provide our formulation of the community membership hiding problem.\nLet G = (V, E) be an arbitrary (directed) graph, where V is a set of \ud835\udc5b nodes (|V| = \ud835\udc5b), and E \u2286 V \u00d7 V is a set of \ud835\udc5a edges (|E | = \ud835\udc5a). Optionally, an additional set of \ud835\udc5d node attributes may also be present. In such cases, each node \ud835\udc62 \u2208 V is associated with a corresponding \ud835\udc5d-dimensional real-valued feature vector \ud835\udc99\ud835\udc62 \u2208 R\ud835\udc5d . Furthermore, the underlying link structure of G is represented using a binary adjacency matrix \ud835\udc68 \u2208 {0, 1}\ud835\udc5b\u00d7\ud835\udc5b , where \ud835\udc68\ud835\udc62,\ud835\udc63 = 1 if and only if the edge (\ud835\udc62, \ud835\udc63) \u2208 E, and it is 0 otherwise.\nThe community detection problem aims to identify clusters of nodes within a graph, called communities. Due to the intricate nature of the concept and its reliance on contextual factors, establishing a universally accepted definition for a \u201ccommunity\u201d is challenging. Intuitively, communities exhibit strong intra-cluster connections and relatively weaker inter-cluster connections [41].\nMore formally, in this work, we adhere to the definition widely used in the literature [8, 19, 21, 23], and we consider a function \ud835\udc53 (\u00b7) that takes a graph as input and generates a partition of its nodesV into a set of non-empty, non-overlapping, communities {C1, . . . , C\ud835\udc58 } as output, i.e., \ud835\udc53 (G) = {C1, . . . , C\ud835\udc58 }, where \ud835\udc58 is usually unknown. Within this framework, every node \ud835\udc62 \u2208 V is assigned to exactly one community. This assignment can be captured using a \ud835\udc58-dimensional stochastic vector \ud835\udc84\ud835\udc62 , where \ud835\udc50\ud835\udc62,\ud835\udc56 = \ud835\udc43 (\ud835\udc62 \u2208 C\ud835\udc56 ) measures the probability that node \ud835\udc62 belongs to community C\ud835\udc56 , and\u2211\ud835\udc58 \ud835\udc56=1 \ud835\udc50\ud835\udc62,\ud835\udc56 = 1. Eventually, we use the notation \ud835\udc56 \u2217 \ud835\udc62 = argmax\ud835\udc56 (\ud835\udc50\ud835\udc62,\ud835\udc56 ) to represent the index of the community to which a specific node \ud835\udc62 belongs to based on the outcome of \ud835\udc53 (G). Note that in the case of hard node partitioning, there exists only one non-zero entry in the vector \ud835\udc84\ud835\udc62 , which evaluates to 1. However, this framework can be extended to scenarios with overlapping communities, where each node can belong to multiple clusters, resulting in more than one non-zero entry in \ud835\udc84\ud835\udc62 . We leave the exploration of overlapping communities for future work.\nTypically, community detection methods operate by maximizing a specific score that measures the intra-community cohesiveness (e.g., Modularity [29]). However, this usually translates into solving NP-hard optimization problems. Hence, some convenient approximations have been proposed in the literature to realize \ud835\udc53 (\u00b7) in practice, e.g., Louvain [1], WalkTrap [30], Greedy [2], InfoMap [3], Label Propagation [31], Leading Eigenvectors [28], Edge-Betweeness [11], SpinGlass [32]. Anyway, the rationale behind how communities are found is irrelevant to our task, and, hereinafter, we will treat the community detection technique \ud835\udc53 (\u00b7) as a \u201cblack box\u201d."
        },
        {
            "heading": "4 COMMUNITY MEMBERSHIP HIDING",
            "text": "In a nutshell, community membership hiding aims to enable a target node within a graph to elude being recognized as a member of a particular node cluster, as determined by a community detection algorithm. This objective is accomplished by granting the node in question the ability to strategically modify its connections with other nodes. Therefore, our primary focus is on making changes to the graph\u2019s structure, represented by the adjacencymatrix.While altering node features holds potential interest, that aspect is reserved for future exploration. We depict our approach in Fig. 1."
        },
        {
            "heading": "4.1 Problem Formulation",
            "text": "Let G = (V, E) be a graph and \ud835\udc53 (G) = {C1, . . . , C\ud835\udc58 } denote the community arrangement derived from applying a detection algorithm \ud835\udc53 (\u00b7) to G. Furthermore, suppose that \ud835\udc53 has identified node \ud835\udc62 \u2208 V as a member of the community C\ud835\udc56 \u2208 \ud835\udc53 (G) \u2013 i.e., \ud835\udc56\u2217\ud835\udc62 = \ud835\udc56 \u2013 denoted as \ud835\udc62 \u2208 C\ud835\udc56 . The aim of community membership hiding is to formulate a function \u210e\ud835\udf3d (\u00b7), parametrized by \ud835\udf3d , that takes as input the initial graph G and produces as output a new graph \u210e\ud835\udf3d (G) = G\u2032 = (V, E\u2032). Among all the possible graphs, we seek the one which, when input to the community detection algorithm \ud835\udc53 , disassociates a target node \ud835\udc62 from its original community C\ud835\udc56 . To achieve that goal, suppose that the target node\ud835\udc62 is associated with a new community C\u2032\n\ud835\udc56 \u2208 \ud835\udc53 (G\u2032). Hence, we can define the objective of\ncommunity membership hiding by establishing a threshold for the similarity between C\u2032\n\ud835\udc56 and C\ud835\udc56 , excluding the target node \ud835\udc62, which,\nby definition, belongs to both communities. In other words, we set a condition: \ud835\udc60\ud835\udc56\ud835\udc5a(C\ud835\udc56 \u2212 {\ud835\udc62}, C\u2032\ud835\udc56 \u2212 {\ud835\udc62}) \u2264 \ud835\udf0f , where \ud835\udf0f \u2208 [0, 1]. 2\nSeveral similarity measures can be used to measure \ud835\udc60\ud835\udc56\ud835\udc5a(\u00b7, \u00b7) depending on the application domain, e.g., the overlap coefficient 2We assume \ud835\udc60\ud835\udc56\ud835\udc5a ( \u00b7, \u00b7 ) ranges between 0 and 1.\n(a.k.a. Szymkiewicz\u2013Simpson coefficient) [24], the Jaccard coefficient [13], and the S\u00f8rensen-Dice coefficient [6].\nSetting \ud835\udf0f = 0 represents the most stringent scenario, where we require zero overlaps between C\u2032\n\ud835\udc56 and C\ud835\udc56 , except for the node\ud835\udc62 itself.\nAt the other extreme, when \ud835\udf0f = 1, we adopt a more tolerant strategy, allowing for maximum overlap between C\u2032\n\ud835\udc56 and C\ud835\udc56 . However, it is\nimportant to note that except for the overlap coefficient, which can yield a value of 1 even if one community is a subset of the other, the Jaccard and S\u00f8rensen-Dice coefficients yield a value of 1 only when the two communities are identical. In practice, setting \ud835\udf0f = 1 may lead to the undesired outcome of C\u2032\n\ud835\udc56 being equal to C\ud835\udc56 , thus\ncontradicting the primary goal of community membership hiding. Therefore, it is common to let \ud835\udf0f \u2208 [0, 1) to avoid this scenario.\nMoreover, it is essential to emphasize that executing \ud835\udc53 on G\u2032 instead of the original G could potentially influence (\ud835\udc56) the community affiliations of nodes beyond the selected target, \ud835\udc62, and (\ud835\udc56\ud835\udc56) the eventual count of recognized communities (i.e., |\ud835\udc53 (G\u2032) | = \ud835\udc58\u2032 \u2260 \ud835\udc58 = |\ud835\udc53 (G)|), providing that \ud835\udc53 does not need this number fixed apriori as one of its inputs. Therefore, community membership hiding must strike a balance between two conflicting goals. On the one hand, the target node \ud835\udc62 must be successfully elided from the original community C\ud835\udc56 ; on the other hand, the cost of such an operation \u2013 i.e., the \u201cdistance\u201d between G and G\u2032, and between \ud835\udc53 (G) and \ud835\udc53 (G\u2032) \u2013 must be as small as possible.\nOverall, we can define the following loss function associated with the community membership hiding task:\nL(\u210e\ud835\udf3d ;G, \ud835\udc53 , \ud835\udc62) = \u2113decept (G, \u210e\ud835\udf3d (G); \ud835\udc53 ,\ud835\udc62) + \ud835\udf06\u2113dist (G, \u210e\ud835\udf3d (G); \ud835\udc53 ). (1)\nThe first component (\u2113decept) penalizes when the goal is not satisfied. Let \u0393 be the set of input graphs which do not meet the membership hiding objective, i.e., those which retain node \ud835\udc62 as part of the community C\ud835\udc56 . More formally, let C\u0303\ud835\udc56 be the community to which node \ud835\udc62 is assigned when \ud835\udc53 is applied to the input graph G\u0303. We define \u0393 = {G\u0303 | \ud835\udc60\ud835\udc56\ud835\udc5a(C\ud835\udc56 \u2212 {\ud835\udc62}, C\u0303\ud835\udc56 \u2212 {\ud835\udc62}) > \ud835\udf0f}. Thus, we can compute \u2113decept as follows:\n\u2113decept (G, \u210e\ud835\udf3d (G); \ud835\udc53 ) = 1\u0393 (\u210e\ud835\udf3d (G)), (2)\nwhere 1\u0393 (\u210e\ud835\udf3d (G)) is the well-known 0-1 indicator function, which evaluates to 1 if \u210e\ud835\udf3d (G) \u2208 \u0393, or 0 otherwise.\nThe second component, denoted as \u2113dist, is a composite function designed to assess the overall dissimilarity between two graphs and their respective communities found by \ud835\udc53 . This function serves the dual purpose of (\ud835\udc56) discouraging the new graph \u210e\ud835\udf3d (G) from diverging significantly from the original graph G and (\ud835\udc56\ud835\udc56) preventing the new community structure \ud835\udc53 (\u210e\ud835\udf3d (G)) from differing substantially from the prior community structure \ud835\udc53 (G)."
        },
        {
            "heading": "4.2 Counterfactual Graph Objective",
            "text": "Given the target community C\ud835\udc56 , from which we want to exclude node \ud835\udc62, we can classify the remaining nodesV \u2212 {\ud835\udc62} of G into two categories: nodes that are inside the same community C\ud835\udc56 as \ud835\udc62 and nodes that belong to a different community from \ud835\udc62. This categorization helps us define which edges the target node \ud835\udc62 can control and, thus, directly manipulate under the assumption that G is a directed graph.3 Specifically, following [8], we assume that \ud835\udc62 can (\ud835\udc56) remove\n3We can easily extend this reasoning if G is undirected.\nexisting outgoing edges to nodes that are inside \ud835\udc62\u2019s community (\ud835\udc56\ud835\udc56) add new outgoing edges to nodes that are outside \ud835\udc62\u2019s community. We intentionally exclude two possible actions: (\ud835\udc56\ud835\udc56\ud835\udc56) removing outgoing links to outside-community nodes and (\ud835\udc56\ud835\udc63) adding outgoing links to inside-community nodes. Two primary reasons drive this choice. On the one hand, allowing (\ud835\udc56\ud835\udc56\ud835\udc56) could isolate \ud835\udc62 and its original community C\ud835\udc56 further. On the other hand, allowing (\ud835\udc56\ud835\udc63) would enhance connectivity between \ud835\udc62 and other nodes in C\ud835\udc56 . Both events contradict the goal of community membership hiding.\nOverall, we can define the set of candidate edges to remove (E\u2212 \ud835\udc62,\ud835\udc56\n) and to add (E+\n\ud835\udc62,\ud835\udc56 ) as follows.\nE\u2212\ud835\udc62,\ud835\udc56 = {(\ud835\udc62, \ud835\udc63) | \ud835\udc62, \ud835\udc63 \u2208 C\ud835\udc56 \u2227 (\ud835\udc62, \ud835\udc63) \u2208 E}, E+\ud835\udc62,\ud835\udc56 = {(\ud835\udc62, \ud835\udc63) | \ud835\udc62 \u2208 C\ud835\udc56 , \ud835\udc63 \u2209 C\ud835\udc56 \u2227 (\ud835\udc62, \ud835\udc63) \u2209 E}.\nIf we suppose the target node \ud835\udc62 has a fixed budget \ud835\udefd > 0, we can find the optimal model \u210e\u2217 = \u210e\ud835\udf3d \u2217 as the one whose parameters \ud835\udf3d \u2217 minimize Eq. (1), i.e., by solving the following constrained objective:\n\ud835\udf3d \u2217 = arg min \ud835\udf3d\n{ L(\u210e\ud835\udf3d ;G, \ud835\udc53 , \ud835\udc62) } subjetc to: |B\ud835\udc62,\ud835\udc56 | \u2264 \ud835\udefd,\n(3)\nwhere B\ud835\udc62,\ud835\udc56 \u2286 E\u2212\ud835\udc62,\ud835\udc56 \u222a E + \ud835\udc62,\ud835\udc56\nis the set of graph edge modifications selected from the candidates.\nNote that Eq. (3) resembles the optimization task to find the best counterfactual graph G\u2217 = \u210e\u2217 (G) that, when fed back into \ud835\udc53 , changes its output to hide the target node \ud835\udc62 from its community."
        },
        {
            "heading": "4.3 Markov Decision Process",
            "text": "The community membership hiding problem defined in Eq. (3) requires minimizing a discrete, non-differentiable loss function. As such, standard optimization methods like stochastic gradient descent are unsuitable for this task. One potential solution involves smoothing the loss function using numerical techniques, such as applying a real-valued perturbation matrix to the original graph\u2019s adjacency matrix like in [22, 38]. We leave the exploration of these smoothing techniques for future work. Instead, we take a different approach and cast this problem as a sequential decision-making process, following standard reinforcement learning principles.\nIn this framework, at each time step, an agent: (i) takes an action (choosing to add or remove an edge based on the rules defined above), and (ii) observes the new set of communities output by \ud835\udc53 when this is fed with the graph modified according to the action taken before. The agent also receives a scalar reward from the environment. The process continues until the agent eventually meets the specified deception goal and the optimal counterfactual graph G\u2217 \u2013 i.e., the optimal \u210e\u2217 \u2013 is found.\nWe formalize this procedure as a typical Markov decision process (MDP) denoted asM = {S,A,P, \ud835\udc5d0, \ud835\udc5f , \ud835\udefe}. Below, we describe each component of this framework separately. States (S). At each time step \ud835\udc61 , the agent\u2019s state is \ud835\udc46\ud835\udc61 = \ud835\udc60\ud835\udc61 , where \ud835\udc60\ud835\udc61 = G\ud835\udc61 \u2208 S is the current modified input graph. In practice, though, we can replace G\ud835\udc61 with its associated adjacency matrix \ud835\udc68\ud835\udc61 \u2208 {0, 1}\ud835\udc5b\u00d7\ud835\udc5b . Initially, when \ud835\udc61 = 0, G0 = G (\ud835\udc680 = \ud835\udc68). Actions (A). The set of actions is defined by A = {\ud835\udc4e\ud835\udc61 }, which consists of all valid graph rewiring operations, assuming node \ud835\udc62\nbelongs to the community \ud835\udc36\ud835\udc56 .\nA = {del(\ud835\udc62, \ud835\udc63) | (\ud835\udc62, \ud835\udc63) \u2208 E\u2212\ud835\udc62,\ud835\udc56 } \u222a {add(\ud835\udc62, \ud835\udc63) | (\ud835\udc62, \ud835\udc63) \u2208 E + \ud835\udc62,\ud835\udc56 }. (4)\nAccording to the allowed graph modifications outlined in Section 4.2, the agent can choose between two types of actions: deleting an edge from \ud835\udc62 to any node within the same community \ud835\udc36\ud835\udc56 or adding an edge from \ud835\udc62 to any node in a different community. Transitions Probability (P). Let \ud835\udc4e\ud835\udc61 \u2208 A be the action taken by the agent at iteration \ud835\udc61 . This action deterministically guides the agent\u2019s transition from the state \ud835\udc60\ud835\udc61 to the state \ud835\udc60\ud835\udc61+1. In essence, the transition function P : S \u00d7 A \u00d7 S \u2192 [0, 1], which associates a transition probability with each state-action pair, assigns a transition probability of 1 when the subsequent state \ud835\udc60\ud835\udc61+1 is determined by the state-action pair (\ud835\udc60\ud835\udc61 , \ud835\udc4e\ud835\udc61 ) and 0 otherwise. Formally:\n\u2022 P(\ud835\udc60\ud835\udc61+1 |\ud835\udc60\ud835\udc61 , \ud835\udc4e\ud835\udc61 ) = 1 if \ud835\udc60\ud835\udc61+1 is the next state resulting from the application of action \ud835\udc4e\ud835\udc61 in state \ud835\udc60\ud835\udc61 .\n\u2022 P(\ud835\udc60\ud835\udc61+1 |\ud835\udc60\ud835\udc61 , \ud835\udc4e\ud835\udc61 ) = 0 otherwise. Reward (\ud835\udc5f ). The reward function of the action \ud835\udc4e\ud835\udc61 which takes the agent from state \ud835\udc60\ud835\udc61 to state \ud835\udc60\ud835\udc61+1 can be defined as:\n\ud835\udc5f (\ud835\udc60\ud835\udc61 , \ud835\udc4e\ud835\udc61 ) = { 1 \u2212 \ud835\udf06(\u2113\ud835\udc61dist \u2212 \u2113 \ud835\udc61\u22121 dist ) , if \u201cthe goal is met\u201d\n\u2212\ud835\udf06(\u2113\ud835\udc61dist \u2212 \u2113 \ud835\udc61\u22121 dist ) , otherwise.\n(5)\nThe goal is considered successfully achieved when \ud835\udc53 (G\ud835\udc61 ) leads to \ud835\udc62 \u2208 C\ud835\udc61\n\ud835\udc56 \u2260 C\ud835\udc56 such that \ud835\udc60\ud835\udc56\ud835\udc5a(C\ud835\udc56 \u2212 {\ud835\udc62}, C\ud835\udc61\ud835\udc56 \u2212 {\ud835\udc62}) \u2264 \ud835\udf0f . In addition,\n\u2113\ud835\udc61dist = \u2113dist (G,G \ud835\udc61 ; \ud835\udc53 ) measures the penalty computed on the graph before and after action \ud835\udc4e\ud835\udc61 , and \ud835\udf06 \u2208 R>0 is a parameter that controls its weight. More precisely, the penalty is calculated as follows:\n\u2113dist (G,G\ud835\udc61 ; \ud835\udc53 ) = \ud835\udefc \u00d7 \ud835\udc51community + (1 \u2212 \ud835\udefc) \u00d7 \ud835\udc51graph, (6) where \ud835\udc51community computes the distance between the community structures \ud835\udc53 (G) and \ud835\udc53 (G\ud835\udc61 ), \ud835\udc51graph measures the distance between the two graphs G and G\ud835\udc61 , and the parameter \ud835\udefc \u2208 [0, 1] balances the importance between the two distances.\nHence, the reward function encourages the agent to take actions that preserve the similarity between the community structures and the graphs before and after the rewiring action. Policy (\ud835\udf0b\ud835\udf3d ).We first define a parameterized policy \ud835\udf0b\ud835\udf3d that maps from states to actions. We then want to find the values of the policy parameters \ud835\udf3d that maximize the expected reward in the MDP. This is equivalent to finding the optimal policy \ud835\udf0b\u2217, which is the policy that gives the highest expected reward for any state. We can find the optimal policy \ud835\udf0b\u2217 by minimizing the Eq. (3). This minimization leads to the discovery of the optimal model \u210e\u2217, which is the model that best predicts the rewards in the MDP.\n\ud835\udf3d \u2217 = arg min \ud835\udf3d \u2113decept (\u210e\ud835\udf3d ;G, \ud835\udc53 , \ud835\udc62) + \ud835\udf06\u2113dist (G, \u210e\ud835\udf3d (G); \ud835\udc53 )\n= arg max \ud835\udf3d \u2212 \u2113decept (\u210e\ud835\udf3d ;G, \ud835\udc53 , \ud835\udc62) \u2212 \ud835\udf06\u2113dist (G, \u210e\ud835\udf3d (G); \ud835\udc53 )\n= arg max \ud835\udf3d\n{ 1 \u2212 \ud835\udf06(\u2113\ud835\udc61dist \u2212 \u2113 \ud835\udc61\u22121 dist ) , if \u201cthe goal is met\u201d\n\u2212\ud835\udf06(\u2113\ud835\udc61dist \u2212 \u2113 \ud835\udc61\u22121 dist ) , otherwise\n= arg max \ud835\udf3d \ud835\udc47\u2211\ufe01 \ud835\udc61=1 \ud835\udc5f (\ud835\udc60\ud835\udc61 , \ud835\udf0b\ud835\udf3d (\ud835\udc60\ud835\udc61 )),\n(7)\nwhere \ud835\udc47 is the maximum number of steps per episode taken by the agent and is therefore always less than the allowed number of graph manipulations, i.e., \ud835\udc47 \u2264 \ud835\udefd ."
        },
        {
            "heading": "5 PROPOSED METHOD",
            "text": "To learn the optimal policy for our agent defined above, we use the Advantage Actor-Critic (A2C) algorithm [25], a popular deep reinforcement learning technique that combines the advantages of both policy-based and value-based methods. Specifically, A2C defines two neural networks, one for the policy function (\ud835\udf0b\ud835\udf3d ) and another for the value function estimator (\ud835\udc49\ud835\udc63 ), such that:\n\u2207\ud835\udf3dJ (\ud835\udf3d ) \u223c \ud835\udc47\u22121\u2211\ufe01 \ud835\udc61=0 \u2207\ud835\udf3d log\ud835\udf0b\ud835\udf3d (\ud835\udc4e\ud835\udc61 |\ud835\udc60\ud835\udc61 )\ud835\udc34(\ud835\udc60\ud835\udc61 , \ud835\udc4e\ud835\udc61 ),\nwith \ud835\udc34(\ud835\udc60\ud835\udc61 , \ud835\udc4e\ud835\udc61 ) = \ud835\udc5f\ud835\udc61+1 + \ud835\udefe\ud835\udc49\ud835\udc63 (\ud835\udc60\ud835\udc61+1) \u2212\ud835\udc49\ud835\udc63 (\ud835\udc60\ud835\udc61 ),\nwhere J (\ud835\udf3d ) is the reward function, and the goal is to find the optimal policy parameters \ud835\udf3d that maximize it.\ud835\udc34(\ud835\udc60\ud835\udc61 , \ud835\udc4e\ud835\udc61 ) is the advantage function that quantifies how good or bad an action \ud835\udc4e\ud835\udc61 is compared to the expected value of actions chosen based on the current policy.\nBelow, we describe the policy (actor) and value function network (critic) separately. The full details of how our agent is trained are provided in Appendix A."
        },
        {
            "heading": "5.1 Policy Function Network (Actor)",
            "text": "The policy function network is responsible for generating a probability distribution over possible actions based on the input, which consists of a list of nodes and the graph\u2019s feature matrix. However, some graphs may lack node features. In such cases, we can extract continuous node feature vectors (i.e., node embeddings) with graph representational learning frameworks like node2vec [12]. These node embeddings serve as the feature matrix.\nOur neural network implementation comprises a primary graph convolution layer (GCNConv [17]) for updating node features. The output of this layer, along with skip connections, feeds into a block consisting of three hidden layers. Each hidden layer includes multilayer perception (MLP) layers, ReLU activations, and dropout layers. The final output is aggregated using a sum-pooling function. In building our network architecture, we were inspired, in part, by the work conducted by Gammelli et al. [10], adapting it to our task. The policy is trained to predict the probability that node \ud835\udc63 is the optimal choice for adding or removing the edge (\ud835\udc62, \ud835\udc63) to hide the target node \ud835\udc62 from its original community. The feasible actions depend on the input node \ud835\udc62 and are restricted to a subset of the graph\u2019s edges as outlined in Section 4.2. Hence, not all nodes \ud835\udc63 \u2208 V are viable options for the policy."
        },
        {
            "heading": "5.2 Value Function Network (Critic)",
            "text": "This network resembles the one employed for the policy, differing only in one aspect: it incorporates a global sum-pooling operation on the convolution layer\u2019s output. This pooling operation results in an output layer with a size of 1, signifying the estimated value of the value function. The role of the value function is to predict the state value when provided with a specific action \ud835\udc4e\ud835\udc61 and state \ud835\udc60\ud835\udc61 ."
        },
        {
            "heading": "6 EXPERIMENTS",
            "text": ""
        },
        {
            "heading": "6.1 Experimental Setup",
            "text": "Datasets. To keep the training time for our DRL agent computationally feasible, we train it on the real dataset words,4 This dataset strikes a favorable balance in terms of the number of nodes, edges, and discovered communities. A swift growth in the number of nodes and edges would lead to an exponential rise in potential actions for the agent. This, in turn, would result in impractical training times given our computational resources.\nIn addition, we evaluate the performance of our method on two additional datasets: kar4 and Wikipedia\u2019s vote.5\nCommunity Detection Algorithms. The DRL agent is trained using a single detection algorithm, i.e., our \ud835\udc53 (\u00b7), namely themodularitybased Greedy (greedy) algorithm [2].\nAt test time, we employ two additional algorithms. One of them, the Louvain (louvain) algorithm [1], falls within the same family as the one used for training. The other, the WalkTrap (walktrap) [30], takes a distinct approach centered on Random Walks.\nTable 1 provides an overview of the datasets used, including key properties and the number of communities detected by each community detection algorithm. The modularity-based algorithms (greedy and louvain) yield comparable community counts, while walktrap identifies a generally higher number of communities. Similarity/Distance Metrics. To assess the achievement of the goal, i.e., whether the new community C\ud835\udc61\n\ud835\udc56 of node \ud835\udc62 at step \ud835\udc61 can\nno longer be considered the same as the initial community C\ud835\udc56 , we need to define the \ud835\udc60\ud835\udc56\ud835\udc5a(\u00b7) function used within \u2113decept. We employ the S\u00f8rensen-Dice coefficient [6], which is defined as follows:\nDSC(C\ud835\udc56 , C\ud835\udc61\ud835\udc56 ) = 2|C\ud835\udc56\n\u22c2C\ud835\udc61 \ud835\udc56 |\n|C\ud835\udc56 | + |C\ud835\udc61\ud835\udc56 | . (8)\nThis metric returns a value between 0 (no similarity) and 1 (strong similarity). If that value is less than or equal to the parameter \ud835\udf0f , we consider the deception goal successfully met.\nFurthermore, as described in Eq. (6), we must specify the penalty function (\u2113dist), which consists of two mutually balanced factors, namely\ud835\udc51community and\ud835\udc51graph. These factors quantify the dissimilarity between community structures and graphs before and after the action. During model training, we operationalize these distances using the Normalized Mutual Information (NMI) score for community comparison and the Jaccard distance for graph comparison.\nThe NMI score [18, 35], utilized for measuring the similarity between community structures, ranges from 0 (indicating nomutual information) to 1 (indicating perfect correlation).\n4http://konect.cc/ 5https://networkrepository.com\nFollowing the formulation by [20], it can be expressed as follows:\nNMI(K,K\ud835\udc61 ) = \ud835\udc3cnorm (\ud835\udc4b : \ud835\udc4c ) = \ud835\udc3b (\ud835\udc4b ) + \ud835\udc3b (\ud835\udc4c ) \u2212 \ud835\udc3b (\ud835\udc4b,\ud835\udc4c )\n(\ud835\udc3b (\ud835\udc4b ) + \ud835\udc3b (\ud835\udc4c ))/2 , (9)\nwhere \ud835\udc3b (\ud835\udc4b ) and \ud835\udc3b (\ud835\udc4c ) denote the entropy of the random variables \ud835\udc4b and \ud835\udc4c associated with partitions K = \ud835\udc53 (G) and K\ud835\udc61 = \ud835\udc53 (G\ud835\udc61 ), respectively, while \ud835\udc3b (\ud835\udc4b,\ud835\udc4c ) denotes the joint entropy. Since we need to transform this metric into a distance, we calculate 1-NMI.\nThe Jaccard distance can be adapted to the case of two graphs, as described in [7], as follows:\nJaccard(G,G\ud835\udc61 ) = |G \u22c3G\ud835\udc61 | \u2212 |G\u22c2G\ud835\udc61 | |G\u22c3G\ud835\udc61 | = \u2211 \ud835\udc56, \ud835\udc57 |\ud835\udc68\ud835\udc56, \ud835\udc57 \u2212\ud835\udc68\ud835\udc61\ud835\udc56, \ud835\udc57 |\u2211 \ud835\udc56, \ud835\udc57 max(\ud835\udc68\ud835\udc56,\ud835\udc57 ,\ud835\udc68\ud835\udc61\ud835\udc56,\ud835\udc57 ) ,\n(10) where \ud835\udc68\ud835\udc56, \ud835\udc57 denotes the (\ud835\udc56, \ud835\udc57)-th entry of the adjacency matrix for the original graph G. The Jaccard distance yields a value of 0 when the two graphs are identical and 1when they are entirely dissimilar. Tasks. We validate our method on two separate tasks: node deception and community deception. The former directly stems from the community membership hiding problem defined in Section 4. Its goal is to conceal an individual node from the community to which it was initially identified. The latter, instead, can be seen as a specific instance of node deception, where the objective is to hide an entire community from a designated detection algorithm. In essence, this involves performing multiple node deception tasks, one for each node within the community to be masked. Actually, this is a simplification of the process since each node deception task may indirectly hide other nodes within the same community."
        },
        {
            "heading": "6.2 Node Deception Task",
            "text": "Baselines. 1) Random-based. This baseline operates by randomly selecting one of the nodes in the graph. If the selected node is a neighbor of the node to be hidden (i.e., there is an edge between them), the edge is removed; otherwise, it is added. The randomness of these decisions aims to obscure the node\u2019s true community membership. 2) Degree-based. This approach adopts a different strategy for node concealment. Specifically, it selects nodes with the highest degrees within the graph and rewires them. By prioritizing nodes with higher degrees, this baseline seeks to disrupt the node\u2019s central connections within its initial community, thus promoting concealment. 3) Roam-based. Our third baseline is based on the Roam heuristics [39], originally designed to reduce a node\u2019s centrality within the network. This hiding approach aims to diminish the centrality and influence of the target node within its initial community, making it less conspicuous and favoring its deception. Evaluation Metrics.We measure the performance of each method in solving the node deception task using the following metrics. 1) Success Rate (SR). This metric calculates the success rate of the node deception algorithm by determining the percentage of times the target node is successfully hidden from its original community. If, after applying the node deception algorithm, the target node no longer belongs to the original community (as per Eq. (8) and the \ud835\udf0f constraint), we consider the goal achieved. By repeating this procedure for several nodes and communities, we can estimate the algorithm\u2019s success rate. Obviously, a higher value of this metric indicates better performance.\n2) Normalized Mutual Information (NMI). To quantify the impact of the function\u210e\ud835\udf3d (\u00b7) on the resulting community structure, denoted as the output of \ud835\udc53 (G\u2032) where G\u2032 is the graph created by modifying the original graph G, we compute NMI(K,K\u2032), as outlined in Eq. (9). This score measures the similarity between the two structures, K = \ud835\udc53 (G) andK\u2032 = \ud835\udc53 (G\u2032). A higher value for this metric indicates a greater degree of similarity between the original and modified community structures."
        },
        {
            "heading": "6.3 Community Deception Task",
            "text": "Description. We adapt our method, originally conceived for the node deception task, to the community deception task as follows. We iterate the execution of our agent on every node of the community to hide. In doing so, we fulfill the constraint on the number of possible actions (i.e., graph rewirings). Specifically, we set the same constraint as in [8], which limits the percentage of edges of the graph that can be modified. To make more efficient use of its budget, our agent, at each step, ranks the nodes within the community to hide based on their centrality degrees, starting with the most central node and progressing to the least central. This selection process prioritizes highly central nodes; hence, the agent is more likely to mask more nodes within the target community using the same budget compared to selecting nodes randomly. In the next step, based on the number of actions performed, the agent chooses another node to hide from the remaining nodes within the target community, with the budget adjusted accordingly. We describe this procedure in Algorithm 1, provided in Appendix B. Baselines.We compare our method with two of the most popular community deception algorithms available in the literature, both proposed in [8]. Those are Modularity-based and Safeness-based. Evaluation Metrics. We validate the quality of each method considered by comparing the community structures obtained before and after applying the node deception function \u210e\ud835\udf3d (\u00b7). In particular, we calculate the Deception Score as defined in [8] and the NMI described in Eq. (9).\nThe Deception Score (H ) evaluates the level of concealment of a set of nodes C\ud835\udc56 , within a community structure K identified by a detection algorithm \ud835\udc53 (\u00b7), i.e., K = \ud835\udc53 (G). It is defined as follows:\nH(C\ud835\udc56 ,K) = ( 1 \u2212 |\ud835\udc46 (C\ud835\udc56 ) | \u2212 1|C\ud835\udc56 | \u2212 1 ) \u00d7[\n1 2 (1 \u2212 max C\ud835\udc57 \u2208K {\ud835\udc45(C\ud835\udc57 , C\ud835\udc56 )}) + 1 2\n( 1 \u2212 \u2211 C\ud835\udc57\u2229C\ud835\udc56\u2260\u2205 \ud835\udc43 (C\ud835\udc57 , C\ud835\udc56 ) |C\ud835\udc57 \u2229 C\ud835\udc56 \u2260 \u2205| ) ] ,\nwhere \ud835\udc45(C\ud835\udc57 , C\ud835\udc56 ) is the recall, \ud835\udc43 (C\ud835\udc57 , C\ud835\udc56 ) is the precision, and |\ud835\udc46 (C\ud835\udc56 ) | is the number of connected components in the subgraph induced by the members of C\ud835\udc56 .\nThe Deception Score yields values ranging from 0 to 1 and quantifies the hiddenness of the target community. Specifically, it measures several desiderata: reachability preservation, community spread, and community hiding. Higher values of this metric correspond with better deception."
        },
        {
            "heading": "6.4 Results and Discussion",
            "text": "The experiments were conducted on the Kaggle platform,6 which provides an Intel Xeon CPU at 2.2 GHz (4 cores) and 18 GB RAM. This section is divided into two paragraphs to present the results of the two distinct tasks: node deception and community deception. Node Deception Task. In this study, we evaluate our DRL-Agent\u2019s performance against the baseline methods discussed in Section 6.2. We investigate various parameter settings, including different values for the similarity constraint \ud835\udf0f (0.3, 0.5, 0.8) and the budget \ud835\udefd ( 12 \ud835\udf07, 1\ud835\udf07, 2\ud835\udf07, where \ud835\udf07 = | E | |V | ). We evaluate all possible combinations of these parameters. For each parameter combination, dataset, and community detection algorithm, we conducted a total of 100 experiments. In each iteration, we randomly select a node from a different community than the previous one for concealment. The reported results are based on the average outcomes across all runs.\nHere, we emphasize two primary findings. Firstly, our approach consistently surpasses baseline techniques when trained on the same community detection algorithm employed for the node deception task (symmetric setup). In Fig. 2, we present the Success Rate and NMI score for our DRL-Agent trained and tested on the modularity-based Greedy algorithm.\nA crucial observation is that our method strikes the best balance between the Success Rate and the NMI score. On the one hand, it achieves a higher success rate in hiding the selected target node than competing methods (reaching up to 80% with an improvement of approximately 15% over the best-performing baseline). On the other hand, our approach pays a limited price for this success (i.e., the modified graph remains relatively similar to the original one), as evidenced by the NMI score compared to other methods. In fact, for the words and vote datasets, the NMI score achieved by our DRL-Agent is similar to that of the baselines. In the case of the kar dataset, our method\u2019s NMI score is slightly lower than that of, for example, Roam. However, while our method accomplishes the node deception task around 50% of the time, Roam always fails.\nThe second key finding concerns the ability of our DRL-Agent to transfer to a different community detection algorithm (asymmetric setup). Specifically, we evaluate the performance of our method, which was trained on the modularity-based Greedy algorithm, in\n6https://www.kaggle.com/\nthe context of a node deception task that utilizes a different community detection algorithm, namely the Louvain algorithm. As illustrated in Fig. 3, both the baselines and our DRL-Agent achieve even higher success rates in this asymmetric setting, with our method maintaining its superiority. Naturally, this outcome has a more substantial impact on the NMI score. However, intriguingly, the disparity between our method\u2019s NMI and other approaches becomes even less pronounced than in the previous symmetric setup.\nSimilar conclusions can be drawn for the other community detection algorithms considered and using different combinations of values for the key parameters \ud835\udf0f and \ud835\udefd . The complete results for the node deception task are outlined in Appendix C.1. Community Deception Task.We evaluate our method against the baselines outlined in Section 6.3, using the same datasets, detection algorithms, and \ud835\udf0f constraint values as the node deception task, with the only difference being the variation of \ud835\udefd (1, 3, 5) due to its distinct interpretation. For smaller to medium-sized datasets, the number of rewirings is fixed based on [8]. Conversely, for larger datasets, we define \ud835\udefd as a ratio of the community size to hide (e.g., \ud835\udefd = 0.1|C\ud835\udc56 |).\nAs with the node deception task, we examine two distinct scenarios: symmetric and asymmetric. The former involves our DRL-Agent trained on the same modularity-based community detection algorithm as used during deception, i.e., the Greedy algorithm. The latter, instead, assesses the agent\u2019s capability to adapt to a different community detection algorithm (Louvain) during deception, despite being still trained on the Greedy algorithm (transferability).\nIn Fig. 4 and Fig. 5, we report the Deception Score (H ) and NMI score for our DRL-Agent in the symmetric and asymmetric setup, respectively.\nMuch like our findings in the node deception task, our approach finds the optimal trade-off between these two quality metrics. This observation holds even more significance for the larger dataset (vote), where our agent not only achieves the highest Deception Score but also the best NMI score. Moreover, our DRL-Agent demonstrates the ability to transfer its performance to a community detection algorithm that differs from the one it was trained on.\nIn summary, across various algorithms and datasets, a common trend emerges: as the \ud835\udf0f similarity constraint increases, the performance of the DRL-Agent on the community deception task typically decreases. This phenomenon may arise because the agent achieves the node deception objective with fewer rewirings, resulting in\nfewer actions targeting nodes with high centrality, as they are typically among the first analyzed by the algorithm. The full results of the community deception task can be found in Appendix C.2."
        },
        {
            "heading": "6.5 Parameter Sensitivity",
            "text": "The effectiveness of ourDRL-Agent relies on two critical parameters: (\ud835\udc56) the similarity threshold (\ud835\udf0f ) used to determine whether the node deception goal has been achieved or not, and (\ud835\udc56\ud835\udc56) the budget (\ud835\udefd) to limit the effort \u2013 i.e., graph modifications \u2013 performed to achieve the goal. In this section, we analyze their impact. Specifically, in Table 2 and Table 3, we explore how the SR and NMI metrics for the node deception task are influenced by varying the values of \ud835\udf0f and \ud835\udefd , while keeping the detection algorithm \ud835\udc53 (\u00b7) and dataset fixed.\nThese results reinforce the previously mentioned findings: our method consistently achieves a superior balance between SR and NMI. Indeed, for instance, Roam has a milder impact on the graph structure, but it frequently fails to achieve the node deception goal. On the other hand, our DRL-Agent has the best success rate without overly altering the original graph."
        },
        {
            "heading": "7 ETHICAL IMPLICATIONS",
            "text": "As highlighted in the motivation for this work, community membership hiding algorithms can serve as valuable tools for safeguarding the privacy of social network users. Furthermore, these methods can be used to protect individuals at risk, including journalists or opposition activists, in regions governed by authoritarian regimes.\nAdditionally, these techniques can combat online criminal activities by modifying network connections to infiltrate espionage agents or disrupt communications among malicious users.\nHowever, node-hiding techniques can also be exploited to pursue harmful goals. For instance, malicious individuals can strategically employ these methods to evade network analysis tools, often used by law enforcement agencies for public safety, enabling them to mask their illicit or criminal activities on the network."
        },
        {
            "heading": "8 CONCLUSION AND FUTUREWORK",
            "text": "This paper tackled the challenge of community membership hiding, which entails strategically modifying the structural characteristics of a network graph to prevent specific nodes from being detected by a community detection algorithm. To address this problem, we formulated it as a constrained counterfactual graph objective and employed deep reinforcement learning for its solution. We conducted extensive experiments to validate our method\u2019s effectiveness in two distinct tasks: node and community deception. Results demonstrated that our approach strikes the best balance between achieving the deception goal and the required cost of graph modifications compared to existing baselines in both tasks.\nIn future work, we intend to apply our method to larger-scale graphs and integrate node feature modifications alongside graph structural alterations."
        }
    ],
    "title": "Community Membership Hiding as Counterfactual Graph Search via Deep Reinforcement Learning",
    "year": 2023
}