{
    "abstractText": "The automotive industry has recently emphasized reducing the number of Electronic Control Units (ECUs) installed in vehicles for economic and ecological reasons. This reduction means that the design and verification must be independent of the vehicle\u2019s final choice of (MC)SoCs, knowing they will evolve as time passes. To that end, dataflow Models of Computation and Communication (MoCCs) are powerful tools for maintaining this independence. A subclass of dataflow MoCCs \u2013deterministic dataflow MoCCs\u2013 is of particular interest since it allows designers to derive safety and security properties at compile-time. This work proposes a short survey of the existing deterministic dataflow MoCCs. We describe the properties of each dataflow MoCC and present an expressiveness hierarchy of dataflow MoCCs adjustable to designers\u2019 needs.",
    "authors": [
        {
            "affiliations": [],
            "name": "Guillaume Roumage"
        },
        {
            "affiliations": [],
            "name": "Selma Azaiez"
        },
        {
            "affiliations": [],
            "name": "Stephane Louise"
        },
        {
            "affiliations": [],
            "name": "St\u00e9phane Louise"
        }
    ],
    "id": "SP:de2b79d48292ab9c6bee414bc3cf10c5ff2805af",
    "references": [
        {
            "authors": [
                "J. Dennis"
            ],
            "title": "First version of a data flow procedure language",
            "venue": "Programming Symposium, vol. 19, 1974, pp. 362\u2013376.",
            "year": 1974
        },
        {
            "authors": [
                "E. Lee",
                "D. Messerschmitt"
            ],
            "title": "Synchronous data flow",
            "venue": "Proceedings of the IEEE, vol. 75, pp. 1235\u20131245, 1987.",
            "year": 1987
        },
        {
            "authors": [
                "\u2014\u2014"
            ],
            "title": "Static Scheduling of Synchronous Data Flow Programs for Digital Signal Processing",
            "venue": "IEEE Trans. Comput., vol. 36, pp. 24\u201335, 1987.",
            "year": 1987
        },
        {
            "authors": [
                "P. Murthy",
                "S. Battacharyya"
            ],
            "title": "Shared memory implementations of synchronous dataflow specifications",
            "venue": "Proceedings Design, Automation and Test in Europe Conference and Exhibition 2000 (Cat. No. PR00537), 2000, pp. 404\u2013410.",
            "year": 2000
        },
        {
            "authors": [
                "S. Stuijk",
                "M. Geilen",
                "T. Basten"
            ],
            "title": "Exploring trade-offs in buffer requirements and throughput constraints for synchronous dataflow graphs",
            "venue": "Proceedings of the 43rd Design Automation Conference, 2006, pp. 899\u2013904.",
            "year": 2006
        },
        {
            "authors": [
                "M. Ad\u00e9",
                "R. Lauwereins",
                "J. Peperstraete"
            ],
            "title": "Data Memory Minimisation for Synchronous Data Flow Graphs Emulated on DSP-FPGA Targets",
            "venue": "Proceedings - Design Automation Conference, 1997, pp. 64\u201369.",
            "year": 1997
        },
        {
            "authors": [
                "M. Geilen",
                "T. Basten",
                "S. Stuijk"
            ],
            "title": "Minimising Buffer Requirements of Synchronous Dataflow Graphs with Model Checking",
            "venue": "Proceedings of the 42nd Annual Conference on Design Automation - DAC \u201905, 2005, pp. 819\u2013824.",
            "year": 2005
        },
        {
            "authors": [
                "R. Govindarajan",
                "G. Gao",
                "P. Desai"
            ],
            "title": "Minimizing Buffer Requirements under Rate-Optimal Schedule in Regular Dataflow Networks",
            "venue": "Journal of VLSI Signal Processing, vol. 31, pp. 207\u2013229, 2002.",
            "year": 2002
        },
        {
            "authors": [
                "A. Ghamarian",
                "S. Stuijk",
                "T. Basten",
                "M. Geilen",
                "B. Theelen"
            ],
            "title": "Latency Minimization for Synchronous Data Flow Graphs",
            "venue": "10th Euromicro Conference on Digital System Design Architectures, Methods and Tools. IEEE, 2007, pp. 189\u2013196.",
            "year": 2007
        },
        {
            "authors": [
                "S. Ritz",
                "M. Pankert",
                "H. Meyr"
            ],
            "title": "High level software synthesis for signal processing systems",
            "venue": "Proceedings of the International Conference on Application Specific Array Processors, 1992, pp. 679\u2013 693.",
            "year": 1992
        },
        {
            "authors": [
                "G. Kuiper",
                "M. Bekooij"
            ],
            "title": "Latency analysis of homogeneous synchronous dataflow graphs using timed automata",
            "venue": "Design, Automation & Test in Europe Conference & Exhibition, 2017, 2017, pp. 902\u2013905.",
            "year": 2017
        },
        {
            "authors": [
                "M. Pankert",
                "O. Mauss",
                "S. Ritz",
                "H. Meyr"
            ],
            "title": "Dynamic data flow and control flow in high level DSP code synthesis",
            "venue": "Proceedings of ICASSP \u201994. IEEE International Conference on Acoustics, Speech and Signal Processing, vol. ii, 1994, pp. II/449\u2013II/452.",
            "year": 1994
        },
        {
            "authors": [
                "R. Karp",
                "R. Miller"
            ],
            "title": "Properties of a Model for Parallel Computations: Determinacy, Termination, Queueing",
            "venue": "SIAM J. Appl. Math., vol. 14, pp. 1390\u20131411, 1966.",
            "year": 1966
        },
        {
            "authors": [
                "P. Fradet",
                "A. Girault",
                "P. Poplavko"
            ],
            "title": "SPDF: A schedulable parametric data-flow MoC",
            "venue": "Design, Automation & Test in Europe Conference & Exhibition (DATE), 2012, pp. 769\u2013774.",
            "year": 2012
        },
        {
            "authors": [
                "P. Murthy",
                "E. Lee"
            ],
            "title": "Multidimensional synchronous dataflow",
            "venue": "IEEE Transactions on Signal Processing, vol. 50, pp. 2064\u20132079, 2002.",
            "year": 2002
        },
        {
            "authors": [
                "J. Keinert",
                "C. Haubelt",
                "J. Teich"
            ],
            "title": "Modeling and Analysis of Windowed Synchronous Algorithms",
            "venue": "2006 IEEE International Conference on Acoustics Speed and Signal Processing Proceedings, vol. 3, 2006, pp. III\u2013892\u2013III\u2013895.",
            "year": 2006
        },
        {
            "authors": [
                "J. Piat",
                "S. Bhattacharyya",
                "M. Raulet"
            ],
            "title": "Interface-based hierarchy for synchronous data-flow graphs",
            "venue": "IEEE Workshop on Signal Processing Systems, SiPS: Design and Implementation, 2009, pp. 145\u2013150.",
            "year": 2009
        },
        {
            "authors": [
                "J. Teich",
                "S.S. Bhattacharyya"
            ],
            "title": "Analysis of Dataflow Programs with Interval-limited Data-rates",
            "venue": "Journal of VLSI signal processing systems for signal, image and video technology, vol. 43, pp. 247\u2013258, 2006.",
            "year": 2006
        },
        {
            "authors": [
                "G. Bilsen",
                "M. Engels",
                "R. Lauwereins",
                "J. Peperstraete"
            ],
            "title": "Cyclo-static dataflow",
            "venue": "IEEE Transactions on Signal Processing, vol. 44, pp. 397\u2013 408, 1996.",
            "year": 1996
        },
        {
            "authors": [
                "S. Stuijk",
                "M. Geilen",
                "T. Basten"
            ],
            "title": "Throughput-Buffering Trade-Off Exploration for Cyclo-Static and Synchronous Dataflow Graphs",
            "venue": "IEEE Trans. Comput., vol. 57, pp. 1331\u20131345, 2008.",
            "year": 2008
        },
        {
            "authors": [
                "P. Koek",
                "S. Geuns",
                "J. Hausmans",
                "H. Corporaal",
                "M. Bekooij"
            ],
            "title": "CSDFa: A Model for Exploiting the Trade-Off between Data and Pipeline Parallelism",
            "venue": "Proceedings of the 19th International Workshop on Software and Compilers for Embedded Systems, 2016, pp. 30\u201339.",
            "year": 2016
        },
        {
            "authors": [
                "P. Wauters",
                "M. Engels",
                "R. Lauwereins",
                "J. Peperstraete"
            ],
            "title": "Cyclodynamic dataflow",
            "venue": "Proceedings of 4th Euromicro Workshop on Parallel and Distributed Processing, 1996, pp. 319\u2013326.",
            "year": 1996
        },
        {
            "authors": [
                "W. Thies",
                "J. Lin",
                "S. Amarasinghe"
            ],
            "title": "Phased Computation Graphs in the Polyhedral Model",
            "venue": "MIT Laboratory for Computer Science, Technical Report, 2002.",
            "year": 2002
        },
        {
            "authors": [
                "B. Bodin",
                "Y. Lesparre",
                "J.-M. Delosme",
                "A. Munier-Kordon"
            ],
            "title": "Fast and efficient dataflow graph generation",
            "venue": "Proceedings of the 17th International Workshop on Software and Compilers for Embedded Systems, 2014, pp. 40\u201349.",
            "year": 2014
        },
        {
            "authors": [
                "H. Oh",
                "S. Ha"
            ],
            "title": "Fractional Rate Dataflow Model for Efficient Code Synthesis",
            "venue": "Journal of VLSI signal processing systems for signal, image and video technology, vol. 37, pp. 41\u201351, 2004.",
            "year": 2004
        },
        {
            "authors": [
                "M.H. Wiggers",
                "M.J.G. Bekooij",
                "G.J.M. Smit"
            ],
            "title": "Buffer capacity computation for throughput-constrained modal task graphs",
            "venue": "ACM Transactions on Embedded Computing Systems, vol. 10, pp. 1\u201359, 2010.",
            "year": 2010
        },
        {
            "authors": [
                "X. Khanh Do",
                "S. Louise",
                "A. Cohen"
            ],
            "title": "Transaction Parameterized Dataflow: A Model for Context-Dependent Streaming Applications",
            "venue": "Design, Automation & Test in Europe Conference & Exhibition, 2016, pp. 960\u2013965.",
            "year": 2016
        },
        {
            "authors": [
                "P. Dubrulle",
                "C. Gaston",
                "N. Kosmatov",
                "A. Lapitre",
                "S. Louise"
            ],
            "title": "A Data Flow Model with Frequency Arithmetic",
            "venue": "Fundamental Approaches to Software Engineering, vol. 11424, 2019, pp. 369\u2013385.",
            "year": 2019
        },
        {
            "authors": [
                "P. Dubrulle",
                "C. Gaston",
                "N. Kosmatov",
                "A. Lapitre"
            ],
            "title": "Dynamic Reconfigurations in Frequency Constrained Data Flow",
            "venue": "Integrated Formal Methods, vol. 11918, 2019, pp. 175\u2013193.",
            "year": 2019
        },
        {
            "authors": [
                "J. Buck",
                "E. Lee"
            ],
            "title": "Scheduling dynamic dataflow graphs with bounded memory using the token flow model",
            "venue": "IEEE International Conference on Acoustics Speech and Signal Processing, 1993, pp. 429\u2013432 vol.1.",
            "year": 1993
        },
        {
            "authors": [
                "J. Buck"
            ],
            "title": "Static scheduling and code generation from dynamic dataflow graphs with integer-valued control streams",
            "venue": "Proceedings of 1994 28th Asilomar Conference on Signals, Systems and Computers, vol. 1, 1994, pp. 508\u2013513.",
            "year": 1994
        },
        {
            "authors": [
                "V. Bebelis",
                "P. Fradet",
                "A. Girault",
                "B. Lavigueur"
            ],
            "title": "BPDF: A statically analyzable dataflow model with integer and boolean parameters",
            "venue": "2013 Proceedings of the International Conference on Embedded Software (EMSOFT), 2013, pp. 1\u201310.",
            "year": 2013
        },
        {
            "authors": [
                "B. Theelen",
                "M. Geilen",
                "T. Basten",
                "J. Voeten",
                "S. Gheorghita",
                "S. Stuijk"
            ],
            "title": "A scenario-aware data flow model for combined long-run average and worst-case performance analysis",
            "venue": "IEEE International Conference on Formal and Models for Co-Design, 2006, pp. 185\u2013194.",
            "year": 2006
        },
        {
            "authors": [
                "S. Stuijk",
                "M. Geilen",
                "B. Theelen",
                "T. Basten"
            ],
            "title": "Scenario-aware dataflow: Modeling, analysis and implementation of dynamic applications",
            "venue": "International Conference on Embedded Computer Systems: Architectures, Modeling, and Simulation, 2011, pp. 404\u2013411.",
            "year": 2011
        },
        {
            "authors": [
                "M. Skelin",
                "M. Geilen",
                "F. Catthoor",
                "S. Hendseth"
            ],
            "title": "Parameterized Dataflow Scenarios",
            "venue": "IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 36, pp. 669\u2013682, 2017.",
            "year": 2017
        },
        {
            "authors": [
                "W. Plishker",
                "N. Sane",
                "M. Kiemb",
                "S. Bhattacharyya"
            ],
            "title": "Heterogeneous Design in Functional DIF",
            "venue": "International Conference on Embedded Computer Systems: Architectures, MOdeling and Simulation, vol. 5114, 2008, pp. 157\u2013166.",
            "year": 2008
        },
        {
            "authors": [
                "S. Lin",
                "L.-H. Wang",
                "A. Vosoughi",
                "J.R. Cavallaro",
                "M. Juntti",
                "J. Boutellier",
                "O. Silv\u00e9n",
                "M. Valkama",
                "S.S. Bhattacharyya"
            ],
            "title": "Parameterized Sets of Dataflow Modes And Their Application to Implementation of Cognitive Radio Systems",
            "venue": "Journal of Signal Processing Systems, vol. 80, pp. 3\u2013 18, 2015.",
            "year": 2015
        },
        {
            "authors": [
                "L.-H. Wang",
                "C.-C. Shen",
                "S.S. Bhattacharyya"
            ],
            "title": "Parameterized core functional dataflow graphs and their application to design and implementation of wireless communication systems",
            "venue": "SiPS 2013 Proceedings, 2013, pp. 1\u20136.",
            "year": 2013
        },
        {
            "authors": [
                "K. Sudusinghe",
                "S. Won",
                "M. van der Schaar",
                "S. Bhattacharyya"
            ],
            "title": "A novel framework for design and implementation of adaptive stream mining systems",
            "venue": "2013 IEEE International Conference on Multimedia and Expo (ICME), 2013, pp. 1\u20136.",
            "year": 2013
        },
        {
            "authors": [
                "Chanik Park",
                "Jaewoong Chung",
                "Soonhoi Ha"
            ],
            "title": "Extended synchronous dataflow for efficient DSP system prototyping",
            "venue": "Proceedings Tenth IEEE International Workshop on Rapid System Prototyping, 1999, pp. 196\u2013201.",
            "year": 1999
        },
        {
            "authors": [
                "A. Girault",
                "Bilung Lee",
                "E. Lee"
            ],
            "title": "Hierarchical finite state machines with multiple concurrency models",
            "venue": "IEEE Transactions on Computer- Aided Design of Integrated Circuits and Systems, vol. 18, pp. 742\u2013760, 1999.",
            "year": 1999
        },
        {
            "authors": [
                "M.H. Wiggers",
                "M.J. Bekooij",
                "G.J. Smit"
            ],
            "title": "Buffer Capacity Computation for Throughput Constrained Streaming Applications with Data-Dependent Inter-Task Communication",
            "venue": "2008 IEEE Real-Time and Embedded Technology and Applications Symposium, 2008, pp. 183\u2013 194.",
            "year": 2008
        },
        {
            "authors": [
                "P.O. Meredith",
                "D. Jin",
                "D. Griffith",
                "F. Chen",
                "G. Rosu"
            ],
            "title": "An overview of the MOP runtime verification framework",
            "venue": "International Journal on Software Tools for Technology Transfer, vol. 14, pp. 249\u2013289, 2012.",
            "year": 2012
        },
        {
            "authors": [
                "G. Kahn"
            ],
            "title": "The Semantics of a Simple Language for Parallel Programming",
            "venue": "Information Processing, Proceedings of the 6th IFIP Congress 1974. North-Holland, 1974, pp. 471\u2013475.",
            "year": 1974
        },
        {
            "authors": [
                "M. Geilen",
                "T. Basten"
            ],
            "title": "Reactive process networks",
            "venue": "Proceedings of the Fourth ACM International Conference on Embedded Software - EMSOFT \u201904, 2004, p. 137.",
            "year": 2004
        },
        {
            "authors": [
                "B. Bhattacharya",
                "S. Bhattacharyya"
            ],
            "title": "Parameterized dataflow modeling for DSP systems",
            "venue": "IEEE Transactions on Signal Processing, vol. 49, pp. 2408\u20132421, 2001.",
            "year": 2001
        },
        {
            "authors": [
                "Mainak Sen",
                "S. Bhattacharyya",
                "T. Lv",
                "W. Wolf"
            ],
            "title": "Modeling Image Processing Systems with Homogeneous Parameterized Dataflow Graphs",
            "venue": "International Conference on Acoustics, Speech, and Signal Processing, 2005, pp. 133\u2013136.",
            "year": 2005
        },
        {
            "authors": [
                "K. Desnos",
                "M. Pelcat",
                "J.-F. Nezan",
                "S. Bhattacharyya",
                "S. Aridhi"
            ],
            "title": "PiMM: Parameterized and Interfaced dataflow Meta-Model for MP- SoCs runtime reconfiguration",
            "venue": "Conference on Embedded Computer Systems: Architectures, Modeling, and Simulation, 2013, pp. 41\u201348.",
            "year": 2013
        },
        {
            "authors": [
                "P. Fradet",
                "A. Girault",
                "R. Krishnaswamy",
                "X. Nicollin",
                "A. Shafiei"
            ],
            "title": "RDF: Reconfigurable Dataflow",
            "venue": "2019 Design, Automation & Test in Europe Conference & Exhibition (DATE), 2019, pp. 1709\u20131714.",
            "year": 2019
        },
        {
            "authors": [
                "F. Arrestier",
                "K. Desnos",
                "M. Pelcat",
                "J. Heulot",
                "E. Juarez",
                "D. Menard"
            ],
            "title": "Delays and states in dataflow models of computation",
            "venue": "Proceedings of the 18th International Conference on Embedded Computer Systems: Architectures, Modeling, and Simulation, 2018, pp. 47\u201354.",
            "year": 2018
        }
    ],
    "sections": [
        {
            "text": "Index Terms\u2014MoCC, CPS design, dataflow graph, survey\nI. INTRODUCTION\nThe current trend in automotive, avionics, and aeronautics embedded systems is to accelerate the transition from several dozen or hundreds of Electronic Control Units (ECUs) to a few Multi -and Many- core SoCs (MC-SoCs). ECUs are simple and generally low-profile processors and Systems-on-Chip (SoC). MC-SoCs provide a software-dominated integration of functions and are usually partially redundant for safety. A transition is also occurring for communication systems in the automotive industry. The constraints in data communications (e.g., several high-resolution cameras, radars, even lidars) have led to the evolution of the old-fashioned CAN bus to Ethernet and PCI buses. Several factors have driven this evolution, such as new functionalities (e.g., ADAS \u2013Advanced Driver Assistance System\u2013 or semi-autonomous vehicles), low-cost high-profile MC-SoCs available on mass-market smartphones, and a higher conscience of the ecological impact of embedded electronics. The current supply chain crisis in electronics has also contributed to this evolution.\nEmbedded systems are now referred to as Cyber-Physical System (CPS). Mathematically sound methods enable an agile and versatile evolution of CPS design without compromising safety, security, and cost (particularly concerning timeconstrained CPSs). A mathematically grounded approach to CPS design allows a system to be adapted to a new line of MCSoC components without re-qualifying the whole software architecture. A mathematical software architecture model is sometimes called a Model of Computation and Communication (MoCC). MoCCs rank from \u201csimple\u201d ones, e.g., the Von Neumann model, to higher-level models on which we focus in this paper.\nCPSs must fulfill various constraints such as scheduling order, latency, throughput, memory footprint, and deadline. Some dataflow (DF) Models of Computation and Communication (dataflow MoCCs/DF MoCCs) ensure the satisfiability of those constraints at compile-time if no run-time fault occurs. A MoCC applied to a CPS functions as a set of rules that defines the behavior of the CPS\u2019s entities, individually and collectively. This work surveys many DF MoCCs in the literature. Each DF MoCC provides different degrees of freedom to abstract a real-life system.\nThe paper is organized as follows: section II presents the benefits of designing a CPS with a subclass of DF MoCCs, the deterministic DF MoCCs. Section III presents the standard foundations of all DF MoCCs. We refine those foundations and submit a short survey in section IV. Throughout this survey, DF MoCCs are described according to features, which are elements that describe the system\u2019s behavior and functioning. In section V, we evaluate those features resulting in an expressiveness hierarchy. We conclude the paper in section VI."
        },
        {
            "heading": "II. DETERMINISTIC DATAFLOW MOCC-BASED SYSTEM DESIGN",
            "text": "Deterministic DF MoCCs is an interesting subclass of DF MoCCs. Static analyses and safety properties of a CPS can be derived through the prism of such MoCCs. They allow designers to ensure critical safety criteria of an embedded system at compile-time. Deterministic DF MoCCs permit the prediction of the run-time system\u2019s behavior, static sizing of data buffers, communication channels process, some scheduling aspects, and proof of the system\u2019s correctness.\nThe need to closely model various real-life systems has led to the development of many DF MoCCs. A trade-off must be found between three aspects that characterize a MoCC:\n\u2022 The expressiveness and compactness define which system can be modeled and how cumbersome the model can be. \u2022 The implementation efficiency is influenced by the code size or the complexity of the run-time scheduling issues. \u2022 The analyzability is the ability to derive safety and security properties from the model."
        },
        {
            "heading": "III. SHARED BACKGROUND FOR DATAFLOW MOCCS",
            "text": "The wide variety of DF MoCCs shares the same background, as they all represent CPSs with a directed graph called the Dataflow Graph (DFG). The DFG models the CPS, and the\nDF MoCC interprets the behavior of the CPS through the DFG. The nodes of a DFG are actors that perform computations, and the arcs are channels through which the actors at both endpoints communicate by exchanging data tokens. A token is the atomic data object. The internal functioning of the actors is usually a black box."
        },
        {
            "heading": "A. Formal definition of the Dataflow Graph",
            "text": "An actor a is a tuple (Ia, Oa) with Ia (resp. Oa) the set of input (resp. output) ports \u2013possibly empty\u2013 of a such that Ia \u2229Oa = \u2205. A channel c is a tuple (ap, ac, prod, cons, init) that connects an output port of a producer actor ap to an input port of a consumer actor ac. A DFG denoted G is a tuple (A,C) where A is a set of actors, and C is a set of channels such that G is not the union of disjoint graphs.\nActors of DFGs usually share standard rules as follows. Let us consider a channel c that connects a producer actor to a consumer actor. Whenever the producer (resp. consumer) fires (i.e., is invoked), it writes (resp. reads) an amount of prod (resp. cons) tokens to (resp. from) the buffer of c that usually has a bounded FIFO structure. An actor fires by executing an execution function. Some initial tokens init might be in the buffer before any fire. An actor is enabled to fire if a set of firing rules is fulfilled. A necessary condition (but not always sufficient) for an actor to be enabled is a sufficient number of tokens in its input channels (i.e., more significant than the consumption rate). The actor\u2019s firing is an atomic process unless Best/Worst-Case Execution (BCET/WCET) Time are provided."
        },
        {
            "heading": "B. Static analyses of the Dataflow Graph",
            "text": "Deterministic DF MoCCs allow designers to derive static analyses of a CPS. The consistency and liveness analysis are arguably the most important. Consistency asserts that a CPS can run indefinitely in finite memory (prevent channel overflow), and liveness asserts that a CPS does not deadlock (prevent channel underflow). Valid consistency and liveness analysis imply that a schedule (i.e., a partial ordering of actors\u2019 firing) can be built at compile-time. Table I summarizes the properties that define the static analyzability of a CPS.\nA static DFG is represented with its topology matrix \u0393 where \u03b3ij is the rate of actor j on the channel i, positive\nif it represents a production of data tokens and negative otherwise. Other entries are null, and the self-loop channels are not written. The topology matrix is crucial for analyzing a DFG through algebraic manipulations. The following matrix represents the topology of the DFG in Fig. 1:\n\u0393G = A B C D E \na 0 \u2212c 0 0 c1 = (A,C) 1 \u2212b 0 0 0 c2 = (A,B) 0 1 \u22121 0 0 c3 = (B,C) 0 0 1 \u22121 0 c4 = (C,D) 0 0 0 d \u22121 c6 = (D,E)\nThe consistency is equivalent to the boundedness when the underlying DF MoCC that interprets the DFG has no parametric rates. Consistency and boundedness are two interpretations of whether a DFG executes in bounded memory. An iteration of a DFG is a set of actors\u2019 fires that keep the distribution token unchanged. The repetition vector of a DFG is the column vector that associates the number of times each actor fires within a single iteration. A DFG is bounded if an iteration needs a finite amount of memory, and a DFG is consistent if a non-trivial repetition vector exists (i.e., \u0393G has a non-trivial kernel). BCET and WCET enable the computation of more refined analyses, such as end-to-end latency or throughput."
        },
        {
            "heading": "C. Timing constraints and Dataflow Graph",
            "text": "The main distinctive property of CPS is timeliness and enforcing time constraints. This property is especially true when individual real-time tasks have periodic behaviors, which is a usual case. Typically, the period and the phase shift of each task/actor would be part of the specifications and initial design because they are rooted in physical and hardware constraints (e.g., maximum speed, inertia, camera frame rate, lidar, and radar output rates, ADC frequencies, servomotors or stepper motors sampling, etc.). All the frequencies rarely match. Even if they would, as sources are different, a small amount of clock drift should be expected and allowed to have a robust system. In practice, data-fusion between captors before calculating decisions for actuators needs to accommodate the\ndiscrepancy between clock rates in some way. Thus, for such applications, a mechanism is required for sub-sampling some channels in data-fusion actors. In practice, such sub-sampling can be modeled by periodically changing rates (e.g., CSDF, section IV-B) or rational rates (e.g., PolyGraph, section IV-C).\nA typical excerpt of an ADAS application is shown in Fig. 2. It presents several captors with their own clocks and two actuators (Speed control and Information Display). Speed Control is a fusion actor with several input channels. Thus, some sub-sampling is required either at its input channel or upstream."
        },
        {
            "heading": "D. Features of deterministic dataflow MoCCs",
            "text": "The DFG is the basic brick of systems modeled with a dataflow perspective. A DF MoCC interprets the system behavior through its DFG. Each DF MoCC emphasizes a set of elements called features. A feature is an element that describes the system\u2019s behavior and functioning. The proposed survey evaluates the static analyzability (defined in table I) and the features (defined in table II) of the main DF MoCCs."
        },
        {
            "heading": "IV. CLASSIFICATION OF DATAFLOW MOCCS",
            "text": "We propose to classify the main DF MoCCs into nine categories as follows: the Synchronous Dataflow and its extensions (section IV-A and table III), the Phase-based DF MoCCs (section IV-B and table IV), the DF MoCCs with timing constraints (section IV-C and table V), the Boolean-based DF MoCCs (Section IV-D and table VI), the Scenario-based DF MoCCs (section IV-E and table VII), the DF MoCCs with Enable and Invoke capabilities (section IV-F and table VIII), the DF MoCCs with unique features (section IV-G and table IX), the process network-based dataflow MoCCs (section IV-H and table X) and the meta-models for DF MoCCs (section IV-I and table XI)."
        },
        {
            "heading": "A. Synchronous Dataflow and its extension",
            "text": "1) SDF: The principles of dataflow models first appeared in [1]. However, the analyzability of that first model is limited,\nand Synchronous Dataflow ([2]) has laid the foundations of the dataflow paradigm we use today. SDF models a CPS with a DFG where the rates belong to N\u2217. Reference [3] provides consistency and liveness checking.\nDespite its low expressiveness, SDF and its variants have been extensively studied because they can model many applications. Besides, researchers have created implementations of SDF. Thus, many works have previously researched memory consumption but with notably distinct techniques. For example, a shared buffer memory model is studied in [4]. A tradeoff between buffer requirements and throughput constraints with a non-shared buffer model is explored in [5]. The authors of [6] provide arithmetic manipulations to compute minimum buffers size that yield a deadlock-free schedule. The authors of [7] chose a model-checking approach. In [8], a linear programming formulation computes the buffer size with optimal throughput without degrading storage constraints.\nThe latency is an important performance indicator explored in [9]. Regarding implementation efficiency, Scalable Synchronous Dataflow (SSDF, [10]) is a specific SDF implementation that minimizes code size and context-switch overhead.\n2) HSDF: The restriction of rates\u2019 values of SDF to {1} yields Homogeneous Synchronous Dataflow (HSDF, [2]). Many static analyses of SDF apply to HSDF.\n3) HSDFa: Homogeneous Synchronous Dataflow with auto-concurrency (HSDFa, [11]) determines the consumption order of tokens with static indices independently of the pro-\nduction order, dismissing the channels\u2019 FIFO policy. HSDFa provides an end-to-end latency using a timed automata model. 4) BDDF: Bounded Dynamic Dataflow (BDDF, [12]) extends SSDF by allowing a set of actors to have dynamic and upper-bounded ports. The topology of the network might change at run-time. A Finite State Machine (FSM) models topology updates. Each state defines a set of connected actors.\n5) CG: The Computation Graphs (CGs, [13]) are more general than SDF. The CGs associate a consumption threshold with each channel of the DFG. Thus, an actor can fire if the number of tokens in its input channel is more significant than that threshold. The authors of [13] develop properties that structure the determinism of the CG and provide a set of conditions that deadlock a CG.\n6) SPDF: Schedulable Parametric Dataflow (SPDF, [14]) is a parametric extension of SDF. The parameters range in N\u2217 and are communicated through a dedicated network inserted at the top of the DFG. The parameters are allowed to change within an iteration. SPDF can statically analyze a DFG concerning boundedness and liveness and computes a quasi-static schedule (i.e., a schedule made at compile-time that depends on parameter values known at run-time).\n7) MDSDF: Multi-Dimensional Synchronous Dataflow (MDSDF, [15]) specifies the number of tokens produced/consumed as a multi-dimensional lattice. Thus, MDSDF is suitable to model signal processing applications (e.g., image processing). MDSDF can schedule a DFG at compile-time. Reference [15] gives a method to compute the repetition matrix (i.e., the repetition vector with many dimensions) and conditions to ensure deadlock-freeness.\n8) WSDF: Windowed Synchronous Dataflow (WSDF, [16]) extends MDSDF by allowing token consumption with sliding windows. A token is consumed with a specific sampling pattern through a set of windows of predefined size. WSDF provides a boundedness checking.\n9) IBSDF: Interface-Based Synchronous Dataflow (IBSDF, [17]) is a hierarchical extension of SDF. A source and sink node surround the DFG. They both behave as an interface to the environment. Each level of the hierarchy is analyzable.\n10) ILDF: Interval-rate, Locally-static Dataflow (ILDF, [18]) models DFG\u2019s rates as a finite natural integers interval and fixes the value at the beginning of the execution. ILDF statically analyzes the DFG regarding consistency, buffer sizing, and latency, assuming a valid schedule is possible."
        },
        {
            "heading": "B. Phase-based dataflow MoCCs",
            "text": "1) CSDF: Cyclo-Static Dataflow (CSDF, [19]) models actors\u2019 execution function, production, and consumption rates as cyclic patterns defined at compile-time. The value changes periodically following that cycle. An element of such a cycle is a phase. The rates take their values in N. Thus, some channels may be disabled for a few phases. CSDF provides consistency and liveness checkings using a conversion algorithm from CSDF to HSDF. The authors of [20] provide a trade-off between throughput and buffer size for the CSDF.\n2) CSDFa: Cyclo-Static Dataflow with Auto-concurrency (CSDFa, [21]) allows the auto-concurrency in CSDF with a static token order; as in HSDFa, the channels consequently no longer have a FIFO policy. The authors provide a buffer sizing computation. A set of mechanisms maintain the overhead independent of the replication factor (i.e., the number of simultaneous execution of an actor), e.g., predefined buffer\u2019s accesses pattern for read/write operations.\n3) CDDF: Cyclo-Dynamic Dataflow (CDDF, [22]) is a dynamic version of CSDF. The execution function, token ratios, and firing sequence length can vary at run-time. The needed information of a previous actor execution for subsequent ones must be conveyed through a self-edge: a control token containing all firings information is read at each fire, including the code segment executed by the actor. Thus, CDDF has the feature \u201cmultiple execution modes\u201d. The data-dependent behavior of CDDF limits the static analyzability and implies run-time scheduling depending on the control token values.\n4) PCG: The Phased Computation Graphs (PCGs, [23]) extend CSDF with consumption thresholds. The rates of PCGs are divided into initial and steady sequences. The initial sequence is performed at the beginning of the execution. The steady sequence, which is cyclic, takes over for the rest of the execution. The authors of [24] create a PCG generator and provide consistency and liveness checking and a lower bound for buffer sizing.\n5) FRDF: Fractional Rate Dataflow (FRDF, [25]) is the first DF MoCC with rational rates. The semantic of rational rates is the following. An actor produces/consumes either a fraction pq of a token every firing or p tokens every q firings. In contrast with other DF MoCCs studied in this paper, FRDF does not have initial tokens and cannot derive a rate into a unique sequence of firings. Thus, the same rate may imply multiple production/execution patterns of data tokens. Therefore, rates may vary within iterations.\n6) VPDF: Variable-rate Phased Dataflow (VPDF, [26]) extends VRDF, described further in section IV-G. VPDF inherits the structural constraints of VRDF, e.g., every parameter defines a single phase of a single actor. Actors\u2019 phases have two parameters: the number of repetitions and the rate of that phase. VPDF provides a buffer capacity computation for a throughput-constrained DFG."
        },
        {
            "heading": "C. Dataflow MoCCs with timing constraints",
            "text": "1) TPDF: Transaction Parameterized Dataflow (TPDF, [27]) variously extends CSDF. Rates can be parametric. TPDF has a select-duplicate and a transaction actor. Select-duplicate actor replicates its single entry into any combinations of its outputs, and the transaction actor is the symmetric process. Besides, TPDF provides clock constraints and actors\u2019 execution modes. A clock actor sends a control token periodically to (an)other actor(s). The control token defines the execution mode of the actor which consumes that control token, e.g., waiting for all input data to be available before fires or selecting the data with the highest priority. TPDF provides consistency, liveness checking, and a scheduling strategy.\n2) PolyGraph: PolyGraph ([28]) enhances the semantic of rational rates of FRDF. A rate of pq means p tokens are produced/consumed every q firings. An actor\u2019s fire increases/decreases by pq the fractional number of tokens in the channels involved. The natural number of tokens in a channel is the fractional number of tokens rounded down. In contrast with FRDF, initials tokens permit to derive a unique firing sequence from a rational rate. An actor may have a frequency constraint and a delay. Thus, it must fire at that frequency, and its first fire occurs after the delay.\nReference [29] present a dynamic extension of PolyGraph. Actors of dynamic Polygraph label tokens with a mode. The mode of tokens consumed by an actor defines its behavior, e.g., modifying the algorithm that processes the tokens. PolyGraph and dynamic Polygraph both have a high expressiveness and are analyzable regarding consistency and liveness."
        },
        {
            "heading": "D. Boolean-based dataflow MoCCs",
            "text": "1) BDF and IDF: Boolean-controlled Dataflow (BDF, [30]) is the first dataflow MoCC focusing on topological modifications. BDF provides an if-then-else structure using two actors. The switch (resp. select) actor has one (resp. two) input port(s) and two (resp. one) output port(s). A boolean control token decides which port is used. BDF is Turing complete\nand weakly analyzable. A consistency analysis based on the proportion of true tokens provides only a probabilistic analysis.\nInteger-controlled Dataflow (IDF, [31]) is a generalization of BDF where control tokens are any integer. Thus, the switch and select actors become case and end-case actors with many output/input ports. The behavior of switch/select and case/endcase actors induce the feature \u201cmultiple execution modes\u201d.\n2) BPDF: Boolean Parametric Dataflow (BPDF, [32]) combines two types of parameters. Integer parameters express dynamic rates and boolean parameters on the channel of the DFG. Those latter dynamically (des)activate the channels. BPDF provides boundedness and liveness static checking."
        },
        {
            "heading": "E. Scenario-based dataflow MoCCs",
            "text": "1) SADF and SADFT : Scenario-Aware Dataflow (SADF, [33]) models a system with a set of scenarios. A scenario is an assignation to parameterized rates. Some actors broadcast the current scenario to their followers. Scenarios are known at compile-time with a stochastic execution time distribution.\nSADF has the determinism property. The behavior of a DFG model with SADF only depends on the probabilistic choices that determine the sequence of scenarios successively detected by each detector and not on the non-deterministic choices originating from the concurrency in the model.\nSADF\u2019s scenarios can model complex control structures, including switch/select of the BDF model. Thus, SADF is Turing complete. SADF might be restricted to be non-Turing complete. In that case, SADF provides conditions for consistency, liveness, and determinism. We denote SADFT as the non-restricted version of SADF, i.e., the Turing complete version.\n2) FSM-SADF: Finite State Machine-based - ScenarioAware Dataflow (FSM-SADF, [34]) restricts SADF. A set of scenarios captures the dynamic behavior. Each scenario is modeled with SDF. An FSM specifies the order in which the scenarios occur and the rates of the current scenario. The SDF graphs, together with the FSM, model the application. In contrast with SADF, the execution time of a scenario is fixed, and the auto-concurrency is enabled. FSM-SADF provides throughput, latency, and buffer size analyses.\n3) FSM-PSADF: The Finite State Machine-based - Parameterized Scenario-Aware Dataflow (FSM-PSADF, [35]) uses parameters to improve the compactness of FSM-SADF. The scenario and the parameter configuration in that scenario are both non-deterministically chosen at the end of an iteration. FSM-PSADF develops latency and throughput analysis."
        },
        {
            "heading": "F. Dataflow MoCCs with Enable & Invoke capabilities",
            "text": "1) EIDF and CFDF: Enable-Invoke Dataflow (EIDF, [36]) endows actors with two capabilities and a set of modes. A mode defines the number of tokens consumed and produced. The enable capability asserts if an actor can fire in a given mode while the invoke capability performs a fire in that mode. The mode used for a fire is called the execution mode.\nThe invoke capability results in both the output tokens and the set of enabled modes for the subsequent firing. The Core Functional Dataflow (CFDF, [36]) behaves the same as EIDF, except that the invoke capability returns a single mode. The following mode description of EIDF is available for CFDF.\nIn contrast with PolyGraph\u2019s deciding mode procedure, EIDF\u2019s mode choice relies on a function, not token labeling. Besides, a mode in PolyGraph is finer-grained, e.g., it may influence the produced data type or the algorithm used.\nThe enable and invoke capabilities can be formulated to describe switch/select actors of BDF. Thus, EIDF and CFDF are Turing-complete. We classify enable and invoke capabilities as the \u201cmultiple execution modes\u201d feature.\n2) PSM-CFDF: Parameterized Set of Modes - Core Functional Dataflow (PSM-CFDF, [37]) is tailored for CFDF when the number of modes grows significantly. Actors have a set of parameters, and a configuration is an assignation to those parameters. Modes with related functionalities are clustered together and denoted as Parameterized Set of Modes (PSM). The active PSM and the active configuration uniquely determine the mode for the actor firing.\n3) CF-PSDF: Core Functional - Parameterized Synchronous Dataflow (CF-PSDF, [38]) is a mix between PSDF (described further in section IV-I) and CFDF. A CF-PSDF actor has a set of modes and three graphs: the ctrl graph, the subctrl graph, and the body graph. The ctrl and subctrl graphs have the same role as the init and subinit graphs of PSDF. The ctrl graph decides the execution mode and transmits the mode information to the ctrl graph of subsequent CF-PSDF actors. Two distinct actors can control a CF-PSDF actor. The first sends mode information to the ctrl graph, and the second sends data to the body graph.\n4) HCFDF: Hierarchical Core Functional Dataflow (HCFDF, [39]) views its actors as CFDF actors with a set of nested DFGs. Let H be an HCFDF actor. The nested DFGs match a subset of ports of H . A firing of H might be an invocation of a subset of the nested graphs, given that the dataflow interface defined by the mode is unchanged."
        },
        {
            "heading": "G. Dataflow MoCCs with unique features",
            "text": "1) SPBDF: Synchronous PiggyBacked Dataflow (SPBDF, [40]) provides a global state for the DFG. SPBDF provides a method for the memory requirements and consistency of the global state. In this context, consistency applies to paths of the DFG. A path is state-consistent if, for each firing of every actor on that path, consumed (resp. produced) tokens from (resp. in) the global table have the same value.\n2) HDF: Heterochronous Dataflow (HDF, [41]) studied the combination between FSM and DF MoCC. For instance, an SDF actor can be an FSM, and conversely. The authors have also studied the combination of FSM with synchronous/reactive model and discrete events models. The liveness, consistency, and schedulability are decidable at compiletime.\n3) VRDF: Variable Rate Dataflow (VRDF, [42]) is a parametric dataflow model which imposes many restrictions on parameter usage and strong structural constraint. For instance, the repetition vector solution for two actors using the same parameter must be equal. VRDF presents an algorithm for computing the required memory capacity."
        },
        {
            "heading": "H. Process network-based dataflow MoCCs",
            "text": "Actors of dataflow MoCCs we studied previously are functional. The output tokens of a firing are purely a function of the input tokens of that firing. Besides, the firing rules are sequential, i.e., they can be tested in a predefined order using only blocking reads ([43]). A sequence of actors\u2019 firings is a dataflow process, and a network of such processes is a dataflow process network.\n1) KPN: The dataflow process networks are a particular case of Kahn Process Networks (KPNs, [44]). An actor of a KPN is a process that maps one or more (possibly infinite) input sequences to one or more output sequences. In contrast with the dataflow process network, actors of a KPN may have a state.\n2) RPN: Reactive Process Networks (RPNs, [45]) is an extension of KPNs where the active configuration (i.e., the set of active processes and channels) may change at run-time. An RPN presents a static interface to the outside world that receives events and data tokens.\nKPNs and RPNs have dynamic rates, dynamic topology, and a rage rate of \u2126. Our semantic of \u2126 is any data, e.g., integer, boolean, pointer, etc. KPNs and RPNs do not have any previously studied features, and in their most general form, they are not statically analyzable."
        },
        {
            "heading": "I. Meta-models dataflow MoCCs",
            "text": "1) PSDF: Parameterized Synchronous Dataflow (PSDF, [46]) is a parametric meta-model applied to SDF. An actor is either primitive or hierarchical. A primitive actor is a PSDF subsystem composed of three graphs:\n\u2022 The init graph handles the parameters\u2019 update that affects the body graph\u2019s rates (i.e., the dataflow interface) and handles parameters\u2019 modification of the subinit graph. \u2022 The subinit graph modifies the body graph parameters that leave the dataflow interface unchanged.\n\u2022 The body graph models the actor\u2019s behavior. The reconfiguration capability of the subinit graph is more restricted than the init graph but occurs more often.\nAn actor is hierarchical if its body graph is itself a PSDF subsystem. The init graph performs modifications at the boundaries of an iteration of the PSDF subsystem to which it belongs. The subinit graph updates parameters within an iteration of its PSDF subsystem. Hence, a PSDF subsystem embedded in a hierarchical actor can change some rates of its parent subsystem within an iteration of that parent subsystem.\n2) PCSDF: The authors of [46] apply their method to CSDF and yield the Parameterized Cyclo-Static Dataflow (PCSDF). The parameterization of PCSDF is less expressive than VPDF: phases\u2019 ratios and sequence fire length are parameterized, while in VPDF, an additional parameter to each phase permits to repeat it a parametric number of times.\n3) HPDF: Homogeneous Parameterized Dataflow (HPDF, [47]) is a DF MoCC that refines a top-level actor of the DFG using any dataflow semantic with a well-defined notion of iteration (e.g., SDF, CSDF).\n4) PIMM: Parameterized and Interfaced Meta-Model (PIMM, [48]) extends the semantics of any deterministic DF MoCC. To that end, PIMM uses an interface-based hierarchy and a set of parameters. The application of PIMM to SDF yields the Parameterized and Interfaced Synchronous Dataflow (PISDF), which can be seen as an extension of IBSDF.\n5) RDF: Reconfigurable Dataflow (RDF, [49]) is a DFG with a controller that specifies how and when the DFG may be reconfigured. Graph rewrite rules are applied if specific conditions are fulfilled. RDF verifies liveness and consistency for the initial DFG configuration and all possible transformations.\n6) SAD: State-Aware Dataflow (SAD, [50]) tackles the memory persistence of initial tokens across the DFG\u2019s iterations. SAD extends the semantics of the initial tokens with an explicit initialization/discard at the start/end of each iteration."
        },
        {
            "heading": "V. EXPRESSIVENESS HIERARCHY FOR DATAFLOW MOCCS",
            "text": ""
        },
        {
            "heading": "A. Protocol to create an expressiveness hierarchy",
            "text": "The expressiveness hierarchy we propose can be seen as an extension of the DF MoCCs comparison in [34]. The protocol to create an expressiveness hierarchy is the following:\n1) Characterize each DF MoCC according to the features described in table II. 2) Assign a score for each feature, then normalize it, i.e., divide it by the maximum possible score. The normalization allows features with a maximum score above 1 to be comparable with others. 3) Classify the features by order of interest in categories and assign a coefficient to each category (a category may be reduced to a single feature). The coefficient assignation allows a designer to increase or reduce the importance of features according to its need. 4) Compute the expressiveness score for each DF MoCC by summing the normalized features\u2019 score with the correct weighting, then sort DF MoCCs with respect to their expressiveness score."
        },
        {
            "heading": "B. Features evaluation of dataflow MoCCs",
            "text": "We evaluate the range rate feature as follows. Singletons {1} have a score of 0. The score is incremented by 1 \u2013 representing an increase in expressiveness\u2013 in the following the order: {1},N\u2217,N,N\u2217 \u00d7 ...\u00d7 N\u2217,Q\u2217,\u2126.\nWe assume a DF MoCC with both dynamic rates and dynamic topology can model more systems than the union of the systems modeled by a DF MoCC with only dynamic topology and those modeled by a DF MoCC with only dynamic rate. This latter assumption is represented in table XII. For instance, we evaluate a DF MoCC with topology and rate updates between iterations with 3, not 2. All other feature is single-choice properties evaluated as 1 if present and 0 otherwise."
        },
        {
            "heading": "C. Features classification and expressiveness score",
            "text": "In future work, we want to develop a tool that provides a run-time fault mitigation capability for time-constrained CPS modeled by a DF MoCC (a typical use case is the ADAS, as shown in Fig. 2). For that purpose, we classify the features in table XIII to choose the most suitable DF MoCC. We choose coefficient 2 for crucial features, coefficient 1 for interesting features yet not mandatory, and the null coefficient for unneeded features. Fig. 3 shows the expressiveness score for the DF MoCCs studied in our survey using those coefficients.\nHSDF2 SDF, MDSDF, SPBDF, WSDF2,4\nHSDFa3 ILDF3,2\nFRDF, CG, IBSDF3,4 CSDF, HDF3,8\nSPDF4,2 BDDF4,4\nFSM-SADF4,6 CSDFa4,8 BPDF5\nFSM-PSADF5,6 PCG, VRDF, SADF5,8\nVPDF6,8 CDDF7,8\nPolyGraph10,6 TPDF10,8\nBDF, IDF3,2 SADFT5,8\nKPN, RPN6 CFDF, EIDF6,8\nHCFDF, PSM-CFDF7,8 CF-PSDF8,8\nSAD2,4 RDF3,6\nHPDF3,8 PSDF5,2\nPCSDF6,6 PISDF6,8\nFig. 3. The expressiveness hierarchy with the expressiveness score (computed with the coefficients of table XIII) shows as a subscript. The Turing complete dataflow MoCCs are on the left, the non-Turing complete ones are in the middle, and the meta-models MoCCs are on the right."
        },
        {
            "heading": "D. Discussion about the expressiveness hierarchy",
            "text": "As shown in Fig. 3, TPDF and PolyGraph are the most suitable DF MoCCs for our needs in modeling CPS: deterministic, statically schedulable, and sizable MoCCs.\nThe hierarchy methodology we propose has limits. Some features may overlap, e.g., parameters and multiple execution modes, since both may update rates. However, we focus on what features a MoCC has and not how it is modeled or implemented. The hierarchy presents the state of the art knowledge\nand straightforward claims. We assume that some MoCCs can be enhanced and thus be more expressive. However, it requires significant work and is out of this survey\u2019s scope.\nAlso, we consider auto-concurrency disabled by default since, without a dedicated mechanism, e.g., static token indices, we cannot ensure the non-overlapping of tokens because of different actors\u2019 execution times.\nThe expressiveness hierarchy is extensible. On the one hand, to introduce a new feature, the designer must define how to evaluate it and apply the preferred coefficient. On the other hand, a DF MoCC is added to the hierarchy with an evaluation according to the feature list."
        },
        {
            "heading": "VI. CONCLUSION AND FUTURE WORKS",
            "text": "This work surveys the main dataflow MoCCs, focusing on a highly interesting subclass \u2013deterministic dataflow MoCCs\u2013 since they can derive a system\u2019s static analyses and safety properties at compile-time. We classify dataflow MoCCs into nine categories with a description of the elements that make each dataflow MoCC unique, as well as their analyzability.\nWe propose a flexible and extensible expressiveness hierarchy to help system designers to choose the most suitable MoCC for their needs. The hierarchy gives a reliable intuition rather than a strict claim of expressiveness because each dataflow MoCC has unique features.\nThe validity of the properties derived from static analysis incorrectly assumes that there is never a run-time fault in the system. In future work, we want to develop a tool that performs runtime verification to ensure that static analyses made with dataflow MoCCs are valid. Thus, we could ensure consistency between dataflow application models and their implementation running on MC-SoCs. The runtime verification process would improve the system\u2019s safety and security and could be incorporated into the Quality Assurance process during CPS validations."
        }
    ],
    "title": "A survey of main dataflow MoCCs for CPS design and verification",
    "year": 2023
}